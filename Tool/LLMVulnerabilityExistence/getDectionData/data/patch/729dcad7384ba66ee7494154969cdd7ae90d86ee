{
    "keystone/assignment/backends/ldap.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 89,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "         def _get_roles_for_just_user_and_project(user_id, tenant_id):"
            },
            "2": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "             self.get_project(tenant_id)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+            user_dn = self.user._id_to_dn(user_id)"
            },
            "4": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "             return [self.role._dn_to_id(a.role_dn)"
            },
            "5": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "                     for a in self.role.get_role_assignments"
            },
            "6": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "                     (self.project._id_to_dn(tenant_id))"
            },
            "7": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if self.user._dn_to_id(a.user_dn) == user_id]"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+                    if common_ldap.is_dn_equal(a.user_dn, user_dn)]"
            },
            "9": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 97,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "         def _get_roles_for_group_and_project(group_id, project_id):"
            },
            "11": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "             self.get_project(project_id)"
            },
            "12": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 107,
                "PatchRowcode": "             return [self.role._dn_to_id(a.role_dn)"
            },
            "13": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "                     for a in self.role.get_role_assignments"
            },
            "14": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "                     (self.project._id_to_dn(project_id))"
            },
            "15": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if a.user_dn.upper() == group_dn.upper()]"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+                    if common_ldap.is_dn_equal(a.user_dn, group_dn)]"
            },
            "17": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 111,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "         if domain_id is not None:"
            },
            "19": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "             msg = _('Domain metadata not supported by LDAP')"
            }
        },
        "frontPatchFile": [
            "# Copyright 2012-2013 OpenStack Foundation",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import absolute_import",
            "",
            "import uuid",
            "",
            "import ldap as ldap",
            "import ldap.filter",
            "",
            "from keystone import assignment",
            "from keystone import clean",
            "from keystone.common import driver_hints",
            "from keystone.common import ldap as common_ldap",
            "from keystone.common import models",
            "from keystone import config",
            "from keystone import exception",
            "from keystone.identity.backends import ldap as ldap_identity",
            "from keystone.openstack.common.gettextutils import _",
            "from keystone.openstack.common import log",
            "",
            "",
            "CONF = config.CONF",
            "LOG = log.getLogger(__name__)",
            "",
            "",
            "class Assignment(assignment.Driver):",
            "    def __init__(self):",
            "        super(Assignment, self).__init__()",
            "        self.LDAP_URL = CONF.ldap.url",
            "        self.LDAP_USER = CONF.ldap.user",
            "        self.LDAP_PASSWORD = CONF.ldap.password",
            "        self.suffix = CONF.ldap.suffix",
            "",
            "        # These are the only deep dependency from assignment back",
            "        # to identity.  The assumption is that if you are using",
            "        # LDAP for assignments, you are using it for Id as well.",
            "        self.user = ldap_identity.UserApi(CONF)",
            "        self.group = ldap_identity.GroupApi(CONF)",
            "",
            "        self.project = ProjectApi(CONF)",
            "        self.role = RoleApi(CONF)",
            "",
            "    def get_project(self, tenant_id):",
            "        return self._set_default_domain(self.project.get(tenant_id))",
            "",
            "    def list_projects(self, hints):",
            "        return self._set_default_domain(self.project.get_all())",
            "",
            "    def list_projects_in_domain(self, domain_id):",
            "        # We don't support multiple domains within this driver, so ignore",
            "        # any domain specified",
            "        return self.list_projects(driver_hints.Hints())",
            "",
            "    def get_project_by_name(self, tenant_name, domain_id):",
            "        self._validate_default_domain_id(domain_id)",
            "        return self._set_default_domain(self.project.get_by_name(tenant_name))",
            "",
            "    def create_project(self, tenant_id, tenant):",
            "        self.project.check_allow_create()",
            "        tenant = self._validate_default_domain(tenant)",
            "        tenant['name'] = clean.project_name(tenant['name'])",
            "        data = tenant.copy()",
            "        if 'id' not in data or data['id'] is None:",
            "            data['id'] = str(uuid.uuid4().hex)",
            "        if 'description' in data and data['description'] in ['', None]:",
            "            data.pop('description')",
            "        return self._set_default_domain(self.project.create(data))",
            "",
            "    def update_project(self, tenant_id, tenant):",
            "        self.project.check_allow_update()",
            "        tenant = self._validate_default_domain(tenant)",
            "        if 'name' in tenant:",
            "            tenant['name'] = clean.project_name(tenant['name'])",
            "        return self._set_default_domain(self.project.update(tenant_id, tenant))",
            "",
            "    def _get_metadata(self, user_id=None, tenant_id=None,",
            "                      domain_id=None, group_id=None):",
            "",
            "        def _get_roles_for_just_user_and_project(user_id, tenant_id):",
            "            self.get_project(tenant_id)",
            "            return [self.role._dn_to_id(a.role_dn)",
            "                    for a in self.role.get_role_assignments",
            "                    (self.project._id_to_dn(tenant_id))",
            "                    if self.user._dn_to_id(a.user_dn) == user_id]",
            "",
            "        def _get_roles_for_group_and_project(group_id, project_id):",
            "            self.get_project(project_id)",
            "            group_dn = self.group._id_to_dn(group_id)",
            "            # NOTE(marcos-fermin-lobo): In Active Directory, for functions",
            "            # such as \"self.role.get_role_assignments\", it returns",
            "            # the key \"CN\" or \"OU\" in uppercase.",
            "            # The group_dn var has \"CN\" and \"OU\" in lowercase.",
            "            # For this reason, it is necessary to use the \"upper()\"",
            "            # function so both are consistent.",
            "            return [self.role._dn_to_id(a.role_dn)",
            "                    for a in self.role.get_role_assignments",
            "                    (self.project._id_to_dn(project_id))",
            "                    if a.user_dn.upper() == group_dn.upper()]",
            "",
            "        if domain_id is not None:",
            "            msg = _('Domain metadata not supported by LDAP')",
            "            raise exception.NotImplemented(message=msg)",
            "        if group_id is None and user_id is None:",
            "            return {}",
            "",
            "        if tenant_id is None:",
            "            return {}",
            "        if user_id is None:",
            "            metadata_ref = _get_roles_for_group_and_project(group_id,",
            "                                                            tenant_id)",
            "        else:",
            "            metadata_ref = _get_roles_for_just_user_and_project(user_id,",
            "                                                                tenant_id)",
            "        if not metadata_ref:",
            "            return {}",
            "        return {'roles': [self._role_to_dict(r, False) for r in metadata_ref]}",
            "",
            "    def get_role(self, role_id):",
            "        return self.role.get(role_id)",
            "",
            "    def list_roles(self, hints):",
            "        return self.role.get_all()",
            "",
            "    def list_projects_for_user(self, user_id, group_ids, hints):",
            "        # NOTE(henry-nash): The LDAP backend is being deprecated, so no",
            "        # support is provided for projects that the user has a role on solely",
            "        # by virtue of group membership.",
            "        user_dn = self.user._id_to_dn(user_id)",
            "        associations = (self.role.list_project_roles_for_user",
            "                        (user_dn, self.project.tree_dn))",
            "        # Since the LDAP backend doesn't store the domain_id in the LDAP",
            "        # records (and only supports the default domain), we fill in the",
            "        # domain_id before we return the list.",
            "        return [self._set_default_domain(x) for x in",
            "                self.project.get_user_projects(user_dn, associations)]",
            "",
            "    def get_roles_for_groups(self, group_ids, project_id=None, domain_id=None):",
            "        raise exception.NotImplemented()",
            "",
            "    def list_projects_for_groups(self, group_ids):",
            "        raise exception.NotImplemented()",
            "",
            "    def list_domains_for_groups(self, group_ids):",
            "        raise exception.NotImplemented()",
            "",
            "    def list_user_ids_for_project(self, tenant_id):",
            "        self.get_project(tenant_id)",
            "        tenant_dn = self.project._id_to_dn(tenant_id)",
            "        rolegrants = self.role.get_role_assignments(tenant_dn)",
            "        return [self.user._dn_to_id(user_dn) for user_dn in",
            "                self.project.get_user_dns(tenant_id, rolegrants)]",
            "",
            "    def _subrole_id_to_dn(self, role_id, tenant_id):",
            "        if tenant_id is None:",
            "            return self.role._id_to_dn(role_id)",
            "        else:",
            "            return '%s=%s,%s' % (self.role.id_attr,",
            "                                 ldap.dn.escape_dn_chars(role_id),",
            "                                 self.project._id_to_dn(tenant_id))",
            "",
            "    def add_role_to_user_and_project(self, user_id, tenant_id, role_id):",
            "        self.get_project(tenant_id)",
            "        self.get_role(role_id)",
            "        user_dn = self.user._id_to_dn(user_id)",
            "        role_dn = self._subrole_id_to_dn(role_id, tenant_id)",
            "        self.role.add_user(role_id, role_dn, user_dn, user_id, tenant_id)",
            "        tenant_dn = self.project._id_to_dn(tenant_id)",
            "        return UserRoleAssociation(role_dn=role_dn,",
            "                                   user_dn=user_dn,",
            "                                   tenant_dn=tenant_dn)",
            "",
            "    def _add_role_to_group_and_project(self, group_id, tenant_id, role_id):",
            "        self.get_project(tenant_id)",
            "        self.get_role(role_id)",
            "        group_dn = self.group._id_to_dn(group_id)",
            "        role_dn = self._subrole_id_to_dn(role_id, tenant_id)",
            "        self.role.add_user(role_id, role_dn, group_dn, group_id, tenant_id)",
            "        tenant_dn = self.project._id_to_dn(tenant_id)",
            "        return GroupRoleAssociation(group_dn=group_dn,",
            "                                    role_dn=role_dn,",
            "                                    tenant_dn=tenant_dn)",
            "",
            "    def create_role(self, role_id, role):",
            "        self.role.check_allow_create()",
            "        try:",
            "            self.get_role(role_id)",
            "        except exception.NotFound:",
            "            pass",
            "        else:",
            "            msg = _('Duplicate ID, %s.') % role_id",
            "            raise exception.Conflict(type='role', details=msg)",
            "",
            "        try:",
            "            self.role.get_by_name(role['name'])",
            "        except exception.NotFound:",
            "            pass",
            "        else:",
            "            msg = _('Duplicate name, %s.') % role['name']",
            "            raise exception.Conflict(type='role', details=msg)",
            "",
            "        return self.role.create(role)",
            "",
            "    def delete_role(self, role_id):",
            "        self.role.check_allow_delete()",
            "        return self.role.delete(role_id, self.project.tree_dn)",
            "",
            "    def delete_project(self, tenant_id):",
            "        self.project.check_allow_delete()",
            "        if self.project.subtree_delete_enabled:",
            "            self.project.deleteTree(tenant_id)",
            "        else:",
            "            tenant_dn = self.project._id_to_dn(tenant_id)",
            "            self.role.roles_delete_subtree_by_project(tenant_dn)",
            "            self.project.delete(tenant_id)",
            "",
            "    def remove_role_from_user_and_project(self, user_id, tenant_id, role_id):",
            "        role_dn = self._subrole_id_to_dn(role_id, tenant_id)",
            "        return self.role.delete_user(role_dn,",
            "                                     self.user._id_to_dn(user_id), role_id)",
            "",
            "    def _remove_role_from_group_and_project(self, group_id, tenant_id,",
            "                                            role_id):",
            "        role_dn = self._subrole_id_to_dn(role_id, tenant_id)",
            "        return self.role.delete_user(role_dn,",
            "                                     self.group._id_to_dn(group_id), role_id)",
            "",
            "    def update_role(self, role_id, role):",
            "        self.role.check_allow_update()",
            "        self.get_role(role_id)",
            "        return self.role.update(role_id, role)",
            "",
            "    def create_domain(self, domain_id, domain):",
            "        if domain_id == CONF.identity.default_domain_id:",
            "            msg = _('Duplicate ID, %s.') % domain_id",
            "            raise exception.Conflict(type='domain', details=msg)",
            "        raise exception.Forbidden(_('Domains are read-only against LDAP'))",
            "",
            "    def get_domain(self, domain_id):",
            "        self._validate_default_domain_id(domain_id)",
            "        return assignment.calc_default_domain()",
            "",
            "    def update_domain(self, domain_id, domain):",
            "        self._validate_default_domain_id(domain_id)",
            "        raise exception.Forbidden(_('Domains are read-only against LDAP'))",
            "",
            "    def delete_domain(self, domain_id):",
            "        self._validate_default_domain_id(domain_id)",
            "        raise exception.Forbidden(_('Domains are read-only against LDAP'))",
            "",
            "    def list_domains(self, hints):",
            "        return [assignment.calc_default_domain()]",
            "",
            "# Bulk actions on User From identity",
            "    def delete_user(self, user_id):",
            "        user_dn = self.user._id_to_dn(user_id)",
            "        for ref in self.role.list_global_roles_for_user(user_dn):",
            "            self.role.delete_user(ref.role_dn, ref.user_dn,",
            "                                  self.role._dn_to_id(ref.role_dn))",
            "        for ref in self.role.list_project_roles_for_user(user_dn,",
            "                                                         self.project.tree_dn):",
            "            self.role.delete_user(ref.role_dn, ref.user_dn,",
            "                                  self.role._dn_to_id(ref.role_dn))",
            "",
            "    # LDAP assignments only supports LDAP identity.  Assignments under",
            "    # identity are already deleted",
            "    def delete_group(self, group_id):",
            "        if not self.group.subtree_delete_enabled:",
            "            # TODO(spzala): this is only placeholder for group and domain",
            "            # role support which will be added under bug 1101287",
            "            query = '(objectClass=%s)' % self.group.object_class",
            "            dn = None",
            "            dn = self.group._id_to_dn(group_id)",
            "            if dn:",
            "                try:",
            "                    conn = self.group.get_connection()",
            "                    roles = conn.search_s(dn, ldap.SCOPE_ONELEVEL,",
            "                                          query, ['%s' % '1.1'])",
            "                    for role_dn, i in roles:",
            "                        conn.delete_s(role_dn)",
            "                except ldap.NO_SUCH_OBJECT:",
            "                    pass",
            "                finally:",
            "                    conn.unbind_s()",
            "",
            "    def create_grant(self, role_id, user_id=None, group_id=None,",
            "                     domain_id=None, project_id=None,",
            "                     inherited_to_projects=False):",
            "        self.get_role(role_id)",
            "",
            "        if domain_id:",
            "            self.get_domain(domain_id)",
            "        if project_id:",
            "            self.get_project(project_id)",
            "",
            "        if project_id and inherited_to_projects:",
            "            msg = _('Inherited roles can only be assigned to domains')",
            "            raise exception.Conflict(type='role grant', details=msg)",
            "",
            "        try:",
            "            metadata_ref = self._get_metadata(user_id, project_id,",
            "                                              domain_id, group_id)",
            "        except exception.MetadataNotFound:",
            "            metadata_ref = {}",
            "",
            "        if user_id is None:",
            "            metadata_ref['roles'] = self._add_role_to_group_and_project(",
            "                group_id, project_id, role_id)",
            "        else:",
            "            metadata_ref['roles'] = self.add_role_to_user_and_project(",
            "                user_id, project_id, role_id)",
            "",
            "    def get_grant(self, role_id, user_id=None, group_id=None,",
            "                  domain_id=None, project_id=None,",
            "                  inherited_to_projects=False):",
            "        role_ref = self.get_role(role_id)",
            "",
            "        if domain_id:",
            "            self.get_domain(domain_id)",
            "        if project_id:",
            "            self.get_project(project_id)",
            "",
            "        try:",
            "            metadata_ref = self._get_metadata(user_id, project_id,",
            "                                              domain_id, group_id)",
            "        except exception.MetadataNotFound:",
            "            metadata_ref = {}",
            "        role_ids = set(self._roles_from_role_dicts(",
            "            metadata_ref.get('roles', []), inherited_to_projects))",
            "        if role_id not in role_ids:",
            "            raise exception.RoleNotFound(role_id=role_id)",
            "        return role_ref",
            "",
            "    def delete_grant(self, role_id, user_id=None, group_id=None,",
            "                     domain_id=None, project_id=None,",
            "                     inherited_to_projects=False):",
            "        self.get_role(role_id)",
            "",
            "        if domain_id:",
            "            self.get_domain(domain_id)",
            "        if project_id:",
            "            self.get_project(project_id)",
            "",
            "        try:",
            "            metadata_ref = self._get_metadata(user_id, project_id,",
            "                                              domain_id, group_id)",
            "        except exception.MetadataNotFound:",
            "            metadata_ref = {}",
            "",
            "        try:",
            "            if user_id is None:",
            "                metadata_ref['roles'] = (",
            "                    self._remove_role_from_group_and_project(",
            "                        group_id, project_id, role_id))",
            "            else:",
            "                metadata_ref['roles'] = self.remove_role_from_user_and_project(",
            "                    user_id, project_id, role_id)",
            "        except KeyError:",
            "            raise exception.RoleNotFound(role_id=role_id)",
            "",
            "    def list_grants(self, user_id=None, group_id=None,",
            "                    domain_id=None, project_id=None,",
            "                    inherited_to_projects=False):",
            "        if domain_id:",
            "            self.get_domain(domain_id)",
            "        if project_id:",
            "            self.get_project(project_id)",
            "",
            "        try:",
            "            metadata_ref = self._get_metadata(user_id, project_id,",
            "                                              domain_id, group_id)",
            "        except exception.MetadataNotFound:",
            "            metadata_ref = {}",
            "",
            "        return [self.get_role(x) for x in",
            "                self._roles_from_role_dicts(metadata_ref.get('roles', []),",
            "                                            inherited_to_projects)]",
            "",
            "    def get_domain_by_name(self, domain_name):",
            "        default_domain = assignment.calc_default_domain()",
            "        if domain_name != default_domain['name']:",
            "            raise exception.DomainNotFound(domain_id=domain_name)",
            "        return default_domain",
            "",
            "    def list_role_assignments(self):",
            "        role_assignments = []",
            "        for a in self.role.list_role_assignments(self.project.tree_dn):",
            "            assignment = {'role_id': self.role._dn_to_id(a.role_dn),",
            "                          'user_id': self.user._dn_to_id(a.user_dn),",
            "                          'project_id': self.project._dn_to_id(a.project_dn)}",
            "            role_assignments.append(assignment)",
            "        return role_assignments",
            "",
            "",
            "# TODO(termie): turn this into a data object and move logic to driver",
            "class ProjectApi(common_ldap.EnabledEmuMixIn, common_ldap.BaseLdap):",
            "    DEFAULT_OU = 'ou=Groups'",
            "    DEFAULT_STRUCTURAL_CLASSES = []",
            "    DEFAULT_OBJECTCLASS = 'groupOfNames'",
            "    DEFAULT_ID_ATTR = 'cn'",
            "    DEFAULT_MEMBER_ATTRIBUTE = 'member'",
            "    NotFound = exception.ProjectNotFound",
            "    notfound_arg = 'project_id'  # NOTE(yorik-sar): while options_name = tenant",
            "    options_name = 'tenant'",
            "    attribute_options_names = {'name': 'name',",
            "                               'description': 'desc',",
            "                               'enabled': 'enabled',",
            "                               'domain_id': 'domain_id'}",
            "    immutable_attrs = ['name']",
            "    model = models.Project",
            "",
            "    def __init__(self, conf):",
            "        super(ProjectApi, self).__init__(conf)",
            "        self.member_attribute = (getattr(conf.ldap, 'tenant_member_attribute')",
            "                                 or self.DEFAULT_MEMBER_ATTRIBUTE)",
            "",
            "    def create(self, values):",
            "        data = values.copy()",
            "        if data.get('id') is None:",
            "            data['id'] = uuid.uuid4().hex",
            "        return super(ProjectApi, self).create(data)",
            "",
            "    def get_user_projects(self, user_dn, associations):",
            "        \"\"\"Returns list of tenants a user has access to",
            "        \"\"\"",
            "",
            "        project_ids = set()",
            "        for assoc in associations:",
            "            project_ids.add(self._dn_to_id(assoc.project_dn))",
            "        projects = []",
            "        for project_id in project_ids:",
            "            # slower to get them one at a time, but a huge list could blow out",
            "            # the connection.  This is the safer way",
            "            projects.append(self.get(project_id))",
            "        return projects",
            "",
            "    def get_user_dns(self, tenant_id, rolegrants, role_dn=None):",
            "        tenant = self._ldap_get(tenant_id)",
            "        res = set()",
            "        if not role_dn:",
            "            # Get users who have default tenant mapping",
            "            for user_dn in tenant[1].get(self.member_attribute, []):",
            "                if self.use_dumb_member and user_dn == self.dumb_member:",
            "                    continue",
            "                res.add(user_dn)",
            "",
            "        # Get users who are explicitly mapped via a tenant",
            "        for rolegrant in rolegrants:",
            "            if role_dn is None or rolegrant.role_dn == role_dn:",
            "                res.add(rolegrant.user_dn)",
            "        return list(res)",
            "",
            "    def update(self, project_id, values):",
            "        old_obj = self.get(project_id)",
            "        return super(ProjectApi, self).update(project_id, values, old_obj)",
            "",
            "",
            "class UserRoleAssociation(object):",
            "    \"\"\"Role Grant model.\"\"\"",
            "",
            "    def __init__(self, user_dn=None, role_dn=None, tenant_dn=None,",
            "                 *args, **kw):",
            "        self.user_dn = user_dn",
            "        self.role_dn = role_dn",
            "        self.project_dn = tenant_dn",
            "",
            "",
            "class GroupRoleAssociation(object):",
            "    \"\"\"Role Grant model.\"\"\"",
            "",
            "    def __init__(self, group_dn=None, role_dn=None, tenant_dn=None,",
            "                 *args, **kw):",
            "        self.group_dn = group_dn",
            "        self.role_dn = role_dn",
            "        self.project_dn = tenant_dn",
            "",
            "",
            "# TODO(termie): turn this into a data object and move logic to driver",
            "class RoleApi(common_ldap.BaseLdap):",
            "    DEFAULT_OU = 'ou=Roles'",
            "    DEFAULT_STRUCTURAL_CLASSES = []",
            "    DEFAULT_OBJECTCLASS = 'organizationalRole'",
            "    DEFAULT_MEMBER_ATTRIBUTE = 'roleOccupant'",
            "    NotFound = exception.RoleNotFound",
            "    options_name = 'role'",
            "    attribute_options_names = {'name': 'name'}",
            "    immutable_attrs = ['id']",
            "    model = models.Role",
            "",
            "    def __init__(self, conf):",
            "        super(RoleApi, self).__init__(conf)",
            "        self.member_attribute = (getattr(conf.ldap, 'role_member_attribute')",
            "                                 or self.DEFAULT_MEMBER_ATTRIBUTE)",
            "",
            "    def get(self, role_id, role_filter=None):",
            "        model = super(RoleApi, self).get(role_id, role_filter)",
            "        return model",
            "",
            "    def create(self, values):",
            "        return super(RoleApi, self).create(values)",
            "",
            "    def add_user(self, role_id, role_dn, user_dn, user_id, tenant_id=None):",
            "        try:",
            "            super(RoleApi, self).add_member(user_dn, role_dn)",
            "        except exception.Conflict:",
            "            msg = (_('User %(user_id)s already has role %(role_id)s in '",
            "                     'tenant %(tenant_id)s') %",
            "                   dict(user_id=user_id, role_id=role_id, tenant_id=tenant_id))",
            "            raise exception.Conflict(type='role grant', details=msg)",
            "        except self.NotFound:",
            "            if tenant_id is None or self.get(role_id) is None:",
            "                raise Exception(_(\"Role %s not found\") % (role_id,))",
            "",
            "            attrs = [('objectClass', [self.object_class]),",
            "                     (self.member_attribute, [user_dn])]",
            "",
            "            if self.use_dumb_member:",
            "                attrs[1][1].append(self.dumb_member)",
            "            conn = self.get_connection()",
            "            try:",
            "                conn.add_s(role_dn, attrs)",
            "            finally:",
            "                conn.unbind_s()",
            "",
            "    def delete_user(self, role_dn, user_dn, role_id):",
            "        try:",
            "            super(RoleApi, self).remove_member(user_dn, role_dn)",
            "        except (self.NotFound, ldap.NO_SUCH_ATTRIBUTE):",
            "            raise exception.RoleNotFound(message=_(",
            "                'Cannot remove role that has not been granted, %s') %",
            "                role_id)",
            "",
            "    def get_role_assignments(self, tenant_dn):",
            "        try:",
            "            roles = self._ldap_get_list(tenant_dn, ldap.SCOPE_ONELEVEL)",
            "        except ldap.NO_SUCH_OBJECT:",
            "            roles = []",
            "        res = []",
            "        for role_dn, attrs in roles:",
            "            try:",
            "                user_dns = attrs[self.member_attribute]",
            "            except KeyError:",
            "                continue",
            "            for user_dn in user_dns:",
            "                if self.use_dumb_member and user_dn == self.dumb_member:",
            "                    continue",
            "                res.append(UserRoleAssociation(",
            "                    user_dn=user_dn,",
            "                    role_dn=role_dn,",
            "                    tenant_dn=tenant_dn))",
            "",
            "        return res",
            "",
            "    def list_global_roles_for_user(self, user_dn):",
            "        user_dn_esc = ldap.filter.escape_filter_chars(user_dn)",
            "        roles = self.get_all('(%s=%s)' % (self.member_attribute, user_dn_esc))",
            "        return [UserRoleAssociation(",
            "                role_dn=role.dn,",
            "                user_dn=user_dn) for role in roles]",
            "",
            "    def list_project_roles_for_user(self, user_dn, project_subtree):",
            "        try:",
            "            roles = self._ldap_get_list(project_subtree, ldap.SCOPE_SUBTREE,",
            "                                        query_params={",
            "                                        self.member_attribute: user_dn})",
            "        except ldap.NO_SUCH_OBJECT:",
            "            roles = []",
            "        res = []",
            "        for role_dn, _ in roles:",
            "            # ldap.dn.dn2str returns an array, where the first",
            "            # element is the first segment.",
            "            # For a role assignment, this contains the role ID,",
            "            # The remainder is the DN of the tenant.",
            "            tenant = ldap.dn.str2dn(role_dn)",
            "            tenant.pop(0)",
            "            tenant_dn = ldap.dn.dn2str(tenant)",
            "            res.append(UserRoleAssociation(",
            "                user_dn=user_dn,",
            "                role_dn=role_dn,",
            "                tenant_dn=tenant_dn))",
            "        return res",
            "",
            "    def roles_delete_subtree_by_project(self, tenant_dn):",
            "        conn = self.get_connection()",
            "        query = '(objectClass=%s)' % self.object_class",
            "        try:",
            "            roles = conn.search_s(tenant_dn, ldap.SCOPE_ONELEVEL, query)",
            "            for role_dn, _ in roles:",
            "                conn.delete_s(role_dn)",
            "        except ldap.NO_SUCH_OBJECT:",
            "            pass",
            "        finally:",
            "            conn.unbind_s()",
            "",
            "    def update(self, role_id, role):",
            "        try:",
            "            old_name = self.get_by_name(role['name'])",
            "            raise exception.Conflict(_('Cannot duplicate name %s') % old_name)",
            "        except exception.NotFound:",
            "            pass",
            "        return super(RoleApi, self).update(role_id, role)",
            "",
            "    def delete(self, role_id, tenant_dn):",
            "        conn = self.get_connection()",
            "        role_id_esc = ldap.filter.escape_filter_chars(role_id)",
            "        query = '(&(objectClass=%s)(%s=%s))' % (self.object_class,",
            "                                                self.id_attr, role_id_esc)",
            "        try:",
            "            # RFC 4511 (The LDAP Protocol) defines a list containing only the",
            "            # OID \"1.1\" as indicating that no attributes should be returned.",
            "            # The following code only needs the DN of the entries.",
            "            request_no_attributes = ['1.1']",
            "            for role_dn, _ in conn.search_s(tenant_dn,",
            "                                            ldap.SCOPE_SUBTREE,",
            "                                            query,",
            "                                            attrlist=request_no_attributes):",
            "                conn.delete_s(role_dn)",
            "        except ldap.NO_SUCH_OBJECT:",
            "            pass",
            "        finally:",
            "            conn.unbind_s()",
            "        super(RoleApi, self).delete(role_id)",
            "",
            "    def list_role_assignments(self, project_tree_dn):",
            "        \"\"\"Returns a list of all the role assignments linked to project_tree_dn",
            "        attribute.",
            "        \"\"\"",
            "        try:",
            "            roles = self._ldap_get_list(project_tree_dn, ldap.SCOPE_SUBTREE)",
            "        except ldap.NO_SUCH_OBJECT:",
            "            roles = []",
            "        res = []",
            "        for role_dn, role in roles:",
            "            tenant = ldap.dn.str2dn(role_dn)",
            "            tenant.pop(0)",
            "            # It obtains the tenant DN to construct the UserRoleAssociation",
            "            # object.",
            "            tenant_dn = ldap.dn.dn2str(tenant)",
            "            for user_dn in role[self.member_attribute]:",
            "                # NOTE(nkinder): Ideally, this comparison would be aware of the",
            "                # Distinguished Name LDAP syntax. Since Keystone is responsible",
            "                # for setting the dumb member DN, we are relatively sure that",
            "                # it is returned in the same form. We still need to do a case",
            "                # insensitive comparison since attribute names will be upper",
            "                # case for AD. We already do this elsewhere in the LDAP",
            "                # driver, so it's OK until we decide to become syntax aware.",
            "                if (self.use_dumb_member and",
            "                        user_dn.lower() == self.dumb_member.lower()):",
            "                    continue",
            "                res.append(UserRoleAssociation(",
            "                           user_dn=user_dn,",
            "                           role_dn=role_dn,",
            "                           tenant_dn=tenant_dn))",
            "        return res"
        ],
        "afterPatchFile": [
            "# Copyright 2012-2013 OpenStack Foundation",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "from __future__ import absolute_import",
            "",
            "import uuid",
            "",
            "import ldap as ldap",
            "import ldap.filter",
            "",
            "from keystone import assignment",
            "from keystone import clean",
            "from keystone.common import driver_hints",
            "from keystone.common import ldap as common_ldap",
            "from keystone.common import models",
            "from keystone import config",
            "from keystone import exception",
            "from keystone.identity.backends import ldap as ldap_identity",
            "from keystone.openstack.common.gettextutils import _",
            "from keystone.openstack.common import log",
            "",
            "",
            "CONF = config.CONF",
            "LOG = log.getLogger(__name__)",
            "",
            "",
            "class Assignment(assignment.Driver):",
            "    def __init__(self):",
            "        super(Assignment, self).__init__()",
            "        self.LDAP_URL = CONF.ldap.url",
            "        self.LDAP_USER = CONF.ldap.user",
            "        self.LDAP_PASSWORD = CONF.ldap.password",
            "        self.suffix = CONF.ldap.suffix",
            "",
            "        # These are the only deep dependency from assignment back",
            "        # to identity.  The assumption is that if you are using",
            "        # LDAP for assignments, you are using it for Id as well.",
            "        self.user = ldap_identity.UserApi(CONF)",
            "        self.group = ldap_identity.GroupApi(CONF)",
            "",
            "        self.project = ProjectApi(CONF)",
            "        self.role = RoleApi(CONF)",
            "",
            "    def get_project(self, tenant_id):",
            "        return self._set_default_domain(self.project.get(tenant_id))",
            "",
            "    def list_projects(self, hints):",
            "        return self._set_default_domain(self.project.get_all())",
            "",
            "    def list_projects_in_domain(self, domain_id):",
            "        # We don't support multiple domains within this driver, so ignore",
            "        # any domain specified",
            "        return self.list_projects(driver_hints.Hints())",
            "",
            "    def get_project_by_name(self, tenant_name, domain_id):",
            "        self._validate_default_domain_id(domain_id)",
            "        return self._set_default_domain(self.project.get_by_name(tenant_name))",
            "",
            "    def create_project(self, tenant_id, tenant):",
            "        self.project.check_allow_create()",
            "        tenant = self._validate_default_domain(tenant)",
            "        tenant['name'] = clean.project_name(tenant['name'])",
            "        data = tenant.copy()",
            "        if 'id' not in data or data['id'] is None:",
            "            data['id'] = str(uuid.uuid4().hex)",
            "        if 'description' in data and data['description'] in ['', None]:",
            "            data.pop('description')",
            "        return self._set_default_domain(self.project.create(data))",
            "",
            "    def update_project(self, tenant_id, tenant):",
            "        self.project.check_allow_update()",
            "        tenant = self._validate_default_domain(tenant)",
            "        if 'name' in tenant:",
            "            tenant['name'] = clean.project_name(tenant['name'])",
            "        return self._set_default_domain(self.project.update(tenant_id, tenant))",
            "",
            "    def _get_metadata(self, user_id=None, tenant_id=None,",
            "                      domain_id=None, group_id=None):",
            "",
            "        def _get_roles_for_just_user_and_project(user_id, tenant_id):",
            "            self.get_project(tenant_id)",
            "            user_dn = self.user._id_to_dn(user_id)",
            "            return [self.role._dn_to_id(a.role_dn)",
            "                    for a in self.role.get_role_assignments",
            "                    (self.project._id_to_dn(tenant_id))",
            "                    if common_ldap.is_dn_equal(a.user_dn, user_dn)]",
            "",
            "        def _get_roles_for_group_and_project(group_id, project_id):",
            "            self.get_project(project_id)",
            "            group_dn = self.group._id_to_dn(group_id)",
            "            # NOTE(marcos-fermin-lobo): In Active Directory, for functions",
            "            # such as \"self.role.get_role_assignments\", it returns",
            "            # the key \"CN\" or \"OU\" in uppercase.",
            "            # The group_dn var has \"CN\" and \"OU\" in lowercase.",
            "            # For this reason, it is necessary to use the \"upper()\"",
            "            # function so both are consistent.",
            "            return [self.role._dn_to_id(a.role_dn)",
            "                    for a in self.role.get_role_assignments",
            "                    (self.project._id_to_dn(project_id))",
            "                    if common_ldap.is_dn_equal(a.user_dn, group_dn)]",
            "",
            "        if domain_id is not None:",
            "            msg = _('Domain metadata not supported by LDAP')",
            "            raise exception.NotImplemented(message=msg)",
            "        if group_id is None and user_id is None:",
            "            return {}",
            "",
            "        if tenant_id is None:",
            "            return {}",
            "        if user_id is None:",
            "            metadata_ref = _get_roles_for_group_and_project(group_id,",
            "                                                            tenant_id)",
            "        else:",
            "            metadata_ref = _get_roles_for_just_user_and_project(user_id,",
            "                                                                tenant_id)",
            "        if not metadata_ref:",
            "            return {}",
            "        return {'roles': [self._role_to_dict(r, False) for r in metadata_ref]}",
            "",
            "    def get_role(self, role_id):",
            "        return self.role.get(role_id)",
            "",
            "    def list_roles(self, hints):",
            "        return self.role.get_all()",
            "",
            "    def list_projects_for_user(self, user_id, group_ids, hints):",
            "        # NOTE(henry-nash): The LDAP backend is being deprecated, so no",
            "        # support is provided for projects that the user has a role on solely",
            "        # by virtue of group membership.",
            "        user_dn = self.user._id_to_dn(user_id)",
            "        associations = (self.role.list_project_roles_for_user",
            "                        (user_dn, self.project.tree_dn))",
            "        # Since the LDAP backend doesn't store the domain_id in the LDAP",
            "        # records (and only supports the default domain), we fill in the",
            "        # domain_id before we return the list.",
            "        return [self._set_default_domain(x) for x in",
            "                self.project.get_user_projects(user_dn, associations)]",
            "",
            "    def get_roles_for_groups(self, group_ids, project_id=None, domain_id=None):",
            "        raise exception.NotImplemented()",
            "",
            "    def list_projects_for_groups(self, group_ids):",
            "        raise exception.NotImplemented()",
            "",
            "    def list_domains_for_groups(self, group_ids):",
            "        raise exception.NotImplemented()",
            "",
            "    def list_user_ids_for_project(self, tenant_id):",
            "        self.get_project(tenant_id)",
            "        tenant_dn = self.project._id_to_dn(tenant_id)",
            "        rolegrants = self.role.get_role_assignments(tenant_dn)",
            "        return [self.user._dn_to_id(user_dn) for user_dn in",
            "                self.project.get_user_dns(tenant_id, rolegrants)]",
            "",
            "    def _subrole_id_to_dn(self, role_id, tenant_id):",
            "        if tenant_id is None:",
            "            return self.role._id_to_dn(role_id)",
            "        else:",
            "            return '%s=%s,%s' % (self.role.id_attr,",
            "                                 ldap.dn.escape_dn_chars(role_id),",
            "                                 self.project._id_to_dn(tenant_id))",
            "",
            "    def add_role_to_user_and_project(self, user_id, tenant_id, role_id):",
            "        self.get_project(tenant_id)",
            "        self.get_role(role_id)",
            "        user_dn = self.user._id_to_dn(user_id)",
            "        role_dn = self._subrole_id_to_dn(role_id, tenant_id)",
            "        self.role.add_user(role_id, role_dn, user_dn, user_id, tenant_id)",
            "        tenant_dn = self.project._id_to_dn(tenant_id)",
            "        return UserRoleAssociation(role_dn=role_dn,",
            "                                   user_dn=user_dn,",
            "                                   tenant_dn=tenant_dn)",
            "",
            "    def _add_role_to_group_and_project(self, group_id, tenant_id, role_id):",
            "        self.get_project(tenant_id)",
            "        self.get_role(role_id)",
            "        group_dn = self.group._id_to_dn(group_id)",
            "        role_dn = self._subrole_id_to_dn(role_id, tenant_id)",
            "        self.role.add_user(role_id, role_dn, group_dn, group_id, tenant_id)",
            "        tenant_dn = self.project._id_to_dn(tenant_id)",
            "        return GroupRoleAssociation(group_dn=group_dn,",
            "                                    role_dn=role_dn,",
            "                                    tenant_dn=tenant_dn)",
            "",
            "    def create_role(self, role_id, role):",
            "        self.role.check_allow_create()",
            "        try:",
            "            self.get_role(role_id)",
            "        except exception.NotFound:",
            "            pass",
            "        else:",
            "            msg = _('Duplicate ID, %s.') % role_id",
            "            raise exception.Conflict(type='role', details=msg)",
            "",
            "        try:",
            "            self.role.get_by_name(role['name'])",
            "        except exception.NotFound:",
            "            pass",
            "        else:",
            "            msg = _('Duplicate name, %s.') % role['name']",
            "            raise exception.Conflict(type='role', details=msg)",
            "",
            "        return self.role.create(role)",
            "",
            "    def delete_role(self, role_id):",
            "        self.role.check_allow_delete()",
            "        return self.role.delete(role_id, self.project.tree_dn)",
            "",
            "    def delete_project(self, tenant_id):",
            "        self.project.check_allow_delete()",
            "        if self.project.subtree_delete_enabled:",
            "            self.project.deleteTree(tenant_id)",
            "        else:",
            "            tenant_dn = self.project._id_to_dn(tenant_id)",
            "            self.role.roles_delete_subtree_by_project(tenant_dn)",
            "            self.project.delete(tenant_id)",
            "",
            "    def remove_role_from_user_and_project(self, user_id, tenant_id, role_id):",
            "        role_dn = self._subrole_id_to_dn(role_id, tenant_id)",
            "        return self.role.delete_user(role_dn,",
            "                                     self.user._id_to_dn(user_id), role_id)",
            "",
            "    def _remove_role_from_group_and_project(self, group_id, tenant_id,",
            "                                            role_id):",
            "        role_dn = self._subrole_id_to_dn(role_id, tenant_id)",
            "        return self.role.delete_user(role_dn,",
            "                                     self.group._id_to_dn(group_id), role_id)",
            "",
            "    def update_role(self, role_id, role):",
            "        self.role.check_allow_update()",
            "        self.get_role(role_id)",
            "        return self.role.update(role_id, role)",
            "",
            "    def create_domain(self, domain_id, domain):",
            "        if domain_id == CONF.identity.default_domain_id:",
            "            msg = _('Duplicate ID, %s.') % domain_id",
            "            raise exception.Conflict(type='domain', details=msg)",
            "        raise exception.Forbidden(_('Domains are read-only against LDAP'))",
            "",
            "    def get_domain(self, domain_id):",
            "        self._validate_default_domain_id(domain_id)",
            "        return assignment.calc_default_domain()",
            "",
            "    def update_domain(self, domain_id, domain):",
            "        self._validate_default_domain_id(domain_id)",
            "        raise exception.Forbidden(_('Domains are read-only against LDAP'))",
            "",
            "    def delete_domain(self, domain_id):",
            "        self._validate_default_domain_id(domain_id)",
            "        raise exception.Forbidden(_('Domains are read-only against LDAP'))",
            "",
            "    def list_domains(self, hints):",
            "        return [assignment.calc_default_domain()]",
            "",
            "# Bulk actions on User From identity",
            "    def delete_user(self, user_id):",
            "        user_dn = self.user._id_to_dn(user_id)",
            "        for ref in self.role.list_global_roles_for_user(user_dn):",
            "            self.role.delete_user(ref.role_dn, ref.user_dn,",
            "                                  self.role._dn_to_id(ref.role_dn))",
            "        for ref in self.role.list_project_roles_for_user(user_dn,",
            "                                                         self.project.tree_dn):",
            "            self.role.delete_user(ref.role_dn, ref.user_dn,",
            "                                  self.role._dn_to_id(ref.role_dn))",
            "",
            "    # LDAP assignments only supports LDAP identity.  Assignments under",
            "    # identity are already deleted",
            "    def delete_group(self, group_id):",
            "        if not self.group.subtree_delete_enabled:",
            "            # TODO(spzala): this is only placeholder for group and domain",
            "            # role support which will be added under bug 1101287",
            "            query = '(objectClass=%s)' % self.group.object_class",
            "            dn = None",
            "            dn = self.group._id_to_dn(group_id)",
            "            if dn:",
            "                try:",
            "                    conn = self.group.get_connection()",
            "                    roles = conn.search_s(dn, ldap.SCOPE_ONELEVEL,",
            "                                          query, ['%s' % '1.1'])",
            "                    for role_dn, i in roles:",
            "                        conn.delete_s(role_dn)",
            "                except ldap.NO_SUCH_OBJECT:",
            "                    pass",
            "                finally:",
            "                    conn.unbind_s()",
            "",
            "    def create_grant(self, role_id, user_id=None, group_id=None,",
            "                     domain_id=None, project_id=None,",
            "                     inherited_to_projects=False):",
            "        self.get_role(role_id)",
            "",
            "        if domain_id:",
            "            self.get_domain(domain_id)",
            "        if project_id:",
            "            self.get_project(project_id)",
            "",
            "        if project_id and inherited_to_projects:",
            "            msg = _('Inherited roles can only be assigned to domains')",
            "            raise exception.Conflict(type='role grant', details=msg)",
            "",
            "        try:",
            "            metadata_ref = self._get_metadata(user_id, project_id,",
            "                                              domain_id, group_id)",
            "        except exception.MetadataNotFound:",
            "            metadata_ref = {}",
            "",
            "        if user_id is None:",
            "            metadata_ref['roles'] = self._add_role_to_group_and_project(",
            "                group_id, project_id, role_id)",
            "        else:",
            "            metadata_ref['roles'] = self.add_role_to_user_and_project(",
            "                user_id, project_id, role_id)",
            "",
            "    def get_grant(self, role_id, user_id=None, group_id=None,",
            "                  domain_id=None, project_id=None,",
            "                  inherited_to_projects=False):",
            "        role_ref = self.get_role(role_id)",
            "",
            "        if domain_id:",
            "            self.get_domain(domain_id)",
            "        if project_id:",
            "            self.get_project(project_id)",
            "",
            "        try:",
            "            metadata_ref = self._get_metadata(user_id, project_id,",
            "                                              domain_id, group_id)",
            "        except exception.MetadataNotFound:",
            "            metadata_ref = {}",
            "        role_ids = set(self._roles_from_role_dicts(",
            "            metadata_ref.get('roles', []), inherited_to_projects))",
            "        if role_id not in role_ids:",
            "            raise exception.RoleNotFound(role_id=role_id)",
            "        return role_ref",
            "",
            "    def delete_grant(self, role_id, user_id=None, group_id=None,",
            "                     domain_id=None, project_id=None,",
            "                     inherited_to_projects=False):",
            "        self.get_role(role_id)",
            "",
            "        if domain_id:",
            "            self.get_domain(domain_id)",
            "        if project_id:",
            "            self.get_project(project_id)",
            "",
            "        try:",
            "            metadata_ref = self._get_metadata(user_id, project_id,",
            "                                              domain_id, group_id)",
            "        except exception.MetadataNotFound:",
            "            metadata_ref = {}",
            "",
            "        try:",
            "            if user_id is None:",
            "                metadata_ref['roles'] = (",
            "                    self._remove_role_from_group_and_project(",
            "                        group_id, project_id, role_id))",
            "            else:",
            "                metadata_ref['roles'] = self.remove_role_from_user_and_project(",
            "                    user_id, project_id, role_id)",
            "        except KeyError:",
            "            raise exception.RoleNotFound(role_id=role_id)",
            "",
            "    def list_grants(self, user_id=None, group_id=None,",
            "                    domain_id=None, project_id=None,",
            "                    inherited_to_projects=False):",
            "        if domain_id:",
            "            self.get_domain(domain_id)",
            "        if project_id:",
            "            self.get_project(project_id)",
            "",
            "        try:",
            "            metadata_ref = self._get_metadata(user_id, project_id,",
            "                                              domain_id, group_id)",
            "        except exception.MetadataNotFound:",
            "            metadata_ref = {}",
            "",
            "        return [self.get_role(x) for x in",
            "                self._roles_from_role_dicts(metadata_ref.get('roles', []),",
            "                                            inherited_to_projects)]",
            "",
            "    def get_domain_by_name(self, domain_name):",
            "        default_domain = assignment.calc_default_domain()",
            "        if domain_name != default_domain['name']:",
            "            raise exception.DomainNotFound(domain_id=domain_name)",
            "        return default_domain",
            "",
            "    def list_role_assignments(self):",
            "        role_assignments = []",
            "        for a in self.role.list_role_assignments(self.project.tree_dn):",
            "            assignment = {'role_id': self.role._dn_to_id(a.role_dn),",
            "                          'user_id': self.user._dn_to_id(a.user_dn),",
            "                          'project_id': self.project._dn_to_id(a.project_dn)}",
            "            role_assignments.append(assignment)",
            "        return role_assignments",
            "",
            "",
            "# TODO(termie): turn this into a data object and move logic to driver",
            "class ProjectApi(common_ldap.EnabledEmuMixIn, common_ldap.BaseLdap):",
            "    DEFAULT_OU = 'ou=Groups'",
            "    DEFAULT_STRUCTURAL_CLASSES = []",
            "    DEFAULT_OBJECTCLASS = 'groupOfNames'",
            "    DEFAULT_ID_ATTR = 'cn'",
            "    DEFAULT_MEMBER_ATTRIBUTE = 'member'",
            "    NotFound = exception.ProjectNotFound",
            "    notfound_arg = 'project_id'  # NOTE(yorik-sar): while options_name = tenant",
            "    options_name = 'tenant'",
            "    attribute_options_names = {'name': 'name',",
            "                               'description': 'desc',",
            "                               'enabled': 'enabled',",
            "                               'domain_id': 'domain_id'}",
            "    immutable_attrs = ['name']",
            "    model = models.Project",
            "",
            "    def __init__(self, conf):",
            "        super(ProjectApi, self).__init__(conf)",
            "        self.member_attribute = (getattr(conf.ldap, 'tenant_member_attribute')",
            "                                 or self.DEFAULT_MEMBER_ATTRIBUTE)",
            "",
            "    def create(self, values):",
            "        data = values.copy()",
            "        if data.get('id') is None:",
            "            data['id'] = uuid.uuid4().hex",
            "        return super(ProjectApi, self).create(data)",
            "",
            "    def get_user_projects(self, user_dn, associations):",
            "        \"\"\"Returns list of tenants a user has access to",
            "        \"\"\"",
            "",
            "        project_ids = set()",
            "        for assoc in associations:",
            "            project_ids.add(self._dn_to_id(assoc.project_dn))",
            "        projects = []",
            "        for project_id in project_ids:",
            "            # slower to get them one at a time, but a huge list could blow out",
            "            # the connection.  This is the safer way",
            "            projects.append(self.get(project_id))",
            "        return projects",
            "",
            "    def get_user_dns(self, tenant_id, rolegrants, role_dn=None):",
            "        tenant = self._ldap_get(tenant_id)",
            "        res = set()",
            "        if not role_dn:",
            "            # Get users who have default tenant mapping",
            "            for user_dn in tenant[1].get(self.member_attribute, []):",
            "                if self.use_dumb_member and user_dn == self.dumb_member:",
            "                    continue",
            "                res.add(user_dn)",
            "",
            "        # Get users who are explicitly mapped via a tenant",
            "        for rolegrant in rolegrants:",
            "            if role_dn is None or rolegrant.role_dn == role_dn:",
            "                res.add(rolegrant.user_dn)",
            "        return list(res)",
            "",
            "    def update(self, project_id, values):",
            "        old_obj = self.get(project_id)",
            "        return super(ProjectApi, self).update(project_id, values, old_obj)",
            "",
            "",
            "class UserRoleAssociation(object):",
            "    \"\"\"Role Grant model.\"\"\"",
            "",
            "    def __init__(self, user_dn=None, role_dn=None, tenant_dn=None,",
            "                 *args, **kw):",
            "        self.user_dn = user_dn",
            "        self.role_dn = role_dn",
            "        self.project_dn = tenant_dn",
            "",
            "",
            "class GroupRoleAssociation(object):",
            "    \"\"\"Role Grant model.\"\"\"",
            "",
            "    def __init__(self, group_dn=None, role_dn=None, tenant_dn=None,",
            "                 *args, **kw):",
            "        self.group_dn = group_dn",
            "        self.role_dn = role_dn",
            "        self.project_dn = tenant_dn",
            "",
            "",
            "# TODO(termie): turn this into a data object and move logic to driver",
            "class RoleApi(common_ldap.BaseLdap):",
            "    DEFAULT_OU = 'ou=Roles'",
            "    DEFAULT_STRUCTURAL_CLASSES = []",
            "    DEFAULT_OBJECTCLASS = 'organizationalRole'",
            "    DEFAULT_MEMBER_ATTRIBUTE = 'roleOccupant'",
            "    NotFound = exception.RoleNotFound",
            "    options_name = 'role'",
            "    attribute_options_names = {'name': 'name'}",
            "    immutable_attrs = ['id']",
            "    model = models.Role",
            "",
            "    def __init__(self, conf):",
            "        super(RoleApi, self).__init__(conf)",
            "        self.member_attribute = (getattr(conf.ldap, 'role_member_attribute')",
            "                                 or self.DEFAULT_MEMBER_ATTRIBUTE)",
            "",
            "    def get(self, role_id, role_filter=None):",
            "        model = super(RoleApi, self).get(role_id, role_filter)",
            "        return model",
            "",
            "    def create(self, values):",
            "        return super(RoleApi, self).create(values)",
            "",
            "    def add_user(self, role_id, role_dn, user_dn, user_id, tenant_id=None):",
            "        try:",
            "            super(RoleApi, self).add_member(user_dn, role_dn)",
            "        except exception.Conflict:",
            "            msg = (_('User %(user_id)s already has role %(role_id)s in '",
            "                     'tenant %(tenant_id)s') %",
            "                   dict(user_id=user_id, role_id=role_id, tenant_id=tenant_id))",
            "            raise exception.Conflict(type='role grant', details=msg)",
            "        except self.NotFound:",
            "            if tenant_id is None or self.get(role_id) is None:",
            "                raise Exception(_(\"Role %s not found\") % (role_id,))",
            "",
            "            attrs = [('objectClass', [self.object_class]),",
            "                     (self.member_attribute, [user_dn])]",
            "",
            "            if self.use_dumb_member:",
            "                attrs[1][1].append(self.dumb_member)",
            "            conn = self.get_connection()",
            "            try:",
            "                conn.add_s(role_dn, attrs)",
            "            finally:",
            "                conn.unbind_s()",
            "",
            "    def delete_user(self, role_dn, user_dn, role_id):",
            "        try:",
            "            super(RoleApi, self).remove_member(user_dn, role_dn)",
            "        except (self.NotFound, ldap.NO_SUCH_ATTRIBUTE):",
            "            raise exception.RoleNotFound(message=_(",
            "                'Cannot remove role that has not been granted, %s') %",
            "                role_id)",
            "",
            "    def get_role_assignments(self, tenant_dn):",
            "        try:",
            "            roles = self._ldap_get_list(tenant_dn, ldap.SCOPE_ONELEVEL)",
            "        except ldap.NO_SUCH_OBJECT:",
            "            roles = []",
            "        res = []",
            "        for role_dn, attrs in roles:",
            "            try:",
            "                user_dns = attrs[self.member_attribute]",
            "            except KeyError:",
            "                continue",
            "            for user_dn in user_dns:",
            "                if self.use_dumb_member and user_dn == self.dumb_member:",
            "                    continue",
            "                res.append(UserRoleAssociation(",
            "                    user_dn=user_dn,",
            "                    role_dn=role_dn,",
            "                    tenant_dn=tenant_dn))",
            "",
            "        return res",
            "",
            "    def list_global_roles_for_user(self, user_dn):",
            "        user_dn_esc = ldap.filter.escape_filter_chars(user_dn)",
            "        roles = self.get_all('(%s=%s)' % (self.member_attribute, user_dn_esc))",
            "        return [UserRoleAssociation(",
            "                role_dn=role.dn,",
            "                user_dn=user_dn) for role in roles]",
            "",
            "    def list_project_roles_for_user(self, user_dn, project_subtree):",
            "        try:",
            "            roles = self._ldap_get_list(project_subtree, ldap.SCOPE_SUBTREE,",
            "                                        query_params={",
            "                                        self.member_attribute: user_dn})",
            "        except ldap.NO_SUCH_OBJECT:",
            "            roles = []",
            "        res = []",
            "        for role_dn, _ in roles:",
            "            # ldap.dn.dn2str returns an array, where the first",
            "            # element is the first segment.",
            "            # For a role assignment, this contains the role ID,",
            "            # The remainder is the DN of the tenant.",
            "            tenant = ldap.dn.str2dn(role_dn)",
            "            tenant.pop(0)",
            "            tenant_dn = ldap.dn.dn2str(tenant)",
            "            res.append(UserRoleAssociation(",
            "                user_dn=user_dn,",
            "                role_dn=role_dn,",
            "                tenant_dn=tenant_dn))",
            "        return res",
            "",
            "    def roles_delete_subtree_by_project(self, tenant_dn):",
            "        conn = self.get_connection()",
            "        query = '(objectClass=%s)' % self.object_class",
            "        try:",
            "            roles = conn.search_s(tenant_dn, ldap.SCOPE_ONELEVEL, query)",
            "            for role_dn, _ in roles:",
            "                conn.delete_s(role_dn)",
            "        except ldap.NO_SUCH_OBJECT:",
            "            pass",
            "        finally:",
            "            conn.unbind_s()",
            "",
            "    def update(self, role_id, role):",
            "        try:",
            "            old_name = self.get_by_name(role['name'])",
            "            raise exception.Conflict(_('Cannot duplicate name %s') % old_name)",
            "        except exception.NotFound:",
            "            pass",
            "        return super(RoleApi, self).update(role_id, role)",
            "",
            "    def delete(self, role_id, tenant_dn):",
            "        conn = self.get_connection()",
            "        role_id_esc = ldap.filter.escape_filter_chars(role_id)",
            "        query = '(&(objectClass=%s)(%s=%s))' % (self.object_class,",
            "                                                self.id_attr, role_id_esc)",
            "        try:",
            "            # RFC 4511 (The LDAP Protocol) defines a list containing only the",
            "            # OID \"1.1\" as indicating that no attributes should be returned.",
            "            # The following code only needs the DN of the entries.",
            "            request_no_attributes = ['1.1']",
            "            for role_dn, _ in conn.search_s(tenant_dn,",
            "                                            ldap.SCOPE_SUBTREE,",
            "                                            query,",
            "                                            attrlist=request_no_attributes):",
            "                conn.delete_s(role_dn)",
            "        except ldap.NO_SUCH_OBJECT:",
            "            pass",
            "        finally:",
            "            conn.unbind_s()",
            "        super(RoleApi, self).delete(role_id)",
            "",
            "    def list_role_assignments(self, project_tree_dn):",
            "        \"\"\"Returns a list of all the role assignments linked to project_tree_dn",
            "        attribute.",
            "        \"\"\"",
            "        try:",
            "            roles = self._ldap_get_list(project_tree_dn, ldap.SCOPE_SUBTREE)",
            "        except ldap.NO_SUCH_OBJECT:",
            "            roles = []",
            "        res = []",
            "        for role_dn, role in roles:",
            "            tenant = ldap.dn.str2dn(role_dn)",
            "            tenant.pop(0)",
            "            # It obtains the tenant DN to construct the UserRoleAssociation",
            "            # object.",
            "            tenant_dn = ldap.dn.dn2str(tenant)",
            "            for user_dn in role[self.member_attribute]:",
            "                # NOTE(nkinder): Ideally, this comparison would be aware of the",
            "                # Distinguished Name LDAP syntax. Since Keystone is responsible",
            "                # for setting the dumb member DN, we are relatively sure that",
            "                # it is returned in the same form. We still need to do a case",
            "                # insensitive comparison since attribute names will be upper",
            "                # case for AD. We already do this elsewhere in the LDAP",
            "                # driver, so it's OK until we decide to become syntax aware.",
            "                if (self.use_dumb_member and",
            "                        user_dn.lower() == self.dumb_member.lower()):",
            "                    continue",
            "                res.append(UserRoleAssociation(",
            "                           user_dn=user_dn,",
            "                           role_dn=role_dn,",
            "                           tenant_dn=tenant_dn))",
            "        return res"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "95": [
                "Assignment",
                "_get_metadata",
                "_get_roles_for_just_user_and_project"
            ],
            "109": [
                "Assignment",
                "_get_metadata",
                "_get_roles_for_group_and_project"
            ]
        },
        "addLocation": [
            "keystone.assignment.backends.ldap.Assignment._get_metadata"
        ]
    },
    "keystone/common/ldap/core.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " import abc"
            },
            "2": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " import os.path"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+import re"
            },
            "4": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " import codecs"
            },
            "6": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " import ldap"
            },
            "7": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "                 'options': ', '.join(LDAP_SCOPES.keys())})"
            },
            "8": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 143,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 144,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+def prep_case_insensitive(value):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+    \"\"\"Prepare a string for case-insensitive comparison."
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+    This is defined in RFC4518. For simplicity, all this function does is"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+    lowercase all the characters, strip leading and trailing whitespace,"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+    and compress sequences of spaces to a single space."
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+    \"\"\""
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+    value = re.sub(r'\\s+', ' ', value.strip().lower())"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+    return value"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+def is_ava_value_equal(attribute_type, val1, val2):"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+    \"\"\"Returns True if and only if the AVAs are equal."
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+    When comparing AVAs, the equality matching rule for the attribute type"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+    should be taken into consideration. For simplicity, this implementation"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+    does a case-insensitive comparison."
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+    Note that this function uses prep_case_insenstive so the limitations of"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+    that function apply here."
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+    \"\"\""
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+    return prep_case_insensitive(val1) == prep_case_insensitive(val2)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+def is_rdn_equal(rdn1, rdn2):"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+    \"\"\"Returns True if and only if the RDNs are equal."
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+    * RDNs must have the same number of AVAs."
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+    * Each AVA of the RDNs must be the equal for the same attribute type. The"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+      order isn't significant. Note that an attribute type will only be in one"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+      AVA in an RDN, otherwise the DN wouldn't be valid."
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+    * Attribute types aren't case sensitive. Note that attribute type"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+      comparison is more complicated than implemented. This function only"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+      compares case-insentive. The code should handle multiple names for an"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+      attribute type (e.g., cn, commonName, and 2.5.4.3 are the same)."
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+    Note that this function uses is_ava_value_equal to compare AVAs so the"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+    limitations of that function apply here."
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+    \"\"\""
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+    if len(rdn1) != len(rdn2):"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+        return False"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+    for attr_type_1, val1, dummy in rdn1:"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+        found = False"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+        for attr_type_2, val2, dummy in rdn2:"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+            if attr_type_1.lower() != attr_type_2.lower():"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+                continue"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+            found = True"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+            if not is_ava_value_equal(attr_type_1, val1, val2):"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+                return False"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+            break"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+        if not found:"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+            return False"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+    return True"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+def is_dn_equal(dn1, dn2):"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+    \"\"\"Returns True if and only if the DNs are equal."
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+    Two DNs are equal if they've got the same number of RDNs and if the RDNs"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+    are the same at each position. See RFC4517."
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+    Note that this function uses is_rdn_equal to compare RDNs so the"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+    limitations of that function apply here."
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+    :param dn1: Either a string DN or a DN parsed by ldap.dn.str2dn."
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+    :param dn2: Either a string DN or a DN parsed by ldap.dn.str2dn."
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+    \"\"\""
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+    if not isinstance(dn1, list):"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        dn1 = ldap.dn.str2dn(dn1)"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+    if not isinstance(dn2, list):"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+        dn2 = ldap.dn.str2dn(dn2)"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+    if len(dn1) != len(dn2):"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+        return False"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+    for rdn1, rdn2 in zip(dn1, dn2):"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+        if not is_rdn_equal(rdn1, rdn2):"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+            return False"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+    return True"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+def dn_startswith(descendant_dn, dn):"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+    \"\"\"Returns True if and only if the descendant_dn is under the dn."
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+    :param descendant_dn: Either a string DN or a DN parsed by ldap.dn.str2dn."
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+    :param dn: Either a string DN or a DN parsed by ldap.dn.str2dn."
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+    \"\"\""
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+    if not isinstance(descendant_dn, list):"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+        descendant_dn = ldap.dn.str2dn(descendant_dn)"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 245,
                "PatchRowcode": "+    if not isinstance(dn, list):"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 246,
                "PatchRowcode": "+        dn = ldap.dn.str2dn(dn)"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 248,
                "PatchRowcode": "+    if len(descendant_dn) <= len(dn):"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+        return False"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+"
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+    return is_dn_equal(descendant_dn[len(dn):], dn)"
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+"
            },
            "119": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 254,
                "PatchRowcode": " @six.add_metaclass(abc.ABCMeta)"
            },
            "120": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 255,
                "PatchRowcode": " class LDAPHandler(object):"
            },
            "121": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "     '''Abstract class which defines methods for a LDAP API provider."
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import abc",
            "import os.path",
            "",
            "import codecs",
            "import ldap",
            "import ldap.filter",
            "import six",
            "",
            "from keystone import exception",
            "from keystone.openstack.common.gettextutils import _",
            "from keystone.openstack.common import log",
            "",
            "LOG = log.getLogger(__name__)",
            "",
            "",
            "LDAP_VALUES = {'TRUE': True, 'FALSE': False}",
            "CONTROL_TREEDELETE = '1.2.840.113556.1.4.805'",
            "LDAP_SCOPES = {'one': ldap.SCOPE_ONELEVEL,",
            "               'sub': ldap.SCOPE_SUBTREE}",
            "LDAP_DEREF = {'always': ldap.DEREF_ALWAYS,",
            "              'default': None,",
            "              'finding': ldap.DEREF_FINDING,",
            "              'never': ldap.DEREF_NEVER,",
            "              'searching': ldap.DEREF_SEARCHING}",
            "LDAP_TLS_CERTS = {'never': ldap.OPT_X_TLS_NEVER,",
            "                  'demand': ldap.OPT_X_TLS_DEMAND,",
            "                  'allow': ldap.OPT_X_TLS_ALLOW}",
            "",
            "",
            "_utf8_encoder = codecs.getencoder('utf-8')",
            "",
            "",
            "def utf8_encode(value):",
            "    if isinstance(value, six.text_type):",
            "        return _utf8_encoder(value)[0]",
            "    elif isinstance(value, six.binary_type):",
            "        return value",
            "    else:",
            "        raise TypeError(\"value must be basestring, \"",
            "                        \"not %s\" % value.__class__.__name__)",
            "",
            "_utf8_decoder = codecs.getdecoder('utf-8')",
            "",
            "",
            "def utf8_decode(value):",
            "    if isinstance(value, six.binary_type):",
            "        return _utf8_decoder(value)[0]",
            "    return six.text_type(value)",
            "",
            "",
            "def py2ldap(val):",
            "    if isinstance(val, bool):",
            "        return u'TRUE' if val else u'FALSE'",
            "    else:",
            "        return six.text_type(val)",
            "",
            "",
            "def ldap2py(val):",
            "    try:",
            "        return LDAP_VALUES[val]",
            "    except KeyError:",
            "        pass",
            "    try:",
            "        return int(val)",
            "    except ValueError:",
            "        pass",
            "    return utf8_decode(val)",
            "",
            "",
            "def convert_ldap_result(ldap_result):",
            "    py_result = []",
            "    at_least_one_referral = False",
            "    for dn, attrs in ldap_result:",
            "        if dn is None:",
            "            # this is a Referral object, rather than an Entry object",
            "            at_least_one_referral = True",
            "            continue",
            "",
            "        py_result.append((utf8_decode(dn),",
            "                          dict((kind, [ldap2py(x) for x in values])",
            "                               for kind, values in six.iteritems(attrs))))",
            "    if at_least_one_referral:",
            "        LOG.debug(_('Referrals were returned and ignored. Enable referral '",
            "                    'chasing in keystone.conf via [ldap] chase_referrals'))",
            "",
            "    return py_result",
            "",
            "",
            "def safe_iter(attrs):",
            "    if attrs is None:",
            "        return",
            "    elif isinstance(attrs, list):",
            "        for e in attrs:",
            "            yield e",
            "    else:",
            "        yield attrs",
            "",
            "",
            "def parse_deref(opt):",
            "    try:",
            "        return LDAP_DEREF[opt]",
            "    except KeyError:",
            "        raise ValueError(_('Invalid LDAP deref option: %(option)s. '",
            "                           'Choose one of: %(options)s') %",
            "                         {'option': opt,",
            "                          'options': ', '.join(LDAP_DEREF.keys()), })",
            "",
            "",
            "def parse_tls_cert(opt):",
            "    try:",
            "        return LDAP_TLS_CERTS[opt]",
            "    except KeyError:",
            "        raise ValueError(_(",
            "            'Invalid LDAP TLS certs option: %(option)s. '",
            "            'Choose one of: %(options)s') % {",
            "                'option': opt,",
            "                'options': ', '.join(LDAP_TLS_CERTS.keys())})",
            "",
            "",
            "def ldap_scope(scope):",
            "    try:",
            "        return LDAP_SCOPES[scope]",
            "    except KeyError:",
            "        raise ValueError(",
            "            _('Invalid LDAP scope: %(scope)s. Choose one of: %(options)s') % {",
            "                'scope': scope,",
            "                'options': ', '.join(LDAP_SCOPES.keys())})",
            "",
            "",
            "@six.add_metaclass(abc.ABCMeta)",
            "class LDAPHandler(object):",
            "    '''Abstract class which defines methods for a LDAP API provider.",
            "",
            "    Native Keystone values cannot be passed directly into and from the",
            "    python-ldap API. Type conversion must occur at the LDAP API",
            "    boudary, examples of type conversions are:",
            "",
            "        * booleans map to the strings 'TRUE' and 'FALSE'",
            "",
            "        * integer values map to their string representation.",
            "",
            "        * unicode strings are encoded in UTF-8",
            "",
            "    In addition to handling type conversions at the API boundary we",
            "    have the requirement to support more than one LDAP API",
            "    provider. Currently we have:",
            "",
            "        * python-ldap, this is the standard LDAP API for Python, it",
            "          requires access to a live LDAP server.",
            "",
            "        * Fake LDAP which emulates python-ldap. This is used for",
            "          testing without requiring a live LDAP server.",
            "",
            "    To support these requirements we need a layer that performs type",
            "    conversions and then calls another LDAP API which is configurable",
            "    (e.g. either python-ldap or the fake emulation).",
            "",
            "    We have an addtional constraint at the time of this writing due to",
            "    limitations in the logging module. The logging module is not",
            "    capable of accepting UTF-8 encoded strings, it will throw an",
            "    encoding exception. Therefore all logging MUST be performed prior",
            "    to UTF-8 conversion. This means no logging can be performed in the",
            "    ldap APIs that implement the python-ldap API because those APIs",
            "    are defined to accept only UTF-8 strings. Thus the layer which",
            "    performs type conversions must also do the logging. We do the type",
            "    conversions in two steps, once to convert all Python types to",
            "    unicode strings, then log, then convert the unicode strings to",
            "    UTF-8.",
            "",
            "    There are a variety of ways one could accomplish this, we elect to",
            "    use a chaining technique whereby instances of this class simply",
            "    call the next member in the chain via the \"conn\" attribute. The",
            "    chain is constructed by passing in an existing instance of this",
            "    class as the conn attribute when the class is instantiated.",
            "",
            "    Here is a brief explanation of why other possible approaches were",
            "    not used:",
            "",
            "        subclassing",
            "",
            "            To perform the wrapping operations in the correct order",
            "            the type convesion class would have to subclass each of",
            "            the API providers. This is awkward, doubles the number of",
            "            classes, and does not scale well. It requires the type",
            "            conversion class to be aware of all possible API",
            "            providers.",
            "",
            "        decorators",
            "",
            "            Decorators provide an elegant solution to wrap methods and",
            "            would be an ideal way to perform type conversions before",
            "            calling the wrapped function and then converting the",
            "            values returned from the wrapped function. However",
            "            decorators need to be aware of the method signature, it",
            "            has to know what input parameters need conversion and how",
            "            to convert the result. For an API like python-ldap which",
            "            has a large number of different method signatures it would",
            "            require a large number of specialized",
            "            decorators. Experience has shown it's very easy to apply",
            "            the wrong decorator due to the inherent complexity and",
            "            tendency to cut-n-paste code. Another option is to",
            "            parameterize the decorator to make it \"smart\". Experience",
            "            has shown such decorators become insanely complicated and",
            "            difficult to understand and debug. Also decorators tend to",
            "            hide what's really going on when a method is called, the",
            "            operations being performed are not visible when looking at",
            "            the implemation of a decorated method, this too experience",
            "            has shown leads to mistakes.",
            "",
            "    Chaining simplifies both wrapping to perform type conversion as",
            "    well as the substitution of alternative API providers. One simply",
            "    creates a new instance of the API interface and insert it at the",
            "    front of the chain. Type conversions are explicit and obvious.",
            "",
            "    If a new method needs to be added to the API interface one adds it",
            "    to the abstract class definition. Should one miss adding the new",
            "    method to any derivations of the abstract class the code will fail",
            "    to load and run making it impossible to forget updating all the",
            "    derived classes.",
            "    '''",
            "    @abc.abstractmethod",
            "    def __init__(self, conn=None):",
            "        self.conn = conn",
            "",
            "    @abc.abstractmethod",
            "    def connect(self, url, page_size=0, alias_dereferencing=None,",
            "                use_tls=False, tls_cacertfile=None, tls_cacertdir=None,",
            "                tls_req_cert='demand', chase_referrals=None, debug_level=None):",
            "        raise exception.NotImplemented()",
            "",
            "    @abc.abstractmethod",
            "    def set_option(self, option, invalue):",
            "        raise exception.NotImplemented()",
            "",
            "    @abc.abstractmethod",
            "    def get_option(self, option):",
            "        raise exception.NotImplemented()",
            "",
            "    @abc.abstractmethod",
            "    def simple_bind_s(self, who='', cred='',",
            "                      serverctrls=None, clientctrls=None):",
            "        raise exception.NotImplemented()",
            "",
            "    @abc.abstractmethod",
            "    def unbind_s(self):",
            "        raise exception.NotImplemented()",
            "",
            "    @abc.abstractmethod",
            "    def add_s(self, dn, modlist):",
            "        raise exception.NotImplemented()",
            "",
            "    @abc.abstractmethod",
            "    def search_s(self, base, scope,",
            "                 filterstr='(objectClass=*)', attrlist=None, attrsonly=0):",
            "        raise exception.NotImplemented()",
            "",
            "    @abc.abstractmethod",
            "    def search_ext(self, base, scope,",
            "                   filterstr='(objectClass=*)', attrlist=None, attrsonly=0,",
            "                   serverctrls=None, clientctrls=None,",
            "                   timeout=-1, sizelimit=0):",
            "        raise exception.NotImplemented()",
            "",
            "    @abc.abstractmethod",
            "    def result3(self, msgid=ldap.RES_ANY, all=1, timeout=None,",
            "                resp_ctrl_classes=None):",
            "        raise exception.NotImplemented()",
            "",
            "    @abc.abstractmethod",
            "    def modify_s(self, dn, modlist):",
            "        raise exception.NotImplemented()",
            "",
            "    @abc.abstractmethod",
            "    def delete_s(self, dn):",
            "        raise exception.NotImplemented()",
            "",
            "    @abc.abstractmethod",
            "    def delete_ext_s(self, dn, serverctrls=None, clientctrls=None):",
            "        raise exception.NotImplemented()",
            "",
            "",
            "class PythonLDAPHandler(LDAPHandler):",
            "    '''Implementation of the LDAPHandler interface which calls the",
            "    python-ldap API.",
            "",
            "    Note, the python-ldap API requires all string values to be UTF-8",
            "    encoded. The KeystoneLDAPHandler enforces this prior to invoking",
            "    the methods in this class.",
            "    '''",
            "",
            "    def __init__(self, conn=None):",
            "        super(PythonLDAPHandler, self).__init__(conn=conn)",
            "",
            "    def connect(self, url, page_size=0, alias_dereferencing=None,",
            "                use_tls=False, tls_cacertfile=None, tls_cacertdir=None,",
            "                tls_req_cert='demand', chase_referrals=None, debug_level=None):",
            "        LOG.debug(\"LDAP init: url=%s\", url)",
            "        LOG.debug('LDAP init: use_tls=%s tls_cacertfile=%s tls_cacertdir=%s '",
            "                  'tls_req_cert=%s tls_avail=%s',",
            "                  use_tls, tls_cacertfile, tls_cacertdir,",
            "                  tls_req_cert, ldap.TLS_AVAIL)",
            "",
            "        if debug_level is not None:",
            "            ldap.set_option(ldap.OPT_DEBUG_LEVEL, debug_level)",
            "",
            "        using_ldaps = url.lower().startswith(\"ldaps\")",
            "",
            "        if use_tls and using_ldaps:",
            "            raise AssertionError(_('Invalid TLS / LDAPS combination'))",
            "",
            "        if use_tls:",
            "            if not ldap.TLS_AVAIL:",
            "                raise ValueError(_('Invalid LDAP TLS_AVAIL option: %s. TLS '",
            "                                   'not available') % ldap.TLS_AVAIL)",
            "            if tls_cacertfile:",
            "                # NOTE(topol)",
            "                # python ldap TLS does not verify CACERTFILE or CACERTDIR",
            "                # so we add some extra simple sanity check verification",
            "                # Also, setting these values globally (i.e. on the ldap object)",
            "                # works but these values are ignored when setting them on the",
            "                # connection",
            "                if not os.path.isfile(tls_cacertfile):",
            "                    raise IOError(_(\"tls_cacertfile %s not found \"",
            "                                    \"or is not a file\") %",
            "                                  tls_cacertfile)",
            "                ldap.set_option(ldap.OPT_X_TLS_CACERTFILE, tls_cacertfile)",
            "            elif tls_cacertdir:",
            "                # NOTE(topol)",
            "                # python ldap TLS does not verify CACERTFILE or CACERTDIR",
            "                # so we add some extra simple sanity check verification",
            "                # Also, setting these values globally (i.e. on the ldap object)",
            "                # works but these values are ignored when setting them on the",
            "                # connection",
            "                if not os.path.isdir(tls_cacertdir):",
            "                    raise IOError(_(\"tls_cacertdir %s not found \"",
            "                                    \"or is not a directory\") %",
            "                                  tls_cacertdir)",
            "                ldap.set_option(ldap.OPT_X_TLS_CACERTDIR, tls_cacertdir)",
            "            if tls_req_cert in LDAP_TLS_CERTS.values():",
            "                ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, tls_req_cert)",
            "            else:",
            "                LOG.debug(_(\"LDAP TLS: invalid TLS_REQUIRE_CERT Option=%s\"),",
            "                          tls_req_cert)",
            "",
            "        self.conn = ldap.initialize(url)",
            "        self.conn.protocol_version = ldap.VERSION3",
            "",
            "        if alias_dereferencing is not None:",
            "            self.conn.set_option(ldap.OPT_DEREF, alias_dereferencing)",
            "        self.page_size = page_size",
            "",
            "        if use_tls:",
            "            self.conn.start_tls_s()",
            "",
            "        if chase_referrals is not None:",
            "            self.conn.set_option(ldap.OPT_REFERRALS, int(chase_referrals))",
            "",
            "    def set_option(self, option, invalue):",
            "        return self.conn.set_option(option, invalue)",
            "",
            "    def get_option(self, option):",
            "        return self.conn.get_option(option)",
            "",
            "    def simple_bind_s(self, who='', cred='',",
            "                      serverctrls=None, clientctrls=None):",
            "        return self.conn.simple_bind_s(who, cred, serverctrls, clientctrls)",
            "",
            "    def unbind_s(self):",
            "        return self.conn.unbind_s()",
            "",
            "    def add_s(self, dn, modlist):",
            "        return self.conn.add_s(dn, modlist)",
            "",
            "    def search_s(self, base, scope,",
            "                 filterstr='(objectClass=*)', attrlist=None, attrsonly=0):",
            "        return self.conn.search_s(base, scope, filterstr,",
            "                                  attrlist, attrsonly)",
            "",
            "    def search_ext(self, base, scope,",
            "                   filterstr='(objectClass=*)', attrlist=None, attrsonly=0,",
            "                   serverctrls=None, clientctrls=None,",
            "                   timeout=-1, sizelimit=0):",
            "        return self.conn.search_ext(base, scope,",
            "                                    filterstr, attrlist, attrsonly,",
            "                                    serverctrls, clientctrls,",
            "                                    timeout, sizelimit)",
            "",
            "    def result3(self, msgid=ldap.RES_ANY, all=1, timeout=None,",
            "                resp_ctrl_classes=None):",
            "        # The resp_ctrl_classes parameter is a recent addition to the",
            "        # API. It defaults to None. We do not anticipate using it.",
            "        # To run with older versions of python-ldap we do not pass it.",
            "        return self.conn.result3(msgid, all, timeout)",
            "",
            "    def modify_s(self, dn, modlist):",
            "        return self.conn.modify_s(dn, modlist)",
            "",
            "    def delete_s(self, dn):",
            "        return self.conn.delete_s(dn)",
            "",
            "    def delete_ext_s(self, dn, serverctrls=None, clientctrls=None):",
            "        return self.conn.delete_ext_s(dn, serverctrls, clientctrls)",
            "",
            "",
            "class KeystoneLDAPHandler(LDAPHandler):",
            "    '''Convert data types and perform logging.",
            "",
            "    This LDAP inteface wraps the python-ldap based interfaces. The",
            "    python-ldap interfaces require string values encoded in UTF-8. The",
            "    OpenStack logging framework at the time of this writing is not",
            "    capable of accepting strings encoded in UTF-8, the log functions",
            "    will throw decoding errors if a non-ascii character appears in a",
            "    string.",
            "",
            "    Prior to the call Python data types are converted to a string",
            "    representation as required by the LDAP APIs.",
            "",
            "    Then logging is performed so we can track what is being",
            "    sent/received from LDAP. Also the logging filters security",
            "    sensitive items (i.e. passwords).",
            "",
            "    Then the string values are encoded into UTF-8.",
            "",
            "    Then the LDAP API entry point is invoked.",
            "",
            "    Data returned from the LDAP call is converted back from UTF-8",
            "    encoded strings into the Python data type used internally in",
            "    OpenStack.",
            "    '''",
            "",
            "    def __init__(self, conn=None):",
            "        super(KeystoneLDAPHandler, self).__init__(conn=conn)",
            "        self.page_size = 0",
            "",
            "    def _disable_paging(self):",
            "        # Disable the pagination from now on",
            "        self.page_size = 0",
            "",
            "    def connect(self, url, page_size=0, alias_dereferencing=None,",
            "                use_tls=False, tls_cacertfile=None, tls_cacertdir=None,",
            "                tls_req_cert='demand', chase_referrals=None, debug_level=None):",
            "        return self.conn.connect(url, page_size, alias_dereferencing,",
            "                                 use_tls, tls_cacertfile, tls_cacertdir,",
            "                                 tls_req_cert, chase_referrals,",
            "                                 debug_level=debug_level)",
            "",
            "    def set_option(self, option, invalue):",
            "        return self.conn.set_option(option, invalue)",
            "",
            "    def get_option(self, option):",
            "        return self.conn.get_option(option)",
            "",
            "    def simple_bind_s(self, who='', cred='',",
            "                      serverctrls=None, clientctrls=None):",
            "        LOG.debug(\"LDAP bind: who=%s\", who)",
            "        who_utf8 = utf8_encode(who)",
            "        cred_utf8 = utf8_encode(cred)",
            "        return self.conn.simple_bind_s(who_utf8, cred_utf8,",
            "                                       serverctrls, clientctrls)",
            "",
            "    def unbind_s(self):",
            "        LOG.debug(\"LDAP unbind\")",
            "        return self.conn.unbind_s()",
            "",
            "    def add_s(self, dn, modlist):",
            "        ldap_attrs = [(kind, [py2ldap(x) for x in safe_iter(values)])",
            "                      for kind, values in modlist]",
            "        logging_attrs = [(kind, values",
            "                         if kind != 'userPassword'",
            "                         else ['****'])",
            "                         for kind, values in ldap_attrs]",
            "        LOG.debug('LDAP add: dn=%s attrs=%s',",
            "                  dn, logging_attrs)",
            "        dn_utf8 = utf8_encode(dn)",
            "        ldap_attrs_utf8 = [(kind, [utf8_encode(x) for x in safe_iter(values)])",
            "                           for kind, values in ldap_attrs]",
            "        return self.conn.add_s(dn_utf8, ldap_attrs_utf8)",
            "",
            "    def search_s(self, base, scope,",
            "                 filterstr='(objectClass=*)', attrlist=None, attrsonly=0):",
            "        # NOTE(morganfainberg): Remove \"None\" singletons from this list, which",
            "        # allows us to set mapped attributes to \"None\" as defaults in config.",
            "        # Without this filtering, the ldap query would raise a TypeError since",
            "        # attrlist is expected to be an iterable of strings.",
            "        if attrlist is not None:",
            "            attrlist = [attr for attr in attrlist if attr is not None]",
            "        LOG.debug('LDAP search: base=%s scope=%s filterstr=%s '",
            "                  'attrs=%s attrsonly=%s',",
            "                  base, scope, filterstr, attrlist, attrsonly)",
            "        if self.page_size:",
            "            ldap_result = self._paged_search_s(base, scope,",
            "                                               filterstr, attrlist)",
            "        else:",
            "            base_utf8 = utf8_encode(base)",
            "            filterstr_utf8 = utf8_encode(filterstr)",
            "            if attrlist is None:",
            "                attrlist_utf8 = None",
            "            else:",
            "                attrlist_utf8 = map(utf8_encode, attrlist)",
            "            ldap_result = self.conn.search_s(base_utf8, scope,",
            "                                             filterstr_utf8,",
            "                                             attrlist_utf8, attrsonly)",
            "",
            "        py_result = convert_ldap_result(ldap_result)",
            "",
            "        return py_result",
            "",
            "    def search_ext(self, base, scope,",
            "                   filterstr='(objectClass=*)', attrlist=None, attrsonly=0,",
            "                   serverctrls=None, clientctrls=None,",
            "                   timeout=-1, sizelimit=0):",
            "        if attrlist is not None:",
            "            attrlist = [attr for attr in attrlist if attr is not None]",
            "        LOG.debug('LDAP search_ext: base=%s scope=%s filterstr=%s '",
            "                  'attrs=%s attrsonly=%s'",
            "                  'serverctrls=%s clientctrls=%s timeout=%s sizelimit=%s',",
            "                  base, scope, filterstr, attrlist, attrsonly,",
            "                  serverctrls, clientctrls, timeout, sizelimit)",
            "        return self.conn.search_ext(base, scope,",
            "                                    filterstr, attrlist, attrsonly,",
            "                                    serverctrls, clientctrls,",
            "                                    timeout, sizelimit)",
            "",
            "    def _paged_search_s(self, base, scope, filterstr, attrlist=None):",
            "        res = []",
            "        lc = ldap.controls.SimplePagedResultsControl(",
            "            controlType=ldap.LDAP_CONTROL_PAGE_OID,",
            "            criticality=True,",
            "            controlValue=(self.page_size, ''))",
            "        base_utf8 = utf8_encode(base)",
            "        filterstr_utf8 = utf8_encode(filterstr)",
            "        if attrlist is None:",
            "            attrlist_utf8 = None",
            "        else:",
            "            attrlist = [attr for attr in attrlist if attr is not None]",
            "            attrlist_utf8 = map(utf8_encode, attrlist)",
            "        msgid = self.conn.search_ext(base_utf8,",
            "                                     scope,",
            "                                     filterstr_utf8,",
            "                                     attrlist_utf8,",
            "                                     serverctrls=[lc])",
            "        # Endless loop request pages on ldap server until it has no data",
            "        while True:",
            "            # Request to the ldap server a page with 'page_size' entries",
            "            rtype, rdata, rmsgid, serverctrls = self.conn.result3(msgid)",
            "            # Receive the data",
            "            res.extend(rdata)",
            "            pctrls = [c for c in serverctrls",
            "                      if c.controlType == ldap.LDAP_CONTROL_PAGE_OID]",
            "            if pctrls:",
            "                # LDAP server supports pagination",
            "                est, cookie = pctrls[0].controlValue",
            "                if cookie:",
            "                    # There is more data still on the server",
            "                    # so we request another page",
            "                    lc.controlValue = (self.page_size, cookie)",
            "                    msgid = self.conn.search_ext(base_utf8,",
            "                                                 scope,",
            "                                                 filterstr_utf8,",
            "                                                 attrlist_utf8,",
            "                                                 serverctrls=[lc])",
            "                else:",
            "                    # Exit condition no more data on server",
            "                    break",
            "            else:",
            "                LOG.warning(_('LDAP Server does not support paging. '",
            "                              'Disable paging in keystone.conf to '",
            "                              'avoid this message.'))",
            "                self._disable_paging()",
            "                break",
            "        return res",
            "",
            "    def result3(self, msgid=ldap.RES_ANY, all=1, timeout=None,",
            "                resp_ctrl_classes=None):",
            "        ldap_result = self.conn.result3(msgid, all, timeout, resp_ctrl_classes)",
            "",
            "        LOG.debug('LDAP result3: msgid=%s all=%s timeout=%s '",
            "                  'resp_ctrl_classes=%s ldap_result=%s',",
            "                  msgid, all, timeout, resp_ctrl_classes, ldap_result)",
            "",
            "        py_result = convert_ldap_result(ldap_result)",
            "        return py_result",
            "",
            "    def modify_s(self, dn, modlist):",
            "        ldap_modlist = [",
            "            (op, kind, (None if values is None",
            "                        else [py2ldap(x) for x in safe_iter(values)]))",
            "            for op, kind, values in modlist]",
            "",
            "        logging_modlist = [(op, kind, (values if kind != 'userPassword'",
            "                           else ['****']))",
            "                           for op, kind, values in ldap_modlist]",
            "        LOG.debug('LDAP modify: dn=%s modlist=%s',",
            "                  dn, logging_modlist)",
            "",
            "        dn_utf8 = utf8_encode(dn)",
            "        ldap_modlist_utf8 = [",
            "            (op, kind, (None if values is None",
            "                        else [utf8_encode(x) for x in safe_iter(values)]))",
            "            for op, kind, values in ldap_modlist]",
            "        return self.conn.modify_s(dn_utf8, ldap_modlist_utf8)",
            "",
            "    def delete_s(self, dn):",
            "        LOG.debug(\"LDAP delete: dn=%s\", dn)",
            "        dn_utf8 = utf8_encode(dn)",
            "        return self.conn.delete_s(dn_utf8)",
            "",
            "    def delete_ext_s(self, dn, serverctrls=None, clientctrls=None):",
            "        LOG.debug('LDAP delete_ext: dn=%s serverctrls=%s clientctrls=%s',",
            "                  dn, serverctrls, clientctrls)",
            "        dn_utf8 = utf8_encode(dn)",
            "        return self.conn.delete_ext_s(dn_utf8, serverctrls, clientctrls)",
            "",
            "",
            "_HANDLERS = {}",
            "",
            "",
            "def register_handler(prefix, handler):",
            "    _HANDLERS[prefix] = handler",
            "",
            "",
            "def _get_connection(conn_url):",
            "    for prefix, handler in six.iteritems(_HANDLERS):",
            "        if conn_url.startswith(prefix):",
            "            return handler()",
            "",
            "    return PythonLDAPHandler()",
            "",
            "",
            "def filter_entity(entity_ref):",
            "    \"\"\"Filter out private items in an entity dict.",
            "",
            "    :param entity_ref:  the entity dictionary. The 'dn' field will be removed.",
            "        'dn' is used in LDAP, but should not be returned to the user.  This",
            "        value may be modified.",
            "",
            "    :returns: entity_ref",
            "",
            "    \"\"\"",
            "    if entity_ref:",
            "        entity_ref.pop('dn', None)",
            "    return entity_ref",
            "",
            "",
            "class BaseLdap(object):",
            "    DEFAULT_SUFFIX = \"dc=example,dc=com\"",
            "    DEFAULT_OU = None",
            "    DEFAULT_STRUCTURAL_CLASSES = None",
            "    DEFAULT_ID_ATTR = 'cn'",
            "    DEFAULT_OBJECTCLASS = None",
            "    DEFAULT_FILTER = None",
            "    DEFAULT_EXTRA_ATTR_MAPPING = []",
            "    DUMB_MEMBER_DN = 'cn=dumb,dc=nonexistent'",
            "    NotFound = None",
            "    notfound_arg = None",
            "    options_name = None",
            "    model = None",
            "    attribute_options_names = {}",
            "    immutable_attrs = []",
            "    attribute_ignore = []",
            "    tree_dn = None",
            "",
            "    def __init__(self, conf):",
            "        self.LDAP_URL = conf.ldap.url",
            "        self.LDAP_USER = conf.ldap.user",
            "        self.LDAP_PASSWORD = conf.ldap.password",
            "        self.LDAP_SCOPE = ldap_scope(conf.ldap.query_scope)",
            "        self.alias_dereferencing = parse_deref(conf.ldap.alias_dereferencing)",
            "        self.page_size = conf.ldap.page_size",
            "        self.use_tls = conf.ldap.use_tls",
            "        self.tls_cacertfile = conf.ldap.tls_cacertfile",
            "        self.tls_cacertdir = conf.ldap.tls_cacertdir",
            "        self.tls_req_cert = parse_tls_cert(conf.ldap.tls_req_cert)",
            "        self.attribute_mapping = {}",
            "        self.chase_referrals = conf.ldap.chase_referrals",
            "        self.debug_level = conf.ldap.debug_level",
            "",
            "        if self.options_name is not None:",
            "            self.suffix = conf.ldap.suffix",
            "            if self.suffix is None:",
            "                self.suffix = self.DEFAULT_SUFFIX",
            "            dn = '%s_tree_dn' % self.options_name",
            "            self.tree_dn = (getattr(conf.ldap, dn)",
            "                            or '%s,%s' % (self.DEFAULT_OU, self.suffix))",
            "",
            "            idatt = '%s_id_attribute' % self.options_name",
            "            self.id_attr = getattr(conf.ldap, idatt) or self.DEFAULT_ID_ATTR",
            "",
            "            objclass = '%s_objectclass' % self.options_name",
            "            self.object_class = (getattr(conf.ldap, objclass)",
            "                                 or self.DEFAULT_OBJECTCLASS)",
            "",
            "            for k, v in six.iteritems(self.attribute_options_names):",
            "                v = '%s_%s_attribute' % (self.options_name, v)",
            "                self.attribute_mapping[k] = getattr(conf.ldap, v)",
            "",
            "            attr_mapping_opt = ('%s_additional_attribute_mapping' %",
            "                                self.options_name)",
            "            attr_mapping = (getattr(conf.ldap, attr_mapping_opt)",
            "                            or self.DEFAULT_EXTRA_ATTR_MAPPING)",
            "            self.extra_attr_mapping = self._parse_extra_attrs(attr_mapping)",
            "",
            "            ldap_filter = '%s_filter' % self.options_name",
            "            self.ldap_filter = getattr(conf.ldap,",
            "                                       ldap_filter) or self.DEFAULT_FILTER",
            "",
            "            allow_create = '%s_allow_create' % self.options_name",
            "            self.allow_create = getattr(conf.ldap, allow_create)",
            "",
            "            allow_update = '%s_allow_update' % self.options_name",
            "            self.allow_update = getattr(conf.ldap, allow_update)",
            "",
            "            allow_delete = '%s_allow_delete' % self.options_name",
            "            self.allow_delete = getattr(conf.ldap, allow_delete)",
            "",
            "            member_attribute = '%s_member_attribute' % self.options_name",
            "            self.member_attribute = getattr(conf.ldap, member_attribute, None)",
            "",
            "            self.structural_classes = self.DEFAULT_STRUCTURAL_CLASSES",
            "",
            "            if self.notfound_arg is None:",
            "                self.notfound_arg = self.options_name + '_id'",
            "",
            "            attribute_ignore = '%s_attribute_ignore' % self.options_name",
            "            self.attribute_ignore = getattr(conf.ldap, attribute_ignore)",
            "",
            "        self.use_dumb_member = getattr(conf.ldap, 'use_dumb_member')",
            "        self.dumb_member = (getattr(conf.ldap, 'dumb_member') or",
            "                            self.DUMB_MEMBER_DN)",
            "",
            "        self.subtree_delete_enabled = getattr(conf.ldap,",
            "                                              'allow_subtree_delete')",
            "",
            "    def _not_found(self, object_id):",
            "        if self.NotFound is None:",
            "            return exception.NotFound(target=object_id)",
            "        else:",
            "            return self.NotFound(**{self.notfound_arg: object_id})",
            "",
            "    def _parse_extra_attrs(self, option_list):",
            "        mapping = {}",
            "        for item in option_list:",
            "            try:",
            "                ldap_attr, attr_map = item.split(':')",
            "            except Exception:",
            "                LOG.warn(_(",
            "                    'Invalid additional attribute mapping: \"%s\". '",
            "                    'Format must be <ldap_attribute>:<keystone_attribute>'),",
            "                    item)",
            "                continue",
            "            mapping[ldap_attr] = attr_map",
            "        return mapping",
            "",
            "    def get_connection(self, user=None, password=None):",
            "        conn = _get_connection(self.LDAP_URL)",
            "",
            "        conn = KeystoneLDAPHandler(conn=conn)",
            "",
            "        conn.connect(self.LDAP_URL,",
            "                     page_size=self.page_size,",
            "                     alias_dereferencing=self.alias_dereferencing,",
            "                     use_tls=self.use_tls,",
            "                     tls_cacertfile=self.tls_cacertfile,",
            "                     tls_cacertdir=self.tls_cacertdir,",
            "                     tls_req_cert=self.tls_req_cert,",
            "                     chase_referrals=self.chase_referrals,",
            "                     debug_level=self.debug_level)",
            "",
            "        if user is None:",
            "            user = self.LDAP_USER",
            "",
            "        if password is None:",
            "            password = self.LDAP_PASSWORD",
            "",
            "        # not all LDAP servers require authentication, so we don't bind",
            "        # if we don't have any user/pass",
            "        if user and password:",
            "            conn.simple_bind_s(user, password)",
            "",
            "        return conn",
            "",
            "    def _id_to_dn_string(self, object_id):",
            "        return u'%s=%s,%s' % (self.id_attr,",
            "                              ldap.dn.escape_dn_chars(",
            "                                  six.text_type(object_id)),",
            "                              self.tree_dn)",
            "",
            "    def _id_to_dn(self, object_id):",
            "        if self.LDAP_SCOPE == ldap.SCOPE_ONELEVEL:",
            "            return self._id_to_dn_string(object_id)",
            "        conn = self.get_connection()",
            "        try:",
            "            search_result = conn.search_s(",
            "                self.tree_dn, self.LDAP_SCOPE,",
            "                u'(&(%(id_attr)s=%(id)s)(objectclass=%(objclass)s))' %",
            "                {'id_attr': self.id_attr,",
            "                 'id': ldap.filter.escape_filter_chars(",
            "                     six.text_type(object_id)),",
            "                 'objclass': self.object_class})",
            "        finally:",
            "            conn.unbind_s()",
            "        if search_result:",
            "            dn, attrs = search_result[0]",
            "            return dn",
            "        else:",
            "            return self._id_to_dn_string(object_id)",
            "",
            "    @staticmethod",
            "    def _dn_to_id(dn):",
            "        return utf8_decode(ldap.dn.str2dn(utf8_encode(dn))[0][0][1])",
            "",
            "    def _ldap_res_to_model(self, res):",
            "        obj = self.model(id=self._dn_to_id(res[0]))",
            "        # LDAP attribute names may be returned in a different case than",
            "        # they are defined in the mapping, so we need to check for keys",
            "        # in a case-insensitive way.  We use the case specified in the",
            "        # mapping for the model to ensure we have a predictable way of",
            "        # retrieving values later.",
            "        lower_res = dict((k.lower(), v) for k, v in six.iteritems(res[1]))",
            "        for k in obj.known_keys:",
            "            if k in self.attribute_ignore:",
            "                continue",
            "",
            "            try:",
            "                v = lower_res[self.attribute_mapping.get(k, k).lower()]",
            "            except KeyError:",
            "                pass",
            "            else:",
            "                try:",
            "                    obj[k] = v[0]",
            "                except IndexError:",
            "                    obj[k] = None",
            "",
            "        return obj",
            "",
            "    def check_allow_create(self):",
            "        if not self.allow_create:",
            "            action = _('LDAP %s create') % self.options_name",
            "            raise exception.ForbiddenAction(action=action)",
            "",
            "    def check_allow_update(self):",
            "        if not self.allow_update:",
            "            action = _('LDAP %s update') % self.options_name",
            "            raise exception.ForbiddenAction(action=action)",
            "",
            "    def check_allow_delete(self):",
            "        if not self.allow_delete:",
            "            action = _('LDAP %s delete') % self.options_name",
            "            raise exception.ForbiddenAction(action=action)",
            "",
            "    def affirm_unique(self, values):",
            "        if values.get('name') is not None:",
            "            try:",
            "                self.get_by_name(values['name'])",
            "            except exception.NotFound:",
            "                pass",
            "            else:",
            "                raise exception.Conflict(type=self.options_name,",
            "                                         details=_('Duplicate name, %s.') %",
            "                                         values['name'])",
            "",
            "        if values.get('id') is not None:",
            "            try:",
            "                self.get(values['id'])",
            "            except exception.NotFound:",
            "                pass",
            "            else:",
            "                raise exception.Conflict(type=self.options_name,",
            "                                         details=_('Duplicate ID, %s.') %",
            "                                         values['id'])",
            "",
            "    def create(self, values):",
            "        self.affirm_unique(values)",
            "        conn = self.get_connection()",
            "        object_classes = self.structural_classes + [self.object_class]",
            "        attrs = [('objectClass', object_classes)]",
            "        for k, v in six.iteritems(values):",
            "            if k == 'id' or k in self.attribute_ignore:",
            "                continue",
            "            if v is not None:",
            "                attr_type = self.attribute_mapping.get(k, k)",
            "                if attr_type is not None:",
            "                    attrs.append((attr_type, [v]))",
            "                extra_attrs = [attr for attr, name",
            "                               in six.iteritems(self.extra_attr_mapping)",
            "                               if name == k]",
            "                for attr in extra_attrs:",
            "                    attrs.append((attr, [v]))",
            "",
            "        if 'groupOfNames' in object_classes and self.use_dumb_member:",
            "            attrs.append(('member', [self.dumb_member]))",
            "        try:",
            "            conn.add_s(self._id_to_dn(values['id']), attrs)",
            "        finally:",
            "            conn.unbind_s()",
            "        return values",
            "",
            "    def _ldap_get(self, object_id, ldap_filter=None):",
            "        conn = self.get_connection()",
            "        query = (u'(&(%(id_attr)s=%(id)s)'",
            "                 u'%(filter)s'",
            "                 u'(objectClass=%(object_class)s))'",
            "                 % {'id_attr': self.id_attr,",
            "                    'id': ldap.filter.escape_filter_chars(",
            "                        six.text_type(object_id)),",
            "                    'filter': (ldap_filter or self.ldap_filter or ''),",
            "                    'object_class': self.object_class})",
            "        try:",
            "            attrs = list(set((self.attribute_mapping.values() +",
            "                              self.extra_attr_mapping.keys())))",
            "            res = conn.search_s(self.tree_dn, self.LDAP_SCOPE, query, attrs)",
            "        except ldap.NO_SUCH_OBJECT:",
            "            return None",
            "        finally:",
            "            conn.unbind_s()",
            "        try:",
            "            return res[0]",
            "        except IndexError:",
            "            return None",
            "",
            "    def _ldap_get_all(self, ldap_filter=None):",
            "        conn = self.get_connection()",
            "        query = u'(&%s(objectClass=%s))' % (ldap_filter or",
            "                                            self.ldap_filter or",
            "                                            '', self.object_class)",
            "        try:",
            "            attrs = list(set((self.attribute_mapping.values() +",
            "                              self.extra_attr_mapping.keys())))",
            "            return conn.search_s(self.tree_dn,",
            "                                 self.LDAP_SCOPE,",
            "                                 query,",
            "                                 attrs)",
            "        except ldap.NO_SUCH_OBJECT:",
            "            return []",
            "        finally:",
            "            conn.unbind_s()",
            "",
            "    def _ldap_get_list(self, search_base, scope, query_params=None,",
            "                       attrlist=None):",
            "        conn = self.get_connection()",
            "        query = u'(objectClass=%s)' % self.object_class",
            "        if query_params:",
            "",
            "            def calc_filter(attrname, value):",
            "                val_esc = ldap.filter.escape_filter_chars(value)",
            "                return '(%s=%s)' % (attrname, val_esc)",
            "",
            "            query = (u'(&%s%s)' %",
            "                     (query, ''.join([calc_filter(k, v) for k, v in",
            "                                      six.iteritems(query_params)])))",
            "        try:",
            "            return conn.search_s(search_base, scope, query, attrlist)",
            "        finally:",
            "            conn.unbind_s()",
            "",
            "    def get(self, object_id, ldap_filter=None):",
            "        res = self._ldap_get(object_id, ldap_filter)",
            "        if res is None:",
            "            raise self._not_found(object_id)",
            "        else:",
            "            return self._ldap_res_to_model(res)",
            "",
            "    def get_by_name(self, name, ldap_filter=None):",
            "        query = (u'(%s=%s)' % (self.attribute_mapping['name'],",
            "                               ldap.filter.escape_filter_chars(",
            "                                   six.text_type(name))))",
            "        res = self.get_all(query)",
            "        try:",
            "            return res[0]",
            "        except IndexError:",
            "            raise self._not_found(name)",
            "",
            "    def get_all(self, ldap_filter=None):",
            "        return [self._ldap_res_to_model(x)",
            "                for x in self._ldap_get_all(ldap_filter)]",
            "",
            "    def update(self, object_id, values, old_obj=None):",
            "        if old_obj is None:",
            "            old_obj = self.get(object_id)",
            "",
            "        modlist = []",
            "        for k, v in six.iteritems(values):",
            "            if k == 'id' or k in self.attribute_ignore:",
            "                continue",
            "",
            "            # attribute value has not changed",
            "            if k in old_obj and old_obj[k] == v:",
            "                continue",
            "",
            "            if k in self.immutable_attrs:",
            "                msg = (_(\"Cannot change %(option_name)s %(attr)s\") %",
            "                       {'option_name': self.options_name, 'attr': k})",
            "                raise exception.ValidationError(msg)",
            "",
            "            if v is None:",
            "                if old_obj.get(k) is not None:",
            "                    modlist.append((ldap.MOD_DELETE,",
            "                                    self.attribute_mapping.get(k, k),",
            "                                    None))",
            "                continue",
            "",
            "            current_value = old_obj.get(k)",
            "            if current_value is None:",
            "                op = ldap.MOD_ADD",
            "                modlist.append((op, self.attribute_mapping.get(k, k), [v]))",
            "            elif current_value != v:",
            "                op = ldap.MOD_REPLACE",
            "                modlist.append((op, self.attribute_mapping.get(k, k), [v]))",
            "",
            "        if modlist:",
            "            conn = self.get_connection()",
            "            try:",
            "                conn.modify_s(self._id_to_dn(object_id), modlist)",
            "            except ldap.NO_SUCH_OBJECT:",
            "                raise self._not_found(object_id)",
            "            finally:",
            "                conn.unbind_s()",
            "",
            "        return self.get(object_id)",
            "",
            "    def delete(self, object_id):",
            "        conn = self.get_connection()",
            "        try:",
            "            conn.delete_s(self._id_to_dn(object_id))",
            "        except ldap.NO_SUCH_OBJECT:",
            "            raise self._not_found(object_id)",
            "        finally:",
            "            conn.unbind_s()",
            "",
            "    def deleteTree(self, object_id):",
            "        conn = self.get_connection()",
            "        tree_delete_control = ldap.controls.LDAPControl(CONTROL_TREEDELETE,",
            "                                                        0,",
            "                                                        None)",
            "        try:",
            "            conn.delete_ext_s(self._id_to_dn(object_id),",
            "                              serverctrls=[tree_delete_control])",
            "        except ldap.NO_SUCH_OBJECT:",
            "            raise self._not_found(object_id)",
            "        finally:",
            "            conn.unbind_s()",
            "",
            "    def add_member(self, member_dn, member_list_dn):",
            "        \"\"\"Add member to the member list.",
            "",
            "        :param member_dn: DN of member to be added.",
            "        :param member_list_dn: DN of group to which the",
            "                               member will be added.",
            "",
            "        :raises: exception.Conflict: If the user was already a member.",
            "                 self.NotFound: If the group entry didn't exist.",
            "        \"\"\"",
            "        conn = self.get_connection()",
            "        try:",
            "            mod = (ldap.MOD_ADD, self.member_attribute, member_dn)",
            "            conn.modify_s(member_list_dn, [mod])",
            "        except ldap.TYPE_OR_VALUE_EXISTS:",
            "            raise exception.Conflict(_('Member %(member)s is already a member'",
            "                                       ' of group %(group)s') % {",
            "                                     'member': member_dn,",
            "                                     'group': member_list_dn})",
            "        except ldap.NO_SUCH_OBJECT:",
            "            raise self._not_found(member_list_dn)",
            "        finally:",
            "            conn.unbind_s()",
            "",
            "    def remove_member(self, member_dn, member_list_dn):",
            "        \"\"\"Remove member from the member list.",
            "",
            "        :param member_dn: DN of member to be removed.",
            "        :param member_list_dn: DN of group from which the",
            "                               member will be removed.",
            "",
            "        :raises: self.NotFound: If the group entry didn't exist.",
            "                 ldap.NO_SUCH_ATTRIBUTE: If the user wasn't a member.",
            "        \"\"\"",
            "        conn = self.get_connection()",
            "        try:",
            "            mod = (ldap.MOD_DELETE, self.member_attribute, member_dn)",
            "            conn.modify_s(member_list_dn, [mod])",
            "        except ldap.NO_SUCH_OBJECT:",
            "            raise self._not_found(member_list_dn)",
            "        finally:",
            "            conn.unbind_s()",
            "",
            "",
            "class EnabledEmuMixIn(BaseLdap):",
            "    \"\"\"Emulates boolean 'enabled' attribute if turned on.",
            "",
            "    Creates groupOfNames holding all enabled objects of this class, all missing",
            "    objects are considered disabled.",
            "",
            "    Options:",
            "",
            "    * $name_enabled_emulation - boolean, on/off",
            "    * $name_enabled_emulation_dn - DN of that groupOfNames, default is",
            "      cn=enabled_${name}s,${tree_dn}",
            "",
            "    Where ${name}s is the plural of self.options_name ('users' or 'tenants'),",
            "    ${tree_dn} is self.tree_dn.",
            "    \"\"\"",
            "",
            "    def __init__(self, conf):",
            "        super(EnabledEmuMixIn, self).__init__(conf)",
            "        enabled_emulation = '%s_enabled_emulation' % self.options_name",
            "        self.enabled_emulation = getattr(conf.ldap, enabled_emulation)",
            "",
            "        enabled_emulation_dn = '%s_enabled_emulation_dn' % self.options_name",
            "        self.enabled_emulation_dn = getattr(conf.ldap, enabled_emulation_dn)",
            "        if not self.enabled_emulation_dn:",
            "            self.enabled_emulation_dn = ('cn=enabled_%ss,%s' %",
            "                                         (self.options_name, self.tree_dn))",
            "",
            "    def _get_enabled(self, object_id):",
            "        conn = self.get_connection()",
            "        dn = self._id_to_dn(object_id)",
            "        query = '(member=%s)' % dn",
            "        try:",
            "            enabled_value = conn.search_s(self.enabled_emulation_dn,",
            "                                          ldap.SCOPE_BASE,",
            "                                          query, ['cn'])",
            "        except ldap.NO_SUCH_OBJECT:",
            "            return False",
            "        else:",
            "            return bool(enabled_value)",
            "        finally:",
            "            conn.unbind_s()",
            "",
            "    def _add_enabled(self, object_id):",
            "        if not self._get_enabled(object_id):",
            "            conn = self.get_connection()",
            "            modlist = [(ldap.MOD_ADD,",
            "                        'member',",
            "                        [self._id_to_dn(object_id)])]",
            "            try:",
            "                conn.modify_s(self.enabled_emulation_dn, modlist)",
            "            except ldap.NO_SUCH_OBJECT:",
            "                attr_list = [('objectClass', ['groupOfNames']),",
            "                             ('member',",
            "                                 [self._id_to_dn(object_id)])]",
            "                if self.use_dumb_member:",
            "                    attr_list[1][1].append(self.dumb_member)",
            "                conn.add_s(self.enabled_emulation_dn, attr_list)",
            "            finally:",
            "                conn.unbind_s()",
            "",
            "    def _remove_enabled(self, object_id):",
            "        conn = self.get_connection()",
            "        modlist = [(ldap.MOD_DELETE,",
            "                    'member',",
            "                    [self._id_to_dn(object_id)])]",
            "        try:",
            "            conn.modify_s(self.enabled_emulation_dn, modlist)",
            "        except (ldap.NO_SUCH_OBJECT, ldap.NO_SUCH_ATTRIBUTE):",
            "            pass",
            "        finally:",
            "            conn.unbind_s()",
            "",
            "    def create(self, values):",
            "        if self.enabled_emulation:",
            "            enabled_value = values.pop('enabled', True)",
            "            ref = super(EnabledEmuMixIn, self).create(values)",
            "            if 'enabled' not in self.attribute_ignore:",
            "                if enabled_value:",
            "                    self._add_enabled(ref['id'])",
            "                ref['enabled'] = enabled_value",
            "            return ref",
            "        else:",
            "            return super(EnabledEmuMixIn, self).create(values)",
            "",
            "    def get(self, object_id, ldap_filter=None):",
            "        ref = super(EnabledEmuMixIn, self).get(object_id, ldap_filter)",
            "        if 'enabled' not in self.attribute_ignore and self.enabled_emulation:",
            "            ref['enabled'] = self._get_enabled(object_id)",
            "        return ref",
            "",
            "    def get_all(self, ldap_filter=None):",
            "        if 'enabled' not in self.attribute_ignore and self.enabled_emulation:",
            "            # had to copy BaseLdap.get_all here to ldap_filter by DN",
            "            tenant_list = [self._ldap_res_to_model(x)",
            "                           for x in self._ldap_get_all(ldap_filter)",
            "                           if x[0] != self.enabled_emulation_dn]",
            "            for tenant_ref in tenant_list:",
            "                tenant_ref['enabled'] = self._get_enabled(tenant_ref['id'])",
            "            return tenant_list",
            "        else:",
            "            return super(EnabledEmuMixIn, self).get_all(ldap_filter)",
            "",
            "    def update(self, object_id, values, old_obj=None):",
            "        if 'enabled' not in self.attribute_ignore and self.enabled_emulation:",
            "            data = values.copy()",
            "            enabled_value = data.pop('enabled', None)",
            "            ref = super(EnabledEmuMixIn, self).update(object_id, data, old_obj)",
            "            if enabled_value is not None:",
            "                if enabled_value:",
            "                    self._add_enabled(object_id)",
            "                else:",
            "                    self._remove_enabled(object_id)",
            "            return ref",
            "        else:",
            "            return super(EnabledEmuMixIn, self).update(",
            "                object_id, values, old_obj)",
            "",
            "    def delete(self, object_id):",
            "        if self.enabled_emulation:",
            "            self._remove_enabled(object_id)",
            "        super(EnabledEmuMixIn, self).delete(object_id)"
        ],
        "afterPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import abc",
            "import os.path",
            "import re",
            "",
            "import codecs",
            "import ldap",
            "import ldap.filter",
            "import six",
            "",
            "from keystone import exception",
            "from keystone.openstack.common.gettextutils import _",
            "from keystone.openstack.common import log",
            "",
            "LOG = log.getLogger(__name__)",
            "",
            "",
            "LDAP_VALUES = {'TRUE': True, 'FALSE': False}",
            "CONTROL_TREEDELETE = '1.2.840.113556.1.4.805'",
            "LDAP_SCOPES = {'one': ldap.SCOPE_ONELEVEL,",
            "               'sub': ldap.SCOPE_SUBTREE}",
            "LDAP_DEREF = {'always': ldap.DEREF_ALWAYS,",
            "              'default': None,",
            "              'finding': ldap.DEREF_FINDING,",
            "              'never': ldap.DEREF_NEVER,",
            "              'searching': ldap.DEREF_SEARCHING}",
            "LDAP_TLS_CERTS = {'never': ldap.OPT_X_TLS_NEVER,",
            "                  'demand': ldap.OPT_X_TLS_DEMAND,",
            "                  'allow': ldap.OPT_X_TLS_ALLOW}",
            "",
            "",
            "_utf8_encoder = codecs.getencoder('utf-8')",
            "",
            "",
            "def utf8_encode(value):",
            "    if isinstance(value, six.text_type):",
            "        return _utf8_encoder(value)[0]",
            "    elif isinstance(value, six.binary_type):",
            "        return value",
            "    else:",
            "        raise TypeError(\"value must be basestring, \"",
            "                        \"not %s\" % value.__class__.__name__)",
            "",
            "_utf8_decoder = codecs.getdecoder('utf-8')",
            "",
            "",
            "def utf8_decode(value):",
            "    if isinstance(value, six.binary_type):",
            "        return _utf8_decoder(value)[0]",
            "    return six.text_type(value)",
            "",
            "",
            "def py2ldap(val):",
            "    if isinstance(val, bool):",
            "        return u'TRUE' if val else u'FALSE'",
            "    else:",
            "        return six.text_type(val)",
            "",
            "",
            "def ldap2py(val):",
            "    try:",
            "        return LDAP_VALUES[val]",
            "    except KeyError:",
            "        pass",
            "    try:",
            "        return int(val)",
            "    except ValueError:",
            "        pass",
            "    return utf8_decode(val)",
            "",
            "",
            "def convert_ldap_result(ldap_result):",
            "    py_result = []",
            "    at_least_one_referral = False",
            "    for dn, attrs in ldap_result:",
            "        if dn is None:",
            "            # this is a Referral object, rather than an Entry object",
            "            at_least_one_referral = True",
            "            continue",
            "",
            "        py_result.append((utf8_decode(dn),",
            "                          dict((kind, [ldap2py(x) for x in values])",
            "                               for kind, values in six.iteritems(attrs))))",
            "    if at_least_one_referral:",
            "        LOG.debug(_('Referrals were returned and ignored. Enable referral '",
            "                    'chasing in keystone.conf via [ldap] chase_referrals'))",
            "",
            "    return py_result",
            "",
            "",
            "def safe_iter(attrs):",
            "    if attrs is None:",
            "        return",
            "    elif isinstance(attrs, list):",
            "        for e in attrs:",
            "            yield e",
            "    else:",
            "        yield attrs",
            "",
            "",
            "def parse_deref(opt):",
            "    try:",
            "        return LDAP_DEREF[opt]",
            "    except KeyError:",
            "        raise ValueError(_('Invalid LDAP deref option: %(option)s. '",
            "                           'Choose one of: %(options)s') %",
            "                         {'option': opt,",
            "                          'options': ', '.join(LDAP_DEREF.keys()), })",
            "",
            "",
            "def parse_tls_cert(opt):",
            "    try:",
            "        return LDAP_TLS_CERTS[opt]",
            "    except KeyError:",
            "        raise ValueError(_(",
            "            'Invalid LDAP TLS certs option: %(option)s. '",
            "            'Choose one of: %(options)s') % {",
            "                'option': opt,",
            "                'options': ', '.join(LDAP_TLS_CERTS.keys())})",
            "",
            "",
            "def ldap_scope(scope):",
            "    try:",
            "        return LDAP_SCOPES[scope]",
            "    except KeyError:",
            "        raise ValueError(",
            "            _('Invalid LDAP scope: %(scope)s. Choose one of: %(options)s') % {",
            "                'scope': scope,",
            "                'options': ', '.join(LDAP_SCOPES.keys())})",
            "",
            "",
            "def prep_case_insensitive(value):",
            "    \"\"\"Prepare a string for case-insensitive comparison.",
            "",
            "    This is defined in RFC4518. For simplicity, all this function does is",
            "    lowercase all the characters, strip leading and trailing whitespace,",
            "    and compress sequences of spaces to a single space.",
            "    \"\"\"",
            "    value = re.sub(r'\\s+', ' ', value.strip().lower())",
            "    return value",
            "",
            "",
            "def is_ava_value_equal(attribute_type, val1, val2):",
            "    \"\"\"Returns True if and only if the AVAs are equal.",
            "",
            "    When comparing AVAs, the equality matching rule for the attribute type",
            "    should be taken into consideration. For simplicity, this implementation",
            "    does a case-insensitive comparison.",
            "",
            "    Note that this function uses prep_case_insenstive so the limitations of",
            "    that function apply here.",
            "",
            "    \"\"\"",
            "",
            "    return prep_case_insensitive(val1) == prep_case_insensitive(val2)",
            "",
            "",
            "def is_rdn_equal(rdn1, rdn2):",
            "    \"\"\"Returns True if and only if the RDNs are equal.",
            "",
            "    * RDNs must have the same number of AVAs.",
            "    * Each AVA of the RDNs must be the equal for the same attribute type. The",
            "      order isn't significant. Note that an attribute type will only be in one",
            "      AVA in an RDN, otherwise the DN wouldn't be valid.",
            "    * Attribute types aren't case sensitive. Note that attribute type",
            "      comparison is more complicated than implemented. This function only",
            "      compares case-insentive. The code should handle multiple names for an",
            "      attribute type (e.g., cn, commonName, and 2.5.4.3 are the same).",
            "",
            "    Note that this function uses is_ava_value_equal to compare AVAs so the",
            "    limitations of that function apply here.",
            "",
            "    \"\"\"",
            "",
            "    if len(rdn1) != len(rdn2):",
            "        return False",
            "",
            "    for attr_type_1, val1, dummy in rdn1:",
            "        found = False",
            "        for attr_type_2, val2, dummy in rdn2:",
            "            if attr_type_1.lower() != attr_type_2.lower():",
            "                continue",
            "",
            "            found = True",
            "            if not is_ava_value_equal(attr_type_1, val1, val2):",
            "                return False",
            "            break",
            "        if not found:",
            "            return False",
            "",
            "    return True",
            "",
            "",
            "def is_dn_equal(dn1, dn2):",
            "    \"\"\"Returns True if and only if the DNs are equal.",
            "",
            "    Two DNs are equal if they've got the same number of RDNs and if the RDNs",
            "    are the same at each position. See RFC4517.",
            "",
            "    Note that this function uses is_rdn_equal to compare RDNs so the",
            "    limitations of that function apply here.",
            "",
            "    :param dn1: Either a string DN or a DN parsed by ldap.dn.str2dn.",
            "    :param dn2: Either a string DN or a DN parsed by ldap.dn.str2dn.",
            "",
            "    \"\"\"",
            "",
            "    if not isinstance(dn1, list):",
            "        dn1 = ldap.dn.str2dn(dn1)",
            "    if not isinstance(dn2, list):",
            "        dn2 = ldap.dn.str2dn(dn2)",
            "",
            "    if len(dn1) != len(dn2):",
            "        return False",
            "",
            "    for rdn1, rdn2 in zip(dn1, dn2):",
            "        if not is_rdn_equal(rdn1, rdn2):",
            "            return False",
            "    return True",
            "",
            "",
            "def dn_startswith(descendant_dn, dn):",
            "    \"\"\"Returns True if and only if the descendant_dn is under the dn.",
            "",
            "    :param descendant_dn: Either a string DN or a DN parsed by ldap.dn.str2dn.",
            "    :param dn: Either a string DN or a DN parsed by ldap.dn.str2dn.",
            "",
            "    \"\"\"",
            "",
            "    if not isinstance(descendant_dn, list):",
            "        descendant_dn = ldap.dn.str2dn(descendant_dn)",
            "    if not isinstance(dn, list):",
            "        dn = ldap.dn.str2dn(dn)",
            "",
            "    if len(descendant_dn) <= len(dn):",
            "        return False",
            "",
            "    return is_dn_equal(descendant_dn[len(dn):], dn)",
            "",
            "",
            "@six.add_metaclass(abc.ABCMeta)",
            "class LDAPHandler(object):",
            "    '''Abstract class which defines methods for a LDAP API provider.",
            "",
            "    Native Keystone values cannot be passed directly into and from the",
            "    python-ldap API. Type conversion must occur at the LDAP API",
            "    boudary, examples of type conversions are:",
            "",
            "        * booleans map to the strings 'TRUE' and 'FALSE'",
            "",
            "        * integer values map to their string representation.",
            "",
            "        * unicode strings are encoded in UTF-8",
            "",
            "    In addition to handling type conversions at the API boundary we",
            "    have the requirement to support more than one LDAP API",
            "    provider. Currently we have:",
            "",
            "        * python-ldap, this is the standard LDAP API for Python, it",
            "          requires access to a live LDAP server.",
            "",
            "        * Fake LDAP which emulates python-ldap. This is used for",
            "          testing without requiring a live LDAP server.",
            "",
            "    To support these requirements we need a layer that performs type",
            "    conversions and then calls another LDAP API which is configurable",
            "    (e.g. either python-ldap or the fake emulation).",
            "",
            "    We have an addtional constraint at the time of this writing due to",
            "    limitations in the logging module. The logging module is not",
            "    capable of accepting UTF-8 encoded strings, it will throw an",
            "    encoding exception. Therefore all logging MUST be performed prior",
            "    to UTF-8 conversion. This means no logging can be performed in the",
            "    ldap APIs that implement the python-ldap API because those APIs",
            "    are defined to accept only UTF-8 strings. Thus the layer which",
            "    performs type conversions must also do the logging. We do the type",
            "    conversions in two steps, once to convert all Python types to",
            "    unicode strings, then log, then convert the unicode strings to",
            "    UTF-8.",
            "",
            "    There are a variety of ways one could accomplish this, we elect to",
            "    use a chaining technique whereby instances of this class simply",
            "    call the next member in the chain via the \"conn\" attribute. The",
            "    chain is constructed by passing in an existing instance of this",
            "    class as the conn attribute when the class is instantiated.",
            "",
            "    Here is a brief explanation of why other possible approaches were",
            "    not used:",
            "",
            "        subclassing",
            "",
            "            To perform the wrapping operations in the correct order",
            "            the type convesion class would have to subclass each of",
            "            the API providers. This is awkward, doubles the number of",
            "            classes, and does not scale well. It requires the type",
            "            conversion class to be aware of all possible API",
            "            providers.",
            "",
            "        decorators",
            "",
            "            Decorators provide an elegant solution to wrap methods and",
            "            would be an ideal way to perform type conversions before",
            "            calling the wrapped function and then converting the",
            "            values returned from the wrapped function. However",
            "            decorators need to be aware of the method signature, it",
            "            has to know what input parameters need conversion and how",
            "            to convert the result. For an API like python-ldap which",
            "            has a large number of different method signatures it would",
            "            require a large number of specialized",
            "            decorators. Experience has shown it's very easy to apply",
            "            the wrong decorator due to the inherent complexity and",
            "            tendency to cut-n-paste code. Another option is to",
            "            parameterize the decorator to make it \"smart\". Experience",
            "            has shown such decorators become insanely complicated and",
            "            difficult to understand and debug. Also decorators tend to",
            "            hide what's really going on when a method is called, the",
            "            operations being performed are not visible when looking at",
            "            the implemation of a decorated method, this too experience",
            "            has shown leads to mistakes.",
            "",
            "    Chaining simplifies both wrapping to perform type conversion as",
            "    well as the substitution of alternative API providers. One simply",
            "    creates a new instance of the API interface and insert it at the",
            "    front of the chain. Type conversions are explicit and obvious.",
            "",
            "    If a new method needs to be added to the API interface one adds it",
            "    to the abstract class definition. Should one miss adding the new",
            "    method to any derivations of the abstract class the code will fail",
            "    to load and run making it impossible to forget updating all the",
            "    derived classes.",
            "    '''",
            "    @abc.abstractmethod",
            "    def __init__(self, conn=None):",
            "        self.conn = conn",
            "",
            "    @abc.abstractmethod",
            "    def connect(self, url, page_size=0, alias_dereferencing=None,",
            "                use_tls=False, tls_cacertfile=None, tls_cacertdir=None,",
            "                tls_req_cert='demand', chase_referrals=None, debug_level=None):",
            "        raise exception.NotImplemented()",
            "",
            "    @abc.abstractmethod",
            "    def set_option(self, option, invalue):",
            "        raise exception.NotImplemented()",
            "",
            "    @abc.abstractmethod",
            "    def get_option(self, option):",
            "        raise exception.NotImplemented()",
            "",
            "    @abc.abstractmethod",
            "    def simple_bind_s(self, who='', cred='',",
            "                      serverctrls=None, clientctrls=None):",
            "        raise exception.NotImplemented()",
            "",
            "    @abc.abstractmethod",
            "    def unbind_s(self):",
            "        raise exception.NotImplemented()",
            "",
            "    @abc.abstractmethod",
            "    def add_s(self, dn, modlist):",
            "        raise exception.NotImplemented()",
            "",
            "    @abc.abstractmethod",
            "    def search_s(self, base, scope,",
            "                 filterstr='(objectClass=*)', attrlist=None, attrsonly=0):",
            "        raise exception.NotImplemented()",
            "",
            "    @abc.abstractmethod",
            "    def search_ext(self, base, scope,",
            "                   filterstr='(objectClass=*)', attrlist=None, attrsonly=0,",
            "                   serverctrls=None, clientctrls=None,",
            "                   timeout=-1, sizelimit=0):",
            "        raise exception.NotImplemented()",
            "",
            "    @abc.abstractmethod",
            "    def result3(self, msgid=ldap.RES_ANY, all=1, timeout=None,",
            "                resp_ctrl_classes=None):",
            "        raise exception.NotImplemented()",
            "",
            "    @abc.abstractmethod",
            "    def modify_s(self, dn, modlist):",
            "        raise exception.NotImplemented()",
            "",
            "    @abc.abstractmethod",
            "    def delete_s(self, dn):",
            "        raise exception.NotImplemented()",
            "",
            "    @abc.abstractmethod",
            "    def delete_ext_s(self, dn, serverctrls=None, clientctrls=None):",
            "        raise exception.NotImplemented()",
            "",
            "",
            "class PythonLDAPHandler(LDAPHandler):",
            "    '''Implementation of the LDAPHandler interface which calls the",
            "    python-ldap API.",
            "",
            "    Note, the python-ldap API requires all string values to be UTF-8",
            "    encoded. The KeystoneLDAPHandler enforces this prior to invoking",
            "    the methods in this class.",
            "    '''",
            "",
            "    def __init__(self, conn=None):",
            "        super(PythonLDAPHandler, self).__init__(conn=conn)",
            "",
            "    def connect(self, url, page_size=0, alias_dereferencing=None,",
            "                use_tls=False, tls_cacertfile=None, tls_cacertdir=None,",
            "                tls_req_cert='demand', chase_referrals=None, debug_level=None):",
            "        LOG.debug(\"LDAP init: url=%s\", url)",
            "        LOG.debug('LDAP init: use_tls=%s tls_cacertfile=%s tls_cacertdir=%s '",
            "                  'tls_req_cert=%s tls_avail=%s',",
            "                  use_tls, tls_cacertfile, tls_cacertdir,",
            "                  tls_req_cert, ldap.TLS_AVAIL)",
            "",
            "        if debug_level is not None:",
            "            ldap.set_option(ldap.OPT_DEBUG_LEVEL, debug_level)",
            "",
            "        using_ldaps = url.lower().startswith(\"ldaps\")",
            "",
            "        if use_tls and using_ldaps:",
            "            raise AssertionError(_('Invalid TLS / LDAPS combination'))",
            "",
            "        if use_tls:",
            "            if not ldap.TLS_AVAIL:",
            "                raise ValueError(_('Invalid LDAP TLS_AVAIL option: %s. TLS '",
            "                                   'not available') % ldap.TLS_AVAIL)",
            "            if tls_cacertfile:",
            "                # NOTE(topol)",
            "                # python ldap TLS does not verify CACERTFILE or CACERTDIR",
            "                # so we add some extra simple sanity check verification",
            "                # Also, setting these values globally (i.e. on the ldap object)",
            "                # works but these values are ignored when setting them on the",
            "                # connection",
            "                if not os.path.isfile(tls_cacertfile):",
            "                    raise IOError(_(\"tls_cacertfile %s not found \"",
            "                                    \"or is not a file\") %",
            "                                  tls_cacertfile)",
            "                ldap.set_option(ldap.OPT_X_TLS_CACERTFILE, tls_cacertfile)",
            "            elif tls_cacertdir:",
            "                # NOTE(topol)",
            "                # python ldap TLS does not verify CACERTFILE or CACERTDIR",
            "                # so we add some extra simple sanity check verification",
            "                # Also, setting these values globally (i.e. on the ldap object)",
            "                # works but these values are ignored when setting them on the",
            "                # connection",
            "                if not os.path.isdir(tls_cacertdir):",
            "                    raise IOError(_(\"tls_cacertdir %s not found \"",
            "                                    \"or is not a directory\") %",
            "                                  tls_cacertdir)",
            "                ldap.set_option(ldap.OPT_X_TLS_CACERTDIR, tls_cacertdir)",
            "            if tls_req_cert in LDAP_TLS_CERTS.values():",
            "                ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, tls_req_cert)",
            "            else:",
            "                LOG.debug(_(\"LDAP TLS: invalid TLS_REQUIRE_CERT Option=%s\"),",
            "                          tls_req_cert)",
            "",
            "        self.conn = ldap.initialize(url)",
            "        self.conn.protocol_version = ldap.VERSION3",
            "",
            "        if alias_dereferencing is not None:",
            "            self.conn.set_option(ldap.OPT_DEREF, alias_dereferencing)",
            "        self.page_size = page_size",
            "",
            "        if use_tls:",
            "            self.conn.start_tls_s()",
            "",
            "        if chase_referrals is not None:",
            "            self.conn.set_option(ldap.OPT_REFERRALS, int(chase_referrals))",
            "",
            "    def set_option(self, option, invalue):",
            "        return self.conn.set_option(option, invalue)",
            "",
            "    def get_option(self, option):",
            "        return self.conn.get_option(option)",
            "",
            "    def simple_bind_s(self, who='', cred='',",
            "                      serverctrls=None, clientctrls=None):",
            "        return self.conn.simple_bind_s(who, cred, serverctrls, clientctrls)",
            "",
            "    def unbind_s(self):",
            "        return self.conn.unbind_s()",
            "",
            "    def add_s(self, dn, modlist):",
            "        return self.conn.add_s(dn, modlist)",
            "",
            "    def search_s(self, base, scope,",
            "                 filterstr='(objectClass=*)', attrlist=None, attrsonly=0):",
            "        return self.conn.search_s(base, scope, filterstr,",
            "                                  attrlist, attrsonly)",
            "",
            "    def search_ext(self, base, scope,",
            "                   filterstr='(objectClass=*)', attrlist=None, attrsonly=0,",
            "                   serverctrls=None, clientctrls=None,",
            "                   timeout=-1, sizelimit=0):",
            "        return self.conn.search_ext(base, scope,",
            "                                    filterstr, attrlist, attrsonly,",
            "                                    serverctrls, clientctrls,",
            "                                    timeout, sizelimit)",
            "",
            "    def result3(self, msgid=ldap.RES_ANY, all=1, timeout=None,",
            "                resp_ctrl_classes=None):",
            "        # The resp_ctrl_classes parameter is a recent addition to the",
            "        # API. It defaults to None. We do not anticipate using it.",
            "        # To run with older versions of python-ldap we do not pass it.",
            "        return self.conn.result3(msgid, all, timeout)",
            "",
            "    def modify_s(self, dn, modlist):",
            "        return self.conn.modify_s(dn, modlist)",
            "",
            "    def delete_s(self, dn):",
            "        return self.conn.delete_s(dn)",
            "",
            "    def delete_ext_s(self, dn, serverctrls=None, clientctrls=None):",
            "        return self.conn.delete_ext_s(dn, serverctrls, clientctrls)",
            "",
            "",
            "class KeystoneLDAPHandler(LDAPHandler):",
            "    '''Convert data types and perform logging.",
            "",
            "    This LDAP inteface wraps the python-ldap based interfaces. The",
            "    python-ldap interfaces require string values encoded in UTF-8. The",
            "    OpenStack logging framework at the time of this writing is not",
            "    capable of accepting strings encoded in UTF-8, the log functions",
            "    will throw decoding errors if a non-ascii character appears in a",
            "    string.",
            "",
            "    Prior to the call Python data types are converted to a string",
            "    representation as required by the LDAP APIs.",
            "",
            "    Then logging is performed so we can track what is being",
            "    sent/received from LDAP. Also the logging filters security",
            "    sensitive items (i.e. passwords).",
            "",
            "    Then the string values are encoded into UTF-8.",
            "",
            "    Then the LDAP API entry point is invoked.",
            "",
            "    Data returned from the LDAP call is converted back from UTF-8",
            "    encoded strings into the Python data type used internally in",
            "    OpenStack.",
            "    '''",
            "",
            "    def __init__(self, conn=None):",
            "        super(KeystoneLDAPHandler, self).__init__(conn=conn)",
            "        self.page_size = 0",
            "",
            "    def _disable_paging(self):",
            "        # Disable the pagination from now on",
            "        self.page_size = 0",
            "",
            "    def connect(self, url, page_size=0, alias_dereferencing=None,",
            "                use_tls=False, tls_cacertfile=None, tls_cacertdir=None,",
            "                tls_req_cert='demand', chase_referrals=None, debug_level=None):",
            "        return self.conn.connect(url, page_size, alias_dereferencing,",
            "                                 use_tls, tls_cacertfile, tls_cacertdir,",
            "                                 tls_req_cert, chase_referrals,",
            "                                 debug_level=debug_level)",
            "",
            "    def set_option(self, option, invalue):",
            "        return self.conn.set_option(option, invalue)",
            "",
            "    def get_option(self, option):",
            "        return self.conn.get_option(option)",
            "",
            "    def simple_bind_s(self, who='', cred='',",
            "                      serverctrls=None, clientctrls=None):",
            "        LOG.debug(\"LDAP bind: who=%s\", who)",
            "        who_utf8 = utf8_encode(who)",
            "        cred_utf8 = utf8_encode(cred)",
            "        return self.conn.simple_bind_s(who_utf8, cred_utf8,",
            "                                       serverctrls, clientctrls)",
            "",
            "    def unbind_s(self):",
            "        LOG.debug(\"LDAP unbind\")",
            "        return self.conn.unbind_s()",
            "",
            "    def add_s(self, dn, modlist):",
            "        ldap_attrs = [(kind, [py2ldap(x) for x in safe_iter(values)])",
            "                      for kind, values in modlist]",
            "        logging_attrs = [(kind, values",
            "                         if kind != 'userPassword'",
            "                         else ['****'])",
            "                         for kind, values in ldap_attrs]",
            "        LOG.debug('LDAP add: dn=%s attrs=%s',",
            "                  dn, logging_attrs)",
            "        dn_utf8 = utf8_encode(dn)",
            "        ldap_attrs_utf8 = [(kind, [utf8_encode(x) for x in safe_iter(values)])",
            "                           for kind, values in ldap_attrs]",
            "        return self.conn.add_s(dn_utf8, ldap_attrs_utf8)",
            "",
            "    def search_s(self, base, scope,",
            "                 filterstr='(objectClass=*)', attrlist=None, attrsonly=0):",
            "        # NOTE(morganfainberg): Remove \"None\" singletons from this list, which",
            "        # allows us to set mapped attributes to \"None\" as defaults in config.",
            "        # Without this filtering, the ldap query would raise a TypeError since",
            "        # attrlist is expected to be an iterable of strings.",
            "        if attrlist is not None:",
            "            attrlist = [attr for attr in attrlist if attr is not None]",
            "        LOG.debug('LDAP search: base=%s scope=%s filterstr=%s '",
            "                  'attrs=%s attrsonly=%s',",
            "                  base, scope, filterstr, attrlist, attrsonly)",
            "        if self.page_size:",
            "            ldap_result = self._paged_search_s(base, scope,",
            "                                               filterstr, attrlist)",
            "        else:",
            "            base_utf8 = utf8_encode(base)",
            "            filterstr_utf8 = utf8_encode(filterstr)",
            "            if attrlist is None:",
            "                attrlist_utf8 = None",
            "            else:",
            "                attrlist_utf8 = map(utf8_encode, attrlist)",
            "            ldap_result = self.conn.search_s(base_utf8, scope,",
            "                                             filterstr_utf8,",
            "                                             attrlist_utf8, attrsonly)",
            "",
            "        py_result = convert_ldap_result(ldap_result)",
            "",
            "        return py_result",
            "",
            "    def search_ext(self, base, scope,",
            "                   filterstr='(objectClass=*)', attrlist=None, attrsonly=0,",
            "                   serverctrls=None, clientctrls=None,",
            "                   timeout=-1, sizelimit=0):",
            "        if attrlist is not None:",
            "            attrlist = [attr for attr in attrlist if attr is not None]",
            "        LOG.debug('LDAP search_ext: base=%s scope=%s filterstr=%s '",
            "                  'attrs=%s attrsonly=%s'",
            "                  'serverctrls=%s clientctrls=%s timeout=%s sizelimit=%s',",
            "                  base, scope, filterstr, attrlist, attrsonly,",
            "                  serverctrls, clientctrls, timeout, sizelimit)",
            "        return self.conn.search_ext(base, scope,",
            "                                    filterstr, attrlist, attrsonly,",
            "                                    serverctrls, clientctrls,",
            "                                    timeout, sizelimit)",
            "",
            "    def _paged_search_s(self, base, scope, filterstr, attrlist=None):",
            "        res = []",
            "        lc = ldap.controls.SimplePagedResultsControl(",
            "            controlType=ldap.LDAP_CONTROL_PAGE_OID,",
            "            criticality=True,",
            "            controlValue=(self.page_size, ''))",
            "        base_utf8 = utf8_encode(base)",
            "        filterstr_utf8 = utf8_encode(filterstr)",
            "        if attrlist is None:",
            "            attrlist_utf8 = None",
            "        else:",
            "            attrlist = [attr for attr in attrlist if attr is not None]",
            "            attrlist_utf8 = map(utf8_encode, attrlist)",
            "        msgid = self.conn.search_ext(base_utf8,",
            "                                     scope,",
            "                                     filterstr_utf8,",
            "                                     attrlist_utf8,",
            "                                     serverctrls=[lc])",
            "        # Endless loop request pages on ldap server until it has no data",
            "        while True:",
            "            # Request to the ldap server a page with 'page_size' entries",
            "            rtype, rdata, rmsgid, serverctrls = self.conn.result3(msgid)",
            "            # Receive the data",
            "            res.extend(rdata)",
            "            pctrls = [c for c in serverctrls",
            "                      if c.controlType == ldap.LDAP_CONTROL_PAGE_OID]",
            "            if pctrls:",
            "                # LDAP server supports pagination",
            "                est, cookie = pctrls[0].controlValue",
            "                if cookie:",
            "                    # There is more data still on the server",
            "                    # so we request another page",
            "                    lc.controlValue = (self.page_size, cookie)",
            "                    msgid = self.conn.search_ext(base_utf8,",
            "                                                 scope,",
            "                                                 filterstr_utf8,",
            "                                                 attrlist_utf8,",
            "                                                 serverctrls=[lc])",
            "                else:",
            "                    # Exit condition no more data on server",
            "                    break",
            "            else:",
            "                LOG.warning(_('LDAP Server does not support paging. '",
            "                              'Disable paging in keystone.conf to '",
            "                              'avoid this message.'))",
            "                self._disable_paging()",
            "                break",
            "        return res",
            "",
            "    def result3(self, msgid=ldap.RES_ANY, all=1, timeout=None,",
            "                resp_ctrl_classes=None):",
            "        ldap_result = self.conn.result3(msgid, all, timeout, resp_ctrl_classes)",
            "",
            "        LOG.debug('LDAP result3: msgid=%s all=%s timeout=%s '",
            "                  'resp_ctrl_classes=%s ldap_result=%s',",
            "                  msgid, all, timeout, resp_ctrl_classes, ldap_result)",
            "",
            "        py_result = convert_ldap_result(ldap_result)",
            "        return py_result",
            "",
            "    def modify_s(self, dn, modlist):",
            "        ldap_modlist = [",
            "            (op, kind, (None if values is None",
            "                        else [py2ldap(x) for x in safe_iter(values)]))",
            "            for op, kind, values in modlist]",
            "",
            "        logging_modlist = [(op, kind, (values if kind != 'userPassword'",
            "                           else ['****']))",
            "                           for op, kind, values in ldap_modlist]",
            "        LOG.debug('LDAP modify: dn=%s modlist=%s',",
            "                  dn, logging_modlist)",
            "",
            "        dn_utf8 = utf8_encode(dn)",
            "        ldap_modlist_utf8 = [",
            "            (op, kind, (None if values is None",
            "                        else [utf8_encode(x) for x in safe_iter(values)]))",
            "            for op, kind, values in ldap_modlist]",
            "        return self.conn.modify_s(dn_utf8, ldap_modlist_utf8)",
            "",
            "    def delete_s(self, dn):",
            "        LOG.debug(\"LDAP delete: dn=%s\", dn)",
            "        dn_utf8 = utf8_encode(dn)",
            "        return self.conn.delete_s(dn_utf8)",
            "",
            "    def delete_ext_s(self, dn, serverctrls=None, clientctrls=None):",
            "        LOG.debug('LDAP delete_ext: dn=%s serverctrls=%s clientctrls=%s',",
            "                  dn, serverctrls, clientctrls)",
            "        dn_utf8 = utf8_encode(dn)",
            "        return self.conn.delete_ext_s(dn_utf8, serverctrls, clientctrls)",
            "",
            "",
            "_HANDLERS = {}",
            "",
            "",
            "def register_handler(prefix, handler):",
            "    _HANDLERS[prefix] = handler",
            "",
            "",
            "def _get_connection(conn_url):",
            "    for prefix, handler in six.iteritems(_HANDLERS):",
            "        if conn_url.startswith(prefix):",
            "            return handler()",
            "",
            "    return PythonLDAPHandler()",
            "",
            "",
            "def filter_entity(entity_ref):",
            "    \"\"\"Filter out private items in an entity dict.",
            "",
            "    :param entity_ref:  the entity dictionary. The 'dn' field will be removed.",
            "        'dn' is used in LDAP, but should not be returned to the user.  This",
            "        value may be modified.",
            "",
            "    :returns: entity_ref",
            "",
            "    \"\"\"",
            "    if entity_ref:",
            "        entity_ref.pop('dn', None)",
            "    return entity_ref",
            "",
            "",
            "class BaseLdap(object):",
            "    DEFAULT_SUFFIX = \"dc=example,dc=com\"",
            "    DEFAULT_OU = None",
            "    DEFAULT_STRUCTURAL_CLASSES = None",
            "    DEFAULT_ID_ATTR = 'cn'",
            "    DEFAULT_OBJECTCLASS = None",
            "    DEFAULT_FILTER = None",
            "    DEFAULT_EXTRA_ATTR_MAPPING = []",
            "    DUMB_MEMBER_DN = 'cn=dumb,dc=nonexistent'",
            "    NotFound = None",
            "    notfound_arg = None",
            "    options_name = None",
            "    model = None",
            "    attribute_options_names = {}",
            "    immutable_attrs = []",
            "    attribute_ignore = []",
            "    tree_dn = None",
            "",
            "    def __init__(self, conf):",
            "        self.LDAP_URL = conf.ldap.url",
            "        self.LDAP_USER = conf.ldap.user",
            "        self.LDAP_PASSWORD = conf.ldap.password",
            "        self.LDAP_SCOPE = ldap_scope(conf.ldap.query_scope)",
            "        self.alias_dereferencing = parse_deref(conf.ldap.alias_dereferencing)",
            "        self.page_size = conf.ldap.page_size",
            "        self.use_tls = conf.ldap.use_tls",
            "        self.tls_cacertfile = conf.ldap.tls_cacertfile",
            "        self.tls_cacertdir = conf.ldap.tls_cacertdir",
            "        self.tls_req_cert = parse_tls_cert(conf.ldap.tls_req_cert)",
            "        self.attribute_mapping = {}",
            "        self.chase_referrals = conf.ldap.chase_referrals",
            "        self.debug_level = conf.ldap.debug_level",
            "",
            "        if self.options_name is not None:",
            "            self.suffix = conf.ldap.suffix",
            "            if self.suffix is None:",
            "                self.suffix = self.DEFAULT_SUFFIX",
            "            dn = '%s_tree_dn' % self.options_name",
            "            self.tree_dn = (getattr(conf.ldap, dn)",
            "                            or '%s,%s' % (self.DEFAULT_OU, self.suffix))",
            "",
            "            idatt = '%s_id_attribute' % self.options_name",
            "            self.id_attr = getattr(conf.ldap, idatt) or self.DEFAULT_ID_ATTR",
            "",
            "            objclass = '%s_objectclass' % self.options_name",
            "            self.object_class = (getattr(conf.ldap, objclass)",
            "                                 or self.DEFAULT_OBJECTCLASS)",
            "",
            "            for k, v in six.iteritems(self.attribute_options_names):",
            "                v = '%s_%s_attribute' % (self.options_name, v)",
            "                self.attribute_mapping[k] = getattr(conf.ldap, v)",
            "",
            "            attr_mapping_opt = ('%s_additional_attribute_mapping' %",
            "                                self.options_name)",
            "            attr_mapping = (getattr(conf.ldap, attr_mapping_opt)",
            "                            or self.DEFAULT_EXTRA_ATTR_MAPPING)",
            "            self.extra_attr_mapping = self._parse_extra_attrs(attr_mapping)",
            "",
            "            ldap_filter = '%s_filter' % self.options_name",
            "            self.ldap_filter = getattr(conf.ldap,",
            "                                       ldap_filter) or self.DEFAULT_FILTER",
            "",
            "            allow_create = '%s_allow_create' % self.options_name",
            "            self.allow_create = getattr(conf.ldap, allow_create)",
            "",
            "            allow_update = '%s_allow_update' % self.options_name",
            "            self.allow_update = getattr(conf.ldap, allow_update)",
            "",
            "            allow_delete = '%s_allow_delete' % self.options_name",
            "            self.allow_delete = getattr(conf.ldap, allow_delete)",
            "",
            "            member_attribute = '%s_member_attribute' % self.options_name",
            "            self.member_attribute = getattr(conf.ldap, member_attribute, None)",
            "",
            "            self.structural_classes = self.DEFAULT_STRUCTURAL_CLASSES",
            "",
            "            if self.notfound_arg is None:",
            "                self.notfound_arg = self.options_name + '_id'",
            "",
            "            attribute_ignore = '%s_attribute_ignore' % self.options_name",
            "            self.attribute_ignore = getattr(conf.ldap, attribute_ignore)",
            "",
            "        self.use_dumb_member = getattr(conf.ldap, 'use_dumb_member')",
            "        self.dumb_member = (getattr(conf.ldap, 'dumb_member') or",
            "                            self.DUMB_MEMBER_DN)",
            "",
            "        self.subtree_delete_enabled = getattr(conf.ldap,",
            "                                              'allow_subtree_delete')",
            "",
            "    def _not_found(self, object_id):",
            "        if self.NotFound is None:",
            "            return exception.NotFound(target=object_id)",
            "        else:",
            "            return self.NotFound(**{self.notfound_arg: object_id})",
            "",
            "    def _parse_extra_attrs(self, option_list):",
            "        mapping = {}",
            "        for item in option_list:",
            "            try:",
            "                ldap_attr, attr_map = item.split(':')",
            "            except Exception:",
            "                LOG.warn(_(",
            "                    'Invalid additional attribute mapping: \"%s\". '",
            "                    'Format must be <ldap_attribute>:<keystone_attribute>'),",
            "                    item)",
            "                continue",
            "            mapping[ldap_attr] = attr_map",
            "        return mapping",
            "",
            "    def get_connection(self, user=None, password=None):",
            "        conn = _get_connection(self.LDAP_URL)",
            "",
            "        conn = KeystoneLDAPHandler(conn=conn)",
            "",
            "        conn.connect(self.LDAP_URL,",
            "                     page_size=self.page_size,",
            "                     alias_dereferencing=self.alias_dereferencing,",
            "                     use_tls=self.use_tls,",
            "                     tls_cacertfile=self.tls_cacertfile,",
            "                     tls_cacertdir=self.tls_cacertdir,",
            "                     tls_req_cert=self.tls_req_cert,",
            "                     chase_referrals=self.chase_referrals,",
            "                     debug_level=self.debug_level)",
            "",
            "        if user is None:",
            "            user = self.LDAP_USER",
            "",
            "        if password is None:",
            "            password = self.LDAP_PASSWORD",
            "",
            "        # not all LDAP servers require authentication, so we don't bind",
            "        # if we don't have any user/pass",
            "        if user and password:",
            "            conn.simple_bind_s(user, password)",
            "",
            "        return conn",
            "",
            "    def _id_to_dn_string(self, object_id):",
            "        return u'%s=%s,%s' % (self.id_attr,",
            "                              ldap.dn.escape_dn_chars(",
            "                                  six.text_type(object_id)),",
            "                              self.tree_dn)",
            "",
            "    def _id_to_dn(self, object_id):",
            "        if self.LDAP_SCOPE == ldap.SCOPE_ONELEVEL:",
            "            return self._id_to_dn_string(object_id)",
            "        conn = self.get_connection()",
            "        try:",
            "            search_result = conn.search_s(",
            "                self.tree_dn, self.LDAP_SCOPE,",
            "                u'(&(%(id_attr)s=%(id)s)(objectclass=%(objclass)s))' %",
            "                {'id_attr': self.id_attr,",
            "                 'id': ldap.filter.escape_filter_chars(",
            "                     six.text_type(object_id)),",
            "                 'objclass': self.object_class})",
            "        finally:",
            "            conn.unbind_s()",
            "        if search_result:",
            "            dn, attrs = search_result[0]",
            "            return dn",
            "        else:",
            "            return self._id_to_dn_string(object_id)",
            "",
            "    @staticmethod",
            "    def _dn_to_id(dn):",
            "        return utf8_decode(ldap.dn.str2dn(utf8_encode(dn))[0][0][1])",
            "",
            "    def _ldap_res_to_model(self, res):",
            "        obj = self.model(id=self._dn_to_id(res[0]))",
            "        # LDAP attribute names may be returned in a different case than",
            "        # they are defined in the mapping, so we need to check for keys",
            "        # in a case-insensitive way.  We use the case specified in the",
            "        # mapping for the model to ensure we have a predictable way of",
            "        # retrieving values later.",
            "        lower_res = dict((k.lower(), v) for k, v in six.iteritems(res[1]))",
            "        for k in obj.known_keys:",
            "            if k in self.attribute_ignore:",
            "                continue",
            "",
            "            try:",
            "                v = lower_res[self.attribute_mapping.get(k, k).lower()]",
            "            except KeyError:",
            "                pass",
            "            else:",
            "                try:",
            "                    obj[k] = v[0]",
            "                except IndexError:",
            "                    obj[k] = None",
            "",
            "        return obj",
            "",
            "    def check_allow_create(self):",
            "        if not self.allow_create:",
            "            action = _('LDAP %s create') % self.options_name",
            "            raise exception.ForbiddenAction(action=action)",
            "",
            "    def check_allow_update(self):",
            "        if not self.allow_update:",
            "            action = _('LDAP %s update') % self.options_name",
            "            raise exception.ForbiddenAction(action=action)",
            "",
            "    def check_allow_delete(self):",
            "        if not self.allow_delete:",
            "            action = _('LDAP %s delete') % self.options_name",
            "            raise exception.ForbiddenAction(action=action)",
            "",
            "    def affirm_unique(self, values):",
            "        if values.get('name') is not None:",
            "            try:",
            "                self.get_by_name(values['name'])",
            "            except exception.NotFound:",
            "                pass",
            "            else:",
            "                raise exception.Conflict(type=self.options_name,",
            "                                         details=_('Duplicate name, %s.') %",
            "                                         values['name'])",
            "",
            "        if values.get('id') is not None:",
            "            try:",
            "                self.get(values['id'])",
            "            except exception.NotFound:",
            "                pass",
            "            else:",
            "                raise exception.Conflict(type=self.options_name,",
            "                                         details=_('Duplicate ID, %s.') %",
            "                                         values['id'])",
            "",
            "    def create(self, values):",
            "        self.affirm_unique(values)",
            "        conn = self.get_connection()",
            "        object_classes = self.structural_classes + [self.object_class]",
            "        attrs = [('objectClass', object_classes)]",
            "        for k, v in six.iteritems(values):",
            "            if k == 'id' or k in self.attribute_ignore:",
            "                continue",
            "            if v is not None:",
            "                attr_type = self.attribute_mapping.get(k, k)",
            "                if attr_type is not None:",
            "                    attrs.append((attr_type, [v]))",
            "                extra_attrs = [attr for attr, name",
            "                               in six.iteritems(self.extra_attr_mapping)",
            "                               if name == k]",
            "                for attr in extra_attrs:",
            "                    attrs.append((attr, [v]))",
            "",
            "        if 'groupOfNames' in object_classes and self.use_dumb_member:",
            "            attrs.append(('member', [self.dumb_member]))",
            "        try:",
            "            conn.add_s(self._id_to_dn(values['id']), attrs)",
            "        finally:",
            "            conn.unbind_s()",
            "        return values",
            "",
            "    def _ldap_get(self, object_id, ldap_filter=None):",
            "        conn = self.get_connection()",
            "        query = (u'(&(%(id_attr)s=%(id)s)'",
            "                 u'%(filter)s'",
            "                 u'(objectClass=%(object_class)s))'",
            "                 % {'id_attr': self.id_attr,",
            "                    'id': ldap.filter.escape_filter_chars(",
            "                        six.text_type(object_id)),",
            "                    'filter': (ldap_filter or self.ldap_filter or ''),",
            "                    'object_class': self.object_class})",
            "        try:",
            "            attrs = list(set((self.attribute_mapping.values() +",
            "                              self.extra_attr_mapping.keys())))",
            "            res = conn.search_s(self.tree_dn, self.LDAP_SCOPE, query, attrs)",
            "        except ldap.NO_SUCH_OBJECT:",
            "            return None",
            "        finally:",
            "            conn.unbind_s()",
            "        try:",
            "            return res[0]",
            "        except IndexError:",
            "            return None",
            "",
            "    def _ldap_get_all(self, ldap_filter=None):",
            "        conn = self.get_connection()",
            "        query = u'(&%s(objectClass=%s))' % (ldap_filter or",
            "                                            self.ldap_filter or",
            "                                            '', self.object_class)",
            "        try:",
            "            attrs = list(set((self.attribute_mapping.values() +",
            "                              self.extra_attr_mapping.keys())))",
            "            return conn.search_s(self.tree_dn,",
            "                                 self.LDAP_SCOPE,",
            "                                 query,",
            "                                 attrs)",
            "        except ldap.NO_SUCH_OBJECT:",
            "            return []",
            "        finally:",
            "            conn.unbind_s()",
            "",
            "    def _ldap_get_list(self, search_base, scope, query_params=None,",
            "                       attrlist=None):",
            "        conn = self.get_connection()",
            "        query = u'(objectClass=%s)' % self.object_class",
            "        if query_params:",
            "",
            "            def calc_filter(attrname, value):",
            "                val_esc = ldap.filter.escape_filter_chars(value)",
            "                return '(%s=%s)' % (attrname, val_esc)",
            "",
            "            query = (u'(&%s%s)' %",
            "                     (query, ''.join([calc_filter(k, v) for k, v in",
            "                                      six.iteritems(query_params)])))",
            "        try:",
            "            return conn.search_s(search_base, scope, query, attrlist)",
            "        finally:",
            "            conn.unbind_s()",
            "",
            "    def get(self, object_id, ldap_filter=None):",
            "        res = self._ldap_get(object_id, ldap_filter)",
            "        if res is None:",
            "            raise self._not_found(object_id)",
            "        else:",
            "            return self._ldap_res_to_model(res)",
            "",
            "    def get_by_name(self, name, ldap_filter=None):",
            "        query = (u'(%s=%s)' % (self.attribute_mapping['name'],",
            "                               ldap.filter.escape_filter_chars(",
            "                                   six.text_type(name))))",
            "        res = self.get_all(query)",
            "        try:",
            "            return res[0]",
            "        except IndexError:",
            "            raise self._not_found(name)",
            "",
            "    def get_all(self, ldap_filter=None):",
            "        return [self._ldap_res_to_model(x)",
            "                for x in self._ldap_get_all(ldap_filter)]",
            "",
            "    def update(self, object_id, values, old_obj=None):",
            "        if old_obj is None:",
            "            old_obj = self.get(object_id)",
            "",
            "        modlist = []",
            "        for k, v in six.iteritems(values):",
            "            if k == 'id' or k in self.attribute_ignore:",
            "                continue",
            "",
            "            # attribute value has not changed",
            "            if k in old_obj and old_obj[k] == v:",
            "                continue",
            "",
            "            if k in self.immutable_attrs:",
            "                msg = (_(\"Cannot change %(option_name)s %(attr)s\") %",
            "                       {'option_name': self.options_name, 'attr': k})",
            "                raise exception.ValidationError(msg)",
            "",
            "            if v is None:",
            "                if old_obj.get(k) is not None:",
            "                    modlist.append((ldap.MOD_DELETE,",
            "                                    self.attribute_mapping.get(k, k),",
            "                                    None))",
            "                continue",
            "",
            "            current_value = old_obj.get(k)",
            "            if current_value is None:",
            "                op = ldap.MOD_ADD",
            "                modlist.append((op, self.attribute_mapping.get(k, k), [v]))",
            "            elif current_value != v:",
            "                op = ldap.MOD_REPLACE",
            "                modlist.append((op, self.attribute_mapping.get(k, k), [v]))",
            "",
            "        if modlist:",
            "            conn = self.get_connection()",
            "            try:",
            "                conn.modify_s(self._id_to_dn(object_id), modlist)",
            "            except ldap.NO_SUCH_OBJECT:",
            "                raise self._not_found(object_id)",
            "            finally:",
            "                conn.unbind_s()",
            "",
            "        return self.get(object_id)",
            "",
            "    def delete(self, object_id):",
            "        conn = self.get_connection()",
            "        try:",
            "            conn.delete_s(self._id_to_dn(object_id))",
            "        except ldap.NO_SUCH_OBJECT:",
            "            raise self._not_found(object_id)",
            "        finally:",
            "            conn.unbind_s()",
            "",
            "    def deleteTree(self, object_id):",
            "        conn = self.get_connection()",
            "        tree_delete_control = ldap.controls.LDAPControl(CONTROL_TREEDELETE,",
            "                                                        0,",
            "                                                        None)",
            "        try:",
            "            conn.delete_ext_s(self._id_to_dn(object_id),",
            "                              serverctrls=[tree_delete_control])",
            "        except ldap.NO_SUCH_OBJECT:",
            "            raise self._not_found(object_id)",
            "        finally:",
            "            conn.unbind_s()",
            "",
            "    def add_member(self, member_dn, member_list_dn):",
            "        \"\"\"Add member to the member list.",
            "",
            "        :param member_dn: DN of member to be added.",
            "        :param member_list_dn: DN of group to which the",
            "                               member will be added.",
            "",
            "        :raises: exception.Conflict: If the user was already a member.",
            "                 self.NotFound: If the group entry didn't exist.",
            "        \"\"\"",
            "        conn = self.get_connection()",
            "        try:",
            "            mod = (ldap.MOD_ADD, self.member_attribute, member_dn)",
            "            conn.modify_s(member_list_dn, [mod])",
            "        except ldap.TYPE_OR_VALUE_EXISTS:",
            "            raise exception.Conflict(_('Member %(member)s is already a member'",
            "                                       ' of group %(group)s') % {",
            "                                     'member': member_dn,",
            "                                     'group': member_list_dn})",
            "        except ldap.NO_SUCH_OBJECT:",
            "            raise self._not_found(member_list_dn)",
            "        finally:",
            "            conn.unbind_s()",
            "",
            "    def remove_member(self, member_dn, member_list_dn):",
            "        \"\"\"Remove member from the member list.",
            "",
            "        :param member_dn: DN of member to be removed.",
            "        :param member_list_dn: DN of group from which the",
            "                               member will be removed.",
            "",
            "        :raises: self.NotFound: If the group entry didn't exist.",
            "                 ldap.NO_SUCH_ATTRIBUTE: If the user wasn't a member.",
            "        \"\"\"",
            "        conn = self.get_connection()",
            "        try:",
            "            mod = (ldap.MOD_DELETE, self.member_attribute, member_dn)",
            "            conn.modify_s(member_list_dn, [mod])",
            "        except ldap.NO_SUCH_OBJECT:",
            "            raise self._not_found(member_list_dn)",
            "        finally:",
            "            conn.unbind_s()",
            "",
            "",
            "class EnabledEmuMixIn(BaseLdap):",
            "    \"\"\"Emulates boolean 'enabled' attribute if turned on.",
            "",
            "    Creates groupOfNames holding all enabled objects of this class, all missing",
            "    objects are considered disabled.",
            "",
            "    Options:",
            "",
            "    * $name_enabled_emulation - boolean, on/off",
            "    * $name_enabled_emulation_dn - DN of that groupOfNames, default is",
            "      cn=enabled_${name}s,${tree_dn}",
            "",
            "    Where ${name}s is the plural of self.options_name ('users' or 'tenants'),",
            "    ${tree_dn} is self.tree_dn.",
            "    \"\"\"",
            "",
            "    def __init__(self, conf):",
            "        super(EnabledEmuMixIn, self).__init__(conf)",
            "        enabled_emulation = '%s_enabled_emulation' % self.options_name",
            "        self.enabled_emulation = getattr(conf.ldap, enabled_emulation)",
            "",
            "        enabled_emulation_dn = '%s_enabled_emulation_dn' % self.options_name",
            "        self.enabled_emulation_dn = getattr(conf.ldap, enabled_emulation_dn)",
            "        if not self.enabled_emulation_dn:",
            "            self.enabled_emulation_dn = ('cn=enabled_%ss,%s' %",
            "                                         (self.options_name, self.tree_dn))",
            "",
            "    def _get_enabled(self, object_id):",
            "        conn = self.get_connection()",
            "        dn = self._id_to_dn(object_id)",
            "        query = '(member=%s)' % dn",
            "        try:",
            "            enabled_value = conn.search_s(self.enabled_emulation_dn,",
            "                                          ldap.SCOPE_BASE,",
            "                                          query, ['cn'])",
            "        except ldap.NO_SUCH_OBJECT:",
            "            return False",
            "        else:",
            "            return bool(enabled_value)",
            "        finally:",
            "            conn.unbind_s()",
            "",
            "    def _add_enabled(self, object_id):",
            "        if not self._get_enabled(object_id):",
            "            conn = self.get_connection()",
            "            modlist = [(ldap.MOD_ADD,",
            "                        'member',",
            "                        [self._id_to_dn(object_id)])]",
            "            try:",
            "                conn.modify_s(self.enabled_emulation_dn, modlist)",
            "            except ldap.NO_SUCH_OBJECT:",
            "                attr_list = [('objectClass', ['groupOfNames']),",
            "                             ('member',",
            "                                 [self._id_to_dn(object_id)])]",
            "                if self.use_dumb_member:",
            "                    attr_list[1][1].append(self.dumb_member)",
            "                conn.add_s(self.enabled_emulation_dn, attr_list)",
            "            finally:",
            "                conn.unbind_s()",
            "",
            "    def _remove_enabled(self, object_id):",
            "        conn = self.get_connection()",
            "        modlist = [(ldap.MOD_DELETE,",
            "                    'member',",
            "                    [self._id_to_dn(object_id)])]",
            "        try:",
            "            conn.modify_s(self.enabled_emulation_dn, modlist)",
            "        except (ldap.NO_SUCH_OBJECT, ldap.NO_SUCH_ATTRIBUTE):",
            "            pass",
            "        finally:",
            "            conn.unbind_s()",
            "",
            "    def create(self, values):",
            "        if self.enabled_emulation:",
            "            enabled_value = values.pop('enabled', True)",
            "            ref = super(EnabledEmuMixIn, self).create(values)",
            "            if 'enabled' not in self.attribute_ignore:",
            "                if enabled_value:",
            "                    self._add_enabled(ref['id'])",
            "                ref['enabled'] = enabled_value",
            "            return ref",
            "        else:",
            "            return super(EnabledEmuMixIn, self).create(values)",
            "",
            "    def get(self, object_id, ldap_filter=None):",
            "        ref = super(EnabledEmuMixIn, self).get(object_id, ldap_filter)",
            "        if 'enabled' not in self.attribute_ignore and self.enabled_emulation:",
            "            ref['enabled'] = self._get_enabled(object_id)",
            "        return ref",
            "",
            "    def get_all(self, ldap_filter=None):",
            "        if 'enabled' not in self.attribute_ignore and self.enabled_emulation:",
            "            # had to copy BaseLdap.get_all here to ldap_filter by DN",
            "            tenant_list = [self._ldap_res_to_model(x)",
            "                           for x in self._ldap_get_all(ldap_filter)",
            "                           if x[0] != self.enabled_emulation_dn]",
            "            for tenant_ref in tenant_list:",
            "                tenant_ref['enabled'] = self._get_enabled(tenant_ref['id'])",
            "            return tenant_list",
            "        else:",
            "            return super(EnabledEmuMixIn, self).get_all(ldap_filter)",
            "",
            "    def update(self, object_id, values, old_obj=None):",
            "        if 'enabled' not in self.attribute_ignore and self.enabled_emulation:",
            "            data = values.copy()",
            "            enabled_value = data.pop('enabled', None)",
            "            ref = super(EnabledEmuMixIn, self).update(object_id, data, old_obj)",
            "            if enabled_value is not None:",
            "                if enabled_value:",
            "                    self._add_enabled(object_id)",
            "                else:",
            "                    self._remove_enabled(object_id)",
            "            return ref",
            "        else:",
            "            return super(EnabledEmuMixIn, self).update(",
            "                object_id, values, old_obj)",
            "",
            "    def delete(self, object_id):",
            "        if self.enabled_emulation:",
            "            self._remove_enabled(object_id)",
            "        super(EnabledEmuMixIn, self).delete(object_id)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "rdiffweb.controller.page_pref_sshkeys.ApiSshKeys.post"
        ]
    },
    "keystone/tests/fakeldap.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         if dn == 'cn=Doe\\\\5c, John,ou=Users,cn=example,cn=com':"
            },
            "1": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "             return 'CN=Doe\\\\, John,OU=Users,CN=example,CN=com'"
            },
            "2": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 64,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+        # NOTE(blk-u): Another special case for this tested value. When a"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+        # roleOccupant has an escaped comma, it gets converted to \\2C."
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        if dn == 'cn=Doe\\\\, John,ou=Users,cn=example,cn=com':"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+            return 'CN=Doe\\\\2C John,OU=Users,CN=example,CN=com'"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         dn = ldap.dn.str2dn(core.utf8_encode(dn))"
            },
            "9": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "         norm = []"
            },
            "10": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "         for part in dn:"
            },
            "11": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "         str_sids = [six.text_type(x) for x in attrs[key]]"
            },
            "12": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "         return six.text_type(value) in str_sids"
            },
            "13": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "     if key != 'objectclass':"
            },
            "14": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return _internal_attr(key, value)[0] in attrs[key]"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+        check_value = _internal_attr(key, value)[0]"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+        norm_values = list(_internal_attr(key, x)[0] for x in attrs[key])"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+        return check_value in norm_values"
            },
            "18": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "     # it is an objectclass check, so check subclasses"
            },
            "19": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "     values = _subs(value)"
            },
            "20": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "     for v in values:"
            }
        },
        "frontPatchFile": [
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"Fake LDAP server for test harness.",
            "",
            "This class does very little error checking, and knows nothing about ldap",
            "class definitions.  It implements the minimum emulation of the python ldap",
            "library to work with nova.",
            "",
            "\"\"\"",
            "",
            "import re",
            "import shelve",
            "",
            "import ldap",
            "import six",
            "from six import moves",
            "",
            "from keystone.common.ldap import core",
            "from keystone import exception",
            "from keystone.openstack.common.gettextutils import _",
            "from keystone.openstack.common import log",
            "",
            "",
            "SCOPE_NAMES = {",
            "    ldap.SCOPE_BASE: 'SCOPE_BASE',",
            "    ldap.SCOPE_ONELEVEL: 'SCOPE_ONELEVEL',",
            "    ldap.SCOPE_SUBTREE: 'SCOPE_SUBTREE',",
            "}",
            "",
            "# http://msdn.microsoft.com\\",
            "#     /en-us/library/windows/desktop/aa366991(v=vs.85).aspx",
            "CONTROL_TREEDELETE = '1.2.840.113556.1.4.805'",
            "",
            "LOG = log.getLogger(__name__)",
            "",
            "",
            "def _internal_attr(attr_name, value_or_values):",
            "    def normalize_value(value):",
            "        return core.utf8_decode(value)",
            "",
            "    def normalize_dn(dn):",
            "        # Capitalize the attribute names as an LDAP server might.",
            "",
            "        # NOTE(blk-u): Special case for this tested value, used with",
            "        # test_user_id_comma. The call to str2dn here isn't always correct",
            "        # here, because `dn` is escaped for an LDAP filter. str2dn() normally",
            "        # works only because there's no special characters in `dn`.",
            "        if dn == 'cn=Doe\\\\5c, John,ou=Users,cn=example,cn=com':",
            "            return 'CN=Doe\\\\, John,OU=Users,CN=example,CN=com'",
            "",
            "        dn = ldap.dn.str2dn(core.utf8_encode(dn))",
            "        norm = []",
            "        for part in dn:",
            "            name, val, i = part[0]",
            "            name = core.utf8_decode(name)",
            "            name = name.upper()",
            "            name = core.utf8_encode(name)",
            "            norm.append([(name, val, i)])",
            "        return core.utf8_decode(ldap.dn.dn2str(norm))",
            "",
            "    if attr_name in ('member', 'roleOccupant'):",
            "        attr_fn = normalize_dn",
            "    else:",
            "        attr_fn = normalize_value",
            "",
            "    if isinstance(value_or_values, list):",
            "        return [attr_fn(x) for x in value_or_values]",
            "    return [attr_fn(value_or_values)]",
            "",
            "",
            "def _match_query(query, attrs):",
            "    \"\"\"Match an ldap query to an attribute dictionary.",
            "",
            "    The characters &, |, and ! are supported in the query. No syntax checking",
            "    is performed, so malformed queries will not work correctly.",
            "    \"\"\"",
            "    # cut off the parentheses",
            "    inner = query[1:-1]",
            "    if inner.startswith(('&', '|')):",
            "        # cut off the & or |",
            "        groups = _paren_groups(inner[1:])",
            "        return all(_match_query(group, attrs) for group in groups)",
            "    if inner.startswith('!'):",
            "        # cut off the ! and the nested parentheses",
            "        return not _match_query(query[2:-1], attrs)",
            "",
            "    (k, _sep, v) = inner.partition('=')",
            "    return _match(k, v, attrs)",
            "",
            "",
            "def _paren_groups(source):",
            "    \"\"\"Split a string into parenthesized groups.\"\"\"",
            "    count = 0",
            "    start = 0",
            "    result = []",
            "    for pos in moves.range(len(source)):",
            "        if source[pos] == '(':",
            "            if count == 0:",
            "                start = pos",
            "            count += 1",
            "        if source[pos] == ')':",
            "            count -= 1",
            "            if count == 0:",
            "                result.append(source[start:pos + 1])",
            "    return result",
            "",
            "",
            "def _match(key, value, attrs):",
            "    \"\"\"Match a given key and value against an attribute list.\"\"\"",
            "    if key not in attrs:",
            "        return False",
            "    # This is a wild card search. Implemented as all or nothing for now.",
            "    if value == '*':",
            "        return True",
            "    if key == 'serviceId':",
            "        # for serviceId, the backend is returning a list of numbers",
            "        # make sure we convert them to strings first before comparing",
            "        # them",
            "        str_sids = [six.text_type(x) for x in attrs[key]]",
            "        return six.text_type(value) in str_sids",
            "    if key != 'objectclass':",
            "        return _internal_attr(key, value)[0] in attrs[key]",
            "    # it is an objectclass check, so check subclasses",
            "    values = _subs(value)",
            "    for v in values:",
            "        if v in attrs[key]:",
            "            return True",
            "    return False",
            "",
            "",
            "def _subs(value):",
            "    \"\"\"Returns a list of subclass strings.",
            "",
            "    The strings represent the ldap objectclass plus any subclasses that",
            "    inherit from it. Fakeldap doesn't know about the ldap object structure,",
            "    so subclasses need to be defined manually in the dictionary below.",
            "",
            "    \"\"\"",
            "    subs = {'groupOfNames': ['keystoneTenant',",
            "                             'keystoneRole',",
            "                             'keystoneTenantRole']}",
            "    if value in subs:",
            "        return [value] + subs[value]",
            "    return [value]",
            "",
            "",
            "server_fail = False",
            "",
            "",
            "class FakeShelve(dict):",
            "",
            "    def sync(self):",
            "        pass",
            "",
            "",
            "FakeShelves = {}",
            "",
            "",
            "class FakeLdap(core.LDAPHandler):",
            "    '''Emulate the python-ldap API.",
            "",
            "    The python-ldap API requires all strings to be UTF-8 encoded. This",
            "    is assured by the caller of this interface",
            "    (i.e. KeystoneLDAPHandler).",
            "",
            "    However, internally this emulation MUST process and store strings",
            "    in a canonical form which permits operations on",
            "    characters. Encoded strings do not provide the ability to operate",
            "    on characters. Therefore this emulation accepts UTF-8 encoded",
            "    strings, decodes them to unicode for operations internal to this",
            "    emulation, and encodes them back to UTF-8 when returning values",
            "    from the emulation.",
            "    '''",
            "",
            "    __prefix = 'ldap:'",
            "",
            "    def __init__(self, conn=None):",
            "        super(FakeLdap, self).__init__(conn=conn)",
            "        self._ldap_options = {ldap.OPT_DEREF: ldap.DEREF_NEVER}",
            "",
            "    def connect(self, url, page_size=0, alias_dereferencing=None,",
            "                use_tls=False, tls_cacertfile=None, tls_cacertdir=None,",
            "                tls_req_cert='demand', chase_referrals=None, debug_level=None):",
            "        if url.startswith('fake://memory'):",
            "            if url not in FakeShelves:",
            "                FakeShelves[url] = FakeShelve()",
            "            self.db = FakeShelves[url]",
            "        else:",
            "            self.db = shelve.open(url[7:])",
            "",
            "        using_ldaps = url.lower().startswith(\"ldaps\")",
            "",
            "        if use_tls and using_ldaps:",
            "            raise AssertionError('Invalid TLS / LDAPS combination')",
            "",
            "        if use_tls:",
            "            if tls_cacertfile:",
            "                ldap.set_option(ldap.OPT_X_TLS_CACERTFILE, tls_cacertfile)",
            "            elif tls_cacertdir:",
            "                ldap.set_option(ldap.OPT_X_TLS_CACERTDIR, tls_cacertdir)",
            "            if tls_req_cert in core.LDAP_TLS_CERTS.values():",
            "                ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, tls_req_cert)",
            "            else:",
            "                raise ValueError(\"invalid TLS_REQUIRE_CERT tls_req_cert=%s\",",
            "                                 tls_req_cert)",
            "",
            "        if alias_dereferencing is not None:",
            "            self.set_option(ldap.OPT_DEREF, alias_dereferencing)",
            "        self.page_size = page_size",
            "",
            "    def dn(self, dn):",
            "        return core.utf8_decode(dn)",
            "",
            "    def key(self, dn):",
            "        return '%s%s' % (self.__prefix, self.dn(dn))",
            "",
            "    def simple_bind_s(self, who='', cred='',",
            "                      serverctrls=None, clientctrls=None):",
            "        \"\"\"This method is ignored, but provided for compatibility.\"\"\"",
            "        if server_fail:",
            "            raise ldap.SERVER_DOWN",
            "        if who == 'cn=Admin' and cred == 'password':",
            "            return",
            "",
            "        try:",
            "            attrs = self.db[self.key(who)]",
            "        except KeyError:",
            "            LOG.debug('bind fail: who=%s not found', core.utf8_decode(who))",
            "            raise ldap.NO_SUCH_OBJECT",
            "",
            "        db_password = None",
            "        try:",
            "            db_password = attrs['userPassword'][0]",
            "        except (KeyError, IndexError):",
            "            LOG.debug('bind fail: password for who=%s not found',",
            "                      core.utf8_decode(who))",
            "            raise ldap.INAPPROPRIATE_AUTH",
            "",
            "        if cred != db_password:",
            "            LOG.debug('bind fail: password for who=%s does not match',",
            "                      core.utf8_decode(who))",
            "            raise ldap.INVALID_CREDENTIALS",
            "",
            "    def unbind_s(self):",
            "        \"\"\"This method is ignored, but provided for compatibility.\"\"\"",
            "        if server_fail:",
            "            raise ldap.SERVER_DOWN",
            "",
            "    def add_s(self, dn, modlist):",
            "        \"\"\"Add an object with the specified attributes at dn.\"\"\"",
            "        if server_fail:",
            "            raise ldap.SERVER_DOWN",
            "",
            "        # The LDAP API raises a TypeError if attr name is None.",
            "        for k, dummy_v in modlist:",
            "            if k is None:",
            "                raise TypeError('must be string, not None. modlist=%s' %",
            "                                modlist)",
            "",
            "        key = self.key(dn)",
            "        LOG.debug('add item: dn=%(dn)s, attrs=%(attrs)s', {",
            "            'dn': dn, 'attrs': modlist})",
            "        if key in self.db:",
            "            LOG.debug('add item failed: dn=%s is already in store.',",
            "                      core.utf8_decode(dn))",
            "            raise ldap.ALREADY_EXISTS(dn)",
            "",
            "        self.db[key] = dict([(k, _internal_attr(k, v))",
            "                             for k, v in modlist])",
            "        self.db.sync()",
            "",
            "    def delete_s(self, dn):",
            "        \"\"\"Remove the ldap object at specified dn.\"\"\"",
            "        if server_fail:",
            "            raise ldap.SERVER_DOWN",
            "",
            "        key = self.key(dn)",
            "        LOG.debug('delete item: dn=%s', dn)",
            "        try:",
            "            del self.db[key]",
            "        except KeyError:",
            "            LOG.debug('delete item failed: dn=%s not found.',",
            "                      core.utf8_decode(dn))",
            "            raise ldap.NO_SUCH_OBJECT",
            "        self.db.sync()",
            "",
            "    def delete_ext_s(self, dn, serverctrls, clientctrls=None):",
            "        \"\"\"Remove the ldap object at specified dn.\"\"\"",
            "        if server_fail:",
            "            raise ldap.SERVER_DOWN",
            "",
            "        try:",
            "            if CONTROL_TREEDELETE in [c.controlType for c in serverctrls]:",
            "                LOG.debug('FakeLdap subtree_delete item: dn=%s',",
            "                          core.utf8_decode(dn))",
            "                children = [k for k, v in six.iteritems(self.db)",
            "                            if re.match('%s.*,%s' % (",
            "                                        re.escape(self.__prefix),",
            "                                        re.escape(self.dn(dn))), k)]",
            "                for c in children:",
            "                    del self.db[c]",
            "",
            "            key = self.key(dn)",
            "            LOG.debug(_('FakeLdap delete item: dn=%s'), dn)",
            "            del self.db[key]",
            "        except KeyError:",
            "            LOG.debug('delete item failed: dn=%s not found.',",
            "                      core.utf8_decode(dn))",
            "            raise ldap.NO_SUCH_OBJECT",
            "        self.db.sync()",
            "",
            "    def modify_s(self, dn, modlist):",
            "        \"\"\"Modify the object at dn using the attribute list.",
            "",
            "        :param dn: an LDAP DN",
            "        :param modlist: a list of tuples in the following form:",
            "                      ([MOD_ADD | MOD_DELETE | MOD_REPACE], attribute, value)",
            "        \"\"\"",
            "        if server_fail:",
            "            raise ldap.SERVER_DOWN",
            "",
            "        key = self.key(dn)",
            "        LOG.debug('modify item: dn=%(dn)s attrs=%(attrs)s', {",
            "            'dn': dn, 'attrs': modlist})",
            "        try:",
            "            entry = self.db[key]",
            "        except KeyError:",
            "            LOG.debug('modify item failed: dn=%s not found.',",
            "                      core.utf8_decode(dn))",
            "            raise ldap.NO_SUCH_OBJECT",
            "",
            "        for cmd, k, v in modlist:",
            "            values = entry.setdefault(k, [])",
            "            if cmd == ldap.MOD_ADD:",
            "                v = _internal_attr(k, v)",
            "                for x in v:",
            "                    if x in values:",
            "                        raise ldap.TYPE_OR_VALUE_EXISTS",
            "                values += v",
            "            elif cmd == ldap.MOD_REPLACE:",
            "                values[:] = _internal_attr(k, v)",
            "            elif cmd == ldap.MOD_DELETE:",
            "                if v is None:",
            "                    if not values:",
            "                        LOG.debug('modify item failed: '",
            "                                  'item has no attribute \"%s\" to delete', k)",
            "                        raise ldap.NO_SUCH_ATTRIBUTE",
            "                    values[:] = []",
            "                else:",
            "                    for val in _internal_attr(k, v):",
            "                        try:",
            "                            values.remove(val)",
            "                        except ValueError:",
            "                            LOG.debug('modify item failed: '",
            "                                      'item has no attribute \"%(k)s\" with '",
            "                                      'value \"%(v)s\" to delete', {",
            "                                          'k': k, 'v': val})",
            "                            raise ldap.NO_SUCH_ATTRIBUTE",
            "            else:",
            "                LOG.debug('modify item failed: unknown command %s', cmd)",
            "                raise NotImplementedError('modify_s action %s not'",
            "                                          ' implemented' % cmd)",
            "        self.db[key] = entry",
            "        self.db.sync()",
            "",
            "    def search_s(self, base, scope,",
            "                 filterstr='(objectClass=*)', attrlist=None, attrsonly=0):",
            "        \"\"\"Search for all matching objects under base using the query.",
            "",
            "        Args:",
            "        base -- dn to search under",
            "        scope -- only SCOPE_BASE and SCOPE_SUBTREE are supported",
            "        filterstr -- filter objects by",
            "        attrlist -- attrs to return. Returns all attrs if not specified",
            "",
            "        \"\"\"",
            "        if server_fail:",
            "            raise ldap.SERVER_DOWN",
            "",
            "        if scope == ldap.SCOPE_BASE:",
            "            try:",
            "                item_dict = self.db[self.key(base)]",
            "            except KeyError:",
            "                LOG.debug('search fail: dn not found for SCOPE_BASE')",
            "                raise ldap.NO_SUCH_OBJECT",
            "            results = [(base, item_dict)]",
            "        elif scope == ldap.SCOPE_SUBTREE:",
            "            results = [(k[len(self.__prefix):], v)",
            "                       for k, v in six.iteritems(self.db)",
            "                       if re.match('%s.*,%s' % (re.escape(self.__prefix),",
            "                                                re.escape(self.dn(base))), k)]",
            "        elif scope == ldap.SCOPE_ONELEVEL:",
            "",
            "            def get_entries():",
            "                base_dn = ldap.dn.str2dn(core.utf8_encode(base))",
            "                base_len = len(base_dn)",
            "",
            "                for k, v in six.iteritems(self.db):",
            "                    if not k.startswith(self.__prefix):",
            "                        continue",
            "                    k_dn_str = k[len(self.__prefix):]",
            "                    k_dn = ldap.dn.str2dn(core.utf8_encode(k_dn_str))",
            "                    if len(k_dn) != base_len + 1:",
            "                        continue",
            "                    if k_dn[-base_len:] != base_dn:",
            "                        continue",
            "                    yield (k_dn_str, v)",
            "",
            "            results = list(get_entries())",
            "",
            "        else:",
            "            LOG.debug('search fail: unknown scope %s', scope)",
            "            raise NotImplementedError('Search scope %s not implemented.'",
            "                                      % scope)",
            "",
            "        objects = []",
            "        for dn, attrs in results:",
            "            # filter the objects by filterstr",
            "            id_attr, id_val, _ = ldap.dn.str2dn(core.utf8_encode(dn))[0][0]",
            "            id_attr = core.utf8_decode(id_attr)",
            "            id_val = core.utf8_decode(id_val)",
            "            match_attrs = attrs.copy()",
            "            match_attrs[id_attr] = [id_val]",
            "            if not filterstr or _match_query(filterstr, match_attrs):",
            "                # filter the attributes by attrlist",
            "                attrs = dict([(k, v) for k, v in six.iteritems(attrs)",
            "                              if not attrlist or k in attrlist])",
            "                objects.append((dn, attrs))",
            "",
            "        return objects",
            "",
            "    def set_option(self, option, invalue):",
            "        self._ldap_options[option] = invalue",
            "",
            "    def get_option(self, option):",
            "        value = self._ldap_options.get(option, None)",
            "        return value",
            "",
            "    def search_ext(self, base, scope,",
            "                   filterstr='(objectClass=*)', attrlist=None, attrsonly=0,",
            "                   serverctrls=None, clientctrls=None,",
            "                   timeout=-1, sizelimit=0):",
            "        raise exception.NotImplemented()",
            "",
            "    def result3(self, msgid=ldap.RES_ANY, all=1, timeout=None,",
            "                resp_ctrl_classes=None):",
            "        raise exception.NotImplemented()"
        ],
        "afterPatchFile": [
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"Fake LDAP server for test harness.",
            "",
            "This class does very little error checking, and knows nothing about ldap",
            "class definitions.  It implements the minimum emulation of the python ldap",
            "library to work with nova.",
            "",
            "\"\"\"",
            "",
            "import re",
            "import shelve",
            "",
            "import ldap",
            "import six",
            "from six import moves",
            "",
            "from keystone.common.ldap import core",
            "from keystone import exception",
            "from keystone.openstack.common.gettextutils import _",
            "from keystone.openstack.common import log",
            "",
            "",
            "SCOPE_NAMES = {",
            "    ldap.SCOPE_BASE: 'SCOPE_BASE',",
            "    ldap.SCOPE_ONELEVEL: 'SCOPE_ONELEVEL',",
            "    ldap.SCOPE_SUBTREE: 'SCOPE_SUBTREE',",
            "}",
            "",
            "# http://msdn.microsoft.com\\",
            "#     /en-us/library/windows/desktop/aa366991(v=vs.85).aspx",
            "CONTROL_TREEDELETE = '1.2.840.113556.1.4.805'",
            "",
            "LOG = log.getLogger(__name__)",
            "",
            "",
            "def _internal_attr(attr_name, value_or_values):",
            "    def normalize_value(value):",
            "        return core.utf8_decode(value)",
            "",
            "    def normalize_dn(dn):",
            "        # Capitalize the attribute names as an LDAP server might.",
            "",
            "        # NOTE(blk-u): Special case for this tested value, used with",
            "        # test_user_id_comma. The call to str2dn here isn't always correct",
            "        # here, because `dn` is escaped for an LDAP filter. str2dn() normally",
            "        # works only because there's no special characters in `dn`.",
            "        if dn == 'cn=Doe\\\\5c, John,ou=Users,cn=example,cn=com':",
            "            return 'CN=Doe\\\\, John,OU=Users,CN=example,CN=com'",
            "",
            "        # NOTE(blk-u): Another special case for this tested value. When a",
            "        # roleOccupant has an escaped comma, it gets converted to \\2C.",
            "        if dn == 'cn=Doe\\\\, John,ou=Users,cn=example,cn=com':",
            "            return 'CN=Doe\\\\2C John,OU=Users,CN=example,CN=com'",
            "",
            "        dn = ldap.dn.str2dn(core.utf8_encode(dn))",
            "        norm = []",
            "        for part in dn:",
            "            name, val, i = part[0]",
            "            name = core.utf8_decode(name)",
            "            name = name.upper()",
            "            name = core.utf8_encode(name)",
            "            norm.append([(name, val, i)])",
            "        return core.utf8_decode(ldap.dn.dn2str(norm))",
            "",
            "    if attr_name in ('member', 'roleOccupant'):",
            "        attr_fn = normalize_dn",
            "    else:",
            "        attr_fn = normalize_value",
            "",
            "    if isinstance(value_or_values, list):",
            "        return [attr_fn(x) for x in value_or_values]",
            "    return [attr_fn(value_or_values)]",
            "",
            "",
            "def _match_query(query, attrs):",
            "    \"\"\"Match an ldap query to an attribute dictionary.",
            "",
            "    The characters &, |, and ! are supported in the query. No syntax checking",
            "    is performed, so malformed queries will not work correctly.",
            "    \"\"\"",
            "    # cut off the parentheses",
            "    inner = query[1:-1]",
            "    if inner.startswith(('&', '|')):",
            "        # cut off the & or |",
            "        groups = _paren_groups(inner[1:])",
            "        return all(_match_query(group, attrs) for group in groups)",
            "    if inner.startswith('!'):",
            "        # cut off the ! and the nested parentheses",
            "        return not _match_query(query[2:-1], attrs)",
            "",
            "    (k, _sep, v) = inner.partition('=')",
            "    return _match(k, v, attrs)",
            "",
            "",
            "def _paren_groups(source):",
            "    \"\"\"Split a string into parenthesized groups.\"\"\"",
            "    count = 0",
            "    start = 0",
            "    result = []",
            "    for pos in moves.range(len(source)):",
            "        if source[pos] == '(':",
            "            if count == 0:",
            "                start = pos",
            "            count += 1",
            "        if source[pos] == ')':",
            "            count -= 1",
            "            if count == 0:",
            "                result.append(source[start:pos + 1])",
            "    return result",
            "",
            "",
            "def _match(key, value, attrs):",
            "    \"\"\"Match a given key and value against an attribute list.\"\"\"",
            "    if key not in attrs:",
            "        return False",
            "    # This is a wild card search. Implemented as all or nothing for now.",
            "    if value == '*':",
            "        return True",
            "    if key == 'serviceId':",
            "        # for serviceId, the backend is returning a list of numbers",
            "        # make sure we convert them to strings first before comparing",
            "        # them",
            "        str_sids = [six.text_type(x) for x in attrs[key]]",
            "        return six.text_type(value) in str_sids",
            "    if key != 'objectclass':",
            "        check_value = _internal_attr(key, value)[0]",
            "        norm_values = list(_internal_attr(key, x)[0] for x in attrs[key])",
            "        return check_value in norm_values",
            "    # it is an objectclass check, so check subclasses",
            "    values = _subs(value)",
            "    for v in values:",
            "        if v in attrs[key]:",
            "            return True",
            "    return False",
            "",
            "",
            "def _subs(value):",
            "    \"\"\"Returns a list of subclass strings.",
            "",
            "    The strings represent the ldap objectclass plus any subclasses that",
            "    inherit from it. Fakeldap doesn't know about the ldap object structure,",
            "    so subclasses need to be defined manually in the dictionary below.",
            "",
            "    \"\"\"",
            "    subs = {'groupOfNames': ['keystoneTenant',",
            "                             'keystoneRole',",
            "                             'keystoneTenantRole']}",
            "    if value in subs:",
            "        return [value] + subs[value]",
            "    return [value]",
            "",
            "",
            "server_fail = False",
            "",
            "",
            "class FakeShelve(dict):",
            "",
            "    def sync(self):",
            "        pass",
            "",
            "",
            "FakeShelves = {}",
            "",
            "",
            "class FakeLdap(core.LDAPHandler):",
            "    '''Emulate the python-ldap API.",
            "",
            "    The python-ldap API requires all strings to be UTF-8 encoded. This",
            "    is assured by the caller of this interface",
            "    (i.e. KeystoneLDAPHandler).",
            "",
            "    However, internally this emulation MUST process and store strings",
            "    in a canonical form which permits operations on",
            "    characters. Encoded strings do not provide the ability to operate",
            "    on characters. Therefore this emulation accepts UTF-8 encoded",
            "    strings, decodes them to unicode for operations internal to this",
            "    emulation, and encodes them back to UTF-8 when returning values",
            "    from the emulation.",
            "    '''",
            "",
            "    __prefix = 'ldap:'",
            "",
            "    def __init__(self, conn=None):",
            "        super(FakeLdap, self).__init__(conn=conn)",
            "        self._ldap_options = {ldap.OPT_DEREF: ldap.DEREF_NEVER}",
            "",
            "    def connect(self, url, page_size=0, alias_dereferencing=None,",
            "                use_tls=False, tls_cacertfile=None, tls_cacertdir=None,",
            "                tls_req_cert='demand', chase_referrals=None, debug_level=None):",
            "        if url.startswith('fake://memory'):",
            "            if url not in FakeShelves:",
            "                FakeShelves[url] = FakeShelve()",
            "            self.db = FakeShelves[url]",
            "        else:",
            "            self.db = shelve.open(url[7:])",
            "",
            "        using_ldaps = url.lower().startswith(\"ldaps\")",
            "",
            "        if use_tls and using_ldaps:",
            "            raise AssertionError('Invalid TLS / LDAPS combination')",
            "",
            "        if use_tls:",
            "            if tls_cacertfile:",
            "                ldap.set_option(ldap.OPT_X_TLS_CACERTFILE, tls_cacertfile)",
            "            elif tls_cacertdir:",
            "                ldap.set_option(ldap.OPT_X_TLS_CACERTDIR, tls_cacertdir)",
            "            if tls_req_cert in core.LDAP_TLS_CERTS.values():",
            "                ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, tls_req_cert)",
            "            else:",
            "                raise ValueError(\"invalid TLS_REQUIRE_CERT tls_req_cert=%s\",",
            "                                 tls_req_cert)",
            "",
            "        if alias_dereferencing is not None:",
            "            self.set_option(ldap.OPT_DEREF, alias_dereferencing)",
            "        self.page_size = page_size",
            "",
            "    def dn(self, dn):",
            "        return core.utf8_decode(dn)",
            "",
            "    def key(self, dn):",
            "        return '%s%s' % (self.__prefix, self.dn(dn))",
            "",
            "    def simple_bind_s(self, who='', cred='',",
            "                      serverctrls=None, clientctrls=None):",
            "        \"\"\"This method is ignored, but provided for compatibility.\"\"\"",
            "        if server_fail:",
            "            raise ldap.SERVER_DOWN",
            "        if who == 'cn=Admin' and cred == 'password':",
            "            return",
            "",
            "        try:",
            "            attrs = self.db[self.key(who)]",
            "        except KeyError:",
            "            LOG.debug('bind fail: who=%s not found', core.utf8_decode(who))",
            "            raise ldap.NO_SUCH_OBJECT",
            "",
            "        db_password = None",
            "        try:",
            "            db_password = attrs['userPassword'][0]",
            "        except (KeyError, IndexError):",
            "            LOG.debug('bind fail: password for who=%s not found',",
            "                      core.utf8_decode(who))",
            "            raise ldap.INAPPROPRIATE_AUTH",
            "",
            "        if cred != db_password:",
            "            LOG.debug('bind fail: password for who=%s does not match',",
            "                      core.utf8_decode(who))",
            "            raise ldap.INVALID_CREDENTIALS",
            "",
            "    def unbind_s(self):",
            "        \"\"\"This method is ignored, but provided for compatibility.\"\"\"",
            "        if server_fail:",
            "            raise ldap.SERVER_DOWN",
            "",
            "    def add_s(self, dn, modlist):",
            "        \"\"\"Add an object with the specified attributes at dn.\"\"\"",
            "        if server_fail:",
            "            raise ldap.SERVER_DOWN",
            "",
            "        # The LDAP API raises a TypeError if attr name is None.",
            "        for k, dummy_v in modlist:",
            "            if k is None:",
            "                raise TypeError('must be string, not None. modlist=%s' %",
            "                                modlist)",
            "",
            "        key = self.key(dn)",
            "        LOG.debug('add item: dn=%(dn)s, attrs=%(attrs)s', {",
            "            'dn': dn, 'attrs': modlist})",
            "        if key in self.db:",
            "            LOG.debug('add item failed: dn=%s is already in store.',",
            "                      core.utf8_decode(dn))",
            "            raise ldap.ALREADY_EXISTS(dn)",
            "",
            "        self.db[key] = dict([(k, _internal_attr(k, v))",
            "                             for k, v in modlist])",
            "        self.db.sync()",
            "",
            "    def delete_s(self, dn):",
            "        \"\"\"Remove the ldap object at specified dn.\"\"\"",
            "        if server_fail:",
            "            raise ldap.SERVER_DOWN",
            "",
            "        key = self.key(dn)",
            "        LOG.debug('delete item: dn=%s', dn)",
            "        try:",
            "            del self.db[key]",
            "        except KeyError:",
            "            LOG.debug('delete item failed: dn=%s not found.',",
            "                      core.utf8_decode(dn))",
            "            raise ldap.NO_SUCH_OBJECT",
            "        self.db.sync()",
            "",
            "    def delete_ext_s(self, dn, serverctrls, clientctrls=None):",
            "        \"\"\"Remove the ldap object at specified dn.\"\"\"",
            "        if server_fail:",
            "            raise ldap.SERVER_DOWN",
            "",
            "        try:",
            "            if CONTROL_TREEDELETE in [c.controlType for c in serverctrls]:",
            "                LOG.debug('FakeLdap subtree_delete item: dn=%s',",
            "                          core.utf8_decode(dn))",
            "                children = [k for k, v in six.iteritems(self.db)",
            "                            if re.match('%s.*,%s' % (",
            "                                        re.escape(self.__prefix),",
            "                                        re.escape(self.dn(dn))), k)]",
            "                for c in children:",
            "                    del self.db[c]",
            "",
            "            key = self.key(dn)",
            "            LOG.debug(_('FakeLdap delete item: dn=%s'), dn)",
            "            del self.db[key]",
            "        except KeyError:",
            "            LOG.debug('delete item failed: dn=%s not found.',",
            "                      core.utf8_decode(dn))",
            "            raise ldap.NO_SUCH_OBJECT",
            "        self.db.sync()",
            "",
            "    def modify_s(self, dn, modlist):",
            "        \"\"\"Modify the object at dn using the attribute list.",
            "",
            "        :param dn: an LDAP DN",
            "        :param modlist: a list of tuples in the following form:",
            "                      ([MOD_ADD | MOD_DELETE | MOD_REPACE], attribute, value)",
            "        \"\"\"",
            "        if server_fail:",
            "            raise ldap.SERVER_DOWN",
            "",
            "        key = self.key(dn)",
            "        LOG.debug('modify item: dn=%(dn)s attrs=%(attrs)s', {",
            "            'dn': dn, 'attrs': modlist})",
            "        try:",
            "            entry = self.db[key]",
            "        except KeyError:",
            "            LOG.debug('modify item failed: dn=%s not found.',",
            "                      core.utf8_decode(dn))",
            "            raise ldap.NO_SUCH_OBJECT",
            "",
            "        for cmd, k, v in modlist:",
            "            values = entry.setdefault(k, [])",
            "            if cmd == ldap.MOD_ADD:",
            "                v = _internal_attr(k, v)",
            "                for x in v:",
            "                    if x in values:",
            "                        raise ldap.TYPE_OR_VALUE_EXISTS",
            "                values += v",
            "            elif cmd == ldap.MOD_REPLACE:",
            "                values[:] = _internal_attr(k, v)",
            "            elif cmd == ldap.MOD_DELETE:",
            "                if v is None:",
            "                    if not values:",
            "                        LOG.debug('modify item failed: '",
            "                                  'item has no attribute \"%s\" to delete', k)",
            "                        raise ldap.NO_SUCH_ATTRIBUTE",
            "                    values[:] = []",
            "                else:",
            "                    for val in _internal_attr(k, v):",
            "                        try:",
            "                            values.remove(val)",
            "                        except ValueError:",
            "                            LOG.debug('modify item failed: '",
            "                                      'item has no attribute \"%(k)s\" with '",
            "                                      'value \"%(v)s\" to delete', {",
            "                                          'k': k, 'v': val})",
            "                            raise ldap.NO_SUCH_ATTRIBUTE",
            "            else:",
            "                LOG.debug('modify item failed: unknown command %s', cmd)",
            "                raise NotImplementedError('modify_s action %s not'",
            "                                          ' implemented' % cmd)",
            "        self.db[key] = entry",
            "        self.db.sync()",
            "",
            "    def search_s(self, base, scope,",
            "                 filterstr='(objectClass=*)', attrlist=None, attrsonly=0):",
            "        \"\"\"Search for all matching objects under base using the query.",
            "",
            "        Args:",
            "        base -- dn to search under",
            "        scope -- only SCOPE_BASE and SCOPE_SUBTREE are supported",
            "        filterstr -- filter objects by",
            "        attrlist -- attrs to return. Returns all attrs if not specified",
            "",
            "        \"\"\"",
            "        if server_fail:",
            "            raise ldap.SERVER_DOWN",
            "",
            "        if scope == ldap.SCOPE_BASE:",
            "            try:",
            "                item_dict = self.db[self.key(base)]",
            "            except KeyError:",
            "                LOG.debug('search fail: dn not found for SCOPE_BASE')",
            "                raise ldap.NO_SUCH_OBJECT",
            "            results = [(base, item_dict)]",
            "        elif scope == ldap.SCOPE_SUBTREE:",
            "            results = [(k[len(self.__prefix):], v)",
            "                       for k, v in six.iteritems(self.db)",
            "                       if re.match('%s.*,%s' % (re.escape(self.__prefix),",
            "                                                re.escape(self.dn(base))), k)]",
            "        elif scope == ldap.SCOPE_ONELEVEL:",
            "",
            "            def get_entries():",
            "                base_dn = ldap.dn.str2dn(core.utf8_encode(base))",
            "                base_len = len(base_dn)",
            "",
            "                for k, v in six.iteritems(self.db):",
            "                    if not k.startswith(self.__prefix):",
            "                        continue",
            "                    k_dn_str = k[len(self.__prefix):]",
            "                    k_dn = ldap.dn.str2dn(core.utf8_encode(k_dn_str))",
            "                    if len(k_dn) != base_len + 1:",
            "                        continue",
            "                    if k_dn[-base_len:] != base_dn:",
            "                        continue",
            "                    yield (k_dn_str, v)",
            "",
            "            results = list(get_entries())",
            "",
            "        else:",
            "            LOG.debug('search fail: unknown scope %s', scope)",
            "            raise NotImplementedError('Search scope %s not implemented.'",
            "                                      % scope)",
            "",
            "        objects = []",
            "        for dn, attrs in results:",
            "            # filter the objects by filterstr",
            "            id_attr, id_val, _ = ldap.dn.str2dn(core.utf8_encode(dn))[0][0]",
            "            id_attr = core.utf8_decode(id_attr)",
            "            id_val = core.utf8_decode(id_val)",
            "            match_attrs = attrs.copy()",
            "            match_attrs[id_attr] = [id_val]",
            "            if not filterstr or _match_query(filterstr, match_attrs):",
            "                # filter the attributes by attrlist",
            "                attrs = dict([(k, v) for k, v in six.iteritems(attrs)",
            "                              if not attrlist or k in attrlist])",
            "                objects.append((dn, attrs))",
            "",
            "        return objects",
            "",
            "    def set_option(self, option, invalue):",
            "        self._ldap_options[option] = invalue",
            "",
            "    def get_option(self, option):",
            "        value = self._ldap_options.get(option, None)",
            "        return value",
            "",
            "    def search_ext(self, base, scope,",
            "                   filterstr='(objectClass=*)', attrlist=None, attrsonly=0,",
            "                   serverctrls=None, clientctrls=None,",
            "                   timeout=-1, sizelimit=0):",
            "        raise exception.NotImplemented()",
            "",
            "    def result3(self, msgid=ldap.RES_ANY, all=1, timeout=None,",
            "                resp_ctrl_classes=None):",
            "        raise exception.NotImplemented()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "136": [
                "_match"
            ]
        },
        "addLocation": [
            "keystone.tests.fakeldap._internal_attr",
            "keystone.tests.fakeldap._internal_attr.attr_fn"
        ]
    },
    "keystone/tests/test_backend_ldap.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 594,
                "afterPatchRowNumber": 594,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 595,
                "afterPatchRowNumber": 595,
                "PatchRowcode": "         self.assertThat(ref_list, matchers.Equals([group]))"
            },
            "2": {
                "beforePatchRowNumber": 596,
                "afterPatchRowNumber": 596,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 597,
                "PatchRowcode": "+    def test_user_id_comma_grants(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 598,
                "PatchRowcode": "+        \"\"\"Even if the user has a , in their ID, can get user and group grants."
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 599,
                "PatchRowcode": "+        \"\"\""
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 600,
                "PatchRowcode": "+"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 601,
                "PatchRowcode": "+        # Create a user with a , in their ID"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 602,
                "PatchRowcode": "+        # NOTE(blk-u): the DN for this user is hard-coded in fakeldap!"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 603,
                "PatchRowcode": "+        user_id = u'Doe, John'"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 604,
                "PatchRowcode": "+        user = {"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 605,
                "PatchRowcode": "+            'id': user_id,"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 606,
                "PatchRowcode": "+            'name': self.getUniqueString(),"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 607,
                "PatchRowcode": "+            'password': self.getUniqueString(),"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 608,
                "PatchRowcode": "+            'domain_id': CONF.identity.default_domain_id,"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 609,
                "PatchRowcode": "+        }"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 610,
                "PatchRowcode": "+        self.identity_api.create_user(user_id, user)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 611,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 612,
                "PatchRowcode": "+        # Grant the user a role on a project."
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 613,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 614,
                "PatchRowcode": "+        role_id = 'member'"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 615,
                "PatchRowcode": "+        project_id = self.tenant_baz['id']"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 616,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 617,
                "PatchRowcode": "+        self.assignment_api.create_grant(role_id, user_id=user_id,"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 618,
                "PatchRowcode": "+                                         project_id=project_id)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 619,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 620,
                "PatchRowcode": "+        role_ref = self.assignment_api.get_grant(role_id, user_id=user_id,"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 621,
                "PatchRowcode": "+                                                 project_id=project_id)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 622,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 623,
                "PatchRowcode": "+        self.assertEqual(role_id, role_ref['id'])"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 624,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": 597,
                "afterPatchRowNumber": 625,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": 598,
                "afterPatchRowNumber": 626,
                "PatchRowcode": " class LDAPIdentity(BaseLDAPIdentity, tests.TestCase):"
            },
            "33": {
                "beforePatchRowNumber": 599,
                "afterPatchRowNumber": 627,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 1250,
                "afterPatchRowNumber": 1278,
                "PatchRowcode": "             user1['id'], CONF.identity.default_domain_id)"
            },
            "35": {
                "beforePatchRowNumber": 1251,
                "afterPatchRowNumber": 1279,
                "PatchRowcode": "         self.assertEqual(0, len(combined_role_list))"
            },
            "36": {
                "beforePatchRowNumber": 1252,
                "afterPatchRowNumber": 1280,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 1253,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def test_get_roles_for_user_and_project_user_group_same_id(self):"
            },
            "38": {
                "beforePatchRowNumber": 1254,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\"When a user has the same ID as a group,"
            },
            "39": {
                "beforePatchRowNumber": 1255,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        get_roles_for_user_and_project returns the roles for the group."
            },
            "40": {
                "beforePatchRowNumber": 1256,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "41": {
                "beforePatchRowNumber": 1257,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        Overriding this test for LDAP because it works differently. The role"
            },
            "42": {
                "beforePatchRowNumber": 1258,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for the group is returned. This is bug 1309228."
            },
            "43": {
                "beforePatchRowNumber": 1259,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        \"\"\""
            },
            "44": {
                "beforePatchRowNumber": 1260,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "45": {
                "beforePatchRowNumber": 1261,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Setup: create user, group with same ID, role, and project;"
            },
            "46": {
                "beforePatchRowNumber": 1262,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # assign the group the role on the project."
            },
            "47": {
                "beforePatchRowNumber": 1263,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "48": {
                "beforePatchRowNumber": 1264,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        user_group_id = uuid.uuid4().hex"
            },
            "49": {
                "beforePatchRowNumber": 1265,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "50": {
                "beforePatchRowNumber": 1266,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        user1 = {'id': user_group_id, 'name': uuid.uuid4().hex,"
            },
            "51": {
                "beforePatchRowNumber": 1267,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                 'domain_id': CONF.identity.default_domain_id, }"
            },
            "52": {
                "beforePatchRowNumber": 1268,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.identity_api.create_user(user_group_id, user1)"
            },
            "53": {
                "beforePatchRowNumber": 1269,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "54": {
                "beforePatchRowNumber": 1270,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        group1 = {'id': user_group_id, 'name': uuid.uuid4().hex,"
            },
            "55": {
                "beforePatchRowNumber": 1271,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                  'domain_id': CONF.identity.default_domain_id, }"
            },
            "56": {
                "beforePatchRowNumber": 1272,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.identity_api.create_group(user_group_id, group1)"
            },
            "57": {
                "beforePatchRowNumber": 1273,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "58": {
                "beforePatchRowNumber": 1274,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}"
            },
            "59": {
                "beforePatchRowNumber": 1275,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assignment_api.create_role(role1['id'], role1)"
            },
            "60": {
                "beforePatchRowNumber": 1276,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "61": {
                "beforePatchRowNumber": 1277,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,"
            },
            "62": {
                "beforePatchRowNumber": 1278,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    'domain_id': CONF.identity.default_domain_id, }"
            },
            "63": {
                "beforePatchRowNumber": 1279,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assignment_api.create_project(project1['id'], project1)"
            },
            "64": {
                "beforePatchRowNumber": 1280,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "65": {
                "beforePatchRowNumber": 1281,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assignment_api.create_grant(role1['id'],"
            },
            "66": {
                "beforePatchRowNumber": 1282,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                         group_id=user_group_id,"
            },
            "67": {
                "beforePatchRowNumber": 1283,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                         project_id=project1['id'])"
            },
            "68": {
                "beforePatchRowNumber": 1284,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "69": {
                "beforePatchRowNumber": 1285,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Check the roles, shouldn't be any since the user wasn't granted any."
            },
            "70": {
                "beforePatchRowNumber": 1286,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        roles = self.assignment_api.get_roles_for_user_and_project("
            },
            "71": {
                "beforePatchRowNumber": 1287,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            user_group_id, project1['id'])"
            },
            "72": {
                "beforePatchRowNumber": 1288,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "73": {
                "beforePatchRowNumber": 1289,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertEqual([role1['id']], roles,"
            },
            "74": {
                "beforePatchRowNumber": 1290,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                         'role for group is %s' % role1['id'])"
            },
            "75": {
                "beforePatchRowNumber": 1291,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "76": {
                "beforePatchRowNumber": 1292,
                "afterPatchRowNumber": 1281,
                "PatchRowcode": "     def test_list_projects_for_alternate_domain(self):"
            },
            "77": {
                "beforePatchRowNumber": 1293,
                "afterPatchRowNumber": 1282,
                "PatchRowcode": "         self.skipTest("
            },
            "78": {
                "beforePatchRowNumber": 1294,
                "afterPatchRowNumber": 1283,
                "PatchRowcode": "             'N/A: LDAP does not support multiple domains')"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2012 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import copy",
            "import uuid",
            "",
            "import ldap",
            "import mock",
            "from testtools import matchers",
            "",
            "from keystone import assignment",
            "from keystone.common import cache",
            "from keystone.common import ldap as common_ldap",
            "from keystone.common.ldap import core as common_ldap_core",
            "from keystone.common import sql",
            "from keystone import config",
            "from keystone import exception",
            "from keystone import identity",
            "from keystone import tests",
            "from keystone.tests import default_fixtures",
            "from keystone.tests import fakeldap",
            "from keystone.tests.ksfixtures import database",
            "from keystone.tests import test_backend",
            "",
            "",
            "CONF = config.CONF",
            "",
            "",
            "class BaseLDAPIdentity(test_backend.IdentityTests):",
            "",
            "    def setUp(self):",
            "        super(BaseLDAPIdentity, self).setUp()",
            "        self.clear_database()",
            "",
            "        common_ldap.register_handler('fake://', fakeldap.FakeLdap)",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "",
            "        self.addCleanup(common_ldap_core._HANDLERS.clear)",
            "",
            "    def _get_domain_fixture(self):",
            "        \"\"\"Domains in LDAP are read-only, so just return the static one.\"\"\"",
            "        return self.assignment_api.get_domain(CONF.identity.default_domain_id)",
            "",
            "    def clear_database(self):",
            "        for shelf in fakeldap.FakeShelves:",
            "            fakeldap.FakeShelves[shelf].clear()",
            "",
            "    def reload_backends(self, domain_id):",
            "        # Only one backend unless we are using separate domain backends",
            "        self.load_backends()",
            "",
            "    def get_config(self, domain_id):",
            "        # Only one conf structure unless we are using separate domain backends",
            "        return CONF",
            "",
            "    def config_overrides(self):",
            "        super(BaseLDAPIdentity, self).config_overrides()",
            "        self.config_fixture.config(",
            "            group='identity',",
            "            driver='keystone.identity.backends.ldap.Identity')",
            "",
            "    def config_files(self):",
            "        config_files = super(BaseLDAPIdentity, self).config_files()",
            "        config_files.append(tests.dirs.tests_conf('backend_ldap.conf'))",
            "        return config_files",
            "",
            "    def test_build_tree(self):",
            "        \"\"\"Regression test for building the tree names",
            "        \"\"\"",
            "        user_api = identity.backends.ldap.UserApi(CONF)",
            "        self.assertTrue(user_api)",
            "        self.assertEqual(\"ou=Users,%s\" % CONF.ldap.suffix, user_api.tree_dn)",
            "",
            "    def test_configurable_allowed_user_actions(self):",
            "        user = {'id': u'f\u00e4k\u00e91',",
            "                'name': u'f\u00e4k\u00e91',",
            "                'password': u'f\u00e4k\u00e9pass1',",
            "                'domain_id': CONF.identity.default_domain_id,",
            "                'tenants': ['bar']}",
            "        self.identity_api.create_user(u'f\u00e4k\u00e91', user)",
            "        user_ref = self.identity_api.get_user(u'f\u00e4k\u00e91')",
            "        self.assertEqual(u'f\u00e4k\u00e91', user_ref['id'])",
            "",
            "        user['password'] = u'f\u00e4k\u00e9pass2'",
            "        self.identity_api.update_user(u'f\u00e4k\u00e91', user)",
            "",
            "        self.identity_api.delete_user(u'f\u00e4k\u00e91')",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          u'f\u00e4k\u00e91')",
            "",
            "    def test_configurable_forbidden_user_actions(self):",
            "        conf = self.get_config(CONF.identity.default_domain_id)",
            "        conf.ldap.user_allow_create = False",
            "        conf.ldap.user_allow_update = False",
            "        conf.ldap.user_allow_delete = False",
            "        self.reload_backends(CONF.identity.default_domain_id)",
            "",
            "        user = {'id': u'f\u00e4k\u00e91',",
            "                'name': u'f\u00e4k\u00e91',",
            "                'password': u'f\u00e4k\u00e9pass1',",
            "                'domain_id': CONF.identity.default_domain_id,",
            "                'tenants': ['bar']}",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.identity_api.create_user,",
            "                          u'f\u00e4k\u00e91',",
            "                          user)",
            "",
            "        self.user_foo['password'] = u'f\u00e4k\u00e9pass2'",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.identity_api.update_user,",
            "                          self.user_foo['id'],",
            "                          self.user_foo)",
            "",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.identity_api.delete_user,",
            "                          self.user_foo['id'])",
            "",
            "    def test_configurable_forbidden_create_existing_user(self):",
            "        conf = self.get_config(CONF.identity.default_domain_id)",
            "        conf.ldap.user_allow_create = False",
            "        self.reload_backends(CONF.identity.default_domain_id)",
            "",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.identity_api.create_user,",
            "                          self.user_foo['id'],",
            "                          self.user_foo)",
            "",
            "    def test_user_filter(self):",
            "        user_ref = self.identity_api.get_user(self.user_foo['id'])",
            "        self.user_foo.pop('password')",
            "        self.assertDictEqual(user_ref, self.user_foo)",
            "",
            "        conf = self.get_config(user_ref['domain_id'])",
            "        conf.ldap.user_filter = '(CN=DOES_NOT_MATCH)'",
            "        self.reload_backends(user_ref['domain_id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          self.user_foo['id'])",
            "",
            "    def test_remove_role_grant_from_user_and_project(self):",
            "        self.assignment_api.create_grant(user_id=self.user_foo['id'],",
            "                                         project_id=self.tenant_baz['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=self.user_foo['id'],",
            "            project_id=self.tenant_baz['id'])",
            "        self.assertDictEqual(roles_ref[0], self.role_member)",
            "",
            "        self.assignment_api.delete_grant(user_id=self.user_foo['id'],",
            "                                         project_id=self.tenant_baz['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=self.user_foo['id'],",
            "            project_id=self.tenant_baz['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.delete_grant,",
            "                          user_id=self.user_foo['id'],",
            "                          project_id=self.tenant_baz['id'],",
            "                          role_id='member')",
            "",
            "    def test_get_and_remove_role_grant_by_group_and_project(self):",
            "        new_domain = self._get_domain_fixture()",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': new_domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'enabled': True,",
            "                    'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            new_group['id'])",
            "",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            project_id=self.tenant_bar['id'])",
            "        self.assertEqual([], roles_ref)",
            "        self.assertEqual(0, len(roles_ref))",
            "",
            "        self.assignment_api.create_grant(group_id=new_group['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            project_id=self.tenant_bar['id'])",
            "        self.assertNotEmpty(roles_ref)",
            "        self.assertDictEqual(roles_ref[0], self.role_member)",
            "",
            "        self.assignment_api.delete_grant(group_id=new_group['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            project_id=self.tenant_bar['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.delete_grant,",
            "                          group_id=new_group['id'],",
            "                          project_id=self.tenant_bar['id'],",
            "                          role_id='member')",
            "",
            "    def test_delete_user_grant_no_user(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_delete_group_grant_no_group(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_get_and_remove_role_grant_by_group_and_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_get_and_remove_role_grant_by_user_and_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_get_and_remove_correct_role_grant_from_a_mix(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_get_and_remove_role_grant_by_group_and_cross_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_get_and_remove_role_grant_by_user_and_cross_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_role_grant_by_group_and_cross_domain_project(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_role_grant_by_user_and_cross_domain_project(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_multi_role_grant_by_user_group_on_project_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_delete_role_with_user_and_group_grants(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_delete_user_with_group_project_domain_links(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_delete_group_with_user_project_domain_links(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_list_projects_for_user(self):",
            "        domain = self._get_domain_fixture()",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'password': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        user_projects = self.assignment_api.list_projects_for_user(user1['id'])",
            "        self.assertEqual(0, len(user_projects))",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id=self.role_member['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=self.tenant_baz['id'],",
            "                                         role_id=self.role_member['id'])",
            "        user_projects = self.assignment_api.list_projects_for_user(user1['id'])",
            "        self.assertEqual(2, len(user_projects))",
            "",
            "    def test_list_projects_for_user_with_grants(self):",
            "        domain = self._get_domain_fixture()",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "",
            "        group1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain['id']}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        group2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain['id']}",
            "        self.identity_api.create_group(group2['id'], group2)",
            "",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        project2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain['id']}",
            "        self.assignment_api.create_project(project2['id'], project2)",
            "",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            group1['id'])",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            group2['id'])",
            "",
            "        self.assignment_api.create_grant(user_id=new_user['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id=self.role_member['id'])",
            "        self.assignment_api.create_grant(user_id=new_user['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=self.role_admin['id'])",
            "        self.assignment_api.create_grant(group_id=group2['id'],",
            "                                         project_id=project2['id'],",
            "                                         role_id=self.role_admin['id'])",
            "",
            "        user_projects = self.assignment_api.list_projects_for_user(",
            "            new_user['id'])",
            "        self.assertEqual(2, len(user_projects))",
            "",
            "    def test_create_duplicate_user_name_in_different_domains(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_create_duplicate_project_name_in_different_domains(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_create_duplicate_group_name_in_different_domains(self):",
            "        self.skipTest(",
            "            'N/A: LDAP does not support multiple domains')",
            "",
            "    def test_move_user_between_domains(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_move_user_between_domains_with_clashing_names_fails(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_move_group_between_domains(self):",
            "        self.skipTest(",
            "            'N/A: LDAP does not support multiple domains')",
            "",
            "    def test_move_group_between_domains_with_clashing_names_fails(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_move_project_between_domains(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_move_project_between_domains_with_clashing_names_fails(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_get_roles_for_user_and_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_list_role_assignments_unfiltered(self):",
            "        new_domain = self._get_domain_fixture()",
            "        new_user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user['id'],",
            "                                      new_user)",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': new_domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        new_project = {'id': uuid.uuid4().hex,",
            "                       'name': uuid.uuid4().hex,",
            "                       'domain_id': new_domain['id']}",
            "        self.assignment_api.create_project(new_project['id'], new_project)",
            "",
            "        # First check how many role grant already exist",
            "        existing_assignments = len(self.assignment_api.list_role_assignments())",
            "",
            "        self.assignment_api.create_grant(user_id=new_user['id'],",
            "                                         project_id=new_project['id'],",
            "                                         role_id='other')",
            "        self.assignment_api.create_grant(group_id=new_group['id'],",
            "                                         project_id=new_project['id'],",
            "                                         role_id='admin')",
            "",
            "        # Read back the list of assignments - check it is gone up by 2",
            "        after_assignments = len(self.assignment_api.list_role_assignments())",
            "        self.assertEqual(existing_assignments + 2, after_assignments)",
            "",
            "    def test_list_role_assignments_dumb_member(self):",
            "        self.config_fixture.config(group='ldap', use_dumb_member=True)",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "",
            "        new_domain = self._get_domain_fixture()",
            "        new_user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user['id'],",
            "                                      new_user)",
            "        new_project = {'id': uuid.uuid4().hex,",
            "                       'name': uuid.uuid4().hex,",
            "                       'domain_id': new_domain['id']}",
            "        self.assignment_api.create_project(new_project['id'], new_project)",
            "        self.assignment_api.create_grant(user_id=new_user['id'],",
            "                                         project_id=new_project['id'],",
            "                                         role_id='other')",
            "",
            "        # Read back the list of assignments and ensure",
            "        # that the LDAP dumb member isn't listed.",
            "        assignment_ids = [a['user_id'] for a in",
            "                          self.assignment_api.list_role_assignments()]",
            "        dumb_id = common_ldap.BaseLdap._dn_to_id(CONF.ldap.dumb_member)",
            "        self.assertNotIn(dumb_id, assignment_ids)",
            "",
            "    def test_list_role_assignments_bad_role(self):",
            "        self.skipTest('Blocked by bug 1221805')",
            "",
            "    def test_multi_group_grants_on_project_domain(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_list_group_members_missing_entry(self):",
            "        \"\"\"List group members with deleted user.",
            "",
            "        If a group has a deleted entry for a member, the non-deleted members",
            "        are returned.",
            "",
            "        \"\"\"",
            "",
            "        # Create a group",
            "        group_id = None",
            "        group = dict(name=uuid.uuid4().hex,",
            "                     domain_id=CONF.identity.default_domain_id)",
            "        group_id = self.identity_api.create_group(group_id, group)['id']",
            "",
            "        # Create a couple of users and add them to the group.",
            "        user_id = None",
            "        user = dict(name=uuid.uuid4().hex, id=uuid.uuid4().hex,",
            "                    domain_id=CONF.identity.default_domain_id)",
            "        user_1_id = self.identity_api.create_user(user_id, user)['id']",
            "",
            "        self.identity_api.add_user_to_group(user_1_id, group_id)",
            "",
            "        user_id = None",
            "        user = dict(name=uuid.uuid4().hex, id=uuid.uuid4().hex,",
            "                    domain_id=CONF.identity.default_domain_id)",
            "        user_2_id = self.identity_api.create_user(user_id, user)['id']",
            "",
            "        self.identity_api.add_user_to_group(user_2_id, group_id)",
            "",
            "        # Delete user 2",
            "        # NOTE(blk-u): need to go directly to user interface to keep from",
            "        # updating the group.",
            "        driver = self.identity_api._select_identity_driver(",
            "            user['domain_id'])",
            "        driver.user.delete(user_2_id)",
            "",
            "        # List group users and verify only user 1.",
            "        res = self.identity_api.list_users_in_group(group_id)",
            "",
            "        self.assertEqual(1, len(res), \"Expected 1 entry (user_1)\")",
            "        self.assertEqual(user_1_id, res[0]['id'], \"Expected user 1 id\")",
            "",
            "    def test_list_group_members_when_no_members(self):",
            "        # List group members when there is no member in the group.",
            "        # No exception should be raised.",
            "        group = {",
            "            'id': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'name': uuid.uuid4().hex,",
            "            'description': uuid.uuid4().hex}",
            "        self.identity_api.create_group(group['id'], group)",
            "",
            "        # If this doesn't raise, then the test is successful.",
            "        self.identity_api.list_users_in_group(group['id'])",
            "",
            "    def test_list_domains(self):",
            "        domains = self.assignment_api.list_domains()",
            "        self.assertEqual(",
            "            [assignment.calc_default_domain()],",
            "            domains)",
            "",
            "    def test_list_domains_non_default_domain_id(self):",
            "        # If change the default_domain_id, the ID of the default domain",
            "        # returned by list_domains changes is the new default_domain_id.",
            "",
            "        new_domain_id = uuid.uuid4().hex",
            "        self.config_fixture.config(group='identity',",
            "                                   default_domain_id=new_domain_id)",
            "",
            "        domains = self.assignment_api.list_domains()",
            "",
            "        self.assertEqual(new_domain_id, domains[0]['id'])",
            "",
            "    def test_authenticate_requires_simple_bind(self):",
            "        user = {",
            "            'id': 'no_meta',",
            "            'name': 'NO_META',",
            "            'domain_id': test_backend.DEFAULT_DOMAIN_ID,",
            "            'password': 'no_meta2',",
            "            'enabled': True,",
            "        }",
            "        self.identity_api.create_user(user['id'], user)",
            "        self.assignment_api.add_user_to_project(self.tenant_baz['id'],",
            "                                                user['id'])",
            "        driver = self.identity_api._select_identity_driver(",
            "            user['domain_id'])",
            "        driver.user.LDAP_USER = None",
            "        driver.user.LDAP_PASSWORD = None",
            "",
            "        self.assertRaises(AssertionError,",
            "                          self.identity_api.authenticate,",
            "                          context={},",
            "                          user_id=user['id'],",
            "                          password=None,",
            "                          domain_scope=user['domain_id'])",
            "",
            "    # (spzala)The group and domain crud tests below override the standard ones",
            "    # in test_backend.py so that we can exclude the update name test, since we",
            "    # do not yet support the update of either group or domain names with LDAP.",
            "    # In the tests below, the update is demonstrated by updating description.",
            "    # Refer to bug 1136403 for more detail.",
            "    def test_group_crud(self):",
            "        group = {",
            "            'id': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'name': uuid.uuid4().hex,",
            "            'description': uuid.uuid4().hex}",
            "        self.identity_api.create_group(group['id'], group)",
            "        group_ref = self.identity_api.get_group(group['id'])",
            "        self.assertDictEqual(group_ref, group)",
            "        group['description'] = uuid.uuid4().hex",
            "        self.identity_api.update_group(group['id'], group)",
            "        group_ref = self.identity_api.get_group(group['id'])",
            "        self.assertDictEqual(group_ref, group)",
            "",
            "        self.identity_api.delete_group(group['id'])",
            "        self.assertRaises(exception.GroupNotFound,",
            "                          self.identity_api.get_group,",
            "                          group['id'])",
            "",
            "    def test_create_user_none_mapping(self):",
            "        # When create a user where an attribute maps to None, the entry is",
            "        # created without that attribute and it doesn't fail with a TypeError.",
            "        conf = self.get_config(CONF.identity.default_domain_id)",
            "        conf.ldap.user_attribute_ignore = ['enabled', 'email',",
            "                                           'tenants', 'tenantId']",
            "        self.reload_backends(CONF.identity.default_domain_id)",
            "",
            "        user = {'id': u'f\u00e4k\u00e91',",
            "                'name': u'f\u00e4k\u00e91',",
            "                'password': u'f\u00e4k\u00e9pass1',",
            "                'domain_id': CONF.identity.default_domain_id,",
            "                'default_project_id': 'maps_to_none',",
            "                }",
            "",
            "        # If this doesn't raise, then the test is successful.",
            "        self.identity_api.create_user(u'f\u00e4k\u00e91', user)",
            "",
            "    def test_update_user_name(self):",
            "        \"\"\"A user's name cannot be changed through the LDAP driver.\"\"\"",
            "        self.assertRaises(exception.Conflict,",
            "                          super(BaseLDAPIdentity, self).test_update_user_name)",
            "",
            "    def test_attribute_update(self):",
            "        self.skipTest(\"Blank value in a required field is an error in LDAP\")",
            "",
            "    def test_arbitrary_attributes_are_returned_from_create_user(self):",
            "        self.skipTest(\"Using arbitrary attributes doesn't work under LDAP\")",
            "",
            "    def test_arbitrary_attributes_are_returned_from_get_user(self):",
            "        self.skipTest(\"Using arbitrary attributes doesn't work under LDAP\")",
            "",
            "    def test_new_arbitrary_attributes_are_returned_from_update_user(self):",
            "        self.skipTest(\"Using arbitrary attributes doesn't work under LDAP\")",
            "",
            "    def test_updated_arbitrary_attributes_are_returned_from_update_user(self):",
            "        self.skipTest(\"Using arbitrary attributes doesn't work under LDAP\")",
            "",
            "    def test_user_id_comma(self):",
            "        \"\"\"Even if the user has a , in their ID, groups can be listed.\"\"\"",
            "",
            "        # Create a user with a , in their ID",
            "        # NOTE(blk-u): the DN for this user is hard-coded in fakeldap!",
            "        user_id = u'Doe, John'",
            "        user = {",
            "            'id': user_id,",
            "            'name': self.getUniqueString(),",
            "            'password': self.getUniqueString(),",
            "            'domain_id': CONF.identity.default_domain_id,",
            "        }",
            "        self.identity_api.create_user(user_id, user)",
            "",
            "        # Create a group",
            "        group_id = uuid.uuid4().hex",
            "        group = {",
            "            'id': group_id,",
            "            'name': self.getUniqueString(prefix='tuidc'),",
            "            'description': self.getUniqueString(),",
            "            'domain_id': CONF.identity.default_domain_id,",
            "        }",
            "        self.identity_api.create_group(group_id, group)",
            "",
            "        # Put the user in the group",
            "        self.identity_api.add_user_to_group(user_id, group_id)",
            "",
            "        # List groups for user.",
            "        ref_list = self.identity_api.list_groups_for_user(user_id)",
            "",
            "        self.assertThat(ref_list, matchers.Equals([group]))",
            "",
            "",
            "class LDAPIdentity(BaseLDAPIdentity, tests.TestCase):",
            "",
            "    def setUp(self):",
            "        # NOTE(dstanek): The database must be setup prior to calling the",
            "        # parent's setUp. The parent's setUp uses services (like",
            "        # credentials) that require a database.",
            "        self.useFixture(database.Database())",
            "        super(LDAPIdentity, self).setUp()",
            "",
            "    def test_configurable_allowed_project_actions(self):",
            "        tenant = {'id': u'f\u00e4k\u00e91', 'name': u'f\u00e4k\u00e91', 'enabled': True}",
            "        self.assignment_api.create_project(u'f\u00e4k\u00e91', tenant)",
            "        tenant_ref = self.assignment_api.get_project(u'f\u00e4k\u00e91')",
            "        self.assertEqual(u'f\u00e4k\u00e91', tenant_ref['id'])",
            "",
            "        tenant['enabled'] = False",
            "        self.assignment_api.update_project(u'f\u00e4k\u00e91', tenant)",
            "",
            "        self.assignment_api.delete_project(u'f\u00e4k\u00e91')",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          u'f\u00e4k\u00e91')",
            "",
            "    def test_configurable_subtree_delete(self):",
            "        self.config_fixture.config(group='ldap', allow_subtree_delete=True)",
            "        self.load_backends()",
            "",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': CONF.identity.default_domain_id}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role1['id'], role1)",
            "",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': CONF.identity.default_domain_id,",
            "                 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            user_id=user1['id'],",
            "            tenant_id=project1['id'],",
            "            role_id=role1['id'])",
            "",
            "        self.assignment_api.delete_project(project1['id'])",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project1['id'])",
            "",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        list = self.assignment_api.get_roles_for_user_and_project(",
            "            user1['id'],",
            "            project1['id'])",
            "        self.assertEqual(0, len(list))",
            "",
            "    def test_configurable_forbidden_project_actions(self):",
            "        self.config_fixture.config(",
            "            group='ldap', tenant_allow_create=False, tenant_allow_update=False,",
            "            tenant_allow_delete=False)",
            "        self.load_backends()",
            "",
            "        tenant = {'id': u'f\u00e4k\u00e91', 'name': u'f\u00e4k\u00e91'}",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.create_project,",
            "                          u'f\u00e4k\u00e91',",
            "                          tenant)",
            "",
            "        self.tenant_bar['enabled'] = False",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.update_project,",
            "                          self.tenant_bar['id'],",
            "                          self.tenant_bar)",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.delete_project,",
            "                          self.tenant_bar['id'])",
            "",
            "    def test_configurable_allowed_role_actions(self):",
            "        role = {'id': u'f\u00e4k\u00e91', 'name': u'f\u00e4k\u00e91'}",
            "        self.assignment_api.create_role(u'f\u00e4k\u00e91', role)",
            "        role_ref = self.assignment_api.get_role(u'f\u00e4k\u00e91')",
            "        self.assertEqual(u'f\u00e4k\u00e91', role_ref['id'])",
            "",
            "        role['name'] = u'f\u00e4k\u00e92'",
            "        self.assignment_api.update_role(u'f\u00e4k\u00e91', role)",
            "",
            "        self.assignment_api.delete_role(u'f\u00e4k\u00e91')",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.get_role,",
            "                          u'f\u00e4k\u00e91')",
            "",
            "    def test_configurable_forbidden_role_actions(self):",
            "        self.config_fixture.config(",
            "            group='ldap', role_allow_create=False, role_allow_update=False,",
            "            role_allow_delete=False)",
            "        self.load_backends()",
            "",
            "        role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.create_role,",
            "                          role['id'],",
            "                          role)",
            "",
            "        self.role_member['name'] = uuid.uuid4().hex",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.update_role,",
            "                          self.role_member['id'],",
            "                          self.role_member)",
            "",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.delete_role,",
            "                          self.role_member['id'])",
            "",
            "    def test_project_filter(self):",
            "        tenant_ref = self.assignment_api.get_project(self.tenant_bar['id'])",
            "        self.assertDictEqual(tenant_ref, self.tenant_bar)",
            "",
            "        self.config_fixture.config(group='ldap',",
            "                                   tenant_filter='(CN=DOES_NOT_MATCH)')",
            "        self.load_backends()",
            "        # NOTE(morganfainberg): CONF.ldap.tenant_filter  will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_role.invalidate(self.assignment_api,",
            "                                                self.role_member['id'])",
            "        self.assignment_api.get_role(self.role_member['id'])",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   self.tenant_bar['id'])",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          self.tenant_bar['id'])",
            "",
            "    def test_role_filter(self):",
            "        role_ref = self.assignment_api.get_role(self.role_member['id'])",
            "        self.assertDictEqual(role_ref, self.role_member)",
            "",
            "        self.config_fixture.config(group='ldap',",
            "                                   role_filter='(CN=DOES_NOT_MATCH)')",
            "        self.load_backends()",
            "        # NOTE(morganfainberg): CONF.ldap.role_filter will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_role.invalidate(self.assignment_api,",
            "                                                self.role_member['id'])",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.get_role,",
            "                          self.role_member['id'])",
            "",
            "    def test_dumb_member(self):",
            "        self.config_fixture.config(group='ldap', use_dumb_member=True)",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        dumb_id = common_ldap.BaseLdap._dn_to_id(CONF.ldap.dumb_member)",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          dumb_id)",
            "",
            "    def test_project_attribute_mapping(self):",
            "        self.config_fixture.config(",
            "            group='ldap', tenant_name_attribute='ou',",
            "            tenant_desc_attribute='description',",
            "            tenant_enabled_attribute='enabled')",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        # NOTE(morganfainberg): CONF.ldap.tenant_name_attribute,",
            "        # CONF.ldap.tenant_desc_attribute, and",
            "        # CONF.ldap.tenant_enabled_attribute will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   self.tenant_baz['id'])",
            "        tenant_ref = self.assignment_api.get_project(self.tenant_baz['id'])",
            "        self.assertEqual(self.tenant_baz['id'], tenant_ref['id'])",
            "        self.assertEqual(self.tenant_baz['name'], tenant_ref['name'])",
            "        self.assertEqual(",
            "            self.tenant_baz['description'],",
            "            tenant_ref['description'])",
            "        self.assertEqual(self.tenant_baz['enabled'], tenant_ref['enabled'])",
            "",
            "        self.config_fixture.config(group='ldap',",
            "                                   tenant_name_attribute='description',",
            "                                   tenant_desc_attribute='ou')",
            "        self.load_backends()",
            "        # NOTE(morganfainberg): CONF.ldap.tenant_name_attribute,",
            "        # CONF.ldap.tenant_desc_attribute, and",
            "        # CONF.ldap.tenant_enabled_attribute will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   self.tenant_baz['id'])",
            "        tenant_ref = self.assignment_api.get_project(self.tenant_baz['id'])",
            "        self.assertEqual(self.tenant_baz['id'], tenant_ref['id'])",
            "        self.assertEqual(self.tenant_baz['description'], tenant_ref['name'])",
            "        self.assertEqual(self.tenant_baz['name'], tenant_ref['description'])",
            "        self.assertEqual(self.tenant_baz['enabled'], tenant_ref['enabled'])",
            "",
            "    def test_project_attribute_ignore(self):",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            tenant_attribute_ignore=['name', 'description', 'enabled'])",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        # NOTE(morganfainberg): CONF.ldap.tenant_attribute_ignore will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change configs values in tests",
            "        # that could affect what the drivers would return up to the manager.",
            "        # This solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   self.tenant_baz['id'])",
            "        tenant_ref = self.assignment_api.get_project(self.tenant_baz['id'])",
            "        self.assertEqual(self.tenant_baz['id'], tenant_ref['id'])",
            "        self.assertNotIn('name', tenant_ref)",
            "        self.assertNotIn('description', tenant_ref)",
            "        self.assertNotIn('enabled', tenant_ref)",
            "",
            "    def test_role_attribute_mapping(self):",
            "        self.config_fixture.config(group='ldap', role_name_attribute='ou')",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        # NOTE(morganfainberg): CONF.ldap.role_name_attribute will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_role.invalidate(self.assignment_api,",
            "                                                self.role_member['id'])",
            "        role_ref = self.assignment_api.get_role(self.role_member['id'])",
            "        self.assertEqual(self.role_member['id'], role_ref['id'])",
            "        self.assertEqual(self.role_member['name'], role_ref['name'])",
            "",
            "        self.config_fixture.config(group='ldap', role_name_attribute='sn')",
            "        self.load_backends()",
            "        # NOTE(morganfainberg): CONF.ldap.role_name_attribute will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_role.invalidate(self.assignment_api,",
            "                                                self.role_member['id'])",
            "        role_ref = self.assignment_api.get_role(self.role_member['id'])",
            "        self.assertEqual(self.role_member['id'], role_ref['id'])",
            "        self.assertNotIn('name', role_ref)",
            "",
            "    def test_role_attribute_ignore(self):",
            "        self.config_fixture.config(group='ldap',",
            "                                   role_attribute_ignore=['name'])",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        # NOTE(morganfainberg): CONF.ldap.role_attribute_ignore will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_role.invalidate(self.assignment_api,",
            "                                                self.role_member['id'])",
            "        role_ref = self.assignment_api.get_role(self.role_member['id'])",
            "        self.assertEqual(self.role_member['id'], role_ref['id'])",
            "        self.assertNotIn('name', role_ref)",
            "",
            "    def test_user_enable_attribute_mask(self):",
            "        self.config_fixture.config(group='ldap', user_enabled_mask=2,",
            "                                   user_enabled_default='512')",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "",
            "        ldap_ = self.identity_api.driver.user.get_connection()",
            "",
            "        def get_enabled_vals():",
            "            user_dn = self.identity_api.driver.user._id_to_dn_string(u'f\u00e4k\u00e91')",
            "            enabled_attr_name = CONF.ldap.user_enabled_attribute",
            "",
            "            res = ldap_.search_s(user_dn,",
            "                                 ldap.SCOPE_BASE,",
            "                                 u'(sn=f\u00e4k\u00e91)')",
            "            return res[0][1][enabled_attr_name]",
            "",
            "        user = {'id': u'f\u00e4k\u00e91', 'name': u'f\u00e4k\u00e91', 'enabled': True,",
            "                'domain_id': CONF.identity.default_domain_id}",
            "",
            "        user_ref = self.identity_api.create_user(u'f\u00e4k\u00e91', user)",
            "",
            "        # Use assertIs rather than assertTrue because assertIs will assert the",
            "        # value is a Boolean as expected.",
            "        self.assertIs(user_ref['enabled'], True)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "        enabled_vals = get_enabled_vals()",
            "        self.assertEqual([512], enabled_vals)",
            "",
            "        user_ref = self.identity_api.get_user(u'f\u00e4k\u00e91')",
            "        self.assertIs(user_ref['enabled'], True)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "        user['enabled'] = False",
            "        user_ref = self.identity_api.update_user(u'f\u00e4k\u00e91', user)",
            "        self.assertIs(user_ref['enabled'], False)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "        enabled_vals = get_enabled_vals()",
            "        self.assertEqual([514], enabled_vals)",
            "",
            "        user_ref = self.identity_api.get_user(u'f\u00e4k\u00e91')",
            "        self.assertIs(user_ref['enabled'], False)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "        user['enabled'] = True",
            "        user_ref = self.identity_api.update_user(u'f\u00e4k\u00e91', user)",
            "        self.assertIs(user_ref['enabled'], True)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "        enabled_vals = get_enabled_vals()",
            "        self.assertEqual([512], enabled_vals)",
            "",
            "        user_ref = self.identity_api.get_user(u'f\u00e4k\u00e91')",
            "        self.assertIs(user_ref['enabled'], True)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "    @mock.patch.object(common_ldap_core.KeystoneLDAPHandler, 'simple_bind_s')",
            "    def test_user_api_get_connection_no_user_password(self, mocked_method):",
            "        \"\"\"Don't bind in case the user and password are blank.\"\"\"",
            "        # Ensure the username/password are in-fact blank",
            "        self.config_fixture.config(group='ldap', user=None, password=None)",
            "        user_api = identity.backends.ldap.UserApi(CONF)",
            "        user_api.get_connection(user=None, password=None)",
            "        self.assertFalse(mocked_method.called,",
            "                         msg='`simple_bind_s` method was unexpectedly called')",
            "",
            "    @mock.patch.object(common_ldap_core.KeystoneLDAPHandler, 'connect')",
            "    def test_chase_referrals_off(self, mocked_fakeldap):",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            url='fake://memory',",
            "            chase_referrals=False)",
            "        user_api = identity.backends.ldap.UserApi(CONF)",
            "        user_api.get_connection(user=None, password=None)",
            "",
            "        # The last call_arg should be a dictionary and should contain",
            "        # chase_referrals. Check to make sure the value of chase_referrals",
            "        # is as expected.",
            "        self.assertFalse(mocked_fakeldap.call_args[-1]['chase_referrals'])",
            "",
            "    @mock.patch.object(common_ldap_core.KeystoneLDAPHandler, 'connect')",
            "    def test_chase_referrals_on(self, mocked_fakeldap):",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            url='fake://memory',",
            "            chase_referrals=True)",
            "        user_api = identity.backends.ldap.UserApi(CONF)",
            "        user_api.get_connection(user=None, password=None)",
            "",
            "        # The last call_arg should be a dictionary and should contain",
            "        # chase_referrals. Check to make sure the value of chase_referrals",
            "        # is as expected.",
            "        self.assertTrue(mocked_fakeldap.call_args[-1]['chase_referrals'])",
            "",
            "    @mock.patch.object(common_ldap_core.KeystoneLDAPHandler, 'connect')",
            "    def test_debug_level_set(self, mocked_fakeldap):",
            "        level = 12345",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            url='fake://memory',",
            "            debug_level=level)",
            "        user_api = identity.backends.ldap.UserApi(CONF)",
            "        user_api.get_connection(user=None, password=None)",
            "",
            "        # The last call_arg should be a dictionary and should contain",
            "        # debug_level. Check to make sure the value of debug_level",
            "        # is as expected.",
            "        self.assertEqual(level, mocked_fakeldap.call_args[-1]['debug_level'])",
            "",
            "    def test_wrong_ldap_scope(self):",
            "        self.config_fixture.config(group='ldap', query_scope=uuid.uuid4().hex)",
            "        self.assertRaisesRegexp(",
            "            ValueError,",
            "            'Invalid LDAP scope: %s. *' % CONF.ldap.query_scope,",
            "            identity.backends.ldap.Identity)",
            "",
            "    def test_wrong_alias_dereferencing(self):",
            "        self.config_fixture.config(group='ldap',",
            "                                   alias_dereferencing=uuid.uuid4().hex)",
            "        self.assertRaisesRegexp(",
            "            ValueError,",
            "            'Invalid LDAP deref option: %s\\.' % CONF.ldap.alias_dereferencing,",
            "            identity.backends.ldap.Identity)",
            "",
            "    def test_user_extra_attribute_mapping(self):",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            user_additional_attribute_mapping=['description:name'])",
            "        self.load_backends()",
            "        user = {",
            "            'id': 'extra_attributes',",
            "            'name': 'EXTRA_ATTRIBUTES',",
            "            'password': 'extra',",
            "            'domain_id': CONF.identity.default_domain_id",
            "        }",
            "        self.identity_api.create_user(user['id'], user)",
            "        dn, attrs = self.identity_api.driver.user._ldap_get(user['id'])",
            "        self.assertTrue(user['name'] in attrs['description'])",
            "",
            "    def test_user_extra_attribute_mapping_description_is_returned(self):",
            "        # Given a mapping like description:description, the description is",
            "        # returned.",
            "",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            user_additional_attribute_mapping=['description:description'])",
            "        self.load_backends()",
            "",
            "        description = uuid.uuid4().hex",
            "        user = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex,",
            "            'description': description,",
            "            'password': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id",
            "        }",
            "        self.identity_api.create_user(user['id'], user)",
            "        res = self.identity_api.driver.user.get_all()",
            "",
            "        new_user = [u for u in res if u['id'] == user['id']][0]",
            "        self.assertThat(new_user['description'], matchers.Equals(description))",
            "",
            "    @mock.patch.object(common_ldap_core.BaseLdap, '_ldap_get')",
            "    def test_user_mixed_case_attribute(self, mock_ldap_get):",
            "        # Mock the search results to return attribute names",
            "        # with unexpected case.",
            "        mock_ldap_get.return_value = (",
            "            'cn=junk,dc=example,dc=com',",
            "            {",
            "                'sN': [uuid.uuid4().hex],",
            "                'eMaIl': [uuid.uuid4().hex]",
            "            }",
            "        )",
            "        user = self.identity_api.get_user('junk')",
            "        self.assertEqual(mock_ldap_get.return_value[1]['sN'][0],",
            "                         user['name'])",
            "        self.assertEqual(mock_ldap_get.return_value[1]['eMaIl'][0],",
            "                         user['email'])",
            "",
            "    def test_parse_extra_attribute_mapping(self):",
            "        option_list = ['description:name', 'gecos:password',",
            "                       'fake:invalid', 'invalid1', 'invalid2:',",
            "                       'description:name:something']",
            "        mapping = self.identity_api.driver.user._parse_extra_attrs(option_list)",
            "        expected_dict = {'description': 'name', 'gecos': 'password',",
            "                         'fake': 'invalid', 'invalid2': ''}",
            "        self.assertDictEqual(expected_dict, mapping)",
            "",
            "# TODO(henry-nash): These need to be removed when the full LDAP implementation",
            "# is submitted - see Bugs 1092187, 1101287, 1101276, 1101289",
            "",
            "    def test_domain_crud(self):",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'enabled': True, 'description': uuid.uuid4().hex}",
            "        self.assertRaises(exception.Forbidden,",
            "                          self.assignment_api.create_domain,",
            "                          domain['id'],",
            "                          domain)",
            "        self.assertRaises(exception.Conflict,",
            "                          self.assignment_api.create_domain,",
            "                          CONF.identity.default_domain_id,",
            "                          domain)",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.get_domain,",
            "                          domain['id'])",
            "",
            "        domain['description'] = uuid.uuid4().hex",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.update_domain,",
            "                          domain['id'],",
            "                          domain)",
            "        self.assertRaises(exception.Forbidden,",
            "                          self.assignment_api.update_domain,",
            "                          CONF.identity.default_domain_id,",
            "                          domain)",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.get_domain,",
            "                          domain['id'])",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.delete_domain,",
            "                          domain['id'])",
            "        self.assertRaises(exception.Forbidden,",
            "                          self.assignment_api.delete_domain,",
            "                          CONF.identity.default_domain_id)",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.get_domain,",
            "                          domain['id'])",
            "",
            "    def test_create_domain_case_sensitivity(self):",
            "        # domains are read-only, so case sensitivity isn't an issue",
            "        ref = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex}",
            "        self.assertRaises(exception.Forbidden,",
            "                          self.assignment_api.create_domain,",
            "                          ref['id'],",
            "                          ref)",
            "",
            "    def test_cache_layer_domain_crud(self):",
            "        # TODO(morganfainberg): This also needs to be removed when full LDAP",
            "        # implementation is submitted.  No need to duplicate the above test,",
            "        # just skip this time.",
            "        self.skipTest('Domains are read-only against LDAP')",
            "",
            "    def test_project_crud(self):",
            "        # NOTE(topol): LDAP implementation does not currently support the",
            "        #              updating of a project name so this method override",
            "        #              provides a different update test",
            "        project = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                   'domain_id': CONF.identity.default_domain_id,",
            "                   'description': uuid.uuid4().hex, 'enabled': True",
            "                   }",
            "        self.assignment_api.create_project(project['id'], project)",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "",
            "        self.assertDictEqual(project_ref, project)",
            "",
            "        project['description'] = uuid.uuid4().hex",
            "        self.assignment_api.update_project(project['id'], project)",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "        self.assertDictEqual(project_ref, project)",
            "",
            "        self.assignment_api.delete_project(project['id'])",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project['id'])",
            "",
            "    @tests.skip_if_cache_disabled('assignment')",
            "    def test_cache_layer_project_crud(self):",
            "        # NOTE(morganfainberg): LDAP implementation does not currently support",
            "        # updating project names.  This method override provides a different",
            "        # update test.",
            "        project = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                   'domain_id': CONF.identity.default_domain_id,",
            "                   'description': uuid.uuid4().hex}",
            "        project_id = project['id']",
            "        # Create a project",
            "        self.assignment_api.create_project(project_id, project)",
            "        self.assignment_api.get_project(project_id)",
            "        updated_project = copy.deepcopy(project)",
            "        updated_project['description'] = uuid.uuid4().hex",
            "        # Update project, bypassing assignment_api manager",
            "        self.assignment_api.driver.update_project(project_id,",
            "                                                  updated_project)",
            "        # Verify get_project still returns the original project_ref",
            "        self.assertDictContainsSubset(",
            "            project, self.assignment_api.get_project(project_id))",
            "        # Invalidate cache",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   project_id)",
            "        # Verify get_project now returns the new project",
            "        self.assertDictContainsSubset(",
            "            updated_project,",
            "            self.assignment_api.get_project(project_id))",
            "        # Update project using the assignment_api manager back to original",
            "        self.assignment_api.update_project(project['id'], project)",
            "        # Verify get_project returns the original project_ref",
            "        self.assertDictContainsSubset(",
            "            project, self.assignment_api.get_project(project_id))",
            "        # Delete project bypassing assignment_api",
            "        self.assignment_api.driver.delete_project(project_id)",
            "        # Verify get_project still returns the project_ref",
            "        self.assertDictContainsSubset(",
            "            project, self.assignment_api.get_project(project_id))",
            "        # Invalidate cache",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   project_id)",
            "        # Verify ProjectNotFound now raised",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project_id)",
            "        # recreate project",
            "        self.assignment_api.create_project(project_id, project)",
            "        self.assignment_api.get_project(project_id)",
            "        # delete project",
            "        self.assignment_api.delete_project(project_id)",
            "        # Verify ProjectNotFound is raised",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project_id)",
            "",
            "    def test_multi_role_grant_by_user_group_on_project_domain(self):",
            "        # This is a partial implementation of the standard test that",
            "        # is defined in test_backend.py.  It omits both domain and",
            "        # group grants. since neither of these are yet supported by",
            "        # the ldap backend.",
            "",
            "        role_list = []",
            "        for _ in range(2):",
            "            role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "            self.assignment_api.create_role(role['id'], role)",
            "            role_list.append(role)",
            "",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': CONF.identity.default_domain_id,",
            "                 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': CONF.identity.default_domain_id}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            user_id=user1['id'],",
            "            tenant_id=project1['id'],",
            "            role_id=role_list[0]['id'])",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            user_id=user1['id'],",
            "            tenant_id=project1['id'],",
            "            role_id=role_list[1]['id'])",
            "",
            "        # Although list_grants are not yet supported, we can test the",
            "        # alternate way of getting back lists of grants, where user",
            "        # and group roles are combined.  Only directly assigned user",
            "        # roles are available, since group grants are not yet supported",
            "",
            "        combined_list = self.assignment_api.get_roles_for_user_and_project(",
            "            user1['id'],",
            "            project1['id'])",
            "        self.assertEqual(2, len(combined_list))",
            "        self.assertIn(role_list[0]['id'], combined_list)",
            "        self.assertIn(role_list[1]['id'], combined_list)",
            "",
            "        # Finally, although domain roles are not implemented, check we can",
            "        # issue the combined get roles call with benign results, since thus is",
            "        # used in token generation",
            "",
            "        combined_role_list = self.assignment_api.get_roles_for_user_and_domain(",
            "            user1['id'], CONF.identity.default_domain_id)",
            "        self.assertEqual(0, len(combined_role_list))",
            "",
            "    def test_get_roles_for_user_and_project_user_group_same_id(self):",
            "        \"\"\"When a user has the same ID as a group,",
            "        get_roles_for_user_and_project returns the roles for the group.",
            "",
            "        Overriding this test for LDAP because it works differently. The role",
            "        for the group is returned. This is bug 1309228.",
            "        \"\"\"",
            "",
            "        # Setup: create user, group with same ID, role, and project;",
            "        # assign the group the role on the project.",
            "",
            "        user_group_id = uuid.uuid4().hex",
            "",
            "        user1 = {'id': user_group_id, 'name': uuid.uuid4().hex,",
            "                 'domain_id': CONF.identity.default_domain_id, }",
            "        self.identity_api.create_user(user_group_id, user1)",
            "",
            "        group1 = {'id': user_group_id, 'name': uuid.uuid4().hex,",
            "                  'domain_id': CONF.identity.default_domain_id, }",
            "        self.identity_api.create_group(user_group_id, group1)",
            "",
            "        role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role1['id'], role1)",
            "",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': CONF.identity.default_domain_id, }",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        self.assignment_api.create_grant(role1['id'],",
            "                                         group_id=user_group_id,",
            "                                         project_id=project1['id'])",
            "",
            "        # Check the roles, shouldn't be any since the user wasn't granted any.",
            "        roles = self.assignment_api.get_roles_for_user_and_project(",
            "            user_group_id, project1['id'])",
            "",
            "        self.assertEqual([role1['id']], roles,",
            "                         'role for group is %s' % role1['id'])",
            "",
            "    def test_list_projects_for_alternate_domain(self):",
            "        self.skipTest(",
            "            'N/A: LDAP does not support multiple domains')",
            "",
            "    def test_create_grant_no_user(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_create_grant_no_group(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_get_default_domain_by_name(self):",
            "        domain = self._get_domain_fixture()",
            "",
            "        domain_ref = self.assignment_api.get_domain_by_name(domain['name'])",
            "        self.assertEqual(domain_ref, domain)",
            "",
            "    def test_base_ldap_connection_deref_option(self):",
            "        def get_conn(deref_name):",
            "            self.config_fixture.config(group='ldap',",
            "                                       alias_dereferencing=deref_name)",
            "            base_ldap = common_ldap.BaseLdap(CONF)",
            "            return base_ldap.get_connection()",
            "",
            "        conn = get_conn('default')",
            "        self.assertEqual(ldap.get_option(ldap.OPT_DEREF),",
            "                         conn.get_option(ldap.OPT_DEREF))",
            "",
            "        conn = get_conn('always')",
            "        self.assertEqual(ldap.DEREF_ALWAYS,",
            "                         conn.get_option(ldap.OPT_DEREF))",
            "",
            "        conn = get_conn('finding')",
            "        self.assertEqual(ldap.DEREF_FINDING,",
            "                         conn.get_option(ldap.OPT_DEREF))",
            "",
            "        conn = get_conn('never')",
            "        self.assertEqual(ldap.DEREF_NEVER,",
            "                         conn.get_option(ldap.OPT_DEREF))",
            "",
            "        conn = get_conn('searching')",
            "        self.assertEqual(ldap.DEREF_SEARCHING,",
            "                         conn.get_option(ldap.OPT_DEREF))",
            "",
            "    def test_list_users_no_dn(self):",
            "        users = self.identity_api.list_users()",
            "        self.assertEqual(len(default_fixtures.USERS), len(users))",
            "        user_ids = set(user['id'] for user in users)",
            "        expected_user_ids = set(user['id'] for user in default_fixtures.USERS)",
            "        for user_ref in users:",
            "            self.assertNotIn('dn', user_ref)",
            "        self.assertEqual(expected_user_ids, user_ids)",
            "",
            "    def test_list_groups_no_dn(self):",
            "        # Create some test groups.",
            "        domain = self._get_domain_fixture()",
            "        expected_group_ids = []",
            "        numgroups = 3",
            "        for _ in range(numgroups):",
            "            group = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                     'domain_id': domain['id']}",
            "            self.identity_api.create_group(group['id'], group)",
            "            expected_group_ids.append(group['id'])",
            "        # Fetch the test groups and ensure that they don't contain a dn.",
            "        groups = self.identity_api.list_groups()",
            "        self.assertEqual(numgroups, len(groups))",
            "        group_ids = set(group['id'] for group in groups)",
            "        for group_ref in groups:",
            "            self.assertNotIn('dn', group_ref)",
            "        self.assertEqual(set(expected_group_ids), group_ids)",
            "",
            "    def test_list_groups_for_user_no_dn(self):",
            "        # Create a test user.",
            "        user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                'domain_id': CONF.identity.default_domain_id,",
            "                'password': uuid.uuid4().hex,",
            "                'enabled': True}",
            "        self.identity_api.create_user(user['id'], user)",
            "        # Create some test groups and add the test user as a member.",
            "        domain = self._get_domain_fixture()",
            "        expected_group_ids = []",
            "        numgroups = 3",
            "        for _ in range(numgroups):",
            "            group = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                     'domain_id': domain['id']}",
            "            self.identity_api.create_group(group['id'], group)",
            "            expected_group_ids.append(group['id'])",
            "            self.identity_api.add_user_to_group(user['id'], group['id'])",
            "        # Fetch the groups for the test user",
            "        # and ensure they don't contain a dn.",
            "        groups = self.identity_api.list_groups_for_user(user['id'])",
            "        self.assertEqual(numgroups, len(groups))",
            "        group_ids = set(group['id'] for group in groups)",
            "        for group_ref in groups:",
            "            self.assertNotIn('dn', group_ref)",
            "        self.assertEqual(set(expected_group_ids), group_ids)",
            "",
            "",
            "class LDAPIdentityEnabledEmulation(LDAPIdentity):",
            "    def setUp(self):",
            "        super(LDAPIdentityEnabledEmulation, self).setUp()",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        for obj in [self.tenant_bar, self.tenant_baz, self.user_foo,",
            "                    self.user_two, self.user_badguy]:",
            "            obj.setdefault('enabled', True)",
            "",
            "    def config_files(self):",
            "        config_files = super(LDAPIdentityEnabledEmulation, self).config_files()",
            "        config_files.append(tests.dirs.tests_conf('backend_ldap.conf'))",
            "        return config_files",
            "",
            "    def config_overrides(self):",
            "        super(LDAPIdentityEnabledEmulation, self).config_overrides()",
            "        self.config_fixture.config(group='ldap',",
            "                                   user_enabled_emulation=True,",
            "                                   tenant_enabled_emulation=True)",
            "",
            "    def test_project_crud(self):",
            "        # NOTE(topol): LDAPIdentityEnabledEmulation will create an",
            "        #              enabled key in the project dictionary so this",
            "        #              method override handles this side-effect",
            "        project = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'description': uuid.uuid4().hex}",
            "",
            "        self.assignment_api.create_project(project['id'], project)",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "",
            "        # self.assignment_api.create_project adds an enabled",
            "        # key with a value of True when LDAPIdentityEnabledEmulation",
            "        # is used so we now add this expected key to the project dictionary",
            "        project['enabled'] = True",
            "        self.assertDictEqual(project_ref, project)",
            "",
            "        project['description'] = uuid.uuid4().hex",
            "        self.assignment_api.update_project(project['id'], project)",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "        self.assertDictEqual(project_ref, project)",
            "",
            "        self.assignment_api.delete_project(project['id'])",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project['id'])",
            "",
            "    def test_user_crud(self):",
            "        user = {",
            "            'id': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'name': uuid.uuid4().hex,",
            "            'password': uuid.uuid4().hex}",
            "        self.identity_api.create_user(user['id'], user)",
            "        user['enabled'] = True",
            "        user_ref = self.identity_api.get_user(user['id'])",
            "        del user['password']",
            "        user_ref_dict = dict((x, user_ref[x]) for x in user_ref)",
            "        self.assertDictEqual(user_ref_dict, user)",
            "",
            "        user['password'] = uuid.uuid4().hex",
            "        self.identity_api.update_user(user['id'], user)",
            "        user_ref = self.identity_api.get_user(user['id'])",
            "        del user['password']",
            "        user_ref_dict = dict((x, user_ref[x]) for x in user_ref)",
            "        self.assertDictEqual(user_ref_dict, user)",
            "",
            "        self.identity_api.delete_user(user['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          user['id'])",
            "",
            "    def test_user_enable_attribute_mask(self):",
            "        self.skipTest(",
            "            \"Enabled emulation conflicts with enabled mask\")",
            "",
            "",
            "class LdapIdentitySqlAssignment(BaseLDAPIdentity, tests.SQLDriverOverrides,",
            "                                tests.TestCase):",
            "",
            "    def config_files(self):",
            "        config_files = super(LdapIdentitySqlAssignment, self).config_files()",
            "        config_files.append(tests.dirs.tests_conf('backend_ldap_sql.conf'))",
            "        return config_files",
            "",
            "    def setUp(self):",
            "        self.useFixture(database.Database())",
            "        super(LdapIdentitySqlAssignment, self).setUp()",
            "        self.clear_database()",
            "        self.load_backends()",
            "        cache.configure_cache_region(cache.REGION)",
            "        self.engine = sql.get_engine()",
            "        self.addCleanup(sql.cleanup)",
            "",
            "        sql.ModelBase.metadata.create_all(bind=self.engine)",
            "        self.addCleanup(sql.ModelBase.metadata.drop_all, bind=self.engine)",
            "",
            "        self.load_fixtures(default_fixtures)",
            "        # defaulted by the data load",
            "        self.user_foo['enabled'] = True",
            "",
            "    def config_overrides(self):",
            "        super(LdapIdentitySqlAssignment, self).config_overrides()",
            "        self.config_fixture.config(",
            "            group='identity',",
            "            driver='keystone.identity.backends.ldap.Identity')",
            "        self.config_fixture.config(",
            "            group='assignment',",
            "            driver='keystone.assignment.backends.sql.Assignment')",
            "",
            "    def test_domain_crud(self):",
            "        pass",
            "",
            "    def test_list_domains(self):",
            "        domains = self.assignment_api.list_domains()",
            "        self.assertEqual([assignment.calc_default_domain()], domains)",
            "",
            "    def test_list_domains_non_default_domain_id(self):",
            "        # If change the default_domain_id, the ID of the default domain",
            "        # returned by list_domains doesn't change because the SQL identity",
            "        # backend reads it from the database, which doesn't get updated by",
            "        # config change.",
            "",
            "        orig_default_domain_id = CONF.identity.default_domain_id",
            "",
            "        new_domain_id = uuid.uuid4().hex",
            "        self.config_fixture.config(group='identity',",
            "                                   default_domain_id=new_domain_id)",
            "",
            "        domains = self.assignment_api.list_domains()",
            "",
            "        self.assertEqual(orig_default_domain_id, domains[0]['id'])",
            "",
            "    def test_project_filter(self):",
            "        self.skipTest(",
            "            'N/A: Not part of SQL backend')",
            "",
            "    def test_role_filter(self):",
            "        self.skipTest(",
            "            'N/A: Not part of SQL backend')",
            "",
            "    def test_add_role_grant_to_user_and_project_404(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_get_role_grants_for_user_and_project_404(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_list_projects_for_user_with_grants(self):",
            "        self.skipTest('Blocked by bug 1221805')",
            "",
            "",
            "class MultiLDAPandSQLIdentity(BaseLDAPIdentity, tests.SQLDriverOverrides,",
            "                              tests.TestCase):",
            "    \"\"\"Class to test common SQL plus individual LDAP backends.",
            "",
            "    We define a set of domains and domain-specific backends:",
            "",
            "    - A separate LDAP backend for the default domain",
            "    - A separate LDAP backend for domain1",
            "    - domain2 shares the same LDAP as domain1, but uses a different",
            "      tree attach point",
            "    - An SQL backend for all other domains (which will include domain3",
            "      and domain4)",
            "",
            "    Normally one would expect that the default domain would be handled as",
            "    part of the \"other domains\" - however the above provides better",
            "    test coverage since most of the existing backend tests use the default",
            "    domain.",
            "",
            "    \"\"\"",
            "    def setUp(self):",
            "        self.useFixture(database.Database())",
            "        super(MultiLDAPandSQLIdentity, self).setUp()",
            "",
            "        self.load_backends()",
            "",
            "        self.engine = sql.get_engine()",
            "        self.addCleanup(sql.cleanup)",
            "",
            "        sql.ModelBase.metadata.create_all(bind=self.engine)",
            "        self.addCleanup(sql.ModelBase.metadata.drop_all, bind=self.engine)",
            "",
            "        self._setup_domain_test_data()",
            "",
            "        # All initial domain data setup complete, time to switch on support",
            "        # for separate backends per domain.",
            "",
            "        self.config_fixture.config(group='identity',",
            "                                   domain_specific_drivers_enabled=True,",
            "                                   domain_config_dir=tests.TESTSDIR)",
            "",
            "        self._set_domain_configs()",
            "        self.clear_database()",
            "        self.load_fixtures(default_fixtures)",
            "",
            "    def config_overrides(self):",
            "        super(MultiLDAPandSQLIdentity, self).config_overrides()",
            "        # Make sure identity and assignment are actually SQL drivers,",
            "        # BaseLDAPIdentity sets these options to use LDAP.",
            "        self.config_fixture.config(",
            "            group='identity',",
            "            driver='keystone.identity.backends.sql.Identity')",
            "        self.config_fixture.config(",
            "            group='assignment',",
            "            driver='keystone.assignment.backends.sql.Assignment')",
            "",
            "    def _setup_domain_test_data(self):",
            "",
            "        def create_domain(domain):",
            "            try:",
            "                ref = self.assignment_api.create_domain(",
            "                    domain['id'], domain)",
            "            except exception.Conflict:",
            "                ref = (",
            "                    self.assignment_api.get_domain_by_name(domain['name']))",
            "            return ref",
            "",
            "        self.domain_default = create_domain(assignment.calc_default_domain())",
            "        self.domain1 = create_domain(",
            "            {'id': uuid.uuid4().hex, 'name': 'domain1'})",
            "        self.domain2 = create_domain(",
            "            {'id': uuid.uuid4().hex, 'name': 'domain2'})",
            "        self.domain3 = create_domain(",
            "            {'id': uuid.uuid4().hex, 'name': 'domain3'})",
            "        self.domain4 = create_domain(",
            "            {'id': uuid.uuid4().hex, 'name': 'domain4'})",
            "",
            "    def _set_domain_configs(self):",
            "        # We need to load the domain configs explicitly to ensure the",
            "        # test overrides are included.",
            "        self.identity_api.domain_configs._load_config(",
            "            self.identity_api.assignment_api,",
            "            [tests.dirs.tests_conf('keystone.Default.conf')],",
            "            'Default')",
            "        self.identity_api.domain_configs._load_config(",
            "            self.identity_api.assignment_api,",
            "            [tests.dirs.tests_conf('keystone.domain1.conf')],",
            "            'domain1')",
            "        self.identity_api.domain_configs._load_config(",
            "            self.identity_api.assignment_api,",
            "            [tests.dirs.tests_conf('keystone.domain2.conf')],",
            "            'domain2')",
            "",
            "    def reload_backends(self, domain_id):",
            "        # Just reload the driver for this domain - which will pickup",
            "        # any updated cfg",
            "        self.identity_api.domain_configs.reload_domain_driver(",
            "            self.identity_api.assignment_api, domain_id)",
            "",
            "    def get_config(self, domain_id):",
            "        # Get the config for this domain, will return CONF",
            "        # if no specific config defined for this domain",
            "        return self.identity_api.domain_configs.get_domain_conf(domain_id)",
            "",
            "    def test_list_domains(self):",
            "        self.skipTest(",
            "            'N/A: Not relevant for multi ldap testing')",
            "",
            "    def test_list_domains_non_default_domain_id(self):",
            "        self.skipTest(",
            "            'N/A: Not relevant for multi ldap testing')",
            "",
            "    def test_domain_segregation(self):",
            "        \"\"\"Test that separate configs have segregated the domain.",
            "",
            "        Test Plan:",
            "",
            "        - Create a user in each of the domains",
            "        - Make sure that you can only find a given user in its",
            "          relevant domain",
            "        - Make sure that for a backend that supports multiple domains",
            "          you can get the users via any of the domain scopes",
            "",
            "        \"\"\"",
            "        def create_user(domain_id):",
            "            user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain_id,",
            "                    'password': uuid.uuid4().hex,",
            "                    'enabled': True}",
            "            self.identity_api.create_user(user['id'], user)",
            "            return user",
            "",
            "        userd = create_user(CONF.identity.default_domain_id)",
            "        user1 = create_user(self.domain1['id'])",
            "        user2 = create_user(self.domain2['id'])",
            "        user3 = create_user(self.domain3['id'])",
            "        user4 = create_user(self.domain4['id'])",
            "",
            "        # Now check that I can read user1 with the appropriate domain",
            "        # scope, but won't find it if the wrong scope is used",
            "",
            "        ref = self.identity_api.get_user(",
            "            userd['id'], domain_scope=CONF.identity.default_domain_id)",
            "        del userd['password']",
            "        self.assertDictEqual(ref, userd)",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          userd['id'],",
            "                          domain_scope=self.domain1['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          userd['id'],",
            "                          domain_scope=self.domain2['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          userd['id'],",
            "                          domain_scope=self.domain3['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          userd['id'],",
            "                          domain_scope=self.domain4['id'])",
            "",
            "        ref = self.identity_api.get_user(",
            "            user1['id'], domain_scope=self.domain1['id'])",
            "        del user1['password']",
            "        self.assertDictEqual(ref, user1)",
            "        ref = self.identity_api.get_user(",
            "            user2['id'], domain_scope=self.domain2['id'])",
            "        del user2['password']",
            "        self.assertDictEqual(ref, user2)",
            "",
            "        # Domains 3 and 4 share the same backend, so you should be",
            "        # able to see user3 and 4 from either",
            "",
            "        ref = self.identity_api.get_user(",
            "            user3['id'], domain_scope=self.domain3['id'])",
            "        del user3['password']",
            "        self.assertDictEqual(ref, user3)",
            "        ref = self.identity_api.get_user(",
            "            user4['id'], domain_scope=self.domain4['id'])",
            "        del user4['password']",
            "        self.assertDictEqual(ref, user4)",
            "        ref = self.identity_api.get_user(",
            "            user3['id'], domain_scope=self.domain4['id'])",
            "        self.assertDictEqual(ref, user3)",
            "        ref = self.identity_api.get_user(",
            "            user4['id'], domain_scope=self.domain3['id'])",
            "        self.assertDictEqual(ref, user4)",
            "",
            "    def test_scanning_of_config_dir(self):",
            "        \"\"\"Test the Manager class scans the config directory.",
            "",
            "        The setup for the main tests above load the domain configs directly",
            "        so that the test overrides can be included. This test just makes sure",
            "        that the standard config directory scanning does pick up the relevant",
            "        domain config files.",
            "",
            "        \"\"\"",
            "        # Confirm that config has drivers_enabled as True, which we will",
            "        # check has been set to False later in this test",
            "        self.assertTrue(config.CONF.identity.domain_specific_drivers_enabled)",
            "        self.load_backends()",
            "        # Execute any command to trigger the lazy loading of domain configs",
            "        self.identity_api.list_users(domain_scope=self.domain1['id'])",
            "        # ...and now check the domain configs have been set up",
            "        self.assertIn('default', self.identity_api.domain_configs)",
            "        self.assertIn(self.domain1['id'], self.identity_api.domain_configs)",
            "        self.assertIn(self.domain2['id'], self.identity_api.domain_configs)",
            "        self.assertNotIn(self.domain3['id'], self.identity_api.domain_configs)",
            "        self.assertNotIn(self.domain4['id'], self.identity_api.domain_configs)",
            "",
            "        # Finally check that a domain specific config contains items from both",
            "        # the primary config and the domain specific config",
            "        conf = self.identity_api.domain_configs.get_domain_conf(",
            "            self.domain1['id'])",
            "        # This should now be false, as is the default, since this is not",
            "        # set in the standard primary config file",
            "        self.assertFalse(conf.identity.domain_specific_drivers_enabled)",
            "        # ..and make sure a domain-specific options is also set",
            "        self.assertEqual('fake://memory1', conf.ldap.url)",
            "",
            "    def test_add_role_grant_to_user_and_project_404(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_get_role_grants_for_user_and_project_404(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_list_projects_for_user_with_grants(self):",
            "        self.skipTest('Blocked by bug 1221805')"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "# Copyright 2012 OpenStack Foundation",
            "# Copyright 2013 IBM Corp.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import copy",
            "import uuid",
            "",
            "import ldap",
            "import mock",
            "from testtools import matchers",
            "",
            "from keystone import assignment",
            "from keystone.common import cache",
            "from keystone.common import ldap as common_ldap",
            "from keystone.common.ldap import core as common_ldap_core",
            "from keystone.common import sql",
            "from keystone import config",
            "from keystone import exception",
            "from keystone import identity",
            "from keystone import tests",
            "from keystone.tests import default_fixtures",
            "from keystone.tests import fakeldap",
            "from keystone.tests.ksfixtures import database",
            "from keystone.tests import test_backend",
            "",
            "",
            "CONF = config.CONF",
            "",
            "",
            "class BaseLDAPIdentity(test_backend.IdentityTests):",
            "",
            "    def setUp(self):",
            "        super(BaseLDAPIdentity, self).setUp()",
            "        self.clear_database()",
            "",
            "        common_ldap.register_handler('fake://', fakeldap.FakeLdap)",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "",
            "        self.addCleanup(common_ldap_core._HANDLERS.clear)",
            "",
            "    def _get_domain_fixture(self):",
            "        \"\"\"Domains in LDAP are read-only, so just return the static one.\"\"\"",
            "        return self.assignment_api.get_domain(CONF.identity.default_domain_id)",
            "",
            "    def clear_database(self):",
            "        for shelf in fakeldap.FakeShelves:",
            "            fakeldap.FakeShelves[shelf].clear()",
            "",
            "    def reload_backends(self, domain_id):",
            "        # Only one backend unless we are using separate domain backends",
            "        self.load_backends()",
            "",
            "    def get_config(self, domain_id):",
            "        # Only one conf structure unless we are using separate domain backends",
            "        return CONF",
            "",
            "    def config_overrides(self):",
            "        super(BaseLDAPIdentity, self).config_overrides()",
            "        self.config_fixture.config(",
            "            group='identity',",
            "            driver='keystone.identity.backends.ldap.Identity')",
            "",
            "    def config_files(self):",
            "        config_files = super(BaseLDAPIdentity, self).config_files()",
            "        config_files.append(tests.dirs.tests_conf('backend_ldap.conf'))",
            "        return config_files",
            "",
            "    def test_build_tree(self):",
            "        \"\"\"Regression test for building the tree names",
            "        \"\"\"",
            "        user_api = identity.backends.ldap.UserApi(CONF)",
            "        self.assertTrue(user_api)",
            "        self.assertEqual(\"ou=Users,%s\" % CONF.ldap.suffix, user_api.tree_dn)",
            "",
            "    def test_configurable_allowed_user_actions(self):",
            "        user = {'id': u'f\u00e4k\u00e91',",
            "                'name': u'f\u00e4k\u00e91',",
            "                'password': u'f\u00e4k\u00e9pass1',",
            "                'domain_id': CONF.identity.default_domain_id,",
            "                'tenants': ['bar']}",
            "        self.identity_api.create_user(u'f\u00e4k\u00e91', user)",
            "        user_ref = self.identity_api.get_user(u'f\u00e4k\u00e91')",
            "        self.assertEqual(u'f\u00e4k\u00e91', user_ref['id'])",
            "",
            "        user['password'] = u'f\u00e4k\u00e9pass2'",
            "        self.identity_api.update_user(u'f\u00e4k\u00e91', user)",
            "",
            "        self.identity_api.delete_user(u'f\u00e4k\u00e91')",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          u'f\u00e4k\u00e91')",
            "",
            "    def test_configurable_forbidden_user_actions(self):",
            "        conf = self.get_config(CONF.identity.default_domain_id)",
            "        conf.ldap.user_allow_create = False",
            "        conf.ldap.user_allow_update = False",
            "        conf.ldap.user_allow_delete = False",
            "        self.reload_backends(CONF.identity.default_domain_id)",
            "",
            "        user = {'id': u'f\u00e4k\u00e91',",
            "                'name': u'f\u00e4k\u00e91',",
            "                'password': u'f\u00e4k\u00e9pass1',",
            "                'domain_id': CONF.identity.default_domain_id,",
            "                'tenants': ['bar']}",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.identity_api.create_user,",
            "                          u'f\u00e4k\u00e91',",
            "                          user)",
            "",
            "        self.user_foo['password'] = u'f\u00e4k\u00e9pass2'",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.identity_api.update_user,",
            "                          self.user_foo['id'],",
            "                          self.user_foo)",
            "",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.identity_api.delete_user,",
            "                          self.user_foo['id'])",
            "",
            "    def test_configurable_forbidden_create_existing_user(self):",
            "        conf = self.get_config(CONF.identity.default_domain_id)",
            "        conf.ldap.user_allow_create = False",
            "        self.reload_backends(CONF.identity.default_domain_id)",
            "",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.identity_api.create_user,",
            "                          self.user_foo['id'],",
            "                          self.user_foo)",
            "",
            "    def test_user_filter(self):",
            "        user_ref = self.identity_api.get_user(self.user_foo['id'])",
            "        self.user_foo.pop('password')",
            "        self.assertDictEqual(user_ref, self.user_foo)",
            "",
            "        conf = self.get_config(user_ref['domain_id'])",
            "        conf.ldap.user_filter = '(CN=DOES_NOT_MATCH)'",
            "        self.reload_backends(user_ref['domain_id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          self.user_foo['id'])",
            "",
            "    def test_remove_role_grant_from_user_and_project(self):",
            "        self.assignment_api.create_grant(user_id=self.user_foo['id'],",
            "                                         project_id=self.tenant_baz['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=self.user_foo['id'],",
            "            project_id=self.tenant_baz['id'])",
            "        self.assertDictEqual(roles_ref[0], self.role_member)",
            "",
            "        self.assignment_api.delete_grant(user_id=self.user_foo['id'],",
            "                                         project_id=self.tenant_baz['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            user_id=self.user_foo['id'],",
            "            project_id=self.tenant_baz['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.delete_grant,",
            "                          user_id=self.user_foo['id'],",
            "                          project_id=self.tenant_baz['id'],",
            "                          role_id='member')",
            "",
            "    def test_get_and_remove_role_grant_by_group_and_project(self):",
            "        new_domain = self._get_domain_fixture()",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': new_domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'enabled': True,",
            "                    'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            new_group['id'])",
            "",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            project_id=self.tenant_bar['id'])",
            "        self.assertEqual([], roles_ref)",
            "        self.assertEqual(0, len(roles_ref))",
            "",
            "        self.assignment_api.create_grant(group_id=new_group['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            project_id=self.tenant_bar['id'])",
            "        self.assertNotEmpty(roles_ref)",
            "        self.assertDictEqual(roles_ref[0], self.role_member)",
            "",
            "        self.assignment_api.delete_grant(group_id=new_group['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id='member')",
            "        roles_ref = self.assignment_api.list_grants(",
            "            group_id=new_group['id'],",
            "            project_id=self.tenant_bar['id'])",
            "        self.assertEqual(0, len(roles_ref))",
            "        self.assertRaises(exception.NotFound,",
            "                          self.assignment_api.delete_grant,",
            "                          group_id=new_group['id'],",
            "                          project_id=self.tenant_bar['id'],",
            "                          role_id='member')",
            "",
            "    def test_delete_user_grant_no_user(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_delete_group_grant_no_group(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_get_and_remove_role_grant_by_group_and_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_get_and_remove_role_grant_by_user_and_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_get_and_remove_correct_role_grant_from_a_mix(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_get_and_remove_role_grant_by_group_and_cross_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_get_and_remove_role_grant_by_user_and_cross_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_role_grant_by_group_and_cross_domain_project(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_role_grant_by_user_and_cross_domain_project(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_multi_role_grant_by_user_group_on_project_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_delete_role_with_user_and_group_grants(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_delete_user_with_group_project_domain_links(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_delete_group_with_user_project_domain_links(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_list_projects_for_user(self):",
            "        domain = self._get_domain_fixture()",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'password': uuid.uuid4().hex, 'domain_id': domain['id'],",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        user_projects = self.assignment_api.list_projects_for_user(user1['id'])",
            "        self.assertEqual(0, len(user_projects))",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id=self.role_member['id'])",
            "        self.assignment_api.create_grant(user_id=user1['id'],",
            "                                         project_id=self.tenant_baz['id'],",
            "                                         role_id=self.role_member['id'])",
            "        user_projects = self.assignment_api.list_projects_for_user(user1['id'])",
            "        self.assertEqual(2, len(user_projects))",
            "",
            "    def test_list_projects_for_user_with_grants(self):",
            "        domain = self._get_domain_fixture()",
            "        new_user = {'id': uuid.uuid4().hex, 'name': 'new_user',",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': domain['id']}",
            "        self.identity_api.create_user(new_user['id'], new_user)",
            "",
            "        group1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain['id']}",
            "        self.identity_api.create_group(group1['id'], group1)",
            "        group2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'domain_id': domain['id']}",
            "        self.identity_api.create_group(group2['id'], group2)",
            "",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain['id']}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "        project2 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain['id']}",
            "        self.assignment_api.create_project(project2['id'], project2)",
            "",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            group1['id'])",
            "        self.identity_api.add_user_to_group(new_user['id'],",
            "                                            group2['id'])",
            "",
            "        self.assignment_api.create_grant(user_id=new_user['id'],",
            "                                         project_id=self.tenant_bar['id'],",
            "                                         role_id=self.role_member['id'])",
            "        self.assignment_api.create_grant(user_id=new_user['id'],",
            "                                         project_id=project1['id'],",
            "                                         role_id=self.role_admin['id'])",
            "        self.assignment_api.create_grant(group_id=group2['id'],",
            "                                         project_id=project2['id'],",
            "                                         role_id=self.role_admin['id'])",
            "",
            "        user_projects = self.assignment_api.list_projects_for_user(",
            "            new_user['id'])",
            "        self.assertEqual(2, len(user_projects))",
            "",
            "    def test_create_duplicate_user_name_in_different_domains(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_create_duplicate_project_name_in_different_domains(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_create_duplicate_group_name_in_different_domains(self):",
            "        self.skipTest(",
            "            'N/A: LDAP does not support multiple domains')",
            "",
            "    def test_move_user_between_domains(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_move_user_between_domains_with_clashing_names_fails(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_move_group_between_domains(self):",
            "        self.skipTest(",
            "            'N/A: LDAP does not support multiple domains')",
            "",
            "    def test_move_group_between_domains_with_clashing_names_fails(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_move_project_between_domains(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_move_project_between_domains_with_clashing_names_fails(self):",
            "        self.skipTest('Blocked by bug 1101276')",
            "",
            "    def test_get_roles_for_user_and_domain(self):",
            "        self.skipTest('N/A: LDAP does not support multiple domains')",
            "",
            "    def test_list_role_assignments_unfiltered(self):",
            "        new_domain = self._get_domain_fixture()",
            "        new_user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user['id'],",
            "                                      new_user)",
            "        new_group = {'id': uuid.uuid4().hex, 'domain_id': new_domain['id'],",
            "                     'name': uuid.uuid4().hex}",
            "        self.identity_api.create_group(new_group['id'], new_group)",
            "        new_project = {'id': uuid.uuid4().hex,",
            "                       'name': uuid.uuid4().hex,",
            "                       'domain_id': new_domain['id']}",
            "        self.assignment_api.create_project(new_project['id'], new_project)",
            "",
            "        # First check how many role grant already exist",
            "        existing_assignments = len(self.assignment_api.list_role_assignments())",
            "",
            "        self.assignment_api.create_grant(user_id=new_user['id'],",
            "                                         project_id=new_project['id'],",
            "                                         role_id='other')",
            "        self.assignment_api.create_grant(group_id=new_group['id'],",
            "                                         project_id=new_project['id'],",
            "                                         role_id='admin')",
            "",
            "        # Read back the list of assignments - check it is gone up by 2",
            "        after_assignments = len(self.assignment_api.list_role_assignments())",
            "        self.assertEqual(existing_assignments + 2, after_assignments)",
            "",
            "    def test_list_role_assignments_dumb_member(self):",
            "        self.config_fixture.config(group='ldap', use_dumb_member=True)",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "",
            "        new_domain = self._get_domain_fixture()",
            "        new_user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'password': uuid.uuid4().hex, 'enabled': True,",
            "                    'domain_id': new_domain['id']}",
            "        self.identity_api.create_user(new_user['id'],",
            "                                      new_user)",
            "        new_project = {'id': uuid.uuid4().hex,",
            "                       'name': uuid.uuid4().hex,",
            "                       'domain_id': new_domain['id']}",
            "        self.assignment_api.create_project(new_project['id'], new_project)",
            "        self.assignment_api.create_grant(user_id=new_user['id'],",
            "                                         project_id=new_project['id'],",
            "                                         role_id='other')",
            "",
            "        # Read back the list of assignments and ensure",
            "        # that the LDAP dumb member isn't listed.",
            "        assignment_ids = [a['user_id'] for a in",
            "                          self.assignment_api.list_role_assignments()]",
            "        dumb_id = common_ldap.BaseLdap._dn_to_id(CONF.ldap.dumb_member)",
            "        self.assertNotIn(dumb_id, assignment_ids)",
            "",
            "    def test_list_role_assignments_bad_role(self):",
            "        self.skipTest('Blocked by bug 1221805')",
            "",
            "    def test_multi_group_grants_on_project_domain(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_list_group_members_missing_entry(self):",
            "        \"\"\"List group members with deleted user.",
            "",
            "        If a group has a deleted entry for a member, the non-deleted members",
            "        are returned.",
            "",
            "        \"\"\"",
            "",
            "        # Create a group",
            "        group_id = None",
            "        group = dict(name=uuid.uuid4().hex,",
            "                     domain_id=CONF.identity.default_domain_id)",
            "        group_id = self.identity_api.create_group(group_id, group)['id']",
            "",
            "        # Create a couple of users and add them to the group.",
            "        user_id = None",
            "        user = dict(name=uuid.uuid4().hex, id=uuid.uuid4().hex,",
            "                    domain_id=CONF.identity.default_domain_id)",
            "        user_1_id = self.identity_api.create_user(user_id, user)['id']",
            "",
            "        self.identity_api.add_user_to_group(user_1_id, group_id)",
            "",
            "        user_id = None",
            "        user = dict(name=uuid.uuid4().hex, id=uuid.uuid4().hex,",
            "                    domain_id=CONF.identity.default_domain_id)",
            "        user_2_id = self.identity_api.create_user(user_id, user)['id']",
            "",
            "        self.identity_api.add_user_to_group(user_2_id, group_id)",
            "",
            "        # Delete user 2",
            "        # NOTE(blk-u): need to go directly to user interface to keep from",
            "        # updating the group.",
            "        driver = self.identity_api._select_identity_driver(",
            "            user['domain_id'])",
            "        driver.user.delete(user_2_id)",
            "",
            "        # List group users and verify only user 1.",
            "        res = self.identity_api.list_users_in_group(group_id)",
            "",
            "        self.assertEqual(1, len(res), \"Expected 1 entry (user_1)\")",
            "        self.assertEqual(user_1_id, res[0]['id'], \"Expected user 1 id\")",
            "",
            "    def test_list_group_members_when_no_members(self):",
            "        # List group members when there is no member in the group.",
            "        # No exception should be raised.",
            "        group = {",
            "            'id': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'name': uuid.uuid4().hex,",
            "            'description': uuid.uuid4().hex}",
            "        self.identity_api.create_group(group['id'], group)",
            "",
            "        # If this doesn't raise, then the test is successful.",
            "        self.identity_api.list_users_in_group(group['id'])",
            "",
            "    def test_list_domains(self):",
            "        domains = self.assignment_api.list_domains()",
            "        self.assertEqual(",
            "            [assignment.calc_default_domain()],",
            "            domains)",
            "",
            "    def test_list_domains_non_default_domain_id(self):",
            "        # If change the default_domain_id, the ID of the default domain",
            "        # returned by list_domains changes is the new default_domain_id.",
            "",
            "        new_domain_id = uuid.uuid4().hex",
            "        self.config_fixture.config(group='identity',",
            "                                   default_domain_id=new_domain_id)",
            "",
            "        domains = self.assignment_api.list_domains()",
            "",
            "        self.assertEqual(new_domain_id, domains[0]['id'])",
            "",
            "    def test_authenticate_requires_simple_bind(self):",
            "        user = {",
            "            'id': 'no_meta',",
            "            'name': 'NO_META',",
            "            'domain_id': test_backend.DEFAULT_DOMAIN_ID,",
            "            'password': 'no_meta2',",
            "            'enabled': True,",
            "        }",
            "        self.identity_api.create_user(user['id'], user)",
            "        self.assignment_api.add_user_to_project(self.tenant_baz['id'],",
            "                                                user['id'])",
            "        driver = self.identity_api._select_identity_driver(",
            "            user['domain_id'])",
            "        driver.user.LDAP_USER = None",
            "        driver.user.LDAP_PASSWORD = None",
            "",
            "        self.assertRaises(AssertionError,",
            "                          self.identity_api.authenticate,",
            "                          context={},",
            "                          user_id=user['id'],",
            "                          password=None,",
            "                          domain_scope=user['domain_id'])",
            "",
            "    # (spzala)The group and domain crud tests below override the standard ones",
            "    # in test_backend.py so that we can exclude the update name test, since we",
            "    # do not yet support the update of either group or domain names with LDAP.",
            "    # In the tests below, the update is demonstrated by updating description.",
            "    # Refer to bug 1136403 for more detail.",
            "    def test_group_crud(self):",
            "        group = {",
            "            'id': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'name': uuid.uuid4().hex,",
            "            'description': uuid.uuid4().hex}",
            "        self.identity_api.create_group(group['id'], group)",
            "        group_ref = self.identity_api.get_group(group['id'])",
            "        self.assertDictEqual(group_ref, group)",
            "        group['description'] = uuid.uuid4().hex",
            "        self.identity_api.update_group(group['id'], group)",
            "        group_ref = self.identity_api.get_group(group['id'])",
            "        self.assertDictEqual(group_ref, group)",
            "",
            "        self.identity_api.delete_group(group['id'])",
            "        self.assertRaises(exception.GroupNotFound,",
            "                          self.identity_api.get_group,",
            "                          group['id'])",
            "",
            "    def test_create_user_none_mapping(self):",
            "        # When create a user where an attribute maps to None, the entry is",
            "        # created without that attribute and it doesn't fail with a TypeError.",
            "        conf = self.get_config(CONF.identity.default_domain_id)",
            "        conf.ldap.user_attribute_ignore = ['enabled', 'email',",
            "                                           'tenants', 'tenantId']",
            "        self.reload_backends(CONF.identity.default_domain_id)",
            "",
            "        user = {'id': u'f\u00e4k\u00e91',",
            "                'name': u'f\u00e4k\u00e91',",
            "                'password': u'f\u00e4k\u00e9pass1',",
            "                'domain_id': CONF.identity.default_domain_id,",
            "                'default_project_id': 'maps_to_none',",
            "                }",
            "",
            "        # If this doesn't raise, then the test is successful.",
            "        self.identity_api.create_user(u'f\u00e4k\u00e91', user)",
            "",
            "    def test_update_user_name(self):",
            "        \"\"\"A user's name cannot be changed through the LDAP driver.\"\"\"",
            "        self.assertRaises(exception.Conflict,",
            "                          super(BaseLDAPIdentity, self).test_update_user_name)",
            "",
            "    def test_attribute_update(self):",
            "        self.skipTest(\"Blank value in a required field is an error in LDAP\")",
            "",
            "    def test_arbitrary_attributes_are_returned_from_create_user(self):",
            "        self.skipTest(\"Using arbitrary attributes doesn't work under LDAP\")",
            "",
            "    def test_arbitrary_attributes_are_returned_from_get_user(self):",
            "        self.skipTest(\"Using arbitrary attributes doesn't work under LDAP\")",
            "",
            "    def test_new_arbitrary_attributes_are_returned_from_update_user(self):",
            "        self.skipTest(\"Using arbitrary attributes doesn't work under LDAP\")",
            "",
            "    def test_updated_arbitrary_attributes_are_returned_from_update_user(self):",
            "        self.skipTest(\"Using arbitrary attributes doesn't work under LDAP\")",
            "",
            "    def test_user_id_comma(self):",
            "        \"\"\"Even if the user has a , in their ID, groups can be listed.\"\"\"",
            "",
            "        # Create a user with a , in their ID",
            "        # NOTE(blk-u): the DN for this user is hard-coded in fakeldap!",
            "        user_id = u'Doe, John'",
            "        user = {",
            "            'id': user_id,",
            "            'name': self.getUniqueString(),",
            "            'password': self.getUniqueString(),",
            "            'domain_id': CONF.identity.default_domain_id,",
            "        }",
            "        self.identity_api.create_user(user_id, user)",
            "",
            "        # Create a group",
            "        group_id = uuid.uuid4().hex",
            "        group = {",
            "            'id': group_id,",
            "            'name': self.getUniqueString(prefix='tuidc'),",
            "            'description': self.getUniqueString(),",
            "            'domain_id': CONF.identity.default_domain_id,",
            "        }",
            "        self.identity_api.create_group(group_id, group)",
            "",
            "        # Put the user in the group",
            "        self.identity_api.add_user_to_group(user_id, group_id)",
            "",
            "        # List groups for user.",
            "        ref_list = self.identity_api.list_groups_for_user(user_id)",
            "",
            "        self.assertThat(ref_list, matchers.Equals([group]))",
            "",
            "    def test_user_id_comma_grants(self):",
            "        \"\"\"Even if the user has a , in their ID, can get user and group grants.",
            "        \"\"\"",
            "",
            "        # Create a user with a , in their ID",
            "        # NOTE(blk-u): the DN for this user is hard-coded in fakeldap!",
            "        user_id = u'Doe, John'",
            "        user = {",
            "            'id': user_id,",
            "            'name': self.getUniqueString(),",
            "            'password': self.getUniqueString(),",
            "            'domain_id': CONF.identity.default_domain_id,",
            "        }",
            "        self.identity_api.create_user(user_id, user)",
            "",
            "        # Grant the user a role on a project.",
            "",
            "        role_id = 'member'",
            "        project_id = self.tenant_baz['id']",
            "",
            "        self.assignment_api.create_grant(role_id, user_id=user_id,",
            "                                         project_id=project_id)",
            "",
            "        role_ref = self.assignment_api.get_grant(role_id, user_id=user_id,",
            "                                                 project_id=project_id)",
            "",
            "        self.assertEqual(role_id, role_ref['id'])",
            "",
            "",
            "class LDAPIdentity(BaseLDAPIdentity, tests.TestCase):",
            "",
            "    def setUp(self):",
            "        # NOTE(dstanek): The database must be setup prior to calling the",
            "        # parent's setUp. The parent's setUp uses services (like",
            "        # credentials) that require a database.",
            "        self.useFixture(database.Database())",
            "        super(LDAPIdentity, self).setUp()",
            "",
            "    def test_configurable_allowed_project_actions(self):",
            "        tenant = {'id': u'f\u00e4k\u00e91', 'name': u'f\u00e4k\u00e91', 'enabled': True}",
            "        self.assignment_api.create_project(u'f\u00e4k\u00e91', tenant)",
            "        tenant_ref = self.assignment_api.get_project(u'f\u00e4k\u00e91')",
            "        self.assertEqual(u'f\u00e4k\u00e91', tenant_ref['id'])",
            "",
            "        tenant['enabled'] = False",
            "        self.assignment_api.update_project(u'f\u00e4k\u00e91', tenant)",
            "",
            "        self.assignment_api.delete_project(u'f\u00e4k\u00e91')",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          u'f\u00e4k\u00e91')",
            "",
            "    def test_configurable_subtree_delete(self):",
            "        self.config_fixture.config(group='ldap', allow_subtree_delete=True)",
            "        self.load_backends()",
            "",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': CONF.identity.default_domain_id}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assignment_api.create_role(role1['id'], role1)",
            "",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': CONF.identity.default_domain_id,",
            "                 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            user_id=user1['id'],",
            "            tenant_id=project1['id'],",
            "            role_id=role1['id'])",
            "",
            "        self.assignment_api.delete_project(project1['id'])",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project1['id'])",
            "",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        list = self.assignment_api.get_roles_for_user_and_project(",
            "            user1['id'],",
            "            project1['id'])",
            "        self.assertEqual(0, len(list))",
            "",
            "    def test_configurable_forbidden_project_actions(self):",
            "        self.config_fixture.config(",
            "            group='ldap', tenant_allow_create=False, tenant_allow_update=False,",
            "            tenant_allow_delete=False)",
            "        self.load_backends()",
            "",
            "        tenant = {'id': u'f\u00e4k\u00e91', 'name': u'f\u00e4k\u00e91'}",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.create_project,",
            "                          u'f\u00e4k\u00e91',",
            "                          tenant)",
            "",
            "        self.tenant_bar['enabled'] = False",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.update_project,",
            "                          self.tenant_bar['id'],",
            "                          self.tenant_bar)",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.delete_project,",
            "                          self.tenant_bar['id'])",
            "",
            "    def test_configurable_allowed_role_actions(self):",
            "        role = {'id': u'f\u00e4k\u00e91', 'name': u'f\u00e4k\u00e91'}",
            "        self.assignment_api.create_role(u'f\u00e4k\u00e91', role)",
            "        role_ref = self.assignment_api.get_role(u'f\u00e4k\u00e91')",
            "        self.assertEqual(u'f\u00e4k\u00e91', role_ref['id'])",
            "",
            "        role['name'] = u'f\u00e4k\u00e92'",
            "        self.assignment_api.update_role(u'f\u00e4k\u00e91', role)",
            "",
            "        self.assignment_api.delete_role(u'f\u00e4k\u00e91')",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.get_role,",
            "                          u'f\u00e4k\u00e91')",
            "",
            "    def test_configurable_forbidden_role_actions(self):",
            "        self.config_fixture.config(",
            "            group='ldap', role_allow_create=False, role_allow_update=False,",
            "            role_allow_delete=False)",
            "        self.load_backends()",
            "",
            "        role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.create_role,",
            "                          role['id'],",
            "                          role)",
            "",
            "        self.role_member['name'] = uuid.uuid4().hex",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.update_role,",
            "                          self.role_member['id'],",
            "                          self.role_member)",
            "",
            "        self.assertRaises(exception.ForbiddenAction,",
            "                          self.assignment_api.delete_role,",
            "                          self.role_member['id'])",
            "",
            "    def test_project_filter(self):",
            "        tenant_ref = self.assignment_api.get_project(self.tenant_bar['id'])",
            "        self.assertDictEqual(tenant_ref, self.tenant_bar)",
            "",
            "        self.config_fixture.config(group='ldap',",
            "                                   tenant_filter='(CN=DOES_NOT_MATCH)')",
            "        self.load_backends()",
            "        # NOTE(morganfainberg): CONF.ldap.tenant_filter  will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_role.invalidate(self.assignment_api,",
            "                                                self.role_member['id'])",
            "        self.assignment_api.get_role(self.role_member['id'])",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   self.tenant_bar['id'])",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          self.tenant_bar['id'])",
            "",
            "    def test_role_filter(self):",
            "        role_ref = self.assignment_api.get_role(self.role_member['id'])",
            "        self.assertDictEqual(role_ref, self.role_member)",
            "",
            "        self.config_fixture.config(group='ldap',",
            "                                   role_filter='(CN=DOES_NOT_MATCH)')",
            "        self.load_backends()",
            "        # NOTE(morganfainberg): CONF.ldap.role_filter will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_role.invalidate(self.assignment_api,",
            "                                                self.role_member['id'])",
            "        self.assertRaises(exception.RoleNotFound,",
            "                          self.assignment_api.get_role,",
            "                          self.role_member['id'])",
            "",
            "    def test_dumb_member(self):",
            "        self.config_fixture.config(group='ldap', use_dumb_member=True)",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        dumb_id = common_ldap.BaseLdap._dn_to_id(CONF.ldap.dumb_member)",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          dumb_id)",
            "",
            "    def test_project_attribute_mapping(self):",
            "        self.config_fixture.config(",
            "            group='ldap', tenant_name_attribute='ou',",
            "            tenant_desc_attribute='description',",
            "            tenant_enabled_attribute='enabled')",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        # NOTE(morganfainberg): CONF.ldap.tenant_name_attribute,",
            "        # CONF.ldap.tenant_desc_attribute, and",
            "        # CONF.ldap.tenant_enabled_attribute will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   self.tenant_baz['id'])",
            "        tenant_ref = self.assignment_api.get_project(self.tenant_baz['id'])",
            "        self.assertEqual(self.tenant_baz['id'], tenant_ref['id'])",
            "        self.assertEqual(self.tenant_baz['name'], tenant_ref['name'])",
            "        self.assertEqual(",
            "            self.tenant_baz['description'],",
            "            tenant_ref['description'])",
            "        self.assertEqual(self.tenant_baz['enabled'], tenant_ref['enabled'])",
            "",
            "        self.config_fixture.config(group='ldap',",
            "                                   tenant_name_attribute='description',",
            "                                   tenant_desc_attribute='ou')",
            "        self.load_backends()",
            "        # NOTE(morganfainberg): CONF.ldap.tenant_name_attribute,",
            "        # CONF.ldap.tenant_desc_attribute, and",
            "        # CONF.ldap.tenant_enabled_attribute will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   self.tenant_baz['id'])",
            "        tenant_ref = self.assignment_api.get_project(self.tenant_baz['id'])",
            "        self.assertEqual(self.tenant_baz['id'], tenant_ref['id'])",
            "        self.assertEqual(self.tenant_baz['description'], tenant_ref['name'])",
            "        self.assertEqual(self.tenant_baz['name'], tenant_ref['description'])",
            "        self.assertEqual(self.tenant_baz['enabled'], tenant_ref['enabled'])",
            "",
            "    def test_project_attribute_ignore(self):",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            tenant_attribute_ignore=['name', 'description', 'enabled'])",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        # NOTE(morganfainberg): CONF.ldap.tenant_attribute_ignore will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change configs values in tests",
            "        # that could affect what the drivers would return up to the manager.",
            "        # This solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   self.tenant_baz['id'])",
            "        tenant_ref = self.assignment_api.get_project(self.tenant_baz['id'])",
            "        self.assertEqual(self.tenant_baz['id'], tenant_ref['id'])",
            "        self.assertNotIn('name', tenant_ref)",
            "        self.assertNotIn('description', tenant_ref)",
            "        self.assertNotIn('enabled', tenant_ref)",
            "",
            "    def test_role_attribute_mapping(self):",
            "        self.config_fixture.config(group='ldap', role_name_attribute='ou')",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        # NOTE(morganfainberg): CONF.ldap.role_name_attribute will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_role.invalidate(self.assignment_api,",
            "                                                self.role_member['id'])",
            "        role_ref = self.assignment_api.get_role(self.role_member['id'])",
            "        self.assertEqual(self.role_member['id'], role_ref['id'])",
            "        self.assertEqual(self.role_member['name'], role_ref['name'])",
            "",
            "        self.config_fixture.config(group='ldap', role_name_attribute='sn')",
            "        self.load_backends()",
            "        # NOTE(morganfainberg): CONF.ldap.role_name_attribute will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_role.invalidate(self.assignment_api,",
            "                                                self.role_member['id'])",
            "        role_ref = self.assignment_api.get_role(self.role_member['id'])",
            "        self.assertEqual(self.role_member['id'], role_ref['id'])",
            "        self.assertNotIn('name', role_ref)",
            "",
            "    def test_role_attribute_ignore(self):",
            "        self.config_fixture.config(group='ldap',",
            "                                   role_attribute_ignore=['name'])",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        # NOTE(morganfainberg): CONF.ldap.role_attribute_ignore will not be",
            "        # dynamically changed at runtime. This invalidate is a work-around for",
            "        # the expectation that it is safe to change config values in tests that",
            "        # could affect what the drivers would return up to the manager.  This",
            "        # solves this assumption when working with aggressive (on-create)",
            "        # cache population.",
            "        self.assignment_api.get_role.invalidate(self.assignment_api,",
            "                                                self.role_member['id'])",
            "        role_ref = self.assignment_api.get_role(self.role_member['id'])",
            "        self.assertEqual(self.role_member['id'], role_ref['id'])",
            "        self.assertNotIn('name', role_ref)",
            "",
            "    def test_user_enable_attribute_mask(self):",
            "        self.config_fixture.config(group='ldap', user_enabled_mask=2,",
            "                                   user_enabled_default='512')",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "",
            "        ldap_ = self.identity_api.driver.user.get_connection()",
            "",
            "        def get_enabled_vals():",
            "            user_dn = self.identity_api.driver.user._id_to_dn_string(u'f\u00e4k\u00e91')",
            "            enabled_attr_name = CONF.ldap.user_enabled_attribute",
            "",
            "            res = ldap_.search_s(user_dn,",
            "                                 ldap.SCOPE_BASE,",
            "                                 u'(sn=f\u00e4k\u00e91)')",
            "            return res[0][1][enabled_attr_name]",
            "",
            "        user = {'id': u'f\u00e4k\u00e91', 'name': u'f\u00e4k\u00e91', 'enabled': True,",
            "                'domain_id': CONF.identity.default_domain_id}",
            "",
            "        user_ref = self.identity_api.create_user(u'f\u00e4k\u00e91', user)",
            "",
            "        # Use assertIs rather than assertTrue because assertIs will assert the",
            "        # value is a Boolean as expected.",
            "        self.assertIs(user_ref['enabled'], True)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "        enabled_vals = get_enabled_vals()",
            "        self.assertEqual([512], enabled_vals)",
            "",
            "        user_ref = self.identity_api.get_user(u'f\u00e4k\u00e91')",
            "        self.assertIs(user_ref['enabled'], True)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "        user['enabled'] = False",
            "        user_ref = self.identity_api.update_user(u'f\u00e4k\u00e91', user)",
            "        self.assertIs(user_ref['enabled'], False)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "        enabled_vals = get_enabled_vals()",
            "        self.assertEqual([514], enabled_vals)",
            "",
            "        user_ref = self.identity_api.get_user(u'f\u00e4k\u00e91')",
            "        self.assertIs(user_ref['enabled'], False)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "        user['enabled'] = True",
            "        user_ref = self.identity_api.update_user(u'f\u00e4k\u00e91', user)",
            "        self.assertIs(user_ref['enabled'], True)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "        enabled_vals = get_enabled_vals()",
            "        self.assertEqual([512], enabled_vals)",
            "",
            "        user_ref = self.identity_api.get_user(u'f\u00e4k\u00e91')",
            "        self.assertIs(user_ref['enabled'], True)",
            "        self.assertNotIn('enabled_nomask', user_ref)",
            "",
            "    @mock.patch.object(common_ldap_core.KeystoneLDAPHandler, 'simple_bind_s')",
            "    def test_user_api_get_connection_no_user_password(self, mocked_method):",
            "        \"\"\"Don't bind in case the user and password are blank.\"\"\"",
            "        # Ensure the username/password are in-fact blank",
            "        self.config_fixture.config(group='ldap', user=None, password=None)",
            "        user_api = identity.backends.ldap.UserApi(CONF)",
            "        user_api.get_connection(user=None, password=None)",
            "        self.assertFalse(mocked_method.called,",
            "                         msg='`simple_bind_s` method was unexpectedly called')",
            "",
            "    @mock.patch.object(common_ldap_core.KeystoneLDAPHandler, 'connect')",
            "    def test_chase_referrals_off(self, mocked_fakeldap):",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            url='fake://memory',",
            "            chase_referrals=False)",
            "        user_api = identity.backends.ldap.UserApi(CONF)",
            "        user_api.get_connection(user=None, password=None)",
            "",
            "        # The last call_arg should be a dictionary and should contain",
            "        # chase_referrals. Check to make sure the value of chase_referrals",
            "        # is as expected.",
            "        self.assertFalse(mocked_fakeldap.call_args[-1]['chase_referrals'])",
            "",
            "    @mock.patch.object(common_ldap_core.KeystoneLDAPHandler, 'connect')",
            "    def test_chase_referrals_on(self, mocked_fakeldap):",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            url='fake://memory',",
            "            chase_referrals=True)",
            "        user_api = identity.backends.ldap.UserApi(CONF)",
            "        user_api.get_connection(user=None, password=None)",
            "",
            "        # The last call_arg should be a dictionary and should contain",
            "        # chase_referrals. Check to make sure the value of chase_referrals",
            "        # is as expected.",
            "        self.assertTrue(mocked_fakeldap.call_args[-1]['chase_referrals'])",
            "",
            "    @mock.patch.object(common_ldap_core.KeystoneLDAPHandler, 'connect')",
            "    def test_debug_level_set(self, mocked_fakeldap):",
            "        level = 12345",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            url='fake://memory',",
            "            debug_level=level)",
            "        user_api = identity.backends.ldap.UserApi(CONF)",
            "        user_api.get_connection(user=None, password=None)",
            "",
            "        # The last call_arg should be a dictionary and should contain",
            "        # debug_level. Check to make sure the value of debug_level",
            "        # is as expected.",
            "        self.assertEqual(level, mocked_fakeldap.call_args[-1]['debug_level'])",
            "",
            "    def test_wrong_ldap_scope(self):",
            "        self.config_fixture.config(group='ldap', query_scope=uuid.uuid4().hex)",
            "        self.assertRaisesRegexp(",
            "            ValueError,",
            "            'Invalid LDAP scope: %s. *' % CONF.ldap.query_scope,",
            "            identity.backends.ldap.Identity)",
            "",
            "    def test_wrong_alias_dereferencing(self):",
            "        self.config_fixture.config(group='ldap',",
            "                                   alias_dereferencing=uuid.uuid4().hex)",
            "        self.assertRaisesRegexp(",
            "            ValueError,",
            "            'Invalid LDAP deref option: %s\\.' % CONF.ldap.alias_dereferencing,",
            "            identity.backends.ldap.Identity)",
            "",
            "    def test_user_extra_attribute_mapping(self):",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            user_additional_attribute_mapping=['description:name'])",
            "        self.load_backends()",
            "        user = {",
            "            'id': 'extra_attributes',",
            "            'name': 'EXTRA_ATTRIBUTES',",
            "            'password': 'extra',",
            "            'domain_id': CONF.identity.default_domain_id",
            "        }",
            "        self.identity_api.create_user(user['id'], user)",
            "        dn, attrs = self.identity_api.driver.user._ldap_get(user['id'])",
            "        self.assertTrue(user['name'] in attrs['description'])",
            "",
            "    def test_user_extra_attribute_mapping_description_is_returned(self):",
            "        # Given a mapping like description:description, the description is",
            "        # returned.",
            "",
            "        self.config_fixture.config(",
            "            group='ldap',",
            "            user_additional_attribute_mapping=['description:description'])",
            "        self.load_backends()",
            "",
            "        description = uuid.uuid4().hex",
            "        user = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex,",
            "            'description': description,",
            "            'password': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id",
            "        }",
            "        self.identity_api.create_user(user['id'], user)",
            "        res = self.identity_api.driver.user.get_all()",
            "",
            "        new_user = [u for u in res if u['id'] == user['id']][0]",
            "        self.assertThat(new_user['description'], matchers.Equals(description))",
            "",
            "    @mock.patch.object(common_ldap_core.BaseLdap, '_ldap_get')",
            "    def test_user_mixed_case_attribute(self, mock_ldap_get):",
            "        # Mock the search results to return attribute names",
            "        # with unexpected case.",
            "        mock_ldap_get.return_value = (",
            "            'cn=junk,dc=example,dc=com',",
            "            {",
            "                'sN': [uuid.uuid4().hex],",
            "                'eMaIl': [uuid.uuid4().hex]",
            "            }",
            "        )",
            "        user = self.identity_api.get_user('junk')",
            "        self.assertEqual(mock_ldap_get.return_value[1]['sN'][0],",
            "                         user['name'])",
            "        self.assertEqual(mock_ldap_get.return_value[1]['eMaIl'][0],",
            "                         user['email'])",
            "",
            "    def test_parse_extra_attribute_mapping(self):",
            "        option_list = ['description:name', 'gecos:password',",
            "                       'fake:invalid', 'invalid1', 'invalid2:',",
            "                       'description:name:something']",
            "        mapping = self.identity_api.driver.user._parse_extra_attrs(option_list)",
            "        expected_dict = {'description': 'name', 'gecos': 'password',",
            "                         'fake': 'invalid', 'invalid2': ''}",
            "        self.assertDictEqual(expected_dict, mapping)",
            "",
            "# TODO(henry-nash): These need to be removed when the full LDAP implementation",
            "# is submitted - see Bugs 1092187, 1101287, 1101276, 1101289",
            "",
            "    def test_domain_crud(self):",
            "        domain = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                  'enabled': True, 'description': uuid.uuid4().hex}",
            "        self.assertRaises(exception.Forbidden,",
            "                          self.assignment_api.create_domain,",
            "                          domain['id'],",
            "                          domain)",
            "        self.assertRaises(exception.Conflict,",
            "                          self.assignment_api.create_domain,",
            "                          CONF.identity.default_domain_id,",
            "                          domain)",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.get_domain,",
            "                          domain['id'])",
            "",
            "        domain['description'] = uuid.uuid4().hex",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.update_domain,",
            "                          domain['id'],",
            "                          domain)",
            "        self.assertRaises(exception.Forbidden,",
            "                          self.assignment_api.update_domain,",
            "                          CONF.identity.default_domain_id,",
            "                          domain)",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.get_domain,",
            "                          domain['id'])",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.delete_domain,",
            "                          domain['id'])",
            "        self.assertRaises(exception.Forbidden,",
            "                          self.assignment_api.delete_domain,",
            "                          CONF.identity.default_domain_id)",
            "        self.assertRaises(exception.DomainNotFound,",
            "                          self.assignment_api.get_domain,",
            "                          domain['id'])",
            "",
            "    def test_create_domain_case_sensitivity(self):",
            "        # domains are read-only, so case sensitivity isn't an issue",
            "        ref = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex}",
            "        self.assertRaises(exception.Forbidden,",
            "                          self.assignment_api.create_domain,",
            "                          ref['id'],",
            "                          ref)",
            "",
            "    def test_cache_layer_domain_crud(self):",
            "        # TODO(morganfainberg): This also needs to be removed when full LDAP",
            "        # implementation is submitted.  No need to duplicate the above test,",
            "        # just skip this time.",
            "        self.skipTest('Domains are read-only against LDAP')",
            "",
            "    def test_project_crud(self):",
            "        # NOTE(topol): LDAP implementation does not currently support the",
            "        #              updating of a project name so this method override",
            "        #              provides a different update test",
            "        project = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                   'domain_id': CONF.identity.default_domain_id,",
            "                   'description': uuid.uuid4().hex, 'enabled': True",
            "                   }",
            "        self.assignment_api.create_project(project['id'], project)",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "",
            "        self.assertDictEqual(project_ref, project)",
            "",
            "        project['description'] = uuid.uuid4().hex",
            "        self.assignment_api.update_project(project['id'], project)",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "        self.assertDictEqual(project_ref, project)",
            "",
            "        self.assignment_api.delete_project(project['id'])",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project['id'])",
            "",
            "    @tests.skip_if_cache_disabled('assignment')",
            "    def test_cache_layer_project_crud(self):",
            "        # NOTE(morganfainberg): LDAP implementation does not currently support",
            "        # updating project names.  This method override provides a different",
            "        # update test.",
            "        project = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                   'domain_id': CONF.identity.default_domain_id,",
            "                   'description': uuid.uuid4().hex}",
            "        project_id = project['id']",
            "        # Create a project",
            "        self.assignment_api.create_project(project_id, project)",
            "        self.assignment_api.get_project(project_id)",
            "        updated_project = copy.deepcopy(project)",
            "        updated_project['description'] = uuid.uuid4().hex",
            "        # Update project, bypassing assignment_api manager",
            "        self.assignment_api.driver.update_project(project_id,",
            "                                                  updated_project)",
            "        # Verify get_project still returns the original project_ref",
            "        self.assertDictContainsSubset(",
            "            project, self.assignment_api.get_project(project_id))",
            "        # Invalidate cache",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   project_id)",
            "        # Verify get_project now returns the new project",
            "        self.assertDictContainsSubset(",
            "            updated_project,",
            "            self.assignment_api.get_project(project_id))",
            "        # Update project using the assignment_api manager back to original",
            "        self.assignment_api.update_project(project['id'], project)",
            "        # Verify get_project returns the original project_ref",
            "        self.assertDictContainsSubset(",
            "            project, self.assignment_api.get_project(project_id))",
            "        # Delete project bypassing assignment_api",
            "        self.assignment_api.driver.delete_project(project_id)",
            "        # Verify get_project still returns the project_ref",
            "        self.assertDictContainsSubset(",
            "            project, self.assignment_api.get_project(project_id))",
            "        # Invalidate cache",
            "        self.assignment_api.get_project.invalidate(self.assignment_api,",
            "                                                   project_id)",
            "        # Verify ProjectNotFound now raised",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project_id)",
            "        # recreate project",
            "        self.assignment_api.create_project(project_id, project)",
            "        self.assignment_api.get_project(project_id)",
            "        # delete project",
            "        self.assignment_api.delete_project(project_id)",
            "        # Verify ProjectNotFound is raised",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project_id)",
            "",
            "    def test_multi_role_grant_by_user_group_on_project_domain(self):",
            "        # This is a partial implementation of the standard test that",
            "        # is defined in test_backend.py.  It omits both domain and",
            "        # group grants. since neither of these are yet supported by",
            "        # the ldap backend.",
            "",
            "        role_list = []",
            "        for _ in range(2):",
            "            role = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}",
            "            self.assignment_api.create_role(role['id'], role)",
            "            role_list.append(role)",
            "",
            "        user1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                 'domain_id': CONF.identity.default_domain_id,",
            "                 'password': uuid.uuid4().hex,",
            "                 'enabled': True}",
            "        self.identity_api.create_user(user1['id'], user1)",
            "        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': CONF.identity.default_domain_id}",
            "        self.assignment_api.create_project(project1['id'], project1)",
            "",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            user_id=user1['id'],",
            "            tenant_id=project1['id'],",
            "            role_id=role_list[0]['id'])",
            "        self.assignment_api.add_role_to_user_and_project(",
            "            user_id=user1['id'],",
            "            tenant_id=project1['id'],",
            "            role_id=role_list[1]['id'])",
            "",
            "        # Although list_grants are not yet supported, we can test the",
            "        # alternate way of getting back lists of grants, where user",
            "        # and group roles are combined.  Only directly assigned user",
            "        # roles are available, since group grants are not yet supported",
            "",
            "        combined_list = self.assignment_api.get_roles_for_user_and_project(",
            "            user1['id'],",
            "            project1['id'])",
            "        self.assertEqual(2, len(combined_list))",
            "        self.assertIn(role_list[0]['id'], combined_list)",
            "        self.assertIn(role_list[1]['id'], combined_list)",
            "",
            "        # Finally, although domain roles are not implemented, check we can",
            "        # issue the combined get roles call with benign results, since thus is",
            "        # used in token generation",
            "",
            "        combined_role_list = self.assignment_api.get_roles_for_user_and_domain(",
            "            user1['id'], CONF.identity.default_domain_id)",
            "        self.assertEqual(0, len(combined_role_list))",
            "",
            "    def test_list_projects_for_alternate_domain(self):",
            "        self.skipTest(",
            "            'N/A: LDAP does not support multiple domains')",
            "",
            "    def test_create_grant_no_user(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_create_grant_no_group(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_get_default_domain_by_name(self):",
            "        domain = self._get_domain_fixture()",
            "",
            "        domain_ref = self.assignment_api.get_domain_by_name(domain['name'])",
            "        self.assertEqual(domain_ref, domain)",
            "",
            "    def test_base_ldap_connection_deref_option(self):",
            "        def get_conn(deref_name):",
            "            self.config_fixture.config(group='ldap',",
            "                                       alias_dereferencing=deref_name)",
            "            base_ldap = common_ldap.BaseLdap(CONF)",
            "            return base_ldap.get_connection()",
            "",
            "        conn = get_conn('default')",
            "        self.assertEqual(ldap.get_option(ldap.OPT_DEREF),",
            "                         conn.get_option(ldap.OPT_DEREF))",
            "",
            "        conn = get_conn('always')",
            "        self.assertEqual(ldap.DEREF_ALWAYS,",
            "                         conn.get_option(ldap.OPT_DEREF))",
            "",
            "        conn = get_conn('finding')",
            "        self.assertEqual(ldap.DEREF_FINDING,",
            "                         conn.get_option(ldap.OPT_DEREF))",
            "",
            "        conn = get_conn('never')",
            "        self.assertEqual(ldap.DEREF_NEVER,",
            "                         conn.get_option(ldap.OPT_DEREF))",
            "",
            "        conn = get_conn('searching')",
            "        self.assertEqual(ldap.DEREF_SEARCHING,",
            "                         conn.get_option(ldap.OPT_DEREF))",
            "",
            "    def test_list_users_no_dn(self):",
            "        users = self.identity_api.list_users()",
            "        self.assertEqual(len(default_fixtures.USERS), len(users))",
            "        user_ids = set(user['id'] for user in users)",
            "        expected_user_ids = set(user['id'] for user in default_fixtures.USERS)",
            "        for user_ref in users:",
            "            self.assertNotIn('dn', user_ref)",
            "        self.assertEqual(expected_user_ids, user_ids)",
            "",
            "    def test_list_groups_no_dn(self):",
            "        # Create some test groups.",
            "        domain = self._get_domain_fixture()",
            "        expected_group_ids = []",
            "        numgroups = 3",
            "        for _ in range(numgroups):",
            "            group = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                     'domain_id': domain['id']}",
            "            self.identity_api.create_group(group['id'], group)",
            "            expected_group_ids.append(group['id'])",
            "        # Fetch the test groups and ensure that they don't contain a dn.",
            "        groups = self.identity_api.list_groups()",
            "        self.assertEqual(numgroups, len(groups))",
            "        group_ids = set(group['id'] for group in groups)",
            "        for group_ref in groups:",
            "            self.assertNotIn('dn', group_ref)",
            "        self.assertEqual(set(expected_group_ids), group_ids)",
            "",
            "    def test_list_groups_for_user_no_dn(self):",
            "        # Create a test user.",
            "        user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                'domain_id': CONF.identity.default_domain_id,",
            "                'password': uuid.uuid4().hex,",
            "                'enabled': True}",
            "        self.identity_api.create_user(user['id'], user)",
            "        # Create some test groups and add the test user as a member.",
            "        domain = self._get_domain_fixture()",
            "        expected_group_ids = []",
            "        numgroups = 3",
            "        for _ in range(numgroups):",
            "            group = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                     'domain_id': domain['id']}",
            "            self.identity_api.create_group(group['id'], group)",
            "            expected_group_ids.append(group['id'])",
            "            self.identity_api.add_user_to_group(user['id'], group['id'])",
            "        # Fetch the groups for the test user",
            "        # and ensure they don't contain a dn.",
            "        groups = self.identity_api.list_groups_for_user(user['id'])",
            "        self.assertEqual(numgroups, len(groups))",
            "        group_ids = set(group['id'] for group in groups)",
            "        for group_ref in groups:",
            "            self.assertNotIn('dn', group_ref)",
            "        self.assertEqual(set(expected_group_ids), group_ids)",
            "",
            "",
            "class LDAPIdentityEnabledEmulation(LDAPIdentity):",
            "    def setUp(self):",
            "        super(LDAPIdentityEnabledEmulation, self).setUp()",
            "        self.clear_database()",
            "        self.load_backends()",
            "        self.load_fixtures(default_fixtures)",
            "        for obj in [self.tenant_bar, self.tenant_baz, self.user_foo,",
            "                    self.user_two, self.user_badguy]:",
            "            obj.setdefault('enabled', True)",
            "",
            "    def config_files(self):",
            "        config_files = super(LDAPIdentityEnabledEmulation, self).config_files()",
            "        config_files.append(tests.dirs.tests_conf('backend_ldap.conf'))",
            "        return config_files",
            "",
            "    def config_overrides(self):",
            "        super(LDAPIdentityEnabledEmulation, self).config_overrides()",
            "        self.config_fixture.config(group='ldap',",
            "                                   user_enabled_emulation=True,",
            "                                   tenant_enabled_emulation=True)",
            "",
            "    def test_project_crud(self):",
            "        # NOTE(topol): LDAPIdentityEnabledEmulation will create an",
            "        #              enabled key in the project dictionary so this",
            "        #              method override handles this side-effect",
            "        project = {",
            "            'id': uuid.uuid4().hex,",
            "            'name': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'description': uuid.uuid4().hex}",
            "",
            "        self.assignment_api.create_project(project['id'], project)",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "",
            "        # self.assignment_api.create_project adds an enabled",
            "        # key with a value of True when LDAPIdentityEnabledEmulation",
            "        # is used so we now add this expected key to the project dictionary",
            "        project['enabled'] = True",
            "        self.assertDictEqual(project_ref, project)",
            "",
            "        project['description'] = uuid.uuid4().hex",
            "        self.assignment_api.update_project(project['id'], project)",
            "        project_ref = self.assignment_api.get_project(project['id'])",
            "        self.assertDictEqual(project_ref, project)",
            "",
            "        self.assignment_api.delete_project(project['id'])",
            "        self.assertRaises(exception.ProjectNotFound,",
            "                          self.assignment_api.get_project,",
            "                          project['id'])",
            "",
            "    def test_user_crud(self):",
            "        user = {",
            "            'id': uuid.uuid4().hex,",
            "            'domain_id': CONF.identity.default_domain_id,",
            "            'name': uuid.uuid4().hex,",
            "            'password': uuid.uuid4().hex}",
            "        self.identity_api.create_user(user['id'], user)",
            "        user['enabled'] = True",
            "        user_ref = self.identity_api.get_user(user['id'])",
            "        del user['password']",
            "        user_ref_dict = dict((x, user_ref[x]) for x in user_ref)",
            "        self.assertDictEqual(user_ref_dict, user)",
            "",
            "        user['password'] = uuid.uuid4().hex",
            "        self.identity_api.update_user(user['id'], user)",
            "        user_ref = self.identity_api.get_user(user['id'])",
            "        del user['password']",
            "        user_ref_dict = dict((x, user_ref[x]) for x in user_ref)",
            "        self.assertDictEqual(user_ref_dict, user)",
            "",
            "        self.identity_api.delete_user(user['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          user['id'])",
            "",
            "    def test_user_enable_attribute_mask(self):",
            "        self.skipTest(",
            "            \"Enabled emulation conflicts with enabled mask\")",
            "",
            "",
            "class LdapIdentitySqlAssignment(BaseLDAPIdentity, tests.SQLDriverOverrides,",
            "                                tests.TestCase):",
            "",
            "    def config_files(self):",
            "        config_files = super(LdapIdentitySqlAssignment, self).config_files()",
            "        config_files.append(tests.dirs.tests_conf('backend_ldap_sql.conf'))",
            "        return config_files",
            "",
            "    def setUp(self):",
            "        self.useFixture(database.Database())",
            "        super(LdapIdentitySqlAssignment, self).setUp()",
            "        self.clear_database()",
            "        self.load_backends()",
            "        cache.configure_cache_region(cache.REGION)",
            "        self.engine = sql.get_engine()",
            "        self.addCleanup(sql.cleanup)",
            "",
            "        sql.ModelBase.metadata.create_all(bind=self.engine)",
            "        self.addCleanup(sql.ModelBase.metadata.drop_all, bind=self.engine)",
            "",
            "        self.load_fixtures(default_fixtures)",
            "        # defaulted by the data load",
            "        self.user_foo['enabled'] = True",
            "",
            "    def config_overrides(self):",
            "        super(LdapIdentitySqlAssignment, self).config_overrides()",
            "        self.config_fixture.config(",
            "            group='identity',",
            "            driver='keystone.identity.backends.ldap.Identity')",
            "        self.config_fixture.config(",
            "            group='assignment',",
            "            driver='keystone.assignment.backends.sql.Assignment')",
            "",
            "    def test_domain_crud(self):",
            "        pass",
            "",
            "    def test_list_domains(self):",
            "        domains = self.assignment_api.list_domains()",
            "        self.assertEqual([assignment.calc_default_domain()], domains)",
            "",
            "    def test_list_domains_non_default_domain_id(self):",
            "        # If change the default_domain_id, the ID of the default domain",
            "        # returned by list_domains doesn't change because the SQL identity",
            "        # backend reads it from the database, which doesn't get updated by",
            "        # config change.",
            "",
            "        orig_default_domain_id = CONF.identity.default_domain_id",
            "",
            "        new_domain_id = uuid.uuid4().hex",
            "        self.config_fixture.config(group='identity',",
            "                                   default_domain_id=new_domain_id)",
            "",
            "        domains = self.assignment_api.list_domains()",
            "",
            "        self.assertEqual(orig_default_domain_id, domains[0]['id'])",
            "",
            "    def test_project_filter(self):",
            "        self.skipTest(",
            "            'N/A: Not part of SQL backend')",
            "",
            "    def test_role_filter(self):",
            "        self.skipTest(",
            "            'N/A: Not part of SQL backend')",
            "",
            "    def test_add_role_grant_to_user_and_project_404(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_get_role_grants_for_user_and_project_404(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_list_projects_for_user_with_grants(self):",
            "        self.skipTest('Blocked by bug 1221805')",
            "",
            "",
            "class MultiLDAPandSQLIdentity(BaseLDAPIdentity, tests.SQLDriverOverrides,",
            "                              tests.TestCase):",
            "    \"\"\"Class to test common SQL plus individual LDAP backends.",
            "",
            "    We define a set of domains and domain-specific backends:",
            "",
            "    - A separate LDAP backend for the default domain",
            "    - A separate LDAP backend for domain1",
            "    - domain2 shares the same LDAP as domain1, but uses a different",
            "      tree attach point",
            "    - An SQL backend for all other domains (which will include domain3",
            "      and domain4)",
            "",
            "    Normally one would expect that the default domain would be handled as",
            "    part of the \"other domains\" - however the above provides better",
            "    test coverage since most of the existing backend tests use the default",
            "    domain.",
            "",
            "    \"\"\"",
            "    def setUp(self):",
            "        self.useFixture(database.Database())",
            "        super(MultiLDAPandSQLIdentity, self).setUp()",
            "",
            "        self.load_backends()",
            "",
            "        self.engine = sql.get_engine()",
            "        self.addCleanup(sql.cleanup)",
            "",
            "        sql.ModelBase.metadata.create_all(bind=self.engine)",
            "        self.addCleanup(sql.ModelBase.metadata.drop_all, bind=self.engine)",
            "",
            "        self._setup_domain_test_data()",
            "",
            "        # All initial domain data setup complete, time to switch on support",
            "        # for separate backends per domain.",
            "",
            "        self.config_fixture.config(group='identity',",
            "                                   domain_specific_drivers_enabled=True,",
            "                                   domain_config_dir=tests.TESTSDIR)",
            "",
            "        self._set_domain_configs()",
            "        self.clear_database()",
            "        self.load_fixtures(default_fixtures)",
            "",
            "    def config_overrides(self):",
            "        super(MultiLDAPandSQLIdentity, self).config_overrides()",
            "        # Make sure identity and assignment are actually SQL drivers,",
            "        # BaseLDAPIdentity sets these options to use LDAP.",
            "        self.config_fixture.config(",
            "            group='identity',",
            "            driver='keystone.identity.backends.sql.Identity')",
            "        self.config_fixture.config(",
            "            group='assignment',",
            "            driver='keystone.assignment.backends.sql.Assignment')",
            "",
            "    def _setup_domain_test_data(self):",
            "",
            "        def create_domain(domain):",
            "            try:",
            "                ref = self.assignment_api.create_domain(",
            "                    domain['id'], domain)",
            "            except exception.Conflict:",
            "                ref = (",
            "                    self.assignment_api.get_domain_by_name(domain['name']))",
            "            return ref",
            "",
            "        self.domain_default = create_domain(assignment.calc_default_domain())",
            "        self.domain1 = create_domain(",
            "            {'id': uuid.uuid4().hex, 'name': 'domain1'})",
            "        self.domain2 = create_domain(",
            "            {'id': uuid.uuid4().hex, 'name': 'domain2'})",
            "        self.domain3 = create_domain(",
            "            {'id': uuid.uuid4().hex, 'name': 'domain3'})",
            "        self.domain4 = create_domain(",
            "            {'id': uuid.uuid4().hex, 'name': 'domain4'})",
            "",
            "    def _set_domain_configs(self):",
            "        # We need to load the domain configs explicitly to ensure the",
            "        # test overrides are included.",
            "        self.identity_api.domain_configs._load_config(",
            "            self.identity_api.assignment_api,",
            "            [tests.dirs.tests_conf('keystone.Default.conf')],",
            "            'Default')",
            "        self.identity_api.domain_configs._load_config(",
            "            self.identity_api.assignment_api,",
            "            [tests.dirs.tests_conf('keystone.domain1.conf')],",
            "            'domain1')",
            "        self.identity_api.domain_configs._load_config(",
            "            self.identity_api.assignment_api,",
            "            [tests.dirs.tests_conf('keystone.domain2.conf')],",
            "            'domain2')",
            "",
            "    def reload_backends(self, domain_id):",
            "        # Just reload the driver for this domain - which will pickup",
            "        # any updated cfg",
            "        self.identity_api.domain_configs.reload_domain_driver(",
            "            self.identity_api.assignment_api, domain_id)",
            "",
            "    def get_config(self, domain_id):",
            "        # Get the config for this domain, will return CONF",
            "        # if no specific config defined for this domain",
            "        return self.identity_api.domain_configs.get_domain_conf(domain_id)",
            "",
            "    def test_list_domains(self):",
            "        self.skipTest(",
            "            'N/A: Not relevant for multi ldap testing')",
            "",
            "    def test_list_domains_non_default_domain_id(self):",
            "        self.skipTest(",
            "            'N/A: Not relevant for multi ldap testing')",
            "",
            "    def test_domain_segregation(self):",
            "        \"\"\"Test that separate configs have segregated the domain.",
            "",
            "        Test Plan:",
            "",
            "        - Create a user in each of the domains",
            "        - Make sure that you can only find a given user in its",
            "          relevant domain",
            "        - Make sure that for a backend that supports multiple domains",
            "          you can get the users via any of the domain scopes",
            "",
            "        \"\"\"",
            "        def create_user(domain_id):",
            "            user = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,",
            "                    'domain_id': domain_id,",
            "                    'password': uuid.uuid4().hex,",
            "                    'enabled': True}",
            "            self.identity_api.create_user(user['id'], user)",
            "            return user",
            "",
            "        userd = create_user(CONF.identity.default_domain_id)",
            "        user1 = create_user(self.domain1['id'])",
            "        user2 = create_user(self.domain2['id'])",
            "        user3 = create_user(self.domain3['id'])",
            "        user4 = create_user(self.domain4['id'])",
            "",
            "        # Now check that I can read user1 with the appropriate domain",
            "        # scope, but won't find it if the wrong scope is used",
            "",
            "        ref = self.identity_api.get_user(",
            "            userd['id'], domain_scope=CONF.identity.default_domain_id)",
            "        del userd['password']",
            "        self.assertDictEqual(ref, userd)",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          userd['id'],",
            "                          domain_scope=self.domain1['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          userd['id'],",
            "                          domain_scope=self.domain2['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          userd['id'],",
            "                          domain_scope=self.domain3['id'])",
            "        self.assertRaises(exception.UserNotFound,",
            "                          self.identity_api.get_user,",
            "                          userd['id'],",
            "                          domain_scope=self.domain4['id'])",
            "",
            "        ref = self.identity_api.get_user(",
            "            user1['id'], domain_scope=self.domain1['id'])",
            "        del user1['password']",
            "        self.assertDictEqual(ref, user1)",
            "        ref = self.identity_api.get_user(",
            "            user2['id'], domain_scope=self.domain2['id'])",
            "        del user2['password']",
            "        self.assertDictEqual(ref, user2)",
            "",
            "        # Domains 3 and 4 share the same backend, so you should be",
            "        # able to see user3 and 4 from either",
            "",
            "        ref = self.identity_api.get_user(",
            "            user3['id'], domain_scope=self.domain3['id'])",
            "        del user3['password']",
            "        self.assertDictEqual(ref, user3)",
            "        ref = self.identity_api.get_user(",
            "            user4['id'], domain_scope=self.domain4['id'])",
            "        del user4['password']",
            "        self.assertDictEqual(ref, user4)",
            "        ref = self.identity_api.get_user(",
            "            user3['id'], domain_scope=self.domain4['id'])",
            "        self.assertDictEqual(ref, user3)",
            "        ref = self.identity_api.get_user(",
            "            user4['id'], domain_scope=self.domain3['id'])",
            "        self.assertDictEqual(ref, user4)",
            "",
            "    def test_scanning_of_config_dir(self):",
            "        \"\"\"Test the Manager class scans the config directory.",
            "",
            "        The setup for the main tests above load the domain configs directly",
            "        so that the test overrides can be included. This test just makes sure",
            "        that the standard config directory scanning does pick up the relevant",
            "        domain config files.",
            "",
            "        \"\"\"",
            "        # Confirm that config has drivers_enabled as True, which we will",
            "        # check has been set to False later in this test",
            "        self.assertTrue(config.CONF.identity.domain_specific_drivers_enabled)",
            "        self.load_backends()",
            "        # Execute any command to trigger the lazy loading of domain configs",
            "        self.identity_api.list_users(domain_scope=self.domain1['id'])",
            "        # ...and now check the domain configs have been set up",
            "        self.assertIn('default', self.identity_api.domain_configs)",
            "        self.assertIn(self.domain1['id'], self.identity_api.domain_configs)",
            "        self.assertIn(self.domain2['id'], self.identity_api.domain_configs)",
            "        self.assertNotIn(self.domain3['id'], self.identity_api.domain_configs)",
            "        self.assertNotIn(self.domain4['id'], self.identity_api.domain_configs)",
            "",
            "        # Finally check that a domain specific config contains items from both",
            "        # the primary config and the domain specific config",
            "        conf = self.identity_api.domain_configs.get_domain_conf(",
            "            self.domain1['id'])",
            "        # This should now be false, as is the default, since this is not",
            "        # set in the standard primary config file",
            "        self.assertFalse(conf.identity.domain_specific_drivers_enabled)",
            "        # ..and make sure a domain-specific options is also set",
            "        self.assertEqual('fake://memory1', conf.ldap.url)",
            "",
            "    def test_add_role_grant_to_user_and_project_404(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_get_role_grants_for_user_and_project_404(self):",
            "        self.skipTest('Blocked by bug 1101287')",
            "",
            "    def test_list_projects_for_user_with_grants(self):",
            "        self.skipTest('Blocked by bug 1221805')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1253": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1254": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1255": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1256": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1257": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1258": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1259": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1260": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1261": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1262": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1263": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1264": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1265": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1266": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1267": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1268": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1269": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1270": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1271": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1272": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1273": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1274": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1275": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1276": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1277": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1278": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1279": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1280": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1281": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1282": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1283": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1284": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1285": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1286": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1287": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1288": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1289": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1290": [
                "LDAPIdentity",
                "test_get_roles_for_user_and_project_user_group_same_id"
            ],
            "1291": [
                "LDAPIdentity"
            ]
        },
        "addLocation": [
            "rdiffweb.controller.page_pref_sshkeys.ApiSshKeys.post"
        ]
    }
}