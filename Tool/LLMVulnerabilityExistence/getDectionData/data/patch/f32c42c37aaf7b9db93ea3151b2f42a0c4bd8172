{
    "lib/ansible/config/manager.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " import os"
            },
            "2": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " import sys"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+import stat"
            },
            "4": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " import tempfile"
            },
            "5": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " import yaml"
            },
            "6": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "     return value"
            },
            "8": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 136,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 137,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def find_ini_config_file():"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+def find_ini_config_file(warnings=None):"
            },
            "12": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "     ''' Load INI Config File order(first found is used): ENV, CWD, HOME, /etc/ansible '''"
            },
            "13": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "     # FIXME: eventually deprecate ini configs"
            },
            "14": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 141,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "         if os.path.isdir(path0):"
            },
            "16": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "             path0 += \"/ansible.cfg\""
            },
            "17": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "     try:"
            },
            "18": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        path1 = os.getcwd() + \"/ansible.cfg\""
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+        path1 = os.getcwd()"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+        perms1 = os.stat(path1)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+        if perms1.st_mode & stat.S_IWOTH:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+            if warnings is not None:"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+                warnings.add(\"Ansible is in a world writable directory (%s), ignoring it as an ansible.cfg source.\" % to_text(path1))"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+            path1 = None"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+        else:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+            path1 += \"/ansible.cfg\""
            },
            "27": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "     except OSError:"
            },
            "28": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "         path1 = None"
            },
            "29": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "     path2 = unfrackpath(\"~/.ansible.cfg\", follow=False)"
            },
            "30": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 171,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "     UNABLE = []"
            },
            "32": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "     DEPRECATED = []"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+    WARNINGS = set()"
            },
            "34": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 175,
                "PatchRowcode": " "
            },
            "35": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "     def __init__(self, conf_file=None):"
            },
            "36": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 177,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": 193,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": 194,
                "PatchRowcode": "         if self._config_file is None:"
            },
            "39": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": 195,
                "PatchRowcode": "             # set config using ini"
            },
            "40": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self._config_file = find_ini_config_file()"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+            self._config_file = find_ini_config_file(self.WARNINGS)"
            },
            "42": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 197,
                "PatchRowcode": " "
            },
            "43": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "         if self._config_file:"
            },
            "44": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 199,
                "PatchRowcode": "             if os.path.exists(self._config_file):"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2017 Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "# Make coding more python3-ish",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import os",
            "import sys",
            "import tempfile",
            "import yaml",
            "",
            "from collections import namedtuple",
            "",
            "from ansible.config.data import ConfigData",
            "from ansible.errors import AnsibleOptionsError, AnsibleError",
            "from ansible.module_utils.six import string_types",
            "from ansible.module_utils.six.moves import configparser",
            "from ansible.module_utils._text import to_text, to_bytes, to_native",
            "from ansible.module_utils.parsing.convert_bool import boolean",
            "from ansible.parsing.quoting import unquote",
            "from ansible.utils.path import unfrackpath",
            "from ansible.utils.path import makedirs_safe",
            "",
            "Plugin = namedtuple('Plugin', 'name type')",
            "Setting = namedtuple('Setting', 'name value origin type')",
            "",
            "",
            "# FIXME: see if we can unify in module_utils with similar function used by argspec",
            "def ensure_type(value, value_type, origin=None):",
            "    ''' return a configuration variable with casting",
            "    :arg value: The value to ensure correct typing of",
            "    :kwarg value_type: The type of the value.  This can be any of the following strings:",
            "        :boolean: sets the value to a True or False value",
            "        :integer: Sets the value to an integer or raises a ValueType error",
            "        :float: Sets the value to a float or raises a ValueType error",
            "        :list: Treats the value as a comma separated list.  Split the value",
            "            and return it as a python list.",
            "        :none: Sets the value to None",
            "        :path: Expands any environment variables and tilde's in the value.",
            "        :tmp_path: Create a unique temporary directory inside of the directory",
            "            specified by value and return its path.",
            "        :pathlist: Treat the value as a typical PATH string.  (On POSIX, this",
            "            means colon separated strings.)  Split the value and then expand",
            "            each part for environment variables and tildes.",
            "    '''",
            "",
            "    basedir = None",
            "    if origin and os.path.isabs(origin) and os.path.exists(origin):",
            "        basedir = origin",
            "",
            "    if value_type:",
            "        value_type = value_type.lower()",
            "",
            "    if value_type in ('boolean', 'bool'):",
            "        value = boolean(value, strict=False)",
            "",
            "    elif value:",
            "        if value_type in ('integer', 'int'):",
            "            value = int(value)",
            "",
            "        elif value_type == 'float':",
            "            value = float(value)",
            "",
            "        elif value_type == 'list':",
            "            if isinstance(value, string_types):",
            "                value = [x.strip() for x in value.split(',')]",
            "",
            "        elif value_type == 'none':",
            "            if value == \"None\":",
            "                value = None",
            "",
            "        elif value_type == 'path':",
            "            value = resolve_path(value, basedir=basedir)",
            "",
            "        elif value_type in ('tmp', 'temppath', 'tmppath'):",
            "            value = resolve_path(value, basedir=basedir)",
            "            if not os.path.exists(value):",
            "                makedirs_safe(value, 0o700)",
            "            prefix = 'ansible-local-%s' % os.getpid()",
            "            value = tempfile.mkdtemp(prefix=prefix, dir=value)",
            "",
            "        elif value_type == 'pathspec':",
            "            if isinstance(value, string_types):",
            "                value = value.split(os.pathsep)",
            "            value = [resolve_path(x, basedir=basedir) for x in value]",
            "",
            "        elif value_type == 'pathlist':",
            "            if isinstance(value, string_types):",
            "                value = value.split(',')",
            "            value = [resolve_path(x, basedir=basedir) for x in value]",
            "",
            "        # defaults to string types",
            "        elif isinstance(value, string_types):",
            "            value = unquote(value)",
            "",
            "    return to_text(value, errors='surrogate_or_strict', nonstring='passthru')",
            "",
            "",
            "# FIXME: see if this can live in utils/path",
            "def resolve_path(path, basedir=None):",
            "    ''' resolve relative or 'varaible' paths '''",
            "    if '{{CWD}}' in path:  # allow users to force CWD using 'magic' {{CWD}}",
            "        path = path.replace('{{CWD}}', os.getcwd())",
            "",
            "    return unfrackpath(path, follow=False, basedir=basedir)",
            "",
            "",
            "# FIXME: generic file type?",
            "def get_config_type(cfile):",
            "",
            "    ftype = None",
            "    if cfile is not None:",
            "        ext = os.path.splitext(cfile)[-1]",
            "        if ext in ('.ini', '.cfg'):",
            "            ftype = 'ini'",
            "        elif ext in ('.yaml', '.yml'):",
            "            ftype = 'yaml'",
            "        else:",
            "            raise AnsibleOptionsError(\"Unsupported configuration file extension for %s: %s\" % (cfile, to_native(ext)))",
            "",
            "    return ftype",
            "",
            "",
            "# FIXME: can move to module_utils for use for ini plugins also?",
            "def get_ini_config_value(p, entry):",
            "    ''' returns the value of last ini entry found '''",
            "    value = None",
            "    if p is not None:",
            "        try:",
            "            value = p.get(entry.get('section', 'defaults'), entry.get('key', ''), raw=True)",
            "        except:  # FIXME: actually report issues here",
            "            pass",
            "    return value",
            "",
            "",
            "def find_ini_config_file():",
            "    ''' Load INI Config File order(first found is used): ENV, CWD, HOME, /etc/ansible '''",
            "    # FIXME: eventually deprecate ini configs",
            "",
            "    path0 = os.getenv(\"ANSIBLE_CONFIG\", None)",
            "    if path0 is not None:",
            "        path0 = unfrackpath(path0, follow=False)",
            "        if os.path.isdir(path0):",
            "            path0 += \"/ansible.cfg\"",
            "    try:",
            "        path1 = os.getcwd() + \"/ansible.cfg\"",
            "    except OSError:",
            "        path1 = None",
            "    path2 = unfrackpath(\"~/.ansible.cfg\", follow=False)",
            "    path3 = \"/etc/ansible/ansible.cfg\"",
            "",
            "    for path in [path0, path1, path2, path3]:",
            "        if path is not None and os.path.exists(path):",
            "            break",
            "    else:",
            "        path = None",
            "",
            "    return path",
            "",
            "",
            "class ConfigManager(object):",
            "",
            "    UNABLE = []",
            "    DEPRECATED = []",
            "",
            "    def __init__(self, conf_file=None):",
            "",
            "        self._base_defs = {}",
            "        self._plugins = {}",
            "        self._parser = None",
            "",
            "        self._config_file = conf_file",
            "        self.data = ConfigData()",
            "",
            "        # FIXME: make dynamic? scan for more? make it's own method?",
            "        # Create configuration definitions from source",
            "        bconfig_def = to_bytes('%s/base.yml' % os.path.dirname(__file__))",
            "        if os.path.exists(bconfig_def):",
            "            with open(bconfig_def, 'rb') as config_def:",
            "                self._base_defs = yaml.safe_load(config_def)",
            "        else:",
            "            raise AnsibleError(\"Missing base configuration definition file (bad install?): %s\" % to_native(bconfig_def))",
            "",
            "        if self._config_file is None:",
            "            # set config using ini",
            "            self._config_file = find_ini_config_file()",
            "",
            "        if self._config_file:",
            "            if os.path.exists(self._config_file):",
            "                # initialize parser and read config",
            "                self._parse_config_file()",
            "",
            "        # update constants",
            "        self.update_config_data()",
            "",
            "    def _parse_config_file(self, cfile=None):",
            "        ''' return flat configuration settings from file(s) '''",
            "        # TODO: take list of files with merge/nomerge",
            "",
            "        if cfile is None:",
            "            cfile = self._config_file",
            "",
            "        ftype = get_config_type(cfile)",
            "        if cfile is not None:",
            "            if ftype == 'ini':",
            "                self._parser = configparser.ConfigParser()",
            "                try:",
            "                    self._parser.read(cfile)",
            "                except configparser.Error as e:",
            "                    raise AnsibleOptionsError(\"Error reading config file (%s): %s\" % (cfile, to_native(e)))",
            "            # FIXME: this should eventually handle yaml config files",
            "            #elif ftype == 'yaml':",
            "            #    with open(cfile, 'rb') as config_stream:",
            "            #        self._parser = yaml.safe_load(config_stream)",
            "            else:",
            "                raise AnsibleOptionsError(\"Unsupported configuration file type: %s\" % to_native(ftype))",
            "",
            "    def _find_yaml_config_files(self):",
            "        ''' Load YAML Config Files in order, check merge flags, keep origin of settings'''",
            "        pass",
            "",
            "    def get_plugin_options(self, plugin_type, name, variables=None):",
            "",
            "        options = {}",
            "        defs = self.get_configuration_definitions(plugin_type, name)",
            "        for option in defs:",
            "            options[option] = self.get_config_value(option, plugin_type=plugin_type, plugin_name=name, variables=variables)",
            "",
            "        return options",
            "",
            "    def get_configuration_definitions(self, plugin_type=None, name=None):",
            "        ''' just list the possible settings, either base or for specific plugins or plugin '''",
            "",
            "        ret = {}",
            "        if plugin_type is None:",
            "            ret = self._base_defs",
            "        elif name is None:",
            "            ret = self._plugins.get(plugin_type, {})",
            "        else:",
            "            ret = self._plugins.get(plugin_type, {}).get(name, {})",
            "",
            "        return ret",
            "",
            "    def _loop_entries(self, container, entry_list):",
            "        ''' repeat code for value entry assignment '''",
            "",
            "        value = None",
            "        origin = None",
            "        for entry in entry_list:",
            "            name = entry.get('name')",
            "            temp_value = container.get(name, None)",
            "            if temp_value is not None:  # only set if env var is defined",
            "                value = temp_value",
            "                origin = name",
            "",
            "                # deal with deprecation of setting source, if used",
            "                if 'deprecated' in entry:",
            "                    self.DEPRECATED.append((entry['name'], entry['deprecated']))",
            "",
            "        return value, origin",
            "",
            "    def get_config_value(self, config, cfile=None, plugin_type=None, plugin_name=None, variables=None):",
            "        ''' wrapper '''",
            "        value, _drop = self.get_config_value_and_origin(config, cfile=cfile, plugin_type=plugin_type, plugin_name=plugin_name, variables=variables)",
            "        return value",
            "",
            "    def get_config_value_and_origin(self, config, cfile=None, plugin_type=None, plugin_name=None, variables=None):",
            "        ''' Given a config key figure out the actual value and report on the origin of the settings '''",
            "",
            "        if cfile is None:",
            "            cfile = self._config_file",
            "",
            "        # Note: sources that are lists listed in low to high precedence (last one wins)",
            "        value = None",
            "        defs = {}",
            "        if plugin_type is None:",
            "            defs = self._base_defs",
            "        elif plugin_name is None:",
            "            defs = self._plugins[plugin_type]",
            "        else:",
            "            defs = self._plugins[plugin_type][plugin_name]",
            "",
            "        # Use 'variable overrides' if present, highest precedence, but only present when querying running play",
            "        if variables:",
            "            value, origin = self._loop_entries(variables, defs[config]['vars'])",
            "            origin = 'var: %s' % origin",
            "",
            "        # env vars are next precedence",
            "        if value is None and defs[config].get('env'):",
            "            value, origin = self._loop_entries(os.environ, defs[config]['env'])",
            "            origin = 'env: %s' % origin",
            "",
            "        # try config file entries next, if we have one",
            "        if value is None and cfile is not None:",
            "            ftype = get_config_type(cfile)",
            "            if ftype and defs[config].get(ftype):",
            "                if ftype == 'ini':",
            "                    # load from ini config",
            "                    try:  # FIXME: generaelize _loop_entries to allow for files also, most of this code is dupe",
            "                        for ini_entry in defs[config]['ini']:",
            "                            temp_value = get_ini_config_value(self._parser, ini_entry)",
            "                            if temp_value is not None:",
            "                                value = temp_value",
            "                                origin = cfile",
            "                                if 'deprecated' in ini_entry:",
            "                                    self.DEPRECATED.append(('[%s]%s' % (ini_entry['section'], ini_entry['key']), ini_entry['deprecated']))",
            "                    except Exception as e:",
            "                        sys.stderr.write(\"Error while loading ini config %s: %s\" % (cfile, to_native(e)))",
            "                elif ftype == 'yaml':",
            "                    pass  # FIXME: implement, also , break down key from defs (. notation???)",
            "                    origin = cfile",
            "",
            "        '''",
            "        # for plugins, try using existing constants, this is for backwards compatiblity",
            "        if plugin_name and defs[config].get('constants'):",
            "            value, origin = self._loop_entries(self.data, defs[config]['constants'])",
            "            origin = 'constant: %s' % origin",
            "        '''",
            "",
            "        # set default if we got here w/o a value",
            "        if value is None:",
            "            value = defs[config].get('default')",
            "            origin = 'default'",
            "            # skip typing as this is a temlated default that will be resolved later in constants, which has needed vars",
            "            if plugin_type is None and isinstance(value, string_types) and (value.startswith('{{') and value.endswith('}}')):",
            "                return value, origin",
            "",
            "        # ensure correct type",
            "        try:",
            "            value = ensure_type(value, defs[config].get('type'), origin=origin)",
            "        except Exception as e:",
            "            self.UNABLE.append(config)",
            "",
            "        # deal with deprecation of the setting",
            "        if 'deprecated' in defs[config] and origin != 'default':",
            "            self.DEPRECATED.append((config, defs[config].get('deprecated')))",
            "",
            "        return value, origin",
            "",
            "    def initialize_plugin_configuration_definitions(self, plugin_type, name, defs):",
            "",
            "        if plugin_type not in self._plugins:",
            "            self._plugins[plugin_type] = {}",
            "",
            "        self._plugins[plugin_type][name] = defs",
            "",
            "    def update_config_data(self, defs=None, configfile=None):",
            "        ''' really: update constants '''",
            "",
            "        if defs is None:",
            "            defs = self._base_defs",
            "",
            "        if configfile is None:",
            "            configfile = self._config_file",
            "",
            "        if not isinstance(defs, dict):",
            "            raise AnsibleOptionsError(\"Invalid configuration definition type: %s for %s\" % (type(defs), defs))",
            "",
            "        # update the constant for config file",
            "        self.data.update_setting(Setting('CONFIG_FILE', configfile, '', 'string'))",
            "",
            "        origin = None",
            "        # env and config defs can have several entries, ordered in list from lowest to highest precedence",
            "        for config in defs:",
            "            if not isinstance(defs[config], dict):",
            "                raise AnsibleOptionsError(\"Invalid configuration definition '%s': type is %s\" % (to_native(config), type(defs[config])))",
            "",
            "            # get value and origin",
            "            value, origin = self.get_config_value_and_origin(config, configfile)",
            "",
            "            # set the constant",
            "            self.data.update_setting(Setting(config, value, origin, defs[config].get('type', 'string')))"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2017 Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "# Make coding more python3-ish",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import os",
            "import sys",
            "import stat",
            "import tempfile",
            "import yaml",
            "",
            "from collections import namedtuple",
            "",
            "from ansible.config.data import ConfigData",
            "from ansible.errors import AnsibleOptionsError, AnsibleError",
            "from ansible.module_utils.six import string_types",
            "from ansible.module_utils.six.moves import configparser",
            "from ansible.module_utils._text import to_text, to_bytes, to_native",
            "from ansible.module_utils.parsing.convert_bool import boolean",
            "from ansible.parsing.quoting import unquote",
            "from ansible.utils.path import unfrackpath",
            "from ansible.utils.path import makedirs_safe",
            "",
            "Plugin = namedtuple('Plugin', 'name type')",
            "Setting = namedtuple('Setting', 'name value origin type')",
            "",
            "",
            "# FIXME: see if we can unify in module_utils with similar function used by argspec",
            "def ensure_type(value, value_type, origin=None):",
            "    ''' return a configuration variable with casting",
            "    :arg value: The value to ensure correct typing of",
            "    :kwarg value_type: The type of the value.  This can be any of the following strings:",
            "        :boolean: sets the value to a True or False value",
            "        :integer: Sets the value to an integer or raises a ValueType error",
            "        :float: Sets the value to a float or raises a ValueType error",
            "        :list: Treats the value as a comma separated list.  Split the value",
            "            and return it as a python list.",
            "        :none: Sets the value to None",
            "        :path: Expands any environment variables and tilde's in the value.",
            "        :tmp_path: Create a unique temporary directory inside of the directory",
            "            specified by value and return its path.",
            "        :pathlist: Treat the value as a typical PATH string.  (On POSIX, this",
            "            means colon separated strings.)  Split the value and then expand",
            "            each part for environment variables and tildes.",
            "    '''",
            "",
            "    basedir = None",
            "    if origin and os.path.isabs(origin) and os.path.exists(origin):",
            "        basedir = origin",
            "",
            "    if value_type:",
            "        value_type = value_type.lower()",
            "",
            "    if value_type in ('boolean', 'bool'):",
            "        value = boolean(value, strict=False)",
            "",
            "    elif value:",
            "        if value_type in ('integer', 'int'):",
            "            value = int(value)",
            "",
            "        elif value_type == 'float':",
            "            value = float(value)",
            "",
            "        elif value_type == 'list':",
            "            if isinstance(value, string_types):",
            "                value = [x.strip() for x in value.split(',')]",
            "",
            "        elif value_type == 'none':",
            "            if value == \"None\":",
            "                value = None",
            "",
            "        elif value_type == 'path':",
            "            value = resolve_path(value, basedir=basedir)",
            "",
            "        elif value_type in ('tmp', 'temppath', 'tmppath'):",
            "            value = resolve_path(value, basedir=basedir)",
            "            if not os.path.exists(value):",
            "                makedirs_safe(value, 0o700)",
            "            prefix = 'ansible-local-%s' % os.getpid()",
            "            value = tempfile.mkdtemp(prefix=prefix, dir=value)",
            "",
            "        elif value_type == 'pathspec':",
            "            if isinstance(value, string_types):",
            "                value = value.split(os.pathsep)",
            "            value = [resolve_path(x, basedir=basedir) for x in value]",
            "",
            "        elif value_type == 'pathlist':",
            "            if isinstance(value, string_types):",
            "                value = value.split(',')",
            "            value = [resolve_path(x, basedir=basedir) for x in value]",
            "",
            "        # defaults to string types",
            "        elif isinstance(value, string_types):",
            "            value = unquote(value)",
            "",
            "    return to_text(value, errors='surrogate_or_strict', nonstring='passthru')",
            "",
            "",
            "# FIXME: see if this can live in utils/path",
            "def resolve_path(path, basedir=None):",
            "    ''' resolve relative or 'varaible' paths '''",
            "    if '{{CWD}}' in path:  # allow users to force CWD using 'magic' {{CWD}}",
            "        path = path.replace('{{CWD}}', os.getcwd())",
            "",
            "    return unfrackpath(path, follow=False, basedir=basedir)",
            "",
            "",
            "# FIXME: generic file type?",
            "def get_config_type(cfile):",
            "",
            "    ftype = None",
            "    if cfile is not None:",
            "        ext = os.path.splitext(cfile)[-1]",
            "        if ext in ('.ini', '.cfg'):",
            "            ftype = 'ini'",
            "        elif ext in ('.yaml', '.yml'):",
            "            ftype = 'yaml'",
            "        else:",
            "            raise AnsibleOptionsError(\"Unsupported configuration file extension for %s: %s\" % (cfile, to_native(ext)))",
            "",
            "    return ftype",
            "",
            "",
            "# FIXME: can move to module_utils for use for ini plugins also?",
            "def get_ini_config_value(p, entry):",
            "    ''' returns the value of last ini entry found '''",
            "    value = None",
            "    if p is not None:",
            "        try:",
            "            value = p.get(entry.get('section', 'defaults'), entry.get('key', ''), raw=True)",
            "        except:  # FIXME: actually report issues here",
            "            pass",
            "    return value",
            "",
            "",
            "def find_ini_config_file(warnings=None):",
            "    ''' Load INI Config File order(first found is used): ENV, CWD, HOME, /etc/ansible '''",
            "    # FIXME: eventually deprecate ini configs",
            "",
            "    path0 = os.getenv(\"ANSIBLE_CONFIG\", None)",
            "    if path0 is not None:",
            "        path0 = unfrackpath(path0, follow=False)",
            "        if os.path.isdir(path0):",
            "            path0 += \"/ansible.cfg\"",
            "    try:",
            "        path1 = os.getcwd()",
            "        perms1 = os.stat(path1)",
            "        if perms1.st_mode & stat.S_IWOTH:",
            "            if warnings is not None:",
            "                warnings.add(\"Ansible is in a world writable directory (%s), ignoring it as an ansible.cfg source.\" % to_text(path1))",
            "            path1 = None",
            "        else:",
            "            path1 += \"/ansible.cfg\"",
            "    except OSError:",
            "        path1 = None",
            "    path2 = unfrackpath(\"~/.ansible.cfg\", follow=False)",
            "    path3 = \"/etc/ansible/ansible.cfg\"",
            "",
            "    for path in [path0, path1, path2, path3]:",
            "        if path is not None and os.path.exists(path):",
            "            break",
            "    else:",
            "        path = None",
            "",
            "    return path",
            "",
            "",
            "class ConfigManager(object):",
            "",
            "    UNABLE = []",
            "    DEPRECATED = []",
            "    WARNINGS = set()",
            "",
            "    def __init__(self, conf_file=None):",
            "",
            "        self._base_defs = {}",
            "        self._plugins = {}",
            "        self._parser = None",
            "",
            "        self._config_file = conf_file",
            "        self.data = ConfigData()",
            "",
            "        # FIXME: make dynamic? scan for more? make it's own method?",
            "        # Create configuration definitions from source",
            "        bconfig_def = to_bytes('%s/base.yml' % os.path.dirname(__file__))",
            "        if os.path.exists(bconfig_def):",
            "            with open(bconfig_def, 'rb') as config_def:",
            "                self._base_defs = yaml.safe_load(config_def)",
            "        else:",
            "            raise AnsibleError(\"Missing base configuration definition file (bad install?): %s\" % to_native(bconfig_def))",
            "",
            "        if self._config_file is None:",
            "            # set config using ini",
            "            self._config_file = find_ini_config_file(self.WARNINGS)",
            "",
            "        if self._config_file:",
            "            if os.path.exists(self._config_file):",
            "                # initialize parser and read config",
            "                self._parse_config_file()",
            "",
            "        # update constants",
            "        self.update_config_data()",
            "",
            "    def _parse_config_file(self, cfile=None):",
            "        ''' return flat configuration settings from file(s) '''",
            "        # TODO: take list of files with merge/nomerge",
            "",
            "        if cfile is None:",
            "            cfile = self._config_file",
            "",
            "        ftype = get_config_type(cfile)",
            "        if cfile is not None:",
            "            if ftype == 'ini':",
            "                self._parser = configparser.ConfigParser()",
            "                try:",
            "                    self._parser.read(cfile)",
            "                except configparser.Error as e:",
            "                    raise AnsibleOptionsError(\"Error reading config file (%s): %s\" % (cfile, to_native(e)))",
            "            # FIXME: this should eventually handle yaml config files",
            "            #elif ftype == 'yaml':",
            "            #    with open(cfile, 'rb') as config_stream:",
            "            #        self._parser = yaml.safe_load(config_stream)",
            "            else:",
            "                raise AnsibleOptionsError(\"Unsupported configuration file type: %s\" % to_native(ftype))",
            "",
            "    def _find_yaml_config_files(self):",
            "        ''' Load YAML Config Files in order, check merge flags, keep origin of settings'''",
            "        pass",
            "",
            "    def get_plugin_options(self, plugin_type, name, variables=None):",
            "",
            "        options = {}",
            "        defs = self.get_configuration_definitions(plugin_type, name)",
            "        for option in defs:",
            "            options[option] = self.get_config_value(option, plugin_type=plugin_type, plugin_name=name, variables=variables)",
            "",
            "        return options",
            "",
            "    def get_configuration_definitions(self, plugin_type=None, name=None):",
            "        ''' just list the possible settings, either base or for specific plugins or plugin '''",
            "",
            "        ret = {}",
            "        if plugin_type is None:",
            "            ret = self._base_defs",
            "        elif name is None:",
            "            ret = self._plugins.get(plugin_type, {})",
            "        else:",
            "            ret = self._plugins.get(plugin_type, {}).get(name, {})",
            "",
            "        return ret",
            "",
            "    def _loop_entries(self, container, entry_list):",
            "        ''' repeat code for value entry assignment '''",
            "",
            "        value = None",
            "        origin = None",
            "        for entry in entry_list:",
            "            name = entry.get('name')",
            "            temp_value = container.get(name, None)",
            "            if temp_value is not None:  # only set if env var is defined",
            "                value = temp_value",
            "                origin = name",
            "",
            "                # deal with deprecation of setting source, if used",
            "                if 'deprecated' in entry:",
            "                    self.DEPRECATED.append((entry['name'], entry['deprecated']))",
            "",
            "        return value, origin",
            "",
            "    def get_config_value(self, config, cfile=None, plugin_type=None, plugin_name=None, variables=None):",
            "        ''' wrapper '''",
            "        value, _drop = self.get_config_value_and_origin(config, cfile=cfile, plugin_type=plugin_type, plugin_name=plugin_name, variables=variables)",
            "        return value",
            "",
            "    def get_config_value_and_origin(self, config, cfile=None, plugin_type=None, plugin_name=None, variables=None):",
            "        ''' Given a config key figure out the actual value and report on the origin of the settings '''",
            "",
            "        if cfile is None:",
            "            cfile = self._config_file",
            "",
            "        # Note: sources that are lists listed in low to high precedence (last one wins)",
            "        value = None",
            "        defs = {}",
            "        if plugin_type is None:",
            "            defs = self._base_defs",
            "        elif plugin_name is None:",
            "            defs = self._plugins[plugin_type]",
            "        else:",
            "            defs = self._plugins[plugin_type][plugin_name]",
            "",
            "        # Use 'variable overrides' if present, highest precedence, but only present when querying running play",
            "        if variables:",
            "            value, origin = self._loop_entries(variables, defs[config]['vars'])",
            "            origin = 'var: %s' % origin",
            "",
            "        # env vars are next precedence",
            "        if value is None and defs[config].get('env'):",
            "            value, origin = self._loop_entries(os.environ, defs[config]['env'])",
            "            origin = 'env: %s' % origin",
            "",
            "        # try config file entries next, if we have one",
            "        if value is None and cfile is not None:",
            "            ftype = get_config_type(cfile)",
            "            if ftype and defs[config].get(ftype):",
            "                if ftype == 'ini':",
            "                    # load from ini config",
            "                    try:  # FIXME: generaelize _loop_entries to allow for files also, most of this code is dupe",
            "                        for ini_entry in defs[config]['ini']:",
            "                            temp_value = get_ini_config_value(self._parser, ini_entry)",
            "                            if temp_value is not None:",
            "                                value = temp_value",
            "                                origin = cfile",
            "                                if 'deprecated' in ini_entry:",
            "                                    self.DEPRECATED.append(('[%s]%s' % (ini_entry['section'], ini_entry['key']), ini_entry['deprecated']))",
            "                    except Exception as e:",
            "                        sys.stderr.write(\"Error while loading ini config %s: %s\" % (cfile, to_native(e)))",
            "                elif ftype == 'yaml':",
            "                    pass  # FIXME: implement, also , break down key from defs (. notation???)",
            "                    origin = cfile",
            "",
            "        '''",
            "        # for plugins, try using existing constants, this is for backwards compatiblity",
            "        if plugin_name and defs[config].get('constants'):",
            "            value, origin = self._loop_entries(self.data, defs[config]['constants'])",
            "            origin = 'constant: %s' % origin",
            "        '''",
            "",
            "        # set default if we got here w/o a value",
            "        if value is None:",
            "            value = defs[config].get('default')",
            "            origin = 'default'",
            "            # skip typing as this is a temlated default that will be resolved later in constants, which has needed vars",
            "            if plugin_type is None and isinstance(value, string_types) and (value.startswith('{{') and value.endswith('}}')):",
            "                return value, origin",
            "",
            "        # ensure correct type",
            "        try:",
            "            value = ensure_type(value, defs[config].get('type'), origin=origin)",
            "        except Exception as e:",
            "            self.UNABLE.append(config)",
            "",
            "        # deal with deprecation of the setting",
            "        if 'deprecated' in defs[config] and origin != 'default':",
            "            self.DEPRECATED.append((config, defs[config].get('deprecated')))",
            "",
            "        return value, origin",
            "",
            "    def initialize_plugin_configuration_definitions(self, plugin_type, name, defs):",
            "",
            "        if plugin_type not in self._plugins:",
            "            self._plugins[plugin_type] = {}",
            "",
            "        self._plugins[plugin_type][name] = defs",
            "",
            "    def update_config_data(self, defs=None, configfile=None):",
            "        ''' really: update constants '''",
            "",
            "        if defs is None:",
            "            defs = self._base_defs",
            "",
            "        if configfile is None:",
            "            configfile = self._config_file",
            "",
            "        if not isinstance(defs, dict):",
            "            raise AnsibleOptionsError(\"Invalid configuration definition type: %s for %s\" % (type(defs), defs))",
            "",
            "        # update the constant for config file",
            "        self.data.update_setting(Setting('CONFIG_FILE', configfile, '', 'string'))",
            "",
            "        origin = None",
            "        # env and config defs can have several entries, ordered in list from lowest to highest precedence",
            "        for config in defs:",
            "            if not isinstance(defs[config], dict):",
            "                raise AnsibleOptionsError(\"Invalid configuration definition '%s': type is %s\" % (to_native(config), type(defs[config])))",
            "",
            "            # get value and origin",
            "            value, origin = self.get_config_value_and_origin(config, configfile)",
            "",
            "            # set the constant",
            "            self.data.update_setting(Setting(config, value, origin, defs[config].get('type', 'string')))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "137": [
                "find_ini_config_file"
            ],
            "147": [
                "find_ini_config_file"
            ],
            "187": [
                "ConfigManager",
                "__init__"
            ]
        },
        "addLocation": []
    },
    "lib/ansible/constants.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from ansible.config.manager import ConfigManager, ensure_type, get_ini_config_value"
            },
            "1": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+def _warning(msg):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+    ''' display is not guaranteed here, nor it being the full class, but try anyways, fallback to sys.stderr.write '''"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+    try:"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+        from __main__ import display"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+        display.warning(msg)"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+    except:"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+        import sys"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+        sys.stderr.write(' [WARNING] %s\\n' % (msg))"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " def _deprecated(msg):"
            },
            "14": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "     ''' display is not guaranteed here, nor it being the full class, but try anyways, fallback to sys.stderr.write '''"
            },
            "15": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     try:"
            },
            "16": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "         value = ensure_type(value, setting.name)"
            },
            "17": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 133,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "     set_constant(setting.name, value)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+for warn in config.WARNINGS:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+    _warning(warn)"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "# Copyright (c) 2017 Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "# Make coding more python3-ish",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import os  # used to set lang and for backwards compat get_config",
            "",
            "from ast import literal_eval",
            "from jinja2 import Template",
            "from string import ascii_letters, digits",
            "",
            "from ansible.module_utils._text import to_text",
            "from ansible.module_utils.parsing.convert_bool import boolean, BOOLEANS_TRUE",
            "from ansible.module_utils.six import string_types",
            "from ansible.config.manager import ConfigManager, ensure_type, get_ini_config_value",
            "",
            "",
            "def _deprecated(msg):",
            "    ''' display is not guaranteed here, nor it being the full class, but try anyways, fallback to sys.stderr.write '''",
            "    try:",
            "        from __main__ import display",
            "        display.deprecated(msg, version='2.8')",
            "    except:",
            "        import sys",
            "        sys.stderr.write('[DEPRECATED] %s, to be removed in 2.8' % msg)",
            "",
            "",
            "def mk_boolean(value):",
            "    ''' moved to module_utils'''",
            "    _deprecated('ansible.constants.mk_boolean() is deprecated.  Use ansible.module_utils.parsing.convert_bool.boolean() instead')",
            "    return boolean(value, strict=False)",
            "",
            "",
            "def get_config(parser, section, key, env_var, default_value, value_type=None, expand_relative_paths=False):",
            "    ''' kept for backwarsd compatibility, but deprecated '''",
            "    _deprecated('ansible.constants.get_config() is deprecated. There is new config API, see porting docs.')",
            "",
            "    value = None",
            "    # small reconstruction of the old code env/ini/default",
            "    value = os.environ.get(env_var, None)",
            "    if value is None:",
            "        try:",
            "            value = get_ini_config_value(parser, {'key': key, 'section': section})",
            "        except:",
            "            pass",
            "    if value is None:",
            "        value = default_value",
            "",
            "    value = ensure_type(value, value_type)",
            "",
            "    return value",
            "",
            "",
            "def set_constant(name, value, export=vars()):",
            "    ''' sets constants and returns resolved options dict '''",
            "    export[name] = value",
            "",
            "",
            "### CONSTANTS ### yes, actual ones",
            "BECOME_METHODS = ['sudo', 'su', 'pbrun', 'pfexec', 'doas', 'dzdo', 'ksu', 'runas', 'pmrun']",
            "BECOME_ERROR_STRINGS = {",
            "    'sudo': 'Sorry, try again.',",
            "    'su': 'Authentication failure',",
            "    'pbrun': '',",
            "    'pfexec': '',",
            "    'doas': 'Permission denied',",
            "    'dzdo': '',",
            "    'ksu': 'Password incorrect',",
            "    'pmrun': 'You are not permitted to run this command'",
            "}  # FIXME: deal with i18n",
            "BECOME_MISSING_STRINGS = {",
            "    'sudo': 'sorry, a password is required to run sudo',",
            "    'su': '',",
            "    'pbrun': '',",
            "    'pfexec': '',",
            "    'doas': 'Authorization required',",
            "    'dzdo': '',",
            "    'ksu': 'No password given',",
            "    'pmrun': ''",
            "}  # FIXME: deal with i18n",
            "BLACKLIST_EXTS = ('.pyc', '.pyo', '.swp', '.bak', '~', '.rpm', '.md', '.txt')",
            "BOOL_TRUE = BOOLEANS_TRUE",
            "CONTROLER_LANG = os.getenv('LANG', 'en_US.UTF-8')",
            "DEFAULT_BECOME_PASS = None",
            "DEFAULT_PASSWORD_CHARS = to_text(ascii_letters + digits + \".,:-_\", errors='strict')  # characters included in auto-generated passwords",
            "DEFAULT_SUDO_PASS = None",
            "DEFAULT_REMOTE_PASS = None",
            "DEFAULT_SUBSET = None",
            "DEFAULT_SU_PASS = None",
            "IGNORE_FILES = [\"COPYING\", \"CONTRIBUTING\", \"LICENSE\", \"README\", \"VERSION\", \"GUIDELINES\"]  # ignore during module search",
            "INTERNAL_RESULT_KEYS = ['add_host', 'add_group']",
            "LOCALHOST = frozenset(['127.0.0.1', 'localhost', '::1'])",
            "MODULE_REQUIRE_ARGS = ['command', 'win_command', 'shell', 'win_shell', 'raw', 'script']",
            "MODULE_NO_JSON = ['command', 'win_command', 'shell', 'win_shell', 'raw']",
            "RESTRICTED_RESULT_KEYS = ['ansible_rsync_path', 'ansible_playbook_python']",
            "TREE_DIR = None",
            "VAULT_VERSION_MIN = 1.0",
            "VAULT_VERSION_MAX = 1.0",
            "",
            "### POPULATE SETTINGS FROM CONFIG ###",
            "config = ConfigManager()",
            "",
            "# Generate constants from config",
            "for setting in config.data.get_settings():",
            "",
            "    value = setting.value",
            "    if setting.origin == 'default' and \\",
            "       isinstance(setting.value, string_types) and \\",
            "       (setting.value.startswith('{{') and setting.value.endswith('}}')):",
            "        try:",
            "            t = Template(setting.value)",
            "            value = t.render(vars())",
            "            try:",
            "                value = literal_eval(value)",
            "            except ValueError:",
            "                pass  # not a python data structure",
            "        except:",
            "            pass # not templatable",
            "        value = ensure_type(value, setting.name)",
            "",
            "    set_constant(setting.name, value)"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>",
            "# Copyright (c) 2017 Ansible Project",
            "# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)",
            "",
            "# Make coding more python3-ish",
            "from __future__ import (absolute_import, division, print_function)",
            "__metaclass__ = type",
            "",
            "import os  # used to set lang and for backwards compat get_config",
            "",
            "from ast import literal_eval",
            "from jinja2 import Template",
            "from string import ascii_letters, digits",
            "",
            "from ansible.module_utils._text import to_text",
            "from ansible.module_utils.parsing.convert_bool import boolean, BOOLEANS_TRUE",
            "from ansible.module_utils.six import string_types",
            "from ansible.config.manager import ConfigManager, ensure_type, get_ini_config_value",
            "",
            "",
            "def _warning(msg):",
            "    ''' display is not guaranteed here, nor it being the full class, but try anyways, fallback to sys.stderr.write '''",
            "    try:",
            "        from __main__ import display",
            "        display.warning(msg)",
            "    except:",
            "        import sys",
            "        sys.stderr.write(' [WARNING] %s\\n' % (msg))",
            "",
            "",
            "def _deprecated(msg):",
            "    ''' display is not guaranteed here, nor it being the full class, but try anyways, fallback to sys.stderr.write '''",
            "    try:",
            "        from __main__ import display",
            "        display.deprecated(msg, version='2.8')",
            "    except:",
            "        import sys",
            "        sys.stderr.write('[DEPRECATED] %s, to be removed in 2.8' % msg)",
            "",
            "",
            "def mk_boolean(value):",
            "    ''' moved to module_utils'''",
            "    _deprecated('ansible.constants.mk_boolean() is deprecated.  Use ansible.module_utils.parsing.convert_bool.boolean() instead')",
            "    return boolean(value, strict=False)",
            "",
            "",
            "def get_config(parser, section, key, env_var, default_value, value_type=None, expand_relative_paths=False):",
            "    ''' kept for backwarsd compatibility, but deprecated '''",
            "    _deprecated('ansible.constants.get_config() is deprecated. There is new config API, see porting docs.')",
            "",
            "    value = None",
            "    # small reconstruction of the old code env/ini/default",
            "    value = os.environ.get(env_var, None)",
            "    if value is None:",
            "        try:",
            "            value = get_ini_config_value(parser, {'key': key, 'section': section})",
            "        except:",
            "            pass",
            "    if value is None:",
            "        value = default_value",
            "",
            "    value = ensure_type(value, value_type)",
            "",
            "    return value",
            "",
            "",
            "def set_constant(name, value, export=vars()):",
            "    ''' sets constants and returns resolved options dict '''",
            "    export[name] = value",
            "",
            "",
            "### CONSTANTS ### yes, actual ones",
            "BECOME_METHODS = ['sudo', 'su', 'pbrun', 'pfexec', 'doas', 'dzdo', 'ksu', 'runas', 'pmrun']",
            "BECOME_ERROR_STRINGS = {",
            "    'sudo': 'Sorry, try again.',",
            "    'su': 'Authentication failure',",
            "    'pbrun': '',",
            "    'pfexec': '',",
            "    'doas': 'Permission denied',",
            "    'dzdo': '',",
            "    'ksu': 'Password incorrect',",
            "    'pmrun': 'You are not permitted to run this command'",
            "}  # FIXME: deal with i18n",
            "BECOME_MISSING_STRINGS = {",
            "    'sudo': 'sorry, a password is required to run sudo',",
            "    'su': '',",
            "    'pbrun': '',",
            "    'pfexec': '',",
            "    'doas': 'Authorization required',",
            "    'dzdo': '',",
            "    'ksu': 'No password given',",
            "    'pmrun': ''",
            "}  # FIXME: deal with i18n",
            "BLACKLIST_EXTS = ('.pyc', '.pyo', '.swp', '.bak', '~', '.rpm', '.md', '.txt')",
            "BOOL_TRUE = BOOLEANS_TRUE",
            "CONTROLER_LANG = os.getenv('LANG', 'en_US.UTF-8')",
            "DEFAULT_BECOME_PASS = None",
            "DEFAULT_PASSWORD_CHARS = to_text(ascii_letters + digits + \".,:-_\", errors='strict')  # characters included in auto-generated passwords",
            "DEFAULT_SUDO_PASS = None",
            "DEFAULT_REMOTE_PASS = None",
            "DEFAULT_SUBSET = None",
            "DEFAULT_SU_PASS = None",
            "IGNORE_FILES = [\"COPYING\", \"CONTRIBUTING\", \"LICENSE\", \"README\", \"VERSION\", \"GUIDELINES\"]  # ignore during module search",
            "INTERNAL_RESULT_KEYS = ['add_host', 'add_group']",
            "LOCALHOST = frozenset(['127.0.0.1', 'localhost', '::1'])",
            "MODULE_REQUIRE_ARGS = ['command', 'win_command', 'shell', 'win_shell', 'raw', 'script']",
            "MODULE_NO_JSON = ['command', 'win_command', 'shell', 'win_shell', 'raw']",
            "RESTRICTED_RESULT_KEYS = ['ansible_rsync_path', 'ansible_playbook_python']",
            "TREE_DIR = None",
            "VAULT_VERSION_MIN = 1.0",
            "VAULT_VERSION_MAX = 1.0",
            "",
            "### POPULATE SETTINGS FROM CONFIG ###",
            "config = ConfigManager()",
            "",
            "# Generate constants from config",
            "for setting in config.data.get_settings():",
            "",
            "    value = setting.value",
            "    if setting.origin == 'default' and \\",
            "       isinstance(setting.value, string_types) and \\",
            "       (setting.value.startswith('{{') and setting.value.endswith('}}')):",
            "        try:",
            "            t = Template(setting.value)",
            "            value = t.render(vars())",
            "            try:",
            "                value = literal_eval(value)",
            "            except ValueError:",
            "                pass  # not a python data structure",
            "        except:",
            "            pass # not templatable",
            "        value = ensure_type(value, setting.name)",
            "",
            "    set_constant(setting.name, value)",
            "",
            "for warn in config.WARNINGS:",
            "    _warning(warn)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "lib.ansible.constants",
            "tuf.client.updater.Updater._get_target_from_targets_role"
        ]
    }
}