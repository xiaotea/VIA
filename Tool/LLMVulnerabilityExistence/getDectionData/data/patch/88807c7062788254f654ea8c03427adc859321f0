{
    "setuptools/package_index.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " \"\"\"PyPI and direct package downloading.\"\"\""
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import sys"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+import subprocess"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " import os"
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " import re"
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " import io"
            },
            "7": {
                "beforePatchRowNumber": 587,
                "afterPatchRowNumber": 588,
                "PatchRowcode": "             scheme = URL_SCHEME(spec)"
            },
            "8": {
                "beforePatchRowNumber": 588,
                "afterPatchRowNumber": 589,
                "PatchRowcode": "             if scheme:"
            },
            "9": {
                "beforePatchRowNumber": 589,
                "afterPatchRowNumber": 590,
                "PatchRowcode": "                 # It's a url, download it to tmpdir"
            },
            "10": {
                "beforePatchRowNumber": 590,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                found = self._download_url(scheme.group(1), spec, tmpdir)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 591,
                "PatchRowcode": "+                found = self._download_url(spec, tmpdir)"
            },
            "12": {
                "beforePatchRowNumber": 591,
                "afterPatchRowNumber": 592,
                "PatchRowcode": "                 base, fragment = egg_info_for_url(spec)"
            },
            "13": {
                "beforePatchRowNumber": 592,
                "afterPatchRowNumber": 593,
                "PatchRowcode": "                 if base.endswith('.py'):"
            },
            "14": {
                "beforePatchRowNumber": 593,
                "afterPatchRowNumber": 594,
                "PatchRowcode": "                     found = self.gen_setup(found, fragment, tmpdir)"
            },
            "15": {
                "beforePatchRowNumber": 816,
                "afterPatchRowNumber": 817,
                "PatchRowcode": "             else:"
            },
            "16": {
                "beforePatchRowNumber": 817,
                "afterPatchRowNumber": 818,
                "PatchRowcode": "                 raise DistutilsError(\"Download error for %s: %s\" % (url, v)) from v"
            },
            "17": {
                "beforePatchRowNumber": 818,
                "afterPatchRowNumber": 819,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 819,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _download_url(self, scheme, url, tmpdir):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 820,
                "PatchRowcode": "+    def _download_url(self, url, tmpdir):"
            },
            "20": {
                "beforePatchRowNumber": 820,
                "afterPatchRowNumber": 821,
                "PatchRowcode": "         # Determine download filename"
            },
            "21": {
                "beforePatchRowNumber": 821,
                "afterPatchRowNumber": 822,
                "PatchRowcode": "         #"
            },
            "22": {
                "beforePatchRowNumber": 822,
                "afterPatchRowNumber": 823,
                "PatchRowcode": "         name, fragment = egg_info_for_url(url)"
            },
            "23": {
                "beforePatchRowNumber": 831,
                "afterPatchRowNumber": 832,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 832,
                "afterPatchRowNumber": 833,
                "PatchRowcode": "         filename = os.path.join(tmpdir, name)"
            },
            "25": {
                "beforePatchRowNumber": 833,
                "afterPatchRowNumber": 834,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 834,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Download the file"
            },
            "27": {
                "beforePatchRowNumber": 835,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        #"
            },
            "28": {
                "beforePatchRowNumber": 836,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if scheme == 'svn' or scheme.startswith('svn+'):"
            },
            "29": {
                "beforePatchRowNumber": 837,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return self._download_svn(url, filename)"
            },
            "30": {
                "beforePatchRowNumber": 838,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif scheme == 'git' or scheme.startswith('git+'):"
            },
            "31": {
                "beforePatchRowNumber": 839,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return self._download_git(url, filename)"
            },
            "32": {
                "beforePatchRowNumber": 840,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif scheme.startswith('hg+'):"
            },
            "33": {
                "beforePatchRowNumber": 841,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return self._download_hg(url, filename)"
            },
            "34": {
                "beforePatchRowNumber": 842,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif scheme == 'file':"
            },
            "35": {
                "beforePatchRowNumber": 843,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return urllib.request.url2pathname(urllib.parse.urlparse(url)[2])"
            },
            "36": {
                "beforePatchRowNumber": 844,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        else:"
            },
            "37": {
                "beforePatchRowNumber": 845,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.url_ok(url, True)  # raises error if not allowed"
            },
            "38": {
                "beforePatchRowNumber": 846,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return self._attempt_download(url, filename)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 835,
                "PatchRowcode": "+        return self._download_vcs(url, filename) or self._download_other(url, filename)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 836,
                "PatchRowcode": "+"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 837,
                "PatchRowcode": "+    @staticmethod"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 838,
                "PatchRowcode": "+    def _resolve_vcs(url):"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 839,
                "PatchRowcode": "+        \"\"\""
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 840,
                "PatchRowcode": "+        >>> rvcs = PackageIndex._resolve_vcs"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 841,
                "PatchRowcode": "+        >>> rvcs('git+http://foo/bar')"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 842,
                "PatchRowcode": "+        'git'"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 843,
                "PatchRowcode": "+        >>> rvcs('hg+https://foo/bar')"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 844,
                "PatchRowcode": "+        'hg'"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 845,
                "PatchRowcode": "+        >>> rvcs('git:myhost')"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 846,
                "PatchRowcode": "+        'git'"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 847,
                "PatchRowcode": "+        >>> rvcs('hg:myhost')"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 848,
                "PatchRowcode": "+        >>> rvcs('http://foo/bar')"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 849,
                "PatchRowcode": "+        \"\"\""
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 850,
                "PatchRowcode": "+        scheme = urllib.parse.urlsplit(url).scheme"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 851,
                "PatchRowcode": "+        pre, sep, post = scheme.partition('+')"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 852,
                "PatchRowcode": "+        # svn and git have their own protocol; hg does not"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 853,
                "PatchRowcode": "+        allowed = set(['svn', 'git'] + ['hg'] * bool(sep))"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 854,
                "PatchRowcode": "+        return next(iter({pre} & allowed), None)"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 855,
                "PatchRowcode": "+"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 856,
                "PatchRowcode": "+    def _download_vcs(self, url, spec_filename):"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 857,
                "PatchRowcode": "+        vcs = self._resolve_vcs(url)"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 858,
                "PatchRowcode": "+        if not vcs:"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 859,
                "PatchRowcode": "+            return"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 860,
                "PatchRowcode": "+        if vcs == 'svn':"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 861,
                "PatchRowcode": "+            raise DistutilsError("
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 862,
                "PatchRowcode": "+                f\"Invalid config, SVN download is not supported: {url}\""
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 863,
                "PatchRowcode": "+            )"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 864,
                "PatchRowcode": "+"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 865,
                "PatchRowcode": "+        filename, _, _ = spec_filename.partition('#')"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 866,
                "PatchRowcode": "+        url, rev = self._vcs_split_rev_from_url(url)"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 867,
                "PatchRowcode": "+"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 868,
                "PatchRowcode": "+        self.info(f\"Doing {vcs} clone from {url} to {filename}\")"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 869,
                "PatchRowcode": "+        subprocess.check_call([vcs, 'clone', '--quiet', url, filename])"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 870,
                "PatchRowcode": "+"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 871,
                "PatchRowcode": "+        co_commands = dict("
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 872,
                "PatchRowcode": "+            git=[vcs, '-C', filename, 'checkout', '--quiet', rev],"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 873,
                "PatchRowcode": "+            hg=[vcs, '--cwd', filename, 'up', '-C', '-r', rev, '-q'],"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 874,
                "PatchRowcode": "+        )"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 875,
                "PatchRowcode": "+        if rev is not None:"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 876,
                "PatchRowcode": "+            self.info(f\"Checking out {rev}\")"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 877,
                "PatchRowcode": "+            subprocess.check_call(co_commands[vcs])"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 878,
                "PatchRowcode": "+"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 879,
                "PatchRowcode": "+        return filename"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 880,
                "PatchRowcode": "+"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 881,
                "PatchRowcode": "+    def _download_other(self, url, filename):"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 882,
                "PatchRowcode": "+        scheme = urllib.parse.urlsplit(url).scheme"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 883,
                "PatchRowcode": "+        if scheme == 'file':  # pragma: no cover"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 884,
                "PatchRowcode": "+            return urllib.request.url2pathname(urllib.parse.urlparse(url).path)"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 885,
                "PatchRowcode": "+        # raise error if not allowed"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 886,
                "PatchRowcode": "+        self.url_ok(url, True)"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 887,
                "PatchRowcode": "+        return self._attempt_download(url, filename)"
            },
            "92": {
                "beforePatchRowNumber": 847,
                "afterPatchRowNumber": 888,
                "PatchRowcode": " "
            },
            "93": {
                "beforePatchRowNumber": 848,
                "afterPatchRowNumber": 889,
                "PatchRowcode": "     def scan_url(self, url):"
            },
            "94": {
                "beforePatchRowNumber": 849,
                "afterPatchRowNumber": 890,
                "PatchRowcode": "         self.process_url(url, True)"
            },
            "95": {
                "beforePatchRowNumber": 859,
                "afterPatchRowNumber": 900,
                "PatchRowcode": "         os.unlink(filename)"
            },
            "96": {
                "beforePatchRowNumber": 860,
                "afterPatchRowNumber": 901,
                "PatchRowcode": "         raise DistutilsError(f\"Unexpected HTML page found at {url}\")"
            },
            "97": {
                "beforePatchRowNumber": 861,
                "afterPatchRowNumber": 902,
                "PatchRowcode": " "
            },
            "98": {
                "beforePatchRowNumber": 862,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _download_svn(self, url, _filename):"
            },
            "99": {
                "beforePatchRowNumber": 863,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise DistutilsError(f\"Invalid config, SVN download is not supported: {url}\")"
            },
            "100": {
                "beforePatchRowNumber": 864,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "101": {
                "beforePatchRowNumber": 865,
                "afterPatchRowNumber": 903,
                "PatchRowcode": "     @staticmethod"
            },
            "102": {
                "beforePatchRowNumber": 866,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _vcs_split_rev_from_url(url, pop_prefix=False):"
            },
            "103": {
                "beforePatchRowNumber": 867,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        scheme, netloc, path, query, frag = urllib.parse.urlsplit(url)"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 904,
                "PatchRowcode": "+    def _vcs_split_rev_from_url(url):"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 905,
                "PatchRowcode": "+        \"\"\""
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 906,
                "PatchRowcode": "+        Given a possible VCS URL, return a clean URL and resolved revision if any."
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 907,
                "PatchRowcode": "+"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 908,
                "PatchRowcode": "+        >>> vsrfu = PackageIndex._vcs_split_rev_from_url"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 909,
                "PatchRowcode": "+        >>> vsrfu('git+https://github.com/pypa/setuptools@v69.0.0#egg-info=setuptools')"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 910,
                "PatchRowcode": "+        ('https://github.com/pypa/setuptools', 'v69.0.0')"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 911,
                "PatchRowcode": "+        >>> vsrfu('git+https://github.com/pypa/setuptools#egg-info=setuptools')"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 912,
                "PatchRowcode": "+        ('https://github.com/pypa/setuptools', None)"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 913,
                "PatchRowcode": "+        >>> vsrfu('http://foo/bar')"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 914,
                "PatchRowcode": "+        ('http://foo/bar', None)"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 915,
                "PatchRowcode": "+        \"\"\""
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 916,
                "PatchRowcode": "+        parts = urllib.parse.urlsplit(url)"
            },
            "117": {
                "beforePatchRowNumber": 868,
                "afterPatchRowNumber": 917,
                "PatchRowcode": " "
            },
            "118": {
                "beforePatchRowNumber": 869,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        scheme = scheme.split('+', 1)[-1]"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 918,
                "PatchRowcode": "+        clean_scheme = parts.scheme.split('+', 1)[-1]"
            },
            "120": {
                "beforePatchRowNumber": 870,
                "afterPatchRowNumber": 919,
                "PatchRowcode": " "
            },
            "121": {
                "beforePatchRowNumber": 871,
                "afterPatchRowNumber": 920,
                "PatchRowcode": "         # Some fragment identification fails"
            },
            "122": {
                "beforePatchRowNumber": 872,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        path = path.split('#', 1)[0]"
            },
            "123": {
                "beforePatchRowNumber": 873,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "124": {
                "beforePatchRowNumber": 874,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        rev = None"
            },
            "125": {
                "beforePatchRowNumber": 875,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if '@' in path:"
            },
            "126": {
                "beforePatchRowNumber": 876,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            path, rev = path.rsplit('@', 1)"
            },
            "127": {
                "beforePatchRowNumber": 877,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "128": {
                "beforePatchRowNumber": 878,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Also, discard fragment"
            },
            "129": {
                "beforePatchRowNumber": 879,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        url = urllib.parse.urlunsplit((scheme, netloc, path, query, ''))"
            },
            "130": {
                "beforePatchRowNumber": 880,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "131": {
                "beforePatchRowNumber": 881,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return url, rev"
            },
            "132": {
                "beforePatchRowNumber": 882,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "133": {
                "beforePatchRowNumber": 883,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _download_git(self, url, filename):"
            },
            "134": {
                "beforePatchRowNumber": 884,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        filename = filename.split('#', 1)[0]"
            },
            "135": {
                "beforePatchRowNumber": 885,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        url, rev = self._vcs_split_rev_from_url(url, pop_prefix=True)"
            },
            "136": {
                "beforePatchRowNumber": 886,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "137": {
                "beforePatchRowNumber": 887,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.info(\"Doing git clone from %s to %s\", url, filename)"
            },
            "138": {
                "beforePatchRowNumber": 888,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        os.system(\"git clone --quiet %s %s\" % (url, filename))"
            },
            "139": {
                "beforePatchRowNumber": 889,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "140": {
                "beforePatchRowNumber": 890,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if rev is not None:"
            },
            "141": {
                "beforePatchRowNumber": 891,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.info(\"Checking out %s\", rev)"
            },
            "142": {
                "beforePatchRowNumber": 892,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            os.system("
            },
            "143": {
                "beforePatchRowNumber": 893,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"git -C %s checkout --quiet %s\""
            },
            "144": {
                "beforePatchRowNumber": 894,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                % ("
            },
            "145": {
                "beforePatchRowNumber": 895,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    filename,"
            },
            "146": {
                "beforePatchRowNumber": 896,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    rev,"
            },
            "147": {
                "beforePatchRowNumber": 897,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                )"
            },
            "148": {
                "beforePatchRowNumber": 898,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "149": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 921,
                "PatchRowcode": "+        no_fragment_path, _, _ = parts.path.partition('#')"
            },
            "150": {
                "beforePatchRowNumber": 899,
                "afterPatchRowNumber": 922,
                "PatchRowcode": " "
            },
            "151": {
                "beforePatchRowNumber": 900,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return filename"
            },
            "152": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 923,
                "PatchRowcode": "+        pre, sep, post = no_fragment_path.rpartition('@')"
            },
            "153": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 924,
                "PatchRowcode": "+        clean_path, rev = (pre, post) if sep else (post, None)"
            },
            "154": {
                "beforePatchRowNumber": 901,
                "afterPatchRowNumber": 925,
                "PatchRowcode": " "
            },
            "155": {
                "beforePatchRowNumber": 902,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _download_hg(self, url, filename):"
            },
            "156": {
                "beforePatchRowNumber": 903,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        filename = filename.split('#', 1)[0]"
            },
            "157": {
                "beforePatchRowNumber": 904,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        url, rev = self._vcs_split_rev_from_url(url, pop_prefix=True)"
            },
            "158": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 926,
                "PatchRowcode": "+        resolved = parts._replace("
            },
            "159": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 927,
                "PatchRowcode": "+            scheme=clean_scheme,"
            },
            "160": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 928,
                "PatchRowcode": "+            path=clean_path,"
            },
            "161": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 929,
                "PatchRowcode": "+            # discard the fragment"
            },
            "162": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 930,
                "PatchRowcode": "+            fragment='',"
            },
            "163": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 931,
                "PatchRowcode": "+        ).geturl()"
            },
            "164": {
                "beforePatchRowNumber": 905,
                "afterPatchRowNumber": 932,
                "PatchRowcode": " "
            },
            "165": {
                "beforePatchRowNumber": 906,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.info(\"Doing hg clone from %s to %s\", url, filename)"
            },
            "166": {
                "beforePatchRowNumber": 907,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        os.system(\"hg clone --quiet %s %s\" % (url, filename))"
            },
            "167": {
                "beforePatchRowNumber": 908,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "168": {
                "beforePatchRowNumber": 909,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if rev is not None:"
            },
            "169": {
                "beforePatchRowNumber": 910,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.info(\"Updating to %s\", rev)"
            },
            "170": {
                "beforePatchRowNumber": 911,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            os.system("
            },
            "171": {
                "beforePatchRowNumber": 912,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                \"hg --cwd %s up -C -r %s -q\""
            },
            "172": {
                "beforePatchRowNumber": 913,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                % ("
            },
            "173": {
                "beforePatchRowNumber": 914,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    filename,"
            },
            "174": {
                "beforePatchRowNumber": 915,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    rev,"
            },
            "175": {
                "beforePatchRowNumber": 916,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                )"
            },
            "176": {
                "beforePatchRowNumber": 917,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            )"
            },
            "177": {
                "beforePatchRowNumber": 918,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "178": {
                "beforePatchRowNumber": 919,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return filename"
            },
            "179": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 933,
                "PatchRowcode": "+        return resolved, rev"
            },
            "180": {
                "beforePatchRowNumber": 920,
                "afterPatchRowNumber": 934,
                "PatchRowcode": " "
            },
            "181": {
                "beforePatchRowNumber": 921,
                "afterPatchRowNumber": 935,
                "PatchRowcode": "     def debug(self, msg, *args):"
            },
            "182": {
                "beforePatchRowNumber": 922,
                "afterPatchRowNumber": 936,
                "PatchRowcode": "         log.debug(msg, *args)"
            }
        },
        "frontPatchFile": [
            "\"\"\"PyPI and direct package downloading.\"\"\"",
            "",
            "import sys",
            "import os",
            "import re",
            "import io",
            "import shutil",
            "import socket",
            "import base64",
            "import hashlib",
            "import itertools",
            "import configparser",
            "import html",
            "import http.client",
            "import urllib.parse",
            "import urllib.request",
            "import urllib.error",
            "from functools import wraps",
            "",
            "import setuptools",
            "from pkg_resources import (",
            "    CHECKOUT_DIST,",
            "    Distribution,",
            "    BINARY_DIST,",
            "    normalize_path,",
            "    SOURCE_DIST,",
            "    Environment,",
            "    find_distributions,",
            "    safe_name,",
            "    safe_version,",
            "    to_filename,",
            "    Requirement,",
            "    DEVELOP_DIST,",
            "    EGG_DIST,",
            "    parse_version,",
            ")",
            "from distutils import log",
            "from distutils.errors import DistutilsError",
            "from fnmatch import translate",
            "from setuptools.wheel import Wheel",
            "from setuptools.extern.more_itertools import unique_everseen",
            "",
            "from .unicode_utils import _read_utf8_with_fallback, _cfg_read_utf8_with_fallback",
            "",
            "",
            "EGG_FRAGMENT = re.compile(r'^egg=([-A-Za-z0-9_.+!]+)$')",
            "HREF = re.compile(r\"\"\"href\\s*=\\s*['\"]?([^'\"> ]+)\"\"\", re.I)",
            "PYPI_MD5 = re.compile(",
            "    r'<a href=\"([^\"#]+)\">([^<]+)</a>\\n\\s+\\(<a (?:title=\"MD5 hash\"\\n\\s+)'",
            "    r'href=\"[^?]+\\?:action=show_md5&amp;digest=([0-9a-f]{32})\">md5</a>\\)'",
            ")",
            "URL_SCHEME = re.compile('([-+.a-z0-9]{2,}):', re.I).match",
            "EXTENSIONS = \".tar.gz .tar.bz2 .tar .zip .tgz\".split()",
            "",
            "__all__ = [",
            "    'PackageIndex',",
            "    'distros_for_url',",
            "    'parse_bdist_wininst',",
            "    'interpret_distro_name',",
            "]",
            "",
            "_SOCKET_TIMEOUT = 15",
            "",
            "_tmpl = \"setuptools/{setuptools.__version__} Python-urllib/{py_major}\"",
            "user_agent = _tmpl.format(",
            "    py_major='{}.{}'.format(*sys.version_info), setuptools=setuptools",
            ")",
            "",
            "",
            "def parse_requirement_arg(spec):",
            "    try:",
            "        return Requirement.parse(spec)",
            "    except ValueError as e:",
            "        raise DistutilsError(",
            "            \"Not a URL, existing file, or requirement spec: %r\" % (spec,)",
            "        ) from e",
            "",
            "",
            "def parse_bdist_wininst(name):",
            "    \"\"\"Return (base,pyversion) or (None,None) for possible .exe name\"\"\"",
            "",
            "    lower = name.lower()",
            "    base, py_ver, plat = None, None, None",
            "",
            "    if lower.endswith('.exe'):",
            "        if lower.endswith('.win32.exe'):",
            "            base = name[:-10]",
            "            plat = 'win32'",
            "        elif lower.startswith('.win32-py', -16):",
            "            py_ver = name[-7:-4]",
            "            base = name[:-16]",
            "            plat = 'win32'",
            "        elif lower.endswith('.win-amd64.exe'):",
            "            base = name[:-14]",
            "            plat = 'win-amd64'",
            "        elif lower.startswith('.win-amd64-py', -20):",
            "            py_ver = name[-7:-4]",
            "            base = name[:-20]",
            "            plat = 'win-amd64'",
            "    return base, py_ver, plat",
            "",
            "",
            "def egg_info_for_url(url):",
            "    parts = urllib.parse.urlparse(url)",
            "    scheme, server, path, parameters, query, fragment = parts",
            "    base = urllib.parse.unquote(path.split('/')[-1])",
            "    if server == 'sourceforge.net' and base == 'download':  # XXX Yuck",
            "        base = urllib.parse.unquote(path.split('/')[-2])",
            "    if '#' in base:",
            "        base, fragment = base.split('#', 1)",
            "    return base, fragment",
            "",
            "",
            "def distros_for_url(url, metadata=None):",
            "    \"\"\"Yield egg or source distribution objects that might be found at a URL\"\"\"",
            "    base, fragment = egg_info_for_url(url)",
            "    yield from distros_for_location(url, base, metadata)",
            "    if fragment:",
            "        match = EGG_FRAGMENT.match(fragment)",
            "        if match:",
            "            yield from interpret_distro_name(",
            "                url, match.group(1), metadata, precedence=CHECKOUT_DIST",
            "            )",
            "",
            "",
            "def distros_for_location(location, basename, metadata=None):",
            "    \"\"\"Yield egg or source distribution objects based on basename\"\"\"",
            "    if basename.endswith('.egg.zip'):",
            "        basename = basename[:-4]  # strip the .zip",
            "    if basename.endswith('.egg') and '-' in basename:",
            "        # only one, unambiguous interpretation",
            "        return [Distribution.from_location(location, basename, metadata)]",
            "    if basename.endswith('.whl') and '-' in basename:",
            "        wheel = Wheel(basename)",
            "        if not wheel.is_compatible():",
            "            return []",
            "        return [",
            "            Distribution(",
            "                location=location,",
            "                project_name=wheel.project_name,",
            "                version=wheel.version,",
            "                # Increase priority over eggs.",
            "                precedence=EGG_DIST + 1,",
            "            )",
            "        ]",
            "    if basename.endswith('.exe'):",
            "        win_base, py_ver, platform = parse_bdist_wininst(basename)",
            "        if win_base is not None:",
            "            return interpret_distro_name(",
            "                location, win_base, metadata, py_ver, BINARY_DIST, platform",
            "            )",
            "    # Try source distro extensions (.zip, .tgz, etc.)",
            "    #",
            "    for ext in EXTENSIONS:",
            "        if basename.endswith(ext):",
            "            basename = basename[: -len(ext)]",
            "            return interpret_distro_name(location, basename, metadata)",
            "    return []  # no extension matched",
            "",
            "",
            "def distros_for_filename(filename, metadata=None):",
            "    \"\"\"Yield possible egg or source distribution objects based on a filename\"\"\"",
            "    return distros_for_location(",
            "        normalize_path(filename), os.path.basename(filename), metadata",
            "    )",
            "",
            "",
            "def interpret_distro_name(",
            "    location, basename, metadata, py_version=None, precedence=SOURCE_DIST, platform=None",
            "):",
            "    \"\"\"Generate the interpretation of a source distro name",
            "",
            "    Note: if `location` is a filesystem filename, you should call",
            "    ``pkg_resources.normalize_path()`` on it before passing it to this",
            "    routine!",
            "    \"\"\"",
            "",
            "    parts = basename.split('-')",
            "    if not py_version and any(re.match(r'py\\d\\.\\d$', p) for p in parts[2:]):",
            "        # it is a bdist_dumb, not an sdist -- bail out",
            "        return",
            "",
            "    # find the pivot (p) that splits the name from the version.",
            "    # infer the version as the first item that has a digit.",
            "    for p in range(len(parts)):",
            "        if parts[p][:1].isdigit():",
            "            break",
            "    else:",
            "        p = len(parts)",
            "",
            "    yield Distribution(",
            "        location,",
            "        metadata,",
            "        '-'.join(parts[:p]),",
            "        '-'.join(parts[p:]),",
            "        py_version=py_version,",
            "        precedence=precedence,",
            "        platform=platform,",
            "    )",
            "",
            "",
            "def unique_values(func):",
            "    \"\"\"",
            "    Wrap a function returning an iterable such that the resulting iterable",
            "    only ever yields unique items.",
            "    \"\"\"",
            "",
            "    @wraps(func)",
            "    def wrapper(*args, **kwargs):",
            "        return unique_everseen(func(*args, **kwargs))",
            "",
            "    return wrapper",
            "",
            "",
            "REL = re.compile(r\"\"\"<([^>]*\\srel\\s{0,10}=\\s{0,10}['\"]?([^'\" >]+)[^>]*)>\"\"\", re.I)",
            "\"\"\"",
            "Regex for an HTML tag with 'rel=\"val\"' attributes.",
            "\"\"\"",
            "",
            "",
            "@unique_values",
            "def find_external_links(url, page):",
            "    \"\"\"Find rel=\"homepage\" and rel=\"download\" links in `page`, yielding URLs\"\"\"",
            "",
            "    for match in REL.finditer(page):",
            "        tag, rel = match.groups()",
            "        rels = set(map(str.strip, rel.lower().split(',')))",
            "        if 'homepage' in rels or 'download' in rels:",
            "            for match in HREF.finditer(tag):",
            "                yield urllib.parse.urljoin(url, htmldecode(match.group(1)))",
            "",
            "    for tag in (\"<th>Home Page\", \"<th>Download URL\"):",
            "        pos = page.find(tag)",
            "        if pos != -1:",
            "            match = HREF.search(page, pos)",
            "            if match:",
            "                yield urllib.parse.urljoin(url, htmldecode(match.group(1)))",
            "",
            "",
            "class ContentChecker:",
            "    \"\"\"",
            "    A null content checker that defines the interface for checking content",
            "    \"\"\"",
            "",
            "    def feed(self, block):",
            "        \"\"\"",
            "        Feed a block of data to the hash.",
            "        \"\"\"",
            "        return",
            "",
            "    def is_valid(self):",
            "        \"\"\"",
            "        Check the hash. Return False if validation fails.",
            "        \"\"\"",
            "        return True",
            "",
            "    def report(self, reporter, template):",
            "        \"\"\"",
            "        Call reporter with information about the checker (hash name)",
            "        substituted into the template.",
            "        \"\"\"",
            "        return",
            "",
            "",
            "class HashChecker(ContentChecker):",
            "    pattern = re.compile(",
            "        r'(?P<hash_name>sha1|sha224|sha384|sha256|sha512|md5)='",
            "        r'(?P<expected>[a-f0-9]+)'",
            "    )",
            "",
            "    def __init__(self, hash_name, expected):",
            "        self.hash_name = hash_name",
            "        self.hash = hashlib.new(hash_name)",
            "        self.expected = expected",
            "",
            "    @classmethod",
            "    def from_url(cls, url):",
            "        \"Construct a (possibly null) ContentChecker from a URL\"",
            "        fragment = urllib.parse.urlparse(url)[-1]",
            "        if not fragment:",
            "            return ContentChecker()",
            "        match = cls.pattern.search(fragment)",
            "        if not match:",
            "            return ContentChecker()",
            "        return cls(**match.groupdict())",
            "",
            "    def feed(self, block):",
            "        self.hash.update(block)",
            "",
            "    def is_valid(self):",
            "        return self.hash.hexdigest() == self.expected",
            "",
            "    def report(self, reporter, template):",
            "        msg = template % self.hash_name",
            "        return reporter(msg)",
            "",
            "",
            "class PackageIndex(Environment):",
            "    \"\"\"A distribution index that scans web pages for download URLs\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        index_url=\"https://pypi.org/simple/\",",
            "        hosts=('*',),",
            "        ca_bundle=None,",
            "        verify_ssl=True,",
            "        *args,",
            "        **kw,",
            "    ):",
            "        super().__init__(*args, **kw)",
            "        self.index_url = index_url + \"/\"[: not index_url.endswith('/')]",
            "        self.scanned_urls = {}",
            "        self.fetched_urls = {}",
            "        self.package_pages = {}",
            "        self.allows = re.compile('|'.join(map(translate, hosts))).match",
            "        self.to_scan = []",
            "        self.opener = urllib.request.urlopen",
            "",
            "    def add(self, dist):",
            "        # ignore invalid versions",
            "        try:",
            "            parse_version(dist.version)",
            "        except Exception:",
            "            return None",
            "        return super().add(dist)",
            "",
            "    # FIXME: 'PackageIndex.process_url' is too complex (14)",
            "    def process_url(self, url, retrieve=False):  # noqa: C901",
            "        \"\"\"Evaluate a URL as a possible download, and maybe retrieve it\"\"\"",
            "        if url in self.scanned_urls and not retrieve:",
            "            return",
            "        self.scanned_urls[url] = True",
            "        if not URL_SCHEME(url):",
            "            self.process_filename(url)",
            "            return",
            "        else:",
            "            dists = list(distros_for_url(url))",
            "            if dists:",
            "                if not self.url_ok(url):",
            "                    return",
            "                self.debug(\"Found link: %s\", url)",
            "",
            "        if dists or not retrieve or url in self.fetched_urls:",
            "            list(map(self.add, dists))",
            "            return  # don't need the actual page",
            "",
            "        if not self.url_ok(url):",
            "            self.fetched_urls[url] = True",
            "            return",
            "",
            "        self.info(\"Reading %s\", url)",
            "        self.fetched_urls[url] = True  # prevent multiple fetch attempts",
            "        tmpl = \"Download error on %s: %%s -- Some packages may not be found!\"",
            "        f = self.open_url(url, tmpl % url)",
            "        if f is None:",
            "            return",
            "        if isinstance(f, urllib.error.HTTPError) and f.code == 401:",
            "            self.info(\"Authentication error: %s\" % f.msg)",
            "        self.fetched_urls[f.url] = True",
            "        if 'html' not in f.headers.get('content-type', '').lower():",
            "            f.close()  # not html, we can't process it",
            "            return",
            "",
            "        base = f.url  # handle redirects",
            "        page = f.read()",
            "        if not isinstance(page, str):",
            "            # In Python 3 and got bytes but want str.",
            "            if isinstance(f, urllib.error.HTTPError):",
            "                # Errors have no charset, assume latin1:",
            "                charset = 'latin-1'",
            "            else:",
            "                charset = f.headers.get_param('charset') or 'latin-1'",
            "            page = page.decode(charset, \"ignore\")",
            "        f.close()",
            "        for match in HREF.finditer(page):",
            "            link = urllib.parse.urljoin(base, htmldecode(match.group(1)))",
            "            self.process_url(link)",
            "        if url.startswith(self.index_url) and getattr(f, 'code', None) != 404:",
            "            page = self.process_index(url, page)",
            "",
            "    def process_filename(self, fn, nested=False):",
            "        # process filenames or directories",
            "        if not os.path.exists(fn):",
            "            self.warn(\"Not found: %s\", fn)",
            "            return",
            "",
            "        if os.path.isdir(fn) and not nested:",
            "            path = os.path.realpath(fn)",
            "            for item in os.listdir(path):",
            "                self.process_filename(os.path.join(path, item), True)",
            "",
            "        dists = distros_for_filename(fn)",
            "        if dists:",
            "            self.debug(\"Found: %s\", fn)",
            "            list(map(self.add, dists))",
            "",
            "    def url_ok(self, url, fatal=False):",
            "        s = URL_SCHEME(url)",
            "        is_file = s and s.group(1).lower() == 'file'",
            "        if is_file or self.allows(urllib.parse.urlparse(url)[1]):",
            "            return True",
            "        msg = (",
            "            \"\\nNote: Bypassing %s (disallowed host; see \"",
            "            \"https://setuptools.pypa.io/en/latest/deprecated/\"",
            "            \"easy_install.html#restricting-downloads-with-allow-hosts for details).\\n\"",
            "        )",
            "        if fatal:",
            "            raise DistutilsError(msg % url)",
            "        else:",
            "            self.warn(msg, url)",
            "            return False",
            "",
            "    def scan_egg_links(self, search_path):",
            "        dirs = filter(os.path.isdir, search_path)",
            "        egg_links = (",
            "            (path, entry)",
            "            for path in dirs",
            "            for entry in os.listdir(path)",
            "            if entry.endswith('.egg-link')",
            "        )",
            "        list(itertools.starmap(self.scan_egg_link, egg_links))",
            "",
            "    def scan_egg_link(self, path, entry):",
            "        content = _read_utf8_with_fallback(os.path.join(path, entry))",
            "        # filter non-empty lines",
            "        lines = list(filter(None, map(str.strip, content.splitlines())))",
            "",
            "        if len(lines) != 2:",
            "            # format is not recognized; punt",
            "            return",
            "",
            "        egg_path, setup_path = lines",
            "",
            "        for dist in find_distributions(os.path.join(path, egg_path)):",
            "            dist.location = os.path.join(path, *lines)",
            "            dist.precedence = SOURCE_DIST",
            "            self.add(dist)",
            "",
            "    def _scan(self, link):",
            "        # Process a URL to see if it's for a package page",
            "        NO_MATCH_SENTINEL = None, None",
            "        if not link.startswith(self.index_url):",
            "            return NO_MATCH_SENTINEL",
            "",
            "        parts = list(map(urllib.parse.unquote, link[len(self.index_url) :].split('/')))",
            "        if len(parts) != 2 or '#' in parts[1]:",
            "            return NO_MATCH_SENTINEL",
            "",
            "        # it's a package page, sanitize and index it",
            "        pkg = safe_name(parts[0])",
            "        ver = safe_version(parts[1])",
            "        self.package_pages.setdefault(pkg.lower(), {})[link] = True",
            "        return to_filename(pkg), to_filename(ver)",
            "",
            "    def process_index(self, url, page):",
            "        \"\"\"Process the contents of a PyPI page\"\"\"",
            "",
            "        # process an index page into the package-page index",
            "        for match in HREF.finditer(page):",
            "            try:",
            "                self._scan(urllib.parse.urljoin(url, htmldecode(match.group(1))))",
            "            except ValueError:",
            "                pass",
            "",
            "        pkg, ver = self._scan(url)  # ensure this page is in the page index",
            "        if not pkg:",
            "            return \"\"  # no sense double-scanning non-package pages",
            "",
            "        # process individual package page",
            "        for new_url in find_external_links(url, page):",
            "            # Process the found URL",
            "            base, frag = egg_info_for_url(new_url)",
            "            if base.endswith('.py') and not frag:",
            "                if ver:",
            "                    new_url += '#egg=%s-%s' % (pkg, ver)",
            "                else:",
            "                    self.need_version_info(url)",
            "            self.scan_url(new_url)",
            "",
            "        return PYPI_MD5.sub(",
            "            lambda m: '<a href=\"%s#md5=%s\">%s</a>' % m.group(1, 3, 2), page",
            "        )",
            "",
            "    def need_version_info(self, url):",
            "        self.scan_all(",
            "            \"Page at %s links to .py file(s) without version info; an index \"",
            "            \"scan is required.\",",
            "            url,",
            "        )",
            "",
            "    def scan_all(self, msg=None, *args):",
            "        if self.index_url not in self.fetched_urls:",
            "            if msg:",
            "                self.warn(msg, *args)",
            "            self.info(\"Scanning index of all packages (this may take a while)\")",
            "        self.scan_url(self.index_url)",
            "",
            "    def find_packages(self, requirement):",
            "        self.scan_url(self.index_url + requirement.unsafe_name + '/')",
            "",
            "        if not self.package_pages.get(requirement.key):",
            "            # Fall back to safe version of the name",
            "            self.scan_url(self.index_url + requirement.project_name + '/')",
            "",
            "        if not self.package_pages.get(requirement.key):",
            "            # We couldn't find the target package, so search the index page too",
            "            self.not_found_in_index(requirement)",
            "",
            "        for url in list(self.package_pages.get(requirement.key, ())):",
            "            # scan each page that might be related to the desired package",
            "            self.scan_url(url)",
            "",
            "    def obtain(self, requirement, installer=None):",
            "        self.prescan()",
            "        self.find_packages(requirement)",
            "        for dist in self[requirement.key]:",
            "            if dist in requirement:",
            "                return dist",
            "            self.debug(\"%s does not match %s\", requirement, dist)",
            "        return super().obtain(requirement, installer)",
            "",
            "    def check_hash(self, checker, filename, tfp):",
            "        \"\"\"",
            "        checker is a ContentChecker",
            "        \"\"\"",
            "        checker.report(self.debug, \"Validating %%s checksum for %s\" % filename)",
            "        if not checker.is_valid():",
            "            tfp.close()",
            "            os.unlink(filename)",
            "            raise DistutilsError(",
            "                \"%s validation failed for %s; \"",
            "                \"possible download problem?\"",
            "                % (checker.hash.name, os.path.basename(filename))",
            "            )",
            "",
            "    def add_find_links(self, urls):",
            "        \"\"\"Add `urls` to the list that will be prescanned for searches\"\"\"",
            "        for url in urls:",
            "            if (",
            "                self.to_scan is None  # if we have already \"gone online\"",
            "                or not URL_SCHEME(url)  # or it's a local file/directory",
            "                or url.startswith('file:')",
            "                or list(distros_for_url(url))  # or a direct package link",
            "            ):",
            "                # then go ahead and process it now",
            "                self.scan_url(url)",
            "            else:",
            "                # otherwise, defer retrieval till later",
            "                self.to_scan.append(url)",
            "",
            "    def prescan(self):",
            "        \"\"\"Scan urls scheduled for prescanning (e.g. --find-links)\"\"\"",
            "        if self.to_scan:",
            "            list(map(self.scan_url, self.to_scan))",
            "        self.to_scan = None  # from now on, go ahead and process immediately",
            "",
            "    def not_found_in_index(self, requirement):",
            "        if self[requirement.key]:  # we've seen at least one distro",
            "            meth, msg = self.info, \"Couldn't retrieve index page for %r\"",
            "        else:  # no distros seen for this name, might be misspelled",
            "            meth, msg = (",
            "                self.warn,",
            "                \"Couldn't find index page for %r (maybe misspelled?)\",",
            "            )",
            "        meth(msg, requirement.unsafe_name)",
            "        self.scan_all()",
            "",
            "    def download(self, spec, tmpdir):",
            "        \"\"\"Locate and/or download `spec` to `tmpdir`, returning a local path",
            "",
            "        `spec` may be a ``Requirement`` object, or a string containing a URL,",
            "        an existing local filename, or a project/version requirement spec",
            "        (i.e. the string form of a ``Requirement`` object).  If it is the URL",
            "        of a .py file with an unambiguous ``#egg=name-version`` tag (i.e., one",
            "        that escapes ``-`` as ``_`` throughout), a trivial ``setup.py`` is",
            "        automatically created alongside the downloaded file.",
            "",
            "        If `spec` is a ``Requirement`` object or a string containing a",
            "        project/version requirement spec, this method returns the location of",
            "        a matching distribution (possibly after downloading it to `tmpdir`).",
            "        If `spec` is a locally existing file or directory name, it is simply",
            "        returned unchanged.  If `spec` is a URL, it is downloaded to a subpath",
            "        of `tmpdir`, and the local filename is returned.  Various errors may be",
            "        raised if a problem occurs during downloading.",
            "        \"\"\"",
            "        if not isinstance(spec, Requirement):",
            "            scheme = URL_SCHEME(spec)",
            "            if scheme:",
            "                # It's a url, download it to tmpdir",
            "                found = self._download_url(scheme.group(1), spec, tmpdir)",
            "                base, fragment = egg_info_for_url(spec)",
            "                if base.endswith('.py'):",
            "                    found = self.gen_setup(found, fragment, tmpdir)",
            "                return found",
            "            elif os.path.exists(spec):",
            "                # Existing file or directory, just return it",
            "                return spec",
            "            else:",
            "                spec = parse_requirement_arg(spec)",
            "        return getattr(self.fetch_distribution(spec, tmpdir), 'location', None)",
            "",
            "    def fetch_distribution(  # noqa: C901  # is too complex (14)  # FIXME",
            "        self,",
            "        requirement,",
            "        tmpdir,",
            "        force_scan=False,",
            "        source=False,",
            "        develop_ok=False,",
            "        local_index=None,",
            "    ):",
            "        \"\"\"Obtain a distribution suitable for fulfilling `requirement`",
            "",
            "        `requirement` must be a ``pkg_resources.Requirement`` instance.",
            "        If necessary, or if the `force_scan` flag is set, the requirement is",
            "        searched for in the (online) package index as well as the locally",
            "        installed packages.  If a distribution matching `requirement` is found,",
            "        the returned distribution's ``location`` is the value you would have",
            "        gotten from calling the ``download()`` method with the matching",
            "        distribution's URL or filename.  If no matching distribution is found,",
            "        ``None`` is returned.",
            "",
            "        If the `source` flag is set, only source distributions and source",
            "        checkout links will be considered.  Unless the `develop_ok` flag is",
            "        set, development and system eggs (i.e., those using the ``.egg-info``",
            "        format) will be ignored.",
            "        \"\"\"",
            "        # process a Requirement",
            "        self.info(\"Searching for %s\", requirement)",
            "        skipped = {}",
            "        dist = None",
            "",
            "        def find(req, env=None):",
            "            if env is None:",
            "                env = self",
            "            # Find a matching distribution; may be called more than once",
            "",
            "            for dist in env[req.key]:",
            "                if dist.precedence == DEVELOP_DIST and not develop_ok:",
            "                    if dist not in skipped:",
            "                        self.warn(",
            "                            \"Skipping development or system egg: %s\",",
            "                            dist,",
            "                        )",
            "                        skipped[dist] = 1",
            "                    continue",
            "",
            "                test = dist in req and (dist.precedence <= SOURCE_DIST or not source)",
            "                if test:",
            "                    loc = self.download(dist.location, tmpdir)",
            "                    dist.download_location = loc",
            "                    if os.path.exists(dist.download_location):",
            "                        return dist",
            "",
            "            return None",
            "",
            "        if force_scan:",
            "            self.prescan()",
            "            self.find_packages(requirement)",
            "            dist = find(requirement)",
            "",
            "        if not dist and local_index is not None:",
            "            dist = find(requirement, local_index)",
            "",
            "        if dist is None:",
            "            if self.to_scan is not None:",
            "                self.prescan()",
            "            dist = find(requirement)",
            "",
            "        if dist is None and not force_scan:",
            "            self.find_packages(requirement)",
            "            dist = find(requirement)",
            "",
            "        if dist is None:",
            "            self.warn(",
            "                \"No local packages or working download links found for %s%s\",",
            "                (source and \"a source distribution of \" or \"\"),",
            "                requirement,",
            "            )",
            "            return None",
            "        else:",
            "            self.info(\"Best match: %s\", dist)",
            "            return dist.clone(location=dist.download_location)",
            "",
            "    def fetch(self, requirement, tmpdir, force_scan=False, source=False):",
            "        \"\"\"Obtain a file suitable for fulfilling `requirement`",
            "",
            "        DEPRECATED; use the ``fetch_distribution()`` method now instead.  For",
            "        backward compatibility, this routine is identical but returns the",
            "        ``location`` of the downloaded distribution instead of a distribution",
            "        object.",
            "        \"\"\"",
            "        dist = self.fetch_distribution(requirement, tmpdir, force_scan, source)",
            "        if dist is not None:",
            "            return dist.location",
            "        return None",
            "",
            "    def gen_setup(self, filename, fragment, tmpdir):",
            "        match = EGG_FRAGMENT.match(fragment)",
            "        dists = (",
            "            match",
            "            and [",
            "                d",
            "                for d in interpret_distro_name(filename, match.group(1), None)",
            "                if d.version",
            "            ]",
            "            or []",
            "        )",
            "",
            "        if len(dists) == 1:  # unambiguous ``#egg`` fragment",
            "            basename = os.path.basename(filename)",
            "",
            "            # Make sure the file has been downloaded to the temp dir.",
            "            if os.path.dirname(filename) != tmpdir:",
            "                dst = os.path.join(tmpdir, basename)",
            "                if not (os.path.exists(dst) and os.path.samefile(filename, dst)):",
            "                    shutil.copy2(filename, dst)",
            "                    filename = dst",
            "",
            "            with open(os.path.join(tmpdir, 'setup.py'), 'w', encoding=\"utf-8\") as file:",
            "                file.write(",
            "                    \"from setuptools import setup\\n\"",
            "                    \"setup(name=%r, version=%r, py_modules=[%r])\\n\"",
            "                    % (",
            "                        dists[0].project_name,",
            "                        dists[0].version,",
            "                        os.path.splitext(basename)[0],",
            "                    )",
            "                )",
            "            return filename",
            "",
            "        elif match:",
            "            raise DistutilsError(",
            "                \"Can't unambiguously interpret project/version identifier %r; \"",
            "                \"any dashes in the name or version should be escaped using \"",
            "                \"underscores. %r\" % (fragment, dists)",
            "            )",
            "        else:",
            "            raise DistutilsError(",
            "                \"Can't process plain .py files without an '#egg=name-version'\"",
            "                \" suffix to enable automatic setup script generation.\"",
            "            )",
            "",
            "    dl_blocksize = 8192",
            "",
            "    def _download_to(self, url, filename):",
            "        self.info(\"Downloading %s\", url)",
            "        # Download the file",
            "        fp = None",
            "        try:",
            "            checker = HashChecker.from_url(url)",
            "            fp = self.open_url(url)",
            "            if isinstance(fp, urllib.error.HTTPError):",
            "                raise DistutilsError(",
            "                    \"Can't download %s: %s %s\" % (url, fp.code, fp.msg)",
            "                )",
            "            headers = fp.info()",
            "            blocknum = 0",
            "            bs = self.dl_blocksize",
            "            size = -1",
            "            if \"content-length\" in headers:",
            "                # Some servers return multiple Content-Length headers :(",
            "                sizes = headers.get_all('Content-Length')",
            "                size = max(map(int, sizes))",
            "                self.reporthook(url, filename, blocknum, bs, size)",
            "            with open(filename, 'wb') as tfp:",
            "                while True:",
            "                    block = fp.read(bs)",
            "                    if block:",
            "                        checker.feed(block)",
            "                        tfp.write(block)",
            "                        blocknum += 1",
            "                        self.reporthook(url, filename, blocknum, bs, size)",
            "                    else:",
            "                        break",
            "                self.check_hash(checker, filename, tfp)",
            "            return headers",
            "        finally:",
            "            if fp:",
            "                fp.close()",
            "",
            "    def reporthook(self, url, filename, blocknum, blksize, size):",
            "        pass  # no-op",
            "",
            "    # FIXME:",
            "    def open_url(self, url, warning=None):  # noqa: C901  # is too complex (12)",
            "        if url.startswith('file:'):",
            "            return local_open(url)",
            "        try:",
            "            return open_with_auth(url, self.opener)",
            "        except (ValueError, http.client.InvalidURL) as v:",
            "            msg = ' '.join([str(arg) for arg in v.args])",
            "            if warning:",
            "                self.warn(warning, msg)",
            "            else:",
            "                raise DistutilsError('%s %s' % (url, msg)) from v",
            "        except urllib.error.HTTPError as v:",
            "            return v",
            "        except urllib.error.URLError as v:",
            "            if warning:",
            "                self.warn(warning, v.reason)",
            "            else:",
            "                raise DistutilsError(",
            "                    \"Download error for %s: %s\" % (url, v.reason)",
            "                ) from v",
            "        except http.client.BadStatusLine as v:",
            "            if warning:",
            "                self.warn(warning, v.line)",
            "            else:",
            "                raise DistutilsError(",
            "                    '%s returned a bad status line. The server might be '",
            "                    'down, %s' % (url, v.line)",
            "                ) from v",
            "        except (http.client.HTTPException, OSError) as v:",
            "            if warning:",
            "                self.warn(warning, v)",
            "            else:",
            "                raise DistutilsError(\"Download error for %s: %s\" % (url, v)) from v",
            "",
            "    def _download_url(self, scheme, url, tmpdir):",
            "        # Determine download filename",
            "        #",
            "        name, fragment = egg_info_for_url(url)",
            "        if name:",
            "            while '..' in name:",
            "                name = name.replace('..', '.').replace('\\\\', '_')",
            "        else:",
            "            name = \"__downloaded__\"  # default if URL has no path contents",
            "",
            "        if name.endswith('.egg.zip'):",
            "            name = name[:-4]  # strip the extra .zip before download",
            "",
            "        filename = os.path.join(tmpdir, name)",
            "",
            "        # Download the file",
            "        #",
            "        if scheme == 'svn' or scheme.startswith('svn+'):",
            "            return self._download_svn(url, filename)",
            "        elif scheme == 'git' or scheme.startswith('git+'):",
            "            return self._download_git(url, filename)",
            "        elif scheme.startswith('hg+'):",
            "            return self._download_hg(url, filename)",
            "        elif scheme == 'file':",
            "            return urllib.request.url2pathname(urllib.parse.urlparse(url)[2])",
            "        else:",
            "            self.url_ok(url, True)  # raises error if not allowed",
            "            return self._attempt_download(url, filename)",
            "",
            "    def scan_url(self, url):",
            "        self.process_url(url, True)",
            "",
            "    def _attempt_download(self, url, filename):",
            "        headers = self._download_to(url, filename)",
            "        if 'html' in headers.get('content-type', '').lower():",
            "            return self._invalid_download_html(url, headers, filename)",
            "        else:",
            "            return filename",
            "",
            "    def _invalid_download_html(self, url, headers, filename):",
            "        os.unlink(filename)",
            "        raise DistutilsError(f\"Unexpected HTML page found at {url}\")",
            "",
            "    def _download_svn(self, url, _filename):",
            "        raise DistutilsError(f\"Invalid config, SVN download is not supported: {url}\")",
            "",
            "    @staticmethod",
            "    def _vcs_split_rev_from_url(url, pop_prefix=False):",
            "        scheme, netloc, path, query, frag = urllib.parse.urlsplit(url)",
            "",
            "        scheme = scheme.split('+', 1)[-1]",
            "",
            "        # Some fragment identification fails",
            "        path = path.split('#', 1)[0]",
            "",
            "        rev = None",
            "        if '@' in path:",
            "            path, rev = path.rsplit('@', 1)",
            "",
            "        # Also, discard fragment",
            "        url = urllib.parse.urlunsplit((scheme, netloc, path, query, ''))",
            "",
            "        return url, rev",
            "",
            "    def _download_git(self, url, filename):",
            "        filename = filename.split('#', 1)[0]",
            "        url, rev = self._vcs_split_rev_from_url(url, pop_prefix=True)",
            "",
            "        self.info(\"Doing git clone from %s to %s\", url, filename)",
            "        os.system(\"git clone --quiet %s %s\" % (url, filename))",
            "",
            "        if rev is not None:",
            "            self.info(\"Checking out %s\", rev)",
            "            os.system(",
            "                \"git -C %s checkout --quiet %s\"",
            "                % (",
            "                    filename,",
            "                    rev,",
            "                )",
            "            )",
            "",
            "        return filename",
            "",
            "    def _download_hg(self, url, filename):",
            "        filename = filename.split('#', 1)[0]",
            "        url, rev = self._vcs_split_rev_from_url(url, pop_prefix=True)",
            "",
            "        self.info(\"Doing hg clone from %s to %s\", url, filename)",
            "        os.system(\"hg clone --quiet %s %s\" % (url, filename))",
            "",
            "        if rev is not None:",
            "            self.info(\"Updating to %s\", rev)",
            "            os.system(",
            "                \"hg --cwd %s up -C -r %s -q\"",
            "                % (",
            "                    filename,",
            "                    rev,",
            "                )",
            "            )",
            "",
            "        return filename",
            "",
            "    def debug(self, msg, *args):",
            "        log.debug(msg, *args)",
            "",
            "    def info(self, msg, *args):",
            "        log.info(msg, *args)",
            "",
            "    def warn(self, msg, *args):",
            "        log.warn(msg, *args)",
            "",
            "",
            "# This pattern matches a character entity reference (a decimal numeric",
            "# references, a hexadecimal numeric reference, or a named reference).",
            "entity_sub = re.compile(r'&(#(\\d+|x[\\da-fA-F]+)|[\\w.:-]+);?').sub",
            "",
            "",
            "def decode_entity(match):",
            "    what = match.group(0)",
            "    return html.unescape(what)",
            "",
            "",
            "def htmldecode(text):",
            "    \"\"\"",
            "    Decode HTML entities in the given text.",
            "",
            "    >>> htmldecode(",
            "    ...     'https://../package_name-0.1.2.tar.gz'",
            "    ...     '?tokena=A&amp;tokenb=B\">package_name-0.1.2.tar.gz')",
            "    'https://../package_name-0.1.2.tar.gz?tokena=A&tokenb=B\">package_name-0.1.2.tar.gz'",
            "    \"\"\"",
            "    return entity_sub(decode_entity, text)",
            "",
            "",
            "def socket_timeout(timeout=15):",
            "    def _socket_timeout(func):",
            "        def _socket_timeout(*args, **kwargs):",
            "            old_timeout = socket.getdefaulttimeout()",
            "            socket.setdefaulttimeout(timeout)",
            "            try:",
            "                return func(*args, **kwargs)",
            "            finally:",
            "                socket.setdefaulttimeout(old_timeout)",
            "",
            "        return _socket_timeout",
            "",
            "    return _socket_timeout",
            "",
            "",
            "def _encode_auth(auth):",
            "    \"\"\"",
            "    Encode auth from a URL suitable for an HTTP header.",
            "    >>> str(_encode_auth('username%3Apassword'))",
            "    'dXNlcm5hbWU6cGFzc3dvcmQ='",
            "",
            "    Long auth strings should not cause a newline to be inserted.",
            "    >>> long_auth = 'username:' + 'password'*10",
            "    >>> chr(10) in str(_encode_auth(long_auth))",
            "    False",
            "    \"\"\"",
            "    auth_s = urllib.parse.unquote(auth)",
            "    # convert to bytes",
            "    auth_bytes = auth_s.encode()",
            "    encoded_bytes = base64.b64encode(auth_bytes)",
            "    # convert back to a string",
            "    encoded = encoded_bytes.decode()",
            "    # strip the trailing carriage return",
            "    return encoded.replace('\\n', '')",
            "",
            "",
            "class Credential:",
            "    \"\"\"",
            "    A username/password pair. Use like a namedtuple.",
            "    \"\"\"",
            "",
            "    def __init__(self, username, password):",
            "        self.username = username",
            "        self.password = password",
            "",
            "    def __iter__(self):",
            "        yield self.username",
            "        yield self.password",
            "",
            "    def __str__(self):",
            "        return '%(username)s:%(password)s' % vars(self)",
            "",
            "",
            "class PyPIConfig(configparser.RawConfigParser):",
            "    def __init__(self):",
            "        \"\"\"",
            "        Load from ~/.pypirc",
            "        \"\"\"",
            "        defaults = dict.fromkeys(['username', 'password', 'repository'], '')",
            "        super().__init__(defaults)",
            "",
            "        rc = os.path.join(os.path.expanduser('~'), '.pypirc')",
            "        if os.path.exists(rc):",
            "            _cfg_read_utf8_with_fallback(self, rc)",
            "",
            "    @property",
            "    def creds_by_repository(self):",
            "        sections_with_repositories = [",
            "            section",
            "            for section in self.sections()",
            "            if self.get(section, 'repository').strip()",
            "        ]",
            "",
            "        return dict(map(self._get_repo_cred, sections_with_repositories))",
            "",
            "    def _get_repo_cred(self, section):",
            "        repo = self.get(section, 'repository').strip()",
            "        return repo, Credential(",
            "            self.get(section, 'username').strip(),",
            "            self.get(section, 'password').strip(),",
            "        )",
            "",
            "    def find_credential(self, url):",
            "        \"\"\"",
            "        If the URL indicated appears to be a repository defined in this",
            "        config, return the credential for that repository.",
            "        \"\"\"",
            "        for repository, cred in self.creds_by_repository.items():",
            "            if url.startswith(repository):",
            "                return cred",
            "        return None",
            "",
            "",
            "def open_with_auth(url, opener=urllib.request.urlopen):",
            "    \"\"\"Open a urllib2 request, handling HTTP authentication\"\"\"",
            "",
            "    parsed = urllib.parse.urlparse(url)",
            "    scheme, netloc, path, params, query, frag = parsed",
            "",
            "    # Double scheme does not raise on macOS as revealed by a",
            "    # failing test. We would expect \"nonnumeric port\". Refs #20.",
            "    if netloc.endswith(':'):",
            "        raise http.client.InvalidURL(\"nonnumeric port: ''\")",
            "",
            "    if scheme in ('http', 'https'):",
            "        auth, address = _splituser(netloc)",
            "    else:",
            "        auth = None",
            "",
            "    if not auth:",
            "        cred = PyPIConfig().find_credential(url)",
            "        if cred:",
            "            auth = str(cred)",
            "            info = cred.username, url",
            "            log.info('Authenticating as %s for %s (from .pypirc)', *info)",
            "",
            "    if auth:",
            "        auth = \"Basic \" + _encode_auth(auth)",
            "        parts = scheme, address, path, params, query, frag",
            "        new_url = urllib.parse.urlunparse(parts)",
            "        request = urllib.request.Request(new_url)",
            "        request.add_header(\"Authorization\", auth)",
            "    else:",
            "        request = urllib.request.Request(url)",
            "",
            "    request.add_header('User-Agent', user_agent)",
            "    fp = opener(request)",
            "",
            "    if auth:",
            "        # Put authentication info back into request URL if same host,",
            "        # so that links found on the page will work",
            "        s2, h2, path2, param2, query2, frag2 = urllib.parse.urlparse(fp.url)",
            "        if s2 == scheme and h2 == address:",
            "            parts = s2, netloc, path2, param2, query2, frag2",
            "            fp.url = urllib.parse.urlunparse(parts)",
            "",
            "    return fp",
            "",
            "",
            "# copy of urllib.parse._splituser from Python 3.8",
            "def _splituser(host):",
            "    \"\"\"splituser('user[:passwd]@host[:port]')",
            "    --> 'user[:passwd]', 'host[:port]'.\"\"\"",
            "    user, delim, host = host.rpartition('@')",
            "    return (user if delim else None), host",
            "",
            "",
            "# adding a timeout to avoid freezing package_index",
            "open_with_auth = socket_timeout(_SOCKET_TIMEOUT)(open_with_auth)",
            "",
            "",
            "def fix_sf_url(url):",
            "    return url  # backward compatibility",
            "",
            "",
            "def local_open(url):",
            "    \"\"\"Read a local path, with special support for directories\"\"\"",
            "    scheme, server, path, param, query, frag = urllib.parse.urlparse(url)",
            "    filename = urllib.request.url2pathname(path)",
            "    if os.path.isfile(filename):",
            "        return urllib.request.urlopen(url)",
            "    elif path.endswith('/') and os.path.isdir(filename):",
            "        files = []",
            "        for f in os.listdir(filename):",
            "            filepath = os.path.join(filename, f)",
            "            if f == 'index.html':",
            "                body = _read_utf8_with_fallback(filepath)",
            "                break",
            "            elif os.path.isdir(filepath):",
            "                f += '/'",
            "            files.append('<a href=\"{name}\">{name}</a>'.format(name=f))",
            "        else:",
            "            tmpl = (",
            "                \"<html><head><title>{url}</title>\" \"</head><body>{files}</body></html>\"",
            "            )",
            "            body = tmpl.format(url=url, files='\\n'.join(files))",
            "        status, message = 200, \"OK\"",
            "    else:",
            "        status, message, body = 404, \"Path not found\", \"Not found\"",
            "",
            "    headers = {'content-type': 'text/html'}",
            "    body_stream = io.StringIO(body)",
            "    return urllib.error.HTTPError(url, status, message, headers, body_stream)"
        ],
        "afterPatchFile": [
            "\"\"\"PyPI and direct package downloading.\"\"\"",
            "",
            "import sys",
            "import subprocess",
            "import os",
            "import re",
            "import io",
            "import shutil",
            "import socket",
            "import base64",
            "import hashlib",
            "import itertools",
            "import configparser",
            "import html",
            "import http.client",
            "import urllib.parse",
            "import urllib.request",
            "import urllib.error",
            "from functools import wraps",
            "",
            "import setuptools",
            "from pkg_resources import (",
            "    CHECKOUT_DIST,",
            "    Distribution,",
            "    BINARY_DIST,",
            "    normalize_path,",
            "    SOURCE_DIST,",
            "    Environment,",
            "    find_distributions,",
            "    safe_name,",
            "    safe_version,",
            "    to_filename,",
            "    Requirement,",
            "    DEVELOP_DIST,",
            "    EGG_DIST,",
            "    parse_version,",
            ")",
            "from distutils import log",
            "from distutils.errors import DistutilsError",
            "from fnmatch import translate",
            "from setuptools.wheel import Wheel",
            "from setuptools.extern.more_itertools import unique_everseen",
            "",
            "from .unicode_utils import _read_utf8_with_fallback, _cfg_read_utf8_with_fallback",
            "",
            "",
            "EGG_FRAGMENT = re.compile(r'^egg=([-A-Za-z0-9_.+!]+)$')",
            "HREF = re.compile(r\"\"\"href\\s*=\\s*['\"]?([^'\"> ]+)\"\"\", re.I)",
            "PYPI_MD5 = re.compile(",
            "    r'<a href=\"([^\"#]+)\">([^<]+)</a>\\n\\s+\\(<a (?:title=\"MD5 hash\"\\n\\s+)'",
            "    r'href=\"[^?]+\\?:action=show_md5&amp;digest=([0-9a-f]{32})\">md5</a>\\)'",
            ")",
            "URL_SCHEME = re.compile('([-+.a-z0-9]{2,}):', re.I).match",
            "EXTENSIONS = \".tar.gz .tar.bz2 .tar .zip .tgz\".split()",
            "",
            "__all__ = [",
            "    'PackageIndex',",
            "    'distros_for_url',",
            "    'parse_bdist_wininst',",
            "    'interpret_distro_name',",
            "]",
            "",
            "_SOCKET_TIMEOUT = 15",
            "",
            "_tmpl = \"setuptools/{setuptools.__version__} Python-urllib/{py_major}\"",
            "user_agent = _tmpl.format(",
            "    py_major='{}.{}'.format(*sys.version_info), setuptools=setuptools",
            ")",
            "",
            "",
            "def parse_requirement_arg(spec):",
            "    try:",
            "        return Requirement.parse(spec)",
            "    except ValueError as e:",
            "        raise DistutilsError(",
            "            \"Not a URL, existing file, or requirement spec: %r\" % (spec,)",
            "        ) from e",
            "",
            "",
            "def parse_bdist_wininst(name):",
            "    \"\"\"Return (base,pyversion) or (None,None) for possible .exe name\"\"\"",
            "",
            "    lower = name.lower()",
            "    base, py_ver, plat = None, None, None",
            "",
            "    if lower.endswith('.exe'):",
            "        if lower.endswith('.win32.exe'):",
            "            base = name[:-10]",
            "            plat = 'win32'",
            "        elif lower.startswith('.win32-py', -16):",
            "            py_ver = name[-7:-4]",
            "            base = name[:-16]",
            "            plat = 'win32'",
            "        elif lower.endswith('.win-amd64.exe'):",
            "            base = name[:-14]",
            "            plat = 'win-amd64'",
            "        elif lower.startswith('.win-amd64-py', -20):",
            "            py_ver = name[-7:-4]",
            "            base = name[:-20]",
            "            plat = 'win-amd64'",
            "    return base, py_ver, plat",
            "",
            "",
            "def egg_info_for_url(url):",
            "    parts = urllib.parse.urlparse(url)",
            "    scheme, server, path, parameters, query, fragment = parts",
            "    base = urllib.parse.unquote(path.split('/')[-1])",
            "    if server == 'sourceforge.net' and base == 'download':  # XXX Yuck",
            "        base = urllib.parse.unquote(path.split('/')[-2])",
            "    if '#' in base:",
            "        base, fragment = base.split('#', 1)",
            "    return base, fragment",
            "",
            "",
            "def distros_for_url(url, metadata=None):",
            "    \"\"\"Yield egg or source distribution objects that might be found at a URL\"\"\"",
            "    base, fragment = egg_info_for_url(url)",
            "    yield from distros_for_location(url, base, metadata)",
            "    if fragment:",
            "        match = EGG_FRAGMENT.match(fragment)",
            "        if match:",
            "            yield from interpret_distro_name(",
            "                url, match.group(1), metadata, precedence=CHECKOUT_DIST",
            "            )",
            "",
            "",
            "def distros_for_location(location, basename, metadata=None):",
            "    \"\"\"Yield egg or source distribution objects based on basename\"\"\"",
            "    if basename.endswith('.egg.zip'):",
            "        basename = basename[:-4]  # strip the .zip",
            "    if basename.endswith('.egg') and '-' in basename:",
            "        # only one, unambiguous interpretation",
            "        return [Distribution.from_location(location, basename, metadata)]",
            "    if basename.endswith('.whl') and '-' in basename:",
            "        wheel = Wheel(basename)",
            "        if not wheel.is_compatible():",
            "            return []",
            "        return [",
            "            Distribution(",
            "                location=location,",
            "                project_name=wheel.project_name,",
            "                version=wheel.version,",
            "                # Increase priority over eggs.",
            "                precedence=EGG_DIST + 1,",
            "            )",
            "        ]",
            "    if basename.endswith('.exe'):",
            "        win_base, py_ver, platform = parse_bdist_wininst(basename)",
            "        if win_base is not None:",
            "            return interpret_distro_name(",
            "                location, win_base, metadata, py_ver, BINARY_DIST, platform",
            "            )",
            "    # Try source distro extensions (.zip, .tgz, etc.)",
            "    #",
            "    for ext in EXTENSIONS:",
            "        if basename.endswith(ext):",
            "            basename = basename[: -len(ext)]",
            "            return interpret_distro_name(location, basename, metadata)",
            "    return []  # no extension matched",
            "",
            "",
            "def distros_for_filename(filename, metadata=None):",
            "    \"\"\"Yield possible egg or source distribution objects based on a filename\"\"\"",
            "    return distros_for_location(",
            "        normalize_path(filename), os.path.basename(filename), metadata",
            "    )",
            "",
            "",
            "def interpret_distro_name(",
            "    location, basename, metadata, py_version=None, precedence=SOURCE_DIST, platform=None",
            "):",
            "    \"\"\"Generate the interpretation of a source distro name",
            "",
            "    Note: if `location` is a filesystem filename, you should call",
            "    ``pkg_resources.normalize_path()`` on it before passing it to this",
            "    routine!",
            "    \"\"\"",
            "",
            "    parts = basename.split('-')",
            "    if not py_version and any(re.match(r'py\\d\\.\\d$', p) for p in parts[2:]):",
            "        # it is a bdist_dumb, not an sdist -- bail out",
            "        return",
            "",
            "    # find the pivot (p) that splits the name from the version.",
            "    # infer the version as the first item that has a digit.",
            "    for p in range(len(parts)):",
            "        if parts[p][:1].isdigit():",
            "            break",
            "    else:",
            "        p = len(parts)",
            "",
            "    yield Distribution(",
            "        location,",
            "        metadata,",
            "        '-'.join(parts[:p]),",
            "        '-'.join(parts[p:]),",
            "        py_version=py_version,",
            "        precedence=precedence,",
            "        platform=platform,",
            "    )",
            "",
            "",
            "def unique_values(func):",
            "    \"\"\"",
            "    Wrap a function returning an iterable such that the resulting iterable",
            "    only ever yields unique items.",
            "    \"\"\"",
            "",
            "    @wraps(func)",
            "    def wrapper(*args, **kwargs):",
            "        return unique_everseen(func(*args, **kwargs))",
            "",
            "    return wrapper",
            "",
            "",
            "REL = re.compile(r\"\"\"<([^>]*\\srel\\s{0,10}=\\s{0,10}['\"]?([^'\" >]+)[^>]*)>\"\"\", re.I)",
            "\"\"\"",
            "Regex for an HTML tag with 'rel=\"val\"' attributes.",
            "\"\"\"",
            "",
            "",
            "@unique_values",
            "def find_external_links(url, page):",
            "    \"\"\"Find rel=\"homepage\" and rel=\"download\" links in `page`, yielding URLs\"\"\"",
            "",
            "    for match in REL.finditer(page):",
            "        tag, rel = match.groups()",
            "        rels = set(map(str.strip, rel.lower().split(',')))",
            "        if 'homepage' in rels or 'download' in rels:",
            "            for match in HREF.finditer(tag):",
            "                yield urllib.parse.urljoin(url, htmldecode(match.group(1)))",
            "",
            "    for tag in (\"<th>Home Page\", \"<th>Download URL\"):",
            "        pos = page.find(tag)",
            "        if pos != -1:",
            "            match = HREF.search(page, pos)",
            "            if match:",
            "                yield urllib.parse.urljoin(url, htmldecode(match.group(1)))",
            "",
            "",
            "class ContentChecker:",
            "    \"\"\"",
            "    A null content checker that defines the interface for checking content",
            "    \"\"\"",
            "",
            "    def feed(self, block):",
            "        \"\"\"",
            "        Feed a block of data to the hash.",
            "        \"\"\"",
            "        return",
            "",
            "    def is_valid(self):",
            "        \"\"\"",
            "        Check the hash. Return False if validation fails.",
            "        \"\"\"",
            "        return True",
            "",
            "    def report(self, reporter, template):",
            "        \"\"\"",
            "        Call reporter with information about the checker (hash name)",
            "        substituted into the template.",
            "        \"\"\"",
            "        return",
            "",
            "",
            "class HashChecker(ContentChecker):",
            "    pattern = re.compile(",
            "        r'(?P<hash_name>sha1|sha224|sha384|sha256|sha512|md5)='",
            "        r'(?P<expected>[a-f0-9]+)'",
            "    )",
            "",
            "    def __init__(self, hash_name, expected):",
            "        self.hash_name = hash_name",
            "        self.hash = hashlib.new(hash_name)",
            "        self.expected = expected",
            "",
            "    @classmethod",
            "    def from_url(cls, url):",
            "        \"Construct a (possibly null) ContentChecker from a URL\"",
            "        fragment = urllib.parse.urlparse(url)[-1]",
            "        if not fragment:",
            "            return ContentChecker()",
            "        match = cls.pattern.search(fragment)",
            "        if not match:",
            "            return ContentChecker()",
            "        return cls(**match.groupdict())",
            "",
            "    def feed(self, block):",
            "        self.hash.update(block)",
            "",
            "    def is_valid(self):",
            "        return self.hash.hexdigest() == self.expected",
            "",
            "    def report(self, reporter, template):",
            "        msg = template % self.hash_name",
            "        return reporter(msg)",
            "",
            "",
            "class PackageIndex(Environment):",
            "    \"\"\"A distribution index that scans web pages for download URLs\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        index_url=\"https://pypi.org/simple/\",",
            "        hosts=('*',),",
            "        ca_bundle=None,",
            "        verify_ssl=True,",
            "        *args,",
            "        **kw,",
            "    ):",
            "        super().__init__(*args, **kw)",
            "        self.index_url = index_url + \"/\"[: not index_url.endswith('/')]",
            "        self.scanned_urls = {}",
            "        self.fetched_urls = {}",
            "        self.package_pages = {}",
            "        self.allows = re.compile('|'.join(map(translate, hosts))).match",
            "        self.to_scan = []",
            "        self.opener = urllib.request.urlopen",
            "",
            "    def add(self, dist):",
            "        # ignore invalid versions",
            "        try:",
            "            parse_version(dist.version)",
            "        except Exception:",
            "            return None",
            "        return super().add(dist)",
            "",
            "    # FIXME: 'PackageIndex.process_url' is too complex (14)",
            "    def process_url(self, url, retrieve=False):  # noqa: C901",
            "        \"\"\"Evaluate a URL as a possible download, and maybe retrieve it\"\"\"",
            "        if url in self.scanned_urls and not retrieve:",
            "            return",
            "        self.scanned_urls[url] = True",
            "        if not URL_SCHEME(url):",
            "            self.process_filename(url)",
            "            return",
            "        else:",
            "            dists = list(distros_for_url(url))",
            "            if dists:",
            "                if not self.url_ok(url):",
            "                    return",
            "                self.debug(\"Found link: %s\", url)",
            "",
            "        if dists or not retrieve or url in self.fetched_urls:",
            "            list(map(self.add, dists))",
            "            return  # don't need the actual page",
            "",
            "        if not self.url_ok(url):",
            "            self.fetched_urls[url] = True",
            "            return",
            "",
            "        self.info(\"Reading %s\", url)",
            "        self.fetched_urls[url] = True  # prevent multiple fetch attempts",
            "        tmpl = \"Download error on %s: %%s -- Some packages may not be found!\"",
            "        f = self.open_url(url, tmpl % url)",
            "        if f is None:",
            "            return",
            "        if isinstance(f, urllib.error.HTTPError) and f.code == 401:",
            "            self.info(\"Authentication error: %s\" % f.msg)",
            "        self.fetched_urls[f.url] = True",
            "        if 'html' not in f.headers.get('content-type', '').lower():",
            "            f.close()  # not html, we can't process it",
            "            return",
            "",
            "        base = f.url  # handle redirects",
            "        page = f.read()",
            "        if not isinstance(page, str):",
            "            # In Python 3 and got bytes but want str.",
            "            if isinstance(f, urllib.error.HTTPError):",
            "                # Errors have no charset, assume latin1:",
            "                charset = 'latin-1'",
            "            else:",
            "                charset = f.headers.get_param('charset') or 'latin-1'",
            "            page = page.decode(charset, \"ignore\")",
            "        f.close()",
            "        for match in HREF.finditer(page):",
            "            link = urllib.parse.urljoin(base, htmldecode(match.group(1)))",
            "            self.process_url(link)",
            "        if url.startswith(self.index_url) and getattr(f, 'code', None) != 404:",
            "            page = self.process_index(url, page)",
            "",
            "    def process_filename(self, fn, nested=False):",
            "        # process filenames or directories",
            "        if not os.path.exists(fn):",
            "            self.warn(\"Not found: %s\", fn)",
            "            return",
            "",
            "        if os.path.isdir(fn) and not nested:",
            "            path = os.path.realpath(fn)",
            "            for item in os.listdir(path):",
            "                self.process_filename(os.path.join(path, item), True)",
            "",
            "        dists = distros_for_filename(fn)",
            "        if dists:",
            "            self.debug(\"Found: %s\", fn)",
            "            list(map(self.add, dists))",
            "",
            "    def url_ok(self, url, fatal=False):",
            "        s = URL_SCHEME(url)",
            "        is_file = s and s.group(1).lower() == 'file'",
            "        if is_file or self.allows(urllib.parse.urlparse(url)[1]):",
            "            return True",
            "        msg = (",
            "            \"\\nNote: Bypassing %s (disallowed host; see \"",
            "            \"https://setuptools.pypa.io/en/latest/deprecated/\"",
            "            \"easy_install.html#restricting-downloads-with-allow-hosts for details).\\n\"",
            "        )",
            "        if fatal:",
            "            raise DistutilsError(msg % url)",
            "        else:",
            "            self.warn(msg, url)",
            "            return False",
            "",
            "    def scan_egg_links(self, search_path):",
            "        dirs = filter(os.path.isdir, search_path)",
            "        egg_links = (",
            "            (path, entry)",
            "            for path in dirs",
            "            for entry in os.listdir(path)",
            "            if entry.endswith('.egg-link')",
            "        )",
            "        list(itertools.starmap(self.scan_egg_link, egg_links))",
            "",
            "    def scan_egg_link(self, path, entry):",
            "        content = _read_utf8_with_fallback(os.path.join(path, entry))",
            "        # filter non-empty lines",
            "        lines = list(filter(None, map(str.strip, content.splitlines())))",
            "",
            "        if len(lines) != 2:",
            "            # format is not recognized; punt",
            "            return",
            "",
            "        egg_path, setup_path = lines",
            "",
            "        for dist in find_distributions(os.path.join(path, egg_path)):",
            "            dist.location = os.path.join(path, *lines)",
            "            dist.precedence = SOURCE_DIST",
            "            self.add(dist)",
            "",
            "    def _scan(self, link):",
            "        # Process a URL to see if it's for a package page",
            "        NO_MATCH_SENTINEL = None, None",
            "        if not link.startswith(self.index_url):",
            "            return NO_MATCH_SENTINEL",
            "",
            "        parts = list(map(urllib.parse.unquote, link[len(self.index_url) :].split('/')))",
            "        if len(parts) != 2 or '#' in parts[1]:",
            "            return NO_MATCH_SENTINEL",
            "",
            "        # it's a package page, sanitize and index it",
            "        pkg = safe_name(parts[0])",
            "        ver = safe_version(parts[1])",
            "        self.package_pages.setdefault(pkg.lower(), {})[link] = True",
            "        return to_filename(pkg), to_filename(ver)",
            "",
            "    def process_index(self, url, page):",
            "        \"\"\"Process the contents of a PyPI page\"\"\"",
            "",
            "        # process an index page into the package-page index",
            "        for match in HREF.finditer(page):",
            "            try:",
            "                self._scan(urllib.parse.urljoin(url, htmldecode(match.group(1))))",
            "            except ValueError:",
            "                pass",
            "",
            "        pkg, ver = self._scan(url)  # ensure this page is in the page index",
            "        if not pkg:",
            "            return \"\"  # no sense double-scanning non-package pages",
            "",
            "        # process individual package page",
            "        for new_url in find_external_links(url, page):",
            "            # Process the found URL",
            "            base, frag = egg_info_for_url(new_url)",
            "            if base.endswith('.py') and not frag:",
            "                if ver:",
            "                    new_url += '#egg=%s-%s' % (pkg, ver)",
            "                else:",
            "                    self.need_version_info(url)",
            "            self.scan_url(new_url)",
            "",
            "        return PYPI_MD5.sub(",
            "            lambda m: '<a href=\"%s#md5=%s\">%s</a>' % m.group(1, 3, 2), page",
            "        )",
            "",
            "    def need_version_info(self, url):",
            "        self.scan_all(",
            "            \"Page at %s links to .py file(s) without version info; an index \"",
            "            \"scan is required.\",",
            "            url,",
            "        )",
            "",
            "    def scan_all(self, msg=None, *args):",
            "        if self.index_url not in self.fetched_urls:",
            "            if msg:",
            "                self.warn(msg, *args)",
            "            self.info(\"Scanning index of all packages (this may take a while)\")",
            "        self.scan_url(self.index_url)",
            "",
            "    def find_packages(self, requirement):",
            "        self.scan_url(self.index_url + requirement.unsafe_name + '/')",
            "",
            "        if not self.package_pages.get(requirement.key):",
            "            # Fall back to safe version of the name",
            "            self.scan_url(self.index_url + requirement.project_name + '/')",
            "",
            "        if not self.package_pages.get(requirement.key):",
            "            # We couldn't find the target package, so search the index page too",
            "            self.not_found_in_index(requirement)",
            "",
            "        for url in list(self.package_pages.get(requirement.key, ())):",
            "            # scan each page that might be related to the desired package",
            "            self.scan_url(url)",
            "",
            "    def obtain(self, requirement, installer=None):",
            "        self.prescan()",
            "        self.find_packages(requirement)",
            "        for dist in self[requirement.key]:",
            "            if dist in requirement:",
            "                return dist",
            "            self.debug(\"%s does not match %s\", requirement, dist)",
            "        return super().obtain(requirement, installer)",
            "",
            "    def check_hash(self, checker, filename, tfp):",
            "        \"\"\"",
            "        checker is a ContentChecker",
            "        \"\"\"",
            "        checker.report(self.debug, \"Validating %%s checksum for %s\" % filename)",
            "        if not checker.is_valid():",
            "            tfp.close()",
            "            os.unlink(filename)",
            "            raise DistutilsError(",
            "                \"%s validation failed for %s; \"",
            "                \"possible download problem?\"",
            "                % (checker.hash.name, os.path.basename(filename))",
            "            )",
            "",
            "    def add_find_links(self, urls):",
            "        \"\"\"Add `urls` to the list that will be prescanned for searches\"\"\"",
            "        for url in urls:",
            "            if (",
            "                self.to_scan is None  # if we have already \"gone online\"",
            "                or not URL_SCHEME(url)  # or it's a local file/directory",
            "                or url.startswith('file:')",
            "                or list(distros_for_url(url))  # or a direct package link",
            "            ):",
            "                # then go ahead and process it now",
            "                self.scan_url(url)",
            "            else:",
            "                # otherwise, defer retrieval till later",
            "                self.to_scan.append(url)",
            "",
            "    def prescan(self):",
            "        \"\"\"Scan urls scheduled for prescanning (e.g. --find-links)\"\"\"",
            "        if self.to_scan:",
            "            list(map(self.scan_url, self.to_scan))",
            "        self.to_scan = None  # from now on, go ahead and process immediately",
            "",
            "    def not_found_in_index(self, requirement):",
            "        if self[requirement.key]:  # we've seen at least one distro",
            "            meth, msg = self.info, \"Couldn't retrieve index page for %r\"",
            "        else:  # no distros seen for this name, might be misspelled",
            "            meth, msg = (",
            "                self.warn,",
            "                \"Couldn't find index page for %r (maybe misspelled?)\",",
            "            )",
            "        meth(msg, requirement.unsafe_name)",
            "        self.scan_all()",
            "",
            "    def download(self, spec, tmpdir):",
            "        \"\"\"Locate and/or download `spec` to `tmpdir`, returning a local path",
            "",
            "        `spec` may be a ``Requirement`` object, or a string containing a URL,",
            "        an existing local filename, or a project/version requirement spec",
            "        (i.e. the string form of a ``Requirement`` object).  If it is the URL",
            "        of a .py file with an unambiguous ``#egg=name-version`` tag (i.e., one",
            "        that escapes ``-`` as ``_`` throughout), a trivial ``setup.py`` is",
            "        automatically created alongside the downloaded file.",
            "",
            "        If `spec` is a ``Requirement`` object or a string containing a",
            "        project/version requirement spec, this method returns the location of",
            "        a matching distribution (possibly after downloading it to `tmpdir`).",
            "        If `spec` is a locally existing file or directory name, it is simply",
            "        returned unchanged.  If `spec` is a URL, it is downloaded to a subpath",
            "        of `tmpdir`, and the local filename is returned.  Various errors may be",
            "        raised if a problem occurs during downloading.",
            "        \"\"\"",
            "        if not isinstance(spec, Requirement):",
            "            scheme = URL_SCHEME(spec)",
            "            if scheme:",
            "                # It's a url, download it to tmpdir",
            "                found = self._download_url(spec, tmpdir)",
            "                base, fragment = egg_info_for_url(spec)",
            "                if base.endswith('.py'):",
            "                    found = self.gen_setup(found, fragment, tmpdir)",
            "                return found",
            "            elif os.path.exists(spec):",
            "                # Existing file or directory, just return it",
            "                return spec",
            "            else:",
            "                spec = parse_requirement_arg(spec)",
            "        return getattr(self.fetch_distribution(spec, tmpdir), 'location', None)",
            "",
            "    def fetch_distribution(  # noqa: C901  # is too complex (14)  # FIXME",
            "        self,",
            "        requirement,",
            "        tmpdir,",
            "        force_scan=False,",
            "        source=False,",
            "        develop_ok=False,",
            "        local_index=None,",
            "    ):",
            "        \"\"\"Obtain a distribution suitable for fulfilling `requirement`",
            "",
            "        `requirement` must be a ``pkg_resources.Requirement`` instance.",
            "        If necessary, or if the `force_scan` flag is set, the requirement is",
            "        searched for in the (online) package index as well as the locally",
            "        installed packages.  If a distribution matching `requirement` is found,",
            "        the returned distribution's ``location`` is the value you would have",
            "        gotten from calling the ``download()`` method with the matching",
            "        distribution's URL or filename.  If no matching distribution is found,",
            "        ``None`` is returned.",
            "",
            "        If the `source` flag is set, only source distributions and source",
            "        checkout links will be considered.  Unless the `develop_ok` flag is",
            "        set, development and system eggs (i.e., those using the ``.egg-info``",
            "        format) will be ignored.",
            "        \"\"\"",
            "        # process a Requirement",
            "        self.info(\"Searching for %s\", requirement)",
            "        skipped = {}",
            "        dist = None",
            "",
            "        def find(req, env=None):",
            "            if env is None:",
            "                env = self",
            "            # Find a matching distribution; may be called more than once",
            "",
            "            for dist in env[req.key]:",
            "                if dist.precedence == DEVELOP_DIST and not develop_ok:",
            "                    if dist not in skipped:",
            "                        self.warn(",
            "                            \"Skipping development or system egg: %s\",",
            "                            dist,",
            "                        )",
            "                        skipped[dist] = 1",
            "                    continue",
            "",
            "                test = dist in req and (dist.precedence <= SOURCE_DIST or not source)",
            "                if test:",
            "                    loc = self.download(dist.location, tmpdir)",
            "                    dist.download_location = loc",
            "                    if os.path.exists(dist.download_location):",
            "                        return dist",
            "",
            "            return None",
            "",
            "        if force_scan:",
            "            self.prescan()",
            "            self.find_packages(requirement)",
            "            dist = find(requirement)",
            "",
            "        if not dist and local_index is not None:",
            "            dist = find(requirement, local_index)",
            "",
            "        if dist is None:",
            "            if self.to_scan is not None:",
            "                self.prescan()",
            "            dist = find(requirement)",
            "",
            "        if dist is None and not force_scan:",
            "            self.find_packages(requirement)",
            "            dist = find(requirement)",
            "",
            "        if dist is None:",
            "            self.warn(",
            "                \"No local packages or working download links found for %s%s\",",
            "                (source and \"a source distribution of \" or \"\"),",
            "                requirement,",
            "            )",
            "            return None",
            "        else:",
            "            self.info(\"Best match: %s\", dist)",
            "            return dist.clone(location=dist.download_location)",
            "",
            "    def fetch(self, requirement, tmpdir, force_scan=False, source=False):",
            "        \"\"\"Obtain a file suitable for fulfilling `requirement`",
            "",
            "        DEPRECATED; use the ``fetch_distribution()`` method now instead.  For",
            "        backward compatibility, this routine is identical but returns the",
            "        ``location`` of the downloaded distribution instead of a distribution",
            "        object.",
            "        \"\"\"",
            "        dist = self.fetch_distribution(requirement, tmpdir, force_scan, source)",
            "        if dist is not None:",
            "            return dist.location",
            "        return None",
            "",
            "    def gen_setup(self, filename, fragment, tmpdir):",
            "        match = EGG_FRAGMENT.match(fragment)",
            "        dists = (",
            "            match",
            "            and [",
            "                d",
            "                for d in interpret_distro_name(filename, match.group(1), None)",
            "                if d.version",
            "            ]",
            "            or []",
            "        )",
            "",
            "        if len(dists) == 1:  # unambiguous ``#egg`` fragment",
            "            basename = os.path.basename(filename)",
            "",
            "            # Make sure the file has been downloaded to the temp dir.",
            "            if os.path.dirname(filename) != tmpdir:",
            "                dst = os.path.join(tmpdir, basename)",
            "                if not (os.path.exists(dst) and os.path.samefile(filename, dst)):",
            "                    shutil.copy2(filename, dst)",
            "                    filename = dst",
            "",
            "            with open(os.path.join(tmpdir, 'setup.py'), 'w', encoding=\"utf-8\") as file:",
            "                file.write(",
            "                    \"from setuptools import setup\\n\"",
            "                    \"setup(name=%r, version=%r, py_modules=[%r])\\n\"",
            "                    % (",
            "                        dists[0].project_name,",
            "                        dists[0].version,",
            "                        os.path.splitext(basename)[0],",
            "                    )",
            "                )",
            "            return filename",
            "",
            "        elif match:",
            "            raise DistutilsError(",
            "                \"Can't unambiguously interpret project/version identifier %r; \"",
            "                \"any dashes in the name or version should be escaped using \"",
            "                \"underscores. %r\" % (fragment, dists)",
            "            )",
            "        else:",
            "            raise DistutilsError(",
            "                \"Can't process plain .py files without an '#egg=name-version'\"",
            "                \" suffix to enable automatic setup script generation.\"",
            "            )",
            "",
            "    dl_blocksize = 8192",
            "",
            "    def _download_to(self, url, filename):",
            "        self.info(\"Downloading %s\", url)",
            "        # Download the file",
            "        fp = None",
            "        try:",
            "            checker = HashChecker.from_url(url)",
            "            fp = self.open_url(url)",
            "            if isinstance(fp, urllib.error.HTTPError):",
            "                raise DistutilsError(",
            "                    \"Can't download %s: %s %s\" % (url, fp.code, fp.msg)",
            "                )",
            "            headers = fp.info()",
            "            blocknum = 0",
            "            bs = self.dl_blocksize",
            "            size = -1",
            "            if \"content-length\" in headers:",
            "                # Some servers return multiple Content-Length headers :(",
            "                sizes = headers.get_all('Content-Length')",
            "                size = max(map(int, sizes))",
            "                self.reporthook(url, filename, blocknum, bs, size)",
            "            with open(filename, 'wb') as tfp:",
            "                while True:",
            "                    block = fp.read(bs)",
            "                    if block:",
            "                        checker.feed(block)",
            "                        tfp.write(block)",
            "                        blocknum += 1",
            "                        self.reporthook(url, filename, blocknum, bs, size)",
            "                    else:",
            "                        break",
            "                self.check_hash(checker, filename, tfp)",
            "            return headers",
            "        finally:",
            "            if fp:",
            "                fp.close()",
            "",
            "    def reporthook(self, url, filename, blocknum, blksize, size):",
            "        pass  # no-op",
            "",
            "    # FIXME:",
            "    def open_url(self, url, warning=None):  # noqa: C901  # is too complex (12)",
            "        if url.startswith('file:'):",
            "            return local_open(url)",
            "        try:",
            "            return open_with_auth(url, self.opener)",
            "        except (ValueError, http.client.InvalidURL) as v:",
            "            msg = ' '.join([str(arg) for arg in v.args])",
            "            if warning:",
            "                self.warn(warning, msg)",
            "            else:",
            "                raise DistutilsError('%s %s' % (url, msg)) from v",
            "        except urllib.error.HTTPError as v:",
            "            return v",
            "        except urllib.error.URLError as v:",
            "            if warning:",
            "                self.warn(warning, v.reason)",
            "            else:",
            "                raise DistutilsError(",
            "                    \"Download error for %s: %s\" % (url, v.reason)",
            "                ) from v",
            "        except http.client.BadStatusLine as v:",
            "            if warning:",
            "                self.warn(warning, v.line)",
            "            else:",
            "                raise DistutilsError(",
            "                    '%s returned a bad status line. The server might be '",
            "                    'down, %s' % (url, v.line)",
            "                ) from v",
            "        except (http.client.HTTPException, OSError) as v:",
            "            if warning:",
            "                self.warn(warning, v)",
            "            else:",
            "                raise DistutilsError(\"Download error for %s: %s\" % (url, v)) from v",
            "",
            "    def _download_url(self, url, tmpdir):",
            "        # Determine download filename",
            "        #",
            "        name, fragment = egg_info_for_url(url)",
            "        if name:",
            "            while '..' in name:",
            "                name = name.replace('..', '.').replace('\\\\', '_')",
            "        else:",
            "            name = \"__downloaded__\"  # default if URL has no path contents",
            "",
            "        if name.endswith('.egg.zip'):",
            "            name = name[:-4]  # strip the extra .zip before download",
            "",
            "        filename = os.path.join(tmpdir, name)",
            "",
            "        return self._download_vcs(url, filename) or self._download_other(url, filename)",
            "",
            "    @staticmethod",
            "    def _resolve_vcs(url):",
            "        \"\"\"",
            "        >>> rvcs = PackageIndex._resolve_vcs",
            "        >>> rvcs('git+http://foo/bar')",
            "        'git'",
            "        >>> rvcs('hg+https://foo/bar')",
            "        'hg'",
            "        >>> rvcs('git:myhost')",
            "        'git'",
            "        >>> rvcs('hg:myhost')",
            "        >>> rvcs('http://foo/bar')",
            "        \"\"\"",
            "        scheme = urllib.parse.urlsplit(url).scheme",
            "        pre, sep, post = scheme.partition('+')",
            "        # svn and git have their own protocol; hg does not",
            "        allowed = set(['svn', 'git'] + ['hg'] * bool(sep))",
            "        return next(iter({pre} & allowed), None)",
            "",
            "    def _download_vcs(self, url, spec_filename):",
            "        vcs = self._resolve_vcs(url)",
            "        if not vcs:",
            "            return",
            "        if vcs == 'svn':",
            "            raise DistutilsError(",
            "                f\"Invalid config, SVN download is not supported: {url}\"",
            "            )",
            "",
            "        filename, _, _ = spec_filename.partition('#')",
            "        url, rev = self._vcs_split_rev_from_url(url)",
            "",
            "        self.info(f\"Doing {vcs} clone from {url} to {filename}\")",
            "        subprocess.check_call([vcs, 'clone', '--quiet', url, filename])",
            "",
            "        co_commands = dict(",
            "            git=[vcs, '-C', filename, 'checkout', '--quiet', rev],",
            "            hg=[vcs, '--cwd', filename, 'up', '-C', '-r', rev, '-q'],",
            "        )",
            "        if rev is not None:",
            "            self.info(f\"Checking out {rev}\")",
            "            subprocess.check_call(co_commands[vcs])",
            "",
            "        return filename",
            "",
            "    def _download_other(self, url, filename):",
            "        scheme = urllib.parse.urlsplit(url).scheme",
            "        if scheme == 'file':  # pragma: no cover",
            "            return urllib.request.url2pathname(urllib.parse.urlparse(url).path)",
            "        # raise error if not allowed",
            "        self.url_ok(url, True)",
            "        return self._attempt_download(url, filename)",
            "",
            "    def scan_url(self, url):",
            "        self.process_url(url, True)",
            "",
            "    def _attempt_download(self, url, filename):",
            "        headers = self._download_to(url, filename)",
            "        if 'html' in headers.get('content-type', '').lower():",
            "            return self._invalid_download_html(url, headers, filename)",
            "        else:",
            "            return filename",
            "",
            "    def _invalid_download_html(self, url, headers, filename):",
            "        os.unlink(filename)",
            "        raise DistutilsError(f\"Unexpected HTML page found at {url}\")",
            "",
            "    @staticmethod",
            "    def _vcs_split_rev_from_url(url):",
            "        \"\"\"",
            "        Given a possible VCS URL, return a clean URL and resolved revision if any.",
            "",
            "        >>> vsrfu = PackageIndex._vcs_split_rev_from_url",
            "        >>> vsrfu('git+https://github.com/pypa/setuptools@v69.0.0#egg-info=setuptools')",
            "        ('https://github.com/pypa/setuptools', 'v69.0.0')",
            "        >>> vsrfu('git+https://github.com/pypa/setuptools#egg-info=setuptools')",
            "        ('https://github.com/pypa/setuptools', None)",
            "        >>> vsrfu('http://foo/bar')",
            "        ('http://foo/bar', None)",
            "        \"\"\"",
            "        parts = urllib.parse.urlsplit(url)",
            "",
            "        clean_scheme = parts.scheme.split('+', 1)[-1]",
            "",
            "        # Some fragment identification fails",
            "        no_fragment_path, _, _ = parts.path.partition('#')",
            "",
            "        pre, sep, post = no_fragment_path.rpartition('@')",
            "        clean_path, rev = (pre, post) if sep else (post, None)",
            "",
            "        resolved = parts._replace(",
            "            scheme=clean_scheme,",
            "            path=clean_path,",
            "            # discard the fragment",
            "            fragment='',",
            "        ).geturl()",
            "",
            "        return resolved, rev",
            "",
            "    def debug(self, msg, *args):",
            "        log.debug(msg, *args)",
            "",
            "    def info(self, msg, *args):",
            "        log.info(msg, *args)",
            "",
            "    def warn(self, msg, *args):",
            "        log.warn(msg, *args)",
            "",
            "",
            "# This pattern matches a character entity reference (a decimal numeric",
            "# references, a hexadecimal numeric reference, or a named reference).",
            "entity_sub = re.compile(r'&(#(\\d+|x[\\da-fA-F]+)|[\\w.:-]+);?').sub",
            "",
            "",
            "def decode_entity(match):",
            "    what = match.group(0)",
            "    return html.unescape(what)",
            "",
            "",
            "def htmldecode(text):",
            "    \"\"\"",
            "    Decode HTML entities in the given text.",
            "",
            "    >>> htmldecode(",
            "    ...     'https://../package_name-0.1.2.tar.gz'",
            "    ...     '?tokena=A&amp;tokenb=B\">package_name-0.1.2.tar.gz')",
            "    'https://../package_name-0.1.2.tar.gz?tokena=A&tokenb=B\">package_name-0.1.2.tar.gz'",
            "    \"\"\"",
            "    return entity_sub(decode_entity, text)",
            "",
            "",
            "def socket_timeout(timeout=15):",
            "    def _socket_timeout(func):",
            "        def _socket_timeout(*args, **kwargs):",
            "            old_timeout = socket.getdefaulttimeout()",
            "            socket.setdefaulttimeout(timeout)",
            "            try:",
            "                return func(*args, **kwargs)",
            "            finally:",
            "                socket.setdefaulttimeout(old_timeout)",
            "",
            "        return _socket_timeout",
            "",
            "    return _socket_timeout",
            "",
            "",
            "def _encode_auth(auth):",
            "    \"\"\"",
            "    Encode auth from a URL suitable for an HTTP header.",
            "    >>> str(_encode_auth('username%3Apassword'))",
            "    'dXNlcm5hbWU6cGFzc3dvcmQ='",
            "",
            "    Long auth strings should not cause a newline to be inserted.",
            "    >>> long_auth = 'username:' + 'password'*10",
            "    >>> chr(10) in str(_encode_auth(long_auth))",
            "    False",
            "    \"\"\"",
            "    auth_s = urllib.parse.unquote(auth)",
            "    # convert to bytes",
            "    auth_bytes = auth_s.encode()",
            "    encoded_bytes = base64.b64encode(auth_bytes)",
            "    # convert back to a string",
            "    encoded = encoded_bytes.decode()",
            "    # strip the trailing carriage return",
            "    return encoded.replace('\\n', '')",
            "",
            "",
            "class Credential:",
            "    \"\"\"",
            "    A username/password pair. Use like a namedtuple.",
            "    \"\"\"",
            "",
            "    def __init__(self, username, password):",
            "        self.username = username",
            "        self.password = password",
            "",
            "    def __iter__(self):",
            "        yield self.username",
            "        yield self.password",
            "",
            "    def __str__(self):",
            "        return '%(username)s:%(password)s' % vars(self)",
            "",
            "",
            "class PyPIConfig(configparser.RawConfigParser):",
            "    def __init__(self):",
            "        \"\"\"",
            "        Load from ~/.pypirc",
            "        \"\"\"",
            "        defaults = dict.fromkeys(['username', 'password', 'repository'], '')",
            "        super().__init__(defaults)",
            "",
            "        rc = os.path.join(os.path.expanduser('~'), '.pypirc')",
            "        if os.path.exists(rc):",
            "            _cfg_read_utf8_with_fallback(self, rc)",
            "",
            "    @property",
            "    def creds_by_repository(self):",
            "        sections_with_repositories = [",
            "            section",
            "            for section in self.sections()",
            "            if self.get(section, 'repository').strip()",
            "        ]",
            "",
            "        return dict(map(self._get_repo_cred, sections_with_repositories))",
            "",
            "    def _get_repo_cred(self, section):",
            "        repo = self.get(section, 'repository').strip()",
            "        return repo, Credential(",
            "            self.get(section, 'username').strip(),",
            "            self.get(section, 'password').strip(),",
            "        )",
            "",
            "    def find_credential(self, url):",
            "        \"\"\"",
            "        If the URL indicated appears to be a repository defined in this",
            "        config, return the credential for that repository.",
            "        \"\"\"",
            "        for repository, cred in self.creds_by_repository.items():",
            "            if url.startswith(repository):",
            "                return cred",
            "        return None",
            "",
            "",
            "def open_with_auth(url, opener=urllib.request.urlopen):",
            "    \"\"\"Open a urllib2 request, handling HTTP authentication\"\"\"",
            "",
            "    parsed = urllib.parse.urlparse(url)",
            "    scheme, netloc, path, params, query, frag = parsed",
            "",
            "    # Double scheme does not raise on macOS as revealed by a",
            "    # failing test. We would expect \"nonnumeric port\". Refs #20.",
            "    if netloc.endswith(':'):",
            "        raise http.client.InvalidURL(\"nonnumeric port: ''\")",
            "",
            "    if scheme in ('http', 'https'):",
            "        auth, address = _splituser(netloc)",
            "    else:",
            "        auth = None",
            "",
            "    if not auth:",
            "        cred = PyPIConfig().find_credential(url)",
            "        if cred:",
            "            auth = str(cred)",
            "            info = cred.username, url",
            "            log.info('Authenticating as %s for %s (from .pypirc)', *info)",
            "",
            "    if auth:",
            "        auth = \"Basic \" + _encode_auth(auth)",
            "        parts = scheme, address, path, params, query, frag",
            "        new_url = urllib.parse.urlunparse(parts)",
            "        request = urllib.request.Request(new_url)",
            "        request.add_header(\"Authorization\", auth)",
            "    else:",
            "        request = urllib.request.Request(url)",
            "",
            "    request.add_header('User-Agent', user_agent)",
            "    fp = opener(request)",
            "",
            "    if auth:",
            "        # Put authentication info back into request URL if same host,",
            "        # so that links found on the page will work",
            "        s2, h2, path2, param2, query2, frag2 = urllib.parse.urlparse(fp.url)",
            "        if s2 == scheme and h2 == address:",
            "            parts = s2, netloc, path2, param2, query2, frag2",
            "            fp.url = urllib.parse.urlunparse(parts)",
            "",
            "    return fp",
            "",
            "",
            "# copy of urllib.parse._splituser from Python 3.8",
            "def _splituser(host):",
            "    \"\"\"splituser('user[:passwd]@host[:port]')",
            "    --> 'user[:passwd]', 'host[:port]'.\"\"\"",
            "    user, delim, host = host.rpartition('@')",
            "    return (user if delim else None), host",
            "",
            "",
            "# adding a timeout to avoid freezing package_index",
            "open_with_auth = socket_timeout(_SOCKET_TIMEOUT)(open_with_auth)",
            "",
            "",
            "def fix_sf_url(url):",
            "    return url  # backward compatibility",
            "",
            "",
            "def local_open(url):",
            "    \"\"\"Read a local path, with special support for directories\"\"\"",
            "    scheme, server, path, param, query, frag = urllib.parse.urlparse(url)",
            "    filename = urllib.request.url2pathname(path)",
            "    if os.path.isfile(filename):",
            "        return urllib.request.urlopen(url)",
            "    elif path.endswith('/') and os.path.isdir(filename):",
            "        files = []",
            "        for f in os.listdir(filename):",
            "            filepath = os.path.join(filename, f)",
            "            if f == 'index.html':",
            "                body = _read_utf8_with_fallback(filepath)",
            "                break",
            "            elif os.path.isdir(filepath):",
            "                f += '/'",
            "            files.append('<a href=\"{name}\">{name}</a>'.format(name=f))",
            "        else:",
            "            tmpl = (",
            "                \"<html><head><title>{url}</title>\" \"</head><body>{files}</body></html>\"",
            "            )",
            "            body = tmpl.format(url=url, files='\\n'.join(files))",
            "        status, message = 200, \"OK\"",
            "    else:",
            "        status, message, body = 404, \"Path not found\", \"Not found\"",
            "",
            "    headers = {'content-type': 'text/html'}",
            "    body_stream = io.StringIO(body)",
            "    return urllib.error.HTTPError(url, status, message, headers, body_stream)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "590": [
                "PackageIndex",
                "download"
            ],
            "819": [
                "PackageIndex",
                "_download_url"
            ],
            "834": [
                "PackageIndex",
                "_download_url"
            ],
            "835": [
                "PackageIndex",
                "_download_url"
            ],
            "836": [
                "PackageIndex",
                "_download_url"
            ],
            "837": [
                "PackageIndex",
                "_download_url"
            ],
            "838": [
                "PackageIndex",
                "_download_url"
            ],
            "839": [
                "PackageIndex",
                "_download_url"
            ],
            "840": [
                "PackageIndex",
                "_download_url"
            ],
            "841": [
                "PackageIndex",
                "_download_url"
            ],
            "842": [
                "PackageIndex",
                "_download_url"
            ],
            "843": [
                "PackageIndex",
                "_download_url"
            ],
            "844": [
                "PackageIndex",
                "_download_url"
            ],
            "845": [
                "PackageIndex",
                "_download_url"
            ],
            "846": [
                "PackageIndex",
                "_download_url"
            ],
            "862": [
                "PackageIndex",
                "_download_svn"
            ],
            "863": [
                "PackageIndex",
                "_download_svn"
            ],
            "864": [
                "PackageIndex"
            ],
            "866": [
                "PackageIndex",
                "_vcs_split_rev_from_url"
            ],
            "867": [
                "PackageIndex",
                "_vcs_split_rev_from_url"
            ],
            "869": [
                "PackageIndex",
                "_vcs_split_rev_from_url"
            ],
            "872": [
                "PackageIndex",
                "_vcs_split_rev_from_url"
            ],
            "873": [
                "PackageIndex",
                "_vcs_split_rev_from_url"
            ],
            "874": [
                "PackageIndex",
                "_vcs_split_rev_from_url"
            ],
            "875": [
                "PackageIndex",
                "_vcs_split_rev_from_url"
            ],
            "876": [
                "PackageIndex",
                "_vcs_split_rev_from_url"
            ],
            "877": [
                "PackageIndex",
                "_vcs_split_rev_from_url"
            ],
            "878": [
                "PackageIndex",
                "_vcs_split_rev_from_url"
            ],
            "879": [
                "PackageIndex",
                "_vcs_split_rev_from_url"
            ],
            "880": [
                "PackageIndex",
                "_vcs_split_rev_from_url"
            ],
            "881": [
                "PackageIndex",
                "_vcs_split_rev_from_url"
            ],
            "882": [
                "PackageIndex"
            ],
            "883": [
                "PackageIndex",
                "_download_git"
            ],
            "884": [
                "PackageIndex",
                "_download_git"
            ],
            "885": [
                "PackageIndex",
                "_download_git"
            ],
            "886": [
                "PackageIndex",
                "_download_git"
            ],
            "887": [
                "PackageIndex",
                "_download_git"
            ],
            "888": [
                "PackageIndex",
                "_download_git"
            ],
            "889": [
                "PackageIndex",
                "_download_git"
            ],
            "890": [
                "PackageIndex",
                "_download_git"
            ],
            "891": [
                "PackageIndex",
                "_download_git"
            ],
            "892": [
                "PackageIndex",
                "_download_git"
            ],
            "893": [
                "PackageIndex",
                "_download_git"
            ],
            "894": [
                "PackageIndex",
                "_download_git"
            ],
            "895": [
                "PackageIndex",
                "_download_git"
            ],
            "896": [
                "PackageIndex",
                "_download_git"
            ],
            "897": [
                "PackageIndex",
                "_download_git"
            ],
            "898": [
                "PackageIndex",
                "_download_git"
            ],
            "900": [
                "PackageIndex",
                "_download_git"
            ],
            "902": [
                "PackageIndex",
                "_download_hg"
            ],
            "903": [
                "PackageIndex",
                "_download_hg"
            ],
            "904": [
                "PackageIndex",
                "_download_hg"
            ],
            "906": [
                "PackageIndex",
                "_download_hg"
            ],
            "907": [
                "PackageIndex",
                "_download_hg"
            ],
            "908": [
                "PackageIndex",
                "_download_hg"
            ],
            "909": [
                "PackageIndex",
                "_download_hg"
            ],
            "910": [
                "PackageIndex",
                "_download_hg"
            ],
            "911": [
                "PackageIndex",
                "_download_hg"
            ],
            "912": [
                "PackageIndex",
                "_download_hg"
            ],
            "913": [
                "PackageIndex",
                "_download_hg"
            ],
            "914": [
                "PackageIndex",
                "_download_hg"
            ],
            "915": [
                "PackageIndex",
                "_download_hg"
            ],
            "916": [
                "PackageIndex",
                "_download_hg"
            ],
            "917": [
                "PackageIndex",
                "_download_hg"
            ],
            "918": [
                "PackageIndex",
                "_download_hg"
            ],
            "919": [
                "PackageIndex",
                "_download_hg"
            ]
        },
        "addLocation": []
    },
    "setuptools/tests/test_packageindex.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import urllib.error"
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import http.client"
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from inspect import cleandoc"
            },
            "3": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from unittest import mock"
            },
            "4": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " import pytest"
            },
            "6": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "             assert dists[0].version == ''"
            },
            "8": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "             assert dists[1].version == vc"
            },
            "9": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 172,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def test_download_git_with_rev(self, tmpdir):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+    def test_download_git_with_rev(self, tmp_path, fp):"
            },
            "12": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "         url = 'git+https://github.example/group/project@master#egg=foo'"
            },
            "13": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "         index = setuptools.package_index.PackageIndex()"
            },
            "14": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 176,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        with mock.patch(\"os.system\") as os_system_mock:"
            },
            "16": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            result = index.download(url, str(tmpdir))"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+        expected_dir = tmp_path / 'project@master'"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+        fp.register(["
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+            'git',"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+            'clone',"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+            '--quiet',"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+            'https://github.example/group/project',"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+            expected_dir,"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+        ])"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+        fp.register(['git', '-C', expected_dir, 'checkout', '--quiet', 'master'])"
            },
            "26": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 186,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        os_system_mock.assert_called()"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+        result = index.download(url, tmp_path)"
            },
            "29": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 188,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        expected_dir = str(tmpdir / 'project@master')"
            },
            "31": {
                "beforePatchRowNumber": 184,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        expected = ("
            },
            "32": {
                "beforePatchRowNumber": 185,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            'git clone --quiet ' 'https://github.example/group/project {expected_dir}'"
            },
            "33": {
                "beforePatchRowNumber": 186,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ).format(**locals())"
            },
            "34": {
                "beforePatchRowNumber": 187,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        first_call_args = os_system_mock.call_args_list[0][0]"
            },
            "35": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        assert first_call_args == (expected,)"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+        assert result == str(expected_dir)"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+        assert len(fp.calls) == 2"
            },
            "38": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 191,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        tmpl = 'git -C {expected_dir} checkout --quiet master'"
            },
            "40": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        expected = tmpl.format(**locals())"
            },
            "41": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        assert os_system_mock.call_args_list[1][0] == (expected,)"
            },
            "42": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        assert result == expected_dir"
            },
            "43": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "44": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def test_download_git_no_rev(self, tmpdir):"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+    def test_download_git_no_rev(self, tmp_path, fp):"
            },
            "46": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 193,
                "PatchRowcode": "         url = 'git+https://github.example/group/project#egg=foo'"
            },
            "47": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 194,
                "PatchRowcode": "         index = setuptools.package_index.PackageIndex()"
            },
            "48": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": 195,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        with mock.patch(\"os.system\") as os_system_mock:"
            },
            "50": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            result = index.download(url, str(tmpdir))"
            },
            "51": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "52": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        os_system_mock.assert_called()"
            },
            "53": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "54": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        expected_dir = str(tmpdir / 'project')"
            },
            "55": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        expected = ("
            },
            "56": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            'git clone --quiet ' 'https://github.example/group/project {expected_dir}'"
            },
            "57": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ).format(**locals())"
            },
            "58": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        os_system_mock.assert_called_once_with(expected)"
            },
            "59": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "60": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def test_download_svn(self, tmpdir):"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+        expected_dir = tmp_path / 'project'"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+        fp.register(["
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+            'git',"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+            'clone',"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+            '--quiet',"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+            'https://github.example/group/project',"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+            expected_dir,"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+        ])"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+        index.download(url, tmp_path)"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+    def test_download_svn(self, tmp_path):"
            },
            "72": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 207,
                "PatchRowcode": "         url = 'svn+https://svn.example/project#egg=foo'"
            },
            "73": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": 208,
                "PatchRowcode": "         index = setuptools.package_index.PackageIndex()"
            },
            "74": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 209,
                "PatchRowcode": " "
            },
            "75": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 210,
                "PatchRowcode": "         msg = r\".*SVN download is not supported.*\""
            },
            "76": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "         with pytest.raises(distutils.errors.DistutilsError, match=msg):"
            },
            "77": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            index.download(url, str(tmpdir))"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+            index.download(url, tmp_path)"
            },
            "79": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 213,
                "PatchRowcode": " "
            },
            "80": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 214,
                "PatchRowcode": " "
            },
            "81": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 215,
                "PatchRowcode": " class TestContentCheckers:"
            }
        },
        "frontPatchFile": [
            "import distutils.errors",
            "import urllib.request",
            "import urllib.error",
            "import http.client",
            "from inspect import cleandoc",
            "from unittest import mock",
            "",
            "import pytest",
            "",
            "import setuptools.package_index",
            "",
            "",
            "class TestPackageIndex:",
            "    def test_regex(self):",
            "        hash_url = 'http://other_url?:action=show_md5&amp;'",
            "        hash_url += 'digest=0123456789abcdef0123456789abcdef'",
            "        doc = \"\"\"",
            "            <a href=\"http://some_url\">Name</a>",
            "            (<a title=\"MD5 hash\"",
            "            href=\"{hash_url}\">md5</a>)",
            "        \"\"\".lstrip().format(**locals())",
            "        assert setuptools.package_index.PYPI_MD5.match(doc)",
            "",
            "    def test_bad_url_bad_port(self):",
            "        index = setuptools.package_index.PackageIndex()",
            "        url = 'http://127.0.0.1:0/nonesuch/test_package_index'",
            "        try:",
            "            v = index.open_url(url)",
            "        except Exception as exc:",
            "            assert url in str(exc)",
            "        else:",
            "            assert isinstance(v, urllib.error.HTTPError)",
            "",
            "    def test_bad_url_typo(self):",
            "        # issue 16",
            "        # easy_install inquant.contentmirror.plone breaks because of a typo",
            "        # in its home URL",
            "        index = setuptools.package_index.PackageIndex(hosts=('www.example.com',))",
            "",
            "        url = (",
            "            'url:%20https://svn.plone.org/svn'",
            "            '/collective/inquant.contentmirror.plone/trunk'",
            "        )",
            "        try:",
            "            v = index.open_url(url)",
            "        except Exception as exc:",
            "            assert url in str(exc)",
            "        else:",
            "            assert isinstance(v, urllib.error.HTTPError)",
            "",
            "    def test_bad_url_bad_status_line(self):",
            "        index = setuptools.package_index.PackageIndex(hosts=('www.example.com',))",
            "",
            "        def _urlopen(*args):",
            "            raise http.client.BadStatusLine('line')",
            "",
            "        index.opener = _urlopen",
            "        url = 'http://example.com'",
            "        try:",
            "            index.open_url(url)",
            "        except Exception as exc:",
            "            assert 'line' in str(exc)",
            "        else:",
            "            raise AssertionError('Should have raise here!')",
            "",
            "    def test_bad_url_double_scheme(self):",
            "        \"\"\"",
            "        A bad URL with a double scheme should raise a DistutilsError.",
            "        \"\"\"",
            "        index = setuptools.package_index.PackageIndex(hosts=('www.example.com',))",
            "",
            "        # issue 20",
            "        url = 'http://http://svn.pythonpaste.org/Paste/wphp/trunk'",
            "        try:",
            "            index.open_url(url)",
            "        except distutils.errors.DistutilsError as error:",
            "            msg = str(error)",
            "            assert (",
            "                'nonnumeric port' in msg",
            "                or 'getaddrinfo failed' in msg",
            "                or 'Name or service not known' in msg",
            "            )",
            "            return",
            "        raise RuntimeError(\"Did not raise\")",
            "",
            "    def test_url_ok(self):",
            "        index = setuptools.package_index.PackageIndex(hosts=('www.example.com',))",
            "        url = 'file:///tmp/test_package_index'",
            "        assert index.url_ok(url, True)",
            "",
            "    def test_parse_bdist_wininst(self):",
            "        parse = setuptools.package_index.parse_bdist_wininst",
            "",
            "        actual = parse('reportlab-2.5.win32-py2.4.exe')",
            "        expected = 'reportlab-2.5', '2.4', 'win32'",
            "        assert actual == expected",
            "",
            "        actual = parse('reportlab-2.5.win32.exe')",
            "        expected = 'reportlab-2.5', None, 'win32'",
            "        assert actual == expected",
            "",
            "        actual = parse('reportlab-2.5.win-amd64-py2.7.exe')",
            "        expected = 'reportlab-2.5', '2.7', 'win-amd64'",
            "        assert actual == expected",
            "",
            "        actual = parse('reportlab-2.5.win-amd64.exe')",
            "        expected = 'reportlab-2.5', None, 'win-amd64'",
            "        assert actual == expected",
            "",
            "    def test__vcs_split_rev_from_url(self):",
            "        \"\"\"",
            "        Test the basic usage of _vcs_split_rev_from_url",
            "        \"\"\"",
            "        vsrfu = setuptools.package_index.PackageIndex._vcs_split_rev_from_url",
            "        url, rev = vsrfu('https://example.com/bar@2995')",
            "        assert url == 'https://example.com/bar'",
            "        assert rev == '2995'",
            "",
            "    def test_local_index(self, tmpdir):",
            "        \"\"\"",
            "        local_open should be able to read an index from the file system.",
            "        \"\"\"",
            "        index_file = tmpdir / 'index.html'",
            "        with index_file.open('w') as f:",
            "            f.write('<div>content</div>')",
            "        url = 'file:' + urllib.request.pathname2url(str(tmpdir)) + '/'",
            "        res = setuptools.package_index.local_open(url)",
            "        assert 'content' in res.read()",
            "",
            "    def test_egg_fragment(self):",
            "        \"\"\"",
            "        EGG fragments must comply to PEP 440",
            "        \"\"\"",
            "        epoch = [",
            "            '',",
            "            '1!',",
            "        ]",
            "        releases = [",
            "            '0',",
            "            '0.0',",
            "            '0.0.0',",
            "        ]",
            "        pre = [",
            "            'a0',",
            "            'b0',",
            "            'rc0',",
            "        ]",
            "        post = ['.post0']",
            "        dev = [",
            "            '.dev0',",
            "        ]",
            "        local = [",
            "            ('', ''),",
            "            ('+ubuntu.0', '+ubuntu.0'),",
            "            ('+ubuntu-0', '+ubuntu.0'),",
            "            ('+ubuntu_0', '+ubuntu.0'),",
            "        ]",
            "        versions = [",
            "            [''.join([e, r, p, loc]) for loc in locs]",
            "            for e in epoch",
            "            for r in releases",
            "            for p in sum([pre, post, dev], [''])",
            "            for locs in local",
            "        ]",
            "        for v, vc in versions:",
            "            dists = list(",
            "                setuptools.package_index.distros_for_url(",
            "                    'http://example.com/example-foo.zip#egg=example-foo-' + v",
            "                )",
            "            )",
            "            assert dists[0].version == ''",
            "            assert dists[1].version == vc",
            "",
            "    def test_download_git_with_rev(self, tmpdir):",
            "        url = 'git+https://github.example/group/project@master#egg=foo'",
            "        index = setuptools.package_index.PackageIndex()",
            "",
            "        with mock.patch(\"os.system\") as os_system_mock:",
            "            result = index.download(url, str(tmpdir))",
            "",
            "        os_system_mock.assert_called()",
            "",
            "        expected_dir = str(tmpdir / 'project@master')",
            "        expected = (",
            "            'git clone --quiet ' 'https://github.example/group/project {expected_dir}'",
            "        ).format(**locals())",
            "        first_call_args = os_system_mock.call_args_list[0][0]",
            "        assert first_call_args == (expected,)",
            "",
            "        tmpl = 'git -C {expected_dir} checkout --quiet master'",
            "        expected = tmpl.format(**locals())",
            "        assert os_system_mock.call_args_list[1][0] == (expected,)",
            "        assert result == expected_dir",
            "",
            "    def test_download_git_no_rev(self, tmpdir):",
            "        url = 'git+https://github.example/group/project#egg=foo'",
            "        index = setuptools.package_index.PackageIndex()",
            "",
            "        with mock.patch(\"os.system\") as os_system_mock:",
            "            result = index.download(url, str(tmpdir))",
            "",
            "        os_system_mock.assert_called()",
            "",
            "        expected_dir = str(tmpdir / 'project')",
            "        expected = (",
            "            'git clone --quiet ' 'https://github.example/group/project {expected_dir}'",
            "        ).format(**locals())",
            "        os_system_mock.assert_called_once_with(expected)",
            "",
            "    def test_download_svn(self, tmpdir):",
            "        url = 'svn+https://svn.example/project#egg=foo'",
            "        index = setuptools.package_index.PackageIndex()",
            "",
            "        msg = r\".*SVN download is not supported.*\"",
            "        with pytest.raises(distutils.errors.DistutilsError, match=msg):",
            "            index.download(url, str(tmpdir))",
            "",
            "",
            "class TestContentCheckers:",
            "    def test_md5(self):",
            "        checker = setuptools.package_index.HashChecker.from_url(",
            "            'http://foo/bar#md5=f12895fdffbd45007040d2e44df98478'",
            "        )",
            "        checker.feed('You should probably not be using MD5'.encode('ascii'))",
            "        assert checker.hash.hexdigest() == 'f12895fdffbd45007040d2e44df98478'",
            "        assert checker.is_valid()",
            "",
            "    def test_other_fragment(self):",
            "        \"Content checks should succeed silently if no hash is present\"",
            "        checker = setuptools.package_index.HashChecker.from_url(",
            "            'http://foo/bar#something%20completely%20different'",
            "        )",
            "        checker.feed('anything'.encode('ascii'))",
            "        assert checker.is_valid()",
            "",
            "    def test_blank_md5(self):",
            "        \"Content checks should succeed if a hash is empty\"",
            "        checker = setuptools.package_index.HashChecker.from_url('http://foo/bar#md5=')",
            "        checker.feed('anything'.encode('ascii'))",
            "        assert checker.is_valid()",
            "",
            "    def test_get_hash_name_md5(self):",
            "        checker = setuptools.package_index.HashChecker.from_url(",
            "            'http://foo/bar#md5=f12895fdffbd45007040d2e44df98478'",
            "        )",
            "        assert checker.hash_name == 'md5'",
            "",
            "    def test_report(self):",
            "        checker = setuptools.package_index.HashChecker.from_url(",
            "            'http://foo/bar#md5=f12895fdffbd45007040d2e44df98478'",
            "        )",
            "        rep = checker.report(lambda x: x, 'My message about %s')",
            "        assert rep == 'My message about md5'",
            "",
            "",
            "class TestPyPIConfig:",
            "    def test_percent_in_password(self, tmp_home_dir):",
            "        pypirc = tmp_home_dir / '.pypirc'",
            "        pypirc.write_text(",
            "            cleandoc(",
            "                \"\"\"",
            "                [pypi]",
            "                repository=https://pypi.org",
            "                username=jaraco",
            "                password=pity%",
            "                \"\"\"",
            "            ),",
            "            encoding=\"utf-8\",",
            "        )",
            "        cfg = setuptools.package_index.PyPIConfig()",
            "        cred = cfg.creds_by_repository['https://pypi.org']",
            "        assert cred.username == 'jaraco'",
            "        assert cred.password == 'pity%'",
            "",
            "",
            "@pytest.mark.timeout(1)",
            "def test_REL_DoS():",
            "    \"\"\"",
            "    REL should not hang on a contrived attack string.",
            "    \"\"\"",
            "    setuptools.package_index.REL.search('< rel=' + ' ' * 2**12)"
        ],
        "afterPatchFile": [
            "import distutils.errors",
            "import urllib.request",
            "import urllib.error",
            "import http.client",
            "from inspect import cleandoc",
            "",
            "import pytest",
            "",
            "import setuptools.package_index",
            "",
            "",
            "class TestPackageIndex:",
            "    def test_regex(self):",
            "        hash_url = 'http://other_url?:action=show_md5&amp;'",
            "        hash_url += 'digest=0123456789abcdef0123456789abcdef'",
            "        doc = \"\"\"",
            "            <a href=\"http://some_url\">Name</a>",
            "            (<a title=\"MD5 hash\"",
            "            href=\"{hash_url}\">md5</a>)",
            "        \"\"\".lstrip().format(**locals())",
            "        assert setuptools.package_index.PYPI_MD5.match(doc)",
            "",
            "    def test_bad_url_bad_port(self):",
            "        index = setuptools.package_index.PackageIndex()",
            "        url = 'http://127.0.0.1:0/nonesuch/test_package_index'",
            "        try:",
            "            v = index.open_url(url)",
            "        except Exception as exc:",
            "            assert url in str(exc)",
            "        else:",
            "            assert isinstance(v, urllib.error.HTTPError)",
            "",
            "    def test_bad_url_typo(self):",
            "        # issue 16",
            "        # easy_install inquant.contentmirror.plone breaks because of a typo",
            "        # in its home URL",
            "        index = setuptools.package_index.PackageIndex(hosts=('www.example.com',))",
            "",
            "        url = (",
            "            'url:%20https://svn.plone.org/svn'",
            "            '/collective/inquant.contentmirror.plone/trunk'",
            "        )",
            "        try:",
            "            v = index.open_url(url)",
            "        except Exception as exc:",
            "            assert url in str(exc)",
            "        else:",
            "            assert isinstance(v, urllib.error.HTTPError)",
            "",
            "    def test_bad_url_bad_status_line(self):",
            "        index = setuptools.package_index.PackageIndex(hosts=('www.example.com',))",
            "",
            "        def _urlopen(*args):",
            "            raise http.client.BadStatusLine('line')",
            "",
            "        index.opener = _urlopen",
            "        url = 'http://example.com'",
            "        try:",
            "            index.open_url(url)",
            "        except Exception as exc:",
            "            assert 'line' in str(exc)",
            "        else:",
            "            raise AssertionError('Should have raise here!')",
            "",
            "    def test_bad_url_double_scheme(self):",
            "        \"\"\"",
            "        A bad URL with a double scheme should raise a DistutilsError.",
            "        \"\"\"",
            "        index = setuptools.package_index.PackageIndex(hosts=('www.example.com',))",
            "",
            "        # issue 20",
            "        url = 'http://http://svn.pythonpaste.org/Paste/wphp/trunk'",
            "        try:",
            "            index.open_url(url)",
            "        except distutils.errors.DistutilsError as error:",
            "            msg = str(error)",
            "            assert (",
            "                'nonnumeric port' in msg",
            "                or 'getaddrinfo failed' in msg",
            "                or 'Name or service not known' in msg",
            "            )",
            "            return",
            "        raise RuntimeError(\"Did not raise\")",
            "",
            "    def test_url_ok(self):",
            "        index = setuptools.package_index.PackageIndex(hosts=('www.example.com',))",
            "        url = 'file:///tmp/test_package_index'",
            "        assert index.url_ok(url, True)",
            "",
            "    def test_parse_bdist_wininst(self):",
            "        parse = setuptools.package_index.parse_bdist_wininst",
            "",
            "        actual = parse('reportlab-2.5.win32-py2.4.exe')",
            "        expected = 'reportlab-2.5', '2.4', 'win32'",
            "        assert actual == expected",
            "",
            "        actual = parse('reportlab-2.5.win32.exe')",
            "        expected = 'reportlab-2.5', None, 'win32'",
            "        assert actual == expected",
            "",
            "        actual = parse('reportlab-2.5.win-amd64-py2.7.exe')",
            "        expected = 'reportlab-2.5', '2.7', 'win-amd64'",
            "        assert actual == expected",
            "",
            "        actual = parse('reportlab-2.5.win-amd64.exe')",
            "        expected = 'reportlab-2.5', None, 'win-amd64'",
            "        assert actual == expected",
            "",
            "    def test__vcs_split_rev_from_url(self):",
            "        \"\"\"",
            "        Test the basic usage of _vcs_split_rev_from_url",
            "        \"\"\"",
            "        vsrfu = setuptools.package_index.PackageIndex._vcs_split_rev_from_url",
            "        url, rev = vsrfu('https://example.com/bar@2995')",
            "        assert url == 'https://example.com/bar'",
            "        assert rev == '2995'",
            "",
            "    def test_local_index(self, tmpdir):",
            "        \"\"\"",
            "        local_open should be able to read an index from the file system.",
            "        \"\"\"",
            "        index_file = tmpdir / 'index.html'",
            "        with index_file.open('w') as f:",
            "            f.write('<div>content</div>')",
            "        url = 'file:' + urllib.request.pathname2url(str(tmpdir)) + '/'",
            "        res = setuptools.package_index.local_open(url)",
            "        assert 'content' in res.read()",
            "",
            "    def test_egg_fragment(self):",
            "        \"\"\"",
            "        EGG fragments must comply to PEP 440",
            "        \"\"\"",
            "        epoch = [",
            "            '',",
            "            '1!',",
            "        ]",
            "        releases = [",
            "            '0',",
            "            '0.0',",
            "            '0.0.0',",
            "        ]",
            "        pre = [",
            "            'a0',",
            "            'b0',",
            "            'rc0',",
            "        ]",
            "        post = ['.post0']",
            "        dev = [",
            "            '.dev0',",
            "        ]",
            "        local = [",
            "            ('', ''),",
            "            ('+ubuntu.0', '+ubuntu.0'),",
            "            ('+ubuntu-0', '+ubuntu.0'),",
            "            ('+ubuntu_0', '+ubuntu.0'),",
            "        ]",
            "        versions = [",
            "            [''.join([e, r, p, loc]) for loc in locs]",
            "            for e in epoch",
            "            for r in releases",
            "            for p in sum([pre, post, dev], [''])",
            "            for locs in local",
            "        ]",
            "        for v, vc in versions:",
            "            dists = list(",
            "                setuptools.package_index.distros_for_url(",
            "                    'http://example.com/example-foo.zip#egg=example-foo-' + v",
            "                )",
            "            )",
            "            assert dists[0].version == ''",
            "            assert dists[1].version == vc",
            "",
            "    def test_download_git_with_rev(self, tmp_path, fp):",
            "        url = 'git+https://github.example/group/project@master#egg=foo'",
            "        index = setuptools.package_index.PackageIndex()",
            "",
            "        expected_dir = tmp_path / 'project@master'",
            "        fp.register([",
            "            'git',",
            "            'clone',",
            "            '--quiet',",
            "            'https://github.example/group/project',",
            "            expected_dir,",
            "        ])",
            "        fp.register(['git', '-C', expected_dir, 'checkout', '--quiet', 'master'])",
            "",
            "        result = index.download(url, tmp_path)",
            "",
            "        assert result == str(expected_dir)",
            "        assert len(fp.calls) == 2",
            "",
            "    def test_download_git_no_rev(self, tmp_path, fp):",
            "        url = 'git+https://github.example/group/project#egg=foo'",
            "        index = setuptools.package_index.PackageIndex()",
            "",
            "        expected_dir = tmp_path / 'project'",
            "        fp.register([",
            "            'git',",
            "            'clone',",
            "            '--quiet',",
            "            'https://github.example/group/project',",
            "            expected_dir,",
            "        ])",
            "        index.download(url, tmp_path)",
            "",
            "    def test_download_svn(self, tmp_path):",
            "        url = 'svn+https://svn.example/project#egg=foo'",
            "        index = setuptools.package_index.PackageIndex()",
            "",
            "        msg = r\".*SVN download is not supported.*\"",
            "        with pytest.raises(distutils.errors.DistutilsError, match=msg):",
            "            index.download(url, tmp_path)",
            "",
            "",
            "class TestContentCheckers:",
            "    def test_md5(self):",
            "        checker = setuptools.package_index.HashChecker.from_url(",
            "            'http://foo/bar#md5=f12895fdffbd45007040d2e44df98478'",
            "        )",
            "        checker.feed('You should probably not be using MD5'.encode('ascii'))",
            "        assert checker.hash.hexdigest() == 'f12895fdffbd45007040d2e44df98478'",
            "        assert checker.is_valid()",
            "",
            "    def test_other_fragment(self):",
            "        \"Content checks should succeed silently if no hash is present\"",
            "        checker = setuptools.package_index.HashChecker.from_url(",
            "            'http://foo/bar#something%20completely%20different'",
            "        )",
            "        checker.feed('anything'.encode('ascii'))",
            "        assert checker.is_valid()",
            "",
            "    def test_blank_md5(self):",
            "        \"Content checks should succeed if a hash is empty\"",
            "        checker = setuptools.package_index.HashChecker.from_url('http://foo/bar#md5=')",
            "        checker.feed('anything'.encode('ascii'))",
            "        assert checker.is_valid()",
            "",
            "    def test_get_hash_name_md5(self):",
            "        checker = setuptools.package_index.HashChecker.from_url(",
            "            'http://foo/bar#md5=f12895fdffbd45007040d2e44df98478'",
            "        )",
            "        assert checker.hash_name == 'md5'",
            "",
            "    def test_report(self):",
            "        checker = setuptools.package_index.HashChecker.from_url(",
            "            'http://foo/bar#md5=f12895fdffbd45007040d2e44df98478'",
            "        )",
            "        rep = checker.report(lambda x: x, 'My message about %s')",
            "        assert rep == 'My message about md5'",
            "",
            "",
            "class TestPyPIConfig:",
            "    def test_percent_in_password(self, tmp_home_dir):",
            "        pypirc = tmp_home_dir / '.pypirc'",
            "        pypirc.write_text(",
            "            cleandoc(",
            "                \"\"\"",
            "                [pypi]",
            "                repository=https://pypi.org",
            "                username=jaraco",
            "                password=pity%",
            "                \"\"\"",
            "            ),",
            "            encoding=\"utf-8\",",
            "        )",
            "        cfg = setuptools.package_index.PyPIConfig()",
            "        cred = cfg.creds_by_repository['https://pypi.org']",
            "        assert cred.username == 'jaraco'",
            "        assert cred.password == 'pity%'",
            "",
            "",
            "@pytest.mark.timeout(1)",
            "def test_REL_DoS():",
            "    \"\"\"",
            "    REL should not hang on a contrived attack string.",
            "    \"\"\"",
            "    setuptools.package_index.REL.search('< rel=' + ' ' * 2**12)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "6": [],
            "174": [
                "TestPackageIndex",
                "test_download_git_with_rev"
            ],
            "178": [
                "TestPackageIndex",
                "test_download_git_with_rev"
            ],
            "179": [
                "TestPackageIndex",
                "test_download_git_with_rev"
            ],
            "181": [
                "TestPackageIndex",
                "test_download_git_with_rev"
            ],
            "183": [
                "TestPackageIndex",
                "test_download_git_with_rev"
            ],
            "184": [
                "TestPackageIndex",
                "test_download_git_with_rev"
            ],
            "185": [
                "TestPackageIndex",
                "test_download_git_with_rev"
            ],
            "186": [
                "TestPackageIndex",
                "test_download_git_with_rev"
            ],
            "187": [
                "TestPackageIndex",
                "test_download_git_with_rev"
            ],
            "188": [
                "TestPackageIndex",
                "test_download_git_with_rev"
            ],
            "190": [
                "TestPackageIndex",
                "test_download_git_with_rev"
            ],
            "191": [
                "TestPackageIndex",
                "test_download_git_with_rev"
            ],
            "192": [
                "TestPackageIndex",
                "test_download_git_with_rev"
            ],
            "193": [
                "TestPackageIndex",
                "test_download_git_with_rev"
            ],
            "194": [
                "TestPackageIndex"
            ],
            "195": [
                "TestPackageIndex",
                "test_download_git_no_rev"
            ],
            "199": [
                "TestPackageIndex",
                "test_download_git_no_rev"
            ],
            "200": [
                "TestPackageIndex",
                "test_download_git_no_rev"
            ],
            "201": [
                "TestPackageIndex",
                "test_download_git_no_rev"
            ],
            "202": [
                "TestPackageIndex",
                "test_download_git_no_rev"
            ],
            "203": [
                "TestPackageIndex",
                "test_download_git_no_rev"
            ],
            "204": [
                "TestPackageIndex",
                "test_download_git_no_rev"
            ],
            "205": [
                "TestPackageIndex",
                "test_download_git_no_rev"
            ],
            "206": [
                "TestPackageIndex",
                "test_download_git_no_rev"
            ],
            "207": [
                "TestPackageIndex",
                "test_download_git_no_rev"
            ],
            "208": [
                "TestPackageIndex",
                "test_download_git_no_rev"
            ],
            "209": [
                "TestPackageIndex"
            ],
            "210": [
                "TestPackageIndex",
                "test_download_svn"
            ],
            "216": [
                "TestPackageIndex",
                "test_download_svn"
            ]
        },
        "addLocation": []
    }
}