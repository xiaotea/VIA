{
    "suds/cache.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 92,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "     @cvar fnprefix: The file name prefix."
            },
            "2": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "     @type fnprefix: str"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+    @cvar remove_default_location_on_exit: Whether to remove the default cache"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+        location on process exit (default=True)."
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+    @type remove_default_location_on_exit: bool"
            },
            "6": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "     @ivar duration: The duration after which cached entries expire (0=never)."
            },
            "7": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "     @type duration: datetime.timedelta"
            },
            "8": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "     @ivar location: The cached file folder."
            },
            "9": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "     @type location: str"
            },
            "10": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 102,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "     \"\"\""
            },
            "12": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "     fnprefix = \"suds\""
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+    __default_location = None"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+    remove_default_location_on_exit = True"
            },
            "15": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 107,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 108,
                "PatchRowcode": "     def __init__(self, location=None, **duration):"
            },
            "17": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "         \"\"\""
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+        Initialized a new FileCache instance."
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        If no cache location is specified, a temporary default location will be"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+        used. Such default cache location will be shared by all FileCache"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        instances with no explicitly specified location within the same"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+        process. The default cache location will be removed automatically on"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+        process exit unless user sets the remove_default_location_on_exit"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+        FileCache class attribute to False."
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "         @param location: The cached file folder."
            },
            "28": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "         @type location: str"
            },
            "29": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "         @param duration: The duration after which cached entries expire"
            },
            "30": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 124,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "         \"\"\""
            },
            "32": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "         if location is None:"
            },
            "33": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            location = os.path.join(tempfile.gettempdir(), \"suds\")"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+            location = self.__get_default_location()"
            },
            "35": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "         self.location = location"
            },
            "36": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "         self.duration = datetime.timedelta(**duration)"
            },
            "37": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "         self.__check_version()"
            },
            "38": {
                "beforePatchRowNumber": 197,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "         filename = \"%s-%s.%s\" % (self.fnprefix, id, suffix)"
            },
            "39": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": 212,
                "PatchRowcode": "         return os.path.join(self.location, filename)"
            },
            "40": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 213,
                "PatchRowcode": " "
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+    @staticmethod"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+    def __get_default_location():"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+        \"\"\""
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+        Returns the current process's default cache location folder."
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+        The folder is determined lazily on first call."
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+        \"\"\""
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        if not FileCache.__default_location:"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+            tmp = tempfile.mkdtemp(\"suds-default-cache\")"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+            FileCache.__default_location = tmp"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+            import atexit"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+            atexit.register(FileCache.__remove_default_location)"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+        return FileCache.__default_location"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+"
            },
            "56": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "     def __mktmp(self):"
            },
            "57": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 230,
                "PatchRowcode": "         \"\"\"Create the I{location} folder if it does not already exist.\"\"\""
            },
            "58": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "         try:"
            },
            "59": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 240,
                "PatchRowcode": "         self.__mktmp()"
            },
            "60": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "         return open(filename, *args)"
            },
            "61": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 242,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+    @staticmethod"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+    def __remove_default_location():"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 245,
                "PatchRowcode": "+        \"\"\""
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 246,
                "PatchRowcode": "+        Removes the default cache location folder."
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 248,
                "PatchRowcode": "+        This removal may be disabled by setting the"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+        remove_default_location_on_exit FileCache class attribute to False."
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+        \"\"\""
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+        if FileCache.remove_default_location_on_exit:"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+            import shutil"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+            shutil.rmtree(FileCache.__default_location, ignore_errors=True)"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+"
            },
            "75": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "     def __remove_if_expired(self, filename):"
            },
            "76": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "         \"\"\""
            },
            "77": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 258,
                "PatchRowcode": "         Remove a cached file entry if it expired."
            }
        },
        "frontPatchFile": [
            "# This program is free software; you can redistribute it and/or modify it under",
            "# the terms of the (LGPL) GNU Lesser General Public License as published by the",
            "# Free Software Foundation; either version 3 of the License, or (at your",
            "# option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful, but WITHOUT",
            "# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS",
            "# FOR A PARTICULAR PURPOSE. See the GNU Library Lesser General Public License",
            "# for more details at ( http://www.gnu.org/licenses/lgpl.html ).",
            "#",
            "# You should have received a copy of the GNU Lesser General Public License",
            "# along with this program; if not, write to the Free Software Foundation, Inc.,",
            "# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.",
            "# written by: Jeff Ortel ( jortel@redhat.com )",
            "",
            "\"\"\"",
            "Basic caching classes.",
            "",
            "\"\"\"",
            "",
            "import suds",
            "import suds.sax.element",
            "import suds.sax.parser",
            "",
            "import datetime",
            "import os",
            "try:",
            "    import cPickle as pickle",
            "except Exception:",
            "    import pickle",
            "import tempfile",
            "",
            "from logging import getLogger",
            "log = getLogger(__name__)",
            "",
            "",
            "class Cache(object):",
            "    \"\"\"An object cache.\"\"\"",
            "",
            "    def get(self, id):",
            "        \"\"\"",
            "        Get an object from the cache by id.",
            "",
            "        @param id: The object id.",
            "        @type id: str",
            "        @return: The object, else None.",
            "        @rtype: any",
            "",
            "        \"\"\"",
            "        raise Exception(\"not-implemented\")",
            "",
            "    def put(self, id, object):",
            "        \"\"\"",
            "        Put an object into the cache.",
            "",
            "        @param id: The object id.",
            "        @type id: str",
            "        @param object: The object to add.",
            "        @type object: any",
            "",
            "        \"\"\"",
            "        raise Exception(\"not-implemented\")",
            "",
            "    def purge(self, id):",
            "        \"\"\"",
            "        Purge an object from the cache by id.",
            "",
            "        @param id: A object id.",
            "        @type id: str",
            "",
            "        \"\"\"",
            "        raise Exception(\"not-implemented\")",
            "",
            "    def clear(self):",
            "        \"\"\"Clear all objects from the cache.\"\"\"",
            "        raise Exception(\"not-implemented\")",
            "",
            "",
            "class NoCache(Cache):",
            "    \"\"\"The pass-through object cache.\"\"\"",
            "",
            "    def get(self, id):",
            "        return",
            "",
            "    def put(self, id, object):",
            "        pass",
            "",
            "",
            "class FileCache(Cache):",
            "    \"\"\"",
            "    A file-based URL cache.",
            "",
            "    @cvar fnprefix: The file name prefix.",
            "    @type fnprefix: str",
            "    @ivar duration: The duration after which cached entries expire (0=never).",
            "    @type duration: datetime.timedelta",
            "    @ivar location: The cached file folder.",
            "    @type location: str",
            "",
            "    \"\"\"",
            "    fnprefix = \"suds\"",
            "",
            "    def __init__(self, location=None, **duration):",
            "        \"\"\"",
            "        @param location: The cached file folder.",
            "        @type location: str",
            "        @param duration: The duration after which cached entries expire",
            "            (default: 0=never).",
            "        @type duration: keyword arguments for datetime.timedelta constructor",
            "",
            "        \"\"\"",
            "        if location is None:",
            "            location = os.path.join(tempfile.gettempdir(), \"suds\")",
            "        self.location = location",
            "        self.duration = datetime.timedelta(**duration)",
            "        self.__check_version()",
            "",
            "    def clear(self):",
            "        for filename in os.listdir(self.location):",
            "            path = os.path.join(self.location, filename)",
            "            if os.path.isdir(path):",
            "                continue",
            "            if filename.startswith(self.fnprefix):",
            "                os.remove(path)",
            "                log.debug(\"deleted: %s\", path)",
            "",
            "    def fnsuffix(self):",
            "        \"\"\"",
            "        Get the file name suffix.",
            "",
            "        @return: The suffix.",
            "        @rtype: str",
            "",
            "        \"\"\"",
            "        return \"gcf\"",
            "",
            "    def get(self, id):",
            "        try:",
            "            f = self._getf(id)",
            "            try:",
            "                return f.read()",
            "            finally:",
            "                f.close()",
            "        except Exception:",
            "            pass",
            "",
            "    def purge(self, id):",
            "        filename = self.__filename(id)",
            "        try:",
            "            os.remove(filename)",
            "        except Exception:",
            "            pass",
            "",
            "    def put(self, id, data):",
            "        try:",
            "            filename = self.__filename(id)",
            "            f = self.__open(filename, \"wb\")",
            "            try:",
            "                f.write(data)",
            "            finally:",
            "                f.close()",
            "            return data",
            "        except Exception:",
            "            log.debug(id, exc_info=1)",
            "            return data",
            "",
            "    def _getf(self, id):",
            "        \"\"\"Open a cached file with the given id for reading.\"\"\"",
            "        try:",
            "            filename = self.__filename(id)",
            "            self.__remove_if_expired(filename)",
            "            return self.__open(filename, \"rb\")",
            "        except Exception:",
            "            pass",
            "",
            "    def __check_version(self):",
            "        path = os.path.join(self.location, \"version\")",
            "        try:",
            "            f = self.__open(path)",
            "            try:",
            "                version = f.read()",
            "            finally:",
            "                f.close()",
            "            if version != suds.__version__:",
            "                raise Exception()",
            "        except Exception:",
            "            self.clear()",
            "            f = self.__open(path, \"w\")",
            "            try:",
            "                f.write(suds.__version__)",
            "            finally:",
            "                f.close()",
            "",
            "    def __filename(self, id):",
            "        \"\"\"Return the cache file name for an entry with a given id.\"\"\"",
            "        suffix = self.fnsuffix()",
            "        filename = \"%s-%s.%s\" % (self.fnprefix, id, suffix)",
            "        return os.path.join(self.location, filename)",
            "",
            "    def __mktmp(self):",
            "        \"\"\"Create the I{location} folder if it does not already exist.\"\"\"",
            "        try:",
            "            if not os.path.isdir(self.location):",
            "                os.makedirs(self.location)",
            "        except Exception:",
            "            log.debug(self.location, exc_info=1)",
            "        return self",
            "",
            "    def __open(self, filename, *args):",
            "        \"\"\"Open cache file making sure the I{location} folder is created.\"\"\"",
            "        self.__mktmp()",
            "        return open(filename, *args)",
            "",
            "    def __remove_if_expired(self, filename):",
            "        \"\"\"",
            "        Remove a cached file entry if it expired.",
            "",
            "        @param filename: The file name.",
            "        @type filename: str",
            "",
            "        \"\"\"",
            "        if not self.duration:",
            "            return",
            "        created = datetime.datetime.fromtimestamp(os.path.getctime(filename))",
            "        expired = created + self.duration",
            "        if expired < datetime.datetime.now():",
            "            os.remove(filename)",
            "            log.debug(\"%s expired, deleted\", filename)",
            "",
            "",
            "class DocumentCache(FileCache):",
            "    \"\"\"XML document file cache.\"\"\"",
            "",
            "    def fnsuffix(self):",
            "        return \"xml\"",
            "",
            "    def get(self, id):",
            "        fp = None",
            "        try:",
            "            fp = self._getf(id)",
            "            if fp is None:",
            "                return None",
            "            p = suds.sax.parser.Parser()",
            "            return p.parse(fp)",
            "        except Exception:",
            "            if fp is not None:",
            "                fp.close()",
            "            self.purge(id)",
            "",
            "    def put(self, id, object):",
            "        if isinstance(object, suds.sax.element.Element):",
            "            super(DocumentCache, self).put(id, suds.byte_str(str(object)))",
            "        return object",
            "",
            "",
            "class ObjectCache(FileCache):",
            "    \"\"\"",
            "    Pickled object file cache.",
            "",
            "    @cvar protocol: The pickling protocol.",
            "    @type protocol: int",
            "",
            "    \"\"\"",
            "    protocol = 2",
            "",
            "    def fnsuffix(self):",
            "        return \"px\"",
            "",
            "    def get(self, id):",
            "        fp = None",
            "        try:",
            "            fp = self._getf(id)",
            "            if fp is not None:",
            "                return pickle.load(fp)",
            "        except Exception:",
            "            if fp is not None:",
            "                fp.close()",
            "            self.purge(id)",
            "",
            "    def put(self, id, object):",
            "        data = pickle.dumps(object, self.protocol)",
            "        super(ObjectCache, self).put(id, data)",
            "        return object"
        ],
        "afterPatchFile": [
            "# This program is free software; you can redistribute it and/or modify it under",
            "# the terms of the (LGPL) GNU Lesser General Public License as published by the",
            "# Free Software Foundation; either version 3 of the License, or (at your",
            "# option) any later version.",
            "#",
            "# This program is distributed in the hope that it will be useful, but WITHOUT",
            "# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS",
            "# FOR A PARTICULAR PURPOSE. See the GNU Library Lesser General Public License",
            "# for more details at ( http://www.gnu.org/licenses/lgpl.html ).",
            "#",
            "# You should have received a copy of the GNU Lesser General Public License",
            "# along with this program; if not, write to the Free Software Foundation, Inc.,",
            "# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.",
            "# written by: Jeff Ortel ( jortel@redhat.com )",
            "",
            "\"\"\"",
            "Basic caching classes.",
            "",
            "\"\"\"",
            "",
            "import suds",
            "import suds.sax.element",
            "import suds.sax.parser",
            "",
            "import datetime",
            "import os",
            "try:",
            "    import cPickle as pickle",
            "except Exception:",
            "    import pickle",
            "import tempfile",
            "",
            "from logging import getLogger",
            "log = getLogger(__name__)",
            "",
            "",
            "class Cache(object):",
            "    \"\"\"An object cache.\"\"\"",
            "",
            "    def get(self, id):",
            "        \"\"\"",
            "        Get an object from the cache by id.",
            "",
            "        @param id: The object id.",
            "        @type id: str",
            "        @return: The object, else None.",
            "        @rtype: any",
            "",
            "        \"\"\"",
            "        raise Exception(\"not-implemented\")",
            "",
            "    def put(self, id, object):",
            "        \"\"\"",
            "        Put an object into the cache.",
            "",
            "        @param id: The object id.",
            "        @type id: str",
            "        @param object: The object to add.",
            "        @type object: any",
            "",
            "        \"\"\"",
            "        raise Exception(\"not-implemented\")",
            "",
            "    def purge(self, id):",
            "        \"\"\"",
            "        Purge an object from the cache by id.",
            "",
            "        @param id: A object id.",
            "        @type id: str",
            "",
            "        \"\"\"",
            "        raise Exception(\"not-implemented\")",
            "",
            "    def clear(self):",
            "        \"\"\"Clear all objects from the cache.\"\"\"",
            "        raise Exception(\"not-implemented\")",
            "",
            "",
            "class NoCache(Cache):",
            "    \"\"\"The pass-through object cache.\"\"\"",
            "",
            "    def get(self, id):",
            "        return",
            "",
            "    def put(self, id, object):",
            "        pass",
            "",
            "",
            "class FileCache(Cache):",
            "    \"\"\"",
            "    A file-based URL cache.",
            "",
            "    @cvar fnprefix: The file name prefix.",
            "    @type fnprefix: str",
            "    @cvar remove_default_location_on_exit: Whether to remove the default cache",
            "        location on process exit (default=True).",
            "    @type remove_default_location_on_exit: bool",
            "    @ivar duration: The duration after which cached entries expire (0=never).",
            "    @type duration: datetime.timedelta",
            "    @ivar location: The cached file folder.",
            "    @type location: str",
            "",
            "    \"\"\"",
            "    fnprefix = \"suds\"",
            "    __default_location = None",
            "    remove_default_location_on_exit = True",
            "",
            "    def __init__(self, location=None, **duration):",
            "        \"\"\"",
            "        Initialized a new FileCache instance.",
            "",
            "        If no cache location is specified, a temporary default location will be",
            "        used. Such default cache location will be shared by all FileCache",
            "        instances with no explicitly specified location within the same",
            "        process. The default cache location will be removed automatically on",
            "        process exit unless user sets the remove_default_location_on_exit",
            "        FileCache class attribute to False.",
            "",
            "        @param location: The cached file folder.",
            "        @type location: str",
            "        @param duration: The duration after which cached entries expire",
            "            (default: 0=never).",
            "        @type duration: keyword arguments for datetime.timedelta constructor",
            "",
            "        \"\"\"",
            "        if location is None:",
            "            location = self.__get_default_location()",
            "        self.location = location",
            "        self.duration = datetime.timedelta(**duration)",
            "        self.__check_version()",
            "",
            "    def clear(self):",
            "        for filename in os.listdir(self.location):",
            "            path = os.path.join(self.location, filename)",
            "            if os.path.isdir(path):",
            "                continue",
            "            if filename.startswith(self.fnprefix):",
            "                os.remove(path)",
            "                log.debug(\"deleted: %s\", path)",
            "",
            "    def fnsuffix(self):",
            "        \"\"\"",
            "        Get the file name suffix.",
            "",
            "        @return: The suffix.",
            "        @rtype: str",
            "",
            "        \"\"\"",
            "        return \"gcf\"",
            "",
            "    def get(self, id):",
            "        try:",
            "            f = self._getf(id)",
            "            try:",
            "                return f.read()",
            "            finally:",
            "                f.close()",
            "        except Exception:",
            "            pass",
            "",
            "    def purge(self, id):",
            "        filename = self.__filename(id)",
            "        try:",
            "            os.remove(filename)",
            "        except Exception:",
            "            pass",
            "",
            "    def put(self, id, data):",
            "        try:",
            "            filename = self.__filename(id)",
            "            f = self.__open(filename, \"wb\")",
            "            try:",
            "                f.write(data)",
            "            finally:",
            "                f.close()",
            "            return data",
            "        except Exception:",
            "            log.debug(id, exc_info=1)",
            "            return data",
            "",
            "    def _getf(self, id):",
            "        \"\"\"Open a cached file with the given id for reading.\"\"\"",
            "        try:",
            "            filename = self.__filename(id)",
            "            self.__remove_if_expired(filename)",
            "            return self.__open(filename, \"rb\")",
            "        except Exception:",
            "            pass",
            "",
            "    def __check_version(self):",
            "        path = os.path.join(self.location, \"version\")",
            "        try:",
            "            f = self.__open(path)",
            "            try:",
            "                version = f.read()",
            "            finally:",
            "                f.close()",
            "            if version != suds.__version__:",
            "                raise Exception()",
            "        except Exception:",
            "            self.clear()",
            "            f = self.__open(path, \"w\")",
            "            try:",
            "                f.write(suds.__version__)",
            "            finally:",
            "                f.close()",
            "",
            "    def __filename(self, id):",
            "        \"\"\"Return the cache file name for an entry with a given id.\"\"\"",
            "        suffix = self.fnsuffix()",
            "        filename = \"%s-%s.%s\" % (self.fnprefix, id, suffix)",
            "        return os.path.join(self.location, filename)",
            "",
            "    @staticmethod",
            "    def __get_default_location():",
            "        \"\"\"",
            "        Returns the current process's default cache location folder.",
            "",
            "        The folder is determined lazily on first call.",
            "",
            "        \"\"\"",
            "        if not FileCache.__default_location:",
            "            tmp = tempfile.mkdtemp(\"suds-default-cache\")",
            "            FileCache.__default_location = tmp",
            "            import atexit",
            "            atexit.register(FileCache.__remove_default_location)",
            "        return FileCache.__default_location",
            "",
            "    def __mktmp(self):",
            "        \"\"\"Create the I{location} folder if it does not already exist.\"\"\"",
            "        try:",
            "            if not os.path.isdir(self.location):",
            "                os.makedirs(self.location)",
            "        except Exception:",
            "            log.debug(self.location, exc_info=1)",
            "        return self",
            "",
            "    def __open(self, filename, *args):",
            "        \"\"\"Open cache file making sure the I{location} folder is created.\"\"\"",
            "        self.__mktmp()",
            "        return open(filename, *args)",
            "",
            "    @staticmethod",
            "    def __remove_default_location():",
            "        \"\"\"",
            "        Removes the default cache location folder.",
            "",
            "        This removal may be disabled by setting the",
            "        remove_default_location_on_exit FileCache class attribute to False.",
            "",
            "        \"\"\"",
            "        if FileCache.remove_default_location_on_exit:",
            "            import shutil",
            "            shutil.rmtree(FileCache.__default_location, ignore_errors=True)",
            "",
            "    def __remove_if_expired(self, filename):",
            "        \"\"\"",
            "        Remove a cached file entry if it expired.",
            "",
            "        @param filename: The file name.",
            "        @type filename: str",
            "",
            "        \"\"\"",
            "        if not self.duration:",
            "            return",
            "        created = datetime.datetime.fromtimestamp(os.path.getctime(filename))",
            "        expired = created + self.duration",
            "        if expired < datetime.datetime.now():",
            "            os.remove(filename)",
            "            log.debug(\"%s expired, deleted\", filename)",
            "",
            "",
            "class DocumentCache(FileCache):",
            "    \"\"\"XML document file cache.\"\"\"",
            "",
            "    def fnsuffix(self):",
            "        return \"xml\"",
            "",
            "    def get(self, id):",
            "        fp = None",
            "        try:",
            "            fp = self._getf(id)",
            "            if fp is None:",
            "                return None",
            "            p = suds.sax.parser.Parser()",
            "            return p.parse(fp)",
            "        except Exception:",
            "            if fp is not None:",
            "                fp.close()",
            "            self.purge(id)",
            "",
            "    def put(self, id, object):",
            "        if isinstance(object, suds.sax.element.Element):",
            "            super(DocumentCache, self).put(id, suds.byte_str(str(object)))",
            "        return object",
            "",
            "",
            "class ObjectCache(FileCache):",
            "    \"\"\"",
            "    Pickled object file cache.",
            "",
            "    @cvar protocol: The pickling protocol.",
            "    @type protocol: int",
            "",
            "    \"\"\"",
            "    protocol = 2",
            "",
            "    def fnsuffix(self):",
            "        return \"px\"",
            "",
            "    def get(self, id):",
            "        fp = None",
            "        try:",
            "            fp = self._getf(id)",
            "            if fp is not None:",
            "                return pickle.load(fp)",
            "        except Exception:",
            "            if fp is not None:",
            "                fp.close()",
            "            self.purge(id)",
            "",
            "    def put(self, id, object):",
            "        data = pickle.dumps(object, self.protocol)",
            "        super(ObjectCache, self).put(id, data)",
            "        return object"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "113": [
                "FileCache",
                "__init__"
            ]
        },
        "addLocation": [
            "suds.cache.FileCache.self",
            "suds.cache.FileCache",
            "src.octoprint.server.api",
            "suds.cache.FileCache.__mktmp"
        ]
    }
}