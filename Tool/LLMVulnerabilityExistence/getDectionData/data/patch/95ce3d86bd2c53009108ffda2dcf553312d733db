{
    "keylime/tpm/tpm_util.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import struct"
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from typing import Any, Dict, List, Optional, Tuple, Union"
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from cryptography.exceptions import InvalidSignature"
            },
            "4": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from cryptography.hazmat import backends"
            },
            "5": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from cryptography.hazmat.primitives import hashes, hmac, serialization"
            },
            "6": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from cryptography.hazmat.primitives.asymmetric import ec, padding"
            },
            "7": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "     digest.update(quoteblob)"
            },
            "8": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "     quote_digest = digest.finalize()"
            },
            "9": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 156,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    try:"
            },
            "11": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        verify(pubkey, signature, quote_digest, hashfunc)"
            },
            "12": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    except InvalidSignature:"
            },
            "13": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        logger.error(\"Invalid quote signature!\")"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+    verify(pubkey, signature, quote_digest, hashfunc)"
            },
            "15": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 158,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "     # Check that reported nonce is expected one"
            },
            "17": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "     retDict = tpm2_objects.unmarshal_tpms_attest(quoteblob)"
            }
        },
        "frontPatchFile": [
            "import os",
            "import string",
            "import struct",
            "from typing import Any, Dict, List, Optional, Tuple, Union",
            "",
            "from cryptography.exceptions import InvalidSignature",
            "from cryptography.hazmat import backends",
            "from cryptography.hazmat.primitives import hashes, hmac, serialization",
            "from cryptography.hazmat.primitives.asymmetric import ec, padding",
            "from cryptography.hazmat.primitives.asymmetric.ec import EllipticCurvePublicKey",
            "from cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicKey",
            "from cryptography.hazmat.primitives.asymmetric.utils import Prehashed",
            "from cryptography.hazmat.primitives.ciphers import Cipher, modes",
            "",
            "from keylime import config, crypto, json, keylime_logging",
            "from keylime.tpm import ec_crypto_helper, tpm2_objects",
            "",
            "logger = keylime_logging.init_logging(\"tpm_util\")",
            "",
            "SupportedKeyTypes = Union[RSAPublicKey, EllipticCurvePublicKey]",
            "",
            "",
            "def verify(pubkey: SupportedKeyTypes, sig: bytes, digest: bytes, hashfunc: hashes.HashAlgorithm) -> None:",
            "    \"\"\"Do signature verification with the given public key\"\"\"",
            "    if isinstance(pubkey, RSAPublicKey):",
            "        pubkey.verify(sig, digest, padding.PKCS1v15(), Prehashed(hashfunc))",
            "    elif isinstance(pubkey, EllipticCurvePublicKey):",
            "        pubkey.verify(sig, digest, ec.ECDSA(Prehashed(hashfunc)))",
            "",
            "",
            "def __get_pcrs_from_blob(pcrblob: bytes) -> Tuple[int, Dict[int, int], List[bytes]]:",
            "    \"\"\"This function is specific to the Intel tools with data in little endian format.",
            "    Data structures were not marshalled but written right from memory.\"\"\"",
            "    # TPML_PCR_SELECTION:count",
            "    (pcr_select_count,) = struct.unpack_from(\"<I\", pcrblob, 0)",
            "",
            "    o = 4",
            "    # TPML_PCR_SELECTION:TPMS_PCR_SELECTION[HASH_COUNT]",
            "    tpml_pcr_selection: Dict[int, int] = {}",
            "    for _ in range(0, 16):",
            "        hash_alg, size_of_select = struct.unpack_from(\"<HB\", pcrblob, o)",
            "        if size_of_select not in [0, 3]:",
            "            raise ValueError(f\"size_of_select must be either 0 or 3 but it is {size_of_select}\")",
            "        o = o + 3",
            "",
            "        if size_of_select == 3:",
            "            (pcr_select_bytes,) = struct.unpack_from(\"3s\", pcrblob, o)",
            "            pcr_select = pcr_select_bytes[0] | pcr_select_bytes[1] << 8 | pcr_select_bytes[2] << 16",
            "        else:",
            "            pcr_select = 0",
            "",
            "        tpml_pcr_selection[hash_alg] = pcr_select",
            "",
            "        # always advance by size_of_select = 3 and 2 bytes alignment",
            "        o = o + 3 + 2",
            "",
            "    # Number of subsequent TPML_DIGEST's",
            "    (pcrs_count,) = struct.unpack_from(\"<I\", pcrblob, o)",
            "    o = o + 4",
            "",
            "    pcr_values: List[bytes] = []",
            "",
            "    for _ in range(0, pcrs_count):",
            "        # TPML_DIGEST::count",
            "        (_,) = struct.unpack_from(\"<I\", pcrblob, o)",
            "        o = o + 4",
            "",
            "        # TPML_DIGEST::TPM2B_DIGEST[8]",
            "        for _ in range(0, 8):",
            "            (sz,) = struct.unpack_from(\"<H\", pcrblob, o)",
            "            o = o + 2",
            "            if sz:",
            "                (pcr_value,) = struct.unpack_from(f\"{sz}s\", pcrblob, o)",
            "                pcr_values.append(pcr_value)",
            "            # Always advance by the size of TPMU_HA (= size of SHA512)",
            "            o = o + 64",
            "",
            "    if o != len(pcrblob):",
            "        raise ValueError(\"Failed to parse the entire pcrblob\")",
            "",
            "    return pcr_select_count, tpml_pcr_selection, pcr_values",
            "",
            "",
            "def __hash_pcr_banks(",
            "    hash_alg: int, pcr_select_count: int, tpml_pcr_selection: Dict[int, int], pcr_values: List[bytes]",
            ") -> Tuple[bytes, Dict[int, str]]:",
            "    \"\"\"From the tpml_pcr_selection determine which PCRs were quoted and hash these PCRs to get",
            "    the hash that was used for the quote. Build a dict that contains the PCR values.\"\"\"",
            "    hashfunc = tpm2_objects.HASH_FUNCS.get(hash_alg)",
            "    if not hashfunc:",
            "        raise ValueError(f\"Unsupported hash with id {hash_alg:#x} in signature blob\")",
            "",
            "    digest = hashes.Hash(hashfunc, backend=backends.default_backend())",
            "",
            "    idx = 0",
            "    pcrs_dict: Dict[int, str] = {}",
            "",
            "    for _ in range(0, pcr_select_count):",
            "        for pcr_id in range(0, 24):",
            "            if tpml_pcr_selection[hash_alg] & (1 << pcr_id) == 0:",
            "                continue",
            "            if idx >= len(pcr_values):",
            "                raise ValueError(f\"pcr_values list is too short to get item {idx}\")",
            "            digest.update(pcr_values[idx])",
            "            pcrs_dict[pcr_id] = pcr_values[idx].hex()",
            "            idx = idx + 1",
            "",
            "    if idx != len(pcr_values):",
            "        raise ValueError(\"Did not consume all entries in pcr_values list\")",
            "",
            "    quote_digest = digest.finalize()",
            "",
            "    return quote_digest, pcrs_dict",
            "",
            "",
            "def __get_and_hash_pcrs(pcrblob: bytes, hash_alg: int) -> Tuple[bytes, Dict[int, str]]:",
            "    pcr_select_count, tpml_pcr_selection, pcr_values = __get_pcrs_from_blob(pcrblob)",
            "    return __hash_pcr_banks(hash_alg, pcr_select_count, tpml_pcr_selection, pcr_values)",
            "",
            "",
            "def checkquote(",
            "    aikblob: bytes, nonce: str, sigblob: bytes, quoteblob: bytes, pcrblob: bytes, exp_hash_alg: str",
            ") -> Dict[int, str]:",
            "    \"\"\"Check the given quote by checking the signature, then the nonce and then the used hash",
            "",
            "    Parameters",
            "    ----------",
            "    aikblob: PEM-formatted public RSA or EC key",
            "    nonce: The nonce that was used during the quote",
            "    sigblob: Signature blob containing signature algorithm, hash used for signing, and plain signature",
            "    quoteblob: Marshalled TPMS_ATTEST",
            "    pcrblob: The state of the PCRs that were quoted; Intel tpm2-tools specific format",
            "    exp_hash_alg: The hash that was expected to have been used for quoting",
            "    \"\"\"",
            "    sig_alg, hash_alg, sig_size = struct.unpack_from(\">HHH\", sigblob, 0)",
            "",
            "    (signature,) = struct.unpack_from(f\"{sig_size}s\", sigblob, 6)",
            "",
            "    pubkey = serialization.load_pem_public_key(aikblob, backend=backends.default_backend())",
            "    if not isinstance(pubkey, (RSAPublicKey, EllipticCurvePublicKey)):",
            "        raise ValueError(f\"Unsupported key type {type(pubkey).__name__}\")",
            "",
            "    if isinstance(pubkey, RSAPublicKey) and sig_alg not in [tpm2_objects.TPM_ALG_RSASSA]:",
            "        raise ValueError(f\"Unsupported quote signature algorithm '{sig_alg:#x}' for RSA keys\")",
            "    if isinstance(pubkey, EllipticCurvePublicKey) and sig_alg not in [tpm2_objects.TPM_ALG_ECDSA]:",
            "        raise ValueError(f\"Unsupported quote signature algorithm '{sig_alg:#x}' for EC keys\")",
            "",
            "    hashfunc = tpm2_objects.HASH_FUNCS.get(hash_alg)",
            "    if not hashfunc:",
            "        raise ValueError(f\"Unsupported hash with id {hash_alg:#x} in signature blob\")",
            "    if hashfunc.name != exp_hash_alg:",
            "        raise ValueError(f\"Quote was expected to use {exp_hash_alg} but used {hashfunc.name} instead\")",
            "",
            "    digest = hashes.Hash(hashfunc, backend=backends.default_backend())",
            "    digest.update(quoteblob)",
            "    quote_digest = digest.finalize()",
            "",
            "    try:",
            "        verify(pubkey, signature, quote_digest, hashfunc)",
            "    except InvalidSignature:",
            "        logger.error(\"Invalid quote signature!\")",
            "",
            "    # Check that reported nonce is expected one",
            "    retDict = tpm2_objects.unmarshal_tpms_attest(quoteblob)",
            "    extradata = retDict[\"extraData\"]",
            "    if extradata.decode(\"utf-8\") != nonce:",
            "        raise Exception(\"The nonce from the attestation differs from the expected nonce\")",
            "",
            "    # Check that correct quote_digest was used which is equivalent to hash(quoteblob)",
            "    compare_digest, pcrs_dict = __get_and_hash_pcrs(pcrblob, hash_alg)",
            "    if retDict[\"attested.quote.pcrDigest\"] != compare_digest:",
            "        raise Exception(\"The digest used for quoting is different than the one that was calculated\")",
            "",
            "    return pcrs_dict",
            "",
            "",
            "def label_to_bytes(label: str) -> bytes:",
            "    return bytes(label, \"UTF-8\") + b\"\\x00\"",
            "",
            "",
            "def makecredential(ek_tpm: bytes, challenge: bytes, aik_name: bytes) -> bytes:",
            "    \"\"\"TPM_MakeCredential implementation",
            "",
            "    Parameters",
            "    ----------",
            "    ek_tpm: marshalled TPMT_PUBKEY",
            "    challenge: random 'password'",
            "    aik_name: name of the object (AIK)",
            "    \"\"\"",
            "    public_key, hash_alg = tpm2_objects.pubkey_parms_from_tpm2b_public(ek_tpm)",
            "",
            "    hashfunc = tpm2_objects.HASH_FUNCS.get(hash_alg)",
            "    if not hashfunc:",
            "        raise ValueError(f\"Unsupported hash with id {hash_alg:#x} in signature blob\")",
            "",
            "    if isinstance(public_key, RSAPublicKey):",
            "        random = os.urandom(hashfunc.digest_size)",
            "",
            "        secret = public_key.encrypt(",
            "            random,",
            "            padding.OAEP(mgf=padding.MGF1(algorithm=hashfunc), algorithm=hashfunc, label=label_to_bytes(\"IDENTITY\")),",
            "        )",
            "    elif isinstance(public_key, EllipticCurvePublicKey):",
            "        random, secret = crypt_secret_encrypt_ecc(public_key, hashfunc)",
            "    else:",
            "        raise ValueError(f\"Unsupported public key type {type(public_key)} for makecredential\")",
            "",
            "    credentialblob = secret_to_credential(challenge, aik_name, random, ek_tpm, hashfunc)",
            "",
            "    # Create tpm2-tools-specific result format",
            "    hdr = struct.pack(\">II\", 0xBADCC0DE, 1)",
            "    tail = struct.pack(f\">H{len(secret)}s\", len(secret), secret)",
            "",
            "    return hdr + credentialblob + tail",
            "",
            "",
            "def crypt_secret_encrypt_ecc(public_key: EllipticCurvePublicKey, hashfunc: hashes.HashAlgorithm) -> Tuple[bytes, bytes]:",
            "    my_private_key = ec.generate_private_key(public_key.curve)",
            "",
            "    my_public_key = my_private_key.public_key()",
            "    point = tpm2_objects.tpms_ecc_point_marshal(my_public_key)",
            "",
            "    ecc_secret_x = ec_crypto_helper.EcCryptoHelper.get_instance().point_multiply_x(public_key, my_private_key)",
            "",
            "    digest_size = hashfunc.digest_size",
            "",
            "    x = my_public_key.public_numbers().x",
            "    party_x = x.to_bytes((x.bit_length() + 7) >> 3, \"big\")",
            "",
            "    x = public_key.public_numbers().x",
            "    party_y = x.to_bytes((x.bit_length() + 7) >> 3, \"big\")",
            "",
            "    data = crypt_kdfe(hashfunc, ecc_secret_x, \"IDENTITY\", party_x, party_y, digest_size << 3)",
            "",
            "    return data, point",
            "",
            "",
            "def secret_to_credential(",
            "    secret: bytes, name: bytes, seed: bytes, ek_tpm: bytes, hashfunc: hashes.HashAlgorithm",
            ") -> bytes:",
            "    \"\"\"TPM 2's SecretToCredential",
            "",
            "    Parameters",
            "    ----------",
            "    secret: the secret",
            "    name: name of the object",
            "    seed: external seed",
            "    ek_tpm: marshalled TPMT_PUBKEY",
            "    hashfunc: the hash function used by the public key (extracted from ek_tpm)",
            "    \"\"\"",
            "    # sensitive data is the 2nd part in TPM2B_ID_OBJECT",
            "    sensitive_data_2b = struct.pack(f\">H{len(secret)}s\", len(secret), secret)",
            "    integrity, sensitive_data_enc = produce_outer_wrap(ek_tpm, name, hashfunc, seed, sensitive_data_2b)",
            "",
            "    tpms_id_object = struct.pack(",
            "        f\">H{len(integrity)}s{len(sensitive_data_enc)}s\",",
            "        len(integrity),",
            "        integrity,",
            "        sensitive_data_enc,",
            "    )",
            "",
            "    return struct.pack(f\">H{len(tpms_id_object)}s\", len(tpms_id_object), tpms_id_object)",
            "",
            "",
            "def produce_outer_wrap(",
            "    ek_tpm: bytes,",
            "    name: bytes,",
            "    hashfunc: hashes.HashAlgorithm,",
            "    seed: bytes,",
            "    sensitive_data_2b: bytes,",
            ") -> Tuple[bytes, bytes]:",
            "    \"\"\"TPM 2's ProduceOuterWrap implementing encrypt-then-MAC of a secret",
            "",
            "    Parameters",
            "    ----------",
            "    ek_tpm: marshalled TPMT_PUBKEY",
            "    name: name of the object",
            "    hashfunc: the hash function used by the public key (extracted from ek_tpm)",
            "    seed: external seed",
            "    sensitive_data_2b: marshalled TPM2B buffer holding a secret",
            "    \"\"\"",
            "    symkey, sym_alg = compute_protection_key_parms(ek_tpm, hashfunc, name, seed)",
            "",
            "    # Encrypt inner buffer",
            "    symcipherfunc = tpm2_objects.SYMCIPHER_FUNCS.get(sym_alg)",
            "    if not symcipherfunc:",
            "        raise ValueError(f\"Unsupported symmetric cipher with Id {sym_alg:#x} was requested\")",
            "",
            "    symcipher = symcipherfunc(symkey)",
            "    block_size = symcipher.block_size >> 3",
            "    encryptor = Cipher(symcipher, modes.CFB(b\"\\x00\" * block_size)).encryptor()",
            "    ciphertext = encryptor.update(sensitive_data_2b) + encryptor.finalize()",
            "",
            "    # Compute outer integrity",
            "    hmac_signature = compute_outer_integrity(name, hashfunc, seed, ciphertext)",
            "",
            "    return hmac_signature, ciphertext",
            "",
            "",
            "def compute_outer_integrity(",
            "    name: bytes,",
            "    hashfunc: hashes.HashAlgorithm,",
            "    seed: bytes,",
            "    ciphertext: bytes,",
            ") -> bytes:",
            "    \"\"\"TPM 2's ComputeOuterIntegrity HMAC'ing a ciphertext",
            "",
            "    Parameters",
            "    ----------",
            "    name: name of the object; this will be part of the HMAC'ed data",
            "    hashfunc: hash function to use for HMAC",
            "    seed: external seed",
            "    ciphertext: ciphertext to HMAC",
            "    \"\"\"",
            "    digest_size = hashfunc.digest_size",
            "",
            "    hmac_key = crypt_kdfa(hashfunc, seed, \"INTEGRITY\", b\"\", b\"\", digest_size << 3)",
            "",
            "    h = hmac.HMAC(hmac_key, hashfunc)",
            "    h.update(ciphertext)",
            "    h.update(name)",
            "    return h.finalize()",
            "",
            "",
            "def compute_protection_key_parms(",
            "    ek_tpm: bytes, hashfunc: hashes.HashAlgorithm, name: bytes, seed: bytes",
            ") -> Tuple[bytes, int]:",
            "    \"\"\"TPM 2's ComputeProtectionKeyParms deriving a symmetric key using KDFa",
            "",
            "    Parameters",
            "    ----------",
            "    ek_tpm: marshalled TPMT_PUBKEY",
            "    hashfunc: hash function to use for key derivation",
            "    name: name of the object",
            "    seed: external seed",
            "    \"\"\"",
            "    assert len(seed) > 0",
            "",
            "    sym_alg, symkey_bits = tpm2_objects.get_tpm2b_public_symkey_params(ek_tpm)",
            "",
            "    symkey = crypt_kdfa(hashfunc, seed, \"STORAGE\", name, b\"\", symkey_bits)",
            "",
            "    return symkey, sym_alg",
            "",
            "",
            "def crypt_kdfa(",
            "    hashfunc: hashes.HashAlgorithm,",
            "    key: bytes,",
            "    label: str,",
            "    context_u: bytes,",
            "    context_v: bytes,",
            "    size_in_bits: int,",
            ") -> bytes:",
            "    \"\"\"TPM 2's KDFa",
            "",
            "    Parameters",
            "    ----------",
            "    hashfunc: hash function",
            "    key: key to use for HMAC",
            "    label: a label to add to the HMAC",
            "    context_u: context to add to the HMAC",
            "    context_v: context to add to the HMAC",
            "    size_in_bits: how many bits of random data to generate",
            "    \"\"\"",
            "    size_in_bytes = (size_in_bits + 7) >> 3",
            "    label_bytes = label_to_bytes(label)",
            "    context = context_u + context_v",
            "",
            "    ctr = 0",
            "    result = b\"\"",
            "",
            "    size = size_in_bytes",
            "",
            "    while size > 0:",
            "        h = hmac.HMAC(key, hashfunc)",
            "        ctr += 1",
            "        h.update(struct.pack(\">I\", ctr))",
            "        h.update(label_bytes)",
            "        if context:",
            "            h.update(context)",
            "        h.update(struct.pack(\">I\", size_in_bits))",
            "        result += h.finalize()",
            "",
            "        size -= hashfunc.digest_size",
            "",
            "    return result[:size_in_bytes]",
            "",
            "",
            "def crypt_kdfe(",
            "    hashfunc: hashes.HashAlgorithm,",
            "    secret_x: bytes,",
            "    label: str,",
            "    party_x: bytes,",
            "    party_y: bytes,",
            "    size_in_bits: int,",
            ") -> bytes:",
            "    \"\"\"TPM 2's KDFe",
            "",
            "    Parameters",
            "    ----------",
            "    hashfunc: hash function",
            "    secret_x: the X coordinate of the product of a public ECC key and a different private ECC key",
            "    label: a label to add to the digest",
            "    party_x: context to add to the digest",
            "    party_y: context to add to the digest",
            "    size_in_bits: how many bits of random data to generate",
            "    \"\"\"",
            "    size_in_bytes = (size_in_bits + 7) >> 3",
            "    label_bytes = label_to_bytes(label)",
            "    party = party_x + party_y",
            "",
            "    ctr = 0",
            "    result = b\"\"",
            "",
            "    size = size_in_bytes",
            "",
            "    while size > 0:",
            "        digest = hashes.Hash(hashfunc, backend=backends.default_backend())",
            "        ctr += 1",
            "        digest.update(struct.pack(\">I\", ctr))",
            "        if secret_x:",
            "            digest.update(secret_x)",
            "        digest.update(label_bytes)",
            "        if party:",
            "            digest.update(party)",
            "        result += digest.finalize()",
            "",
            "        size -= hashfunc.digest_size",
            "",
            "    return result[:size_in_bytes]",
            "",
            "",
            "def check_mask(mask: Optional[str], pcr: int) -> bool:",
            "    if mask is None:",
            "        return False",
            "    return bool(1 << pcr & int(mask, 0))",
            "",
            "",
            "def random_password(length: int = 20) -> str:",
            "    rand = crypto.generate_random_key(length)",
            "    chars = string.ascii_uppercase + string.digits + string.ascii_lowercase",
            "    password = \"\"",
            "    for i in range(length):",
            "        password += chars[(rand[i]) % len(chars)]",
            "    return password",
            "",
            "",
            "def readPolicy(configval: str) -> Dict[str, Any]:",
            "    policy: Dict[str, Any] = json.loads(configval)",
            "",
            "    # compute PCR mask from tpm_policy",
            "    mask = 0",
            "    for key in policy:",
            "        if not key.isdigit() or int(key) > 24:",
            "            raise Exception(f\"Invalid tpm policy pcr number: {key}\")",
            "",
            "        if int(key) == config.TPM_DATA_PCR:",
            "            raise Exception(f\"Invalid allowlist PCR number {key}, keylime uses this PCR to bind data.\")",
            "        if int(key) == config.IMA_PCR:",
            "            raise Exception(f\"Invalid allowlist PCR number {key}, this PCR is used for IMA.\")",
            "",
            "        mask = mask | (1 << int(key))",
            "",
            "        # wrap it in a list if it is a singleton",
            "        if isinstance(policy[key], str):",
            "            policy[key] = [policy[key]]",
            "",
            "        # convert all hash values to lowercase",
            "        policy[key] = [x.lower() for x in policy[key]]",
            "",
            "    policy[\"mask\"] = hex(mask)",
            "    return policy"
        ],
        "afterPatchFile": [
            "import os",
            "import string",
            "import struct",
            "from typing import Any, Dict, List, Optional, Tuple, Union",
            "",
            "from cryptography.hazmat import backends",
            "from cryptography.hazmat.primitives import hashes, hmac, serialization",
            "from cryptography.hazmat.primitives.asymmetric import ec, padding",
            "from cryptography.hazmat.primitives.asymmetric.ec import EllipticCurvePublicKey",
            "from cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicKey",
            "from cryptography.hazmat.primitives.asymmetric.utils import Prehashed",
            "from cryptography.hazmat.primitives.ciphers import Cipher, modes",
            "",
            "from keylime import config, crypto, json, keylime_logging",
            "from keylime.tpm import ec_crypto_helper, tpm2_objects",
            "",
            "logger = keylime_logging.init_logging(\"tpm_util\")",
            "",
            "SupportedKeyTypes = Union[RSAPublicKey, EllipticCurvePublicKey]",
            "",
            "",
            "def verify(pubkey: SupportedKeyTypes, sig: bytes, digest: bytes, hashfunc: hashes.HashAlgorithm) -> None:",
            "    \"\"\"Do signature verification with the given public key\"\"\"",
            "    if isinstance(pubkey, RSAPublicKey):",
            "        pubkey.verify(sig, digest, padding.PKCS1v15(), Prehashed(hashfunc))",
            "    elif isinstance(pubkey, EllipticCurvePublicKey):",
            "        pubkey.verify(sig, digest, ec.ECDSA(Prehashed(hashfunc)))",
            "",
            "",
            "def __get_pcrs_from_blob(pcrblob: bytes) -> Tuple[int, Dict[int, int], List[bytes]]:",
            "    \"\"\"This function is specific to the Intel tools with data in little endian format.",
            "    Data structures were not marshalled but written right from memory.\"\"\"",
            "    # TPML_PCR_SELECTION:count",
            "    (pcr_select_count,) = struct.unpack_from(\"<I\", pcrblob, 0)",
            "",
            "    o = 4",
            "    # TPML_PCR_SELECTION:TPMS_PCR_SELECTION[HASH_COUNT]",
            "    tpml_pcr_selection: Dict[int, int] = {}",
            "    for _ in range(0, 16):",
            "        hash_alg, size_of_select = struct.unpack_from(\"<HB\", pcrblob, o)",
            "        if size_of_select not in [0, 3]:",
            "            raise ValueError(f\"size_of_select must be either 0 or 3 but it is {size_of_select}\")",
            "        o = o + 3",
            "",
            "        if size_of_select == 3:",
            "            (pcr_select_bytes,) = struct.unpack_from(\"3s\", pcrblob, o)",
            "            pcr_select = pcr_select_bytes[0] | pcr_select_bytes[1] << 8 | pcr_select_bytes[2] << 16",
            "        else:",
            "            pcr_select = 0",
            "",
            "        tpml_pcr_selection[hash_alg] = pcr_select",
            "",
            "        # always advance by size_of_select = 3 and 2 bytes alignment",
            "        o = o + 3 + 2",
            "",
            "    # Number of subsequent TPML_DIGEST's",
            "    (pcrs_count,) = struct.unpack_from(\"<I\", pcrblob, o)",
            "    o = o + 4",
            "",
            "    pcr_values: List[bytes] = []",
            "",
            "    for _ in range(0, pcrs_count):",
            "        # TPML_DIGEST::count",
            "        (_,) = struct.unpack_from(\"<I\", pcrblob, o)",
            "        o = o + 4",
            "",
            "        # TPML_DIGEST::TPM2B_DIGEST[8]",
            "        for _ in range(0, 8):",
            "            (sz,) = struct.unpack_from(\"<H\", pcrblob, o)",
            "            o = o + 2",
            "            if sz:",
            "                (pcr_value,) = struct.unpack_from(f\"{sz}s\", pcrblob, o)",
            "                pcr_values.append(pcr_value)",
            "            # Always advance by the size of TPMU_HA (= size of SHA512)",
            "            o = o + 64",
            "",
            "    if o != len(pcrblob):",
            "        raise ValueError(\"Failed to parse the entire pcrblob\")",
            "",
            "    return pcr_select_count, tpml_pcr_selection, pcr_values",
            "",
            "",
            "def __hash_pcr_banks(",
            "    hash_alg: int, pcr_select_count: int, tpml_pcr_selection: Dict[int, int], pcr_values: List[bytes]",
            ") -> Tuple[bytes, Dict[int, str]]:",
            "    \"\"\"From the tpml_pcr_selection determine which PCRs were quoted and hash these PCRs to get",
            "    the hash that was used for the quote. Build a dict that contains the PCR values.\"\"\"",
            "    hashfunc = tpm2_objects.HASH_FUNCS.get(hash_alg)",
            "    if not hashfunc:",
            "        raise ValueError(f\"Unsupported hash with id {hash_alg:#x} in signature blob\")",
            "",
            "    digest = hashes.Hash(hashfunc, backend=backends.default_backend())",
            "",
            "    idx = 0",
            "    pcrs_dict: Dict[int, str] = {}",
            "",
            "    for _ in range(0, pcr_select_count):",
            "        for pcr_id in range(0, 24):",
            "            if tpml_pcr_selection[hash_alg] & (1 << pcr_id) == 0:",
            "                continue",
            "            if idx >= len(pcr_values):",
            "                raise ValueError(f\"pcr_values list is too short to get item {idx}\")",
            "            digest.update(pcr_values[idx])",
            "            pcrs_dict[pcr_id] = pcr_values[idx].hex()",
            "            idx = idx + 1",
            "",
            "    if idx != len(pcr_values):",
            "        raise ValueError(\"Did not consume all entries in pcr_values list\")",
            "",
            "    quote_digest = digest.finalize()",
            "",
            "    return quote_digest, pcrs_dict",
            "",
            "",
            "def __get_and_hash_pcrs(pcrblob: bytes, hash_alg: int) -> Tuple[bytes, Dict[int, str]]:",
            "    pcr_select_count, tpml_pcr_selection, pcr_values = __get_pcrs_from_blob(pcrblob)",
            "    return __hash_pcr_banks(hash_alg, pcr_select_count, tpml_pcr_selection, pcr_values)",
            "",
            "",
            "def checkquote(",
            "    aikblob: bytes, nonce: str, sigblob: bytes, quoteblob: bytes, pcrblob: bytes, exp_hash_alg: str",
            ") -> Dict[int, str]:",
            "    \"\"\"Check the given quote by checking the signature, then the nonce and then the used hash",
            "",
            "    Parameters",
            "    ----------",
            "    aikblob: PEM-formatted public RSA or EC key",
            "    nonce: The nonce that was used during the quote",
            "    sigblob: Signature blob containing signature algorithm, hash used for signing, and plain signature",
            "    quoteblob: Marshalled TPMS_ATTEST",
            "    pcrblob: The state of the PCRs that were quoted; Intel tpm2-tools specific format",
            "    exp_hash_alg: The hash that was expected to have been used for quoting",
            "    \"\"\"",
            "    sig_alg, hash_alg, sig_size = struct.unpack_from(\">HHH\", sigblob, 0)",
            "",
            "    (signature,) = struct.unpack_from(f\"{sig_size}s\", sigblob, 6)",
            "",
            "    pubkey = serialization.load_pem_public_key(aikblob, backend=backends.default_backend())",
            "    if not isinstance(pubkey, (RSAPublicKey, EllipticCurvePublicKey)):",
            "        raise ValueError(f\"Unsupported key type {type(pubkey).__name__}\")",
            "",
            "    if isinstance(pubkey, RSAPublicKey) and sig_alg not in [tpm2_objects.TPM_ALG_RSASSA]:",
            "        raise ValueError(f\"Unsupported quote signature algorithm '{sig_alg:#x}' for RSA keys\")",
            "    if isinstance(pubkey, EllipticCurvePublicKey) and sig_alg not in [tpm2_objects.TPM_ALG_ECDSA]:",
            "        raise ValueError(f\"Unsupported quote signature algorithm '{sig_alg:#x}' for EC keys\")",
            "",
            "    hashfunc = tpm2_objects.HASH_FUNCS.get(hash_alg)",
            "    if not hashfunc:",
            "        raise ValueError(f\"Unsupported hash with id {hash_alg:#x} in signature blob\")",
            "    if hashfunc.name != exp_hash_alg:",
            "        raise ValueError(f\"Quote was expected to use {exp_hash_alg} but used {hashfunc.name} instead\")",
            "",
            "    digest = hashes.Hash(hashfunc, backend=backends.default_backend())",
            "    digest.update(quoteblob)",
            "    quote_digest = digest.finalize()",
            "",
            "    verify(pubkey, signature, quote_digest, hashfunc)",
            "",
            "    # Check that reported nonce is expected one",
            "    retDict = tpm2_objects.unmarshal_tpms_attest(quoteblob)",
            "    extradata = retDict[\"extraData\"]",
            "    if extradata.decode(\"utf-8\") != nonce:",
            "        raise Exception(\"The nonce from the attestation differs from the expected nonce\")",
            "",
            "    # Check that correct quote_digest was used which is equivalent to hash(quoteblob)",
            "    compare_digest, pcrs_dict = __get_and_hash_pcrs(pcrblob, hash_alg)",
            "    if retDict[\"attested.quote.pcrDigest\"] != compare_digest:",
            "        raise Exception(\"The digest used for quoting is different than the one that was calculated\")",
            "",
            "    return pcrs_dict",
            "",
            "",
            "def label_to_bytes(label: str) -> bytes:",
            "    return bytes(label, \"UTF-8\") + b\"\\x00\"",
            "",
            "",
            "def makecredential(ek_tpm: bytes, challenge: bytes, aik_name: bytes) -> bytes:",
            "    \"\"\"TPM_MakeCredential implementation",
            "",
            "    Parameters",
            "    ----------",
            "    ek_tpm: marshalled TPMT_PUBKEY",
            "    challenge: random 'password'",
            "    aik_name: name of the object (AIK)",
            "    \"\"\"",
            "    public_key, hash_alg = tpm2_objects.pubkey_parms_from_tpm2b_public(ek_tpm)",
            "",
            "    hashfunc = tpm2_objects.HASH_FUNCS.get(hash_alg)",
            "    if not hashfunc:",
            "        raise ValueError(f\"Unsupported hash with id {hash_alg:#x} in signature blob\")",
            "",
            "    if isinstance(public_key, RSAPublicKey):",
            "        random = os.urandom(hashfunc.digest_size)",
            "",
            "        secret = public_key.encrypt(",
            "            random,",
            "            padding.OAEP(mgf=padding.MGF1(algorithm=hashfunc), algorithm=hashfunc, label=label_to_bytes(\"IDENTITY\")),",
            "        )",
            "    elif isinstance(public_key, EllipticCurvePublicKey):",
            "        random, secret = crypt_secret_encrypt_ecc(public_key, hashfunc)",
            "    else:",
            "        raise ValueError(f\"Unsupported public key type {type(public_key)} for makecredential\")",
            "",
            "    credentialblob = secret_to_credential(challenge, aik_name, random, ek_tpm, hashfunc)",
            "",
            "    # Create tpm2-tools-specific result format",
            "    hdr = struct.pack(\">II\", 0xBADCC0DE, 1)",
            "    tail = struct.pack(f\">H{len(secret)}s\", len(secret), secret)",
            "",
            "    return hdr + credentialblob + tail",
            "",
            "",
            "def crypt_secret_encrypt_ecc(public_key: EllipticCurvePublicKey, hashfunc: hashes.HashAlgorithm) -> Tuple[bytes, bytes]:",
            "    my_private_key = ec.generate_private_key(public_key.curve)",
            "",
            "    my_public_key = my_private_key.public_key()",
            "    point = tpm2_objects.tpms_ecc_point_marshal(my_public_key)",
            "",
            "    ecc_secret_x = ec_crypto_helper.EcCryptoHelper.get_instance().point_multiply_x(public_key, my_private_key)",
            "",
            "    digest_size = hashfunc.digest_size",
            "",
            "    x = my_public_key.public_numbers().x",
            "    party_x = x.to_bytes((x.bit_length() + 7) >> 3, \"big\")",
            "",
            "    x = public_key.public_numbers().x",
            "    party_y = x.to_bytes((x.bit_length() + 7) >> 3, \"big\")",
            "",
            "    data = crypt_kdfe(hashfunc, ecc_secret_x, \"IDENTITY\", party_x, party_y, digest_size << 3)",
            "",
            "    return data, point",
            "",
            "",
            "def secret_to_credential(",
            "    secret: bytes, name: bytes, seed: bytes, ek_tpm: bytes, hashfunc: hashes.HashAlgorithm",
            ") -> bytes:",
            "    \"\"\"TPM 2's SecretToCredential",
            "",
            "    Parameters",
            "    ----------",
            "    secret: the secret",
            "    name: name of the object",
            "    seed: external seed",
            "    ek_tpm: marshalled TPMT_PUBKEY",
            "    hashfunc: the hash function used by the public key (extracted from ek_tpm)",
            "    \"\"\"",
            "    # sensitive data is the 2nd part in TPM2B_ID_OBJECT",
            "    sensitive_data_2b = struct.pack(f\">H{len(secret)}s\", len(secret), secret)",
            "    integrity, sensitive_data_enc = produce_outer_wrap(ek_tpm, name, hashfunc, seed, sensitive_data_2b)",
            "",
            "    tpms_id_object = struct.pack(",
            "        f\">H{len(integrity)}s{len(sensitive_data_enc)}s\",",
            "        len(integrity),",
            "        integrity,",
            "        sensitive_data_enc,",
            "    )",
            "",
            "    return struct.pack(f\">H{len(tpms_id_object)}s\", len(tpms_id_object), tpms_id_object)",
            "",
            "",
            "def produce_outer_wrap(",
            "    ek_tpm: bytes,",
            "    name: bytes,",
            "    hashfunc: hashes.HashAlgorithm,",
            "    seed: bytes,",
            "    sensitive_data_2b: bytes,",
            ") -> Tuple[bytes, bytes]:",
            "    \"\"\"TPM 2's ProduceOuterWrap implementing encrypt-then-MAC of a secret",
            "",
            "    Parameters",
            "    ----------",
            "    ek_tpm: marshalled TPMT_PUBKEY",
            "    name: name of the object",
            "    hashfunc: the hash function used by the public key (extracted from ek_tpm)",
            "    seed: external seed",
            "    sensitive_data_2b: marshalled TPM2B buffer holding a secret",
            "    \"\"\"",
            "    symkey, sym_alg = compute_protection_key_parms(ek_tpm, hashfunc, name, seed)",
            "",
            "    # Encrypt inner buffer",
            "    symcipherfunc = tpm2_objects.SYMCIPHER_FUNCS.get(sym_alg)",
            "    if not symcipherfunc:",
            "        raise ValueError(f\"Unsupported symmetric cipher with Id {sym_alg:#x} was requested\")",
            "",
            "    symcipher = symcipherfunc(symkey)",
            "    block_size = symcipher.block_size >> 3",
            "    encryptor = Cipher(symcipher, modes.CFB(b\"\\x00\" * block_size)).encryptor()",
            "    ciphertext = encryptor.update(sensitive_data_2b) + encryptor.finalize()",
            "",
            "    # Compute outer integrity",
            "    hmac_signature = compute_outer_integrity(name, hashfunc, seed, ciphertext)",
            "",
            "    return hmac_signature, ciphertext",
            "",
            "",
            "def compute_outer_integrity(",
            "    name: bytes,",
            "    hashfunc: hashes.HashAlgorithm,",
            "    seed: bytes,",
            "    ciphertext: bytes,",
            ") -> bytes:",
            "    \"\"\"TPM 2's ComputeOuterIntegrity HMAC'ing a ciphertext",
            "",
            "    Parameters",
            "    ----------",
            "    name: name of the object; this will be part of the HMAC'ed data",
            "    hashfunc: hash function to use for HMAC",
            "    seed: external seed",
            "    ciphertext: ciphertext to HMAC",
            "    \"\"\"",
            "    digest_size = hashfunc.digest_size",
            "",
            "    hmac_key = crypt_kdfa(hashfunc, seed, \"INTEGRITY\", b\"\", b\"\", digest_size << 3)",
            "",
            "    h = hmac.HMAC(hmac_key, hashfunc)",
            "    h.update(ciphertext)",
            "    h.update(name)",
            "    return h.finalize()",
            "",
            "",
            "def compute_protection_key_parms(",
            "    ek_tpm: bytes, hashfunc: hashes.HashAlgorithm, name: bytes, seed: bytes",
            ") -> Tuple[bytes, int]:",
            "    \"\"\"TPM 2's ComputeProtectionKeyParms deriving a symmetric key using KDFa",
            "",
            "    Parameters",
            "    ----------",
            "    ek_tpm: marshalled TPMT_PUBKEY",
            "    hashfunc: hash function to use for key derivation",
            "    name: name of the object",
            "    seed: external seed",
            "    \"\"\"",
            "    assert len(seed) > 0",
            "",
            "    sym_alg, symkey_bits = tpm2_objects.get_tpm2b_public_symkey_params(ek_tpm)",
            "",
            "    symkey = crypt_kdfa(hashfunc, seed, \"STORAGE\", name, b\"\", symkey_bits)",
            "",
            "    return symkey, sym_alg",
            "",
            "",
            "def crypt_kdfa(",
            "    hashfunc: hashes.HashAlgorithm,",
            "    key: bytes,",
            "    label: str,",
            "    context_u: bytes,",
            "    context_v: bytes,",
            "    size_in_bits: int,",
            ") -> bytes:",
            "    \"\"\"TPM 2's KDFa",
            "",
            "    Parameters",
            "    ----------",
            "    hashfunc: hash function",
            "    key: key to use for HMAC",
            "    label: a label to add to the HMAC",
            "    context_u: context to add to the HMAC",
            "    context_v: context to add to the HMAC",
            "    size_in_bits: how many bits of random data to generate",
            "    \"\"\"",
            "    size_in_bytes = (size_in_bits + 7) >> 3",
            "    label_bytes = label_to_bytes(label)",
            "    context = context_u + context_v",
            "",
            "    ctr = 0",
            "    result = b\"\"",
            "",
            "    size = size_in_bytes",
            "",
            "    while size > 0:",
            "        h = hmac.HMAC(key, hashfunc)",
            "        ctr += 1",
            "        h.update(struct.pack(\">I\", ctr))",
            "        h.update(label_bytes)",
            "        if context:",
            "            h.update(context)",
            "        h.update(struct.pack(\">I\", size_in_bits))",
            "        result += h.finalize()",
            "",
            "        size -= hashfunc.digest_size",
            "",
            "    return result[:size_in_bytes]",
            "",
            "",
            "def crypt_kdfe(",
            "    hashfunc: hashes.HashAlgorithm,",
            "    secret_x: bytes,",
            "    label: str,",
            "    party_x: bytes,",
            "    party_y: bytes,",
            "    size_in_bits: int,",
            ") -> bytes:",
            "    \"\"\"TPM 2's KDFe",
            "",
            "    Parameters",
            "    ----------",
            "    hashfunc: hash function",
            "    secret_x: the X coordinate of the product of a public ECC key and a different private ECC key",
            "    label: a label to add to the digest",
            "    party_x: context to add to the digest",
            "    party_y: context to add to the digest",
            "    size_in_bits: how many bits of random data to generate",
            "    \"\"\"",
            "    size_in_bytes = (size_in_bits + 7) >> 3",
            "    label_bytes = label_to_bytes(label)",
            "    party = party_x + party_y",
            "",
            "    ctr = 0",
            "    result = b\"\"",
            "",
            "    size = size_in_bytes",
            "",
            "    while size > 0:",
            "        digest = hashes.Hash(hashfunc, backend=backends.default_backend())",
            "        ctr += 1",
            "        digest.update(struct.pack(\">I\", ctr))",
            "        if secret_x:",
            "            digest.update(secret_x)",
            "        digest.update(label_bytes)",
            "        if party:",
            "            digest.update(party)",
            "        result += digest.finalize()",
            "",
            "        size -= hashfunc.digest_size",
            "",
            "    return result[:size_in_bytes]",
            "",
            "",
            "def check_mask(mask: Optional[str], pcr: int) -> bool:",
            "    if mask is None:",
            "        return False",
            "    return bool(1 << pcr & int(mask, 0))",
            "",
            "",
            "def random_password(length: int = 20) -> str:",
            "    rand = crypto.generate_random_key(length)",
            "    chars = string.ascii_uppercase + string.digits + string.ascii_lowercase",
            "    password = \"\"",
            "    for i in range(length):",
            "        password += chars[(rand[i]) % len(chars)]",
            "    return password",
            "",
            "",
            "def readPolicy(configval: str) -> Dict[str, Any]:",
            "    policy: Dict[str, Any] = json.loads(configval)",
            "",
            "    # compute PCR mask from tpm_policy",
            "    mask = 0",
            "    for key in policy:",
            "        if not key.isdigit() or int(key) > 24:",
            "            raise Exception(f\"Invalid tpm policy pcr number: {key}\")",
            "",
            "        if int(key) == config.TPM_DATA_PCR:",
            "            raise Exception(f\"Invalid allowlist PCR number {key}, keylime uses this PCR to bind data.\")",
            "        if int(key) == config.IMA_PCR:",
            "            raise Exception(f\"Invalid allowlist PCR number {key}, this PCR is used for IMA.\")",
            "",
            "        mask = mask | (1 << int(key))",
            "",
            "        # wrap it in a list if it is a singleton",
            "        if isinstance(policy[key], str):",
            "            policy[key] = [policy[key]]",
            "",
            "        # convert all hash values to lowercase",
            "        policy[key] = [x.lower() for x in policy[key]]",
            "",
            "    policy[\"mask\"] = hex(mask)",
            "    return policy"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "6": [],
            "158": [
                "checkquote"
            ],
            "159": [
                "checkquote"
            ],
            "160": [
                "checkquote"
            ],
            "161": [
                "checkquote"
            ]
        },
        "addLocation": []
    },
    "keylime/tpm/tpm_util_test.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import unittest"
            },
            "1": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from unittest import mock"
            },
            "2": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+from cryptography.exceptions import InvalidSignature"
            },
            "4": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from cryptography.hazmat.primitives.asymmetric.ec import ("
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": "     SECP256R1,"
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": "     EllipticCurve,"
            },
            "7": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "         except Exception as e:"
            },
            "8": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "             self.fail(f\"checkquote failed with {e}\")"
            },
            "9": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+        # test bad input"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+        bad_quoteblob = bytearray(quoteblob)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+        bad_quoteblob[5] ^= 0x1"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        with self.assertRaises(InvalidSignature):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+            checkquote(aikblob, nonce, sigblob, bad_quoteblob, pcrblob, \"sha256\")"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+        l = list(nonce)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+        l[0] = \"a\""
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+        bad_nonce = \"\".join(l)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+        with self.assertRaises(Exception):"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+            checkquote(aikblob, bad_nonce, sigblob, quoteblob, pcrblob, \"sha256\")"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+        bad_pcrblob = bytearray(pcrblob)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+        bad_pcrblob[5] ^= 0x1"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+        with self.assertRaises(Exception):"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+            checkquote(aikblob, nonce, sigblob, quoteblob, bad_pcrblob, \"sha256\")"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+        with self.assertRaises(ValueError):"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+            checkquote(aikblob, nonce, sigblob, quoteblob, pcrblob, \"sha1\")"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "     @staticmethod"
            },
            "31": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "     def not_random(numbytes: int) -> bytes:"
            },
            "32": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "         return b\"\\x12\" * numbytes"
            }
        },
        "frontPatchFile": [
            "import base64",
            "import unittest",
            "from unittest import mock",
            "",
            "from cryptography.hazmat.primitives.asymmetric.ec import (",
            "    SECP256R1,",
            "    EllipticCurve,",
            "    EllipticCurvePrivateKey,",
            "    EllipticCurvePrivateNumbers,",
            "    EllipticCurvePublicNumbers,",
            ")",
            "",
            "from keylime.tpm.tpm_util import checkquote, makecredential",
            "",
            "",
            "class TestTpmUtil(unittest.TestCase):",
            "    def test_checkquote(self) -> None:",
            "        aikblob = bytes(",
            "            \"-----BEGIN PUBLIC KEY-----\\n\"",
            "            \"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAw3owm7uitOaspMCDlhEv\\n\"",
            "            \"bxNgGsxa1MpbHytT/Y9K0sdpTxgay571B8zvLOUbJHEJ0gt4NHY0+/NCzIAzT6kB\\n\"",
            "            \"n7aL67BV8QiyKBcywlVGS9PqYGoB9uxozDap/O9Bc5WrQUCso4m4TxrW1QOOBkNX\\n\"",
            "            \"x5OnresvsRv5O3m6BYZeUk2pJOyiBXM0HEkEC/Q/hxsfF1KfJG3JYOhpdF0E//dy\\n\"",
            "            \"LHOtdW9FP8Dt3YZuchJmyhFDjMKuxF2Zt7YVk9Pg4ZvmJ64CmOtshUj9k+Ctj44Z\\n\"",
            "            \"gMS/cIVmMrk7cdUBEBtq8x3g0cARZ5cUb4KB+dO0v/fvZkb4Qt5zwym1eUzmvVfD\\n\"",
            "            \"6QIDAQAB\\n\"",
            "            \"-----END PUBLIC KEY-----\",",
            "            \"utf-8\",",
            "        )",
            "        sigblob = base64.b64decode(",
            "            \"ABQACwEAgkUGLLuWpJETl3E5G2mvoVqbgVxzwAluOtyUwkoZEC2j4DeqOrl/q7jLaAC2KxDcoJbk\"",
            "            \"QPqu2sgwV84lfZOqRNhCydiwxbBTPIXImoDsCnkpkYwrk9NJcM+18qm/+f5V2/8QBQQmbN+6EV3I\"",
            "            \"gpSOYor2XcVntHCIrcloh/qN2gjihXDSjtHH9aSwOH7Z69gzyTt/4yVul7QRAOQCjqnasaSEGvoA\"",
            "            \"vtIin0aJLfD9wo1wlRzRDU62t3oHKLY49tMA3hQYF15+If/NsTKCTmUKmiKLBTk3yWAE64ThCxpB\"",
            "            \"EED6peiJlSxhdkyRm632IWAt8ahuyrfi/iEDVfyV+LnTBw==\"",
            "        )",
            "        quoteblob = base64.b64decode(",
            "            \"/1RDR4AYACIACzi1x2WoenP+buZXpt2LdpW0GTj5lBE6PXQmPZ0upQM0ABRBaTVNNVNqWWpua3l2\"",
            "            \"NFA3aXRIMQAAAABMlE7mAAAAAwAAAAABIBkQIwAWNjYAAAABAAsDAAABACBtTTdJEy9iVxchZM1f\"",
            "            \"8xNfRHlz1KXITgGJAfZ1NwW3AQ==\"",
            "        )",
            "        pcrblob = base64.b64decode(",
            "            \"AQAAAAsAAwAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "            \"AAAAAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAAgANRxwGdJUfDvB1rs3UL776bspgGYIK3QvSItHE5i\"",
            "            \"Qs5vAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\"",
            "        )",
            "        nonce = \"Ai5M5SjYjnkyv4P7itH1\"",
            "",
            "        try:",
            "            checkquote(aikblob, nonce, sigblob, quoteblob, pcrblob, \"sha256\")",
            "        except Exception as e:",
            "            self.fail(f\"checkquote failed with {e}\")",
            "",
            "    @staticmethod",
            "    def not_random(numbytes: int) -> bytes:",
            "        return b\"\\x12\" * numbytes",
            "",
            "    def test_makecredential(self) -> None:",
            "        with mock.patch(\"os.urandom\", TestTpmUtil.not_random):",
            "            ek_tpm = bytes.fromhex(",
            "                \"013a0001000b000300b20020837197674484b3f81a90cc8d46a5d724fd52d76e06520b64f2a1\"",
            "                \"da1b331469aa00060080004300100800000000000100aef12278a9b8d8a1e5700fb835ff3d9b\"",
            "                \"613d0d6fc17df186711260244f3f24847eb3ef1f5ff9b53d01cfebf291104385fbd71ead80a8\"",
            "                \"294ebc76f671859b7c3c9a998300f30859ef3fdba00c5229f17092fd97f19128243000205cfe\"",
            "                \"5ba24f5fc55538e52bf849c6f777690919929c7d2d9328070a2a6bdd67355a516b94afdceda0\"",
            "                \"0a0d27988a28644b30ac11beae23a51d9038cd9d789ae39cae15c1312ef174e217449771a602\"",
            "                \"ade4daf35b20e072017c85a2f211fe5512319184059ddeaab94fa331c49c3f213bc3fbccd1e8\"",
            "                \"56b8984353ac92e3df0f72f1e5c0b97b9cdc333702872e9e63565c809d81fa8bb6c6da86867c\"",
            "                \"ead2adedc0cee80bb6617183\"",
            "            )",
            "            challenge = bytes.fromhex(\"5a4e524b4f4e6e777552754831683734785a466a42416f314758676c484d4149\")",
            "            aik_name = bytes.fromhex(\"000b9601163463aacdb45be7ad1f6d11ad3dae0578d5aeeb5125e1075c5601b7c7fa\")",
            "",
            "            credential = makecredential(ek_tpm, challenge, aik_name)",
            "",
            "            # the signature is not 'constant' due to OAEP padding",
            "            self.assertEqual(",
            "                credential[:80],",
            "                bytes.fromhex(",
            "                    \"badcc0de00000001004400206f0c4b08cfa00f21b474ca75623d098309c2cd7fac8d10\"",
            "                    \"ae3caf0da40162496db140cc6a5ae79a2bd7c22dc52cee372f34b356bf9bcd5176fa94\"",
            "                    \"239ee93191a0a75d0100\"",
            "                ),",
            "            )",
            "",
            "    @staticmethod",
            "    def create_fixed_ec_key(curve: EllipticCurve) -> EllipticCurvePrivateKey:",
            "        assert isinstance(curve, SECP256R1)",
            "        priv = int(\"75548318724506252006992803713632448754009807765151974952668642988315053146586\")",
            "        x = int(\"24475970435455602523615976476876273915861210750530480136577912291006924068625\")",
            "        y = int(\"54663881618849781513153369976321537514677018641256406838874390754930401176808\")",
            "        pub = EllipticCurvePublicNumbers(x, y, curve)",
            "        priv_numbers = EllipticCurvePrivateNumbers(priv, pub)",
            "        return priv_numbers.private_key()",
            "",
            "    def test_makecredential_ecc(self) -> None:",
            "        with mock.patch(",
            "            \"cryptography.hazmat.primitives.asymmetric.ec.generate_private_key\", TestTpmUtil.create_fixed_ec_key",
            "        ):",
            "            ek_tpm = bytes.fromhex(",
            "                \"007a0023000b000300b20020837197674484b3f81a90cc8d46a5d724fd52d76e06520b64f2a1\"",
            "                \"da1b331469aa0006008000430010000300100020d31f0e190c36691abdc5c8cef7201139664f\"",
            "                \"93bcc45e68861a62d649d9a157d400209bf3cc57da9b2c09539cae40f0518e651b65befaab84\"",
            "                \"f26a3285d88be134b0cf\"",
            "            )",
            "            challenge = bytes.fromhex(\"7756666e6e4574706552556d717932656e7954474c64434f576a523545654a69\")",
            "            aik_name = bytes.fromhex(\"000b9f7f75b0564ea96bd70ef98baafbf6bf779641d17576bd11b5c6979273d2ba21\")",
            "",
            "            credential = makecredential(ek_tpm, challenge, aik_name)",
            "",
            "            # the signature is not 'constant' due to OAEP padding",
            "            self.assertEqual(",
            "                credential,",
            "                bytes.fromhex(",
            "                    \"badcc0de00000001004400207d7934f023133b07f7d9bce3062451ea4da5f1917c95e1\"",
            "                    \"42da1c3277e658f66bbea694a7c1b30d006a09b28dc534876d59b644b9223c5f3c3432\"",
            "                    \"d8bae35f3ea3fba600440020361ce888d5152797aaca04838003976967c0c0a0a0e969\"",
            "                    \"8b7b5e6e5294e21711002078daa91b35fb5efc70052a470064a96dd556bd53a784d737\"",
            "                    \"e40966edc5f36ce8\"",
            "                ),",
            "            )"
        ],
        "afterPatchFile": [
            "import base64",
            "import unittest",
            "from unittest import mock",
            "",
            "from cryptography.exceptions import InvalidSignature",
            "from cryptography.hazmat.primitives.asymmetric.ec import (",
            "    SECP256R1,",
            "    EllipticCurve,",
            "    EllipticCurvePrivateKey,",
            "    EllipticCurvePrivateNumbers,",
            "    EllipticCurvePublicNumbers,",
            ")",
            "",
            "from keylime.tpm.tpm_util import checkquote, makecredential",
            "",
            "",
            "class TestTpmUtil(unittest.TestCase):",
            "    def test_checkquote(self) -> None:",
            "        aikblob = bytes(",
            "            \"-----BEGIN PUBLIC KEY-----\\n\"",
            "            \"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAw3owm7uitOaspMCDlhEv\\n\"",
            "            \"bxNgGsxa1MpbHytT/Y9K0sdpTxgay571B8zvLOUbJHEJ0gt4NHY0+/NCzIAzT6kB\\n\"",
            "            \"n7aL67BV8QiyKBcywlVGS9PqYGoB9uxozDap/O9Bc5WrQUCso4m4TxrW1QOOBkNX\\n\"",
            "            \"x5OnresvsRv5O3m6BYZeUk2pJOyiBXM0HEkEC/Q/hxsfF1KfJG3JYOhpdF0E//dy\\n\"",
            "            \"LHOtdW9FP8Dt3YZuchJmyhFDjMKuxF2Zt7YVk9Pg4ZvmJ64CmOtshUj9k+Ctj44Z\\n\"",
            "            \"gMS/cIVmMrk7cdUBEBtq8x3g0cARZ5cUb4KB+dO0v/fvZkb4Qt5zwym1eUzmvVfD\\n\"",
            "            \"6QIDAQAB\\n\"",
            "            \"-----END PUBLIC KEY-----\",",
            "            \"utf-8\",",
            "        )",
            "        sigblob = base64.b64decode(",
            "            \"ABQACwEAgkUGLLuWpJETl3E5G2mvoVqbgVxzwAluOtyUwkoZEC2j4DeqOrl/q7jLaAC2KxDcoJbk\"",
            "            \"QPqu2sgwV84lfZOqRNhCydiwxbBTPIXImoDsCnkpkYwrk9NJcM+18qm/+f5V2/8QBQQmbN+6EV3I\"",
            "            \"gpSOYor2XcVntHCIrcloh/qN2gjihXDSjtHH9aSwOH7Z69gzyTt/4yVul7QRAOQCjqnasaSEGvoA\"",
            "            \"vtIin0aJLfD9wo1wlRzRDU62t3oHKLY49tMA3hQYF15+If/NsTKCTmUKmiKLBTk3yWAE64ThCxpB\"",
            "            \"EED6peiJlSxhdkyRm632IWAt8ahuyrfi/iEDVfyV+LnTBw==\"",
            "        )",
            "        quoteblob = base64.b64decode(",
            "            \"/1RDR4AYACIACzi1x2WoenP+buZXpt2LdpW0GTj5lBE6PXQmPZ0upQM0ABRBaTVNNVNqWWpua3l2\"",
            "            \"NFA3aXRIMQAAAABMlE7mAAAAAwAAAAABIBkQIwAWNjYAAAABAAsDAAABACBtTTdJEy9iVxchZM1f\"",
            "            \"8xNfRHlz1KXITgGJAfZ1NwW3AQ==\"",
            "        )",
            "        pcrblob = base64.b64decode(",
            "            \"AQAAAAsAAwAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "            \"AAAAAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAAgANRxwGdJUfDvB1rs3UL776bspgGYIK3QvSItHE5i\"",
            "            \"Qs5vAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "            \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\"",
            "        )",
            "        nonce = \"Ai5M5SjYjnkyv4P7itH1\"",
            "",
            "        try:",
            "            checkquote(aikblob, nonce, sigblob, quoteblob, pcrblob, \"sha256\")",
            "        except Exception as e:",
            "            self.fail(f\"checkquote failed with {e}\")",
            "",
            "        # test bad input",
            "        bad_quoteblob = bytearray(quoteblob)",
            "        bad_quoteblob[5] ^= 0x1",
            "        with self.assertRaises(InvalidSignature):",
            "            checkquote(aikblob, nonce, sigblob, bad_quoteblob, pcrblob, \"sha256\")",
            "",
            "        l = list(nonce)",
            "        l[0] = \"a\"",
            "        bad_nonce = \"\".join(l)",
            "        with self.assertRaises(Exception):",
            "            checkquote(aikblob, bad_nonce, sigblob, quoteblob, pcrblob, \"sha256\")",
            "",
            "        bad_pcrblob = bytearray(pcrblob)",
            "        bad_pcrblob[5] ^= 0x1",
            "        with self.assertRaises(Exception):",
            "            checkquote(aikblob, nonce, sigblob, quoteblob, bad_pcrblob, \"sha256\")",
            "",
            "        with self.assertRaises(ValueError):",
            "            checkquote(aikblob, nonce, sigblob, quoteblob, pcrblob, \"sha1\")",
            "",
            "    @staticmethod",
            "    def not_random(numbytes: int) -> bytes:",
            "        return b\"\\x12\" * numbytes",
            "",
            "    def test_makecredential(self) -> None:",
            "        with mock.patch(\"os.urandom\", TestTpmUtil.not_random):",
            "            ek_tpm = bytes.fromhex(",
            "                \"013a0001000b000300b20020837197674484b3f81a90cc8d46a5d724fd52d76e06520b64f2a1\"",
            "                \"da1b331469aa00060080004300100800000000000100aef12278a9b8d8a1e5700fb835ff3d9b\"",
            "                \"613d0d6fc17df186711260244f3f24847eb3ef1f5ff9b53d01cfebf291104385fbd71ead80a8\"",
            "                \"294ebc76f671859b7c3c9a998300f30859ef3fdba00c5229f17092fd97f19128243000205cfe\"",
            "                \"5ba24f5fc55538e52bf849c6f777690919929c7d2d9328070a2a6bdd67355a516b94afdceda0\"",
            "                \"0a0d27988a28644b30ac11beae23a51d9038cd9d789ae39cae15c1312ef174e217449771a602\"",
            "                \"ade4daf35b20e072017c85a2f211fe5512319184059ddeaab94fa331c49c3f213bc3fbccd1e8\"",
            "                \"56b8984353ac92e3df0f72f1e5c0b97b9cdc333702872e9e63565c809d81fa8bb6c6da86867c\"",
            "                \"ead2adedc0cee80bb6617183\"",
            "            )",
            "            challenge = bytes.fromhex(\"5a4e524b4f4e6e777552754831683734785a466a42416f314758676c484d4149\")",
            "            aik_name = bytes.fromhex(\"000b9601163463aacdb45be7ad1f6d11ad3dae0578d5aeeb5125e1075c5601b7c7fa\")",
            "",
            "            credential = makecredential(ek_tpm, challenge, aik_name)",
            "",
            "            # the signature is not 'constant' due to OAEP padding",
            "            self.assertEqual(",
            "                credential[:80],",
            "                bytes.fromhex(",
            "                    \"badcc0de00000001004400206f0c4b08cfa00f21b474ca75623d098309c2cd7fac8d10\"",
            "                    \"ae3caf0da40162496db140cc6a5ae79a2bd7c22dc52cee372f34b356bf9bcd5176fa94\"",
            "                    \"239ee93191a0a75d0100\"",
            "                ),",
            "            )",
            "",
            "    @staticmethod",
            "    def create_fixed_ec_key(curve: EllipticCurve) -> EllipticCurvePrivateKey:",
            "        assert isinstance(curve, SECP256R1)",
            "        priv = int(\"75548318724506252006992803713632448754009807765151974952668642988315053146586\")",
            "        x = int(\"24475970435455602523615976476876273915861210750530480136577912291006924068625\")",
            "        y = int(\"54663881618849781513153369976321537514677018641256406838874390754930401176808\")",
            "        pub = EllipticCurvePublicNumbers(x, y, curve)",
            "        priv_numbers = EllipticCurvePrivateNumbers(priv, pub)",
            "        return priv_numbers.private_key()",
            "",
            "    def test_makecredential_ecc(self) -> None:",
            "        with mock.patch(",
            "            \"cryptography.hazmat.primitives.asymmetric.ec.generate_private_key\", TestTpmUtil.create_fixed_ec_key",
            "        ):",
            "            ek_tpm = bytes.fromhex(",
            "                \"007a0023000b000300b20020837197674484b3f81a90cc8d46a5d724fd52d76e06520b64f2a1\"",
            "                \"da1b331469aa0006008000430010000300100020d31f0e190c36691abdc5c8cef7201139664f\"",
            "                \"93bcc45e68861a62d649d9a157d400209bf3cc57da9b2c09539cae40f0518e651b65befaab84\"",
            "                \"f26a3285d88be134b0cf\"",
            "            )",
            "            challenge = bytes.fromhex(\"7756666e6e4574706552556d717932656e7954474c64434f576a523545654a69\")",
            "            aik_name = bytes.fromhex(\"000b9f7f75b0564ea96bd70ef98baafbf6bf779641d17576bd11b5c6979273d2ba21\")",
            "",
            "            credential = makecredential(ek_tpm, challenge, aik_name)",
            "",
            "            # the signature is not 'constant' due to OAEP padding",
            "            self.assertEqual(",
            "                credential,",
            "                bytes.fromhex(",
            "                    \"badcc0de00000001004400207d7934f023133b07f7d9bce3062451ea4da5f1917c95e1\"",
            "                    \"42da1c3277e658f66bbea694a7c1b30d006a09b28dc534876d59b644b9223c5f3c3432\"",
            "                    \"d8bae35f3ea3fba600440020361ce888d5152797aaca04838003976967c0c0a0a0e969\"",
            "                    \"8b7b5e6e5294e21711002078daa91b35fb5efc70052a470064a96dd556bd53a784d737\"",
            "                    \"e40966edc5f36ce8\"",
            "                ),",
            "            )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "keylime.tpm.tpm_util_test.TestTpmUtil.self",
            "lib.ansible.plugins.action.ActionBase._execute_module"
        ]
    }
}