{
    "litestar/app.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "         path: str | None = None,"
            },
            "1": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "         plugins: Sequence[PluginProtocol] | None = None,"
            },
            "2": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "         request_class: type[Request] | None = None,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+        request_max_body_size: int | None = 10_000_000,"
            },
            "4": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": 206,
                "PatchRowcode": "         response_cache_config: ResponseCacheConfig | None = None,"
            },
            "5": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 207,
                "PatchRowcode": "         response_class: type[Response] | None = None,"
            },
            "6": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 208,
                "PatchRowcode": "         response_cookies: ResponseCookies | None = None,"
            },
            "7": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 287,
                "PatchRowcode": "             pdb_on_exception: Drop into the PDB when an exception occurs."
            },
            "8": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 288,
                "PatchRowcode": "             plugins: Sequence of plugins."
            },
            "9": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": 289,
                "PatchRowcode": "             request_class: An optional subclass of :class:`Request <.connection.Request>` to use for http connections."
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 290,
                "PatchRowcode": "+            request_max_body_size: Maximum allowed size of the request body in bytes. If this size is exceeded, a"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 291,
                "PatchRowcode": "+                '413 - Request Entity Too Large' error response is returned."
            },
            "12": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 292,
                "PatchRowcode": "             response_class: A custom subclass of :class:`Response <.response.Response>` to be used as the app's default"
            },
            "13": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 293,
                "PatchRowcode": "                 response."
            },
            "14": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 294,
                "PatchRowcode": "             response_cookies: A sequence of :class:`Cookie <.datastructures.Cookie>`."
            },
            "15": {
                "beforePatchRowNumber": 361,
                "afterPatchRowNumber": 364,
                "PatchRowcode": "             pdb_on_exception=pdb_on_exception,"
            },
            "16": {
                "beforePatchRowNumber": 362,
                "afterPatchRowNumber": 365,
                "PatchRowcode": "             plugins=self._get_default_plugins(list(plugins or [])),"
            },
            "17": {
                "beforePatchRowNumber": 363,
                "afterPatchRowNumber": 366,
                "PatchRowcode": "             request_class=request_class,"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 367,
                "PatchRowcode": "+            request_max_body_size=request_max_body_size,"
            },
            "19": {
                "beforePatchRowNumber": 364,
                "afterPatchRowNumber": 368,
                "PatchRowcode": "             response_cache_config=response_cache_config or ResponseCacheConfig(),"
            },
            "20": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": 369,
                "PatchRowcode": "             response_class=response_class,"
            },
            "21": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": 370,
                "PatchRowcode": "             response_cookies=response_cookies or [],"
            },
            "22": {
                "beforePatchRowNumber": 464,
                "afterPatchRowNumber": 468,
                "PatchRowcode": "             parameters=config.parameters,"
            },
            "23": {
                "beforePatchRowNumber": 465,
                "afterPatchRowNumber": 469,
                "PatchRowcode": "             path=config.path,"
            },
            "24": {
                "beforePatchRowNumber": 466,
                "afterPatchRowNumber": 470,
                "PatchRowcode": "             request_class=self.request_class,"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 471,
                "PatchRowcode": "+            request_max_body_size=request_max_body_size,"
            },
            "26": {
                "beforePatchRowNumber": 467,
                "afterPatchRowNumber": 472,
                "PatchRowcode": "             response_class=config.response_class,"
            },
            "27": {
                "beforePatchRowNumber": 468,
                "afterPatchRowNumber": 473,
                "PatchRowcode": "             response_cookies=config.response_cookies,"
            },
            "28": {
                "beforePatchRowNumber": 469,
                "afterPatchRowNumber": 474,
                "PatchRowcode": "             response_headers=config.response_headers,"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import inspect",
            "import logging",
            "import os",
            "import warnings",
            "from contextlib import (",
            "    AbstractAsyncContextManager,",
            "    AsyncExitStack,",
            "    asynccontextmanager,",
            "    suppress,",
            ")",
            "from datetime import date, datetime, time, timedelta",
            "from functools import partial",
            "from itertools import chain",
            "from pathlib import Path",
            "from typing import TYPE_CHECKING, Any, AsyncGenerator, Callable, Iterable, Mapping, Sequence, TypedDict, cast",
            "",
            "from litestar._asgi import ASGIRouter",
            "from litestar._asgi.utils import get_route_handlers, wrap_in_exception_handler",
            "from litestar._openapi.plugin import OpenAPIPlugin",
            "from litestar._openapi.schema_generation import openapi_schema_plugins",
            "from litestar.config.allowed_hosts import AllowedHostsConfig",
            "from litestar.config.app import AppConfig, ExperimentalFeatures",
            "from litestar.config.response_cache import ResponseCacheConfig",
            "from litestar.connection import Request, WebSocket",
            "from litestar.datastructures.state import State",
            "from litestar.events.emitter import BaseEventEmitterBackend, SimpleEventEmitter",
            "from litestar.exceptions import (",
            "    LitestarWarning,",
            "    MissingDependencyException,",
            "    NoRouteMatchFoundException,",
            ")",
            "from litestar.logging.config import LoggingConfig, get_logger_placeholder",
            "from litestar.middleware._internal.cors import CORSMiddleware",
            "from litestar.openapi.config import OpenAPIConfig",
            "from litestar.plugins import (",
            "    CLIPluginProtocol,",
            "    InitPluginProtocol,",
            "    OpenAPISchemaPluginProtocol,",
            "    PluginProtocol,",
            "    PluginRegistry,",
            "    SerializationPluginProtocol,",
            ")",
            "from litestar.plugins.base import CLIPlugin",
            "from litestar.router import Router",
            "from litestar.routes import ASGIRoute, HTTPRoute, WebSocketRoute",
            "from litestar.static_files.base import StaticFiles",
            "from litestar.stores.registry import StoreRegistry",
            "from litestar.types import Empty, TypeDecodersSequence",
            "from litestar.types.internal_types import PathParameterDefinition, TemplateConfigType",
            "from litestar.utils import deprecated, ensure_async_callable, join_paths, unique",
            "from litestar.utils.dataclass import extract_dataclass_items",
            "from litestar.utils.predicates import is_async_callable",
            "from litestar.utils.warnings import warn_pdb_on_exception",
            "",
            "if TYPE_CHECKING:",
            "    from typing_extensions import Self",
            "",
            "    from litestar.config.compression import CompressionConfig",
            "    from litestar.config.cors import CORSConfig",
            "    from litestar.config.csrf import CSRFConfig",
            "    from litestar.contrib.opentelemetry import OpenTelemetryPlugin",
            "    from litestar.datastructures import CacheControlHeader, ETag",
            "    from litestar.dto import AbstractDTO",
            "    from litestar.events.listener import EventListener",
            "    from litestar.logging.config import BaseLoggingConfig",
            "    from litestar.openapi.spec import SecurityRequirement",
            "    from litestar.openapi.spec.open_api import OpenAPI",
            "    from litestar.response import Response",
            "    from litestar.static_files.config import StaticFilesConfig",
            "    from litestar.stores.base import Store",
            "    from litestar.types import (",
            "        AfterExceptionHookHandler,",
            "        AfterRequestHookHandler,",
            "        AfterResponseHookHandler,",
            "        AnyCallable,",
            "        ASGIApp,",
            "        BeforeMessageSendHookHandler,",
            "        BeforeRequestHookHandler,",
            "        ControllerRouterHandler,",
            "        Dependencies,",
            "        EmptyType,",
            "        ExceptionHandlersMap,",
            "        GetLogger,",
            "        Guard,",
            "        LifeSpanReceive,",
            "        LifeSpanScope,",
            "        LifeSpanSend,",
            "        Logger,",
            "        Message,",
            "        Middleware,",
            "        OnAppInitHandler,",
            "        ParametersMap,",
            "        Receive,",
            "        ResponseCookies,",
            "        ResponseHeaders,",
            "        RouteHandlerType,",
            "        Scope,",
            "        Send,",
            "        TypeEncodersMap,",
            "    )",
            "    from litestar.types.callable_types import LifespanHook",
            "",
            "",
            "__all__ = (\"HandlerIndex\", \"Litestar\", \"DEFAULT_OPENAPI_CONFIG\")",
            "",
            "DEFAULT_OPENAPI_CONFIG = OpenAPIConfig(title=\"Litestar API\", version=\"1.0.0\")",
            "\"\"\"The default OpenAPI config used if not configuration is explicitly passed to the",
            ":class:`Litestar <.app.Litestar>` instance constructor.",
            "\"\"\"",
            "",
            "",
            "class HandlerIndex(TypedDict):",
            "    \"\"\"Map route handler names to a mapping of paths + route handler.",
            "",
            "    It's returned from the 'get_handler_index_by_name' utility method.",
            "    \"\"\"",
            "",
            "    paths: list[str]",
            "    \"\"\"Full route paths to the route handler.\"\"\"",
            "    handler: RouteHandlerType",
            "    \"\"\"Route handler instance.\"\"\"",
            "    identifier: str",
            "    \"\"\"Unique identifier of the handler.",
            "",
            "    Either equal to :attr`__name__ <obj.__name__>` attribute or ``__str__`` value of the handler.",
            "    \"\"\"",
            "",
            "",
            "class Litestar(Router):",
            "    \"\"\"The Litestar application.",
            "",
            "    ``Litestar`` is the root level of the app - it has the base path of ``/`` and all root level Controllers, Routers",
            "    and Route Handlers should be registered on it.",
            "    \"\"\"",
            "",
            "    __slots__ = (",
            "        \"_lifespan_managers\",",
            "        \"_server_lifespan_managers\",",
            "        \"_debug\",",
            "        \"_openapi_schema\",",
            "        \"_static_files_config\",",
            "        \"plugins\",",
            "        \"after_exception\",",
            "        \"allowed_hosts\",",
            "        \"asgi_handler\",",
            "        \"asgi_router\",",
            "        \"before_send\",",
            "        \"compression_config\",",
            "        \"cors_config\",",
            "        \"csrf_config\",",
            "        \"event_emitter\",",
            "        \"get_logger\",",
            "        \"logger\",",
            "        \"logging_config\",",
            "        \"multipart_form_part_limit\",",
            "        \"on_shutdown\",",
            "        \"on_startup\",",
            "        \"openapi_config\",",
            "        \"response_cache_config\",",
            "        \"route_map\",",
            "        \"state\",",
            "        \"stores\",",
            "        \"template_engine\",",
            "        \"pdb_on_exception\",",
            "        \"experimental_features\",",
            "    )",
            "",
            "    def __init__(",
            "        self,",
            "        route_handlers: Sequence[ControllerRouterHandler] | None = None,",
            "        *,",
            "        after_exception: Sequence[AfterExceptionHookHandler] | None = None,",
            "        after_request: AfterRequestHookHandler | None = None,",
            "        after_response: AfterResponseHookHandler | None = None,",
            "        allowed_hosts: Sequence[str] | AllowedHostsConfig | None = None,",
            "        before_request: BeforeRequestHookHandler | None = None,",
            "        before_send: Sequence[BeforeMessageSendHookHandler] | None = None,",
            "        cache_control: CacheControlHeader | None = None,",
            "        compression_config: CompressionConfig | None = None,",
            "        cors_config: CORSConfig | None = None,",
            "        csrf_config: CSRFConfig | None = None,",
            "        dto: type[AbstractDTO] | None | EmptyType = Empty,",
            "        debug: bool | None = None,",
            "        dependencies: Dependencies | None = None,",
            "        etag: ETag | None = None,",
            "        event_emitter_backend: type[BaseEventEmitterBackend] = SimpleEventEmitter,",
            "        exception_handlers: ExceptionHandlersMap | None = None,",
            "        guards: Sequence[Guard] | None = None,",
            "        include_in_schema: bool | EmptyType = Empty,",
            "        listeners: Sequence[EventListener] | None = None,",
            "        logging_config: BaseLoggingConfig | EmptyType | None = Empty,",
            "        middleware: Sequence[Middleware] | None = None,",
            "        multipart_form_part_limit: int = 1000,",
            "        on_app_init: Sequence[OnAppInitHandler] | None = None,",
            "        on_shutdown: Sequence[LifespanHook] | None = None,",
            "        on_startup: Sequence[LifespanHook] | None = None,",
            "        openapi_config: OpenAPIConfig | None = DEFAULT_OPENAPI_CONFIG,",
            "        opt: Mapping[str, Any] | None = None,",
            "        parameters: ParametersMap | None = None,",
            "        path: str | None = None,",
            "        plugins: Sequence[PluginProtocol] | None = None,",
            "        request_class: type[Request] | None = None,",
            "        response_cache_config: ResponseCacheConfig | None = None,",
            "        response_class: type[Response] | None = None,",
            "        response_cookies: ResponseCookies | None = None,",
            "        response_headers: ResponseHeaders | None = None,",
            "        return_dto: type[AbstractDTO] | None | EmptyType = Empty,",
            "        security: Sequence[SecurityRequirement] | None = None,",
            "        signature_namespace: Mapping[str, Any] | None = None,",
            "        signature_types: Sequence[Any] | None = None,",
            "        state: State | None = None,",
            "        static_files_config: Sequence[StaticFilesConfig] | None = None,",
            "        stores: StoreRegistry | dict[str, Store] | None = None,",
            "        tags: Sequence[str] | None = None,",
            "        template_config: TemplateConfigType | None = None,",
            "        type_decoders: TypeDecodersSequence | None = None,",
            "        type_encoders: TypeEncodersMap | None = None,",
            "        websocket_class: type[WebSocket] | None = None,",
            "        lifespan: Sequence[Callable[[Litestar], AbstractAsyncContextManager] | AbstractAsyncContextManager]",
            "        | None = None,",
            "        pdb_on_exception: bool | None = None,",
            "        experimental_features: Iterable[ExperimentalFeatures] | None = None,",
            "    ) -> None:",
            "        \"\"\"Initialize a ``Litestar`` application.",
            "",
            "        Args:",
            "            after_exception: A sequence of :class:`exception hook handlers <.types.AfterExceptionHookHandler>`. This",
            "                hook is called after an exception occurs. In difference to exception handlers, it is not meant to",
            "                return a response - only to process the exception (e.g. log it, send it to Sentry etc.).",
            "            after_request: A sync or async function executed after the route handler function returned and the response",
            "                object has been resolved. Receives the response object.",
            "            after_response: A sync or async function called after the response has been awaited. It receives the",
            "                :class:`Request <.connection.Request>` object and should not return any values.",
            "            allowed_hosts: A sequence of allowed hosts, or an",
            "                :class:`AllowedHostsConfig <.config.allowed_hosts.AllowedHostsConfig>` instance. Enables the builtin",
            "                allowed hosts middleware.",
            "            before_request: A sync or async function called immediately before calling the route handler. Receives the",
            "                :class:`Request <.connection.Request>` instance and any non-``None`` return value is used for the",
            "                response, bypassing the route handler.",
            "            before_send: A sequence of :class:`before send hook handlers <.types.BeforeMessageSendHookHandler>`. Called",
            "                when the ASGI send function is called.",
            "            cache_control: A ``cache-control`` header of type",
            "                :class:`CacheControlHeader <litestar.datastructures.CacheControlHeader>` to add to route handlers of",
            "                this app. Can be overridden by route handlers.",
            "            compression_config: Configures compression behaviour of the application, this enabled a builtin or user",
            "                defined Compression middleware.",
            "            cors_config: If set, configures CORS handling for the application.",
            "            csrf_config: If set, configures :class:`CSRFMiddleware <.middleware.csrf.CSRFMiddleware>`.",
            "            debug: If ``True``, app errors rendered as HTML with a stack trace.",
            "            dependencies: A string keyed mapping of dependency :class:`Providers <.di.Provide>`.",
            "            dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for (de)serializing and",
            "                validation of request data.",
            "            etag: An ``etag`` header of type :class:`ETag <.datastructures.ETag>` to add to route handlers of this app.",
            "                Can be overridden by route handlers.",
            "            event_emitter_backend: A subclass of",
            "                :class:`BaseEventEmitterBackend <.events.emitter.BaseEventEmitterBackend>`.",
            "            exception_handlers: A mapping of status codes and/or exception types to handler functions.",
            "            guards: A sequence of :class:`Guard <.types.Guard>` callables.",
            "            include_in_schema: A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.",
            "            lifespan: A list of callables returning async context managers, wrapping the lifespan of the ASGI application",
            "            listeners: A sequence of :class:`EventListener <.events.listener.EventListener>`.",
            "            logging_config: A subclass of :class:`BaseLoggingConfig <.logging.config.BaseLoggingConfig>`.",
            "            middleware: A sequence of :class:`Middleware <.types.Middleware>`.",
            "            multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request. This limit",
            "                is intended to protect from DoS attacks.",
            "            on_app_init: A sequence of :class:`OnAppInitHandler <.types.OnAppInitHandler>` instances. Handlers receive",
            "                an instance of :class:`AppConfig <.config.app.AppConfig>` that will have been initially populated with",
            "                the parameters passed to :class:`Litestar <litestar.app.Litestar>`, and must return an instance of same.",
            "                If more than one handler is registered they are called in the order they are provided.",
            "            on_shutdown: A sequence of :class:`LifespanHook <.types.LifespanHook>` called during application",
            "                shutdown.",
            "            on_startup: A sequence of :class:`LifespanHook <litestar.types.LifespanHook>` called during",
            "                application startup.",
            "            openapi_config: Defaults to :attr:`DEFAULT_OPENAPI_CONFIG`",
            "            opt: A string keyed mapping of arbitrary values that can be accessed in :class:`Guards <.types.Guard>` or",
            "                wherever you have access to :class:`Request <litestar.connection.request.Request>` or",
            "                :class:`ASGI Scope <.types.Scope>`.",
            "            parameters: A mapping of :class:`Parameter <.params.Parameter>` definitions available to all application",
            "                paths.",
            "            path: A path fragment that is prefixed to all route handlers, controllers and routers associated",
            "                with the application instance.",
            "",
            "                .. versionadded:: 2.8.0",
            "            pdb_on_exception: Drop into the PDB when an exception occurs.",
            "            plugins: Sequence of plugins.",
            "            request_class: An optional subclass of :class:`Request <.connection.Request>` to use for http connections.",
            "            response_class: A custom subclass of :class:`Response <.response.Response>` to be used as the app's default",
            "                response.",
            "            response_cookies: A sequence of :class:`Cookie <.datastructures.Cookie>`.",
            "            response_headers: A string keyed mapping of :class:`ResponseHeader <.datastructures.ResponseHeader>`",
            "            response_cache_config: Configures caching behavior of the application.",
            "            return_dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for serializing",
            "                outbound response data.",
            "            route_handlers: A sequence of route handlers, which can include instances of",
            "                :class:`Router <.router.Router>`, subclasses of :class:`Controller <.controller.Controller>` or any",
            "                callable decorated by the route handler decorators.",
            "            security: A sequence of dicts that will be added to the schema of all route handlers in the application.",
            "                See",
            "                :data:`SecurityRequirement <.openapi.spec.SecurityRequirement>` for details.",
            "            signature_namespace: A mapping of names to types for use in forward reference resolution during signature modeling.",
            "            signature_types: A sequence of types for use in forward reference resolution during signature modeling.",
            "                These types will be added to the signature namespace using their ``__name__`` attribute.",
            "            state: An optional :class:`State <.datastructures.State>` for application state.",
            "            static_files_config: A sequence of :class:`StaticFilesConfig <.static_files.StaticFilesConfig>`",
            "            stores: Central registry of :class:`Store <.stores.base.Store>` that will be available throughout the",
            "                application. If this is a dictionary to it will be passed to a",
            "                :class:`StoreRegistry <.stores.registry.StoreRegistry>`. If it is a",
            "                :class:`StoreRegistry <.stores.registry.StoreRegistry>`, this instance will be used directly.",
            "            tags: A sequence of string tags that will be appended to the schema of all route handlers under the",
            "                application.",
            "            template_config: An instance of :class:`TemplateConfig <.template.TemplateConfig>`",
            "            type_decoders: A sequence of tuples, each composed of a predicate testing for type identity and a msgspec",
            "                hook for deserialization.",
            "            type_encoders: A mapping of types to callables that transform them into types supported for serialization.",
            "            websocket_class: An optional subclass of :class:`WebSocket <.connection.WebSocket>` to use for websocket",
            "                connections.",
            "            experimental_features: An iterable of experimental features to enable",
            "        \"\"\"",
            "",
            "        if logging_config is Empty:",
            "            logging_config = LoggingConfig()",
            "",
            "        if debug is None:",
            "            debug = os.getenv(\"LITESTAR_DEBUG\", \"0\") == \"1\"",
            "",
            "        if pdb_on_exception is None:",
            "            pdb_on_exception = os.getenv(\"LITESTAR_PDB\", \"0\") == \"1\"",
            "",
            "        config = AppConfig(",
            "            after_exception=list(after_exception or []),",
            "            after_request=after_request,",
            "            after_response=after_response,",
            "            allowed_hosts=allowed_hosts if isinstance(allowed_hosts, AllowedHostsConfig) else list(allowed_hosts or []),",
            "            before_request=before_request,",
            "            before_send=list(before_send or []),",
            "            cache_control=cache_control,",
            "            compression_config=compression_config,",
            "            cors_config=cors_config,",
            "            csrf_config=csrf_config,",
            "            debug=debug,",
            "            dependencies=dict(dependencies or {}),",
            "            dto=dto,",
            "            etag=etag,",
            "            event_emitter_backend=event_emitter_backend,",
            "            exception_handlers=exception_handlers or {},",
            "            guards=list(guards or []),",
            "            include_in_schema=include_in_schema,",
            "            lifespan=list(lifespan or []),",
            "            listeners=list(listeners or []),",
            "            logging_config=logging_config,",
            "            middleware=list(middleware or []),",
            "            multipart_form_part_limit=multipart_form_part_limit,",
            "            on_shutdown=list(on_shutdown or []),",
            "            on_startup=list(on_startup or []),",
            "            openapi_config=openapi_config,",
            "            opt=dict(opt or {}),",
            "            path=path or \"\",",
            "            parameters=parameters or {},",
            "            pdb_on_exception=pdb_on_exception,",
            "            plugins=self._get_default_plugins(list(plugins or [])),",
            "            request_class=request_class,",
            "            response_cache_config=response_cache_config or ResponseCacheConfig(),",
            "            response_class=response_class,",
            "            response_cookies=response_cookies or [],",
            "            response_headers=response_headers or [],",
            "            return_dto=return_dto,",
            "            route_handlers=list(route_handlers) if route_handlers is not None else [],",
            "            security=list(security or []),",
            "            signature_namespace=dict(signature_namespace or {}),",
            "            signature_types=list(signature_types or []),",
            "            state=state or State(),",
            "            static_files_config=list(static_files_config or []),",
            "            stores=stores,",
            "            tags=list(tags or []),",
            "            template_config=template_config,",
            "            type_encoders=type_encoders,",
            "            type_decoders=type_decoders,",
            "            websocket_class=websocket_class,",
            "            experimental_features=list(experimental_features or []),",
            "        )",
            "",
            "        config.plugins.extend([OpenAPIPlugin(self), *openapi_schema_plugins])",
            "",
            "        for handler in chain(",
            "            on_app_init or [],",
            "            (p.on_app_init for p in config.plugins if isinstance(p, InitPluginProtocol)),",
            "            [self._patch_opentelemetry_middleware],",
            "        ):",
            "            config = handler(config)  # pyright: ignore",
            "",
            "        self.plugins = PluginRegistry(config.plugins)",
            "",
            "        self._openapi_schema: OpenAPI | None = None",
            "        self._debug: bool = True",
            "        self.stores: StoreRegistry = (",
            "            config.stores if isinstance(config.stores, StoreRegistry) else StoreRegistry(config.stores)",
            "        )",
            "        self._lifespan_managers = config.lifespan",
            "        for store in self.stores._stores.values():",
            "            self._lifespan_managers.append(store)",
            "        self._server_lifespan_managers = [p.server_lifespan for p in config.plugins or [] if isinstance(p, CLIPlugin)]",
            "        self.experimental_features = frozenset(config.experimental_features or [])",
            "        if ExperimentalFeatures.DTO_CODEGEN in self.experimental_features:",
            "            warnings.warn(",
            "                \"Use of redundant experimental feature flag DTO_CODEGEN. \"",
            "                \"DTO codegen backend is enabled by default since Litestar 2.8. The \"",
            "                \"DTO_CODEGEN feature flag can be safely removed from the configuration \"",
            "                \"and will be removed in version 3.0.\",",
            "                category=LitestarWarning,",
            "                stacklevel=2,",
            "            )",
            "",
            "        self.get_logger: GetLogger = get_logger_placeholder",
            "        self.logger: Logger | None = None",
            "        self.routes: list[HTTPRoute | ASGIRoute | WebSocketRoute] = []",
            "",
            "        self.after_exception = [ensure_async_callable(h) for h in config.after_exception]",
            "        self.allowed_hosts = cast(\"AllowedHostsConfig | None\", config.allowed_hosts)",
            "        self.before_send = [ensure_async_callable(h) for h in config.before_send]",
            "        self.compression_config = config.compression_config",
            "        self.cors_config = config.cors_config",
            "        self.csrf_config = config.csrf_config",
            "        self.event_emitter = config.event_emitter_backend(listeners=config.listeners)",
            "        self.logging_config = config.logging_config",
            "        self.multipart_form_part_limit = config.multipart_form_part_limit",
            "        self.on_shutdown = config.on_shutdown",
            "        self.on_startup = config.on_startup",
            "        self.openapi_config = config.openapi_config",
            "        self.request_class: type[Request] = config.request_class or Request",
            "        self.response_cache_config = config.response_cache_config",
            "        self.state = config.state",
            "        self._static_files_config = config.static_files_config",
            "        self.template_engine = config.template_config.engine_instance if config.template_config else None",
            "        self.websocket_class: type[WebSocket] = config.websocket_class or WebSocket",
            "        self.debug = config.debug",
            "        self.pdb_on_exception: bool = config.pdb_on_exception",
            "        self.include_in_schema = include_in_schema",
            "",
            "        if self.pdb_on_exception:",
            "            warn_pdb_on_exception()",
            "",
            "        try:",
            "            from starlette.exceptions import HTTPException as StarletteHTTPException",
            "",
            "            from litestar.middleware._internal.exceptions.middleware import _starlette_exception_handler",
            "",
            "            config.exception_handlers.setdefault(StarletteHTTPException, _starlette_exception_handler)",
            "        except ImportError:",
            "            pass",
            "        super().__init__(",
            "            after_request=config.after_request,",
            "            after_response=config.after_response,",
            "            before_request=config.before_request,",
            "            cache_control=config.cache_control,",
            "            dependencies=config.dependencies,",
            "            dto=config.dto,",
            "            etag=config.etag,",
            "            exception_handlers=config.exception_handlers,",
            "            guards=config.guards,",
            "            middleware=config.middleware,",
            "            opt=config.opt,",
            "            parameters=config.parameters,",
            "            path=config.path,",
            "            request_class=self.request_class,",
            "            response_class=config.response_class,",
            "            response_cookies=config.response_cookies,",
            "            response_headers=config.response_headers,",
            "            return_dto=config.return_dto,",
            "            # route handlers are registered below",
            "            route_handlers=[],",
            "            security=config.security,",
            "            signature_namespace=config.signature_namespace,",
            "            signature_types=config.signature_types,",
            "            tags=config.tags,",
            "            type_encoders=config.type_encoders,",
            "            type_decoders=config.type_decoders,",
            "            include_in_schema=config.include_in_schema,",
            "            websocket_class=self.websocket_class,",
            "        )",
            "",
            "        self.asgi_router = ASGIRouter(app=self)",
            "",
            "        for route_handler in config.route_handlers:",
            "            self.register(route_handler)",
            "",
            "        if self.logging_config:",
            "            self.get_logger = self.logging_config.configure()",
            "            self.logger = self.get_logger(\"litestar\")",
            "",
            "        for static_config in self._static_files_config:",
            "            self.register(static_config.to_static_files_app())",
            "",
            "        self.asgi_handler = self._create_asgi_handler()",
            "",
            "    @staticmethod",
            "    def _patch_opentelemetry_middleware(config: AppConfig) -> AppConfig:",
            "        # workaround to support otel middleware priority. Should be replaced by regular",
            "        # middleware priorities once available",
            "        try:",
            "            from litestar.contrib.opentelemetry import OpenTelemetryPlugin",
            "",
            "            if not any(isinstance(p, OpenTelemetryPlugin) for p in config.plugins):",
            "                config.middleware, otel_middleware = OpenTelemetryPlugin._pop_otel_middleware(config.middleware)",
            "                if otel_middleware:",
            "                    otel_plugin = OpenTelemetryPlugin()",
            "                    otel_plugin._middleware = otel_middleware",
            "                    config.plugins = [*config.plugins, otel_plugin]",
            "        except ImportError:",
            "            pass",
            "        return config",
            "",
            "    @property",
            "    @deprecated(version=\"2.6.0\", kind=\"property\", info=\"Use create_static_files router instead\")",
            "    def static_files_config(self) -> list[StaticFilesConfig]:",
            "        return self._static_files_config",
            "",
            "    @property",
            "    @deprecated(version=\"2.0\", alternative=\"Litestar.plugins.cli\", kind=\"property\")",
            "    def cli_plugins(self) -> list[CLIPluginProtocol]:",
            "        return list(self.plugins.cli)",
            "",
            "    @property",
            "    @deprecated(version=\"2.0\", alternative=\"Litestar.plugins.openapi\", kind=\"property\")",
            "    def openapi_schema_plugins(self) -> list[OpenAPISchemaPluginProtocol]:",
            "        return list(self.plugins.openapi)",
            "",
            "    @property",
            "    @deprecated(version=\"2.0\", alternative=\"Litestar.plugins.serialization\", kind=\"property\")",
            "    def serialization_plugins(self) -> list[SerializationPluginProtocol]:",
            "        return list(self.plugins.serialization)",
            "",
            "    @staticmethod",
            "    def _get_default_plugins(plugins: list[PluginProtocol]) -> list[PluginProtocol]:",
            "        from litestar.plugins.core import MsgspecDIPlugin",
            "",
            "        plugins.append(MsgspecDIPlugin())",
            "",
            "        with suppress(MissingDependencyException):",
            "            from litestar.plugins.pydantic import (",
            "                PydanticDIPlugin,",
            "                PydanticInitPlugin,",
            "                PydanticPlugin,",
            "                PydanticSchemaPlugin,",
            "            )",
            "",
            "            pydantic_plugin_found = any(isinstance(plugin, PydanticPlugin) for plugin in plugins)",
            "            pydantic_init_plugin_found = any(isinstance(plugin, PydanticInitPlugin) for plugin in plugins)",
            "            pydantic_schema_plugin_found = any(isinstance(plugin, PydanticSchemaPlugin) for plugin in plugins)",
            "            pydantic_serialization_plugin_found = any(isinstance(plugin, PydanticDIPlugin) for plugin in plugins)",
            "            if not pydantic_plugin_found and not pydantic_init_plugin_found and not pydantic_schema_plugin_found:",
            "                plugins.append(PydanticPlugin())",
            "            elif not pydantic_plugin_found and pydantic_init_plugin_found and not pydantic_schema_plugin_found:",
            "                plugins.append(PydanticSchemaPlugin())",
            "            elif not pydantic_plugin_found and not pydantic_init_plugin_found:",
            "                plugins.append(PydanticInitPlugin())",
            "            if not pydantic_plugin_found and not pydantic_serialization_plugin_found:",
            "                plugins.append(PydanticDIPlugin())",
            "        with suppress(MissingDependencyException):",
            "            from litestar.contrib.attrs import AttrsSchemaPlugin",
            "",
            "            pre_configured = any(isinstance(plugin, AttrsSchemaPlugin) for plugin in plugins)",
            "            if not pre_configured:",
            "                plugins.append(AttrsSchemaPlugin())",
            "        return plugins",
            "",
            "    @property",
            "    def debug(self) -> bool:",
            "        return self._debug",
            "",
            "    @debug.setter",
            "    def debug(self, value: bool) -> None:",
            "        \"\"\"Sets the debug logging level for the application.",
            "",
            "        When possible, it calls the `self.logging_config.set_level` method.  This allows for implementation specific code and APIs to be called.",
            "        \"\"\"",
            "        if self.logger and self.logging_config:",
            "            self.logging_config.set_level(self.logger, logging.DEBUG if value else logging.INFO)",
            "        elif self.logger and hasattr(self.logger, \"setLevel\"):  # pragma: no cover",
            "            self.logger.setLevel(logging.DEBUG if value else logging.INFO)  # pragma: no cover",
            "        if isinstance(self.logging_config, LoggingConfig):",
            "            self.logging_config.loggers[\"litestar\"][\"level\"] = \"DEBUG\" if value else \"INFO\"",
            "        self._debug = value",
            "",
            "    async def __call__(",
            "        self,",
            "        scope: Scope | LifeSpanScope,",
            "        receive: Receive | LifeSpanReceive,",
            "        send: Send | LifeSpanSend,",
            "    ) -> None:",
            "        \"\"\"Application entry point.",
            "",
            "        Lifespan events (startup / shutdown) are sent to the lifespan handler, otherwise the ASGI handler is used",
            "",
            "        Args:",
            "            scope: The ASGI connection scope.",
            "            receive: The ASGI receive function.",
            "            send: The ASGI send function.",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        if scope[\"type\"] == \"lifespan\":",
            "            await self.asgi_router.lifespan(receive=receive, send=send)  # type: ignore[arg-type]",
            "            return",
            "",
            "        scope[\"app\"] = self",
            "        scope.setdefault(\"state\", {})",
            "        await self.asgi_handler(scope, receive, self._wrap_send(send=send, scope=scope))  # type: ignore[arg-type]",
            "",
            "    async def _call_lifespan_hook(self, hook: LifespanHook) -> None:",
            "        ret = hook(self) if inspect.signature(hook).parameters else hook()  # type: ignore[call-arg]",
            "",
            "        if is_async_callable(hook):  # pyright: ignore[reportGeneralTypeIssues]",
            "            await ret",
            "",
            "    @asynccontextmanager",
            "    async def lifespan(self) -> AsyncGenerator[None, None]:",
            "        \"\"\"Context manager handling the ASGI lifespan.",
            "",
            "        It will be entered when the ``lifespan`` message has been received from the",
            "        server, and exit after the ``asgi.shutdown`` message. During this period, it is",
            "        responsible for calling the ``on_startup``, ``on_shutdown`` hooks, as well as",
            "        custom lifespan managers.",
            "        \"\"\"",
            "        async with AsyncExitStack() as exit_stack:",
            "            for hook in self.on_shutdown[::-1]:",
            "                exit_stack.push_async_callback(partial(self._call_lifespan_hook, hook))",
            "",
            "            await exit_stack.enter_async_context(self.event_emitter)",
            "",
            "            for manager in self._lifespan_managers:",
            "                if not isinstance(manager, AbstractAsyncContextManager):",
            "                    manager = manager(self)",
            "                await exit_stack.enter_async_context(manager)",
            "",
            "            for hook in self.on_startup:",
            "                await self._call_lifespan_hook(hook)",
            "",
            "            yield",
            "",
            "    @property",
            "    def openapi_schema(self) -> OpenAPI:",
            "        \"\"\"Access  the OpenAPI schema of the application.",
            "",
            "        Returns:",
            "            The :class:`OpenAPI`",
            "            <pydantic_openapi_schema.open_api.OpenAPI> instance of the",
            "            application.",
            "",
            "        Raises:",
            "            ImproperlyConfiguredException: If the application ``openapi_config`` attribute is ``None``.",
            "        \"\"\"",
            "        return self.plugins.get(OpenAPIPlugin).provide_openapi()",
            "",
            "    @classmethod",
            "    def from_config(cls, config: AppConfig) -> Self:",
            "        \"\"\"Initialize a ``Litestar`` application from a configuration instance.",
            "",
            "        Args:",
            "            config: An instance of :class:`AppConfig` <.config.AppConfig>",
            "",
            "        Returns:",
            "            An instance of ``Litestar`` application.",
            "        \"\"\"",
            "        return cls(**dict(extract_dataclass_items(config)))",
            "",
            "    def register(self, value: ControllerRouterHandler) -> None:  # type: ignore[override]",
            "        \"\"\"Register a route handler on the app.",
            "",
            "        This method can be used to dynamically add endpoints to an application.",
            "",
            "        Args:",
            "            value: An instance of :class:`Router <.router.Router>`, a subclass of",
            "                :class:`Controller <.controller.Controller>` or any function decorated by the route handler decorators.",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        routes = super().register(value=value)",
            "",
            "        for route in routes:",
            "            route_handlers = get_route_handlers(route)",
            "",
            "            for route_handler in route_handlers:",
            "                route_handler.on_registration(self)",
            "",
            "            if isinstance(route, HTTPRoute):",
            "                route.create_handler_map()",
            "",
            "            elif isinstance(route, WebSocketRoute):",
            "                handler = route.route_handler",
            "                route.handler_parameter_model = handler.create_kwargs_model(path_parameters=route.path_parameters)",
            "",
            "            for plugin in self.plugins.receive_route:",
            "                plugin.receive_route(route)",
            "",
            "        self.asgi_router.construct_routing_trie()",
            "",
            "    def get_handler_index_by_name(self, name: str) -> HandlerIndex | None:",
            "        \"\"\"Receives a route handler name and returns an optional dictionary containing the route handler instance and",
            "        list of paths sorted lexically.",
            "",
            "        Examples:",
            "            .. code-block:: python",
            "",
            "                from litestar import Litestar, get",
            "",
            "",
            "                @get(\"/\", name=\"my-handler\")",
            "                def handler() -> None:",
            "                    pass",
            "",
            "",
            "                app = Litestar(route_handlers=[handler])",
            "",
            "                handler_index = app.get_handler_index_by_name(\"my-handler\")",
            "",
            "                # { \"paths\": [\"/\"], \"handler\" ... }",
            "",
            "        Args:",
            "            name: A route handler unique name.",
            "",
            "        Returns:",
            "            A :class:`HandlerIndex <.app.HandlerIndex>` instance or ``None``.",
            "        \"\"\"",
            "        handler = self.asgi_router.route_handler_index.get(name)",
            "        if not handler:",
            "            return None",
            "",
            "        identifier = handler.name or str(handler)",
            "        routes = self.asgi_router.route_mapping[identifier]",
            "        paths = sorted(unique([route.path for route in routes]))",
            "",
            "        return HandlerIndex(handler=handler, paths=paths, identifier=identifier)",
            "",
            "    def route_reverse(self, name: str, **path_parameters: Any) -> str:",
            "        \"\"\"Receives a route handler name, path parameter values and returns url path to the handler with filled path",
            "        parameters.",
            "",
            "        Examples:",
            "            .. code-block:: python",
            "",
            "                from litestar import Litestar, get",
            "",
            "",
            "                @get(\"/group/{group_id:int}/user/{user_id:int}\", name=\"get_membership_details\")",
            "                def get_membership_details(group_id: int, user_id: int) -> None:",
            "                    pass",
            "",
            "",
            "                app = Litestar(route_handlers=[get_membership_details])",
            "",
            "                path = app.route_reverse(\"get_membership_details\", user_id=100, group_id=10)",
            "",
            "                # /group/10/user/100",
            "",
            "        Args:",
            "            name: A route handler unique name.",
            "            **path_parameters: Actual values for path parameters in the route.",
            "",
            "        Raises:",
            "            NoRouteMatchFoundException: If route with 'name' does not exist, path parameters are missing in",
            "                ``**path_parameters or have wrong type``.",
            "",
            "        Returns:",
            "            A fully formatted url path.",
            "        \"\"\"",
            "        handler_index = self.get_handler_index_by_name(name)",
            "        if handler_index is None:",
            "            raise NoRouteMatchFoundException(f\"Route {name} can not be found\")",
            "",
            "        allow_str_instead = {datetime, date, time, timedelta, float, Path}",
            "        routes = sorted(",
            "            self.asgi_router.route_mapping[handler_index[\"identifier\"]],",
            "            key=lambda r: len(r.path_parameters),",
            "            reverse=True,",
            "        )",
            "        passed_parameters = set(path_parameters.keys())",
            "",
            "        selected_route = next(",
            "            (route for route in routes if passed_parameters.issuperset(route.path_parameters)),",
            "            routes[-1],",
            "        )",
            "        output: list[str] = []",
            "        for component in selected_route.path_components:",
            "            if isinstance(component, PathParameterDefinition):",
            "                val = path_parameters.get(component.name)",
            "                if not isinstance(val, component.type) and (",
            "                    component.type not in allow_str_instead or not isinstance(val, str)",
            "                ):",
            "                    raise NoRouteMatchFoundException(",
            "                        f\"Received type for path parameter {component.name} doesn't match declared type {component.type}\"",
            "                    )",
            "                output.append(str(val))",
            "            else:",
            "                output.append(component)",
            "",
            "        return join_paths(output)",
            "",
            "    @deprecated(",
            "        \"2.6.0\", info=\"Use create_static_files router instead of StaticFilesConfig, which works with route_reverse\"",
            "    )",
            "    def url_for_static_asset(self, name: str, file_path: str) -> str:",
            "        \"\"\"Receives a static files handler name, an asset file path and returns resolved url path to the asset.",
            "",
            "        Examples:",
            "            .. code-block:: python",
            "",
            "                from litestar import Litestar",
            "                from litestar.static_files.config import StaticFilesConfig",
            "",
            "                app = Litestar(",
            "                    static_files_config=[",
            "                        StaticFilesConfig(directories=[\"css\"], path=\"/static/css\", name=\"css\")",
            "                    ]",
            "                )",
            "",
            "                path = app.url_for_static_asset(\"css\", \"main.css\")",
            "",
            "                # /static/css/main.css",
            "",
            "        Args:",
            "            name: A static handler unique name.",
            "            file_path: a string containing path to an asset.",
            "",
            "        Raises:",
            "            NoRouteMatchFoundException: If static files handler with ``name`` does not exist.",
            "",
            "        Returns:",
            "            A url path to the asset.",
            "        \"\"\"",
            "",
            "        handler_index = self.get_handler_index_by_name(name)",
            "        if handler_index is None:",
            "            raise NoRouteMatchFoundException(f\"Static handler {name} can not be found\")",
            "",
            "        handler_fn = cast(\"AnyCallable\", handler_index[\"handler\"].fn)",
            "        if not isinstance(handler_fn, StaticFiles):",
            "            raise NoRouteMatchFoundException(f\"Handler with name {name} is not a static files handler\")",
            "",
            "        return join_paths([handler_index[\"paths\"][0], file_path])",
            "",
            "    @property",
            "    def route_handler_method_view(self) -> dict[str, list[str]]:",
            "        \"\"\"Map route handlers to paths.",
            "",
            "        Returns:",
            "            A dictionary of router handlers and lists of paths as strings",
            "        \"\"\"",
            "        route_map: dict[str, list[str]] = {",
            "            handler: [route.path for route in routes] for handler, routes in self.asgi_router.route_mapping.items()",
            "        }",
            "        return route_map",
            "",
            "    def _create_asgi_handler(self) -> ASGIApp:",
            "        \"\"\"Create an ASGIApp that wraps the ASGI router inside an exception handler.",
            "",
            "        If CORS or TrustedHost configs are provided to the constructor, they will wrap the router as well.",
            "        \"\"\"",
            "        asgi_handler = wrap_in_exception_handler(app=self.asgi_router)",
            "",
            "        if self.cors_config:",
            "            asgi_handler = CORSMiddleware(app=asgi_handler, config=self.cors_config)",
            "",
            "        try:",
            "            otel_plugin: OpenTelemetryPlugin = self.plugins.get(\"OpenTelemetryPlugin\")",
            "            asgi_handler = otel_plugin.middleware(app=asgi_handler)",
            "        except KeyError:",
            "            pass",
            "",
            "        return asgi_handler",
            "",
            "    def _wrap_send(self, send: Send, scope: Scope) -> Send:",
            "        \"\"\"Wrap the ASGI send and handles any 'before send' hooks.",
            "",
            "        Args:",
            "            send: The ASGI send function.",
            "            scope: The ASGI scope.",
            "",
            "        Returns:",
            "            An ASGI send function.",
            "        \"\"\"",
            "        if self.before_send:",
            "",
            "            async def wrapped_send(message: Message) -> None:",
            "                for hook in self.before_send:",
            "                    await hook(message, scope)",
            "                await send(message)",
            "",
            "            return wrapped_send",
            "        return send",
            "",
            "    def update_openapi_schema(self) -> None:",
            "        \"\"\"Update the OpenAPI schema to reflect the route handlers registered on the app.",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        self.plugins.get(OpenAPIPlugin)._build_openapi()",
            "",
            "    def emit(self, event_id: str, *args: Any, **kwargs: Any) -> None:",
            "        \"\"\"Emit an event to all attached listeners.",
            "",
            "        Args:",
            "            event_id: The ID of the event to emit, e.g ``my_event``.",
            "            args: args to pass to the listener(s).",
            "            kwargs: kwargs to pass to the listener(s)",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        self.event_emitter.emit(event_id, *args, **kwargs)"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import inspect",
            "import logging",
            "import os",
            "import warnings",
            "from contextlib import (",
            "    AbstractAsyncContextManager,",
            "    AsyncExitStack,",
            "    asynccontextmanager,",
            "    suppress,",
            ")",
            "from datetime import date, datetime, time, timedelta",
            "from functools import partial",
            "from itertools import chain",
            "from pathlib import Path",
            "from typing import TYPE_CHECKING, Any, AsyncGenerator, Callable, Iterable, Mapping, Sequence, TypedDict, cast",
            "",
            "from litestar._asgi import ASGIRouter",
            "from litestar._asgi.utils import get_route_handlers, wrap_in_exception_handler",
            "from litestar._openapi.plugin import OpenAPIPlugin",
            "from litestar._openapi.schema_generation import openapi_schema_plugins",
            "from litestar.config.allowed_hosts import AllowedHostsConfig",
            "from litestar.config.app import AppConfig, ExperimentalFeatures",
            "from litestar.config.response_cache import ResponseCacheConfig",
            "from litestar.connection import Request, WebSocket",
            "from litestar.datastructures.state import State",
            "from litestar.events.emitter import BaseEventEmitterBackend, SimpleEventEmitter",
            "from litestar.exceptions import (",
            "    LitestarWarning,",
            "    MissingDependencyException,",
            "    NoRouteMatchFoundException,",
            ")",
            "from litestar.logging.config import LoggingConfig, get_logger_placeholder",
            "from litestar.middleware._internal.cors import CORSMiddleware",
            "from litestar.openapi.config import OpenAPIConfig",
            "from litestar.plugins import (",
            "    CLIPluginProtocol,",
            "    InitPluginProtocol,",
            "    OpenAPISchemaPluginProtocol,",
            "    PluginProtocol,",
            "    PluginRegistry,",
            "    SerializationPluginProtocol,",
            ")",
            "from litestar.plugins.base import CLIPlugin",
            "from litestar.router import Router",
            "from litestar.routes import ASGIRoute, HTTPRoute, WebSocketRoute",
            "from litestar.static_files.base import StaticFiles",
            "from litestar.stores.registry import StoreRegistry",
            "from litestar.types import Empty, TypeDecodersSequence",
            "from litestar.types.internal_types import PathParameterDefinition, TemplateConfigType",
            "from litestar.utils import deprecated, ensure_async_callable, join_paths, unique",
            "from litestar.utils.dataclass import extract_dataclass_items",
            "from litestar.utils.predicates import is_async_callable",
            "from litestar.utils.warnings import warn_pdb_on_exception",
            "",
            "if TYPE_CHECKING:",
            "    from typing_extensions import Self",
            "",
            "    from litestar.config.compression import CompressionConfig",
            "    from litestar.config.cors import CORSConfig",
            "    from litestar.config.csrf import CSRFConfig",
            "    from litestar.contrib.opentelemetry import OpenTelemetryPlugin",
            "    from litestar.datastructures import CacheControlHeader, ETag",
            "    from litestar.dto import AbstractDTO",
            "    from litestar.events.listener import EventListener",
            "    from litestar.logging.config import BaseLoggingConfig",
            "    from litestar.openapi.spec import SecurityRequirement",
            "    from litestar.openapi.spec.open_api import OpenAPI",
            "    from litestar.response import Response",
            "    from litestar.static_files.config import StaticFilesConfig",
            "    from litestar.stores.base import Store",
            "    from litestar.types import (",
            "        AfterExceptionHookHandler,",
            "        AfterRequestHookHandler,",
            "        AfterResponseHookHandler,",
            "        AnyCallable,",
            "        ASGIApp,",
            "        BeforeMessageSendHookHandler,",
            "        BeforeRequestHookHandler,",
            "        ControllerRouterHandler,",
            "        Dependencies,",
            "        EmptyType,",
            "        ExceptionHandlersMap,",
            "        GetLogger,",
            "        Guard,",
            "        LifeSpanReceive,",
            "        LifeSpanScope,",
            "        LifeSpanSend,",
            "        Logger,",
            "        Message,",
            "        Middleware,",
            "        OnAppInitHandler,",
            "        ParametersMap,",
            "        Receive,",
            "        ResponseCookies,",
            "        ResponseHeaders,",
            "        RouteHandlerType,",
            "        Scope,",
            "        Send,",
            "        TypeEncodersMap,",
            "    )",
            "    from litestar.types.callable_types import LifespanHook",
            "",
            "",
            "__all__ = (\"HandlerIndex\", \"Litestar\", \"DEFAULT_OPENAPI_CONFIG\")",
            "",
            "DEFAULT_OPENAPI_CONFIG = OpenAPIConfig(title=\"Litestar API\", version=\"1.0.0\")",
            "\"\"\"The default OpenAPI config used if not configuration is explicitly passed to the",
            ":class:`Litestar <.app.Litestar>` instance constructor.",
            "\"\"\"",
            "",
            "",
            "class HandlerIndex(TypedDict):",
            "    \"\"\"Map route handler names to a mapping of paths + route handler.",
            "",
            "    It's returned from the 'get_handler_index_by_name' utility method.",
            "    \"\"\"",
            "",
            "    paths: list[str]",
            "    \"\"\"Full route paths to the route handler.\"\"\"",
            "    handler: RouteHandlerType",
            "    \"\"\"Route handler instance.\"\"\"",
            "    identifier: str",
            "    \"\"\"Unique identifier of the handler.",
            "",
            "    Either equal to :attr`__name__ <obj.__name__>` attribute or ``__str__`` value of the handler.",
            "    \"\"\"",
            "",
            "",
            "class Litestar(Router):",
            "    \"\"\"The Litestar application.",
            "",
            "    ``Litestar`` is the root level of the app - it has the base path of ``/`` and all root level Controllers, Routers",
            "    and Route Handlers should be registered on it.",
            "    \"\"\"",
            "",
            "    __slots__ = (",
            "        \"_lifespan_managers\",",
            "        \"_server_lifespan_managers\",",
            "        \"_debug\",",
            "        \"_openapi_schema\",",
            "        \"_static_files_config\",",
            "        \"plugins\",",
            "        \"after_exception\",",
            "        \"allowed_hosts\",",
            "        \"asgi_handler\",",
            "        \"asgi_router\",",
            "        \"before_send\",",
            "        \"compression_config\",",
            "        \"cors_config\",",
            "        \"csrf_config\",",
            "        \"event_emitter\",",
            "        \"get_logger\",",
            "        \"logger\",",
            "        \"logging_config\",",
            "        \"multipart_form_part_limit\",",
            "        \"on_shutdown\",",
            "        \"on_startup\",",
            "        \"openapi_config\",",
            "        \"response_cache_config\",",
            "        \"route_map\",",
            "        \"state\",",
            "        \"stores\",",
            "        \"template_engine\",",
            "        \"pdb_on_exception\",",
            "        \"experimental_features\",",
            "    )",
            "",
            "    def __init__(",
            "        self,",
            "        route_handlers: Sequence[ControllerRouterHandler] | None = None,",
            "        *,",
            "        after_exception: Sequence[AfterExceptionHookHandler] | None = None,",
            "        after_request: AfterRequestHookHandler | None = None,",
            "        after_response: AfterResponseHookHandler | None = None,",
            "        allowed_hosts: Sequence[str] | AllowedHostsConfig | None = None,",
            "        before_request: BeforeRequestHookHandler | None = None,",
            "        before_send: Sequence[BeforeMessageSendHookHandler] | None = None,",
            "        cache_control: CacheControlHeader | None = None,",
            "        compression_config: CompressionConfig | None = None,",
            "        cors_config: CORSConfig | None = None,",
            "        csrf_config: CSRFConfig | None = None,",
            "        dto: type[AbstractDTO] | None | EmptyType = Empty,",
            "        debug: bool | None = None,",
            "        dependencies: Dependencies | None = None,",
            "        etag: ETag | None = None,",
            "        event_emitter_backend: type[BaseEventEmitterBackend] = SimpleEventEmitter,",
            "        exception_handlers: ExceptionHandlersMap | None = None,",
            "        guards: Sequence[Guard] | None = None,",
            "        include_in_schema: bool | EmptyType = Empty,",
            "        listeners: Sequence[EventListener] | None = None,",
            "        logging_config: BaseLoggingConfig | EmptyType | None = Empty,",
            "        middleware: Sequence[Middleware] | None = None,",
            "        multipart_form_part_limit: int = 1000,",
            "        on_app_init: Sequence[OnAppInitHandler] | None = None,",
            "        on_shutdown: Sequence[LifespanHook] | None = None,",
            "        on_startup: Sequence[LifespanHook] | None = None,",
            "        openapi_config: OpenAPIConfig | None = DEFAULT_OPENAPI_CONFIG,",
            "        opt: Mapping[str, Any] | None = None,",
            "        parameters: ParametersMap | None = None,",
            "        path: str | None = None,",
            "        plugins: Sequence[PluginProtocol] | None = None,",
            "        request_class: type[Request] | None = None,",
            "        request_max_body_size: int | None = 10_000_000,",
            "        response_cache_config: ResponseCacheConfig | None = None,",
            "        response_class: type[Response] | None = None,",
            "        response_cookies: ResponseCookies | None = None,",
            "        response_headers: ResponseHeaders | None = None,",
            "        return_dto: type[AbstractDTO] | None | EmptyType = Empty,",
            "        security: Sequence[SecurityRequirement] | None = None,",
            "        signature_namespace: Mapping[str, Any] | None = None,",
            "        signature_types: Sequence[Any] | None = None,",
            "        state: State | None = None,",
            "        static_files_config: Sequence[StaticFilesConfig] | None = None,",
            "        stores: StoreRegistry | dict[str, Store] | None = None,",
            "        tags: Sequence[str] | None = None,",
            "        template_config: TemplateConfigType | None = None,",
            "        type_decoders: TypeDecodersSequence | None = None,",
            "        type_encoders: TypeEncodersMap | None = None,",
            "        websocket_class: type[WebSocket] | None = None,",
            "        lifespan: Sequence[Callable[[Litestar], AbstractAsyncContextManager] | AbstractAsyncContextManager]",
            "        | None = None,",
            "        pdb_on_exception: bool | None = None,",
            "        experimental_features: Iterable[ExperimentalFeatures] | None = None,",
            "    ) -> None:",
            "        \"\"\"Initialize a ``Litestar`` application.",
            "",
            "        Args:",
            "            after_exception: A sequence of :class:`exception hook handlers <.types.AfterExceptionHookHandler>`. This",
            "                hook is called after an exception occurs. In difference to exception handlers, it is not meant to",
            "                return a response - only to process the exception (e.g. log it, send it to Sentry etc.).",
            "            after_request: A sync or async function executed after the route handler function returned and the response",
            "                object has been resolved. Receives the response object.",
            "            after_response: A sync or async function called after the response has been awaited. It receives the",
            "                :class:`Request <.connection.Request>` object and should not return any values.",
            "            allowed_hosts: A sequence of allowed hosts, or an",
            "                :class:`AllowedHostsConfig <.config.allowed_hosts.AllowedHostsConfig>` instance. Enables the builtin",
            "                allowed hosts middleware.",
            "            before_request: A sync or async function called immediately before calling the route handler. Receives the",
            "                :class:`Request <.connection.Request>` instance and any non-``None`` return value is used for the",
            "                response, bypassing the route handler.",
            "            before_send: A sequence of :class:`before send hook handlers <.types.BeforeMessageSendHookHandler>`. Called",
            "                when the ASGI send function is called.",
            "            cache_control: A ``cache-control`` header of type",
            "                :class:`CacheControlHeader <litestar.datastructures.CacheControlHeader>` to add to route handlers of",
            "                this app. Can be overridden by route handlers.",
            "            compression_config: Configures compression behaviour of the application, this enabled a builtin or user",
            "                defined Compression middleware.",
            "            cors_config: If set, configures CORS handling for the application.",
            "            csrf_config: If set, configures :class:`CSRFMiddleware <.middleware.csrf.CSRFMiddleware>`.",
            "            debug: If ``True``, app errors rendered as HTML with a stack trace.",
            "            dependencies: A string keyed mapping of dependency :class:`Providers <.di.Provide>`.",
            "            dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for (de)serializing and",
            "                validation of request data.",
            "            etag: An ``etag`` header of type :class:`ETag <.datastructures.ETag>` to add to route handlers of this app.",
            "                Can be overridden by route handlers.",
            "            event_emitter_backend: A subclass of",
            "                :class:`BaseEventEmitterBackend <.events.emitter.BaseEventEmitterBackend>`.",
            "            exception_handlers: A mapping of status codes and/or exception types to handler functions.",
            "            guards: A sequence of :class:`Guard <.types.Guard>` callables.",
            "            include_in_schema: A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.",
            "            lifespan: A list of callables returning async context managers, wrapping the lifespan of the ASGI application",
            "            listeners: A sequence of :class:`EventListener <.events.listener.EventListener>`.",
            "            logging_config: A subclass of :class:`BaseLoggingConfig <.logging.config.BaseLoggingConfig>`.",
            "            middleware: A sequence of :class:`Middleware <.types.Middleware>`.",
            "            multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request. This limit",
            "                is intended to protect from DoS attacks.",
            "            on_app_init: A sequence of :class:`OnAppInitHandler <.types.OnAppInitHandler>` instances. Handlers receive",
            "                an instance of :class:`AppConfig <.config.app.AppConfig>` that will have been initially populated with",
            "                the parameters passed to :class:`Litestar <litestar.app.Litestar>`, and must return an instance of same.",
            "                If more than one handler is registered they are called in the order they are provided.",
            "            on_shutdown: A sequence of :class:`LifespanHook <.types.LifespanHook>` called during application",
            "                shutdown.",
            "            on_startup: A sequence of :class:`LifespanHook <litestar.types.LifespanHook>` called during",
            "                application startup.",
            "            openapi_config: Defaults to :attr:`DEFAULT_OPENAPI_CONFIG`",
            "            opt: A string keyed mapping of arbitrary values that can be accessed in :class:`Guards <.types.Guard>` or",
            "                wherever you have access to :class:`Request <litestar.connection.request.Request>` or",
            "                :class:`ASGI Scope <.types.Scope>`.",
            "            parameters: A mapping of :class:`Parameter <.params.Parameter>` definitions available to all application",
            "                paths.",
            "            path: A path fragment that is prefixed to all route handlers, controllers and routers associated",
            "                with the application instance.",
            "",
            "                .. versionadded:: 2.8.0",
            "            pdb_on_exception: Drop into the PDB when an exception occurs.",
            "            plugins: Sequence of plugins.",
            "            request_class: An optional subclass of :class:`Request <.connection.Request>` to use for http connections.",
            "            request_max_body_size: Maximum allowed size of the request body in bytes. If this size is exceeded, a",
            "                '413 - Request Entity Too Large' error response is returned.",
            "            response_class: A custom subclass of :class:`Response <.response.Response>` to be used as the app's default",
            "                response.",
            "            response_cookies: A sequence of :class:`Cookie <.datastructures.Cookie>`.",
            "            response_headers: A string keyed mapping of :class:`ResponseHeader <.datastructures.ResponseHeader>`",
            "            response_cache_config: Configures caching behavior of the application.",
            "            return_dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for serializing",
            "                outbound response data.",
            "            route_handlers: A sequence of route handlers, which can include instances of",
            "                :class:`Router <.router.Router>`, subclasses of :class:`Controller <.controller.Controller>` or any",
            "                callable decorated by the route handler decorators.",
            "            security: A sequence of dicts that will be added to the schema of all route handlers in the application.",
            "                See",
            "                :data:`SecurityRequirement <.openapi.spec.SecurityRequirement>` for details.",
            "            signature_namespace: A mapping of names to types for use in forward reference resolution during signature modeling.",
            "            signature_types: A sequence of types for use in forward reference resolution during signature modeling.",
            "                These types will be added to the signature namespace using their ``__name__`` attribute.",
            "            state: An optional :class:`State <.datastructures.State>` for application state.",
            "            static_files_config: A sequence of :class:`StaticFilesConfig <.static_files.StaticFilesConfig>`",
            "            stores: Central registry of :class:`Store <.stores.base.Store>` that will be available throughout the",
            "                application. If this is a dictionary to it will be passed to a",
            "                :class:`StoreRegistry <.stores.registry.StoreRegistry>`. If it is a",
            "                :class:`StoreRegistry <.stores.registry.StoreRegistry>`, this instance will be used directly.",
            "            tags: A sequence of string tags that will be appended to the schema of all route handlers under the",
            "                application.",
            "            template_config: An instance of :class:`TemplateConfig <.template.TemplateConfig>`",
            "            type_decoders: A sequence of tuples, each composed of a predicate testing for type identity and a msgspec",
            "                hook for deserialization.",
            "            type_encoders: A mapping of types to callables that transform them into types supported for serialization.",
            "            websocket_class: An optional subclass of :class:`WebSocket <.connection.WebSocket>` to use for websocket",
            "                connections.",
            "            experimental_features: An iterable of experimental features to enable",
            "        \"\"\"",
            "",
            "        if logging_config is Empty:",
            "            logging_config = LoggingConfig()",
            "",
            "        if debug is None:",
            "            debug = os.getenv(\"LITESTAR_DEBUG\", \"0\") == \"1\"",
            "",
            "        if pdb_on_exception is None:",
            "            pdb_on_exception = os.getenv(\"LITESTAR_PDB\", \"0\") == \"1\"",
            "",
            "        config = AppConfig(",
            "            after_exception=list(after_exception or []),",
            "            after_request=after_request,",
            "            after_response=after_response,",
            "            allowed_hosts=allowed_hosts if isinstance(allowed_hosts, AllowedHostsConfig) else list(allowed_hosts or []),",
            "            before_request=before_request,",
            "            before_send=list(before_send or []),",
            "            cache_control=cache_control,",
            "            compression_config=compression_config,",
            "            cors_config=cors_config,",
            "            csrf_config=csrf_config,",
            "            debug=debug,",
            "            dependencies=dict(dependencies or {}),",
            "            dto=dto,",
            "            etag=etag,",
            "            event_emitter_backend=event_emitter_backend,",
            "            exception_handlers=exception_handlers or {},",
            "            guards=list(guards or []),",
            "            include_in_schema=include_in_schema,",
            "            lifespan=list(lifespan or []),",
            "            listeners=list(listeners or []),",
            "            logging_config=logging_config,",
            "            middleware=list(middleware or []),",
            "            multipart_form_part_limit=multipart_form_part_limit,",
            "            on_shutdown=list(on_shutdown or []),",
            "            on_startup=list(on_startup or []),",
            "            openapi_config=openapi_config,",
            "            opt=dict(opt or {}),",
            "            path=path or \"\",",
            "            parameters=parameters or {},",
            "            pdb_on_exception=pdb_on_exception,",
            "            plugins=self._get_default_plugins(list(plugins or [])),",
            "            request_class=request_class,",
            "            request_max_body_size=request_max_body_size,",
            "            response_cache_config=response_cache_config or ResponseCacheConfig(),",
            "            response_class=response_class,",
            "            response_cookies=response_cookies or [],",
            "            response_headers=response_headers or [],",
            "            return_dto=return_dto,",
            "            route_handlers=list(route_handlers) if route_handlers is not None else [],",
            "            security=list(security or []),",
            "            signature_namespace=dict(signature_namespace or {}),",
            "            signature_types=list(signature_types or []),",
            "            state=state or State(),",
            "            static_files_config=list(static_files_config or []),",
            "            stores=stores,",
            "            tags=list(tags or []),",
            "            template_config=template_config,",
            "            type_encoders=type_encoders,",
            "            type_decoders=type_decoders,",
            "            websocket_class=websocket_class,",
            "            experimental_features=list(experimental_features or []),",
            "        )",
            "",
            "        config.plugins.extend([OpenAPIPlugin(self), *openapi_schema_plugins])",
            "",
            "        for handler in chain(",
            "            on_app_init or [],",
            "            (p.on_app_init for p in config.plugins if isinstance(p, InitPluginProtocol)),",
            "            [self._patch_opentelemetry_middleware],",
            "        ):",
            "            config = handler(config)  # pyright: ignore",
            "",
            "        self.plugins = PluginRegistry(config.plugins)",
            "",
            "        self._openapi_schema: OpenAPI | None = None",
            "        self._debug: bool = True",
            "        self.stores: StoreRegistry = (",
            "            config.stores if isinstance(config.stores, StoreRegistry) else StoreRegistry(config.stores)",
            "        )",
            "        self._lifespan_managers = config.lifespan",
            "        for store in self.stores._stores.values():",
            "            self._lifespan_managers.append(store)",
            "        self._server_lifespan_managers = [p.server_lifespan for p in config.plugins or [] if isinstance(p, CLIPlugin)]",
            "        self.experimental_features = frozenset(config.experimental_features or [])",
            "        if ExperimentalFeatures.DTO_CODEGEN in self.experimental_features:",
            "            warnings.warn(",
            "                \"Use of redundant experimental feature flag DTO_CODEGEN. \"",
            "                \"DTO codegen backend is enabled by default since Litestar 2.8. The \"",
            "                \"DTO_CODEGEN feature flag can be safely removed from the configuration \"",
            "                \"and will be removed in version 3.0.\",",
            "                category=LitestarWarning,",
            "                stacklevel=2,",
            "            )",
            "",
            "        self.get_logger: GetLogger = get_logger_placeholder",
            "        self.logger: Logger | None = None",
            "        self.routes: list[HTTPRoute | ASGIRoute | WebSocketRoute] = []",
            "",
            "        self.after_exception = [ensure_async_callable(h) for h in config.after_exception]",
            "        self.allowed_hosts = cast(\"AllowedHostsConfig | None\", config.allowed_hosts)",
            "        self.before_send = [ensure_async_callable(h) for h in config.before_send]",
            "        self.compression_config = config.compression_config",
            "        self.cors_config = config.cors_config",
            "        self.csrf_config = config.csrf_config",
            "        self.event_emitter = config.event_emitter_backend(listeners=config.listeners)",
            "        self.logging_config = config.logging_config",
            "        self.multipart_form_part_limit = config.multipart_form_part_limit",
            "        self.on_shutdown = config.on_shutdown",
            "        self.on_startup = config.on_startup",
            "        self.openapi_config = config.openapi_config",
            "        self.request_class: type[Request] = config.request_class or Request",
            "        self.response_cache_config = config.response_cache_config",
            "        self.state = config.state",
            "        self._static_files_config = config.static_files_config",
            "        self.template_engine = config.template_config.engine_instance if config.template_config else None",
            "        self.websocket_class: type[WebSocket] = config.websocket_class or WebSocket",
            "        self.debug = config.debug",
            "        self.pdb_on_exception: bool = config.pdb_on_exception",
            "        self.include_in_schema = include_in_schema",
            "",
            "        if self.pdb_on_exception:",
            "            warn_pdb_on_exception()",
            "",
            "        try:",
            "            from starlette.exceptions import HTTPException as StarletteHTTPException",
            "",
            "            from litestar.middleware._internal.exceptions.middleware import _starlette_exception_handler",
            "",
            "            config.exception_handlers.setdefault(StarletteHTTPException, _starlette_exception_handler)",
            "        except ImportError:",
            "            pass",
            "        super().__init__(",
            "            after_request=config.after_request,",
            "            after_response=config.after_response,",
            "            before_request=config.before_request,",
            "            cache_control=config.cache_control,",
            "            dependencies=config.dependencies,",
            "            dto=config.dto,",
            "            etag=config.etag,",
            "            exception_handlers=config.exception_handlers,",
            "            guards=config.guards,",
            "            middleware=config.middleware,",
            "            opt=config.opt,",
            "            parameters=config.parameters,",
            "            path=config.path,",
            "            request_class=self.request_class,",
            "            request_max_body_size=request_max_body_size,",
            "            response_class=config.response_class,",
            "            response_cookies=config.response_cookies,",
            "            response_headers=config.response_headers,",
            "            return_dto=config.return_dto,",
            "            # route handlers are registered below",
            "            route_handlers=[],",
            "            security=config.security,",
            "            signature_namespace=config.signature_namespace,",
            "            signature_types=config.signature_types,",
            "            tags=config.tags,",
            "            type_encoders=config.type_encoders,",
            "            type_decoders=config.type_decoders,",
            "            include_in_schema=config.include_in_schema,",
            "            websocket_class=self.websocket_class,",
            "        )",
            "",
            "        self.asgi_router = ASGIRouter(app=self)",
            "",
            "        for route_handler in config.route_handlers:",
            "            self.register(route_handler)",
            "",
            "        if self.logging_config:",
            "            self.get_logger = self.logging_config.configure()",
            "            self.logger = self.get_logger(\"litestar\")",
            "",
            "        for static_config in self._static_files_config:",
            "            self.register(static_config.to_static_files_app())",
            "",
            "        self.asgi_handler = self._create_asgi_handler()",
            "",
            "    @staticmethod",
            "    def _patch_opentelemetry_middleware(config: AppConfig) -> AppConfig:",
            "        # workaround to support otel middleware priority. Should be replaced by regular",
            "        # middleware priorities once available",
            "        try:",
            "            from litestar.contrib.opentelemetry import OpenTelemetryPlugin",
            "",
            "            if not any(isinstance(p, OpenTelemetryPlugin) for p in config.plugins):",
            "                config.middleware, otel_middleware = OpenTelemetryPlugin._pop_otel_middleware(config.middleware)",
            "                if otel_middleware:",
            "                    otel_plugin = OpenTelemetryPlugin()",
            "                    otel_plugin._middleware = otel_middleware",
            "                    config.plugins = [*config.plugins, otel_plugin]",
            "        except ImportError:",
            "            pass",
            "        return config",
            "",
            "    @property",
            "    @deprecated(version=\"2.6.0\", kind=\"property\", info=\"Use create_static_files router instead\")",
            "    def static_files_config(self) -> list[StaticFilesConfig]:",
            "        return self._static_files_config",
            "",
            "    @property",
            "    @deprecated(version=\"2.0\", alternative=\"Litestar.plugins.cli\", kind=\"property\")",
            "    def cli_plugins(self) -> list[CLIPluginProtocol]:",
            "        return list(self.plugins.cli)",
            "",
            "    @property",
            "    @deprecated(version=\"2.0\", alternative=\"Litestar.plugins.openapi\", kind=\"property\")",
            "    def openapi_schema_plugins(self) -> list[OpenAPISchemaPluginProtocol]:",
            "        return list(self.plugins.openapi)",
            "",
            "    @property",
            "    @deprecated(version=\"2.0\", alternative=\"Litestar.plugins.serialization\", kind=\"property\")",
            "    def serialization_plugins(self) -> list[SerializationPluginProtocol]:",
            "        return list(self.plugins.serialization)",
            "",
            "    @staticmethod",
            "    def _get_default_plugins(plugins: list[PluginProtocol]) -> list[PluginProtocol]:",
            "        from litestar.plugins.core import MsgspecDIPlugin",
            "",
            "        plugins.append(MsgspecDIPlugin())",
            "",
            "        with suppress(MissingDependencyException):",
            "            from litestar.plugins.pydantic import (",
            "                PydanticDIPlugin,",
            "                PydanticInitPlugin,",
            "                PydanticPlugin,",
            "                PydanticSchemaPlugin,",
            "            )",
            "",
            "            pydantic_plugin_found = any(isinstance(plugin, PydanticPlugin) for plugin in plugins)",
            "            pydantic_init_plugin_found = any(isinstance(plugin, PydanticInitPlugin) for plugin in plugins)",
            "            pydantic_schema_plugin_found = any(isinstance(plugin, PydanticSchemaPlugin) for plugin in plugins)",
            "            pydantic_serialization_plugin_found = any(isinstance(plugin, PydanticDIPlugin) for plugin in plugins)",
            "            if not pydantic_plugin_found and not pydantic_init_plugin_found and not pydantic_schema_plugin_found:",
            "                plugins.append(PydanticPlugin())",
            "            elif not pydantic_plugin_found and pydantic_init_plugin_found and not pydantic_schema_plugin_found:",
            "                plugins.append(PydanticSchemaPlugin())",
            "            elif not pydantic_plugin_found and not pydantic_init_plugin_found:",
            "                plugins.append(PydanticInitPlugin())",
            "            if not pydantic_plugin_found and not pydantic_serialization_plugin_found:",
            "                plugins.append(PydanticDIPlugin())",
            "        with suppress(MissingDependencyException):",
            "            from litestar.contrib.attrs import AttrsSchemaPlugin",
            "",
            "            pre_configured = any(isinstance(plugin, AttrsSchemaPlugin) for plugin in plugins)",
            "            if not pre_configured:",
            "                plugins.append(AttrsSchemaPlugin())",
            "        return plugins",
            "",
            "    @property",
            "    def debug(self) -> bool:",
            "        return self._debug",
            "",
            "    @debug.setter",
            "    def debug(self, value: bool) -> None:",
            "        \"\"\"Sets the debug logging level for the application.",
            "",
            "        When possible, it calls the `self.logging_config.set_level` method.  This allows for implementation specific code and APIs to be called.",
            "        \"\"\"",
            "        if self.logger and self.logging_config:",
            "            self.logging_config.set_level(self.logger, logging.DEBUG if value else logging.INFO)",
            "        elif self.logger and hasattr(self.logger, \"setLevel\"):  # pragma: no cover",
            "            self.logger.setLevel(logging.DEBUG if value else logging.INFO)  # pragma: no cover",
            "        if isinstance(self.logging_config, LoggingConfig):",
            "            self.logging_config.loggers[\"litestar\"][\"level\"] = \"DEBUG\" if value else \"INFO\"",
            "        self._debug = value",
            "",
            "    async def __call__(",
            "        self,",
            "        scope: Scope | LifeSpanScope,",
            "        receive: Receive | LifeSpanReceive,",
            "        send: Send | LifeSpanSend,",
            "    ) -> None:",
            "        \"\"\"Application entry point.",
            "",
            "        Lifespan events (startup / shutdown) are sent to the lifespan handler, otherwise the ASGI handler is used",
            "",
            "        Args:",
            "            scope: The ASGI connection scope.",
            "            receive: The ASGI receive function.",
            "            send: The ASGI send function.",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        if scope[\"type\"] == \"lifespan\":",
            "            await self.asgi_router.lifespan(receive=receive, send=send)  # type: ignore[arg-type]",
            "            return",
            "",
            "        scope[\"app\"] = self",
            "        scope.setdefault(\"state\", {})",
            "        await self.asgi_handler(scope, receive, self._wrap_send(send=send, scope=scope))  # type: ignore[arg-type]",
            "",
            "    async def _call_lifespan_hook(self, hook: LifespanHook) -> None:",
            "        ret = hook(self) if inspect.signature(hook).parameters else hook()  # type: ignore[call-arg]",
            "",
            "        if is_async_callable(hook):  # pyright: ignore[reportGeneralTypeIssues]",
            "            await ret",
            "",
            "    @asynccontextmanager",
            "    async def lifespan(self) -> AsyncGenerator[None, None]:",
            "        \"\"\"Context manager handling the ASGI lifespan.",
            "",
            "        It will be entered when the ``lifespan`` message has been received from the",
            "        server, and exit after the ``asgi.shutdown`` message. During this period, it is",
            "        responsible for calling the ``on_startup``, ``on_shutdown`` hooks, as well as",
            "        custom lifespan managers.",
            "        \"\"\"",
            "        async with AsyncExitStack() as exit_stack:",
            "            for hook in self.on_shutdown[::-1]:",
            "                exit_stack.push_async_callback(partial(self._call_lifespan_hook, hook))",
            "",
            "            await exit_stack.enter_async_context(self.event_emitter)",
            "",
            "            for manager in self._lifespan_managers:",
            "                if not isinstance(manager, AbstractAsyncContextManager):",
            "                    manager = manager(self)",
            "                await exit_stack.enter_async_context(manager)",
            "",
            "            for hook in self.on_startup:",
            "                await self._call_lifespan_hook(hook)",
            "",
            "            yield",
            "",
            "    @property",
            "    def openapi_schema(self) -> OpenAPI:",
            "        \"\"\"Access  the OpenAPI schema of the application.",
            "",
            "        Returns:",
            "            The :class:`OpenAPI`",
            "            <pydantic_openapi_schema.open_api.OpenAPI> instance of the",
            "            application.",
            "",
            "        Raises:",
            "            ImproperlyConfiguredException: If the application ``openapi_config`` attribute is ``None``.",
            "        \"\"\"",
            "        return self.plugins.get(OpenAPIPlugin).provide_openapi()",
            "",
            "    @classmethod",
            "    def from_config(cls, config: AppConfig) -> Self:",
            "        \"\"\"Initialize a ``Litestar`` application from a configuration instance.",
            "",
            "        Args:",
            "            config: An instance of :class:`AppConfig` <.config.AppConfig>",
            "",
            "        Returns:",
            "            An instance of ``Litestar`` application.",
            "        \"\"\"",
            "        return cls(**dict(extract_dataclass_items(config)))",
            "",
            "    def register(self, value: ControllerRouterHandler) -> None:  # type: ignore[override]",
            "        \"\"\"Register a route handler on the app.",
            "",
            "        This method can be used to dynamically add endpoints to an application.",
            "",
            "        Args:",
            "            value: An instance of :class:`Router <.router.Router>`, a subclass of",
            "                :class:`Controller <.controller.Controller>` or any function decorated by the route handler decorators.",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        routes = super().register(value=value)",
            "",
            "        for route in routes:",
            "            route_handlers = get_route_handlers(route)",
            "",
            "            for route_handler in route_handlers:",
            "                route_handler.on_registration(self)",
            "",
            "            if isinstance(route, HTTPRoute):",
            "                route.create_handler_map()",
            "",
            "            elif isinstance(route, WebSocketRoute):",
            "                handler = route.route_handler",
            "                route.handler_parameter_model = handler.create_kwargs_model(path_parameters=route.path_parameters)",
            "",
            "            for plugin in self.plugins.receive_route:",
            "                plugin.receive_route(route)",
            "",
            "        self.asgi_router.construct_routing_trie()",
            "",
            "    def get_handler_index_by_name(self, name: str) -> HandlerIndex | None:",
            "        \"\"\"Receives a route handler name and returns an optional dictionary containing the route handler instance and",
            "        list of paths sorted lexically.",
            "",
            "        Examples:",
            "            .. code-block:: python",
            "",
            "                from litestar import Litestar, get",
            "",
            "",
            "                @get(\"/\", name=\"my-handler\")",
            "                def handler() -> None:",
            "                    pass",
            "",
            "",
            "                app = Litestar(route_handlers=[handler])",
            "",
            "                handler_index = app.get_handler_index_by_name(\"my-handler\")",
            "",
            "                # { \"paths\": [\"/\"], \"handler\" ... }",
            "",
            "        Args:",
            "            name: A route handler unique name.",
            "",
            "        Returns:",
            "            A :class:`HandlerIndex <.app.HandlerIndex>` instance or ``None``.",
            "        \"\"\"",
            "        handler = self.asgi_router.route_handler_index.get(name)",
            "        if not handler:",
            "            return None",
            "",
            "        identifier = handler.name or str(handler)",
            "        routes = self.asgi_router.route_mapping[identifier]",
            "        paths = sorted(unique([route.path for route in routes]))",
            "",
            "        return HandlerIndex(handler=handler, paths=paths, identifier=identifier)",
            "",
            "    def route_reverse(self, name: str, **path_parameters: Any) -> str:",
            "        \"\"\"Receives a route handler name, path parameter values and returns url path to the handler with filled path",
            "        parameters.",
            "",
            "        Examples:",
            "            .. code-block:: python",
            "",
            "                from litestar import Litestar, get",
            "",
            "",
            "                @get(\"/group/{group_id:int}/user/{user_id:int}\", name=\"get_membership_details\")",
            "                def get_membership_details(group_id: int, user_id: int) -> None:",
            "                    pass",
            "",
            "",
            "                app = Litestar(route_handlers=[get_membership_details])",
            "",
            "                path = app.route_reverse(\"get_membership_details\", user_id=100, group_id=10)",
            "",
            "                # /group/10/user/100",
            "",
            "        Args:",
            "            name: A route handler unique name.",
            "            **path_parameters: Actual values for path parameters in the route.",
            "",
            "        Raises:",
            "            NoRouteMatchFoundException: If route with 'name' does not exist, path parameters are missing in",
            "                ``**path_parameters or have wrong type``.",
            "",
            "        Returns:",
            "            A fully formatted url path.",
            "        \"\"\"",
            "        handler_index = self.get_handler_index_by_name(name)",
            "        if handler_index is None:",
            "            raise NoRouteMatchFoundException(f\"Route {name} can not be found\")",
            "",
            "        allow_str_instead = {datetime, date, time, timedelta, float, Path}",
            "        routes = sorted(",
            "            self.asgi_router.route_mapping[handler_index[\"identifier\"]],",
            "            key=lambda r: len(r.path_parameters),",
            "            reverse=True,",
            "        )",
            "        passed_parameters = set(path_parameters.keys())",
            "",
            "        selected_route = next(",
            "            (route for route in routes if passed_parameters.issuperset(route.path_parameters)),",
            "            routes[-1],",
            "        )",
            "        output: list[str] = []",
            "        for component in selected_route.path_components:",
            "            if isinstance(component, PathParameterDefinition):",
            "                val = path_parameters.get(component.name)",
            "                if not isinstance(val, component.type) and (",
            "                    component.type not in allow_str_instead or not isinstance(val, str)",
            "                ):",
            "                    raise NoRouteMatchFoundException(",
            "                        f\"Received type for path parameter {component.name} doesn't match declared type {component.type}\"",
            "                    )",
            "                output.append(str(val))",
            "            else:",
            "                output.append(component)",
            "",
            "        return join_paths(output)",
            "",
            "    @deprecated(",
            "        \"2.6.0\", info=\"Use create_static_files router instead of StaticFilesConfig, which works with route_reverse\"",
            "    )",
            "    def url_for_static_asset(self, name: str, file_path: str) -> str:",
            "        \"\"\"Receives a static files handler name, an asset file path and returns resolved url path to the asset.",
            "",
            "        Examples:",
            "            .. code-block:: python",
            "",
            "                from litestar import Litestar",
            "                from litestar.static_files.config import StaticFilesConfig",
            "",
            "                app = Litestar(",
            "                    static_files_config=[",
            "                        StaticFilesConfig(directories=[\"css\"], path=\"/static/css\", name=\"css\")",
            "                    ]",
            "                )",
            "",
            "                path = app.url_for_static_asset(\"css\", \"main.css\")",
            "",
            "                # /static/css/main.css",
            "",
            "        Args:",
            "            name: A static handler unique name.",
            "            file_path: a string containing path to an asset.",
            "",
            "        Raises:",
            "            NoRouteMatchFoundException: If static files handler with ``name`` does not exist.",
            "",
            "        Returns:",
            "            A url path to the asset.",
            "        \"\"\"",
            "",
            "        handler_index = self.get_handler_index_by_name(name)",
            "        if handler_index is None:",
            "            raise NoRouteMatchFoundException(f\"Static handler {name} can not be found\")",
            "",
            "        handler_fn = cast(\"AnyCallable\", handler_index[\"handler\"].fn)",
            "        if not isinstance(handler_fn, StaticFiles):",
            "            raise NoRouteMatchFoundException(f\"Handler with name {name} is not a static files handler\")",
            "",
            "        return join_paths([handler_index[\"paths\"][0], file_path])",
            "",
            "    @property",
            "    def route_handler_method_view(self) -> dict[str, list[str]]:",
            "        \"\"\"Map route handlers to paths.",
            "",
            "        Returns:",
            "            A dictionary of router handlers and lists of paths as strings",
            "        \"\"\"",
            "        route_map: dict[str, list[str]] = {",
            "            handler: [route.path for route in routes] for handler, routes in self.asgi_router.route_mapping.items()",
            "        }",
            "        return route_map",
            "",
            "    def _create_asgi_handler(self) -> ASGIApp:",
            "        \"\"\"Create an ASGIApp that wraps the ASGI router inside an exception handler.",
            "",
            "        If CORS or TrustedHost configs are provided to the constructor, they will wrap the router as well.",
            "        \"\"\"",
            "        asgi_handler = wrap_in_exception_handler(app=self.asgi_router)",
            "",
            "        if self.cors_config:",
            "            asgi_handler = CORSMiddleware(app=asgi_handler, config=self.cors_config)",
            "",
            "        try:",
            "            otel_plugin: OpenTelemetryPlugin = self.plugins.get(\"OpenTelemetryPlugin\")",
            "            asgi_handler = otel_plugin.middleware(app=asgi_handler)",
            "        except KeyError:",
            "            pass",
            "",
            "        return asgi_handler",
            "",
            "    def _wrap_send(self, send: Send, scope: Scope) -> Send:",
            "        \"\"\"Wrap the ASGI send and handles any 'before send' hooks.",
            "",
            "        Args:",
            "            send: The ASGI send function.",
            "            scope: The ASGI scope.",
            "",
            "        Returns:",
            "            An ASGI send function.",
            "        \"\"\"",
            "        if self.before_send:",
            "",
            "            async def wrapped_send(message: Message) -> None:",
            "                for hook in self.before_send:",
            "                    await hook(message, scope)",
            "                await send(message)",
            "",
            "            return wrapped_send",
            "        return send",
            "",
            "    def update_openapi_schema(self) -> None:",
            "        \"\"\"Update the OpenAPI schema to reflect the route handlers registered on the app.",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        self.plugins.get(OpenAPIPlugin)._build_openapi()",
            "",
            "    def emit(self, event_id: str, *args: Any, **kwargs: Any) -> None:",
            "        \"\"\"Emit an event to all attached listeners.",
            "",
            "        Args:",
            "            event_id: The ID of the event to emit, e.g ``my_event``.",
            "            args: args to pass to the listener(s).",
            "            kwargs: kwargs to pass to the listener(s)",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        self.event_emitter.emit(event_id, *args, **kwargs)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "litestar.app.Litestar",
            "litestar.app.Litestar.from_config",
            "litellm.utils.token_counter"
        ]
    },
    "litestar/config/app.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "     \"\"\"List of :class:`SerializationPluginProtocol <.plugins.SerializationPluginProtocol>`.\"\"\""
            },
            "1": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "     request_class: type[Request] | None = field(default=None)"
            },
            "2": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "     \"\"\"An optional subclass of :class:`Request <.connection.Request>` to use for http connections.\"\"\""
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+    request_max_body_size: int | None | EmptyType = Empty"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+    \"\"\"Maximum allowed size of the request body in bytes. If this size is exceeded, a '413 - Request Entity Too Large'"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+    error response is returned.\"\"\""
            },
            "6": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "     response_class: type[Response] | None = field(default=None)"
            },
            "7": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "     \"\"\"A custom subclass of :class:`Response <.response.Response>` to be used as the app's default response.\"\"\""
            },
            "8": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "     response_cookies: ResponseCookies = field(default_factory=list)"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import enum",
            "from dataclasses import dataclass, field",
            "from typing import TYPE_CHECKING, Any, Callable",
            "",
            "from litestar.config.allowed_hosts import AllowedHostsConfig",
            "from litestar.config.response_cache import ResponseCacheConfig",
            "from litestar.datastructures import State",
            "from litestar.events.emitter import SimpleEventEmitter",
            "from litestar.types.empty import Empty",
            "",
            "if TYPE_CHECKING:",
            "    from contextlib import AbstractAsyncContextManager",
            "",
            "    from litestar import Litestar, Response",
            "    from litestar.config.compression import CompressionConfig",
            "    from litestar.config.cors import CORSConfig",
            "    from litestar.config.csrf import CSRFConfig",
            "    from litestar.connection import Request, WebSocket",
            "    from litestar.datastructures import CacheControlHeader, ETag",
            "    from litestar.di import Provide",
            "    from litestar.dto import AbstractDTO",
            "    from litestar.events.emitter import BaseEventEmitterBackend",
            "    from litestar.events.listener import EventListener",
            "    from litestar.logging.config import BaseLoggingConfig",
            "    from litestar.openapi.config import OpenAPIConfig",
            "    from litestar.openapi.spec import SecurityRequirement",
            "    from litestar.plugins import PluginProtocol",
            "    from litestar.static_files.config import StaticFilesConfig",
            "    from litestar.stores.base import Store",
            "    from litestar.stores.registry import StoreRegistry",
            "    from litestar.types import (",
            "        AfterExceptionHookHandler,",
            "        AfterRequestHookHandler,",
            "        AfterResponseHookHandler,",
            "        AnyCallable,",
            "        BeforeMessageSendHookHandler,",
            "        BeforeRequestHookHandler,",
            "        ControllerRouterHandler,",
            "        ExceptionHandlersMap,",
            "        Guard,",
            "        Middleware,",
            "        ParametersMap,",
            "        ResponseCookies,",
            "        ResponseHeaders,",
            "        TypeEncodersMap,",
            "    )",
            "    from litestar.types.callable_types import LifespanHook",
            "    from litestar.types.composite_types import TypeDecodersSequence",
            "    from litestar.types.empty import EmptyType",
            "    from litestar.types.internal_types import TemplateConfigType",
            "",
            "",
            "__all__ = (",
            "    \"AppConfig\",",
            "    \"ExperimentalFeatures\",",
            ")",
            "",
            "",
            "@dataclass",
            "class AppConfig:",
            "    \"\"\"The parameters provided to the ``Litestar`` app are used to instantiate an instance, and then the instance is",
            "    passed to any callbacks registered to ``on_app_init`` in the order they are provided.",
            "",
            "    The final attribute values are used to instantiate the application object.",
            "    \"\"\"",
            "",
            "    after_exception: list[AfterExceptionHookHandler] = field(default_factory=list)",
            "    \"\"\"An application level :class:`exception hook handler <.types.AfterExceptionHookHandler>` or list thereof.",
            "",
            "    This hook is called after an exception occurs. In difference to exception handlers, it is not meant to return a",
            "    response - only to process the exception (e.g. log it, send it to Sentry etc.).",
            "    \"\"\"",
            "    after_request: AfterRequestHookHandler | None = field(default=None)",
            "    \"\"\"A sync or async function executed after the route handler function returned and the response object has been",
            "    resolved.",
            "",
            "    Receives the response object which may be any subclass of :class:`Response <.response.Response>`.",
            "    \"\"\"",
            "    after_response: AfterResponseHookHandler | None = field(default=None)",
            "    \"\"\"A sync or async function called after the response has been awaited. It receives the",
            "    :class:`Request <.connection.Request>` object and should not return any values.",
            "    \"\"\"",
            "    allowed_hosts: list[str] | AllowedHostsConfig | None = field(default=None)",
            "    \"\"\"If set enables the builtin allowed hosts middleware.\"\"\"",
            "    before_request: BeforeRequestHookHandler | None = field(default=None)",
            "    \"\"\"A sync or async function called immediately before calling the route handler. Receives the",
            "    :class:`Request <.connection.Request>` instance and any non-``None`` return value is used for the response,",
            "    bypassing the route handler.",
            "    \"\"\"",
            "    before_send: list[BeforeMessageSendHookHandler] = field(default_factory=list)",
            "    \"\"\"An application level :class:`before send hook handler <.types.BeforeMessageSendHookHandler>` or list thereof.",
            "",
            "    This hook is called when the ASGI send function is called.",
            "    \"\"\"",
            "    cache_control: CacheControlHeader | None = field(default=None)",
            "    \"\"\"A ``cache-control`` header of type :class:`CacheControlHeader <.datastructures.CacheControlHeader>` to add to",
            "    route handlers of this app.",
            "",
            "    Can be overridden by route handlers.",
            "    \"\"\"",
            "    compression_config: CompressionConfig | None = field(default=None)",
            "    \"\"\"Configures compression behaviour of the application, this enabled a builtin or user defined Compression",
            "    middleware.",
            "    \"\"\"",
            "    cors_config: CORSConfig | None = field(default=None)",
            "    \"\"\"If set this enables the builtin CORS middleware.\"\"\"",
            "    csrf_config: CSRFConfig | None = field(default=None)",
            "    \"\"\"If set this enables the builtin CSRF middleware.\"\"\"",
            "    debug: bool = field(default=False)",
            "    \"\"\"If ``True``, app errors rendered as HTML with a stack trace.\"\"\"",
            "    dependencies: dict[str, Provide | AnyCallable] = field(default_factory=dict)",
            "    \"\"\"A string keyed dictionary of dependency :class:`Provider <.di.Provide>` instances.\"\"\"",
            "    dto: type[AbstractDTO] | None | EmptyType = field(default=Empty)",
            "    \"\"\":class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for (de)serializing and validation of request data.\"\"\"",
            "    etag: ETag | None = field(default=None)",
            "    \"\"\"An ``etag`` header of type :class:`ETag <.datastructures.ETag>` to add to route handlers of this app.",
            "",
            "    Can be overridden by route handlers.",
            "    \"\"\"",
            "    event_emitter_backend: type[BaseEventEmitterBackend] = field(default=SimpleEventEmitter)",
            "    \"\"\"A subclass of :class:`BaseEventEmitterBackend <.events.emitter.BaseEventEmitterBackend>`.\"\"\"",
            "    exception_handlers: ExceptionHandlersMap = field(default_factory=dict)",
            "    \"\"\"A dictionary that maps handler functions to status codes and/or exception types.\"\"\"",
            "    guards: list[Guard] = field(default_factory=list)",
            "    \"\"\"A list of :class:`Guard <.types.Guard>` callables.\"\"\"",
            "    include_in_schema: bool | EmptyType = field(default=Empty)",
            "    \"\"\"A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema\"\"\"",
            "    lifespan: list[Callable[[Litestar], AbstractAsyncContextManager] | AbstractAsyncContextManager] = field(",
            "        default_factory=list",
            "    )",
            "    \"\"\"A list of callables returning async context managers, wrapping the lifespan of the ASGI application\"\"\"",
            "    listeners: list[EventListener] = field(default_factory=list)",
            "    \"\"\"A list of :class:`EventListener <.events.listener.EventListener>`.\"\"\"",
            "    logging_config: BaseLoggingConfig | None = field(default=None)",
            "    \"\"\"An instance of :class:`BaseLoggingConfig <.logging.config.BaseLoggingConfig>` subclass.\"\"\"",
            "    middleware: list[Middleware] = field(default_factory=list)",
            "    \"\"\"A list of :class:`Middleware <.types.Middleware>`.\"\"\"",
            "    on_shutdown: list[LifespanHook] = field(default_factory=list)",
            "    \"\"\"A list of :class:`LifespanHook <.types.LifespanHook>` called during application shutdown.\"\"\"",
            "    on_startup: list[LifespanHook] = field(default_factory=list)",
            "    \"\"\"A list of :class:`LifespanHook <.types.LifespanHook>` called during application startup.\"\"\"",
            "    openapi_config: OpenAPIConfig | None = field(default=None)",
            "    \"\"\"Defaults to :data:`DEFAULT_OPENAPI_CONFIG <litestar.app.DEFAULT_OPENAPI_CONFIG>`\"\"\"",
            "    opt: dict[str, Any] = field(default_factory=dict)",
            "    \"\"\"A string keyed dictionary of arbitrary values that can be accessed in :class:`Guards <.types.Guard>` or",
            "    wherever you have access to :class:`Request <.connection.Request>` or :class:`ASGI Scope <litestar.types.Scope>`.",
            "",
            "    Can be overridden by routers and router handlers.",
            "    \"\"\"",
            "    parameters: ParametersMap = field(default_factory=dict)",
            "    \"\"\"A mapping of :class:`Parameter <.params.Parameter>` definitions available to all application paths.\"\"\"",
            "    path: str = field(default=\"\")",
            "    \"\"\"A base path that prefixed to all route handlers, controllers and routers associated with the",
            "    application instance.",
            "",
            "    .. versionadded:: 2.8.0",
            "    \"\"\"",
            "    pdb_on_exception: bool = field(default=False)",
            "    \"\"\"Drop into the PDB on an exception\"\"\"",
            "    plugins: list[PluginProtocol] = field(default_factory=list)",
            "    \"\"\"List of :class:`SerializationPluginProtocol <.plugins.SerializationPluginProtocol>`.\"\"\"",
            "    request_class: type[Request] | None = field(default=None)",
            "    \"\"\"An optional subclass of :class:`Request <.connection.Request>` to use for http connections.\"\"\"",
            "    response_class: type[Response] | None = field(default=None)",
            "    \"\"\"A custom subclass of :class:`Response <.response.Response>` to be used as the app's default response.\"\"\"",
            "    response_cookies: ResponseCookies = field(default_factory=list)",
            "    \"\"\"A list of :class:`Cookie <.datastructures.Cookie>`.\"\"\"",
            "    response_headers: ResponseHeaders = field(default_factory=list)",
            "    \"\"\"A string keyed dictionary mapping :class:`ResponseHeader <.datastructures.ResponseHeader>`.\"\"\"",
            "    response_cache_config: ResponseCacheConfig = field(default_factory=ResponseCacheConfig)",
            "    \"\"\"Configures caching behavior of the application.\"\"\"",
            "    return_dto: type[AbstractDTO] | None | EmptyType = field(default=Empty)",
            "    \"\"\":class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for serializing outbound response",
            "    data.",
            "    \"\"\"",
            "    route_handlers: list[ControllerRouterHandler] = field(default_factory=list)",
            "    \"\"\"A required list of route handlers, which can include instances of :class:`Router <.router.Router>`,",
            "    subclasses of :class:`Controller <.controller.Controller>` or any function decorated by the route handler",
            "    decorators.",
            "    \"\"\"",
            "    security: list[SecurityRequirement] = field(default_factory=list)",
            "    \"\"\"A list of dictionaries that will be added to the schema of all route handlers in the application. See",
            "    :data:`SecurityRequirement <.openapi.spec.SecurityRequirement>` for details.",
            "    \"\"\"",
            "    signature_namespace: dict[str, Any] = field(default_factory=dict)",
            "    \"\"\"A mapping of names to types for use in forward reference resolution during signature modeling.\"\"\"",
            "    signature_types: list[Any] = field(default_factory=list)",
            "    \"\"\"A sequence of types for use in forward reference resolution during signature modeling.",
            "",
            "    These types will be added to the signature namespace using their ``__name__`` attribute.",
            "    \"\"\"",
            "    state: State = field(default_factory=State)",
            "    \"\"\"A :class:`State` <.datastructures.State>` instance holding application state.\"\"\"",
            "    static_files_config: list[StaticFilesConfig] = field(default_factory=list)",
            "    \"\"\"An instance or list of :class:`StaticFilesConfig <.static_files.StaticFilesConfig>`.\"\"\"",
            "    stores: StoreRegistry | dict[str, Store] | None = None",
            "    \"\"\"Central registry of :class:`Store <.stores.base.Store>` to be made available and be used throughout the",
            "    application. Can be either a dictionary mapping strings to :class:`Store <.stores.base.Store>` instances, or an",
            "    instance of :class:`StoreRegistry <.stores.registry.StoreRegistry>`.",
            "    \"\"\"",
            "    tags: list[str] = field(default_factory=list)",
            "    \"\"\"A list of string tags that will be appended to the schema of all route handlers under the application.\"\"\"",
            "    template_config: TemplateConfigType | None = field(default=None)",
            "    \"\"\"An instance of :class:`TemplateConfig <.template.TemplateConfig>`.\"\"\"",
            "    type_decoders: TypeDecodersSequence | None = field(default=None)",
            "    \"\"\"A sequence of tuples, each composed of a predicate testing for type identity and a msgspec hook for deserialization.\"\"\"",
            "    type_encoders: TypeEncodersMap | None = field(default=None)",
            "    \"\"\"A mapping of types to callables that transform them into types supported for serialization.\"\"\"",
            "    websocket_class: type[WebSocket] | None = field(default=None)",
            "    \"\"\"An optional subclass of :class:`WebSocket <.connection.WebSocket>` to use for websocket connections.\"\"\"",
            "    multipart_form_part_limit: int = field(default=1000)",
            "    \"\"\"The maximal number of allowed parts in a multipart/formdata request. This limit is intended to protect from",
            "    DoS attacks.\"\"\"",
            "    experimental_features: list[ExperimentalFeatures] | None = None",
            "",
            "    def __post_init__(self) -> None:",
            "        \"\"\"Normalize the allowed hosts to be a config or None.",
            "",
            "        Returns:",
            "            Optional config.",
            "        \"\"\"",
            "        if self.allowed_hosts and isinstance(self.allowed_hosts, list):",
            "            self.allowed_hosts = AllowedHostsConfig(allowed_hosts=self.allowed_hosts)",
            "",
            "",
            "class ExperimentalFeatures(str, enum.Enum):",
            "    DTO_CODEGEN = \"DTO_CODEGEN\""
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import enum",
            "from dataclasses import dataclass, field",
            "from typing import TYPE_CHECKING, Any, Callable",
            "",
            "from litestar.config.allowed_hosts import AllowedHostsConfig",
            "from litestar.config.response_cache import ResponseCacheConfig",
            "from litestar.datastructures import State",
            "from litestar.events.emitter import SimpleEventEmitter",
            "from litestar.types.empty import Empty",
            "",
            "if TYPE_CHECKING:",
            "    from contextlib import AbstractAsyncContextManager",
            "",
            "    from litestar import Litestar, Response",
            "    from litestar.config.compression import CompressionConfig",
            "    from litestar.config.cors import CORSConfig",
            "    from litestar.config.csrf import CSRFConfig",
            "    from litestar.connection import Request, WebSocket",
            "    from litestar.datastructures import CacheControlHeader, ETag",
            "    from litestar.di import Provide",
            "    from litestar.dto import AbstractDTO",
            "    from litestar.events.emitter import BaseEventEmitterBackend",
            "    from litestar.events.listener import EventListener",
            "    from litestar.logging.config import BaseLoggingConfig",
            "    from litestar.openapi.config import OpenAPIConfig",
            "    from litestar.openapi.spec import SecurityRequirement",
            "    from litestar.plugins import PluginProtocol",
            "    from litestar.static_files.config import StaticFilesConfig",
            "    from litestar.stores.base import Store",
            "    from litestar.stores.registry import StoreRegistry",
            "    from litestar.types import (",
            "        AfterExceptionHookHandler,",
            "        AfterRequestHookHandler,",
            "        AfterResponseHookHandler,",
            "        AnyCallable,",
            "        BeforeMessageSendHookHandler,",
            "        BeforeRequestHookHandler,",
            "        ControllerRouterHandler,",
            "        ExceptionHandlersMap,",
            "        Guard,",
            "        Middleware,",
            "        ParametersMap,",
            "        ResponseCookies,",
            "        ResponseHeaders,",
            "        TypeEncodersMap,",
            "    )",
            "    from litestar.types.callable_types import LifespanHook",
            "    from litestar.types.composite_types import TypeDecodersSequence",
            "    from litestar.types.empty import EmptyType",
            "    from litestar.types.internal_types import TemplateConfigType",
            "",
            "",
            "__all__ = (",
            "    \"AppConfig\",",
            "    \"ExperimentalFeatures\",",
            ")",
            "",
            "",
            "@dataclass",
            "class AppConfig:",
            "    \"\"\"The parameters provided to the ``Litestar`` app are used to instantiate an instance, and then the instance is",
            "    passed to any callbacks registered to ``on_app_init`` in the order they are provided.",
            "",
            "    The final attribute values are used to instantiate the application object.",
            "    \"\"\"",
            "",
            "    after_exception: list[AfterExceptionHookHandler] = field(default_factory=list)",
            "    \"\"\"An application level :class:`exception hook handler <.types.AfterExceptionHookHandler>` or list thereof.",
            "",
            "    This hook is called after an exception occurs. In difference to exception handlers, it is not meant to return a",
            "    response - only to process the exception (e.g. log it, send it to Sentry etc.).",
            "    \"\"\"",
            "    after_request: AfterRequestHookHandler | None = field(default=None)",
            "    \"\"\"A sync or async function executed after the route handler function returned and the response object has been",
            "    resolved.",
            "",
            "    Receives the response object which may be any subclass of :class:`Response <.response.Response>`.",
            "    \"\"\"",
            "    after_response: AfterResponseHookHandler | None = field(default=None)",
            "    \"\"\"A sync or async function called after the response has been awaited. It receives the",
            "    :class:`Request <.connection.Request>` object and should not return any values.",
            "    \"\"\"",
            "    allowed_hosts: list[str] | AllowedHostsConfig | None = field(default=None)",
            "    \"\"\"If set enables the builtin allowed hosts middleware.\"\"\"",
            "    before_request: BeforeRequestHookHandler | None = field(default=None)",
            "    \"\"\"A sync or async function called immediately before calling the route handler. Receives the",
            "    :class:`Request <.connection.Request>` instance and any non-``None`` return value is used for the response,",
            "    bypassing the route handler.",
            "    \"\"\"",
            "    before_send: list[BeforeMessageSendHookHandler] = field(default_factory=list)",
            "    \"\"\"An application level :class:`before send hook handler <.types.BeforeMessageSendHookHandler>` or list thereof.",
            "",
            "    This hook is called when the ASGI send function is called.",
            "    \"\"\"",
            "    cache_control: CacheControlHeader | None = field(default=None)",
            "    \"\"\"A ``cache-control`` header of type :class:`CacheControlHeader <.datastructures.CacheControlHeader>` to add to",
            "    route handlers of this app.",
            "",
            "    Can be overridden by route handlers.",
            "    \"\"\"",
            "    compression_config: CompressionConfig | None = field(default=None)",
            "    \"\"\"Configures compression behaviour of the application, this enabled a builtin or user defined Compression",
            "    middleware.",
            "    \"\"\"",
            "    cors_config: CORSConfig | None = field(default=None)",
            "    \"\"\"If set this enables the builtin CORS middleware.\"\"\"",
            "    csrf_config: CSRFConfig | None = field(default=None)",
            "    \"\"\"If set this enables the builtin CSRF middleware.\"\"\"",
            "    debug: bool = field(default=False)",
            "    \"\"\"If ``True``, app errors rendered as HTML with a stack trace.\"\"\"",
            "    dependencies: dict[str, Provide | AnyCallable] = field(default_factory=dict)",
            "    \"\"\"A string keyed dictionary of dependency :class:`Provider <.di.Provide>` instances.\"\"\"",
            "    dto: type[AbstractDTO] | None | EmptyType = field(default=Empty)",
            "    \"\"\":class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for (de)serializing and validation of request data.\"\"\"",
            "    etag: ETag | None = field(default=None)",
            "    \"\"\"An ``etag`` header of type :class:`ETag <.datastructures.ETag>` to add to route handlers of this app.",
            "",
            "    Can be overridden by route handlers.",
            "    \"\"\"",
            "    event_emitter_backend: type[BaseEventEmitterBackend] = field(default=SimpleEventEmitter)",
            "    \"\"\"A subclass of :class:`BaseEventEmitterBackend <.events.emitter.BaseEventEmitterBackend>`.\"\"\"",
            "    exception_handlers: ExceptionHandlersMap = field(default_factory=dict)",
            "    \"\"\"A dictionary that maps handler functions to status codes and/or exception types.\"\"\"",
            "    guards: list[Guard] = field(default_factory=list)",
            "    \"\"\"A list of :class:`Guard <.types.Guard>` callables.\"\"\"",
            "    include_in_schema: bool | EmptyType = field(default=Empty)",
            "    \"\"\"A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema\"\"\"",
            "    lifespan: list[Callable[[Litestar], AbstractAsyncContextManager] | AbstractAsyncContextManager] = field(",
            "        default_factory=list",
            "    )",
            "    \"\"\"A list of callables returning async context managers, wrapping the lifespan of the ASGI application\"\"\"",
            "    listeners: list[EventListener] = field(default_factory=list)",
            "    \"\"\"A list of :class:`EventListener <.events.listener.EventListener>`.\"\"\"",
            "    logging_config: BaseLoggingConfig | None = field(default=None)",
            "    \"\"\"An instance of :class:`BaseLoggingConfig <.logging.config.BaseLoggingConfig>` subclass.\"\"\"",
            "    middleware: list[Middleware] = field(default_factory=list)",
            "    \"\"\"A list of :class:`Middleware <.types.Middleware>`.\"\"\"",
            "    on_shutdown: list[LifespanHook] = field(default_factory=list)",
            "    \"\"\"A list of :class:`LifespanHook <.types.LifespanHook>` called during application shutdown.\"\"\"",
            "    on_startup: list[LifespanHook] = field(default_factory=list)",
            "    \"\"\"A list of :class:`LifespanHook <.types.LifespanHook>` called during application startup.\"\"\"",
            "    openapi_config: OpenAPIConfig | None = field(default=None)",
            "    \"\"\"Defaults to :data:`DEFAULT_OPENAPI_CONFIG <litestar.app.DEFAULT_OPENAPI_CONFIG>`\"\"\"",
            "    opt: dict[str, Any] = field(default_factory=dict)",
            "    \"\"\"A string keyed dictionary of arbitrary values that can be accessed in :class:`Guards <.types.Guard>` or",
            "    wherever you have access to :class:`Request <.connection.Request>` or :class:`ASGI Scope <litestar.types.Scope>`.",
            "",
            "    Can be overridden by routers and router handlers.",
            "    \"\"\"",
            "    parameters: ParametersMap = field(default_factory=dict)",
            "    \"\"\"A mapping of :class:`Parameter <.params.Parameter>` definitions available to all application paths.\"\"\"",
            "    path: str = field(default=\"\")",
            "    \"\"\"A base path that prefixed to all route handlers, controllers and routers associated with the",
            "    application instance.",
            "",
            "    .. versionadded:: 2.8.0",
            "    \"\"\"",
            "    pdb_on_exception: bool = field(default=False)",
            "    \"\"\"Drop into the PDB on an exception\"\"\"",
            "    plugins: list[PluginProtocol] = field(default_factory=list)",
            "    \"\"\"List of :class:`SerializationPluginProtocol <.plugins.SerializationPluginProtocol>`.\"\"\"",
            "    request_class: type[Request] | None = field(default=None)",
            "    \"\"\"An optional subclass of :class:`Request <.connection.Request>` to use for http connections.\"\"\"",
            "    request_max_body_size: int | None | EmptyType = Empty",
            "    \"\"\"Maximum allowed size of the request body in bytes. If this size is exceeded, a '413 - Request Entity Too Large'",
            "    error response is returned.\"\"\"",
            "    response_class: type[Response] | None = field(default=None)",
            "    \"\"\"A custom subclass of :class:`Response <.response.Response>` to be used as the app's default response.\"\"\"",
            "    response_cookies: ResponseCookies = field(default_factory=list)",
            "    \"\"\"A list of :class:`Cookie <.datastructures.Cookie>`.\"\"\"",
            "    response_headers: ResponseHeaders = field(default_factory=list)",
            "    \"\"\"A string keyed dictionary mapping :class:`ResponseHeader <.datastructures.ResponseHeader>`.\"\"\"",
            "    response_cache_config: ResponseCacheConfig = field(default_factory=ResponseCacheConfig)",
            "    \"\"\"Configures caching behavior of the application.\"\"\"",
            "    return_dto: type[AbstractDTO] | None | EmptyType = field(default=Empty)",
            "    \"\"\":class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for serializing outbound response",
            "    data.",
            "    \"\"\"",
            "    route_handlers: list[ControllerRouterHandler] = field(default_factory=list)",
            "    \"\"\"A required list of route handlers, which can include instances of :class:`Router <.router.Router>`,",
            "    subclasses of :class:`Controller <.controller.Controller>` or any function decorated by the route handler",
            "    decorators.",
            "    \"\"\"",
            "    security: list[SecurityRequirement] = field(default_factory=list)",
            "    \"\"\"A list of dictionaries that will be added to the schema of all route handlers in the application. See",
            "    :data:`SecurityRequirement <.openapi.spec.SecurityRequirement>` for details.",
            "    \"\"\"",
            "    signature_namespace: dict[str, Any] = field(default_factory=dict)",
            "    \"\"\"A mapping of names to types for use in forward reference resolution during signature modeling.\"\"\"",
            "    signature_types: list[Any] = field(default_factory=list)",
            "    \"\"\"A sequence of types for use in forward reference resolution during signature modeling.",
            "",
            "    These types will be added to the signature namespace using their ``__name__`` attribute.",
            "    \"\"\"",
            "    state: State = field(default_factory=State)",
            "    \"\"\"A :class:`State` <.datastructures.State>` instance holding application state.\"\"\"",
            "    static_files_config: list[StaticFilesConfig] = field(default_factory=list)",
            "    \"\"\"An instance or list of :class:`StaticFilesConfig <.static_files.StaticFilesConfig>`.\"\"\"",
            "    stores: StoreRegistry | dict[str, Store] | None = None",
            "    \"\"\"Central registry of :class:`Store <.stores.base.Store>` to be made available and be used throughout the",
            "    application. Can be either a dictionary mapping strings to :class:`Store <.stores.base.Store>` instances, or an",
            "    instance of :class:`StoreRegistry <.stores.registry.StoreRegistry>`.",
            "    \"\"\"",
            "    tags: list[str] = field(default_factory=list)",
            "    \"\"\"A list of string tags that will be appended to the schema of all route handlers under the application.\"\"\"",
            "    template_config: TemplateConfigType | None = field(default=None)",
            "    \"\"\"An instance of :class:`TemplateConfig <.template.TemplateConfig>`.\"\"\"",
            "    type_decoders: TypeDecodersSequence | None = field(default=None)",
            "    \"\"\"A sequence of tuples, each composed of a predicate testing for type identity and a msgspec hook for deserialization.\"\"\"",
            "    type_encoders: TypeEncodersMap | None = field(default=None)",
            "    \"\"\"A mapping of types to callables that transform them into types supported for serialization.\"\"\"",
            "    websocket_class: type[WebSocket] | None = field(default=None)",
            "    \"\"\"An optional subclass of :class:`WebSocket <.connection.WebSocket>` to use for websocket connections.\"\"\"",
            "    multipart_form_part_limit: int = field(default=1000)",
            "    \"\"\"The maximal number of allowed parts in a multipart/formdata request. This limit is intended to protect from",
            "    DoS attacks.\"\"\"",
            "    experimental_features: list[ExperimentalFeatures] | None = None",
            "",
            "    def __post_init__(self) -> None:",
            "        \"\"\"Normalize the allowed hosts to be a config or None.",
            "",
            "        Returns:",
            "            Optional config.",
            "        \"\"\"",
            "        if self.allowed_hosts and isinstance(self.allowed_hosts, list):",
            "            self.allowed_hosts = AllowedHostsConfig(allowed_hosts=self.allowed_hosts)",
            "",
            "",
            "class ExperimentalFeatures(str, enum.Enum):",
            "    DTO_CODEGEN = \"DTO_CODEGEN\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "litestar.config.app.AppConfig.self"
        ]
    },
    "litestar/connection/request.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " from __future__ import annotations"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3,
                "PatchRowcode": "+import math"
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " import warnings"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from typing import TYPE_CHECKING, Any, AsyncGenerator, Generic"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+from typing import TYPE_CHECKING, Any, AsyncGenerator, Generic, cast"
            },
            "6": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from litestar._multipart import parse_content_header, parse_multipart_form"
            },
            "8": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from litestar._parsers import parse_url_encoded_form_data"
            },
            "9": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from litestar.datastructures.multi_dicts import FormMultiDict"
            },
            "10": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from litestar.enums import ASGIExtension, RequestEncodingType"
            },
            "11": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from litestar.exceptions import ("
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+    ClientException,"
            },
            "13": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     InternalServerException,"
            },
            "14": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "     LitestarException,"
            },
            "15": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "     LitestarWarning,"
            },
            "16": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " )"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+from litestar.exceptions.http_exceptions import RequestEntityTooLarge"
            },
            "18": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from litestar.serialization import decode_json, decode_msgpack"
            },
            "19": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from litestar.types import Empty"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+from litestar.types import Empty, HTTPReceiveMessage"
            },
            "21": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " __all__ = (\"Request\",)"
            },
            "23": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "         \"_msgpack\","
            },
            "25": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "         \"_content_type\","
            },
            "26": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "         \"_accept\","
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+        \"_content_length\","
            },
            "28": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "         \"is_connected\","
            },
            "29": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "         \"supports_push_promise\","
            },
            "30": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "     )"
            },
            "31": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "         self._msgpack: Any = Empty"
            },
            "32": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         self._content_type: tuple[str, dict[str, str]] | EmptyType = Empty"
            },
            "33": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "         self._accept: Accept | EmptyType = Empty"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+        self._content_length: int | None | EmptyType = Empty"
            },
            "35": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "         self.supports_push_promise = ASGIExtension.SERVER_PUSH in self._server_extensions"
            },
            "36": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 88,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "     @property"
            },
            "38": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "                 )"
            },
            "39": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "         return self._msgpack"
            },
            "40": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 159,
                "PatchRowcode": " "
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+    @property"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+    def content_length(self) -> int | None:"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+        cached_content_length = self._content_length"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+        if cached_content_length is not Empty:"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+            return cached_content_length"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+        content_length_header = self.headers.get(\"content-length\")"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+        try:"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+            content_length = self._content_length = ("
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+                int(content_length_header) if content_length_header is not None else None"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+            )"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+        except ValueError:"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+            raise ClientException(f\"Invalid content-length: {content_length_header!r}\") from None"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+        return content_length"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+"
            },
            "56": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "     async def stream(self) -> AsyncGenerator[bytes, None]:"
            },
            "57": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "         \"\"\"Return an async generator that streams chunks of bytes."
            },
            "58": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 177,
                "PatchRowcode": " "
            },
            "59": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "         if self._body is Empty:"
            },
            "60": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "             if not self.is_connected:"
            },
            "61": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 186,
                "PatchRowcode": "                 raise InternalServerException(\"stream consumed\")"
            },
            "62": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            while event := await self.receive():"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+            announced_content_length = self.content_length"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+            # setting this to 'math.inf' as a micro-optimisation; Comparing against a"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+            # float is slightly faster than checking if a value is 'None' and then"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+            # comparing it to an int. since we expect a limit to be set most of the"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+            # time, this is a bit more efficient"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+            max_content_length = self.route_handler.resolve_request_max_body_size() or math.inf"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+            # if the 'content-length' header is set, and exceeds the limit, we can bail"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+            # out early before reading anything"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+            if announced_content_length is not None and announced_content_length > max_content_length:"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+                raise RequestEntityTooLarge"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+            total_bytes_streamed: int = 0"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+            while event := cast(\"HTTPReceiveMessage\", await self.receive()):"
            },
            "78": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "                 if event[\"type\"] == \"http.request\":"
            },
            "79": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if event[\"body\"]:"
            },
            "80": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                        yield event[\"body\"]"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+                    body = event[\"body\"]"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+                    if body:"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 205,
                "PatchRowcode": "+                        total_bytes_streamed += len(body)"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+                        # if a 'content-length' header was set, check if we have"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+                        # received more bytes than specified. in most cases this should"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+                        # be caught before it hits the application layer and an ASGI"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+                        # server (e.g. uvicorn) will not allow this, but since it's not"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+                        # forbidden according to the HTTP or ASGI spec, we err on the"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+                        # side of caution and still perform this check."
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+                        #"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+                        # uvicorn documented behaviour for this case:"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+                        # https://github.com/encode/uvicorn/blob/fe3910083e3990695bc19c2ef671dd447262ae18/docs/server-behavior.md?plain=1#L11"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+                        if announced_content_length:"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+                            if total_bytes_streamed > announced_content_length:"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+                                raise ClientException(\"Malformed request\")"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+                        # we don't have a 'content-length' header, likely a chunked"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+                        # transfer. we don't really care and simply check if we have"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+                        # received more bytes than allowed"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+                        elif total_bytes_streamed > max_content_length:"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+                            raise RequestEntityTooLarge"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+                        yield body"
            },
            "105": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 227,
                "PatchRowcode": " "
            },
            "106": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "                     if not event.get(\"more_body\", False):"
            },
            "107": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "                         break"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import warnings",
            "from typing import TYPE_CHECKING, Any, AsyncGenerator, Generic",
            "",
            "from litestar._multipart import parse_content_header, parse_multipart_form",
            "from litestar._parsers import parse_url_encoded_form_data",
            "from litestar.connection.base import (",
            "    ASGIConnection,",
            "    AuthT,",
            "    StateT,",
            "    UserT,",
            "    empty_receive,",
            "    empty_send,",
            ")",
            "from litestar.datastructures.headers import Accept",
            "from litestar.datastructures.multi_dicts import FormMultiDict",
            "from litestar.enums import ASGIExtension, RequestEncodingType",
            "from litestar.exceptions import (",
            "    InternalServerException,",
            "    LitestarException,",
            "    LitestarWarning,",
            ")",
            "from litestar.serialization import decode_json, decode_msgpack",
            "from litestar.types import Empty",
            "",
            "__all__ = (\"Request\",)",
            "",
            "",
            "if TYPE_CHECKING:",
            "    from litestar.handlers.http_handlers import HTTPRouteHandler  # noqa: F401",
            "    from litestar.types.asgi_types import HTTPScope, Method, Receive, Scope, Send",
            "    from litestar.types.empty import EmptyType",
            "",
            "",
            "SERVER_PUSH_HEADERS = {",
            "    \"accept\",",
            "    \"accept-encoding\",",
            "    \"accept-language\",",
            "    \"cache-control\",",
            "    \"user-agent\",",
            "}",
            "",
            "",
            "class Request(Generic[UserT, AuthT, StateT], ASGIConnection[\"HTTPRouteHandler\", UserT, AuthT, StateT]):",
            "    \"\"\"The Litestar Request class.\"\"\"",
            "",
            "    __slots__ = (",
            "        \"_json\",",
            "        \"_form\",",
            "        \"_body\",",
            "        \"_msgpack\",",
            "        \"_content_type\",",
            "        \"_accept\",",
            "        \"is_connected\",",
            "        \"supports_push_promise\",",
            "    )",
            "",
            "    scope: HTTPScope  # pyright: ignore",
            "    \"\"\"The ASGI scope attached to the connection.\"\"\"",
            "    receive: Receive",
            "    \"\"\"The ASGI receive function.\"\"\"",
            "    send: Send",
            "    \"\"\"The ASGI send function.\"\"\"",
            "",
            "    def __init__(self, scope: Scope, receive: Receive = empty_receive, send: Send = empty_send) -> None:",
            "        \"\"\"Initialize ``Request``.",
            "",
            "        Args:",
            "            scope: The ASGI connection scope.",
            "            receive: The ASGI receive function.",
            "            send: The ASGI send function.",
            "        \"\"\"",
            "        super().__init__(scope, receive, send)",
            "        self.is_connected: bool = True",
            "        self._body: bytes | EmptyType = Empty",
            "        self._form: FormMultiDict | EmptyType = Empty",
            "        self._json: Any = Empty",
            "        self._msgpack: Any = Empty",
            "        self._content_type: tuple[str, dict[str, str]] | EmptyType = Empty",
            "        self._accept: Accept | EmptyType = Empty",
            "        self.supports_push_promise = ASGIExtension.SERVER_PUSH in self._server_extensions",
            "",
            "    @property",
            "    def method(self) -> Method:",
            "        \"\"\"Return the request method.",
            "",
            "        Returns:",
            "            The request :class:`Method <litestar.types.Method>`",
            "        \"\"\"",
            "        return self.scope[\"method\"]",
            "",
            "    @property",
            "    def content_type(self) -> tuple[str, dict[str, str]]:",
            "        \"\"\"Parse the request's 'Content-Type' header, returning the header value and any options as a dictionary.",
            "",
            "        Returns:",
            "            A tuple with the parsed value and a dictionary containing any options send in it.",
            "        \"\"\"",
            "        if self._content_type is Empty:",
            "            if (content_type := self._connection_state.content_type) is not Empty:",
            "                self._content_type = content_type",
            "            else:",
            "                self._content_type = self._connection_state.content_type = parse_content_header(",
            "                    self.headers.get(\"Content-Type\", \"\")",
            "                )",
            "        return self._content_type",
            "",
            "    @property",
            "    def accept(self) -> Accept:",
            "        \"\"\"Parse the request's 'Accept' header, returning an :class:`Accept <litestar.datastructures.headers.Accept>` instance.",
            "",
            "        Returns:",
            "            An :class:`Accept <litestar.datastructures.headers.Accept>` instance, representing the list of acceptable media types.",
            "        \"\"\"",
            "        if self._accept is Empty:",
            "            if (accept := self._connection_state.accept) is not Empty:",
            "                self._accept = accept",
            "            else:",
            "                self._accept = self._connection_state.accept = Accept(self.headers.get(\"Accept\", \"*/*\"))",
            "        return self._accept",
            "",
            "    async def json(self) -> Any:",
            "        \"\"\"Retrieve the json request body from the request.",
            "",
            "        Returns:",
            "            An arbitrary value",
            "        \"\"\"",
            "        if self._json is Empty:",
            "            if (json_ := self._connection_state.json) is not Empty:",
            "                self._json = json_",
            "            else:",
            "                body = await self.body()",
            "                self._json = self._connection_state.json = decode_json(",
            "                    body or b\"null\", type_decoders=self.route_handler.resolve_type_decoders()",
            "                )",
            "        return self._json",
            "",
            "    async def msgpack(self) -> Any:",
            "        \"\"\"Retrieve the MessagePack request body from the request.",
            "",
            "        Returns:",
            "            An arbitrary value",
            "        \"\"\"",
            "        if self._msgpack is Empty:",
            "            if (msgpack := self._connection_state.msgpack) is not Empty:",
            "                self._msgpack = msgpack",
            "            else:",
            "                body = await self.body()",
            "                self._msgpack = self._connection_state.msgpack = decode_msgpack(",
            "                    body or b\"\\xc0\", type_decoders=self.route_handler.resolve_type_decoders()",
            "                )",
            "        return self._msgpack",
            "",
            "    async def stream(self) -> AsyncGenerator[bytes, None]:",
            "        \"\"\"Return an async generator that streams chunks of bytes.",
            "",
            "        Returns:",
            "            An async generator.",
            "",
            "        Raises:",
            "            RuntimeError: if the stream is already consumed",
            "        \"\"\"",
            "        if self._body is Empty:",
            "            if not self.is_connected:",
            "                raise InternalServerException(\"stream consumed\")",
            "            while event := await self.receive():",
            "                if event[\"type\"] == \"http.request\":",
            "                    if event[\"body\"]:",
            "                        yield event[\"body\"]",
            "",
            "                    if not event.get(\"more_body\", False):",
            "                        break",
            "",
            "                if event[\"type\"] == \"http.disconnect\":",
            "                    raise InternalServerException(\"client disconnected prematurely\")",
            "",
            "            self.is_connected = False",
            "            yield b\"\"",
            "",
            "        else:",
            "            yield self._body",
            "            yield b\"\"",
            "            return",
            "",
            "    async def body(self) -> bytes:",
            "        \"\"\"Return the body of the request.",
            "",
            "        Returns:",
            "            A byte-string representing the body of the request.",
            "        \"\"\"",
            "        if self._body is Empty:",
            "            if (body := self._connection_state.body) is not Empty:",
            "                self._body = body",
            "            else:",
            "                self._body = self._connection_state.body = b\"\".join([c async for c in self.stream()])",
            "        return self._body",
            "",
            "    async def form(self) -> FormMultiDict:",
            "        \"\"\"Retrieve form data from the request. If the request is either a 'multipart/form-data' or an",
            "        'application/x-www-form- urlencoded', return a FormMultiDict instance populated with the values sent in the",
            "        request, otherwise, an empty instance.",
            "",
            "        Returns:",
            "            A FormMultiDict instance",
            "        \"\"\"",
            "        if self._form is Empty:",
            "            if (form_data := self._connection_state.form) is Empty:",
            "                content_type, options = self.content_type",
            "                if content_type == RequestEncodingType.MULTI_PART:",
            "                    form_data = parse_multipart_form(",
            "                        body=await self.body(),",
            "                        boundary=options.get(\"boundary\", \"\").encode(),",
            "                        multipart_form_part_limit=self.app.multipart_form_part_limit,",
            "                    )",
            "                elif content_type == RequestEncodingType.URL_ENCODED:",
            "                    form_data = parse_url_encoded_form_data(",
            "                        await self.body(),",
            "                    )",
            "                else:",
            "                    form_data = {}",
            "",
            "                self._connection_state.form = form_data",
            "",
            "            # form_data is a dict[str, list[str] | str | UploadFile]. Convert it to a",
            "            # list[tuple[str, str | UploadFile]] before passing it to FormMultiDict so",
            "            # multi-keys can be accessed properly",
            "            items = []",
            "            for k, v in form_data.items():",
            "                if isinstance(v, list):",
            "                    for sv in v:",
            "                        items.append((k, sv))",
            "                else:",
            "                    items.append((k, v))",
            "            self._form = FormMultiDict(items)",
            "",
            "        return self._form",
            "",
            "    async def send_push_promise(self, path: str, raise_if_unavailable: bool = False) -> None:",
            "        \"\"\"Send a push promise.",
            "",
            "        This method requires the `http.response.push` extension to be sent from the ASGI server.",
            "",
            "        Args:",
            "            path: Path to send the promise to.",
            "            raise_if_unavailable: Raise an exception if server push is not supported by",
            "                the server",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        if not self.supports_push_promise:",
            "            if raise_if_unavailable:",
            "                raise LitestarException(\"Attempted to send a push promise but the server does not support it\")",
            "",
            "            warnings.warn(",
            "                \"Attempted to send a push promise but the server does not support it. In a future version, this will \"",
            "                \"raise an exception. To enable this behaviour in the current version, set raise_if_unavailable=True. \"",
            "                \"To prevent this behaviour, make sure that the server you are using supports the 'http.response.push' \"",
            "                \"ASGI extension, or check this dynamically via \"",
            "                \":attr:`~litestar.connection.Request.supports_push_promise`\",",
            "                stacklevel=2,",
            "                category=LitestarWarning,",
            "            )",
            "",
            "            return",
            "",
            "        raw_headers = [",
            "            (header_name.encode(\"latin-1\"), value.encode(\"latin-1\"))",
            "            for header_name in (self.headers.keys() & SERVER_PUSH_HEADERS)",
            "            for value in self.headers.getall(header_name, [])",
            "        ]",
            "        await self.send({\"type\": \"http.response.push\", \"path\": path, \"headers\": raw_headers})"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import math",
            "import warnings",
            "from typing import TYPE_CHECKING, Any, AsyncGenerator, Generic, cast",
            "",
            "from litestar._multipart import parse_content_header, parse_multipart_form",
            "from litestar._parsers import parse_url_encoded_form_data",
            "from litestar.connection.base import (",
            "    ASGIConnection,",
            "    AuthT,",
            "    StateT,",
            "    UserT,",
            "    empty_receive,",
            "    empty_send,",
            ")",
            "from litestar.datastructures.headers import Accept",
            "from litestar.datastructures.multi_dicts import FormMultiDict",
            "from litestar.enums import ASGIExtension, RequestEncodingType",
            "from litestar.exceptions import (",
            "    ClientException,",
            "    InternalServerException,",
            "    LitestarException,",
            "    LitestarWarning,",
            ")",
            "from litestar.exceptions.http_exceptions import RequestEntityTooLarge",
            "from litestar.serialization import decode_json, decode_msgpack",
            "from litestar.types import Empty, HTTPReceiveMessage",
            "",
            "__all__ = (\"Request\",)",
            "",
            "",
            "if TYPE_CHECKING:",
            "    from litestar.handlers.http_handlers import HTTPRouteHandler  # noqa: F401",
            "    from litestar.types.asgi_types import HTTPScope, Method, Receive, Scope, Send",
            "    from litestar.types.empty import EmptyType",
            "",
            "",
            "SERVER_PUSH_HEADERS = {",
            "    \"accept\",",
            "    \"accept-encoding\",",
            "    \"accept-language\",",
            "    \"cache-control\",",
            "    \"user-agent\",",
            "}",
            "",
            "",
            "class Request(Generic[UserT, AuthT, StateT], ASGIConnection[\"HTTPRouteHandler\", UserT, AuthT, StateT]):",
            "    \"\"\"The Litestar Request class.\"\"\"",
            "",
            "    __slots__ = (",
            "        \"_json\",",
            "        \"_form\",",
            "        \"_body\",",
            "        \"_msgpack\",",
            "        \"_content_type\",",
            "        \"_accept\",",
            "        \"_content_length\",",
            "        \"is_connected\",",
            "        \"supports_push_promise\",",
            "    )",
            "",
            "    scope: HTTPScope  # pyright: ignore",
            "    \"\"\"The ASGI scope attached to the connection.\"\"\"",
            "    receive: Receive",
            "    \"\"\"The ASGI receive function.\"\"\"",
            "    send: Send",
            "    \"\"\"The ASGI send function.\"\"\"",
            "",
            "    def __init__(self, scope: Scope, receive: Receive = empty_receive, send: Send = empty_send) -> None:",
            "        \"\"\"Initialize ``Request``.",
            "",
            "        Args:",
            "            scope: The ASGI connection scope.",
            "            receive: The ASGI receive function.",
            "            send: The ASGI send function.",
            "        \"\"\"",
            "        super().__init__(scope, receive, send)",
            "        self.is_connected: bool = True",
            "        self._body: bytes | EmptyType = Empty",
            "        self._form: FormMultiDict | EmptyType = Empty",
            "        self._json: Any = Empty",
            "        self._msgpack: Any = Empty",
            "        self._content_type: tuple[str, dict[str, str]] | EmptyType = Empty",
            "        self._accept: Accept | EmptyType = Empty",
            "        self._content_length: int | None | EmptyType = Empty",
            "        self.supports_push_promise = ASGIExtension.SERVER_PUSH in self._server_extensions",
            "",
            "    @property",
            "    def method(self) -> Method:",
            "        \"\"\"Return the request method.",
            "",
            "        Returns:",
            "            The request :class:`Method <litestar.types.Method>`",
            "        \"\"\"",
            "        return self.scope[\"method\"]",
            "",
            "    @property",
            "    def content_type(self) -> tuple[str, dict[str, str]]:",
            "        \"\"\"Parse the request's 'Content-Type' header, returning the header value and any options as a dictionary.",
            "",
            "        Returns:",
            "            A tuple with the parsed value and a dictionary containing any options send in it.",
            "        \"\"\"",
            "        if self._content_type is Empty:",
            "            if (content_type := self._connection_state.content_type) is not Empty:",
            "                self._content_type = content_type",
            "            else:",
            "                self._content_type = self._connection_state.content_type = parse_content_header(",
            "                    self.headers.get(\"Content-Type\", \"\")",
            "                )",
            "        return self._content_type",
            "",
            "    @property",
            "    def accept(self) -> Accept:",
            "        \"\"\"Parse the request's 'Accept' header, returning an :class:`Accept <litestar.datastructures.headers.Accept>` instance.",
            "",
            "        Returns:",
            "            An :class:`Accept <litestar.datastructures.headers.Accept>` instance, representing the list of acceptable media types.",
            "        \"\"\"",
            "        if self._accept is Empty:",
            "            if (accept := self._connection_state.accept) is not Empty:",
            "                self._accept = accept",
            "            else:",
            "                self._accept = self._connection_state.accept = Accept(self.headers.get(\"Accept\", \"*/*\"))",
            "        return self._accept",
            "",
            "    async def json(self) -> Any:",
            "        \"\"\"Retrieve the json request body from the request.",
            "",
            "        Returns:",
            "            An arbitrary value",
            "        \"\"\"",
            "        if self._json is Empty:",
            "            if (json_ := self._connection_state.json) is not Empty:",
            "                self._json = json_",
            "            else:",
            "                body = await self.body()",
            "                self._json = self._connection_state.json = decode_json(",
            "                    body or b\"null\", type_decoders=self.route_handler.resolve_type_decoders()",
            "                )",
            "        return self._json",
            "",
            "    async def msgpack(self) -> Any:",
            "        \"\"\"Retrieve the MessagePack request body from the request.",
            "",
            "        Returns:",
            "            An arbitrary value",
            "        \"\"\"",
            "        if self._msgpack is Empty:",
            "            if (msgpack := self._connection_state.msgpack) is not Empty:",
            "                self._msgpack = msgpack",
            "            else:",
            "                body = await self.body()",
            "                self._msgpack = self._connection_state.msgpack = decode_msgpack(",
            "                    body or b\"\\xc0\", type_decoders=self.route_handler.resolve_type_decoders()",
            "                )",
            "        return self._msgpack",
            "",
            "    @property",
            "    def content_length(self) -> int | None:",
            "        cached_content_length = self._content_length",
            "        if cached_content_length is not Empty:",
            "            return cached_content_length",
            "",
            "        content_length_header = self.headers.get(\"content-length\")",
            "        try:",
            "            content_length = self._content_length = (",
            "                int(content_length_header) if content_length_header is not None else None",
            "            )",
            "        except ValueError:",
            "            raise ClientException(f\"Invalid content-length: {content_length_header!r}\") from None",
            "        return content_length",
            "",
            "    async def stream(self) -> AsyncGenerator[bytes, None]:",
            "        \"\"\"Return an async generator that streams chunks of bytes.",
            "",
            "        Returns:",
            "            An async generator.",
            "",
            "        Raises:",
            "            RuntimeError: if the stream is already consumed",
            "        \"\"\"",
            "        if self._body is Empty:",
            "            if not self.is_connected:",
            "                raise InternalServerException(\"stream consumed\")",
            "",
            "            announced_content_length = self.content_length",
            "            # setting this to 'math.inf' as a micro-optimisation; Comparing against a",
            "            # float is slightly faster than checking if a value is 'None' and then",
            "            # comparing it to an int. since we expect a limit to be set most of the",
            "            # time, this is a bit more efficient",
            "            max_content_length = self.route_handler.resolve_request_max_body_size() or math.inf",
            "",
            "            # if the 'content-length' header is set, and exceeds the limit, we can bail",
            "            # out early before reading anything",
            "            if announced_content_length is not None and announced_content_length > max_content_length:",
            "                raise RequestEntityTooLarge",
            "",
            "            total_bytes_streamed: int = 0",
            "            while event := cast(\"HTTPReceiveMessage\", await self.receive()):",
            "                if event[\"type\"] == \"http.request\":",
            "                    body = event[\"body\"]",
            "                    if body:",
            "                        total_bytes_streamed += len(body)",
            "",
            "                        # if a 'content-length' header was set, check if we have",
            "                        # received more bytes than specified. in most cases this should",
            "                        # be caught before it hits the application layer and an ASGI",
            "                        # server (e.g. uvicorn) will not allow this, but since it's not",
            "                        # forbidden according to the HTTP or ASGI spec, we err on the",
            "                        # side of caution and still perform this check.",
            "                        #",
            "                        # uvicorn documented behaviour for this case:",
            "                        # https://github.com/encode/uvicorn/blob/fe3910083e3990695bc19c2ef671dd447262ae18/docs/server-behavior.md?plain=1#L11",
            "                        if announced_content_length:",
            "                            if total_bytes_streamed > announced_content_length:",
            "                                raise ClientException(\"Malformed request\")",
            "",
            "                        # we don't have a 'content-length' header, likely a chunked",
            "                        # transfer. we don't really care and simply check if we have",
            "                        # received more bytes than allowed",
            "                        elif total_bytes_streamed > max_content_length:",
            "                            raise RequestEntityTooLarge",
            "",
            "                        yield body",
            "",
            "                    if not event.get(\"more_body\", False):",
            "                        break",
            "",
            "                if event[\"type\"] == \"http.disconnect\":",
            "                    raise InternalServerException(\"client disconnected prematurely\")",
            "",
            "            self.is_connected = False",
            "            yield b\"\"",
            "",
            "        else:",
            "            yield self._body",
            "            yield b\"\"",
            "            return",
            "",
            "    async def body(self) -> bytes:",
            "        \"\"\"Return the body of the request.",
            "",
            "        Returns:",
            "            A byte-string representing the body of the request.",
            "        \"\"\"",
            "        if self._body is Empty:",
            "            if (body := self._connection_state.body) is not Empty:",
            "                self._body = body",
            "            else:",
            "                self._body = self._connection_state.body = b\"\".join([c async for c in self.stream()])",
            "        return self._body",
            "",
            "    async def form(self) -> FormMultiDict:",
            "        \"\"\"Retrieve form data from the request. If the request is either a 'multipart/form-data' or an",
            "        'application/x-www-form- urlencoded', return a FormMultiDict instance populated with the values sent in the",
            "        request, otherwise, an empty instance.",
            "",
            "        Returns:",
            "            A FormMultiDict instance",
            "        \"\"\"",
            "        if self._form is Empty:",
            "            if (form_data := self._connection_state.form) is Empty:",
            "                content_type, options = self.content_type",
            "                if content_type == RequestEncodingType.MULTI_PART:",
            "                    form_data = parse_multipart_form(",
            "                        body=await self.body(),",
            "                        boundary=options.get(\"boundary\", \"\").encode(),",
            "                        multipart_form_part_limit=self.app.multipart_form_part_limit,",
            "                    )",
            "                elif content_type == RequestEncodingType.URL_ENCODED:",
            "                    form_data = parse_url_encoded_form_data(",
            "                        await self.body(),",
            "                    )",
            "                else:",
            "                    form_data = {}",
            "",
            "                self._connection_state.form = form_data",
            "",
            "            # form_data is a dict[str, list[str] | str | UploadFile]. Convert it to a",
            "            # list[tuple[str, str | UploadFile]] before passing it to FormMultiDict so",
            "            # multi-keys can be accessed properly",
            "            items = []",
            "            for k, v in form_data.items():",
            "                if isinstance(v, list):",
            "                    for sv in v:",
            "                        items.append((k, sv))",
            "                else:",
            "                    items.append((k, v))",
            "            self._form = FormMultiDict(items)",
            "",
            "        return self._form",
            "",
            "    async def send_push_promise(self, path: str, raise_if_unavailable: bool = False) -> None:",
            "        \"\"\"Send a push promise.",
            "",
            "        This method requires the `http.response.push` extension to be sent from the ASGI server.",
            "",
            "        Args:",
            "            path: Path to send the promise to.",
            "            raise_if_unavailable: Raise an exception if server push is not supported by",
            "                the server",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        if not self.supports_push_promise:",
            "            if raise_if_unavailable:",
            "                raise LitestarException(\"Attempted to send a push promise but the server does not support it\")",
            "",
            "            warnings.warn(",
            "                \"Attempted to send a push promise but the server does not support it. In a future version, this will \"",
            "                \"raise an exception. To enable this behaviour in the current version, set raise_if_unavailable=True. \"",
            "                \"To prevent this behaviour, make sure that the server you are using supports the 'http.response.push' \"",
            "                \"ASGI extension, or check this dynamically via \"",
            "                \":attr:`~litestar.connection.Request.supports_push_promise`\",",
            "                stacklevel=2,",
            "                category=LitestarWarning,",
            "            )",
            "",
            "            return",
            "",
            "        raw_headers = [",
            "            (header_name.encode(\"latin-1\"), value.encode(\"latin-1\"))",
            "            for header_name in (self.headers.keys() & SERVER_PUSH_HEADERS)",
            "            for value in self.headers.getall(header_name, [])",
            "        ]",
            "        await self.send({\"type\": \"http.response.push\", \"path\": path, \"headers\": raw_headers})"
        ],
        "action": [
            "0",
            "0",
            "-1",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "4": [],
            "25": [],
            "167": [
                "Request"
            ],
            "169": [
                "Request"
            ],
            "170": [
                "Request"
            ]
        },
        "addLocation": []
    },
    "litestar/controller.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "         \"parameters\","
            },
            "1": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "         \"path\","
            },
            "2": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "         \"request_class\","
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        \"request_max_body_size\","
            },
            "4": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 68,
                "PatchRowcode": "         \"response_class\","
            },
            "5": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "         \"response_cookies\","
            },
            "6": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         \"response_headers\","
            },
            "7": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "     \"\"\"A custom subclass of :class:`Request <.connection.Request>` to be used as the default request for all route"
            },
            "8": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "     handlers under the controller."
            },
            "9": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "     \"\"\""
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+    request_max_body_size: int | None | EmptyType"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+    \"\"\""
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+    Maximum allowed size of the request body in bytes. If this size is exceeded, a '413 - Request Entity Too Large'"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+    error response is returned.\"\"\""
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "     response_class: type[Response] | None"
            },
            "16": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "     \"\"\"A custom subclass of :class:`Response <.response.Response>` to be used as the default response for all route"
            },
            "17": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "     handlers under the controller."
            },
            "18": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": 197,
                "PatchRowcode": "         if not hasattr(self, \"include_in_schema\"):"
            },
            "19": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": 198,
                "PatchRowcode": "             self.include_in_schema = Empty"
            },
            "20": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 199,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+        if not hasattr(self, \"request_max_body_size\"):"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+            self.request_max_body_size = Empty"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "         self.signature_namespace = add_types_to_signature_namespace("
            },
            "25": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "             getattr(self, \"signature_types\", []), getattr(self, \"signature_namespace\", {})"
            },
            "26": {
                "beforePatchRowNumber": 196,
                "afterPatchRowNumber": 205,
                "PatchRowcode": "         )"
            },
            "27": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "             type_encoders=self.type_encoders,"
            },
            "28": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "             type_decoders=self.type_decoders,"
            },
            "29": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "             websocket_class=self.websocket_class,"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+            request_max_body_size=self.request_max_body_size,"
            },
            "31": {
                "beforePatchRowNumber": 238,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "         )"
            },
            "32": {
                "beforePatchRowNumber": 239,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "         router.owner = self.owner"
            },
            "33": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "         return router"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import types",
            "from collections import defaultdict",
            "from copy import deepcopy",
            "from operator import attrgetter",
            "from typing import TYPE_CHECKING, Any, Mapping, Sequence, cast",
            "",
            "from litestar._layers.utils import narrow_response_cookies, narrow_response_headers",
            "from litestar.exceptions import ImproperlyConfiguredException",
            "from litestar.handlers.base import BaseRouteHandler",
            "from litestar.handlers.http_handlers import HTTPRouteHandler",
            "from litestar.handlers.websocket_handlers import WebsocketRouteHandler",
            "from litestar.types.empty import Empty",
            "from litestar.utils import normalize_path",
            "from litestar.utils.signature import add_types_to_signature_namespace",
            "",
            "__all__ = (\"Controller\",)",
            "",
            "",
            "if TYPE_CHECKING:",
            "    from litestar.connection import Request, WebSocket",
            "    from litestar.datastructures import CacheControlHeader, ETag",
            "    from litestar.dto import AbstractDTO",
            "    from litestar.openapi.spec import SecurityRequirement",
            "    from litestar.response import Response",
            "    from litestar.router import Router",
            "    from litestar.types import (",
            "        AfterRequestHookHandler,",
            "        AfterResponseHookHandler,",
            "        BeforeRequestHookHandler,",
            "        Dependencies,",
            "        ExceptionHandlersMap,",
            "        Guard,",
            "        Middleware,",
            "        ParametersMap,",
            "        ResponseCookies,",
            "        TypeEncodersMap,",
            "    )",
            "    from litestar.types.composite_types import ResponseHeaders, TypeDecodersSequence",
            "    from litestar.types.empty import EmptyType",
            "",
            "",
            "class Controller:",
            "    \"\"\"The Litestar Controller class.",
            "",
            "    Subclass this class to create 'view' like components and utilize OOP.",
            "    \"\"\"",
            "",
            "    __slots__ = (",
            "        \"after_request\",",
            "        \"after_response\",",
            "        \"before_request\",",
            "        \"cache_control\",",
            "        \"dependencies\",",
            "        \"dto\",",
            "        \"etag\",",
            "        \"exception_handlers\",",
            "        \"guards\",",
            "        \"include_in_schema\",",
            "        \"middleware\",",
            "        \"opt\",",
            "        \"owner\",",
            "        \"parameters\",",
            "        \"path\",",
            "        \"request_class\",",
            "        \"response_class\",",
            "        \"response_cookies\",",
            "        \"response_headers\",",
            "        \"return_dto\",",
            "        \"security\",",
            "        \"signature_namespace\",",
            "        \"signature_types\",",
            "        \"tags\",",
            "        \"type_encoders\",",
            "        \"type_decoders\",",
            "        \"websocket_class\",",
            "    )",
            "",
            "    after_request: AfterRequestHookHandler | None",
            "    \"\"\"A sync or async function executed before a :class:`Request <.connection.Request>` is passed to any route handler.",
            "",
            "    If this function returns a value, the request will not reach the route handler, and instead this value will be used.",
            "    \"\"\"",
            "    after_response: AfterResponseHookHandler | None",
            "    \"\"\"A sync or async function called after the response has been awaited.",
            "",
            "    It receives the :class:`Request <.connection.Request>` instance and should not return any values.",
            "    \"\"\"",
            "    before_request: BeforeRequestHookHandler | None",
            "    \"\"\"A sync or async function called immediately before calling the route handler.",
            "",
            "    It receives the :class:`Request <.connection.Request>` instance and any non-``None`` return value is used for the",
            "    response, bypassing the route handler.",
            "    \"\"\"",
            "    cache_control: CacheControlHeader | None",
            "    \"\"\"A :class:`CacheControlHeader <.datastructures.CacheControlHeader>` header to add to route handlers of this",
            "    controller.",
            "",
            "    Can be overridden by route handlers.",
            "    \"\"\"",
            "    dependencies: Dependencies | None",
            "    \"\"\"A string keyed dictionary of dependency :class:`Provider <.di.Provide>` instances.\"\"\"",
            "    dto: type[AbstractDTO] | None | EmptyType",
            "    \"\"\":class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for (de)serializing and validation of request data.\"\"\"",
            "    etag: ETag | None",
            "    \"\"\"An ``etag`` header of type :class:`ETag <.datastructures.ETag>` to add to route handlers of this controller.",
            "",
            "    Can be overridden by route handlers.",
            "    \"\"\"",
            "    exception_handlers: ExceptionHandlersMap | None",
            "    \"\"\"A map of handler functions to status codes and/or exception types.\"\"\"",
            "    guards: Sequence[Guard] | None",
            "    \"\"\"A sequence of :class:`Guard <.types.Guard>` callables.\"\"\"",
            "    include_in_schema: bool | EmptyType",
            "    \"\"\"A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema\"\"\"",
            "    middleware: Sequence[Middleware] | None",
            "    \"\"\"A sequence of :class:`Middleware <.types.Middleware>`.\"\"\"",
            "    opt: Mapping[str, Any] | None",
            "    \"\"\"A string key mapping of arbitrary values that can be accessed in :class:`Guards <.types.Guard>` or wherever you",
            "    have access to :class:`Request <.connection.Request>` or :class:`ASGI Scope <.types.Scope>`.",
            "    \"\"\"",
            "    owner: Router",
            "    \"\"\"The :class:`Router <.router.Router>` or :class:`Litestar <litestar.app.Litestar>` app that owns the controller.",
            "",
            "    This value is set internally by Litestar and it should not be set when subclassing the controller.",
            "    \"\"\"",
            "    parameters: ParametersMap | None",
            "    \"\"\"A mapping of :class:`Parameter <.params.Parameter>` definitions available to all application paths.\"\"\"",
            "    path: str",
            "    \"\"\"A path fragment for the controller.",
            "",
            "    All route handlers under the controller will have the fragment appended to them. If not set it defaults to ``/``.",
            "    \"\"\"",
            "    request_class: type[Request] | None",
            "    \"\"\"A custom subclass of :class:`Request <.connection.Request>` to be used as the default request for all route",
            "    handlers under the controller.",
            "    \"\"\"",
            "    response_class: type[Response] | None",
            "    \"\"\"A custom subclass of :class:`Response <.response.Response>` to be used as the default response for all route",
            "    handlers under the controller.",
            "    \"\"\"",
            "    response_cookies: ResponseCookies | None",
            "    \"\"\"A list of :class:`Cookie <.datastructures.Cookie>` instances.\"\"\"",
            "    response_headers: ResponseHeaders | None",
            "    \"\"\"A string keyed dictionary mapping :class:`ResponseHeader <.datastructures.ResponseHeader>` instances.\"\"\"",
            "    return_dto: type[AbstractDTO] | None | EmptyType",
            "    \"\"\":class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for serializing outbound response",
            "    data.",
            "    \"\"\"",
            "    tags: Sequence[str] | None",
            "    \"\"\"A sequence of string tags that will be appended to the schema of all route handlers under the controller.\"\"\"",
            "    security: Sequence[SecurityRequirement] | None",
            "    \"\"\"A sequence of dictionaries that to the schema of all route handlers under the controller.\"\"\"",
            "    signature_namespace: dict[str, Any]",
            "    \"\"\"A mapping of names to types for use in forward reference resolution during signature modeling.\"\"\"",
            "    signature_types: Sequence[Any]",
            "    \"\"\"A sequence of types for use in forward reference resolution during signature modeling.",
            "",
            "    These types will be added to the signature namespace using their ``__name__`` attribute.",
            "    \"\"\"",
            "    type_decoders: TypeDecodersSequence | None",
            "    \"\"\"A sequence of tuples, each composed of a predicate testing for type identity and a msgspec hook for deserialization.\"\"\"",
            "    type_encoders: TypeEncodersMap | None",
            "    \"\"\"A mapping of types to callables that transform them into types supported for serialization.\"\"\"",
            "    websocket_class: type[WebSocket] | None",
            "    \"\"\"A custom subclass of :class:`WebSocket <.connection.WebSocket>` to be used as the default websocket for all route",
            "    handlers under the controller.",
            "    \"\"\"",
            "",
            "    def __init__(self, owner: Router) -> None:",
            "        \"\"\"Initialize a controller.",
            "",
            "        Should only be called by routers as part of controller registration.",
            "",
            "        Args:",
            "            owner: An instance of :class:`Router <.router.Router>`",
            "        \"\"\"",
            "        # Since functions set on classes are bound, we need replace the bound instance with the class version",
            "        for key in (\"after_request\", \"after_response\", \"before_request\"):",
            "            cls_value = getattr(type(self), key, None)",
            "            if callable(cls_value):",
            "                setattr(self, key, cls_value)",
            "",
            "        if not hasattr(self, \"dto\"):",
            "            self.dto = Empty",
            "",
            "        if not hasattr(self, \"return_dto\"):",
            "            self.return_dto = Empty",
            "",
            "        if not hasattr(self, \"include_in_schema\"):",
            "            self.include_in_schema = Empty",
            "",
            "        self.signature_namespace = add_types_to_signature_namespace(",
            "            getattr(self, \"signature_types\", []), getattr(self, \"signature_namespace\", {})",
            "        )",
            "",
            "        for key in self.__slots__:",
            "            if not hasattr(self, key):",
            "                setattr(self, key, None)",
            "",
            "        self.response_cookies = narrow_response_cookies(self.response_cookies)",
            "        self.response_headers = narrow_response_headers(self.response_headers)",
            "        self.path = normalize_path(self.path or \"/\")",
            "        self.owner = owner",
            "",
            "    def as_router(self) -> Router:",
            "        from litestar.router import Router",
            "",
            "        router = Router(",
            "            path=self.path,",
            "            route_handlers=self.get_route_handlers(),",
            "            after_request=self.after_request,",
            "            after_response=self.after_response,",
            "            before_request=self.before_request,",
            "            cache_control=self.cache_control,",
            "            dependencies=self.dependencies,",
            "            dto=self.dto,",
            "            etag=self.etag,",
            "            exception_handlers=self.exception_handlers,",
            "            guards=self.guards,",
            "            include_in_schema=self.include_in_schema,",
            "            middleware=self.middleware,",
            "            opt=self.opt,",
            "            parameters=self.parameters,",
            "            request_class=self.request_class,",
            "            response_class=self.response_class,",
            "            response_cookies=self.response_cookies,",
            "            response_headers=self.response_headers,",
            "            return_dto=self.return_dto,",
            "            security=self.security,",
            "            signature_types=self.signature_types,",
            "            signature_namespace=self.signature_namespace,",
            "            tags=self.tags,",
            "            type_encoders=self.type_encoders,",
            "            type_decoders=self.type_decoders,",
            "            websocket_class=self.websocket_class,",
            "        )",
            "        router.owner = self.owner",
            "        return router",
            "",
            "    def get_route_handlers(self) -> list[BaseRouteHandler]:",
            "        \"\"\"Get a controller's route handlers and set the controller as the handlers' owner.",
            "",
            "        Returns:",
            "            A list containing a copy of the route handlers defined on the controller",
            "        \"\"\"",
            "",
            "        route_handlers: list[BaseRouteHandler] = []",
            "        controller_names = set(dir(Controller))",
            "        self_handlers = [",
            "            getattr(self, name)",
            "            for name in dir(self)",
            "            if name not in controller_names and isinstance(getattr(self, name), BaseRouteHandler)",
            "        ]",
            "        self_handlers.sort(key=attrgetter(\"handler_id\"))",
            "        for self_handler in self_handlers:",
            "            route_handler = deepcopy(self_handler)",
            "            # at the point we get a reference to the handler function, it's unbound, so",
            "            # we replace it with a regular bound method here",
            "            route_handler._fn = types.MethodType(route_handler._fn, self)",
            "            route_handler.owner = self",
            "            route_handlers.append(route_handler)",
            "",
            "        self.validate_route_handlers(route_handlers=route_handlers)",
            "",
            "        return route_handlers",
            "",
            "    def validate_route_handlers(self, route_handlers: list[BaseRouteHandler]) -> None:",
            "        \"\"\"Validate that the combination of path and decorator method or type are unique on the controller.",
            "",
            "        Args:",
            "            route_handlers: The controller's route handlers.",
            "",
            "        Raises:",
            "            ImproperlyConfiguredException",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        paths: defaultdict[str, set[str]] = defaultdict(set)",
            "",
            "        for route_handler in route_handlers:",
            "            if isinstance(route_handler, HTTPRouteHandler):",
            "                methods: set[str] = cast(\"set[str]\", route_handler.http_methods)",
            "            elif isinstance(route_handler, WebsocketRouteHandler):",
            "                methods = {\"websocket\"}",
            "            else:",
            "                methods = {\"asgi\"}",
            "",
            "            for path in route_handler.paths:",
            "                if (entry := paths[path]) and (intersection := entry.intersection(methods)):",
            "                    raise ImproperlyConfiguredException(",
            "                        f\"the combination of path and method must be unique in a controller - \"",
            "                        f\"the following methods {''.join(m.lower() for m in intersection)} for {type(self).__name__} \"",
            "                        f\"controller path {path} are not unique\"",
            "                    )",
            "                paths[path].update(methods)"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import types",
            "from collections import defaultdict",
            "from copy import deepcopy",
            "from operator import attrgetter",
            "from typing import TYPE_CHECKING, Any, Mapping, Sequence, cast",
            "",
            "from litestar._layers.utils import narrow_response_cookies, narrow_response_headers",
            "from litestar.exceptions import ImproperlyConfiguredException",
            "from litestar.handlers.base import BaseRouteHandler",
            "from litestar.handlers.http_handlers import HTTPRouteHandler",
            "from litestar.handlers.websocket_handlers import WebsocketRouteHandler",
            "from litestar.types.empty import Empty",
            "from litestar.utils import normalize_path",
            "from litestar.utils.signature import add_types_to_signature_namespace",
            "",
            "__all__ = (\"Controller\",)",
            "",
            "",
            "if TYPE_CHECKING:",
            "    from litestar.connection import Request, WebSocket",
            "    from litestar.datastructures import CacheControlHeader, ETag",
            "    from litestar.dto import AbstractDTO",
            "    from litestar.openapi.spec import SecurityRequirement",
            "    from litestar.response import Response",
            "    from litestar.router import Router",
            "    from litestar.types import (",
            "        AfterRequestHookHandler,",
            "        AfterResponseHookHandler,",
            "        BeforeRequestHookHandler,",
            "        Dependencies,",
            "        ExceptionHandlersMap,",
            "        Guard,",
            "        Middleware,",
            "        ParametersMap,",
            "        ResponseCookies,",
            "        TypeEncodersMap,",
            "    )",
            "    from litestar.types.composite_types import ResponseHeaders, TypeDecodersSequence",
            "    from litestar.types.empty import EmptyType",
            "",
            "",
            "class Controller:",
            "    \"\"\"The Litestar Controller class.",
            "",
            "    Subclass this class to create 'view' like components and utilize OOP.",
            "    \"\"\"",
            "",
            "    __slots__ = (",
            "        \"after_request\",",
            "        \"after_response\",",
            "        \"before_request\",",
            "        \"cache_control\",",
            "        \"dependencies\",",
            "        \"dto\",",
            "        \"etag\",",
            "        \"exception_handlers\",",
            "        \"guards\",",
            "        \"include_in_schema\",",
            "        \"middleware\",",
            "        \"opt\",",
            "        \"owner\",",
            "        \"parameters\",",
            "        \"path\",",
            "        \"request_class\",",
            "        \"request_max_body_size\",",
            "        \"response_class\",",
            "        \"response_cookies\",",
            "        \"response_headers\",",
            "        \"return_dto\",",
            "        \"security\",",
            "        \"signature_namespace\",",
            "        \"signature_types\",",
            "        \"tags\",",
            "        \"type_encoders\",",
            "        \"type_decoders\",",
            "        \"websocket_class\",",
            "    )",
            "",
            "    after_request: AfterRequestHookHandler | None",
            "    \"\"\"A sync or async function executed before a :class:`Request <.connection.Request>` is passed to any route handler.",
            "",
            "    If this function returns a value, the request will not reach the route handler, and instead this value will be used.",
            "    \"\"\"",
            "    after_response: AfterResponseHookHandler | None",
            "    \"\"\"A sync or async function called after the response has been awaited.",
            "",
            "    It receives the :class:`Request <.connection.Request>` instance and should not return any values.",
            "    \"\"\"",
            "    before_request: BeforeRequestHookHandler | None",
            "    \"\"\"A sync or async function called immediately before calling the route handler.",
            "",
            "    It receives the :class:`Request <.connection.Request>` instance and any non-``None`` return value is used for the",
            "    response, bypassing the route handler.",
            "    \"\"\"",
            "    cache_control: CacheControlHeader | None",
            "    \"\"\"A :class:`CacheControlHeader <.datastructures.CacheControlHeader>` header to add to route handlers of this",
            "    controller.",
            "",
            "    Can be overridden by route handlers.",
            "    \"\"\"",
            "    dependencies: Dependencies | None",
            "    \"\"\"A string keyed dictionary of dependency :class:`Provider <.di.Provide>` instances.\"\"\"",
            "    dto: type[AbstractDTO] | None | EmptyType",
            "    \"\"\":class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for (de)serializing and validation of request data.\"\"\"",
            "    etag: ETag | None",
            "    \"\"\"An ``etag`` header of type :class:`ETag <.datastructures.ETag>` to add to route handlers of this controller.",
            "",
            "    Can be overridden by route handlers.",
            "    \"\"\"",
            "    exception_handlers: ExceptionHandlersMap | None",
            "    \"\"\"A map of handler functions to status codes and/or exception types.\"\"\"",
            "    guards: Sequence[Guard] | None",
            "    \"\"\"A sequence of :class:`Guard <.types.Guard>` callables.\"\"\"",
            "    include_in_schema: bool | EmptyType",
            "    \"\"\"A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema\"\"\"",
            "    middleware: Sequence[Middleware] | None",
            "    \"\"\"A sequence of :class:`Middleware <.types.Middleware>`.\"\"\"",
            "    opt: Mapping[str, Any] | None",
            "    \"\"\"A string key mapping of arbitrary values that can be accessed in :class:`Guards <.types.Guard>` or wherever you",
            "    have access to :class:`Request <.connection.Request>` or :class:`ASGI Scope <.types.Scope>`.",
            "    \"\"\"",
            "    owner: Router",
            "    \"\"\"The :class:`Router <.router.Router>` or :class:`Litestar <litestar.app.Litestar>` app that owns the controller.",
            "",
            "    This value is set internally by Litestar and it should not be set when subclassing the controller.",
            "    \"\"\"",
            "    parameters: ParametersMap | None",
            "    \"\"\"A mapping of :class:`Parameter <.params.Parameter>` definitions available to all application paths.\"\"\"",
            "    path: str",
            "    \"\"\"A path fragment for the controller.",
            "",
            "    All route handlers under the controller will have the fragment appended to them. If not set it defaults to ``/``.",
            "    \"\"\"",
            "    request_class: type[Request] | None",
            "    \"\"\"A custom subclass of :class:`Request <.connection.Request>` to be used as the default request for all route",
            "    handlers under the controller.",
            "    \"\"\"",
            "    request_max_body_size: int | None | EmptyType",
            "    \"\"\"",
            "    Maximum allowed size of the request body in bytes. If this size is exceeded, a '413 - Request Entity Too Large'",
            "    error response is returned.\"\"\"",
            "",
            "    response_class: type[Response] | None",
            "    \"\"\"A custom subclass of :class:`Response <.response.Response>` to be used as the default response for all route",
            "    handlers under the controller.",
            "    \"\"\"",
            "    response_cookies: ResponseCookies | None",
            "    \"\"\"A list of :class:`Cookie <.datastructures.Cookie>` instances.\"\"\"",
            "    response_headers: ResponseHeaders | None",
            "    \"\"\"A string keyed dictionary mapping :class:`ResponseHeader <.datastructures.ResponseHeader>` instances.\"\"\"",
            "    return_dto: type[AbstractDTO] | None | EmptyType",
            "    \"\"\":class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for serializing outbound response",
            "    data.",
            "    \"\"\"",
            "    tags: Sequence[str] | None",
            "    \"\"\"A sequence of string tags that will be appended to the schema of all route handlers under the controller.\"\"\"",
            "    security: Sequence[SecurityRequirement] | None",
            "    \"\"\"A sequence of dictionaries that to the schema of all route handlers under the controller.\"\"\"",
            "    signature_namespace: dict[str, Any]",
            "    \"\"\"A mapping of names to types for use in forward reference resolution during signature modeling.\"\"\"",
            "    signature_types: Sequence[Any]",
            "    \"\"\"A sequence of types for use in forward reference resolution during signature modeling.",
            "",
            "    These types will be added to the signature namespace using their ``__name__`` attribute.",
            "    \"\"\"",
            "    type_decoders: TypeDecodersSequence | None",
            "    \"\"\"A sequence of tuples, each composed of a predicate testing for type identity and a msgspec hook for deserialization.\"\"\"",
            "    type_encoders: TypeEncodersMap | None",
            "    \"\"\"A mapping of types to callables that transform them into types supported for serialization.\"\"\"",
            "    websocket_class: type[WebSocket] | None",
            "    \"\"\"A custom subclass of :class:`WebSocket <.connection.WebSocket>` to be used as the default websocket for all route",
            "    handlers under the controller.",
            "    \"\"\"",
            "",
            "    def __init__(self, owner: Router) -> None:",
            "        \"\"\"Initialize a controller.",
            "",
            "        Should only be called by routers as part of controller registration.",
            "",
            "        Args:",
            "            owner: An instance of :class:`Router <.router.Router>`",
            "        \"\"\"",
            "        # Since functions set on classes are bound, we need replace the bound instance with the class version",
            "        for key in (\"after_request\", \"after_response\", \"before_request\"):",
            "            cls_value = getattr(type(self), key, None)",
            "            if callable(cls_value):",
            "                setattr(self, key, cls_value)",
            "",
            "        if not hasattr(self, \"dto\"):",
            "            self.dto = Empty",
            "",
            "        if not hasattr(self, \"return_dto\"):",
            "            self.return_dto = Empty",
            "",
            "        if not hasattr(self, \"include_in_schema\"):",
            "            self.include_in_schema = Empty",
            "",
            "        if not hasattr(self, \"request_max_body_size\"):",
            "            self.request_max_body_size = Empty",
            "",
            "        self.signature_namespace = add_types_to_signature_namespace(",
            "            getattr(self, \"signature_types\", []), getattr(self, \"signature_namespace\", {})",
            "        )",
            "",
            "        for key in self.__slots__:",
            "            if not hasattr(self, key):",
            "                setattr(self, key, None)",
            "",
            "        self.response_cookies = narrow_response_cookies(self.response_cookies)",
            "        self.response_headers = narrow_response_headers(self.response_headers)",
            "        self.path = normalize_path(self.path or \"/\")",
            "        self.owner = owner",
            "",
            "    def as_router(self) -> Router:",
            "        from litestar.router import Router",
            "",
            "        router = Router(",
            "            path=self.path,",
            "            route_handlers=self.get_route_handlers(),",
            "            after_request=self.after_request,",
            "            after_response=self.after_response,",
            "            before_request=self.before_request,",
            "            cache_control=self.cache_control,",
            "            dependencies=self.dependencies,",
            "            dto=self.dto,",
            "            etag=self.etag,",
            "            exception_handlers=self.exception_handlers,",
            "            guards=self.guards,",
            "            include_in_schema=self.include_in_schema,",
            "            middleware=self.middleware,",
            "            opt=self.opt,",
            "            parameters=self.parameters,",
            "            request_class=self.request_class,",
            "            response_class=self.response_class,",
            "            response_cookies=self.response_cookies,",
            "            response_headers=self.response_headers,",
            "            return_dto=self.return_dto,",
            "            security=self.security,",
            "            signature_types=self.signature_types,",
            "            signature_namespace=self.signature_namespace,",
            "            tags=self.tags,",
            "            type_encoders=self.type_encoders,",
            "            type_decoders=self.type_decoders,",
            "            websocket_class=self.websocket_class,",
            "            request_max_body_size=self.request_max_body_size,",
            "        )",
            "        router.owner = self.owner",
            "        return router",
            "",
            "    def get_route_handlers(self) -> list[BaseRouteHandler]:",
            "        \"\"\"Get a controller's route handlers and set the controller as the handlers' owner.",
            "",
            "        Returns:",
            "            A list containing a copy of the route handlers defined on the controller",
            "        \"\"\"",
            "",
            "        route_handlers: list[BaseRouteHandler] = []",
            "        controller_names = set(dir(Controller))",
            "        self_handlers = [",
            "            getattr(self, name)",
            "            for name in dir(self)",
            "            if name not in controller_names and isinstance(getattr(self, name), BaseRouteHandler)",
            "        ]",
            "        self_handlers.sort(key=attrgetter(\"handler_id\"))",
            "        for self_handler in self_handlers:",
            "            route_handler = deepcopy(self_handler)",
            "            # at the point we get a reference to the handler function, it's unbound, so",
            "            # we replace it with a regular bound method here",
            "            route_handler._fn = types.MethodType(route_handler._fn, self)",
            "            route_handler.owner = self",
            "            route_handlers.append(route_handler)",
            "",
            "        self.validate_route_handlers(route_handlers=route_handlers)",
            "",
            "        return route_handlers",
            "",
            "    def validate_route_handlers(self, route_handlers: list[BaseRouteHandler]) -> None:",
            "        \"\"\"Validate that the combination of path and decorator method or type are unique on the controller.",
            "",
            "        Args:",
            "            route_handlers: The controller's route handlers.",
            "",
            "        Raises:",
            "            ImproperlyConfiguredException",
            "",
            "        Returns:",
            "            None",
            "        \"\"\"",
            "        paths: defaultdict[str, set[str]] = defaultdict(set)",
            "",
            "        for route_handler in route_handlers:",
            "            if isinstance(route_handler, HTTPRouteHandler):",
            "                methods: set[str] = cast(\"set[str]\", route_handler.http_methods)",
            "            elif isinstance(route_handler, WebsocketRouteHandler):",
            "                methods = {\"websocket\"}",
            "            else:",
            "                methods = {\"asgi\"}",
            "",
            "            for path in route_handler.paths:",
            "                if (entry := paths[path]) and (intersection := entry.intersection(methods)):",
            "                    raise ImproperlyConfiguredException(",
            "                        f\"the combination of path and method must be unique in a controller - \"",
            "                        f\"the following methods {''.join(m.lower() for m in intersection)} for {type(self).__name__} \"",
            "                        f\"controller path {path} are not unique\"",
            "                    )",
            "                paths[path].update(methods)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "litestar.controller.Controller",
            "litellm.utils.token_counter",
            "litestar.controller.Controller.self"
        ]
    },
    "litestar/exceptions/http_exceptions.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": "     HTTP_403_FORBIDDEN,"
            },
            "1": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": "     HTTP_404_NOT_FOUND,"
            },
            "2": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": "     HTTP_405_METHOD_NOT_ALLOWED,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+    HTTP_413_REQUEST_ENTITY_TOO_LARGE,"
            },
            "4": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 14,
                "PatchRowcode": "     HTTP_429_TOO_MANY_REQUESTS,"
            },
            "5": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "     HTTP_500_INTERNAL_SERVER_ERROR,"
            },
            "6": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 16,
                "PatchRowcode": "     HTTP_503_SERVICE_UNAVAILABLE,"
            },
            "7": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "     status_code = HTTP_405_METHOD_NOT_ALLOWED"
            },
            "8": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 121,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 122,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+class RequestEntityTooLarge(ClientException):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+    status_code = HTTP_413_REQUEST_ENTITY_TOO_LARGE"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+    detail = \"Request Entity Too Large\""
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 128,
                "PatchRowcode": " class TooManyRequestsException(ClientException):"
            },
            "16": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "     \"\"\"Request limits have been exceeded.\"\"\""
            },
            "17": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 130,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "from http import HTTPStatus",
            "from typing import Any",
            "",
            "from litestar.exceptions.base_exceptions import LitestarException",
            "from litestar.status_codes import (",
            "    HTTP_400_BAD_REQUEST,",
            "    HTTP_401_UNAUTHORIZED,",
            "    HTTP_403_FORBIDDEN,",
            "    HTTP_404_NOT_FOUND,",
            "    HTTP_405_METHOD_NOT_ALLOWED,",
            "    HTTP_429_TOO_MANY_REQUESTS,",
            "    HTTP_500_INTERNAL_SERVER_ERROR,",
            "    HTTP_503_SERVICE_UNAVAILABLE,",
            ")",
            "",
            "__all__ = (",
            "    \"ClientException\",",
            "    \"HTTPException\",",
            "    \"ImproperlyConfiguredException\",",
            "    \"InternalServerException\",",
            "    \"MethodNotAllowedException\",",
            "    \"NoRouteMatchFoundException\",",
            "    \"NotAuthorizedException\",",
            "    \"NotFoundException\",",
            "    \"PermissionDeniedException\",",
            "    \"ServiceUnavailableException\",",
            "    \"TemplateNotFoundException\",",
            "    \"TooManyRequestsException\",",
            "    \"ValidationException\",",
            ")",
            "",
            "",
            "class HTTPException(LitestarException):",
            "    \"\"\"Base exception for HTTP error responses.",
            "",
            "    These exceptions carry information to construct an HTTP response.",
            "    \"\"\"",
            "",
            "    status_code: int = HTTP_500_INTERNAL_SERVER_ERROR",
            "    \"\"\"Exception status code.\"\"\"",
            "    detail: str",
            "    \"\"\"Exception details or message.\"\"\"",
            "    headers: dict[str, str] | None",
            "    \"\"\"Headers to attach to the response.\"\"\"",
            "    extra: dict[str, Any] | list[Any] | None",
            "    \"\"\"An extra mapping to attach to the exception.\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        *args: Any,",
            "        detail: str = \"\",",
            "        status_code: int | None = None,",
            "        headers: dict[str, str] | None = None,",
            "        extra: dict[str, Any] | list[Any] | None = None,",
            "    ) -> None:",
            "        \"\"\"Initialize ``HTTPException``.",
            "",
            "        Set ``detail`` and ``args`` if not provided.",
            "",
            "        Args:",
            "            *args: if ``detail`` kwarg not provided, first arg should be error detail.",
            "            detail: Exception details or message. Will default to args[0] if not provided.",
            "            status_code: Exception HTTP status code.",
            "            headers: Headers to set on the response.",
            "            extra: An extra mapping to attach to the exception.",
            "        \"\"\"",
            "        super().__init__(*args, detail=detail)",
            "        self.status_code = status_code or self.status_code",
            "        self.extra = extra",
            "        self.headers = headers",
            "        if not self.detail:",
            "            self.detail = HTTPStatus(self.status_code).phrase",
            "        self.args = (f\"{self.status_code}: {self.detail}\", *self.args)",
            "",
            "    def __repr__(self) -> str:",
            "        return f\"{self.status_code} - {self.__class__.__name__} - {self.detail}\"",
            "",
            "    def __str__(self) -> str:",
            "        return \" \".join(self.args).strip()",
            "",
            "",
            "class ImproperlyConfiguredException(HTTPException, ValueError):",
            "    \"\"\"Application has improper configuration.\"\"\"",
            "",
            "",
            "class ClientException(HTTPException):",
            "    \"\"\"Client error.\"\"\"",
            "",
            "    status_code: int = HTTP_400_BAD_REQUEST",
            "",
            "",
            "class ValidationException(ClientException, ValueError):",
            "    \"\"\"Client data validation error.\"\"\"",
            "",
            "",
            "class NotAuthorizedException(ClientException):",
            "    \"\"\"Request lacks valid authentication credentials for the requested resource.\"\"\"",
            "",
            "    status_code = HTTP_401_UNAUTHORIZED",
            "",
            "",
            "class PermissionDeniedException(ClientException):",
            "    \"\"\"Request understood, but not authorized.\"\"\"",
            "",
            "    status_code = HTTP_403_FORBIDDEN",
            "",
            "",
            "class NotFoundException(ClientException, ValueError):",
            "    \"\"\"Cannot find the requested resource.\"\"\"",
            "",
            "    status_code = HTTP_404_NOT_FOUND",
            "",
            "",
            "class MethodNotAllowedException(ClientException):",
            "    \"\"\"Server knows the request method, but the target resource doesn't support this method.\"\"\"",
            "",
            "    status_code = HTTP_405_METHOD_NOT_ALLOWED",
            "",
            "",
            "class TooManyRequestsException(ClientException):",
            "    \"\"\"Request limits have been exceeded.\"\"\"",
            "",
            "    status_code = HTTP_429_TOO_MANY_REQUESTS",
            "",
            "",
            "class InternalServerException(HTTPException):",
            "    \"\"\"Server encountered an unexpected condition that prevented it from fulfilling the request.\"\"\"",
            "",
            "    status_code: int = HTTP_500_INTERNAL_SERVER_ERROR",
            "",
            "",
            "class ServiceUnavailableException(InternalServerException):",
            "    \"\"\"Server is not ready to handle the request.\"\"\"",
            "",
            "    status_code = HTTP_503_SERVICE_UNAVAILABLE",
            "",
            "",
            "class NoRouteMatchFoundException(InternalServerException):",
            "    \"\"\"A route with the given name could not be found.\"\"\"",
            "",
            "",
            "class TemplateNotFoundException(InternalServerException):",
            "    \"\"\"Referenced template could not be found.\"\"\"",
            "",
            "    def __init__(self, *args: Any, template_name: str) -> None:",
            "        \"\"\"Initialize ``TemplateNotFoundException``.",
            "",
            "        Args:",
            "            *args (Any): Passed through to ``super().__init__()`` - should not include ``detail``.",
            "            template_name (str): Name of template that could not be found.",
            "        \"\"\"",
            "        super().__init__(*args, detail=f\"Template {template_name} not found.\")"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "from http import HTTPStatus",
            "from typing import Any",
            "",
            "from litestar.exceptions.base_exceptions import LitestarException",
            "from litestar.status_codes import (",
            "    HTTP_400_BAD_REQUEST,",
            "    HTTP_401_UNAUTHORIZED,",
            "    HTTP_403_FORBIDDEN,",
            "    HTTP_404_NOT_FOUND,",
            "    HTTP_405_METHOD_NOT_ALLOWED,",
            "    HTTP_413_REQUEST_ENTITY_TOO_LARGE,",
            "    HTTP_429_TOO_MANY_REQUESTS,",
            "    HTTP_500_INTERNAL_SERVER_ERROR,",
            "    HTTP_503_SERVICE_UNAVAILABLE,",
            ")",
            "",
            "__all__ = (",
            "    \"ClientException\",",
            "    \"HTTPException\",",
            "    \"ImproperlyConfiguredException\",",
            "    \"InternalServerException\",",
            "    \"MethodNotAllowedException\",",
            "    \"NoRouteMatchFoundException\",",
            "    \"NotAuthorizedException\",",
            "    \"NotFoundException\",",
            "    \"PermissionDeniedException\",",
            "    \"ServiceUnavailableException\",",
            "    \"TemplateNotFoundException\",",
            "    \"TooManyRequestsException\",",
            "    \"ValidationException\",",
            ")",
            "",
            "",
            "class HTTPException(LitestarException):",
            "    \"\"\"Base exception for HTTP error responses.",
            "",
            "    These exceptions carry information to construct an HTTP response.",
            "    \"\"\"",
            "",
            "    status_code: int = HTTP_500_INTERNAL_SERVER_ERROR",
            "    \"\"\"Exception status code.\"\"\"",
            "    detail: str",
            "    \"\"\"Exception details or message.\"\"\"",
            "    headers: dict[str, str] | None",
            "    \"\"\"Headers to attach to the response.\"\"\"",
            "    extra: dict[str, Any] | list[Any] | None",
            "    \"\"\"An extra mapping to attach to the exception.\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        *args: Any,",
            "        detail: str = \"\",",
            "        status_code: int | None = None,",
            "        headers: dict[str, str] | None = None,",
            "        extra: dict[str, Any] | list[Any] | None = None,",
            "    ) -> None:",
            "        \"\"\"Initialize ``HTTPException``.",
            "",
            "        Set ``detail`` and ``args`` if not provided.",
            "",
            "        Args:",
            "            *args: if ``detail`` kwarg not provided, first arg should be error detail.",
            "            detail: Exception details or message. Will default to args[0] if not provided.",
            "            status_code: Exception HTTP status code.",
            "            headers: Headers to set on the response.",
            "            extra: An extra mapping to attach to the exception.",
            "        \"\"\"",
            "        super().__init__(*args, detail=detail)",
            "        self.status_code = status_code or self.status_code",
            "        self.extra = extra",
            "        self.headers = headers",
            "        if not self.detail:",
            "            self.detail = HTTPStatus(self.status_code).phrase",
            "        self.args = (f\"{self.status_code}: {self.detail}\", *self.args)",
            "",
            "    def __repr__(self) -> str:",
            "        return f\"{self.status_code} - {self.__class__.__name__} - {self.detail}\"",
            "",
            "    def __str__(self) -> str:",
            "        return \" \".join(self.args).strip()",
            "",
            "",
            "class ImproperlyConfiguredException(HTTPException, ValueError):",
            "    \"\"\"Application has improper configuration.\"\"\"",
            "",
            "",
            "class ClientException(HTTPException):",
            "    \"\"\"Client error.\"\"\"",
            "",
            "    status_code: int = HTTP_400_BAD_REQUEST",
            "",
            "",
            "class ValidationException(ClientException, ValueError):",
            "    \"\"\"Client data validation error.\"\"\"",
            "",
            "",
            "class NotAuthorizedException(ClientException):",
            "    \"\"\"Request lacks valid authentication credentials for the requested resource.\"\"\"",
            "",
            "    status_code = HTTP_401_UNAUTHORIZED",
            "",
            "",
            "class PermissionDeniedException(ClientException):",
            "    \"\"\"Request understood, but not authorized.\"\"\"",
            "",
            "    status_code = HTTP_403_FORBIDDEN",
            "",
            "",
            "class NotFoundException(ClientException, ValueError):",
            "    \"\"\"Cannot find the requested resource.\"\"\"",
            "",
            "    status_code = HTTP_404_NOT_FOUND",
            "",
            "",
            "class MethodNotAllowedException(ClientException):",
            "    \"\"\"Server knows the request method, but the target resource doesn't support this method.\"\"\"",
            "",
            "    status_code = HTTP_405_METHOD_NOT_ALLOWED",
            "",
            "",
            "class RequestEntityTooLarge(ClientException):",
            "    status_code = HTTP_413_REQUEST_ENTITY_TOO_LARGE",
            "    detail = \"Request Entity Too Large\"",
            "",
            "",
            "class TooManyRequestsException(ClientException):",
            "    \"\"\"Request limits have been exceeded.\"\"\"",
            "",
            "    status_code = HTTP_429_TOO_MANY_REQUESTS",
            "",
            "",
            "class InternalServerException(HTTPException):",
            "    \"\"\"Server encountered an unexpected condition that prevented it from fulfilling the request.\"\"\"",
            "",
            "    status_code: int = HTTP_500_INTERNAL_SERVER_ERROR",
            "",
            "",
            "class ServiceUnavailableException(InternalServerException):",
            "    \"\"\"Server is not ready to handle the request.\"\"\"",
            "",
            "    status_code = HTTP_503_SERVICE_UNAVAILABLE",
            "",
            "",
            "class NoRouteMatchFoundException(InternalServerException):",
            "    \"\"\"A route with the given name could not be found.\"\"\"",
            "",
            "",
            "class TemplateNotFoundException(InternalServerException):",
            "    \"\"\"Referenced template could not be found.\"\"\"",
            "",
            "    def __init__(self, *args: Any, template_name: str) -> None:",
            "        \"\"\"Initialize ``TemplateNotFoundException``.",
            "",
            "        Args:",
            "            *args (Any): Passed through to ``super().__init__()`` - should not include ``detail``.",
            "            template_name (str): Name of template that could not be found.",
            "        \"\"\"",
            "        super().__init__(*args, detail=f\"Template {template_name} not found.\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "litestar/handlers/http_handlers/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "         \"_resolved_request_class\","
            },
            "1": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "         \"_resolved_tags\","
            },
            "2": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         \"_resolved_security\","
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+        \"_resolved_request_max_body_size\","
            },
            "4": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "         \"after_request\","
            },
            "5": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "         \"after_response\","
            },
            "6": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "         \"background\","
            },
            "7": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 114,
                "PatchRowcode": "         \"sync_to_thread\","
            },
            "8": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "         \"tags\","
            },
            "9": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "         \"template_name\","
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+        \"request_max_body_size\","
            },
            "11": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "     )"
            },
            "12": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 119,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "     has_sync_callable: bool"
            },
            "14": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "         name: str | None = None,"
            },
            "15": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "         opt: Mapping[str, Any] | None = None,"
            },
            "16": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "         request_class: type[Request] | None = None,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+        request_max_body_size: int | None | EmptyType = Empty,"
            },
            "18": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "         response_class: type[Response] | None = None,"
            },
            "19": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "         response_cookies: ResponseCookies | None = None,"
            },
            "20": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "         response_headers: ResponseHeaders | None = None,"
            },
            "21": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 207,
                "PatchRowcode": "                 :class:`ASGI Scope <.types.Scope>`."
            },
            "22": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": 208,
                "PatchRowcode": "             request_class: A custom subclass of :class:`Request <.connection.Request>` to be used as route handler's"
            },
            "23": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 209,
                "PatchRowcode": "                 default request."
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+            request_max_body_size: Maximum allowed size of the request body in bytes. If this size is exceeded,"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 211,
                "PatchRowcode": "+                a '413 - Request Entity Too Large' error response is returned."
            },
            "26": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 212,
                "PatchRowcode": "             response_class: A custom subclass of :class:`Response <.response.Response>` to be used as route handler's"
            },
            "27": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": 213,
                "PatchRowcode": "                 default response."
            },
            "28": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 214,
                "PatchRowcode": "             response_cookies: A sequence of :class:`Cookie <.datastructures.Cookie>` instances."
            },
            "29": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": 277,
                "PatchRowcode": "         self.response_class = response_class"
            },
            "30": {
                "beforePatchRowNumber": 273,
                "afterPatchRowNumber": 278,
                "PatchRowcode": "         self.response_cookies: Sequence[Cookie] | None = narrow_response_cookies(response_cookies)"
            },
            "31": {
                "beforePatchRowNumber": 274,
                "afterPatchRowNumber": 279,
                "PatchRowcode": "         self.response_headers: Sequence[ResponseHeader] | None = narrow_response_headers(response_headers)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 280,
                "PatchRowcode": "+        self.request_max_body_size = request_max_body_size"
            },
            "33": {
                "beforePatchRowNumber": 275,
                "afterPatchRowNumber": 281,
                "PatchRowcode": " "
            },
            "34": {
                "beforePatchRowNumber": 276,
                "afterPatchRowNumber": 282,
                "PatchRowcode": "         self.sync_to_thread = sync_to_thread"
            },
            "35": {
                "beforePatchRowNumber": 277,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "         # OpenAPI related attributes"
            },
            "36": {
                "beforePatchRowNumber": 297,
                "afterPatchRowNumber": 303,
                "PatchRowcode": "         self._resolved_request_class: type[Request] | EmptyType = Empty"
            },
            "37": {
                "beforePatchRowNumber": 298,
                "afterPatchRowNumber": 304,
                "PatchRowcode": "         self._resolved_security: list[SecurityRequirement] | EmptyType = Empty"
            },
            "38": {
                "beforePatchRowNumber": 299,
                "afterPatchRowNumber": 305,
                "PatchRowcode": "         self._resolved_tags: list[str] | EmptyType = Empty"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 306,
                "PatchRowcode": "+        self._resolved_request_max_body_size: int | EmptyType | None = Empty"
            },
            "40": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": 307,
                "PatchRowcode": " "
            },
            "41": {
                "beforePatchRowNumber": 301,
                "afterPatchRowNumber": 308,
                "PatchRowcode": "     def __call__(self, fn: AnyCallable) -> HTTPRouteHandler:"
            },
            "42": {
                "beforePatchRowNumber": 302,
                "afterPatchRowNumber": 309,
                "PatchRowcode": "         \"\"\"Replace a function with itself.\"\"\""
            },
            "43": {
                "beforePatchRowNumber": 473,
                "afterPatchRowNumber": 480,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": 474,
                "afterPatchRowNumber": 481,
                "PatchRowcode": "         return self._resolved_tags"
            },
            "45": {
                "beforePatchRowNumber": 475,
                "afterPatchRowNumber": 482,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 483,
                "PatchRowcode": "+    def resolve_request_max_body_size(self) -> int | None:"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 484,
                "PatchRowcode": "+        if (resolved_limits := self._resolved_request_max_body_size) is not Empty:"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 485,
                "PatchRowcode": "+            return resolved_limits"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 486,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 487,
                "PatchRowcode": "+        max_body_size = self._resolved_request_max_body_size = next(  # pyright: ignore"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 488,
                "PatchRowcode": "+            ("
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 489,
                "PatchRowcode": "+                max_body_size"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 490,
                "PatchRowcode": "+                for layer in reversed(self.ownership_layers)"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 491,
                "PatchRowcode": "+                if (max_body_size := layer.request_max_body_size) is not Empty"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 492,
                "PatchRowcode": "+            ),"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 493,
                "PatchRowcode": "+            Empty,"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 494,
                "PatchRowcode": "+        )"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 495,
                "PatchRowcode": "+        if max_body_size is Empty:"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 496,
                "PatchRowcode": "+            raise ImproperlyConfiguredException("
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 497,
                "PatchRowcode": "+                \"'request_max_body_size' set to 'Empty' on all layers. To omit a limit, \""
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 498,
                "PatchRowcode": "+                \"set 'request_max_body_size=None'\""
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 499,
                "PatchRowcode": "+            )"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 500,
                "PatchRowcode": "+        return max_body_size"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 501,
                "PatchRowcode": "+"
            },
            "65": {
                "beforePatchRowNumber": 476,
                "afterPatchRowNumber": 502,
                "PatchRowcode": "     def get_response_handler(self, is_response_type_data: bool = False) -> Callable[[Any], Awaitable[ASGIApp]]:"
            },
            "66": {
                "beforePatchRowNumber": 477,
                "afterPatchRowNumber": 503,
                "PatchRowcode": "         \"\"\"Resolve the response_handler function for the route handler."
            },
            "67": {
                "beforePatchRowNumber": 478,
                "afterPatchRowNumber": 504,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "from enum import Enum",
            "from typing import TYPE_CHECKING, AnyStr, Mapping, Sequence, TypedDict, cast",
            "",
            "from litestar._layers.utils import narrow_response_cookies, narrow_response_headers",
            "from litestar.connection import Request",
            "from litestar.datastructures.cookie import Cookie",
            "from litestar.datastructures.response_header import ResponseHeader",
            "from litestar.enums import HttpMethod, MediaType",
            "from litestar.exceptions import (",
            "    HTTPException,",
            "    ImproperlyConfiguredException,",
            ")",
            "from litestar.handlers.base import BaseRouteHandler",
            "from litestar.handlers.http_handlers._utils import (",
            "    create_data_handler,",
            "    create_generic_asgi_response_handler,",
            "    create_response_handler,",
            "    get_default_status_code,",
            "    is_empty_response_annotation,",
            "    normalize_http_method,",
            ")",
            "from litestar.openapi.spec import Operation",
            "from litestar.response import Response",
            "from litestar.status_codes import HTTP_204_NO_CONTENT, HTTP_304_NOT_MODIFIED",
            "from litestar.types import (",
            "    AfterRequestHookHandler,",
            "    AfterResponseHookHandler,",
            "    AnyCallable,",
            "    ASGIApp,",
            "    BeforeRequestHookHandler,",
            "    CacheKeyBuilder,",
            "    Dependencies,",
            "    Empty,",
            "    EmptyType,",
            "    ExceptionHandlersMap,",
            "    Guard,",
            "    Method,",
            "    Middleware,",
            "    ResponseCookies,",
            "    ResponseHeaders,",
            "    TypeEncodersMap,",
            ")",
            "from litestar.utils import ensure_async_callable",
            "from litestar.utils.predicates import is_async_callable",
            "from litestar.utils.warnings import warn_implicit_sync_to_thread, warn_sync_to_thread_with_async_callable",
            "",
            "if TYPE_CHECKING:",
            "    from typing import Any, Awaitable, Callable",
            "",
            "    from litestar.app import Litestar",
            "    from litestar.background_tasks import BackgroundTask, BackgroundTasks",
            "    from litestar.config.response_cache import CACHE_FOREVER",
            "    from litestar.datastructures import CacheControlHeader, ETag",
            "    from litestar.dto import AbstractDTO",
            "    from litestar.openapi.datastructures import ResponseSpec",
            "    from litestar.openapi.spec import SecurityRequirement",
            "    from litestar.types.callable_types import AsyncAnyCallable, OperationIDCreator",
            "    from litestar.types.composite_types import TypeDecodersSequence",
            "",
            "__all__ = (\"HTTPRouteHandler\", \"route\")",
            "",
            "",
            "class ResponseHandlerMap(TypedDict):",
            "    default_handler: Callable[[Any], Awaitable[ASGIApp]] | EmptyType",
            "    response_type_handler: Callable[[Any], Awaitable[ASGIApp]] | EmptyType",
            "",
            "",
            "class HTTPRouteHandler(BaseRouteHandler):",
            "    \"\"\"HTTP Route Decorator.",
            "",
            "    Use this decorator to decorate an HTTP handler with multiple methods.",
            "    \"\"\"",
            "",
            "    __slots__ = (",
            "        \"_resolved_after_response\",",
            "        \"_resolved_before_request\",",
            "        \"_response_handler_mapping\",",
            "        \"_resolved_include_in_schema\",",
            "        \"_resolved_response_class\",",
            "        \"_resolved_request_class\",",
            "        \"_resolved_tags\",",
            "        \"_resolved_security\",",
            "        \"after_request\",",
            "        \"after_response\",",
            "        \"background\",",
            "        \"before_request\",",
            "        \"cache\",",
            "        \"cache_control\",",
            "        \"cache_key_builder\",",
            "        \"content_encoding\",",
            "        \"content_media_type\",",
            "        \"deprecated\",",
            "        \"description\",",
            "        \"etag\",",
            "        \"has_sync_callable\",",
            "        \"http_methods\",",
            "        \"include_in_schema\",",
            "        \"media_type\",",
            "        \"operation_class\",",
            "        \"operation_id\",",
            "        \"raises\",",
            "        \"request_class\",",
            "        \"response_class\",",
            "        \"response_cookies\",",
            "        \"response_description\",",
            "        \"response_headers\",",
            "        \"responses\",",
            "        \"security\",",
            "        \"status_code\",",
            "        \"summary\",",
            "        \"sync_to_thread\",",
            "        \"tags\",",
            "        \"template_name\",",
            "    )",
            "",
            "    has_sync_callable: bool",
            "",
            "    def __init__(",
            "        self,",
            "        path: str | Sequence[str] | None = None,",
            "        *,",
            "        after_request: AfterRequestHookHandler | None = None,",
            "        after_response: AfterResponseHookHandler | None = None,",
            "        background: BackgroundTask | BackgroundTasks | None = None,",
            "        before_request: BeforeRequestHookHandler | None = None,",
            "        cache: bool | int | type[CACHE_FOREVER] = False,",
            "        cache_control: CacheControlHeader | None = None,",
            "        cache_key_builder: CacheKeyBuilder | None = None,",
            "        dependencies: Dependencies | None = None,",
            "        dto: type[AbstractDTO] | None | EmptyType = Empty,",
            "        etag: ETag | None = None,",
            "        exception_handlers: ExceptionHandlersMap | None = None,",
            "        guards: Sequence[Guard] | None = None,",
            "        http_method: HttpMethod | Method | Sequence[HttpMethod | Method],",
            "        media_type: MediaType | str | None = None,",
            "        middleware: Sequence[Middleware] | None = None,",
            "        name: str | None = None,",
            "        opt: Mapping[str, Any] | None = None,",
            "        request_class: type[Request] | None = None,",
            "        response_class: type[Response] | None = None,",
            "        response_cookies: ResponseCookies | None = None,",
            "        response_headers: ResponseHeaders | None = None,",
            "        return_dto: type[AbstractDTO] | None | EmptyType = Empty,",
            "        status_code: int | None = None,",
            "        sync_to_thread: bool | None = None,",
            "        # OpenAPI related attributes",
            "        content_encoding: str | None = None,",
            "        content_media_type: str | None = None,",
            "        deprecated: bool = False,",
            "        description: str | None = None,",
            "        include_in_schema: bool | EmptyType = Empty,",
            "        operation_class: type[Operation] = Operation,",
            "        operation_id: str | OperationIDCreator | None = None,",
            "        raises: Sequence[type[HTTPException]] | None = None,",
            "        response_description: str | None = None,",
            "        responses: Mapping[int, ResponseSpec] | None = None,",
            "        signature_namespace: Mapping[str, Any] | None = None,",
            "        security: Sequence[SecurityRequirement] | None = None,",
            "        summary: str | None = None,",
            "        tags: Sequence[str] | None = None,",
            "        type_decoders: TypeDecodersSequence | None = None,",
            "        type_encoders: TypeEncodersMap | None = None,",
            "        **kwargs: Any,",
            "    ) -> None:",
            "        \"\"\"Initialize ``HTTPRouteHandler``.",
            "",
            "        Args:",
            "            path: A path fragment for the route handler function or a sequence of path fragments.",
            "                If not given defaults to ``/``",
            "            after_request: A sync or async function executed before a :class:`Request <.connection.Request>` is passed",
            "                to any route handler. If this function returns a value, the request will not reach the route handler,",
            "                and instead this value will be used.",
            "            after_response: A sync or async function called after the response has been awaited. It receives the",
            "                :class:`Request <.connection.Request>` object and should not return any values.",
            "            background: A :class:`BackgroundTask <.background_tasks.BackgroundTask>` instance or",
            "                :class:`BackgroundTasks <.background_tasks.BackgroundTasks>` to execute after the response is finished.",
            "                Defaults to ``None``.",
            "            before_request: A sync or async function called immediately before calling the route handler. Receives",
            "                the :class:`Request <.connection.Request>` instance and any non-``None`` return value is used for the",
            "                response, bypassing the route handler.",
            "            cache: Enables response caching if configured on the application level. Valid values are ``True`` or a",
            "                number of seconds (e.g. ``120``) to cache the response.",
            "            cache_control: A ``cache-control`` header of type",
            "                :class:`CacheControlHeader <.datastructures.CacheControlHeader>` that will be added to the response.",
            "            cache_key_builder: A :class:`cache-key builder function <.types.CacheKeyBuilder>`. Allows for customization",
            "                of the cache key if caching is configured on the application level.",
            "            dependencies: A string keyed mapping of dependency :class:`Provider <.di.Provide>` instances.",
            "            dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for (de)serializing and",
            "                validation of request data.",
            "            etag: An ``etag`` header of type :class:`ETag <.datastructures.ETag>` that will be added to the response.",
            "            exception_handlers: A mapping of status codes and/or exception types to handler functions.",
            "            guards: A sequence of :class:`Guard <.types.Guard>` callables.",
            "            http_method: An :class:`http method string <.types.Method>`, a member of the enum",
            "                :class:`HttpMethod <.enums.HttpMethod>` or a list of these that correlates to the methods the route",
            "                handler function should handle.",
            "            media_type: A member of the :class:`MediaType <.enums.MediaType>` enum or a string with a valid IANA",
            "                Media-Type.",
            "            middleware: A sequence of :class:`Middleware <.types.Middleware>`.",
            "            name: A string identifying the route handler.",
            "            opt: A string keyed mapping of arbitrary values that can be accessed in :class:`Guards <.types.Guard>` or",
            "                wherever you have access to :class:`Request <.connection.Request>` or",
            "                :class:`ASGI Scope <.types.Scope>`.",
            "            request_class: A custom subclass of :class:`Request <.connection.Request>` to be used as route handler's",
            "                default request.",
            "            response_class: A custom subclass of :class:`Response <.response.Response>` to be used as route handler's",
            "                default response.",
            "            response_cookies: A sequence of :class:`Cookie <.datastructures.Cookie>` instances.",
            "            response_headers: A string keyed mapping of :class:`ResponseHeader <.datastructures.ResponseHeader>`",
            "                instances.",
            "            responses: A mapping of additional status codes and a description of their expected content.",
            "                This information will be included in the OpenAPI schema",
            "            return_dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for serializing",
            "                outbound response data.",
            "            signature_namespace: A mapping of names to types for use in forward reference resolution during signature modelling.",
            "            status_code: An http status code for the response. Defaults to ``200`` for ``GET``, ``PUT`` and ``PATCH``,",
            "                ``201`` for ``POST`` and ``204`` for ``DELETE``. For mixed method requests it will check for ``POST`` and ``DELETE`` first",
            "                then defaults to ``200``.",
            "            sync_to_thread: A boolean dictating whether the handler function will be executed in a worker thread or the",
            "                main event loop. This has an effect only for sync handler functions. See using sync handler functions.",
            "            content_encoding: A string describing the encoding of the content, e.g. ``\"base64\"``.",
            "            content_media_type: A string designating the media-type of the content, e.g. ``\"image/png\"``.",
            "            deprecated:  A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema.",
            "            description: Text used for the route's schema description section.",
            "            include_in_schema: A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.",
            "            operation_class: :class:`Operation <.openapi.spec.operation.Operation>` to be used with the route's OpenAPI schema.",
            "            operation_id: Either a string or a callable returning a string. An identifier used for the route's schema operationId.",
            "            raises:  A list of exception classes extending from litestar.HttpException that is used for the OpenAPI documentation.",
            "                This list should describe all exceptions raised within the route handler's function/method. The Litestar",
            "                ValidationException will be added automatically for the schema if any validation is involved.",
            "            response_description: Text used for the route's response schema description section.",
            "            security: A sequence of dictionaries that contain information about which security scheme can be used on the endpoint.",
            "            summary: Text used for the route's schema summary section.",
            "            tags: A sequence of string tags that will be appended to the OpenAPI schema.",
            "            type_decoders: A sequence of tuples, each composed of a predicate testing for type identity and a msgspec hook for deserialization.",
            "            type_encoders: A mapping of types to callables that transform them into types supported for serialization.",
            "            **kwargs: Any additional kwarg - will be set in the opt dictionary.",
            "        \"\"\"",
            "        if not http_method:",
            "            raise ImproperlyConfiguredException(\"An http_method kwarg is required\")",
            "",
            "        self.http_methods = normalize_http_method(http_methods=http_method)",
            "        self.status_code = status_code or get_default_status_code(http_methods=self.http_methods)",
            "",
            "        super().__init__(",
            "            path=path,",
            "            dependencies=dependencies,",
            "            dto=dto,",
            "            exception_handlers=exception_handlers,",
            "            guards=guards,",
            "            middleware=middleware,",
            "            name=name,",
            "            opt=opt,",
            "            return_dto=return_dto,",
            "            signature_namespace=signature_namespace,",
            "            type_decoders=type_decoders,",
            "            type_encoders=type_encoders,",
            "            **kwargs,",
            "        )",
            "",
            "        self.after_request = ensure_async_callable(after_request) if after_request else None  # pyright: ignore",
            "        self.after_response = ensure_async_callable(after_response) if after_response else None",
            "        self.background = background",
            "        self.before_request = ensure_async_callable(before_request) if before_request else None",
            "        self.cache = cache",
            "        self.cache_control = cache_control",
            "        self.cache_key_builder = cache_key_builder",
            "        self.etag = etag",
            "        self.media_type: MediaType | str = media_type or \"\"",
            "        self.request_class = request_class",
            "        self.response_class = response_class",
            "        self.response_cookies: Sequence[Cookie] | None = narrow_response_cookies(response_cookies)",
            "        self.response_headers: Sequence[ResponseHeader] | None = narrow_response_headers(response_headers)",
            "",
            "        self.sync_to_thread = sync_to_thread",
            "        # OpenAPI related attributes",
            "        self.content_encoding = content_encoding",
            "        self.content_media_type = content_media_type",
            "        self.deprecated = deprecated",
            "        self.description = description",
            "        self.include_in_schema = include_in_schema",
            "        self.operation_class = operation_class",
            "        self.operation_id = operation_id",
            "        self.raises = raises",
            "        self.response_description = response_description",
            "        self.summary = summary",
            "        self.tags = tags",
            "        self.security = security",
            "        self.responses = responses",
            "        # memoized attributes, defaulted to Empty",
            "        self._resolved_after_response: AsyncAnyCallable | None | EmptyType = Empty",
            "        self._resolved_before_request: AsyncAnyCallable | None | EmptyType = Empty",
            "        self._response_handler_mapping: ResponseHandlerMap = {\"default_handler\": Empty, \"response_type_handler\": Empty}",
            "        self._resolved_include_in_schema: bool | EmptyType = Empty",
            "        self._resolved_response_class: type[Response] | EmptyType = Empty",
            "        self._resolved_request_class: type[Request] | EmptyType = Empty",
            "        self._resolved_security: list[SecurityRequirement] | EmptyType = Empty",
            "        self._resolved_tags: list[str] | EmptyType = Empty",
            "",
            "    def __call__(self, fn: AnyCallable) -> HTTPRouteHandler:",
            "        \"\"\"Replace a function with itself.\"\"\"",
            "        if not is_async_callable(fn):",
            "            if self.sync_to_thread is None:",
            "                warn_implicit_sync_to_thread(fn, stacklevel=3)",
            "        elif self.sync_to_thread is not None:",
            "            warn_sync_to_thread_with_async_callable(fn, stacklevel=3)",
            "",
            "        super().__call__(fn)",
            "        return self",
            "",
            "    def resolve_request_class(self) -> type[Request]:",
            "        \"\"\"Return the closest custom Request class in the owner graph or the default Request class.",
            "",
            "        This method is memoized so the computation occurs only once.",
            "",
            "        Returns:",
            "            The default :class:`Request <.connection.Request>` class for the route handler.",
            "        \"\"\"",
            "",
            "        if self._resolved_request_class is Empty:",
            "            self._resolved_request_class = next(",
            "                (layer.request_class for layer in reversed(self.ownership_layers) if layer.request_class is not None),",
            "                Request,",
            "            )",
            "",
            "        return cast(\"type[Request]\", self._resolved_request_class)",
            "",
            "    def resolve_response_class(self) -> type[Response]:",
            "        \"\"\"Return the closest custom Response class in the owner graph or the default Response class.",
            "",
            "        This method is memoized so the computation occurs only once.",
            "",
            "        Returns:",
            "            The default :class:`Response <.response.Response>` class for the route handler.",
            "        \"\"\"",
            "        if self._resolved_response_class is Empty:",
            "            self._resolved_response_class = next(",
            "                (layer.response_class for layer in reversed(self.ownership_layers) if layer.response_class is not None),",
            "                Response,",
            "            )",
            "",
            "        return cast(\"type[Response]\", self._resolved_response_class)",
            "",
            "    def resolve_response_headers(self) -> frozenset[ResponseHeader]:",
            "        \"\"\"Return all header parameters in the scope of the handler function.",
            "",
            "        Returns:",
            "            A dictionary mapping keys to :class:`ResponseHeader <.datastructures.ResponseHeader>` instances.",
            "        \"\"\"",
            "        resolved_response_headers: dict[str, ResponseHeader] = {}",
            "",
            "        for layer in self.ownership_layers:",
            "            if layer_response_headers := layer.response_headers:",
            "                if isinstance(layer_response_headers, Mapping):",
            "                    # this can't happen unless you manually set response_headers on an instance, which would result in a",
            "                    # type-checking error on everything but the controller. We cover this case nevertheless",
            "                    resolved_response_headers.update(",
            "                        {name: ResponseHeader(name=name, value=value) for name, value in layer_response_headers.items()}",
            "                    )",
            "                else:",
            "                    resolved_response_headers.update({h.name: h for h in layer_response_headers})",
            "            for extra_header in (\"cache_control\", \"etag\"):",
            "                if header_model := getattr(layer, extra_header, None):",
            "                    resolved_response_headers[header_model.HEADER_NAME] = ResponseHeader(",
            "                        name=header_model.HEADER_NAME,",
            "                        value=header_model.to_header(),",
            "                        documentation_only=header_model.documentation_only,",
            "                    )",
            "",
            "        return frozenset(resolved_response_headers.values())",
            "",
            "    def resolve_response_cookies(self) -> frozenset[Cookie]:",
            "        \"\"\"Return a list of Cookie instances. Filters the list to ensure each cookie key is unique.",
            "",
            "        Returns:",
            "            A list of :class:`Cookie <.datastructures.Cookie>` instances.",
            "        \"\"\"",
            "        response_cookies: set[Cookie] = set()",
            "        for layer in reversed(self.ownership_layers):",
            "            if layer_response_cookies := layer.response_cookies:",
            "                if isinstance(layer_response_cookies, Mapping):",
            "                    # this can't happen unless you manually set response_cookies on an instance, which would result in a",
            "                    # type-checking error on everything but the controller. We cover this case nevertheless",
            "                    response_cookies.update(",
            "                        {Cookie(key=key, value=value) for key, value in layer_response_cookies.items()}",
            "                    )",
            "                else:",
            "                    response_cookies.update(cast(\"set[Cookie]\", layer_response_cookies))",
            "        return frozenset(response_cookies)",
            "",
            "    def resolve_before_request(self) -> AsyncAnyCallable | None:",
            "        \"\"\"Resolve the before_handler handler by starting from the route handler and moving up.",
            "",
            "        If a handler is found it is returned, otherwise None is set.",
            "        This method is memoized so the computation occurs only once.",
            "",
            "        Returns:",
            "            An optional :class:`before request lifecycle hook handler <.types.BeforeRequestHookHandler>`",
            "        \"\"\"",
            "        if self._resolved_before_request is Empty:",
            "            before_request_handlers = [layer.before_request for layer in self.ownership_layers if layer.before_request]",
            "            self._resolved_before_request = before_request_handlers[-1] if before_request_handlers else None",
            "        return cast(\"AsyncAnyCallable | None\", self._resolved_before_request)",
            "",
            "    def resolve_after_response(self) -> AsyncAnyCallable | None:",
            "        \"\"\"Resolve the after_response handler by starting from the route handler and moving up.",
            "",
            "        If a handler is found it is returned, otherwise None is set.",
            "        This method is memoized so the computation occurs only once.",
            "",
            "        Returns:",
            "            An optional :class:`after response lifecycle hook handler <.types.AfterResponseHookHandler>`",
            "        \"\"\"",
            "        if self._resolved_after_response is Empty:",
            "            after_response_handlers: list[AsyncAnyCallable] = [",
            "                layer.after_response  # type: ignore[misc]",
            "                for layer in self.ownership_layers",
            "                if layer.after_response",
            "            ]",
            "            self._resolved_after_response = after_response_handlers[-1] if after_response_handlers else None",
            "",
            "        return cast(\"AsyncAnyCallable | None\", self._resolved_after_response)",
            "",
            "    def resolve_include_in_schema(self) -> bool:",
            "        \"\"\"Resolve the 'include_in_schema' property by starting from the route handler and moving up.",
            "",
            "        If 'include_in_schema' is found in any of the ownership layers, the last value found is returned.",
            "        If not found in any layer, the default value ``True`` is returned.",
            "",
            "        Returns:",
            "            bool: The resolved 'include_in_schema' property.",
            "        \"\"\"",
            "        if self._resolved_include_in_schema is Empty:",
            "            include_in_schemas = [",
            "                i.include_in_schema for i in self.ownership_layers if isinstance(i.include_in_schema, bool)",
            "            ]",
            "            self._resolved_include_in_schema = include_in_schemas[-1] if include_in_schemas else True",
            "",
            "        return self._resolved_include_in_schema",
            "",
            "    def resolve_security(self) -> list[SecurityRequirement]:",
            "        \"\"\"Resolve the security property by starting from the route handler and moving up.",
            "",
            "        Security requirements are additive, so the security requirements of the route handler are the sum of all",
            "        security requirements of the ownership layers.",
            "",
            "        Returns:",
            "            list[SecurityRequirement]: The resolved security property.",
            "        \"\"\"",
            "        if self._resolved_security is Empty:",
            "            self._resolved_security = []",
            "            for layer in self.ownership_layers:",
            "                if isinstance(layer.security, Sequence):",
            "                    self._resolved_security.extend(layer.security)",
            "",
            "        return self._resolved_security",
            "",
            "    def resolve_tags(self) -> list[str]:",
            "        \"\"\"Resolve the tags property by starting from the route handler and moving up.",
            "",
            "        Tags are additive, so the tags of the route handler are the sum of all tags of the ownership layers.",
            "",
            "        Returns:",
            "            list[str]: A sorted list of unique tags.",
            "        \"\"\"",
            "        if self._resolved_tags is Empty:",
            "            tag_set = set()",
            "            for layer in self.ownership_layers:",
            "                for tag in layer.tags or []:",
            "                    tag_set.add(tag)",
            "            self._resolved_tags = sorted(tag_set)",
            "",
            "        return self._resolved_tags",
            "",
            "    def get_response_handler(self, is_response_type_data: bool = False) -> Callable[[Any], Awaitable[ASGIApp]]:",
            "        \"\"\"Resolve the response_handler function for the route handler.",
            "",
            "        This method is memoized so the computation occurs only once.",
            "",
            "        Args:",
            "            is_response_type_data: Whether to return a handler for 'Response' instances.",
            "",
            "        Returns:",
            "            Async Callable to handle an HTTP Request",
            "        \"\"\"",
            "        if self._response_handler_mapping[\"default_handler\"] is Empty:",
            "            after_request_handlers: list[AsyncAnyCallable] = [",
            "                layer.after_request  # type: ignore[misc]",
            "                for layer in self.ownership_layers",
            "                if layer.after_request",
            "            ]",
            "            after_request = cast(",
            "                \"AfterRequestHookHandler | None\",",
            "                after_request_handlers[-1] if after_request_handlers else None,",
            "            )",
            "",
            "            media_type = self.media_type.value if isinstance(self.media_type, Enum) else self.media_type",
            "            response_class = self.resolve_response_class()",
            "            headers = self.resolve_response_headers()",
            "            cookies = self.resolve_response_cookies()",
            "            type_encoders = self.resolve_type_encoders()",
            "",
            "            return_type = self.parsed_fn_signature.return_type",
            "            return_annotation = return_type.annotation",
            "",
            "            self._response_handler_mapping[\"response_type_handler\"] = response_type_handler = create_response_handler(",
            "                after_request=after_request,",
            "                background=self.background,",
            "                cookies=cookies,",
            "                headers=headers,",
            "                media_type=media_type,",
            "                status_code=self.status_code,",
            "                type_encoders=type_encoders,",
            "            )",
            "",
            "            if return_type.is_subclass_of(Response):",
            "                self._response_handler_mapping[\"default_handler\"] = response_type_handler",
            "            elif is_async_callable(return_annotation) or return_annotation is ASGIApp:",
            "                self._response_handler_mapping[\"default_handler\"] = create_generic_asgi_response_handler(",
            "                    after_request=after_request",
            "                )",
            "            else:",
            "                self._response_handler_mapping[\"default_handler\"] = create_data_handler(",
            "                    after_request=after_request,",
            "                    background=self.background,",
            "                    cookies=cookies,",
            "                    headers=headers,",
            "                    media_type=media_type,",
            "                    response_class=response_class,",
            "                    status_code=self.status_code,",
            "                    type_encoders=type_encoders,",
            "                )",
            "",
            "        return cast(",
            "            \"Callable[[Any], Awaitable[ASGIApp]]\",",
            "            self._response_handler_mapping[\"response_type_handler\"]",
            "            if is_response_type_data",
            "            else self._response_handler_mapping[\"default_handler\"],",
            "        )",
            "",
            "    async def to_response(self, app: Litestar, data: Any, request: Request) -> ASGIApp:",
            "        \"\"\"Return a :class:`Response <.response.Response>` from the handler by resolving and calling it.",
            "",
            "        Args:",
            "            app: The :class:`Litestar <litestar.app.Litestar>` app instance",
            "            data: Either an instance of a :class:`Response <.response.Response>`,",
            "                a Response instance or an arbitrary value.",
            "            request: A :class:`Request <.connection.Request>` instance",
            "",
            "        Returns:",
            "            A Response instance",
            "        \"\"\"",
            "        if return_dto_type := self.resolve_return_dto():",
            "            data = return_dto_type(request).data_to_encodable_type(data)",
            "",
            "        response_handler = self.get_response_handler(is_response_type_data=isinstance(data, Response))",
            "        return await response_handler(app=app, data=data, request=request)  # type: ignore[call-arg]",
            "",
            "    def on_registration(self, app: Litestar) -> None:",
            "        super().on_registration(app)",
            "        self.resolve_after_response()",
            "        self.resolve_include_in_schema()",
            "        self.has_sync_callable = not is_async_callable(self.fn)",
            "",
            "        if self.has_sync_callable and self.sync_to_thread:",
            "            self._fn = ensure_async_callable(self.fn)",
            "            self.has_sync_callable = False",
            "",
            "    def _validate_handler_function(self) -> None:",
            "        \"\"\"Validate the route handler function once it is set by inspecting its return annotations.\"\"\"",
            "        super()._validate_handler_function()",
            "",
            "        return_type = self.parsed_fn_signature.return_type",
            "",
            "        if return_type.annotation is Empty:",
            "            raise ImproperlyConfiguredException(",
            "                f\"A return value of a route handler function {self} should be type annotated. \"",
            "                \"If your function doesn't return a value, annotate it as returning 'None'.\"",
            "            )",
            "",
            "        if (",
            "            self.status_code < 200 or self.status_code in {HTTP_204_NO_CONTENT, HTTP_304_NOT_MODIFIED}",
            "        ) and not is_empty_response_annotation(return_type):",
            "            raise ImproperlyConfiguredException(",
            "                \"A status code 204, 304 or in the range below 200 does not support a response body. \"",
            "                \"If the function should return a value, change the route handler status code to an appropriate value.\",",
            "            )",
            "",
            "        if not self.media_type:",
            "            if return_type.is_subclass_of((str, bytes)) or return_type.annotation is AnyStr:",
            "                self.media_type = MediaType.TEXT",
            "            elif not return_type.is_subclass_of(Response):",
            "                self.media_type = MediaType.JSON",
            "",
            "        if \"socket\" in self.parsed_fn_signature.parameters:",
            "            raise ImproperlyConfiguredException(\"The 'socket' kwarg is not supported with http handlers\")",
            "",
            "        if \"data\" in self.parsed_fn_signature.parameters and \"GET\" in self.http_methods:",
            "            raise ImproperlyConfiguredException(\"'data' kwarg is unsupported for 'GET' request handlers\")",
            "",
            "        if (body_param := self.parsed_fn_signature.parameters.get(\"body\")) and not body_param.is_subclass_of(bytes):",
            "            raise ImproperlyConfiguredException(",
            "                f\"Invalid type annotation for 'body' parameter in route handler {self}. 'body' will always receive the \"",
            "                f\"raw request body as bytes but was annotated with '{body_param.raw!r}'. If you want to receive \"",
            "                \"processed request data, use the 'data' parameter.\"",
            "            )",
            "",
            "",
            "route = HTTPRouteHandler"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "from enum import Enum",
            "from typing import TYPE_CHECKING, AnyStr, Mapping, Sequence, TypedDict, cast",
            "",
            "from litestar._layers.utils import narrow_response_cookies, narrow_response_headers",
            "from litestar.connection import Request",
            "from litestar.datastructures.cookie import Cookie",
            "from litestar.datastructures.response_header import ResponseHeader",
            "from litestar.enums import HttpMethod, MediaType",
            "from litestar.exceptions import (",
            "    HTTPException,",
            "    ImproperlyConfiguredException,",
            ")",
            "from litestar.handlers.base import BaseRouteHandler",
            "from litestar.handlers.http_handlers._utils import (",
            "    create_data_handler,",
            "    create_generic_asgi_response_handler,",
            "    create_response_handler,",
            "    get_default_status_code,",
            "    is_empty_response_annotation,",
            "    normalize_http_method,",
            ")",
            "from litestar.openapi.spec import Operation",
            "from litestar.response import Response",
            "from litestar.status_codes import HTTP_204_NO_CONTENT, HTTP_304_NOT_MODIFIED",
            "from litestar.types import (",
            "    AfterRequestHookHandler,",
            "    AfterResponseHookHandler,",
            "    AnyCallable,",
            "    ASGIApp,",
            "    BeforeRequestHookHandler,",
            "    CacheKeyBuilder,",
            "    Dependencies,",
            "    Empty,",
            "    EmptyType,",
            "    ExceptionHandlersMap,",
            "    Guard,",
            "    Method,",
            "    Middleware,",
            "    ResponseCookies,",
            "    ResponseHeaders,",
            "    TypeEncodersMap,",
            ")",
            "from litestar.utils import ensure_async_callable",
            "from litestar.utils.predicates import is_async_callable",
            "from litestar.utils.warnings import warn_implicit_sync_to_thread, warn_sync_to_thread_with_async_callable",
            "",
            "if TYPE_CHECKING:",
            "    from typing import Any, Awaitable, Callable",
            "",
            "    from litestar.app import Litestar",
            "    from litestar.background_tasks import BackgroundTask, BackgroundTasks",
            "    from litestar.config.response_cache import CACHE_FOREVER",
            "    from litestar.datastructures import CacheControlHeader, ETag",
            "    from litestar.dto import AbstractDTO",
            "    from litestar.openapi.datastructures import ResponseSpec",
            "    from litestar.openapi.spec import SecurityRequirement",
            "    from litestar.types.callable_types import AsyncAnyCallable, OperationIDCreator",
            "    from litestar.types.composite_types import TypeDecodersSequence",
            "",
            "__all__ = (\"HTTPRouteHandler\", \"route\")",
            "",
            "",
            "class ResponseHandlerMap(TypedDict):",
            "    default_handler: Callable[[Any], Awaitable[ASGIApp]] | EmptyType",
            "    response_type_handler: Callable[[Any], Awaitable[ASGIApp]] | EmptyType",
            "",
            "",
            "class HTTPRouteHandler(BaseRouteHandler):",
            "    \"\"\"HTTP Route Decorator.",
            "",
            "    Use this decorator to decorate an HTTP handler with multiple methods.",
            "    \"\"\"",
            "",
            "    __slots__ = (",
            "        \"_resolved_after_response\",",
            "        \"_resolved_before_request\",",
            "        \"_response_handler_mapping\",",
            "        \"_resolved_include_in_schema\",",
            "        \"_resolved_response_class\",",
            "        \"_resolved_request_class\",",
            "        \"_resolved_tags\",",
            "        \"_resolved_security\",",
            "        \"_resolved_request_max_body_size\",",
            "        \"after_request\",",
            "        \"after_response\",",
            "        \"background\",",
            "        \"before_request\",",
            "        \"cache\",",
            "        \"cache_control\",",
            "        \"cache_key_builder\",",
            "        \"content_encoding\",",
            "        \"content_media_type\",",
            "        \"deprecated\",",
            "        \"description\",",
            "        \"etag\",",
            "        \"has_sync_callable\",",
            "        \"http_methods\",",
            "        \"include_in_schema\",",
            "        \"media_type\",",
            "        \"operation_class\",",
            "        \"operation_id\",",
            "        \"raises\",",
            "        \"request_class\",",
            "        \"response_class\",",
            "        \"response_cookies\",",
            "        \"response_description\",",
            "        \"response_headers\",",
            "        \"responses\",",
            "        \"security\",",
            "        \"status_code\",",
            "        \"summary\",",
            "        \"sync_to_thread\",",
            "        \"tags\",",
            "        \"template_name\",",
            "        \"request_max_body_size\",",
            "    )",
            "",
            "    has_sync_callable: bool",
            "",
            "    def __init__(",
            "        self,",
            "        path: str | Sequence[str] | None = None,",
            "        *,",
            "        after_request: AfterRequestHookHandler | None = None,",
            "        after_response: AfterResponseHookHandler | None = None,",
            "        background: BackgroundTask | BackgroundTasks | None = None,",
            "        before_request: BeforeRequestHookHandler | None = None,",
            "        cache: bool | int | type[CACHE_FOREVER] = False,",
            "        cache_control: CacheControlHeader | None = None,",
            "        cache_key_builder: CacheKeyBuilder | None = None,",
            "        dependencies: Dependencies | None = None,",
            "        dto: type[AbstractDTO] | None | EmptyType = Empty,",
            "        etag: ETag | None = None,",
            "        exception_handlers: ExceptionHandlersMap | None = None,",
            "        guards: Sequence[Guard] | None = None,",
            "        http_method: HttpMethod | Method | Sequence[HttpMethod | Method],",
            "        media_type: MediaType | str | None = None,",
            "        middleware: Sequence[Middleware] | None = None,",
            "        name: str | None = None,",
            "        opt: Mapping[str, Any] | None = None,",
            "        request_class: type[Request] | None = None,",
            "        request_max_body_size: int | None | EmptyType = Empty,",
            "        response_class: type[Response] | None = None,",
            "        response_cookies: ResponseCookies | None = None,",
            "        response_headers: ResponseHeaders | None = None,",
            "        return_dto: type[AbstractDTO] | None | EmptyType = Empty,",
            "        status_code: int | None = None,",
            "        sync_to_thread: bool | None = None,",
            "        # OpenAPI related attributes",
            "        content_encoding: str | None = None,",
            "        content_media_type: str | None = None,",
            "        deprecated: bool = False,",
            "        description: str | None = None,",
            "        include_in_schema: bool | EmptyType = Empty,",
            "        operation_class: type[Operation] = Operation,",
            "        operation_id: str | OperationIDCreator | None = None,",
            "        raises: Sequence[type[HTTPException]] | None = None,",
            "        response_description: str | None = None,",
            "        responses: Mapping[int, ResponseSpec] | None = None,",
            "        signature_namespace: Mapping[str, Any] | None = None,",
            "        security: Sequence[SecurityRequirement] | None = None,",
            "        summary: str | None = None,",
            "        tags: Sequence[str] | None = None,",
            "        type_decoders: TypeDecodersSequence | None = None,",
            "        type_encoders: TypeEncodersMap | None = None,",
            "        **kwargs: Any,",
            "    ) -> None:",
            "        \"\"\"Initialize ``HTTPRouteHandler``.",
            "",
            "        Args:",
            "            path: A path fragment for the route handler function or a sequence of path fragments.",
            "                If not given defaults to ``/``",
            "            after_request: A sync or async function executed before a :class:`Request <.connection.Request>` is passed",
            "                to any route handler. If this function returns a value, the request will not reach the route handler,",
            "                and instead this value will be used.",
            "            after_response: A sync or async function called after the response has been awaited. It receives the",
            "                :class:`Request <.connection.Request>` object and should not return any values.",
            "            background: A :class:`BackgroundTask <.background_tasks.BackgroundTask>` instance or",
            "                :class:`BackgroundTasks <.background_tasks.BackgroundTasks>` to execute after the response is finished.",
            "                Defaults to ``None``.",
            "            before_request: A sync or async function called immediately before calling the route handler. Receives",
            "                the :class:`Request <.connection.Request>` instance and any non-``None`` return value is used for the",
            "                response, bypassing the route handler.",
            "            cache: Enables response caching if configured on the application level. Valid values are ``True`` or a",
            "                number of seconds (e.g. ``120``) to cache the response.",
            "            cache_control: A ``cache-control`` header of type",
            "                :class:`CacheControlHeader <.datastructures.CacheControlHeader>` that will be added to the response.",
            "            cache_key_builder: A :class:`cache-key builder function <.types.CacheKeyBuilder>`. Allows for customization",
            "                of the cache key if caching is configured on the application level.",
            "            dependencies: A string keyed mapping of dependency :class:`Provider <.di.Provide>` instances.",
            "            dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for (de)serializing and",
            "                validation of request data.",
            "            etag: An ``etag`` header of type :class:`ETag <.datastructures.ETag>` that will be added to the response.",
            "            exception_handlers: A mapping of status codes and/or exception types to handler functions.",
            "            guards: A sequence of :class:`Guard <.types.Guard>` callables.",
            "            http_method: An :class:`http method string <.types.Method>`, a member of the enum",
            "                :class:`HttpMethod <.enums.HttpMethod>` or a list of these that correlates to the methods the route",
            "                handler function should handle.",
            "            media_type: A member of the :class:`MediaType <.enums.MediaType>` enum or a string with a valid IANA",
            "                Media-Type.",
            "            middleware: A sequence of :class:`Middleware <.types.Middleware>`.",
            "            name: A string identifying the route handler.",
            "            opt: A string keyed mapping of arbitrary values that can be accessed in :class:`Guards <.types.Guard>` or",
            "                wherever you have access to :class:`Request <.connection.Request>` or",
            "                :class:`ASGI Scope <.types.Scope>`.",
            "            request_class: A custom subclass of :class:`Request <.connection.Request>` to be used as route handler's",
            "                default request.",
            "            request_max_body_size: Maximum allowed size of the request body in bytes. If this size is exceeded,",
            "                a '413 - Request Entity Too Large' error response is returned.",
            "            response_class: A custom subclass of :class:`Response <.response.Response>` to be used as route handler's",
            "                default response.",
            "            response_cookies: A sequence of :class:`Cookie <.datastructures.Cookie>` instances.",
            "            response_headers: A string keyed mapping of :class:`ResponseHeader <.datastructures.ResponseHeader>`",
            "                instances.",
            "            responses: A mapping of additional status codes and a description of their expected content.",
            "                This information will be included in the OpenAPI schema",
            "            return_dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for serializing",
            "                outbound response data.",
            "            signature_namespace: A mapping of names to types for use in forward reference resolution during signature modelling.",
            "            status_code: An http status code for the response. Defaults to ``200`` for ``GET``, ``PUT`` and ``PATCH``,",
            "                ``201`` for ``POST`` and ``204`` for ``DELETE``. For mixed method requests it will check for ``POST`` and ``DELETE`` first",
            "                then defaults to ``200``.",
            "            sync_to_thread: A boolean dictating whether the handler function will be executed in a worker thread or the",
            "                main event loop. This has an effect only for sync handler functions. See using sync handler functions.",
            "            content_encoding: A string describing the encoding of the content, e.g. ``\"base64\"``.",
            "            content_media_type: A string designating the media-type of the content, e.g. ``\"image/png\"``.",
            "            deprecated:  A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema.",
            "            description: Text used for the route's schema description section.",
            "            include_in_schema: A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.",
            "            operation_class: :class:`Operation <.openapi.spec.operation.Operation>` to be used with the route's OpenAPI schema.",
            "            operation_id: Either a string or a callable returning a string. An identifier used for the route's schema operationId.",
            "            raises:  A list of exception classes extending from litestar.HttpException that is used for the OpenAPI documentation.",
            "                This list should describe all exceptions raised within the route handler's function/method. The Litestar",
            "                ValidationException will be added automatically for the schema if any validation is involved.",
            "            response_description: Text used for the route's response schema description section.",
            "            security: A sequence of dictionaries that contain information about which security scheme can be used on the endpoint.",
            "            summary: Text used for the route's schema summary section.",
            "            tags: A sequence of string tags that will be appended to the OpenAPI schema.",
            "            type_decoders: A sequence of tuples, each composed of a predicate testing for type identity and a msgspec hook for deserialization.",
            "            type_encoders: A mapping of types to callables that transform them into types supported for serialization.",
            "            **kwargs: Any additional kwarg - will be set in the opt dictionary.",
            "        \"\"\"",
            "        if not http_method:",
            "            raise ImproperlyConfiguredException(\"An http_method kwarg is required\")",
            "",
            "        self.http_methods = normalize_http_method(http_methods=http_method)",
            "        self.status_code = status_code or get_default_status_code(http_methods=self.http_methods)",
            "",
            "        super().__init__(",
            "            path=path,",
            "            dependencies=dependencies,",
            "            dto=dto,",
            "            exception_handlers=exception_handlers,",
            "            guards=guards,",
            "            middleware=middleware,",
            "            name=name,",
            "            opt=opt,",
            "            return_dto=return_dto,",
            "            signature_namespace=signature_namespace,",
            "            type_decoders=type_decoders,",
            "            type_encoders=type_encoders,",
            "            **kwargs,",
            "        )",
            "",
            "        self.after_request = ensure_async_callable(after_request) if after_request else None  # pyright: ignore",
            "        self.after_response = ensure_async_callable(after_response) if after_response else None",
            "        self.background = background",
            "        self.before_request = ensure_async_callable(before_request) if before_request else None",
            "        self.cache = cache",
            "        self.cache_control = cache_control",
            "        self.cache_key_builder = cache_key_builder",
            "        self.etag = etag",
            "        self.media_type: MediaType | str = media_type or \"\"",
            "        self.request_class = request_class",
            "        self.response_class = response_class",
            "        self.response_cookies: Sequence[Cookie] | None = narrow_response_cookies(response_cookies)",
            "        self.response_headers: Sequence[ResponseHeader] | None = narrow_response_headers(response_headers)",
            "        self.request_max_body_size = request_max_body_size",
            "",
            "        self.sync_to_thread = sync_to_thread",
            "        # OpenAPI related attributes",
            "        self.content_encoding = content_encoding",
            "        self.content_media_type = content_media_type",
            "        self.deprecated = deprecated",
            "        self.description = description",
            "        self.include_in_schema = include_in_schema",
            "        self.operation_class = operation_class",
            "        self.operation_id = operation_id",
            "        self.raises = raises",
            "        self.response_description = response_description",
            "        self.summary = summary",
            "        self.tags = tags",
            "        self.security = security",
            "        self.responses = responses",
            "        # memoized attributes, defaulted to Empty",
            "        self._resolved_after_response: AsyncAnyCallable | None | EmptyType = Empty",
            "        self._resolved_before_request: AsyncAnyCallable | None | EmptyType = Empty",
            "        self._response_handler_mapping: ResponseHandlerMap = {\"default_handler\": Empty, \"response_type_handler\": Empty}",
            "        self._resolved_include_in_schema: bool | EmptyType = Empty",
            "        self._resolved_response_class: type[Response] | EmptyType = Empty",
            "        self._resolved_request_class: type[Request] | EmptyType = Empty",
            "        self._resolved_security: list[SecurityRequirement] | EmptyType = Empty",
            "        self._resolved_tags: list[str] | EmptyType = Empty",
            "        self._resolved_request_max_body_size: int | EmptyType | None = Empty",
            "",
            "    def __call__(self, fn: AnyCallable) -> HTTPRouteHandler:",
            "        \"\"\"Replace a function with itself.\"\"\"",
            "        if not is_async_callable(fn):",
            "            if self.sync_to_thread is None:",
            "                warn_implicit_sync_to_thread(fn, stacklevel=3)",
            "        elif self.sync_to_thread is not None:",
            "            warn_sync_to_thread_with_async_callable(fn, stacklevel=3)",
            "",
            "        super().__call__(fn)",
            "        return self",
            "",
            "    def resolve_request_class(self) -> type[Request]:",
            "        \"\"\"Return the closest custom Request class in the owner graph or the default Request class.",
            "",
            "        This method is memoized so the computation occurs only once.",
            "",
            "        Returns:",
            "            The default :class:`Request <.connection.Request>` class for the route handler.",
            "        \"\"\"",
            "",
            "        if self._resolved_request_class is Empty:",
            "            self._resolved_request_class = next(",
            "                (layer.request_class for layer in reversed(self.ownership_layers) if layer.request_class is not None),",
            "                Request,",
            "            )",
            "",
            "        return cast(\"type[Request]\", self._resolved_request_class)",
            "",
            "    def resolve_response_class(self) -> type[Response]:",
            "        \"\"\"Return the closest custom Response class in the owner graph or the default Response class.",
            "",
            "        This method is memoized so the computation occurs only once.",
            "",
            "        Returns:",
            "            The default :class:`Response <.response.Response>` class for the route handler.",
            "        \"\"\"",
            "        if self._resolved_response_class is Empty:",
            "            self._resolved_response_class = next(",
            "                (layer.response_class for layer in reversed(self.ownership_layers) if layer.response_class is not None),",
            "                Response,",
            "            )",
            "",
            "        return cast(\"type[Response]\", self._resolved_response_class)",
            "",
            "    def resolve_response_headers(self) -> frozenset[ResponseHeader]:",
            "        \"\"\"Return all header parameters in the scope of the handler function.",
            "",
            "        Returns:",
            "            A dictionary mapping keys to :class:`ResponseHeader <.datastructures.ResponseHeader>` instances.",
            "        \"\"\"",
            "        resolved_response_headers: dict[str, ResponseHeader] = {}",
            "",
            "        for layer in self.ownership_layers:",
            "            if layer_response_headers := layer.response_headers:",
            "                if isinstance(layer_response_headers, Mapping):",
            "                    # this can't happen unless you manually set response_headers on an instance, which would result in a",
            "                    # type-checking error on everything but the controller. We cover this case nevertheless",
            "                    resolved_response_headers.update(",
            "                        {name: ResponseHeader(name=name, value=value) for name, value in layer_response_headers.items()}",
            "                    )",
            "                else:",
            "                    resolved_response_headers.update({h.name: h for h in layer_response_headers})",
            "            for extra_header in (\"cache_control\", \"etag\"):",
            "                if header_model := getattr(layer, extra_header, None):",
            "                    resolved_response_headers[header_model.HEADER_NAME] = ResponseHeader(",
            "                        name=header_model.HEADER_NAME,",
            "                        value=header_model.to_header(),",
            "                        documentation_only=header_model.documentation_only,",
            "                    )",
            "",
            "        return frozenset(resolved_response_headers.values())",
            "",
            "    def resolve_response_cookies(self) -> frozenset[Cookie]:",
            "        \"\"\"Return a list of Cookie instances. Filters the list to ensure each cookie key is unique.",
            "",
            "        Returns:",
            "            A list of :class:`Cookie <.datastructures.Cookie>` instances.",
            "        \"\"\"",
            "        response_cookies: set[Cookie] = set()",
            "        for layer in reversed(self.ownership_layers):",
            "            if layer_response_cookies := layer.response_cookies:",
            "                if isinstance(layer_response_cookies, Mapping):",
            "                    # this can't happen unless you manually set response_cookies on an instance, which would result in a",
            "                    # type-checking error on everything but the controller. We cover this case nevertheless",
            "                    response_cookies.update(",
            "                        {Cookie(key=key, value=value) for key, value in layer_response_cookies.items()}",
            "                    )",
            "                else:",
            "                    response_cookies.update(cast(\"set[Cookie]\", layer_response_cookies))",
            "        return frozenset(response_cookies)",
            "",
            "    def resolve_before_request(self) -> AsyncAnyCallable | None:",
            "        \"\"\"Resolve the before_handler handler by starting from the route handler and moving up.",
            "",
            "        If a handler is found it is returned, otherwise None is set.",
            "        This method is memoized so the computation occurs only once.",
            "",
            "        Returns:",
            "            An optional :class:`before request lifecycle hook handler <.types.BeforeRequestHookHandler>`",
            "        \"\"\"",
            "        if self._resolved_before_request is Empty:",
            "            before_request_handlers = [layer.before_request for layer in self.ownership_layers if layer.before_request]",
            "            self._resolved_before_request = before_request_handlers[-1] if before_request_handlers else None",
            "        return cast(\"AsyncAnyCallable | None\", self._resolved_before_request)",
            "",
            "    def resolve_after_response(self) -> AsyncAnyCallable | None:",
            "        \"\"\"Resolve the after_response handler by starting from the route handler and moving up.",
            "",
            "        If a handler is found it is returned, otherwise None is set.",
            "        This method is memoized so the computation occurs only once.",
            "",
            "        Returns:",
            "            An optional :class:`after response lifecycle hook handler <.types.AfterResponseHookHandler>`",
            "        \"\"\"",
            "        if self._resolved_after_response is Empty:",
            "            after_response_handlers: list[AsyncAnyCallable] = [",
            "                layer.after_response  # type: ignore[misc]",
            "                for layer in self.ownership_layers",
            "                if layer.after_response",
            "            ]",
            "            self._resolved_after_response = after_response_handlers[-1] if after_response_handlers else None",
            "",
            "        return cast(\"AsyncAnyCallable | None\", self._resolved_after_response)",
            "",
            "    def resolve_include_in_schema(self) -> bool:",
            "        \"\"\"Resolve the 'include_in_schema' property by starting from the route handler and moving up.",
            "",
            "        If 'include_in_schema' is found in any of the ownership layers, the last value found is returned.",
            "        If not found in any layer, the default value ``True`` is returned.",
            "",
            "        Returns:",
            "            bool: The resolved 'include_in_schema' property.",
            "        \"\"\"",
            "        if self._resolved_include_in_schema is Empty:",
            "            include_in_schemas = [",
            "                i.include_in_schema for i in self.ownership_layers if isinstance(i.include_in_schema, bool)",
            "            ]",
            "            self._resolved_include_in_schema = include_in_schemas[-1] if include_in_schemas else True",
            "",
            "        return self._resolved_include_in_schema",
            "",
            "    def resolve_security(self) -> list[SecurityRequirement]:",
            "        \"\"\"Resolve the security property by starting from the route handler and moving up.",
            "",
            "        Security requirements are additive, so the security requirements of the route handler are the sum of all",
            "        security requirements of the ownership layers.",
            "",
            "        Returns:",
            "            list[SecurityRequirement]: The resolved security property.",
            "        \"\"\"",
            "        if self._resolved_security is Empty:",
            "            self._resolved_security = []",
            "            for layer in self.ownership_layers:",
            "                if isinstance(layer.security, Sequence):",
            "                    self._resolved_security.extend(layer.security)",
            "",
            "        return self._resolved_security",
            "",
            "    def resolve_tags(self) -> list[str]:",
            "        \"\"\"Resolve the tags property by starting from the route handler and moving up.",
            "",
            "        Tags are additive, so the tags of the route handler are the sum of all tags of the ownership layers.",
            "",
            "        Returns:",
            "            list[str]: A sorted list of unique tags.",
            "        \"\"\"",
            "        if self._resolved_tags is Empty:",
            "            tag_set = set()",
            "            for layer in self.ownership_layers:",
            "                for tag in layer.tags or []:",
            "                    tag_set.add(tag)",
            "            self._resolved_tags = sorted(tag_set)",
            "",
            "        return self._resolved_tags",
            "",
            "    def resolve_request_max_body_size(self) -> int | None:",
            "        if (resolved_limits := self._resolved_request_max_body_size) is not Empty:",
            "            return resolved_limits",
            "",
            "        max_body_size = self._resolved_request_max_body_size = next(  # pyright: ignore",
            "            (",
            "                max_body_size",
            "                for layer in reversed(self.ownership_layers)",
            "                if (max_body_size := layer.request_max_body_size) is not Empty",
            "            ),",
            "            Empty,",
            "        )",
            "        if max_body_size is Empty:",
            "            raise ImproperlyConfiguredException(",
            "                \"'request_max_body_size' set to 'Empty' on all layers. To omit a limit, \"",
            "                \"set 'request_max_body_size=None'\"",
            "            )",
            "        return max_body_size",
            "",
            "    def get_response_handler(self, is_response_type_data: bool = False) -> Callable[[Any], Awaitable[ASGIApp]]:",
            "        \"\"\"Resolve the response_handler function for the route handler.",
            "",
            "        This method is memoized so the computation occurs only once.",
            "",
            "        Args:",
            "            is_response_type_data: Whether to return a handler for 'Response' instances.",
            "",
            "        Returns:",
            "            Async Callable to handle an HTTP Request",
            "        \"\"\"",
            "        if self._response_handler_mapping[\"default_handler\"] is Empty:",
            "            after_request_handlers: list[AsyncAnyCallable] = [",
            "                layer.after_request  # type: ignore[misc]",
            "                for layer in self.ownership_layers",
            "                if layer.after_request",
            "            ]",
            "            after_request = cast(",
            "                \"AfterRequestHookHandler | None\",",
            "                after_request_handlers[-1] if after_request_handlers else None,",
            "            )",
            "",
            "            media_type = self.media_type.value if isinstance(self.media_type, Enum) else self.media_type",
            "            response_class = self.resolve_response_class()",
            "            headers = self.resolve_response_headers()",
            "            cookies = self.resolve_response_cookies()",
            "            type_encoders = self.resolve_type_encoders()",
            "",
            "            return_type = self.parsed_fn_signature.return_type",
            "            return_annotation = return_type.annotation",
            "",
            "            self._response_handler_mapping[\"response_type_handler\"] = response_type_handler = create_response_handler(",
            "                after_request=after_request,",
            "                background=self.background,",
            "                cookies=cookies,",
            "                headers=headers,",
            "                media_type=media_type,",
            "                status_code=self.status_code,",
            "                type_encoders=type_encoders,",
            "            )",
            "",
            "            if return_type.is_subclass_of(Response):",
            "                self._response_handler_mapping[\"default_handler\"] = response_type_handler",
            "            elif is_async_callable(return_annotation) or return_annotation is ASGIApp:",
            "                self._response_handler_mapping[\"default_handler\"] = create_generic_asgi_response_handler(",
            "                    after_request=after_request",
            "                )",
            "            else:",
            "                self._response_handler_mapping[\"default_handler\"] = create_data_handler(",
            "                    after_request=after_request,",
            "                    background=self.background,",
            "                    cookies=cookies,",
            "                    headers=headers,",
            "                    media_type=media_type,",
            "                    response_class=response_class,",
            "                    status_code=self.status_code,",
            "                    type_encoders=type_encoders,",
            "                )",
            "",
            "        return cast(",
            "            \"Callable[[Any], Awaitable[ASGIApp]]\",",
            "            self._response_handler_mapping[\"response_type_handler\"]",
            "            if is_response_type_data",
            "            else self._response_handler_mapping[\"default_handler\"],",
            "        )",
            "",
            "    async def to_response(self, app: Litestar, data: Any, request: Request) -> ASGIApp:",
            "        \"\"\"Return a :class:`Response <.response.Response>` from the handler by resolving and calling it.",
            "",
            "        Args:",
            "            app: The :class:`Litestar <litestar.app.Litestar>` app instance",
            "            data: Either an instance of a :class:`Response <.response.Response>`,",
            "                a Response instance or an arbitrary value.",
            "            request: A :class:`Request <.connection.Request>` instance",
            "",
            "        Returns:",
            "            A Response instance",
            "        \"\"\"",
            "        if return_dto_type := self.resolve_return_dto():",
            "            data = return_dto_type(request).data_to_encodable_type(data)",
            "",
            "        response_handler = self.get_response_handler(is_response_type_data=isinstance(data, Response))",
            "        return await response_handler(app=app, data=data, request=request)  # type: ignore[call-arg]",
            "",
            "    def on_registration(self, app: Litestar) -> None:",
            "        super().on_registration(app)",
            "        self.resolve_after_response()",
            "        self.resolve_include_in_schema()",
            "        self.has_sync_callable = not is_async_callable(self.fn)",
            "",
            "        if self.has_sync_callable and self.sync_to_thread:",
            "            self._fn = ensure_async_callable(self.fn)",
            "            self.has_sync_callable = False",
            "",
            "    def _validate_handler_function(self) -> None:",
            "        \"\"\"Validate the route handler function once it is set by inspecting its return annotations.\"\"\"",
            "        super()._validate_handler_function()",
            "",
            "        return_type = self.parsed_fn_signature.return_type",
            "",
            "        if return_type.annotation is Empty:",
            "            raise ImproperlyConfiguredException(",
            "                f\"A return value of a route handler function {self} should be type annotated. \"",
            "                \"If your function doesn't return a value, annotate it as returning 'None'.\"",
            "            )",
            "",
            "        if (",
            "            self.status_code < 200 or self.status_code in {HTTP_204_NO_CONTENT, HTTP_304_NOT_MODIFIED}",
            "        ) and not is_empty_response_annotation(return_type):",
            "            raise ImproperlyConfiguredException(",
            "                \"A status code 204, 304 or in the range below 200 does not support a response body. \"",
            "                \"If the function should return a value, change the route handler status code to an appropriate value.\",",
            "            )",
            "",
            "        if not self.media_type:",
            "            if return_type.is_subclass_of((str, bytes)) or return_type.annotation is AnyStr:",
            "                self.media_type = MediaType.TEXT",
            "            elif not return_type.is_subclass_of(Response):",
            "                self.media_type = MediaType.JSON",
            "",
            "        if \"socket\" in self.parsed_fn_signature.parameters:",
            "            raise ImproperlyConfiguredException(\"The 'socket' kwarg is not supported with http handlers\")",
            "",
            "        if \"data\" in self.parsed_fn_signature.parameters and \"GET\" in self.http_methods:",
            "            raise ImproperlyConfiguredException(\"'data' kwarg is unsupported for 'GET' request handlers\")",
            "",
            "        if (body_param := self.parsed_fn_signature.parameters.get(\"body\")) and not body_param.is_subclass_of(bytes):",
            "            raise ImproperlyConfiguredException(",
            "                f\"Invalid type annotation for 'body' parameter in route handler {self}. 'body' will always receive the \"",
            "                f\"raw request body as bytes but was annotated with '{body_param.raw!r}'. If you want to receive \"",
            "                \"processed request data, use the 'data' parameter.\"",
            "            )",
            "",
            "",
            "route = HTTPRouteHandler"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "litellm.utils.token_counter",
            "litestar.handlers.http_handlers.base.HTTPRouteHandler",
            "litestar.handlers.http_handlers.base.route",
            "litestar.handlers.http_handlers.base.HTTPRouteHandler.self",
            "litestar.handlers.http_handlers.base.HTTPRouteHandler.__call__"
        ]
    }
}