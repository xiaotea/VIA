{
    "nova/tests/unit/virt/libvirt/test_driver.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 8636,
                "afterPatchRowNumber": 8636,
                "PatchRowcode": "                            fallback_from_host=instance.host)])"
            },
            "1": {
                "beforePatchRowNumber": 8637,
                "afterPatchRowNumber": 8637,
                "PatchRowcode": "             self.assertIsInstance(res, objects.LibvirtLiveMigrateData)"
            },
            "2": {
                "beforePatchRowNumber": 8638,
                "afterPatchRowNumber": 8638,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8639,
                "PatchRowcode": "+    def test_pre_live_migration_recreate_disk_info(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8640,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8641,
                "PatchRowcode": "+        migrate_data = {'is_shared_block_storage': False,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8642,
                "PatchRowcode": "+                        'is_shared_instance_path': False,"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8643,
                "PatchRowcode": "+                        'block_migration': True,"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8644,
                "PatchRowcode": "+                        'instance_relative_path': '/some/path/'}"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8645,
                "PatchRowcode": "+        disk_info = [{'disk_size': 5368709120, 'type': 'raw',"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8646,
                "PatchRowcode": "+                      'virt_disk_size': 5368709120,"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8647,
                "PatchRowcode": "+                      'path': '/some/path/disk',"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8648,
                "PatchRowcode": "+                      'backing_file': '', 'over_committed_disk_size': 0},"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8649,
                "PatchRowcode": "+                     {'disk_size': 1073741824, 'type': 'raw',"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8650,
                "PatchRowcode": "+                      'virt_disk_size': 1073741824,"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8651,
                "PatchRowcode": "+                      'path': '/some/path/disk.eph0',"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8652,
                "PatchRowcode": "+                      'backing_file': '', 'over_committed_disk_size': 0}]"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8653,
                "PatchRowcode": "+        image_disk_info = {'/some/path/disk': 'raw',"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8654,
                "PatchRowcode": "+                           '/some/path/disk.eph0': 'raw'}"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8655,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8656,
                "PatchRowcode": "+        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8657,
                "PatchRowcode": "+        instance = objects.Instance(**self.test_instance)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8658,
                "PatchRowcode": "+        instance_path = os.path.dirname(disk_info[0]['path'])"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8659,
                "PatchRowcode": "+        disk_info_path = os.path.join(instance_path, 'disk.info')"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8660,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8661,
                "PatchRowcode": "+        with test.nested("
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8662,
                "PatchRowcode": "+            mock.patch.object(os, 'mkdir'),"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8663,
                "PatchRowcode": "+            mock.patch.object(fake_libvirt_utils, 'write_to_file'),"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8664,
                "PatchRowcode": "+            mock.patch.object(drvr, '_create_images_and_backing')"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8665,
                "PatchRowcode": "+        ) as ("
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8666,
                "PatchRowcode": "+            mkdir, write_to_file, create_images_and_backing"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8667,
                "PatchRowcode": "+        ):"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8668,
                "PatchRowcode": "+            drvr.pre_live_migration(self.context, instance,"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8669,
                "PatchRowcode": "+                                    block_device_info=None,"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8670,
                "PatchRowcode": "+                                    network_info=[],"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8671,
                "PatchRowcode": "+                                    disk_info=jsonutils.dumps(disk_info),"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8672,
                "PatchRowcode": "+                                    migrate_data=migrate_data)"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8673,
                "PatchRowcode": "+            write_to_file.assert_called_with(disk_info_path,"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8674,
                "PatchRowcode": "+                                             jsonutils.dumps(image_disk_info))"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8675,
                "PatchRowcode": "+"
            },
            "40": {
                "beforePatchRowNumber": 8639,
                "afterPatchRowNumber": 8676,
                "PatchRowcode": "     def test_get_instance_disk_info_works_correctly(self):"
            },
            "41": {
                "beforePatchRowNumber": 8640,
                "afterPatchRowNumber": 8677,
                "PatchRowcode": "         # Test data"
            },
            "42": {
                "beforePatchRowNumber": 8641,
                "afterPatchRowNumber": 8678,
                "PatchRowcode": "         instance = objects.Instance(**self.test_instance)"
            },
            "43": {
                "beforePatchRowNumber": 14170,
                "afterPatchRowNumber": 14207,
                "PatchRowcode": "         flavor_obj = objects.Flavor(**flavor)"
            },
            "44": {
                "beforePatchRowNumber": 14171,
                "afterPatchRowNumber": 14208,
                "PatchRowcode": "         self._test_migrate_disk_and_power_off(flavor_obj)"
            },
            "45": {
                "beforePatchRowNumber": 14172,
                "afterPatchRowNumber": 14209,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14210,
                "PatchRowcode": "+    @mock.patch('nova.utils.execute')"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14211,
                "PatchRowcode": "+    @mock.patch('nova.virt.libvirt.utils.copy_image')"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14212,
                "PatchRowcode": "+    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._destroy')"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14213,
                "PatchRowcode": "+    @mock.patch('nova.virt.libvirt.utils.get_instance_path')"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14214,
                "PatchRowcode": "+    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver'"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14215,
                "PatchRowcode": "+                '._is_storage_shared_with')"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14216,
                "PatchRowcode": "+    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver'"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14217,
                "PatchRowcode": "+                '.get_instance_disk_info')"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14218,
                "PatchRowcode": "+    def test_migrate_disk_and_power_off_resize_copy_disk_info(self,"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14219,
                "PatchRowcode": "+                                                              mock_disk_info,"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14220,
                "PatchRowcode": "+                                                              mock_shared,"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14221,
                "PatchRowcode": "+                                                              mock_path,"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14222,
                "PatchRowcode": "+                                                              mock_destroy,"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14223,
                "PatchRowcode": "+                                                              mock_copy,"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14224,
                "PatchRowcode": "+                                                              mock_execuate):"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14225,
                "PatchRowcode": "+"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14226,
                "PatchRowcode": "+        instance = self._create_instance()"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14227,
                "PatchRowcode": "+        disk_info = self._disk_info()"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14228,
                "PatchRowcode": "+        disk_info_text = jsonutils.loads(disk_info)"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14229,
                "PatchRowcode": "+        instance_base = os.path.dirname(disk_info_text[0]['path'])"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14230,
                "PatchRowcode": "+        flavor = {'root_gb': 10, 'ephemeral_gb': 25}"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14231,
                "PatchRowcode": "+        flavor_obj = objects.Flavor(**flavor)"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14232,
                "PatchRowcode": "+"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14233,
                "PatchRowcode": "+        mock_disk_info.return_value = disk_info"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14234,
                "PatchRowcode": "+        mock_path.return_value = instance_base"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14235,
                "PatchRowcode": "+        mock_shared.return_value = False"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14236,
                "PatchRowcode": "+"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14237,
                "PatchRowcode": "+        self.drvr.migrate_disk_and_power_off(context.get_admin_context(),"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14238,
                "PatchRowcode": "+                                             instance, mock.sentinel,"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14239,
                "PatchRowcode": "+                                             flavor_obj, None)"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14240,
                "PatchRowcode": "+"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14241,
                "PatchRowcode": "+        src_disk_info_path = os.path.join(instance_base + '_resize',"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14242,
                "PatchRowcode": "+                                          'disk.info')"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14243,
                "PatchRowcode": "+        dst_disk_info_path = os.path.join(instance_base, 'disk.info')"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14244,
                "PatchRowcode": "+        mock_copy.assert_any_call(src_disk_info_path, dst_disk_info_path,"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14245,
                "PatchRowcode": "+                                  host=mock.sentinel, on_execute=mock.ANY,"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14246,
                "PatchRowcode": "+                                  on_completion=mock.ANY, compression=mock.ANY)"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14247,
                "PatchRowcode": "+"
            },
            "84": {
                "beforePatchRowNumber": 14173,
                "afterPatchRowNumber": 14248,
                "PatchRowcode": "     def test_wait_for_running(self):"
            },
            "85": {
                "beforePatchRowNumber": 14174,
                "afterPatchRowNumber": 14249,
                "PatchRowcode": "         def fake_get_info(instance):"
            },
            "86": {
                "beforePatchRowNumber": 14175,
                "afterPatchRowNumber": 14250,
                "PatchRowcode": "             if instance['name'] == \"not_found\":"
            }
        },
        "frontPatchFile": [
            "#    Copyright 2010 OpenStack Foundation",
            "#    Copyright 2012 University Of Minho",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import contextlib",
            "import copy",
            "import datetime",
            "import errno",
            "import glob",
            "import os",
            "import random",
            "import re",
            "import shutil",
            "import signal",
            "import threading",
            "import time",
            "import uuid",
            "",
            "import eventlet",
            "from eventlet import greenthread",
            "import fixtures",
            "from lxml import etree",
            "import mock",
            "from mox3 import mox",
            "from os_brick.initiator import connector",
            "from oslo_concurrency import lockutils",
            "from oslo_concurrency import processutils",
            "from oslo_config import cfg",
            "from oslo_serialization import jsonutils",
            "from oslo_service import loopingcall",
            "from oslo_utils import encodeutils",
            "from oslo_utils import fileutils",
            "from oslo_utils import fixture as utils_fixture",
            "from oslo_utils import importutils",
            "from oslo_utils import units",
            "from oslo_utils import uuidutils",
            "from oslo_utils import versionutils",
            "import six",
            "from six.moves import builtins",
            "from six.moves import range",
            "",
            "from nova.api.metadata import base as instance_metadata",
            "from nova.compute import arch",
            "from nova.compute import cpumodel",
            "from nova.compute import manager",
            "from nova.compute import power_state",
            "from nova.compute import task_states",
            "from nova.compute import vm_mode",
            "from nova.compute import vm_states",
            "from nova import context",
            "from nova import db",
            "from nova import exception",
            "from nova.network import model as network_model",
            "from nova import objects",
            "from nova.objects import block_device as block_device_obj",
            "from nova.objects import fields",
            "from nova.pci import manager as pci_manager",
            "from nova.pci import utils as pci_utils",
            "from nova import test",
            "from nova.tests.unit import fake_block_device",
            "from nova.tests.unit import fake_instance",
            "from nova.tests.unit import fake_network",
            "import nova.tests.unit.image.fake",
            "from nova.tests.unit import matchers",
            "from nova.tests.unit.objects import test_pci_device",
            "from nova.tests.unit.objects import test_vcpu_model",
            "from nova.tests.unit.virt.libvirt import fake_imagebackend",
            "from nova.tests.unit.virt.libvirt import fake_libvirt_utils",
            "from nova.tests.unit.virt.libvirt import fakelibvirt",
            "from nova import utils",
            "from nova import version",
            "from nova.virt import block_device as driver_block_device",
            "from nova.virt import configdrive",
            "from nova.virt.disk import api as disk",
            "from nova.virt import driver",
            "from nova.virt import fake",
            "from nova.virt import firewall as base_firewall",
            "from nova.virt import hardware",
            "from nova.virt.image import model as imgmodel",
            "from nova.virt.libvirt import blockinfo",
            "from nova.virt.libvirt import config as vconfig",
            "from nova.virt.libvirt import driver as libvirt_driver",
            "from nova.virt.libvirt import firewall",
            "from nova.virt.libvirt import guest as libvirt_guest",
            "from nova.virt.libvirt import host",
            "from nova.virt.libvirt import imagebackend",
            "from nova.virt.libvirt.storage import dmcrypt",
            "from nova.virt.libvirt.storage import lvm",
            "from nova.virt.libvirt.storage import rbd_utils",
            "from nova.virt.libvirt import utils as libvirt_utils",
            "from nova.virt.libvirt.volume import volume as volume_drivers",
            "",
            "libvirt_driver.libvirt = fakelibvirt",
            "host.libvirt = fakelibvirt",
            "libvirt_guest.libvirt = fakelibvirt",
            "",
            "",
            "CONF = cfg.CONF",
            "CONF.import_opt('compute_manager', 'nova.service')",
            "CONF.import_opt('host', 'nova.netconf')",
            "CONF.import_opt('my_ip', 'nova.netconf')",
            "CONF.import_opt('image_cache_subdirectory_name', 'nova.virt.imagecache')",
            "CONF.import_opt('instances_path', 'nova.compute.manager')",
            "",
            "_fake_network_info = fake_network.fake_get_instance_nw_info",
            "",
            "_fake_NodeDevXml = \\",
            "    {\"pci_0000_04_00_3\": \"\"\"",
            "        <device>",
            "        <name>pci_0000_04_00_3</name>",
            "        <parent>pci_0000_00_01_1</parent>",
            "        <driver>",
            "            <name>igb</name>",
            "        </driver>",
            "        <capability type='pci'>",
            "            <domain>0</domain>",
            "            <bus>4</bus>",
            "            <slot>0</slot>",
            "            <function>3</function>",
            "            <product id='0x1521'>I350 Gigabit Network Connection</product>",
            "            <vendor id='0x8086'>Intel Corporation</vendor>",
            "            <capability type='virt_functions'>",
            "              <address domain='0x0000' bus='0x04' slot='0x10' function='0x3'/>",
            "              <address domain='0x0000' bus='0x04' slot='0x10' function='0x7'/>",
            "              <address domain='0x0000' bus='0x04' slot='0x11' function='0x3'/>",
            "              <address domain='0x0000' bus='0x04' slot='0x11' function='0x7'/>",
            "            </capability>",
            "        </capability>",
            "      </device>\"\"\",",
            "    \"pci_0000_04_10_7\": \"\"\"",
            "      <device>",
            "         <name>pci_0000_04_10_7</name>",
            "         <parent>pci_0000_00_01_1</parent>",
            "         <driver>",
            "         <name>igbvf</name>",
            "         </driver>",
            "         <capability type='pci'>",
            "          <domain>0</domain>",
            "          <bus>4</bus>",
            "          <slot>16</slot>",
            "          <function>7</function>",
            "          <product id='0x1520'>I350 Ethernet Controller Virtual Function",
            "            </product>",
            "          <vendor id='0x8086'>Intel Corporation</vendor>",
            "          <capability type='phys_function'>",
            "             <address domain='0x0000' bus='0x04' slot='0x00' function='0x3'/>",
            "          </capability>",
            "          <capability type='virt_functions'>",
            "          </capability>",
            "        </capability>",
            "    </device>\"\"\",",
            "    \"pci_0000_04_11_7\": \"\"\"",
            "      <device>",
            "         <name>pci_0000_04_11_7</name>",
            "         <parent>pci_0000_00_01_1</parent>",
            "         <driver>",
            "         <name>igbvf</name>",
            "         </driver>",
            "         <capability type='pci'>",
            "          <domain>0</domain>",
            "          <bus>4</bus>",
            "          <slot>17</slot>",
            "          <function>7</function>",
            "          <product id='0x1520'>I350 Ethernet Controller Virtual Function",
            "            </product>",
            "          <vendor id='0x8086'>Intel Corporation</vendor>",
            "          <numa node='0'/>",
            "          <capability type='phys_function'>",
            "             <address domain='0x0000' bus='0x04' slot='0x00' function='0x3'/>",
            "          </capability>",
            "          <capability type='virt_functions'>",
            "          </capability>",
            "        </capability>",
            "    </device>\"\"\",",
            "    \"pci_0000_04_00_1\": \"\"\"",
            "    <device>",
            "      <name>pci_0000_04_00_1</name>",
            "      <path>/sys/devices/pci0000:00/0000:00:02.0/0000:04:00.1</path>",
            "      <parent>pci_0000_00_02_0</parent>",
            "      <driver>",
            "        <name>mlx5_core</name>",
            "      </driver>",
            "      <capability type='pci'>",
            "        <domain>0</domain>",
            "        <bus>4</bus>",
            "        <slot>0</slot>",
            "        <function>1</function>",
            "        <product id='0x1013'>MT27700 Family [ConnectX-4]</product>",
            "        <vendor id='0x15b3'>Mellanox Technologies</vendor>",
            "        <iommuGroup number='15'>",
            "          <address domain='0x0000' bus='0x03' slot='0x00' function='0x0'/>",
            "          <address domain='0x0000' bus='0x03' slot='0x00' function='0x1'/>",
            "        </iommuGroup>",
            "        <numa node='0'/>",
            "        <pci-express>",
            "          <link validity='cap' port='0' speed='8' width='16'/>",
            "          <link validity='sta' speed='8' width='16'/>",
            "        </pci-express>",
            "      </capability>",
            "    </device>\"\"\",",
            "    # libvirt  >= 1.3.0 nodedev-dumpxml",
            "    \"pci_0000_03_00_0\": \"\"\"",
            "    <device>",
            "        <name>pci_0000_03_00_0</name>",
            "        <path>/sys/devices/pci0000:00/0000:00:02.0/0000:03:00.0</path>",
            "        <parent>pci_0000_00_02_0</parent>",
            "        <driver>",
            "        <name>mlx5_core</name>",
            "        </driver>",
            "        <capability type='pci'>",
            "        <domain>0</domain>",
            "        <bus>3</bus>",
            "        <slot>0</slot>",
            "        <function>0</function>",
            "        <product id='0x1013'>MT27700 Family [ConnectX-4]</product>",
            "        <vendor id='0x15b3'>Mellanox Technologies</vendor>",
            "        <capability type='virt_functions' maxCount='16'>",
            "          <address domain='0x0000' bus='0x03' slot='0x00' function='0x2'/>",
            "          <address domain='0x0000' bus='0x03' slot='0x00' function='0x3'/>",
            "          <address domain='0x0000' bus='0x03' slot='0x00' function='0x4'/>",
            "          <address domain='0x0000' bus='0x03' slot='0x00' function='0x5'/>",
            "        </capability>",
            "        <iommuGroup number='15'>",
            "          <address domain='0x0000' bus='0x03' slot='0x00' function='0x0'/>",
            "          <address domain='0x0000' bus='0x03' slot='0x00' function='0x1'/>",
            "        </iommuGroup>",
            "        <numa node='0'/>",
            "        <pci-express>",
            "          <link validity='cap' port='0' speed='8' width='16'/>",
            "          <link validity='sta' speed='8' width='16'/>",
            "        </pci-express>",
            "      </capability>",
            "    </device>\"\"\",",
            "    \"pci_0000_03_00_1\": \"\"\"",
            "    <device>",
            "      <name>pci_0000_03_00_1</name>",
            "      <path>/sys/devices/pci0000:00/0000:00:02.0/0000:03:00.1</path>",
            "      <parent>pci_0000_00_02_0</parent>",
            "      <driver>",
            "        <name>mlx5_core</name>",
            "      </driver>",
            "      <capability type='pci'>",
            "        <domain>0</domain>",
            "        <bus>3</bus>",
            "        <slot>0</slot>",
            "        <function>1</function>",
            "        <product id='0x1013'>MT27700 Family [ConnectX-4]</product>",
            "        <vendor id='0x15b3'>Mellanox Technologies</vendor>",
            "        <capability type='virt_functions' maxCount='16'/>",
            "        <iommuGroup number='15'>",
            "          <address domain='0x0000' bus='0x03' slot='0x00' function='0x0'/>",
            "          <address domain='0x0000' bus='0x03' slot='0x00' function='0x1'/>",
            "        </iommuGroup>",
            "        <numa node='0'/>",
            "        <pci-express>",
            "          <link validity='cap' port='0' speed='8' width='16'/>",
            "          <link validity='sta' speed='8' width='16'/>",
            "        </pci-express>",
            "      </capability>",
            "    </device>\"\"\",",
            "    }",
            "",
            "_fake_cpu_info = {",
            "    \"arch\": \"test_arch\",",
            "    \"model\": \"test_model\",",
            "    \"vendor\": \"test_vendor\",",
            "    \"topology\": {",
            "        \"sockets\": 1,",
            "        \"cores\": 8,",
            "        \"threads\": 16",
            "    },",
            "    \"features\": [\"feature1\", \"feature2\"]",
            "}",
            "",
            "",
            "def _concurrency(signal, wait, done, target, is_block_dev=False):",
            "    signal.send()",
            "    wait.wait()",
            "    done.send()",
            "",
            "",
            "class FakeVirtDomain(object):",
            "",
            "    def __init__(self, fake_xml=None, uuidstr=None, id=None, name=None):",
            "        if uuidstr is None:",
            "            uuidstr = str(uuid.uuid4())",
            "        self.uuidstr = uuidstr",
            "        self.id = id",
            "        self.domname = name",
            "        self._info = [power_state.RUNNING, 2048 * units.Mi, 1234 * units.Mi,",
            "                     None, None]",
            "        if fake_xml:",
            "            self._fake_dom_xml = fake_xml",
            "        else:",
            "            self._fake_dom_xml = \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                        </disk>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\"",
            "",
            "    def name(self):",
            "        if self.domname is None:",
            "            return \"fake-domain %s\" % self",
            "        else:",
            "            return self.domname",
            "",
            "    def ID(self):",
            "        return self.id",
            "",
            "    def info(self):",
            "        return self._info",
            "",
            "    def create(self):",
            "        pass",
            "",
            "    def managedSave(self, *args):",
            "        pass",
            "",
            "    def createWithFlags(self, launch_flags):",
            "        pass",
            "",
            "    def XMLDesc(self, flags):",
            "        return self._fake_dom_xml",
            "",
            "    def UUIDString(self):",
            "        return self.uuidstr",
            "",
            "    def attachDeviceFlags(self, xml, flags):",
            "        pass",
            "",
            "    def attachDevice(self, xml):",
            "        pass",
            "",
            "    def detachDeviceFlags(self, xml, flags):",
            "        pass",
            "",
            "    def snapshotCreateXML(self, xml, flags):",
            "        pass",
            "",
            "    def blockCommit(self, disk, base, top, bandwidth=0, flags=0):",
            "        pass",
            "",
            "    def blockRebase(self, disk, base, bandwidth=0, flags=0):",
            "        pass",
            "",
            "    def blockJobInfo(self, path, flags):",
            "        pass",
            "",
            "    def resume(self):",
            "        pass",
            "",
            "    def destroy(self):",
            "        pass",
            "",
            "    def fsFreeze(self, disks=None, flags=0):",
            "        pass",
            "",
            "    def fsThaw(self, disks=None, flags=0):",
            "        pass",
            "",
            "    def isActive(self):",
            "        return True",
            "",
            "",
            "class CacheConcurrencyTestCase(test.NoDBTestCase):",
            "    def setUp(self):",
            "        super(CacheConcurrencyTestCase, self).setUp()",
            "",
            "        self.flags(instances_path=self.useFixture(fixtures.TempDir()).path)",
            "",
            "        # utils.synchronized() will create the lock_path for us if it",
            "        # doesn't already exist. It will also delete it when it's done,",
            "        # which can cause race conditions with the multiple threads we",
            "        # use for tests. So, create the path here so utils.synchronized()",
            "        # won't delete it out from under one of the threads.",
            "        self.lock_path = os.path.join(CONF.instances_path, 'locks')",
            "        fileutils.ensure_tree(self.lock_path)",
            "",
            "        def fake_exists(fname):",
            "            basedir = os.path.join(CONF.instances_path,",
            "                                   CONF.image_cache_subdirectory_name)",
            "            if fname == basedir or fname == self.lock_path:",
            "                return True",
            "            return False",
            "",
            "        def fake_execute(*args, **kwargs):",
            "            pass",
            "",
            "        def fake_extend(image, size, use_cow=False):",
            "            pass",
            "",
            "        self.stub_out('os.path.exists', fake_exists)",
            "        self.stubs.Set(utils, 'execute', fake_execute)",
            "        self.stubs.Set(imagebackend.disk, 'extend', fake_extend)",
            "        self.useFixture(fixtures.MonkeyPatch(",
            "            'nova.virt.libvirt.imagebackend.libvirt_utils',",
            "            fake_libvirt_utils))",
            "",
            "    def _fake_instance(self, uuid):",
            "        return objects.Instance(id=1, uuid=uuid)",
            "",
            "    def test_same_fname_concurrency(self):",
            "        # Ensures that the same fname cache runs at a sequentially.",
            "        uuid = uuidutils.generate_uuid()",
            "",
            "        backend = imagebackend.Backend(False)",
            "        wait1 = eventlet.event.Event()",
            "        done1 = eventlet.event.Event()",
            "        sig1 = eventlet.event.Event()",
            "        thr1 = eventlet.spawn(backend.image(self._fake_instance(uuid),",
            "                                            'name').cache,",
            "                _concurrency, 'fname', None,",
            "                signal=sig1, wait=wait1, done=done1)",
            "        eventlet.sleep(0)",
            "        # Thread 1 should run before thread 2.",
            "        sig1.wait()",
            "",
            "        wait2 = eventlet.event.Event()",
            "        done2 = eventlet.event.Event()",
            "        sig2 = eventlet.event.Event()",
            "        thr2 = eventlet.spawn(backend.image(self._fake_instance(uuid),",
            "                                            'name').cache,",
            "                _concurrency, 'fname', None,",
            "                signal=sig2, wait=wait2, done=done2)",
            "",
            "        wait2.send()",
            "        eventlet.sleep(0)",
            "        try:",
            "            self.assertFalse(done2.ready())",
            "        finally:",
            "            wait1.send()",
            "        done1.wait()",
            "        eventlet.sleep(0)",
            "        self.assertTrue(done2.ready())",
            "        # Wait on greenthreads to assert they didn't raise exceptions",
            "        # during execution",
            "        thr1.wait()",
            "        thr2.wait()",
            "",
            "    def test_different_fname_concurrency(self):",
            "        # Ensures that two different fname caches are concurrent.",
            "        uuid = uuidutils.generate_uuid()",
            "",
            "        backend = imagebackend.Backend(False)",
            "        wait1 = eventlet.event.Event()",
            "        done1 = eventlet.event.Event()",
            "        sig1 = eventlet.event.Event()",
            "        thr1 = eventlet.spawn(backend.image(self._fake_instance(uuid),",
            "                                            'name').cache,",
            "                _concurrency, 'fname2', None,",
            "                signal=sig1, wait=wait1, done=done1)",
            "        eventlet.sleep(0)",
            "        # Thread 1 should run before thread 2.",
            "        sig1.wait()",
            "",
            "        wait2 = eventlet.event.Event()",
            "        done2 = eventlet.event.Event()",
            "        sig2 = eventlet.event.Event()",
            "        thr2 = eventlet.spawn(backend.image(self._fake_instance(uuid),",
            "                                            'name').cache,",
            "                _concurrency, 'fname1', None,",
            "                signal=sig2, wait=wait2, done=done2)",
            "        eventlet.sleep(0)",
            "        # Wait for thread 2 to start.",
            "        sig2.wait()",
            "",
            "        wait2.send()",
            "        tries = 0",
            "        while not done2.ready() and tries < 10:",
            "            eventlet.sleep(0)",
            "            tries += 1",
            "        try:",
            "            self.assertTrue(done2.ready())",
            "        finally:",
            "            wait1.send()",
            "            eventlet.sleep(0)",
            "        # Wait on greenthreads to assert they didn't raise exceptions",
            "        # during execution",
            "        thr1.wait()",
            "        thr2.wait()",
            "",
            "",
            "class FakeVolumeDriver(object):",
            "    def __init__(self, *args, **kwargs):",
            "        pass",
            "",
            "    def attach_volume(self, *args):",
            "        pass",
            "",
            "    def detach_volume(self, *args):",
            "        pass",
            "",
            "    def get_xml(self, *args):",
            "        return \"\"",
            "",
            "    def get_config(self, *args):",
            "        \"\"\"Connect the volume to a fake device.\"\"\"",
            "        conf = vconfig.LibvirtConfigGuestDisk()",
            "        conf.source_type = \"network\"",
            "        conf.source_protocol = \"fake\"",
            "        conf.source_name = \"fake\"",
            "        conf.target_dev = \"fake\"",
            "        conf.target_bus = \"fake\"",
            "        return conf",
            "",
            "    def connect_volume(self, *args):",
            "        \"\"\"Connect the volume to a fake device.\"\"\"",
            "        pass",
            "",
            "",
            "class FakeConfigGuestDisk(object):",
            "    def __init__(self, *args, **kwargs):",
            "        self.source_type = None",
            "        self.driver_cache = None",
            "",
            "",
            "class FakeConfigGuest(object):",
            "    def __init__(self, *args, **kwargs):",
            "        self.driver_cache = None",
            "",
            "",
            "class FakeNodeDevice(object):",
            "    def __init__(self, fakexml):",
            "        self.xml = fakexml",
            "",
            "    def XMLDesc(self, flags):",
            "        return self.xml",
            "",
            "",
            "def _create_test_instance():",
            "    flavor = objects.Flavor(memory_mb=2048,",
            "                            swap=0,",
            "                            vcpu_weight=None,",
            "                            root_gb=1,",
            "                            id=2,",
            "                            name=u'm1.small',",
            "                            ephemeral_gb=0,",
            "                            rxtx_factor=1.0,",
            "                            flavorid=u'1',",
            "                            vcpus=1,",
            "                            extra_specs={})",
            "    return {",
            "        'id': 1,",
            "        'uuid': '32dfcb37-5af1-552b-357c-be8c3aa38310',",
            "        'memory_kb': '1024000',",
            "        'basepath': '/some/path',",
            "        'bridge_name': 'br100',",
            "        'display_name': \"Acme webserver\",",
            "        'vcpus': 2,",
            "        'project_id': 'fake',",
            "        'bridge': 'br101',",
            "        'image_ref': '155d900f-4e14-4e4c-a73d-069cbf4541e6',",
            "        'root_gb': 10,",
            "        'ephemeral_gb': 20,",
            "        'instance_type_id': '5',  # m1.small",
            "        'extra_specs': {},",
            "        'system_metadata': {",
            "            'image_disk_format': 'raw',",
            "        },",
            "        'flavor': flavor,",
            "        'new_flavor': None,",
            "        'old_flavor': None,",
            "        'pci_devices': objects.PciDeviceList(),",
            "        'numa_topology': None,",
            "        'config_drive': None,",
            "        'vm_mode': None,",
            "        'kernel_id': None,",
            "        'ramdisk_id': None,",
            "        'os_type': 'linux',",
            "        'user_id': '838a72b0-0d54-4827-8fd6-fb1227633ceb',",
            "        'ephemeral_key_uuid': None,",
            "        'vcpu_model': None,",
            "        'host': 'fake-host',",
            "        'task_state': None,",
            "    }",
            "",
            "",
            "class LibvirtConnTestCase(test.NoDBTestCase):",
            "",
            "    REQUIRES_LOCKING = True",
            "",
            "    _EPHEMERAL_20_DEFAULT = ('ephemeral_20_%s' %",
            "                             utils.get_hash_str(disk._DEFAULT_FILE_SYSTEM)[:7])",
            "",
            "    def setUp(self):",
            "        super(LibvirtConnTestCase, self).setUp()",
            "        self.flags(fake_call=True)",
            "        self.user_id = 'fake'",
            "        self.project_id = 'fake'",
            "        self.context = context.get_admin_context()",
            "        temp_dir = self.useFixture(fixtures.TempDir()).path",
            "        self.flags(instances_path=temp_dir)",
            "        self.flags(snapshots_directory=temp_dir, group='libvirt')",
            "        self.useFixture(fixtures.MonkeyPatch(",
            "            'nova.virt.libvirt.driver.libvirt_utils',",
            "            fake_libvirt_utils))",
            "",
            "        self.flags(sysinfo_serial=\"hardware\", group=\"libvirt\")",
            "",
            "        self.useFixture(fixtures.MonkeyPatch(",
            "            'nova.virt.libvirt.imagebackend.libvirt_utils',",
            "            fake_libvirt_utils))",
            "",
            "        def fake_extend(image, size, use_cow=False):",
            "            pass",
            "",
            "        self.stubs.Set(libvirt_driver.disk, 'extend', fake_extend)",
            "",
            "        self.stubs.Set(imagebackend.Image, 'resolve_driver_format',",
            "                       imagebackend.Image._get_driver_format)",
            "",
            "        self.useFixture(fakelibvirt.FakeLibvirtFixture())",
            "        self.test_instance = _create_test_instance()",
            "        self.test_image_meta = {",
            "            \"disk_format\": \"raw\",",
            "        }",
            "        self.image_service = nova.tests.unit.image.fake.stub_out_image_service(",
            "                self)",
            "        self.device_xml_tmpl = \"\"\"",
            "        <domain type='kvm'>",
            "          <devices>",
            "            <disk type='block' device='disk'>",
            "              <driver name='qemu' type='raw' cache='none'/>",
            "              <source dev='{device_path}'/>",
            "              <target bus='virtio' dev='vdb'/>",
            "              <serial>58a84f6d-3f0c-4e19-a0af-eb657b790657</serial>",
            "              <address type='pci' domain='0x0' bus='0x0' slot='0x04' \\",
            "              function='0x0'/>",
            "            </disk>",
            "          </devices>",
            "        </domain>",
            "        \"\"\"",
            "",
            "    def relpath(self, path):",
            "        return os.path.relpath(path, CONF.instances_path)",
            "",
            "    def tearDown(self):",
            "        nova.tests.unit.image.fake.FakeImageService_reset()",
            "        super(LibvirtConnTestCase, self).tearDown()",
            "",
            "    def test_driver_capabilities(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertTrue(drvr.capabilities['has_imagecache'],",
            "                        'Driver capabilities for \\'has_imagecache\\' '",
            "                        'is invalid')",
            "        self.assertTrue(drvr.capabilities['supports_recreate'],",
            "                        'Driver capabilities for \\'supports_recreate\\' '",
            "                        'is invalid')",
            "        self.assertFalse(drvr.capabilities['supports_migrate_to_same_host'],",
            "                         'Driver capabilities for '",
            "                         '\\'supports_migrate_to_same_host\\' is invalid')",
            "",
            "    def create_fake_libvirt_mock(self, **kwargs):",
            "        \"\"\"Defining mocks for LibvirtDriver(libvirt is not used).\"\"\"",
            "",
            "        # A fake libvirt.virConnect",
            "        class FakeLibvirtDriver(object):",
            "            def defineXML(self, xml):",
            "                return FakeVirtDomain()",
            "",
            "        # Creating mocks",
            "        volume_driver = ['iscsi=nova.tests.unit.virt.libvirt.test_driver'",
            "                         '.FakeVolumeDriver']",
            "        fake = FakeLibvirtDriver()",
            "        # Customizing above fake if necessary",
            "        for key, val in kwargs.items():",
            "            fake.__setattr__(key, val)",
            "",
            "        self.stubs.Set(libvirt_driver.LibvirtDriver, '_conn', fake)",
            "        self.stubs.Set(libvirt_driver.LibvirtDriver, '_get_volume_drivers',",
            "            lambda x: volume_driver)",
            "        self.stubs.Set(host.Host, 'get_connection', lambda x: fake)",
            "",
            "    def fake_lookup(self, instance_name):",
            "        return FakeVirtDomain()",
            "",
            "    def fake_execute(self, *args, **kwargs):",
            "        open(args[-1], \"a\").close()",
            "",
            "    def _create_service(self, **kwargs):",
            "        service_ref = {'host': kwargs.get('host', 'dummy'),",
            "                       'disabled': kwargs.get('disabled', False),",
            "                       'binary': 'nova-compute',",
            "                       'topic': 'compute',",
            "                       'report_count': 0}",
            "",
            "        return objects.Service(**service_ref)",
            "",
            "    def _get_pause_flag(self, drvr, network_info, power_on=True,",
            "                          vifs_already_plugged=False):",
            "        timeout = CONF.vif_plugging_timeout",
            "",
            "        events = []",
            "        if (drvr._conn_supports_start_paused and",
            "            utils.is_neutron() and",
            "            not vifs_already_plugged and",
            "            power_on and timeout):",
            "            events = drvr._get_neutron_events(network_info)",
            "",
            "        return bool(events)",
            "",
            "    def test_public_api_signatures(self):",
            "        baseinst = driver.ComputeDriver(None)",
            "        inst = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertPublicAPISignatures(baseinst, inst)",
            "",
            "    def test_legacy_block_device_info(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertFalse(drvr.need_legacy_block_device_info)",
            "",
            "    @mock.patch.object(host.Host, \"has_min_version\")",
            "    def test_min_version_start_ok(self, mock_version):",
            "        mock_version.return_value = True",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        drvr.init_host(\"dummyhost\")",
            "",
            "    @mock.patch.object(host.Host, \"has_min_version\")",
            "    def test_min_version_start_abort(self, mock_version):",
            "        mock_version.return_value = False",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertRaises(exception.NovaException,",
            "                          drvr.init_host,",
            "                          \"dummyhost\")",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                            libvirt_driver.NEXT_MIN_LIBVIRT_VERSION) - 1)",
            "    @mock.patch.object(libvirt_driver.LOG, 'warning')",
            "    def test_next_min_version_deprecation_warning(self, mock_warning,",
            "                                                  mock_get_libversion):",
            "        # Skip test if there's no currently planned new min version",
            "        if (versionutils.convert_version_to_int(",
            "                libvirt_driver.NEXT_MIN_LIBVIRT_VERSION) ==",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_VERSION)):",
            "            self.skipTest(\"NEXT_MIN_LIBVIRT_VERSION == MIN_LIBVIRT_VERSION\")",
            "",
            "        # Test that a warning is logged if the libvirt version is less than",
            "        # the next required minimum version.",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        drvr.init_host(\"dummyhost\")",
            "        # assert that the next min version is in a warning message",
            "        expected_arg = {'version': versionutils.convert_version_to_str(",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.NEXT_MIN_LIBVIRT_VERSION))}",
            "        version_arg_found = False",
            "        for call in mock_warning.call_args_list:",
            "            if call[0][1] == expected_arg:",
            "                version_arg_found = True",
            "                break",
            "        self.assertTrue(version_arg_found)",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                            libvirt_driver.NEXT_MIN_LIBVIRT_VERSION))",
            "    @mock.patch.object(libvirt_driver.LOG, 'warning')",
            "    def test_next_min_version_ok(self, mock_warning, mock_get_libversion):",
            "        # Skip test if there's no currently planned new min version",
            "",
            "        if (versionutils.convert_version_to_int(",
            "                libvirt_driver.NEXT_MIN_LIBVIRT_VERSION) ==",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_VERSION)):",
            "            self.skipTest(\"NEXT_MIN_LIBVIRT_VERSION == MIN_LIBVIRT_VERSION\")",
            "",
            "        # Test that a warning is not logged if the libvirt version is greater",
            "        # than or equal to NEXT_MIN_LIBVIRT_VERSION.",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        drvr.init_host(\"dummyhost\")",
            "        # assert that the next min version is in a warning message",
            "        expected_arg = {'version': versionutils.convert_version_to_str(",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.NEXT_MIN_LIBVIRT_VERSION))}",
            "        version_arg_found = False",
            "        for call in mock_warning.call_args_list:",
            "            if call[0][1] == expected_arg:",
            "                version_arg_found = True",
            "                break",
            "        self.assertFalse(version_arg_found)",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_LIBVIRT_OTHER_ARCH.get(",
            "                               arch.PPC64)) - 1)",
            "    @mock.patch.object(fakelibvirt.Connection, 'getVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_QEMU_OTHER_ARCH.get(",
            "                               arch.PPC64)))",
            "    @mock.patch.object(arch, \"from_host\", return_value=arch.PPC64)",
            "    def test_min_version_ppc_old_libvirt(self, mock_libv, mock_qemu,",
            "                                         mock_arch):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertRaises(exception.NovaException,",
            "                          drvr.init_host,",
            "                          \"dummyhost\")",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_LIBVIRT_OTHER_ARCH.get(",
            "                               arch.PPC64)))",
            "    @mock.patch.object(fakelibvirt.Connection, 'getVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_QEMU_OTHER_ARCH.get(",
            "                               arch.PPC64)) - 1)",
            "    @mock.patch.object(arch, \"from_host\", return_value=arch.PPC64)",
            "    def test_min_version_ppc_old_qemu(self, mock_libv, mock_qemu,",
            "                                      mock_arch):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertRaises(exception.NovaException,",
            "                          drvr.init_host,",
            "                          \"dummyhost\")",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_LIBVIRT_OTHER_ARCH.get(",
            "                               arch.PPC64)))",
            "    @mock.patch.object(fakelibvirt.Connection, 'getVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_QEMU_OTHER_ARCH.get(",
            "                               arch.PPC64)))",
            "    @mock.patch.object(arch, \"from_host\", return_value=arch.PPC64)",
            "    def test_min_version_ppc_ok(self, mock_libv, mock_qemu, mock_arch):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        drvr.init_host(\"dummyhost\")",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_LIBVIRT_OTHER_ARCH.get(",
            "                               arch.S390X)) - 1)",
            "    @mock.patch.object(fakelibvirt.Connection, 'getVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_QEMU_OTHER_ARCH.get(",
            "                               arch.S390X)))",
            "    @mock.patch.object(arch, \"from_host\", return_value=arch.S390X)",
            "    def test_min_version_s390_old_libvirt(self, mock_libv, mock_qemu,",
            "                                          mock_arch):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertRaises(exception.NovaException,",
            "                          drvr.init_host,",
            "                          \"dummyhost\")",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_LIBVIRT_OTHER_ARCH.get(",
            "                               arch.S390X)))",
            "    @mock.patch.object(fakelibvirt.Connection, 'getVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_QEMU_OTHER_ARCH.get(",
            "                               arch.S390X)) - 1)",
            "    @mock.patch.object(arch, \"from_host\", return_value=arch.S390X)",
            "    def test_min_version_s390_old_qemu(self, mock_libv, mock_qemu,",
            "                                       mock_arch):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertRaises(exception.NovaException,",
            "                          drvr.init_host,",
            "                          \"dummyhost\")",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_LIBVIRT_OTHER_ARCH.get(",
            "                               arch.S390X)))",
            "    @mock.patch.object(fakelibvirt.Connection, 'getVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_QEMU_OTHER_ARCH.get(",
            "                               arch.S390X)))",
            "    @mock.patch.object(arch, \"from_host\", return_value=arch.S390X)",
            "    def test_min_version_s390_ok(self, mock_libv, mock_qemu, mock_arch):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        drvr.init_host(\"dummyhost\")",
            "",
            "    def _do_test_parse_migration_flags(self, lm_config=None, lm_expected=None,",
            "                                       bm_config=None, bm_expected=None):",
            "        if lm_config is not None:",
            "            self.flags(live_migration_flag=lm_config, group='libvirt')",
            "        if bm_config is not None:",
            "            self.flags(block_migration_flag=bm_config, group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        drvr._parse_migration_flags()",
            "",
            "        if lm_expected is not None:",
            "            self.assertEqual(lm_expected, drvr._live_migration_flags)",
            "        if bm_expected is not None:",
            "            self.assertEqual(bm_expected, drvr._block_migration_flags)",
            "",
            "    def test_parse_live_migration_flags_default(self):",
            "        self._do_test_parse_migration_flags(",
            "            lm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, VIR_MIGRATE_TUNNELLED'),",
            "            lm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED))",
            "",
            "    def test_parse_live_migration_flags(self):",
            "        self._do_test_parse_migration_flags(",
            "            lm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE'),",
            "            lm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE))",
            "",
            "    def test_parse_block_migration_flags_default(self):",
            "        self._do_test_parse_migration_flags(",
            "            bm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, VIR_MIGRATE_TUNNELLED, '",
            "                       'VIR_MIGRATE_NON_SHARED_INC'),",
            "            bm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_NON_SHARED_INC))",
            "",
            "    def test_parse_block_migration_flags(self):",
            "        self._do_test_parse_migration_flags(",
            "            bm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, VIR_MIGRATE_NON_SHARED_INC'),",
            "            bm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_NON_SHARED_INC))",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG')",
            "    def test_parse_live_migration_flag_with_invalid_flag(self, mock_log):",
            "        self._do_test_parse_migration_flags(",
            "            lm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, VIR_MIGRATE_TUNNELLED, '",
            "                       'VIR_MIGRATE_FOO_BAR'),",
            "            lm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED),",
            "            bm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, VIR_MIGRATE_TUNNELLED, '",
            "                       'VIR_MIGRATE_NON_SHARED_INC, VIR_MIGRATE_FOO_BAR'),",
            "            bm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_NON_SHARED_INC))",
            "",
            "        msg = mock_log.warning.call_args_list[0]",
            "        self.assertIn(\"unknown libvirt live migration flag\", msg[0][0])",
            "        msg = mock_log.warning.call_args_list[1]",
            "        self.assertIn(\"unknown libvirt live migration flag\", msg[0][0])",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG')",
            "    def test_parse_migration_flags_unsafe_block(self, mock_log):",
            "        '''Test if the driver logs a warning if the live_migration_flag",
            "        and/or block_migration_flag config option uses a value which can",
            "        cause potential damage.",
            "        '''",
            "        self._do_test_parse_migration_flags(",
            "            lm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, '",
            "                       'VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, '",
            "                       'VIR_MIGRATE_TUNNELLED, '",
            "                       'VIR_MIGRATE_NON_SHARED_INC'),",
            "            bm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, '",
            "                       'VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, '",
            "                       'VIR_MIGRATE_TUNNELLED'),",
            "            lm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED),",
            "            bm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_NON_SHARED_INC))",
            "",
            "        msg = mock_log.warning.call_args_list[0]",
            "        self.assertIn('Removing the VIR_MIGRATE_NON_SHARED_INC', msg[0][0])",
            "        msg = mock_log.warning.call_args_list[1]",
            "        self.assertIn('Adding the VIR_MIGRATE_NON_SHARED_INC', msg[0][0])",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG')",
            "    def test_parse_migration_flags_p2p_missing(self, mock_log):",
            "        self._do_test_parse_migration_flags(",
            "            lm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, '",
            "                       'VIR_MIGRATE_LIVE, '",
            "                       'VIR_MIGRATE_TUNNELLED'),",
            "            bm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, '",
            "                       'VIR_MIGRATE_LIVE, '",
            "                       'VIR_MIGRATE_TUNNELLED, '",
            "                       'VIR_MIGRATE_NON_SHARED_INC'),",
            "            lm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED),",
            "            bm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_NON_SHARED_INC))",
            "",
            "        msg = mock_log.warning.call_args_list[0]",
            "        self.assertIn('Adding the VIR_MIGRATE_PEER2PEER flag', msg[0][0])",
            "        msg = mock_log.warning.call_args_list[1]",
            "        self.assertIn('Adding the VIR_MIGRATE_PEER2PEER flag', msg[0][0])",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG')",
            "    def test_parse_migration_flags_p2p_xen(self, mock_log):",
            "        self.flags(virt_type='xen', group='libvirt')",
            "",
            "        self._do_test_parse_migration_flags(",
            "            lm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, '",
            "                       'VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, '",
            "                       'VIR_MIGRATE_TUNNELLED'),",
            "            bm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, '",
            "                       'VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, '",
            "                       'VIR_MIGRATE_TUNNELLED, '",
            "                       'VIR_MIGRATE_NON_SHARED_INC'),",
            "            lm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED),",
            "            bm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_NON_SHARED_INC))",
            "",
            "        msg = mock_log.warning.call_args_list[0]",
            "        self.assertIn('Removing the VIR_MIGRATE_PEER2PEER flag', msg[0][0])",
            "        msg = mock_log.warning.call_args_list[1]",
            "        self.assertIn('Removing the VIR_MIGRATE_PEER2PEER flag', msg[0][0])",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG')",
            "    def test_parse_migration_flags_config_mgmt(self, mock_log):",
            "        self._do_test_parse_migration_flags(",
            "            lm_config=('VIR_MIGRATE_PERSIST_DEST, '",
            "                       'VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, '",
            "                       'VIR_MIGRATE_TUNNELLED'),",
            "            bm_config=('VIR_MIGRATE_PERSIST_DEST, '",
            "                       'VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, '",
            "                       'VIR_MIGRATE_TUNNELLED, '",
            "                       'VIR_MIGRATE_NON_SHARED_INC'),",
            "            lm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED),",
            "            bm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_NON_SHARED_INC))",
            "",
            "        msg = mock_log.warning.call_args_list[0]",
            "        self.assertIn('Adding the VIR_MIGRATE_UNDEFINE_SOURCE flag', msg[0][0])",
            "        msg = mock_log.warning.call_args_list[1]",
            "        self.assertIn('Removing the VIR_MIGRATE_PERSIST_DEST flag', msg[0][0])",
            "        msg = mock_log.warning.call_args_list[2]",
            "        self.assertIn('Adding the VIR_MIGRATE_UNDEFINE_SOURCE flag', msg[0][0])",
            "        msg = mock_log.warning.call_args_list[3]",
            "        self.assertIn('Removing the VIR_MIGRATE_PERSIST_DEST flag', msg[0][0])",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG')",
            "    def test_live_migration_tunnelled_true(self, mock_log):",
            "        self.flags(live_migration_tunnelled=True, group='libvirt')",
            "",
            "        self._do_test_parse_migration_flags(",
            "            lm_config=('VIR_MIGRATE_PEER2PEER, VIR_MIGRATE_UNDEFINE_SOURCE, '",
            "                       'VIR_MIGRATE_LIVE'),",
            "            bm_config=('VIR_MIGRATE_PEER2PEER, VIR_MIGRATE_UNDEFINE_SOURCE, '",
            "                       'VIR_MIGRATE_LIVE, VIR_MIGRATE_NON_SHARED_INC'),",
            "            lm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED),",
            "            bm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_NON_SHARED_INC |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED))",
            "",
            "        msg = mock_log.warning.call_args_list[0]",
            "        self.assertIn('does not contain the VIR_MIGRATE_TUNNELLED', msg[0][0])",
            "        msg = mock_log.warning.call_args_list[1]",
            "        self.assertIn('does not contain the VIR_MIGRATE_TUNNELLED', msg[0][0])",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG')",
            "    def test_live_migration_tunnelled_false(self, mock_log):",
            "        self.flags(live_migration_tunnelled=False, group='libvirt')",
            "",
            "        self._do_test_parse_migration_flags(",
            "            lm_config=('VIR_MIGRATE_PEER2PEER, VIR_MIGRATE_UNDEFINE_SOURCE, '",
            "                       'VIR_MIGRATE_LIVE, VIR_MIGRATE_TUNNELLED'),",
            "            bm_config=('VIR_MIGRATE_PEER2PEER, VIR_MIGRATE_UNDEFINE_SOURCE, '",
            "                       'VIR_MIGRATE_LIVE, VIR_MIGRATE_NON_SHARED_INC, '",
            "                       'VIR_MIGRATE_TUNNELLED'),",
            "            lm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE),",
            "            bm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_NON_SHARED_INC))",
            "",
            "        msg = mock_log.warning.call_args_list[0]",
            "        self.assertIn('contains the VIR_MIGRATE_TUNNELLED flag', msg[0][0])",
            "        msg = mock_log.warning.call_args_list[1]",
            "        self.assertIn('contains the VIR_MIGRATE_TUNNELLED flag', msg[0][0])",
            "",
            "    @mock.patch('nova.utils.get_image_from_system_metadata')",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_guest')",
            "    def test_set_admin_password(self, mock_get_guest, ver, mock_image):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_image.return_value = {\"properties\": {",
            "            \"hw_qemu_guest_agent\": \"yes\"}}",
            "        mock_guest = mock.Mock(spec=libvirt_guest.Guest)",
            "        mock_get_guest.return_value = mock_guest",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        drvr.set_admin_password(instance, \"123\")",
            "",
            "        mock_guest.set_user_password.assert_called_once_with(\"root\", \"123\")",
            "",
            "    @mock.patch('nova.utils.get_image_from_system_metadata')",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_guest')",
            "    def test_set_admin_password_windows(self, mock_get_guest, ver, mock_image):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        instance = objects.Instance(**self.test_instance)",
            "        instance.os_type = \"windows\"",
            "        mock_image.return_value = {\"properties\": {",
            "            \"hw_qemu_guest_agent\": \"yes\"}}",
            "        mock_guest = mock.Mock(spec=libvirt_guest.Guest)",
            "        mock_get_guest.return_value = mock_guest",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        drvr.set_admin_password(instance, \"123\")",
            "",
            "        mock_guest.set_user_password.assert_called_once_with(",
            "            \"Administrator\", \"123\")",
            "",
            "    @mock.patch('nova.utils.get_image_from_system_metadata')",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_guest')",
            "    def test_set_admin_password_image(self, mock_get_guest, ver, mock_image):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_image.return_value = {\"properties\": {",
            "            \"hw_qemu_guest_agent\": \"yes\",",
            "            \"os_admin_user\": \"foo\"",
            "        }}",
            "        mock_guest = mock.Mock(spec=libvirt_guest.Guest)",
            "        mock_get_guest.return_value = mock_guest",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        drvr.set_admin_password(instance, \"123\")",
            "",
            "        mock_guest.set_user_password.assert_called_once_with(\"foo\", \"123\")",
            "",
            "    @mock.patch('nova.utils.get_image_from_system_metadata')",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=False)",
            "    def test_set_admin_password_bad_version(self, mock_svc, mock_image):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_image.return_value = {\"properties\": {",
            "            \"hw_qemu_guest_agent\": \"yes\"}}",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertRaises(exception.SetAdminPasswdNotSupported,",
            "                          drvr.set_admin_password, instance, \"123\")",
            "",
            "    @mock.patch('nova.utils.get_image_from_system_metadata')",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    def test_set_admin_password_bad_hyp(self, mock_svc, mock_image):",
            "        self.flags(virt_type='foo', group='libvirt')",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_image.return_value = {\"properties\": {",
            "            \"hw_qemu_guest_agent\": \"yes\"}}",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertRaises(exception.SetAdminPasswdNotSupported,",
            "                          drvr.set_admin_password, instance, \"123\")",
            "",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    def test_set_admin_password_guest_agent_not_running(self, mock_svc):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        instance = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertRaises(exception.QemuGuestAgentNotEnabled,",
            "                          drvr.set_admin_password, instance, \"123\")",
            "",
            "    @mock.patch('nova.utils.get_image_from_system_metadata')",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_guest')",
            "    def test_set_admin_password_error(self, mock_get_guest, ver, mock_image):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_image.return_value = {\"properties\": {",
            "            \"hw_qemu_guest_agent\": \"yes\"}}",
            "        mock_guest = mock.Mock(spec=libvirt_guest.Guest)",
            "        mock_guest.set_user_password.side_effect = (",
            "            fakelibvirt.libvirtError(\"error\"))",
            "        mock_get_guest.return_value = mock_guest",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertRaises(exception.NovaException,",
            "                          drvr.set_admin_password, instance, \"123\")",
            "",
            "    @mock.patch.object(objects.Service, 'get_by_compute_host')",
            "    def test_set_host_enabled_with_disable(self, mock_svc):",
            "        # Tests disabling an enabled host.",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        svc = self._create_service(host='fake-mini')",
            "        mock_svc.return_value = svc",
            "        drvr._set_host_enabled(False)",
            "        self.assertTrue(svc.disabled)",
            "",
            "    @mock.patch.object(objects.Service, 'get_by_compute_host')",
            "    def test_set_host_enabled_with_enable(self, mock_svc):",
            "        # Tests enabling a disabled host.",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        svc = self._create_service(disabled=True, host='fake-mini')",
            "        mock_svc.return_value = svc",
            "        drvr._set_host_enabled(True)",
            "        self.assertTrue(svc.disabled)",
            "",
            "    @mock.patch.object(objects.Service, 'get_by_compute_host')",
            "    def test_set_host_enabled_with_enable_state_enabled(self, mock_svc):",
            "        # Tests enabling an enabled host.",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        svc = self._create_service(disabled=False, host='fake-mini')",
            "        mock_svc.return_value = svc",
            "        drvr._set_host_enabled(True)",
            "        self.assertFalse(svc.disabled)",
            "",
            "    @mock.patch.object(objects.Service, 'get_by_compute_host')",
            "    def test_set_host_enabled_with_disable_state_disabled(self, mock_svc):",
            "        # Tests disabling a disabled host.",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        svc = self._create_service(disabled=True, host='fake-mini')",
            "        mock_svc.return_value = svc",
            "        drvr._set_host_enabled(False)",
            "        self.assertTrue(svc.disabled)",
            "",
            "    def test_set_host_enabled_swallows_exceptions(self):",
            "        # Tests that set_host_enabled will swallow exceptions coming from the",
            "        # db_api code so they don't break anything calling it, e.g. the",
            "        # _get_new_connection method.",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        with mock.patch.object(db, 'service_get_by_compute_host') as db_mock:",
            "            # Make db.service_get_by_compute_host raise NovaException; this",
            "            # is more robust than just raising ComputeHostNotFound.",
            "            db_mock.side_effect = exception.NovaException",
            "            drvr._set_host_enabled(False)",
            "",
            "    @mock.patch.object(fakelibvirt.virConnect, \"nodeDeviceLookupByName\")",
            "    def test_prepare_pci_device(self, mock_lookup):",
            "",
            "        pci_devices = [dict(hypervisor_name='xxx')]",
            "",
            "        self.flags(virt_type='xen', group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        conn = drvr._host.get_connection()",
            "",
            "        mock_lookup.side_effect = lambda x: fakelibvirt.NodeDevice(conn)",
            "        drvr._prepare_pci_devices_for_use(pci_devices)",
            "",
            "    @mock.patch.object(fakelibvirt.virConnect, \"nodeDeviceLookupByName\")",
            "    @mock.patch.object(fakelibvirt.virNodeDevice, \"dettach\")",
            "    def test_prepare_pci_device_exception(self, mock_detach, mock_lookup):",
            "",
            "        pci_devices = [dict(hypervisor_name='xxx',",
            "                            id='id1',",
            "                            instance_uuid='uuid')]",
            "",
            "        self.flags(virt_type='xen', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        conn = drvr._host.get_connection()",
            "",
            "        mock_lookup.side_effect = lambda x: fakelibvirt.NodeDevice(conn)",
            "        mock_detach.side_effect = fakelibvirt.libvirtError(\"xxxx\")",
            "",
            "        self.assertRaises(exception.PciDevicePrepareFailed,",
            "                          drvr._prepare_pci_devices_for_use, pci_devices)",
            "",
            "    def test_detach_pci_devices_exception(self):",
            "",
            "        pci_devices = [dict(hypervisor_name='xxx',",
            "                            id='id1',",
            "                            instance_uuid='uuid')]",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.mox.StubOutWithMock(host.Host,",
            "                                 'has_min_version')",
            "        host.Host.has_min_version = lambda x, y: False",
            "",
            "        self.assertRaises(exception.PciDeviceDetachFailed,",
            "                          drvr._detach_pci_devices, None, pci_devices)",
            "",
            "    def test_detach_pci_devices(self):",
            "",
            "        fake_domXML1 =\\",
            "            \"\"\"<domain> <devices>",
            "            <disk type='file' device='disk'>",
            "            <driver name='qemu' type='qcow2' cache='none'/>",
            "            <source file='xxx'/>",
            "            <target dev='vda' bus='virtio'/>",
            "            <alias name='virtio-disk0'/>",
            "            <address type='pci' domain='0x0000' bus='0x00'",
            "            slot='0x04' function='0x0'/>",
            "            </disk>",
            "            <hostdev mode=\"subsystem\" type=\"pci\" managed=\"yes\">",
            "            <source>",
            "            <address function=\"0x1\" slot=\"0x10\" domain=\"0x0000\"",
            "             bus=\"0x04\"/>",
            "            </source>",
            "            </hostdev></devices></domain>\"\"\"",
            "",
            "        pci_devices = [dict(hypervisor_name='xxx',",
            "                            id='id1',",
            "                            instance_uuid='uuid',",
            "                            address=\"0001:04:10:1\")]",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.mox.StubOutWithMock(host.Host,",
            "                                 'has_min_version')",
            "        host.Host.has_min_version = lambda x, y: True",
            "",
            "        self.mox.StubOutWithMock(libvirt_driver.LibvirtDriver,",
            "                                 '_get_guest_pci_device')",
            "",
            "        class FakeDev(object):",
            "            def to_xml(self):",
            "                pass",
            "",
            "        libvirt_driver.LibvirtDriver._get_guest_pci_device =\\",
            "            lambda x, y: FakeDev()",
            "",
            "        class FakeDomain(object):",
            "            def detachDeviceFlags(self, xml, flags):",
            "                pci_devices[0]['hypervisor_name'] = 'marked'",
            "                pass",
            "",
            "            def XMLDesc(self, flags):",
            "                return fake_domXML1",
            "",
            "        guest = libvirt_guest.Guest(FakeDomain())",
            "        drvr._detach_pci_devices(guest, pci_devices)",
            "        self.assertEqual(pci_devices[0]['hypervisor_name'], 'marked')",
            "",
            "    def test_detach_pci_devices_timeout(self):",
            "",
            "        fake_domXML1 =\\",
            "            \"\"\"<domain>",
            "                <devices>",
            "                  <hostdev mode=\"subsystem\" type=\"pci\" managed=\"yes\">",
            "                    <source>",
            "            <address function=\"0x1\" slot=\"0x10\" domain=\"0x0000\" bus=\"0x04\"/>",
            "                    </source>",
            "                  </hostdev>",
            "                </devices>",
            "            </domain>\"\"\"",
            "",
            "        pci_devices = [dict(hypervisor_name='xxx',",
            "                            id='id1',",
            "                            instance_uuid='uuid',",
            "                            address=\"0000:04:10:1\")]",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.mox.StubOutWithMock(host.Host,",
            "                                 'has_min_version')",
            "        host.Host.has_min_version = lambda x, y: True",
            "",
            "        self.mox.StubOutWithMock(libvirt_driver.LibvirtDriver,",
            "                                 '_get_guest_pci_device')",
            "",
            "        class FakeDev(object):",
            "            def to_xml(self):",
            "                pass",
            "",
            "        libvirt_driver.LibvirtDriver._get_guest_pci_device =\\",
            "            lambda x, y: FakeDev()",
            "",
            "        class FakeDomain(object):",
            "            def detachDeviceFlags(self, xml, flags):",
            "                pass",
            "",
            "            def XMLDesc(self, flags):",
            "                return fake_domXML1",
            "",
            "        guest = libvirt_guest.Guest(FakeDomain())",
            "        self.assertRaises(exception.PciDeviceDetachFailed,",
            "                          drvr._detach_pci_devices, guest, pci_devices)",
            "",
            "    @mock.patch.object(connector, 'get_connector_properties')",
            "    def test_get_connector(self, fake_get_connector):",
            "        initiator = 'fake.initiator.iqn'",
            "        ip = 'fakeip'",
            "        host = 'fakehost'",
            "        wwpns = ['100010604b019419']",
            "        wwnns = ['200010604b019419']",
            "        self.flags(my_ip=ip)",
            "        self.flags(host=host)",
            "",
            "        expected = {",
            "            'ip': ip,",
            "            'initiator': initiator,",
            "            'host': host,",
            "            'wwpns': wwpns,",
            "            'wwnns': wwnns",
            "        }",
            "        volume = {",
            "            'id': 'fake'",
            "        }",
            "",
            "        # TODO(walter-boring) add the fake in os-brick",
            "        fake_get_connector.return_value = expected",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        result = drvr.get_volume_connector(volume)",
            "        self.assertThat(expected, matchers.DictMatches(result))",
            "",
            "    @mock.patch.object(connector, 'get_connector_properties')",
            "    def test_get_connector_storage_ip(self, fake_get_connector):",
            "        ip = '100.100.100.100'",
            "        storage_ip = '101.101.101.101'",
            "        self.flags(my_block_storage_ip=storage_ip, my_ip=ip)",
            "        volume = {",
            "            'id': 'fake'",
            "        }",
            "        expected = {",
            "            'ip': storage_ip",
            "        }",
            "        # TODO(walter-boring) add the fake in os-brick",
            "        fake_get_connector.return_value = expected",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        result = drvr.get_volume_connector(volume)",
            "        self.assertEqual(storage_ip, result['ip'])",
            "",
            "    def test_lifecycle_event_registration(self):",
            "        calls = []",
            "",
            "        def fake_registerErrorHandler(*args, **kwargs):",
            "            calls.append('fake_registerErrorHandler')",
            "",
            "        def fake_get_host_capabilities(**args):",
            "            cpu = vconfig.LibvirtConfigGuestCPU()",
            "            cpu.arch = arch.ARMV7",
            "",
            "            caps = vconfig.LibvirtConfigCaps()",
            "            caps.host = vconfig.LibvirtConfigCapsHost()",
            "            caps.host.cpu = cpu",
            "            calls.append('fake_get_host_capabilities')",
            "            return caps",
            "",
            "        @mock.patch.object(fakelibvirt, 'registerErrorHandler',",
            "                           side_effect=fake_registerErrorHandler)",
            "        @mock.patch.object(host.Host, \"get_capabilities\",",
            "                            side_effect=fake_get_host_capabilities)",
            "        def test_init_host(get_host_capabilities, register_error_handler):",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "            drvr.init_host(\"test_host\")",
            "",
            "        test_init_host()",
            "        # NOTE(dkliban): Will fail if get_host_capabilities is called before",
            "        # registerErrorHandler",
            "        self.assertEqual(['fake_registerErrorHandler',",
            "                          'fake_get_host_capabilities'], calls)",
            "",
            "    def test_sanitize_log_to_xml(self):",
            "        # setup fake data",
            "        data = {'auth_password': 'scrubme'}",
            "        bdm = [{'connection_info': {'data': data}}]",
            "        bdi = {'block_device_mapping': bdm}",
            "",
            "        # Tests that the parameters to the _get_guest_xml method",
            "        # are sanitized for passwords when logged.",
            "        def fake_debug(*args, **kwargs):",
            "            if 'auth_password' in args[0]:",
            "                self.assertNotIn('scrubme', args[0])",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        conf = mock.Mock()",
            "        with test.nested(",
            "            mock.patch.object(libvirt_driver.LOG, 'debug',",
            "                              side_effect=fake_debug),",
            "            mock.patch.object(drvr, '_get_guest_config', return_value=conf)",
            "        ) as (",
            "            debug_mock, conf_mock",
            "        ):",
            "            drvr._get_guest_xml(self.context, self.test_instance,",
            "                                network_info={}, disk_info={},",
            "                                image_meta={}, block_device_info=bdi)",
            "            # we don't care what the log message is, we just want to make sure",
            "            # our stub method is called which asserts the password is scrubbed",
            "            self.assertTrue(debug_mock.called)",
            "",
            "    @mock.patch.object(time, \"time\")",
            "    def test_get_guest_config(self, time_mock):",
            "        time_mock.return_value = 1234567.89",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        test_instance = copy.deepcopy(self.test_instance)",
            "        test_instance[\"display_name\"] = \"purple tomatoes\"",
            "",
            "        ctxt = context.RequestContext(project_id=123,",
            "                                      project_name=\"aubergine\",",
            "                                      user_id=456,",
            "                                      user_name=\"pie\")",
            "",
            "        flavor = objects.Flavor(name='m1.small',",
            "                                memory_mb=6,",
            "                                vcpus=28,",
            "                                root_gb=496,",
            "                                ephemeral_gb=8128,",
            "                                swap=33550336,",
            "                                extra_specs={})",
            "        instance_ref = objects.Instance(**test_instance)",
            "        instance_ref.flavor = flavor",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info,",
            "                                     context=ctxt)",
            "",
            "        self.assertEqual(cfg.uuid, instance_ref[\"uuid\"])",
            "        self.assertEqual(2, len(cfg.features))",
            "        self.assertIsInstance(cfg.features[0],",
            "                              vconfig.LibvirtConfigGuestFeatureACPI)",
            "        self.assertIsInstance(cfg.features[1],",
            "                              vconfig.LibvirtConfigGuestFeatureAPIC)",
            "        self.assertEqual(cfg.memory, 6 * units.Ki)",
            "        self.assertEqual(cfg.vcpus, 28)",
            "        self.assertEqual(cfg.os_type, vm_mode.HVM)",
            "        self.assertEqual(cfg.os_boot_dev, [\"hd\"])",
            "        self.assertIsNone(cfg.os_root)",
            "        self.assertEqual(len(cfg.devices), 10)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestInterface)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[8],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[9],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "        self.assertEqual(len(cfg.metadata), 1)",
            "        self.assertIsInstance(cfg.metadata[0],",
            "                              vconfig.LibvirtConfigGuestMetaNovaInstance)",
            "        self.assertEqual(version.version_string_with_package(),",
            "                         cfg.metadata[0].package)",
            "        self.assertEqual(\"purple tomatoes\",",
            "                         cfg.metadata[0].name)",
            "        self.assertEqual(1234567.89,",
            "                         cfg.metadata[0].creationTime)",
            "        self.assertEqual(\"image\",",
            "                         cfg.metadata[0].roottype)",
            "        self.assertEqual(str(instance_ref[\"image_ref\"]),",
            "                         cfg.metadata[0].rootid)",
            "",
            "        self.assertIsInstance(cfg.metadata[0].owner,",
            "                              vconfig.LibvirtConfigGuestMetaNovaOwner)",
            "        self.assertEqual(456,",
            "                         cfg.metadata[0].owner.userid)",
            "        self.assertEqual(\"pie\",",
            "                         cfg.metadata[0].owner.username)",
            "        self.assertEqual(123,",
            "                         cfg.metadata[0].owner.projectid)",
            "        self.assertEqual(\"aubergine\",",
            "                         cfg.metadata[0].owner.projectname)",
            "",
            "        self.assertIsInstance(cfg.metadata[0].flavor,",
            "                              vconfig.LibvirtConfigGuestMetaNovaFlavor)",
            "        self.assertEqual(\"m1.small\",",
            "                         cfg.metadata[0].flavor.name)",
            "        self.assertEqual(6,",
            "                         cfg.metadata[0].flavor.memory)",
            "        self.assertEqual(28,",
            "                         cfg.metadata[0].flavor.vcpus)",
            "        self.assertEqual(496,",
            "                         cfg.metadata[0].flavor.disk)",
            "        self.assertEqual(8128,",
            "                         cfg.metadata[0].flavor.ephemeral)",
            "        self.assertEqual(33550336,",
            "                         cfg.metadata[0].flavor.swap)",
            "",
            "    def test_get_guest_config_lxc(self):",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, {'mapping': {}})",
            "        self.assertEqual(instance_ref[\"uuid\"], cfg.uuid)",
            "        self.assertEqual(2 * units.Mi, cfg.memory)",
            "        self.assertEqual(1, cfg.vcpus)",
            "        self.assertEqual(vm_mode.EXE, cfg.os_type)",
            "        self.assertEqual(\"/sbin/init\", cfg.os_init_path)",
            "        self.assertEqual(\"console=tty0 console=ttyS0\", cfg.os_cmdline)",
            "        self.assertIsNone(cfg.os_root)",
            "        self.assertEqual(3, len(cfg.devices))",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestFilesys)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestInterface)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestConsole)",
            "",
            "    def test_get_guest_config_lxc_with_id_maps(self):",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "        self.flags(uid_maps=['0:1000:100'], group='libvirt')",
            "        self.flags(gid_maps=['0:1000:100'], group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, {'mapping': {}})",
            "        self.assertEqual(instance_ref[\"uuid\"], cfg.uuid)",
            "        self.assertEqual(2 * units.Mi, cfg.memory)",
            "        self.assertEqual(1, cfg.vcpus)",
            "        self.assertEqual(vm_mode.EXE, cfg.os_type)",
            "        self.assertEqual(\"/sbin/init\", cfg.os_init_path)",
            "        self.assertEqual(\"console=tty0 console=ttyS0\", cfg.os_cmdline)",
            "        self.assertIsNone(cfg.os_root)",
            "        self.assertEqual(3, len(cfg.devices))",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestFilesys)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestInterface)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestConsole)",
            "        self.assertEqual(len(cfg.idmaps), 2)",
            "        self.assertIsInstance(cfg.idmaps[0],",
            "                              vconfig.LibvirtConfigGuestUIDMap)",
            "        self.assertIsInstance(cfg.idmaps[1],",
            "                              vconfig.LibvirtConfigGuestGIDMap)",
            "",
            "    @mock.patch.object(",
            "        host.Host, \"is_cpu_control_policy_capable\", return_value=True)",
            "    def test_get_guest_config_numa_host_instance_fits(self, is_able):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=1, vcpus=2, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={})",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        with test.nested(",
            "                mock.patch.object(host.Host, 'has_min_version',",
            "                                  return_value=True),",
            "                mock.patch.object(host.Host, \"get_capabilities\",",
            "                                  return_value=caps)):",
            "            cfg = drvr._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "            self.assertIsNone(cfg.cpuset)",
            "            self.assertEqual(0, len(cfg.cputune.vcpupin))",
            "            self.assertIsNone(cfg.cpu.numa)",
            "",
            "    @mock.patch.object(",
            "        host.Host, \"is_cpu_control_policy_capable\", return_value=True)",
            "    def test_get_guest_config_numa_host_instance_no_fit(self, is_able):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=4096, vcpus=4, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={})",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        with test.nested(",
            "                mock.patch.object(host.Host, \"get_capabilities\",",
            "                                  return_value=caps),",
            "                mock.patch.object(",
            "                    hardware, 'get_vcpu_pin_set', return_value=set([3])),",
            "                mock.patch.object(random, 'choice')",
            "            ) as (get_host_cap_mock,",
            "                  get_vcpu_pin_set_mock, choice_mock):",
            "            cfg = drvr._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "            self.assertFalse(choice_mock.called)",
            "            self.assertEqual(set([3]), cfg.cpuset)",
            "            self.assertEqual(0, len(cfg.cputune.vcpupin))",
            "            self.assertIsNone(cfg.cpu.numa)",
            "",
            "    def _test_get_guest_memory_backing_config(",
            "            self, host_topology, inst_topology, numatune):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        with mock.patch.object(",
            "                drvr, \"_get_host_numa_topology\",",
            "                return_value=host_topology):",
            "            return drvr._get_guest_memory_backing_config(",
            "                inst_topology, numatune, {})",
            "",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    def test_get_guest_memory_backing_config_large_success(self, mock_version):",
            "        host_topology = objects.NUMATopology(",
            "            cells=[",
            "                objects.NUMACell(",
            "                    id=3, cpuset=set([1]), memory=1024, mempages=[",
            "                        objects.NUMAPagesTopology(size_kb=4, total=2000,",
            "                                                  used=0),",
            "                        objects.NUMAPagesTopology(size_kb=2048, total=512,",
            "                                                  used=0),",
            "                        objects.NUMAPagesTopology(size_kb=1048576, total=0,",
            "                                                  used=0),",
            "                    ])])",
            "        inst_topology = objects.InstanceNUMATopology(cells=[",
            "            objects.InstanceNUMACell(",
            "                id=3, cpuset=set([0, 1]), memory=1024, pagesize=2048)])",
            "",
            "        numa_tune = vconfig.LibvirtConfigGuestNUMATune()",
            "        numa_tune.memnodes = [vconfig.LibvirtConfigGuestNUMATuneMemNode()]",
            "        numa_tune.memnodes[0].cellid = 0",
            "        numa_tune.memnodes[0].nodeset = [3]",
            "",
            "        result = self._test_get_guest_memory_backing_config(",
            "            host_topology, inst_topology, numa_tune)",
            "        self.assertEqual(1, len(result.hugepages))",
            "        self.assertEqual(2048, result.hugepages[0].size_kb)",
            "        self.assertEqual([0], result.hugepages[0].nodeset)",
            "",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    def test_get_guest_memory_backing_config_smallest(self, mock_version):",
            "        host_topology = objects.NUMATopology(",
            "            cells=[",
            "                objects.NUMACell(",
            "                    id=3, cpuset=set([1]), memory=1024, mempages=[",
            "                        objects.NUMAPagesTopology(size_kb=4, total=2000,",
            "                                                  used=0),",
            "                        objects.NUMAPagesTopology(size_kb=2048, total=512,",
            "                                                  used=0),",
            "                        objects.NUMAPagesTopology(size_kb=1048576, total=0,",
            "                                                  used=0),",
            "                    ])])",
            "        inst_topology = objects.InstanceNUMATopology(cells=[",
            "            objects.InstanceNUMACell(",
            "                id=3, cpuset=set([0, 1]), memory=1024, pagesize=4)])",
            "",
            "        numa_tune = vconfig.LibvirtConfigGuestNUMATune()",
            "        numa_tune.memnodes = [vconfig.LibvirtConfigGuestNUMATuneMemNode()]",
            "        numa_tune.memnodes[0].cellid = 0",
            "        numa_tune.memnodes[0].nodeset = [3]",
            "",
            "        result = self._test_get_guest_memory_backing_config(",
            "            host_topology, inst_topology, numa_tune)",
            "        self.assertIsNone(result)",
            "",
            "    def test_get_guest_memory_backing_config_realtime(self):",
            "        flavor = {\"extra_specs\": {",
            "            \"hw:cpu_realtime\": \"yes\",",
            "            \"hw:cpu_policy\": \"dedicated\"",
            "        }}",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        membacking = drvr._get_guest_memory_backing_config(",
            "            None, None, flavor)",
            "        self.assertTrue(membacking.locked)",
            "        self.assertFalse(membacking.sharedpages)",
            "",
            "    @mock.patch.object(",
            "        host.Host, \"is_cpu_control_policy_capable\", return_value=True)",
            "    def test_get_guest_config_numa_host_instance_pci_no_numa_info(",
            "            self, is_able):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=1, vcpus=2, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={})",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        pci_device_info = dict(test_pci_device.fake_db_dev)",
            "        pci_device_info.update(compute_node_id=1,",
            "                               label='fake',",
            "                               status=fields.PciDeviceStatus.AVAILABLE,",
            "                               address='0000:00:00.1',",
            "                               instance_uuid=None,",
            "                               request_id=None,",
            "                               extra_info={},",
            "                               numa_node=None)",
            "        pci_device = objects.PciDevice(**pci_device_info)",
            "",
            "        with test.nested(",
            "                mock.patch.object(host.Host, 'has_min_version',",
            "                                  return_value=True),",
            "                mock.patch.object(",
            "                    host.Host, \"get_capabilities\", return_value=caps),",
            "                mock.patch.object(",
            "                    hardware, 'get_vcpu_pin_set', return_value=set([3])),",
            "                mock.patch.object(host.Host, 'get_online_cpus',",
            "                                  return_value=set(range(8))),",
            "                mock.patch.object(pci_manager, \"get_instance_pci_devs\",",
            "                                  return_value=[pci_device])):",
            "            cfg = conn._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "            self.assertEqual(set([3]), cfg.cpuset)",
            "            self.assertEqual(0, len(cfg.cputune.vcpupin))",
            "            self.assertIsNone(cfg.cpu.numa)",
            "",
            "    @mock.patch.object(",
            "        host.Host, \"is_cpu_control_policy_capable\", return_value=True)",
            "    def test_get_guest_config_numa_host_instance_2pci_no_fit(self, is_able):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=4096, vcpus=4, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={})",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        pci_device_info = dict(test_pci_device.fake_db_dev)",
            "        pci_device_info.update(compute_node_id=1,",
            "                               label='fake',",
            "                               status=fields.PciDeviceStatus.AVAILABLE,",
            "                               address='0000:00:00.1',",
            "                               instance_uuid=None,",
            "                               request_id=None,",
            "                               extra_info={},",
            "                               numa_node=1)",
            "        pci_device = objects.PciDevice(**pci_device_info)",
            "        pci_device_info.update(numa_node=0, address='0000:00:00.2')",
            "        pci_device2 = objects.PciDevice(**pci_device_info)",
            "        with test.nested(",
            "                mock.patch.object(",
            "                    host.Host, \"get_capabilities\", return_value=caps),",
            "                mock.patch.object(",
            "                    hardware, 'get_vcpu_pin_set', return_value=set([3])),",
            "                mock.patch.object(random, 'choice'),",
            "                mock.patch.object(pci_manager, \"get_instance_pci_devs\",",
            "                                  return_value=[pci_device, pci_device2])",
            "            ) as (get_host_cap_mock,",
            "                  get_vcpu_pin_set_mock, choice_mock, pci_mock):",
            "            cfg = conn._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "            self.assertFalse(choice_mock.called)",
            "            self.assertEqual(set([3]), cfg.cpuset)",
            "            self.assertEqual(0, len(cfg.cputune.vcpupin))",
            "            self.assertIsNone(cfg.cpu.numa)",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getType')",
            "    @mock.patch.object(fakelibvirt.Connection, 'getVersion')",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion')",
            "    @mock.patch.object(host.Host, 'get_capabilities')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_set_host_enabled')",
            "    def _test_get_guest_config_numa_unsupported(self, fake_lib_version,",
            "                                                fake_version, fake_type,",
            "                                                fake_arch, exception_class,",
            "                                                pagesize, mock_host,",
            "                                                mock_caps, mock_lib_version,",
            "                                                mock_version, mock_type):",
            "        instance_topology = objects.InstanceNUMATopology(",
            "                    cells=[objects.InstanceNUMACell(",
            "                        id=0, cpuset=set([0]),",
            "                        memory=1024, pagesize=pagesize)])",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.numa_topology = instance_topology",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=1, vcpus=2, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={})",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = fake_arch",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        mock_type.return_value = fake_type",
            "        mock_version.return_value = fake_version",
            "        mock_lib_version.return_value = fake_lib_version",
            "        mock_caps.return_value = caps",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        self.assertRaises(exception_class,",
            "                          drvr._get_guest_config,",
            "                          instance_ref, [],",
            "                          image_meta, disk_info)",
            "",
            "    def test_get_guest_config_numa_old_version_libvirt(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        self._test_get_guest_config_numa_unsupported(",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_NUMA_VERSION) - 1,",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_QEMU_NUMA_HUGEPAGE_VERSION),",
            "            host.HV_DRIVER_QEMU,",
            "            arch.X86_64,",
            "            exception.NUMATopologyUnsupported,",
            "            None)",
            "",
            "    def test_get_guest_config_numa_old_version_libvirt_ppc(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        self._test_get_guest_config_numa_unsupported(",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_NUMA_VERSION_PPC) - 1,",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_QEMU_NUMA_HUGEPAGE_VERSION),",
            "            host.HV_DRIVER_QEMU,",
            "            arch.PPC64LE,",
            "            exception.NUMATopologyUnsupported,",
            "            None)",
            "",
            "    def test_get_guest_config_numa_bad_version_libvirt(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        self._test_get_guest_config_numa_unsupported(",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.BAD_LIBVIRT_NUMA_VERSIONS[0]),",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_QEMU_NUMA_HUGEPAGE_VERSION),",
            "            host.HV_DRIVER_QEMU,",
            "            arch.X86_64,",
            "            exception.NUMATopologyUnsupported,",
            "            None)",
            "",
            "    @mock.patch.object(libvirt_driver.LOG, 'warn')",
            "    def test_has_numa_support_bad_version_libvirt_log(self, mock_warn):",
            "        # Tests that a warning is logged once and only once when there is a bad",
            "        # BAD_LIBVIRT_NUMA_VERSIONS detected.",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertFalse(hasattr(drvr, '_bad_libvirt_numa_version_warn'))",
            "        with mock.patch.object(drvr._host, 'has_version', return_value=True):",
            "            for i in range(2):",
            "                self.assertFalse(drvr._has_numa_support())",
            "        self.assertTrue(drvr._bad_libvirt_numa_version_warn)",
            "        self.assertEqual(1, mock_warn.call_count)",
            "        # assert the version is logged properly",
            "        self.assertEqual('1.2.9.2', mock_warn.call_args[0][1])",
            "",
            "    def test_get_guest_config_numa_old_version_qemu(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        self._test_get_guest_config_numa_unsupported(",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_NUMA_VERSION),",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_QEMU_NUMA_HUGEPAGE_VERSION) - 1,",
            "            host.HV_DRIVER_QEMU,",
            "            arch.X86_64,",
            "            exception.NUMATopologyUnsupported,",
            "            None)",
            "",
            "    def test_get_guest_config_numa_other_arch_qemu(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        self._test_get_guest_config_numa_unsupported(",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_NUMA_VERSION),",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_QEMU_NUMA_HUGEPAGE_VERSION),",
            "            host.HV_DRIVER_QEMU,",
            "            arch.S390,",
            "            exception.NUMATopologyUnsupported,",
            "            None)",
            "",
            "    def test_get_guest_config_numa_xen(self):",
            "        self.flags(virt_type='xen', group='libvirt')",
            "        self._test_get_guest_config_numa_unsupported(",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_NUMA_VERSION),",
            "            versionutils.convert_version_to_int((4, 5, 0)),",
            "            'XEN',",
            "            arch.X86_64,",
            "            exception.NUMATopologyUnsupported,",
            "            None)",
            "",
            "    def test_get_guest_config_numa_old_pages_libvirt(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        self._test_get_guest_config_numa_unsupported(",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_HUGEPAGE_VERSION) - 1,",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_QEMU_NUMA_HUGEPAGE_VERSION),",
            "            host.HV_DRIVER_QEMU,",
            "            arch.X86_64,",
            "            exception.MemoryPagesUnsupported,",
            "            2048)",
            "",
            "    def test_get_guest_config_numa_old_pages_qemu(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        self._test_get_guest_config_numa_unsupported(",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_HUGEPAGE_VERSION),",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_QEMU_NUMA_HUGEPAGE_VERSION) - 1,",
            "            host.HV_DRIVER_QEMU,",
            "            arch.X86_64,",
            "            exception.NUMATopologyUnsupported,",
            "            2048)",
            "",
            "    @mock.patch.object(",
            "        host.Host, \"is_cpu_control_policy_capable\", return_value=True)",
            "    def test_get_guest_config_numa_host_instance_fit_w_cpu_pinset(",
            "            self, is_able):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=1024, vcpus=2, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={})",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology(kb_mem=4194304)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        with test.nested(",
            "                mock.patch.object(host.Host, 'has_min_version',",
            "                                  return_value=True),",
            "                mock.patch.object(host.Host, \"get_capabilities\",",
            "                                  return_value=caps),",
            "                mock.patch.object(",
            "                    hardware, 'get_vcpu_pin_set', return_value=set([2, 3])),",
            "                mock.patch.object(host.Host, 'get_online_cpus',",
            "                                  return_value=set(range(8)))",
            "                ) as (has_min_version_mock, get_host_cap_mock,",
            "                        get_vcpu_pin_set_mock, get_online_cpus_mock):",
            "            cfg = drvr._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "            # NOTE(ndipanov): we make sure that pin_set was taken into account",
            "            # when choosing viable cells",
            "            self.assertEqual(set([2, 3]), cfg.cpuset)",
            "            self.assertEqual(0, len(cfg.cputune.vcpupin))",
            "            self.assertIsNone(cfg.cpu.numa)",
            "",
            "    @mock.patch.object(",
            "        host.Host, \"is_cpu_control_policy_capable\", return_value=True)",
            "    def test_get_guest_config_non_numa_host_instance_topo(self, is_able):",
            "        instance_topology = objects.InstanceNUMATopology(",
            "                    cells=[objects.InstanceNUMACell(",
            "                        id=0, cpuset=set([0]), memory=1024),",
            "                           objects.InstanceNUMACell(",
            "                        id=1, cpuset=set([2]), memory=1024)])",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.numa_topology = instance_topology",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=2048, vcpus=2, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={})",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = None",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        with test.nested(",
            "                mock.patch.object(",
            "                    objects.InstanceNUMATopology, \"get_by_instance_uuid\",",
            "                    return_value=instance_topology),",
            "                mock.patch.object(host.Host, 'has_min_version',",
            "                                  return_value=True),",
            "                mock.patch.object(host.Host, \"get_capabilities\",",
            "                                  return_value=caps)):",
            "            cfg = drvr._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "            self.assertIsNone(cfg.cpuset)",
            "            self.assertEqual(0, len(cfg.cputune.vcpupin))",
            "            self.assertIsNone(cfg.numatune)",
            "            self.assertIsNotNone(cfg.cpu.numa)",
            "            for instance_cell, numa_cfg_cell in zip(",
            "                    instance_topology.cells, cfg.cpu.numa.cells):",
            "                self.assertEqual(instance_cell.id, numa_cfg_cell.id)",
            "                self.assertEqual(instance_cell.cpuset, numa_cfg_cell.cpus)",
            "                self.assertEqual(instance_cell.memory * units.Ki,",
            "                                 numa_cfg_cell.memory)",
            "",
            "    @mock.patch.object(",
            "        host.Host, \"is_cpu_control_policy_capable\", return_value=True)",
            "    def test_get_guest_config_numa_host_instance_topo(self, is_able):",
            "        instance_topology = objects.InstanceNUMATopology(",
            "                    cells=[objects.InstanceNUMACell(",
            "                        id=1, cpuset=set([0, 1]), memory=1024, pagesize=None),",
            "                           objects.InstanceNUMACell(",
            "                               id=2, cpuset=set([2, 3]), memory=1024,",
            "                               pagesize=None)])",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.numa_topology = instance_topology",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=2048, vcpus=4, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={})",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        with test.nested(",
            "                mock.patch.object(",
            "                    objects.InstanceNUMATopology, \"get_by_instance_uuid\",",
            "                    return_value=instance_topology),",
            "                mock.patch.object(host.Host, 'has_min_version',",
            "                                  return_value=True),",
            "                mock.patch.object(host.Host, \"get_capabilities\",",
            "                                  return_value=caps),",
            "                mock.patch.object(",
            "                    hardware, 'get_vcpu_pin_set',",
            "                    return_value=set([2, 3, 4, 5])),",
            "                mock.patch.object(host.Host, 'get_online_cpus',",
            "                                  return_value=set(range(8))),",
            "                ):",
            "            cfg = drvr._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "            self.assertIsNone(cfg.cpuset)",
            "            # Test that the pinning is correct and limited to allowed only",
            "            self.assertEqual(0, cfg.cputune.vcpupin[0].id)",
            "            self.assertEqual(set([2, 3]), cfg.cputune.vcpupin[0].cpuset)",
            "            self.assertEqual(1, cfg.cputune.vcpupin[1].id)",
            "            self.assertEqual(set([2, 3]), cfg.cputune.vcpupin[1].cpuset)",
            "            self.assertEqual(2, cfg.cputune.vcpupin[2].id)",
            "            self.assertEqual(set([4, 5]), cfg.cputune.vcpupin[2].cpuset)",
            "            self.assertEqual(3, cfg.cputune.vcpupin[3].id)",
            "            self.assertEqual(set([4, 5]), cfg.cputune.vcpupin[3].cpuset)",
            "            self.assertIsNotNone(cfg.cpu.numa)",
            "",
            "            self.assertIsInstance(cfg.cputune.emulatorpin,",
            "                                  vconfig.LibvirtConfigGuestCPUTuneEmulatorPin)",
            "            self.assertEqual(set([2, 3, 4, 5]), cfg.cputune.emulatorpin.cpuset)",
            "",
            "            for instance_cell, numa_cfg_cell, index in zip(",
            "                    instance_topology.cells,",
            "                    cfg.cpu.numa.cells,",
            "                    range(len(instance_topology.cells))):",
            "                self.assertEqual(index, numa_cfg_cell.id)",
            "                self.assertEqual(instance_cell.cpuset, numa_cfg_cell.cpus)",
            "                self.assertEqual(instance_cell.memory * units.Ki,",
            "                                 numa_cfg_cell.memory)",
            "",
            "            allnodes = [cell.id for cell in instance_topology.cells]",
            "            self.assertEqual(allnodes, cfg.numatune.memory.nodeset)",
            "            self.assertEqual(\"strict\", cfg.numatune.memory.mode)",
            "",
            "            for instance_cell, memnode, index in zip(",
            "                    instance_topology.cells,",
            "                    cfg.numatune.memnodes,",
            "                    range(len(instance_topology.cells))):",
            "                self.assertEqual(index, memnode.cellid)",
            "                self.assertEqual([instance_cell.id], memnode.nodeset)",
            "                self.assertEqual(\"strict\", memnode.mode)",
            "",
            "    def test_get_guest_config_numa_host_instance_topo_reordered(self):",
            "        instance_topology = objects.InstanceNUMATopology(",
            "                    cells=[objects.InstanceNUMACell(",
            "                        id=3, cpuset=set([0, 1]), memory=1024),",
            "                           objects.InstanceNUMACell(",
            "                        id=0, cpuset=set([2, 3]), memory=1024)])",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.numa_topology = instance_topology",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=2048, vcpus=4, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={})",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        with test.nested(",
            "                mock.patch.object(",
            "                    objects.InstanceNUMATopology, \"get_by_instance_uuid\",",
            "                    return_value=instance_topology),",
            "                mock.patch.object(host.Host, 'has_min_version',",
            "                                  return_value=True),",
            "                mock.patch.object(host.Host, \"get_capabilities\",",
            "                                  return_value=caps),",
            "                mock.patch.object(host.Host, 'get_online_cpus',",
            "                                  return_value=set(range(8))),",
            "                ):",
            "            cfg = drvr._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "            self.assertIsNone(cfg.cpuset)",
            "            # Test that the pinning is correct and limited to allowed only",
            "            self.assertEqual(0, cfg.cputune.vcpupin[0].id)",
            "            self.assertEqual(set([6, 7]), cfg.cputune.vcpupin[0].cpuset)",
            "            self.assertEqual(1, cfg.cputune.vcpupin[1].id)",
            "            self.assertEqual(set([6, 7]), cfg.cputune.vcpupin[1].cpuset)",
            "            self.assertEqual(2, cfg.cputune.vcpupin[2].id)",
            "            self.assertEqual(set([0, 1]), cfg.cputune.vcpupin[2].cpuset)",
            "            self.assertEqual(3, cfg.cputune.vcpupin[3].id)",
            "            self.assertEqual(set([0, 1]), cfg.cputune.vcpupin[3].cpuset)",
            "            self.assertIsNotNone(cfg.cpu.numa)",
            "",
            "            self.assertIsInstance(cfg.cputune.emulatorpin,",
            "                                  vconfig.LibvirtConfigGuestCPUTuneEmulatorPin)",
            "            self.assertEqual(set([0, 1, 6, 7]), cfg.cputune.emulatorpin.cpuset)",
            "",
            "            for index, (instance_cell, numa_cfg_cell) in enumerate(zip(",
            "                    instance_topology.cells,",
            "                    cfg.cpu.numa.cells)):",
            "                self.assertEqual(index, numa_cfg_cell.id)",
            "                self.assertEqual(instance_cell.cpuset, numa_cfg_cell.cpus)",
            "                self.assertEqual(instance_cell.memory * units.Ki,",
            "                                 numa_cfg_cell.memory)",
            "                self.assertIsNone(numa_cfg_cell.memAccess)",
            "",
            "            allnodes = set([cell.id for cell in instance_topology.cells])",
            "            self.assertEqual(allnodes, set(cfg.numatune.memory.nodeset))",
            "            self.assertEqual(\"strict\", cfg.numatune.memory.mode)",
            "",
            "            for index, (instance_cell, memnode) in enumerate(zip(",
            "                    instance_topology.cells,",
            "                    cfg.numatune.memnodes)):",
            "                self.assertEqual(index, memnode.cellid)",
            "                self.assertEqual([instance_cell.id], memnode.nodeset)",
            "                self.assertEqual(\"strict\", memnode.mode)",
            "",
            "    def test_get_guest_config_numa_host_instance_topo_cpu_pinning(self):",
            "        instance_topology = objects.InstanceNUMATopology(",
            "                    cells=[objects.InstanceNUMACell(",
            "                        id=1, cpuset=set([0, 1]), memory=1024,",
            "                        cpu_pinning={0: 24, 1: 25}),",
            "                           objects.InstanceNUMACell(",
            "                        id=0, cpuset=set([2, 3]), memory=1024,",
            "                        cpu_pinning={2: 0, 3: 1})])",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.numa_topology = instance_topology",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=2048, vcpus=2, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={})",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology(",
            "            sockets_per_cell=4, cores_per_socket=3, threads_per_core=2)",
            "",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        with test.nested(",
            "                mock.patch.object(",
            "                    objects.InstanceNUMATopology, \"get_by_instance_uuid\",",
            "                    return_value=instance_topology),",
            "                mock.patch.object(host.Host, 'has_min_version',",
            "                                  return_value=True),",
            "                mock.patch.object(host.Host, \"get_capabilities\",",
            "                                  return_value=caps),",
            "                mock.patch.object(host.Host, 'get_online_cpus',",
            "                                  return_value=set(range(8))),",
            "                ):",
            "            cfg = conn._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "            self.assertIsNone(cfg.cpuset)",
            "            # Test that the pinning is correct and limited to allowed only",
            "            self.assertEqual(0, cfg.cputune.vcpupin[0].id)",
            "            self.assertEqual(set([24]), cfg.cputune.vcpupin[0].cpuset)",
            "            self.assertEqual(1, cfg.cputune.vcpupin[1].id)",
            "            self.assertEqual(set([25]), cfg.cputune.vcpupin[1].cpuset)",
            "            self.assertEqual(2, cfg.cputune.vcpupin[2].id)",
            "            self.assertEqual(set([0]), cfg.cputune.vcpupin[2].cpuset)",
            "            self.assertEqual(3, cfg.cputune.vcpupin[3].id)",
            "            self.assertEqual(set([1]), cfg.cputune.vcpupin[3].cpuset)",
            "            self.assertIsNotNone(cfg.cpu.numa)",
            "",
            "            # Emulator must be pinned to union of cfg.cputune.vcpupin[*].cpuset",
            "            self.assertIsInstance(cfg.cputune.emulatorpin,",
            "                                  vconfig.LibvirtConfigGuestCPUTuneEmulatorPin)",
            "            self.assertEqual(set([0, 1, 24, 25]),",
            "                             cfg.cputune.emulatorpin.cpuset)",
            "",
            "            for i, (instance_cell, numa_cfg_cell) in enumerate(zip(",
            "                    instance_topology.cells, cfg.cpu.numa.cells)):",
            "                self.assertEqual(i, numa_cfg_cell.id)",
            "                self.assertEqual(instance_cell.cpuset, numa_cfg_cell.cpus)",
            "                self.assertEqual(instance_cell.memory * units.Ki,",
            "                                 numa_cfg_cell.memory)",
            "                self.assertIsNone(numa_cfg_cell.memAccess)",
            "",
            "            allnodes = set([cell.id for cell in instance_topology.cells])",
            "            self.assertEqual(allnodes, set(cfg.numatune.memory.nodeset))",
            "            self.assertEqual(\"strict\", cfg.numatune.memory.mode)",
            "",
            "            for i, (instance_cell, memnode) in enumerate(zip(",
            "                    instance_topology.cells, cfg.numatune.memnodes)):",
            "                self.assertEqual(i, memnode.cellid)",
            "                self.assertEqual([instance_cell.id], memnode.nodeset)",
            "                self.assertEqual(\"strict\", memnode.mode)",
            "",
            "    def test_get_guest_config_numa_host_mempages_shared(self):",
            "        instance_topology = objects.InstanceNUMATopology(",
            "            cells=[",
            "                objects.InstanceNUMACell(",
            "                    id=1, cpuset=set([0, 1]),",
            "                    memory=1024, pagesize=2048),",
            "                objects.InstanceNUMACell(",
            "                    id=2, cpuset=set([2, 3]),",
            "                    memory=1024, pagesize=2048)])",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.numa_topology = instance_topology",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=2048, vcpus=4, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={})",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        with test.nested(",
            "                mock.patch.object(",
            "                    objects.InstanceNUMATopology, \"get_by_instance_uuid\",",
            "                    return_value=instance_topology),",
            "                mock.patch.object(host.Host, 'has_min_version',",
            "                                  return_value=True),",
            "                mock.patch.object(host.Host, \"get_capabilities\",",
            "                                  return_value=caps),",
            "                mock.patch.object(",
            "                    hardware, 'get_vcpu_pin_set',",
            "                    return_value=set([2, 3, 4, 5])),",
            "                mock.patch.object(host.Host, 'get_online_cpus',",
            "                                  return_value=set(range(8))),",
            "                ):",
            "            cfg = drvr._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "",
            "            for instance_cell, numa_cfg_cell, index in zip(",
            "                    instance_topology.cells,",
            "                    cfg.cpu.numa.cells,",
            "                    range(len(instance_topology.cells))):",
            "                self.assertEqual(index, numa_cfg_cell.id)",
            "                self.assertEqual(instance_cell.cpuset, numa_cfg_cell.cpus)",
            "                self.assertEqual(instance_cell.memory * units.Ki,",
            "                                 numa_cfg_cell.memory)",
            "                self.assertEqual(\"shared\", numa_cfg_cell.memAccess)",
            "",
            "            allnodes = [cell.id for cell in instance_topology.cells]",
            "            self.assertEqual(allnodes, cfg.numatune.memory.nodeset)",
            "            self.assertEqual(\"strict\", cfg.numatune.memory.mode)",
            "",
            "            for instance_cell, memnode, index in zip(",
            "                    instance_topology.cells,",
            "                    cfg.numatune.memnodes,",
            "                    range(len(instance_topology.cells))):",
            "                self.assertEqual(index, memnode.cellid)",
            "                self.assertEqual([instance_cell.id], memnode.nodeset)",
            "                self.assertEqual(\"strict\", memnode.mode)",
            "",
            "            self.assertEqual(0, len(cfg.cputune.vcpusched))",
            "            self.assertEqual(set([2, 3, 4, 5]), cfg.cputune.emulatorpin.cpuset)",
            "",
            "    def test_get_guest_config_numa_host_instance_cpu_pinning_realtime(self):",
            "        instance_topology = objects.InstanceNUMATopology(",
            "            cells=[",
            "                objects.InstanceNUMACell(",
            "                    id=1, cpuset=set([0, 1]),",
            "                    memory=1024, pagesize=2048),",
            "                objects.InstanceNUMACell(",
            "                    id=2, cpuset=set([2, 3]),",
            "                    memory=1024, pagesize=2048)])",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.numa_topology = instance_topology",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=2048, vcpus=2, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={",
            "                                    \"hw:cpu_realtime\": \"yes\",",
            "                                    \"hw:cpu_policy\": \"dedicated\",",
            "                                    \"hw:cpu_realtime_mask\": \"^0-1\"",
            "                                })",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        with test.nested(",
            "                mock.patch.object(",
            "                    objects.InstanceNUMATopology, \"get_by_instance_uuid\",",
            "                    return_value=instance_topology),",
            "                mock.patch.object(host.Host, 'has_min_version',",
            "                                  return_value=True),",
            "                mock.patch.object(host.Host, \"get_capabilities\",",
            "                                  return_value=caps),",
            "                mock.patch.object(",
            "                    hardware, 'get_vcpu_pin_set',",
            "                    return_value=set([2, 3, 4, 5])),",
            "                mock.patch.object(host.Host, 'get_online_cpus',",
            "                                  return_value=set(range(8))),",
            "                ):",
            "            cfg = drvr._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "",
            "            for instance_cell, numa_cfg_cell, index in zip(",
            "                    instance_topology.cells,",
            "                    cfg.cpu.numa.cells,",
            "                    range(len(instance_topology.cells))):",
            "                self.assertEqual(index, numa_cfg_cell.id)",
            "                self.assertEqual(instance_cell.cpuset, numa_cfg_cell.cpus)",
            "                self.assertEqual(instance_cell.memory * units.Ki,",
            "                                 numa_cfg_cell.memory)",
            "                self.assertEqual(\"shared\", numa_cfg_cell.memAccess)",
            "",
            "            allnodes = [cell.id for cell in instance_topology.cells]",
            "            self.assertEqual(allnodes, cfg.numatune.memory.nodeset)",
            "            self.assertEqual(\"strict\", cfg.numatune.memory.mode)",
            "",
            "            for instance_cell, memnode, index in zip(",
            "                    instance_topology.cells,",
            "                    cfg.numatune.memnodes,",
            "                    range(len(instance_topology.cells))):",
            "                self.assertEqual(index, memnode.cellid)",
            "                self.assertEqual([instance_cell.id], memnode.nodeset)",
            "                self.assertEqual(\"strict\", memnode.mode)",
            "",
            "            self.assertEqual(1, len(cfg.cputune.vcpusched))",
            "            self.assertEqual(\"fifo\", cfg.cputune.vcpusched[0].scheduler)",
            "            self.assertEqual(set([2, 3]), cfg.cputune.vcpusched[0].vcpus)",
            "            self.assertEqual(set([0, 1]), cfg.cputune.emulatorpin.cpuset)",
            "",
            "    def test_get_cpu_numa_config_from_instance(self):",
            "        topology = objects.InstanceNUMATopology(cells=[",
            "            objects.InstanceNUMACell(id=0, cpuset=set([1, 2]), memory=128),",
            "            objects.InstanceNUMACell(id=1, cpuset=set([3, 4]), memory=128),",
            "        ])",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        conf = drvr._get_cpu_numa_config_from_instance(topology, True)",
            "",
            "        self.assertIsInstance(conf, vconfig.LibvirtConfigGuestCPUNUMA)",
            "        self.assertEqual(0, conf.cells[0].id)",
            "        self.assertEqual(set([1, 2]), conf.cells[0].cpus)",
            "        self.assertEqual(131072, conf.cells[0].memory)",
            "        self.assertEqual(\"shared\", conf.cells[0].memAccess)",
            "        self.assertEqual(1, conf.cells[1].id)",
            "        self.assertEqual(set([3, 4]), conf.cells[1].cpus)",
            "        self.assertEqual(131072, conf.cells[1].memory)",
            "        self.assertEqual(\"shared\", conf.cells[1].memAccess)",
            "",
            "    def test_get_cpu_numa_config_from_instance_none(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        conf = drvr._get_cpu_numa_config_from_instance(None, False)",
            "        self.assertIsNone(conf)",
            "",
            "    @mock.patch.object(host.Host, 'has_version', return_value=True)",
            "    def test_has_cpu_policy_support(self, mock_has_version):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertRaises(exception.CPUPinningNotSupported,",
            "                          drvr._has_cpu_policy_support)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, \"_has_numa_support\",",
            "                       return_value=True)",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, \"_has_hugepage_support\",",
            "                       return_value=True)",
            "    @mock.patch.object(host.Host, \"get_capabilities\")",
            "    def test_does_not_want_hugepages(self, mock_caps, mock_numa, mock_hp):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_topology = objects.InstanceNUMATopology(",
            "            cells=[",
            "                objects.InstanceNUMACell(",
            "                    id=1, cpuset=set([0, 1]),",
            "                    memory=1024, pagesize=4),",
            "                objects.InstanceNUMACell(",
            "                    id=2, cpuset=set([2, 3]),",
            "                    memory=1024, pagesize=4)])",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        mock_caps.return_value = caps",
            "",
            "        host_topology = drvr._get_host_numa_topology()",
            "",
            "        self.assertFalse(drvr._wants_hugepages(None, None))",
            "        self.assertFalse(drvr._wants_hugepages(host_topology, None))",
            "        self.assertFalse(drvr._wants_hugepages(None, instance_topology))",
            "        self.assertFalse(drvr._wants_hugepages(host_topology,",
            "                                               instance_topology))",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, \"_has_numa_support\",",
            "                       return_value=True)",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, \"_has_hugepage_support\",",
            "                       return_value=True)",
            "    @mock.patch.object(host.Host, \"get_capabilities\")",
            "    def test_does_want_hugepages(self, mock_caps, mock_numa, mock_hp):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_topology = objects.InstanceNUMATopology(",
            "            cells=[",
            "                objects.InstanceNUMACell(",
            "                    id=1, cpuset=set([0, 1]),",
            "                    memory=1024, pagesize=2048),",
            "                objects.InstanceNUMACell(",
            "                    id=2, cpuset=set([2, 3]),",
            "                    memory=1024, pagesize=2048)])",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        mock_caps.return_value = caps",
            "",
            "        host_topology = drvr._get_host_numa_topology()",
            "",
            "        self.assertTrue(drvr._wants_hugepages(host_topology,",
            "                                              instance_topology))",
            "",
            "    def test_get_guest_config_clock(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        hpet_map = {",
            "            arch.X86_64: True,",
            "            arch.I686: True,",
            "            arch.PPC: False,",
            "            arch.PPC64: False,",
            "            arch.ARMV7: False,",
            "            arch.AARCH64: False,",
            "            }",
            "",
            "        for guestarch, expect_hpet in hpet_map.items():",
            "            with mock.patch.object(libvirt_driver.libvirt_utils,",
            "                                   'get_arch',",
            "                                   return_value=guestarch):",
            "                cfg = drvr._get_guest_config(instance_ref, [],",
            "                                             image_meta,",
            "                                             disk_info)",
            "                self.assertIsInstance(cfg.clock,",
            "                                      vconfig.LibvirtConfigGuestClock)",
            "                self.assertEqual(cfg.clock.offset, \"utc\")",
            "                self.assertIsInstance(cfg.clock.timers[0],",
            "                                      vconfig.LibvirtConfigGuestTimer)",
            "                self.assertIsInstance(cfg.clock.timers[1],",
            "                                      vconfig.LibvirtConfigGuestTimer)",
            "                self.assertEqual(cfg.clock.timers[0].name, \"pit\")",
            "                self.assertEqual(cfg.clock.timers[0].tickpolicy,",
            "                                      \"delay\")",
            "                self.assertEqual(cfg.clock.timers[1].name, \"rtc\")",
            "                self.assertEqual(cfg.clock.timers[1].tickpolicy,",
            "                                      \"catchup\")",
            "                if expect_hpet:",
            "                    self.assertEqual(3, len(cfg.clock.timers))",
            "                    self.assertIsInstance(cfg.clock.timers[2],",
            "                                          vconfig.LibvirtConfigGuestTimer)",
            "                    self.assertEqual('hpet', cfg.clock.timers[2].name)",
            "                    self.assertFalse(cfg.clock.timers[2].present)",
            "                else:",
            "                    self.assertEqual(2, len(cfg.clock.timers))",
            "",
            "    @mock.patch.object(libvirt_utils, 'get_arch')",
            "    @mock.patch.object(host.Host, 'has_min_version')",
            "    def test_get_guest_config_windows(self, mock_version, mock_get_arch):",
            "        mock_version.return_value = False",
            "        mock_get_arch.return_value = arch.I686",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref['os_type'] = 'windows'",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info)",
            "",
            "        self.assertIsInstance(cfg.clock,",
            "                              vconfig.LibvirtConfigGuestClock)",
            "        self.assertEqual(cfg.clock.offset, \"localtime\")",
            "",
            "        self.assertEqual(3, len(cfg.clock.timers), cfg.clock.timers)",
            "        self.assertEqual(\"pit\", cfg.clock.timers[0].name)",
            "        self.assertEqual(\"rtc\", cfg.clock.timers[1].name)",
            "        self.assertEqual(\"hpet\", cfg.clock.timers[2].name)",
            "        self.assertFalse(cfg.clock.timers[2].present)",
            "",
            "    @mock.patch.object(libvirt_utils, 'get_arch')",
            "    @mock.patch.object(host.Host, 'has_min_version')",
            "    def test_get_guest_config_windows_timer(self, mock_version, mock_get_arch):",
            "        mock_version.return_value = True",
            "        mock_get_arch.return_value = arch.I686",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref['os_type'] = 'windows'",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info)",
            "",
            "        self.assertIsInstance(cfg.clock,",
            "                              vconfig.LibvirtConfigGuestClock)",
            "        self.assertEqual(cfg.clock.offset, \"localtime\")",
            "",
            "        self.assertEqual(4, len(cfg.clock.timers), cfg.clock.timers)",
            "        self.assertEqual(\"pit\", cfg.clock.timers[0].name)",
            "        self.assertEqual(\"rtc\", cfg.clock.timers[1].name)",
            "        self.assertEqual(\"hpet\", cfg.clock.timers[2].name)",
            "        self.assertFalse(cfg.clock.timers[2].present)",
            "        self.assertEqual(\"hypervclock\", cfg.clock.timers[3].name)",
            "        self.assertTrue(cfg.clock.timers[3].present)",
            "",
            "        self.assertEqual(3, len(cfg.features))",
            "        self.assertIsInstance(cfg.features[0],",
            "                              vconfig.LibvirtConfigGuestFeatureACPI)",
            "        self.assertIsInstance(cfg.features[1],",
            "                              vconfig.LibvirtConfigGuestFeatureAPIC)",
            "        self.assertIsInstance(cfg.features[2],",
            "                              vconfig.LibvirtConfigGuestFeatureHyperV)",
            "",
            "    @mock.patch.object(host.Host, 'has_min_version')",
            "    def test_get_guest_config_windows_hyperv_feature1(self, mock_version):",
            "        def fake_version(lv_ver=None, hv_ver=None, hv_type=None):",
            "            if lv_ver == (1, 0, 0) and hv_ver == (1, 1, 0):",
            "                return True",
            "            return False",
            "",
            "        mock_version.side_effect = fake_version",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref['os_type'] = 'windows'",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info)",
            "",
            "        self.assertIsInstance(cfg.clock,",
            "                              vconfig.LibvirtConfigGuestClock)",
            "        self.assertEqual(cfg.clock.offset, \"localtime\")",
            "",
            "        self.assertEqual(3, len(cfg.features))",
            "        self.assertIsInstance(cfg.features[0],",
            "                              vconfig.LibvirtConfigGuestFeatureACPI)",
            "        self.assertIsInstance(cfg.features[1],",
            "                              vconfig.LibvirtConfigGuestFeatureAPIC)",
            "        self.assertIsInstance(cfg.features[2],",
            "                              vconfig.LibvirtConfigGuestFeatureHyperV)",
            "",
            "        self.assertTrue(cfg.features[2].relaxed)",
            "        self.assertFalse(cfg.features[2].spinlocks)",
            "        self.assertFalse(cfg.features[2].vapic)",
            "",
            "    @mock.patch.object(host.Host, 'has_min_version')",
            "    def test_get_guest_config_windows_hyperv_feature2(self, mock_version):",
            "        mock_version.return_value = True",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref['os_type'] = 'windows'",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info)",
            "",
            "        self.assertIsInstance(cfg.clock,",
            "                              vconfig.LibvirtConfigGuestClock)",
            "        self.assertEqual(cfg.clock.offset, \"localtime\")",
            "",
            "        self.assertEqual(3, len(cfg.features))",
            "        self.assertIsInstance(cfg.features[0],",
            "                              vconfig.LibvirtConfigGuestFeatureACPI)",
            "        self.assertIsInstance(cfg.features[1],",
            "                              vconfig.LibvirtConfigGuestFeatureAPIC)",
            "        self.assertIsInstance(cfg.features[2],",
            "                              vconfig.LibvirtConfigGuestFeatureHyperV)",
            "",
            "        self.assertTrue(cfg.features[2].relaxed)",
            "        self.assertTrue(cfg.features[2].spinlocks)",
            "        self.assertEqual(8191, cfg.features[2].spinlock_retries)",
            "        self.assertTrue(cfg.features[2].vapic)",
            "",
            "    def test_get_guest_config_with_two_nics(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 2),",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(2, len(cfg.features))",
            "        self.assertIsInstance(cfg.features[0],",
            "                              vconfig.LibvirtConfigGuestFeatureACPI)",
            "        self.assertIsInstance(cfg.features[1],",
            "                              vconfig.LibvirtConfigGuestFeatureAPIC)",
            "        self.assertEqual(cfg.memory, 2 * units.Mi)",
            "        self.assertEqual(cfg.vcpus, 1)",
            "        self.assertEqual(cfg.os_type, vm_mode.HVM)",
            "        self.assertEqual(cfg.os_boot_dev, [\"hd\"])",
            "        self.assertIsNone(cfg.os_root)",
            "        self.assertEqual(len(cfg.devices), 10)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestInterface)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestInterface)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[8],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[9],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "    def test_get_guest_config_bug_1118829(self):",
            "        self.flags(virt_type='uml', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "",
            "        disk_info = {'disk_bus': 'virtio',",
            "                     'cdrom_bus': 'ide',",
            "                     'mapping': {u'vda': {'bus': 'virtio',",
            "                                          'type': 'disk',",
            "                                          'dev': u'vda'},",
            "                                 'root': {'bus': 'virtio',",
            "                                          'type': 'disk',",
            "                                          'dev': 'vda'}}}",
            "",
            "        # NOTE(jdg): For this specific test leave this blank",
            "        # This will exercise the failed code path still,",
            "        # and won't require fakes and stubs of the iscsi discovery",
            "        block_device_info = {}",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        drvr._get_guest_config(instance_ref, [], image_meta, disk_info,",
            "                               None, block_device_info)",
            "        self.assertEqual(instance_ref['root_device_name'], '/dev/vda')",
            "",
            "    def test_get_guest_config_with_root_device_name(self):",
            "        self.flags(virt_type='uml', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        block_device_info = {'root_device_name': '/dev/vdb'}",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta,",
            "                                            block_device_info)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info,",
            "                                     None, block_device_info)",
            "        self.assertEqual(0, len(cfg.features))",
            "        self.assertEqual(cfg.memory, 2 * units.Mi)",
            "        self.assertEqual(cfg.vcpus, 1)",
            "        self.assertEqual(cfg.os_type, \"uml\")",
            "        self.assertEqual(cfg.os_boot_dev, [])",
            "        self.assertEqual(cfg.os_root, '/dev/vdb')",
            "        self.assertEqual(len(cfg.devices), 3)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestConsole)",
            "",
            "    def test_has_uefi_support_with_invalid_version(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        with mock.patch.object(drvr._host,",
            "                               'has_min_version', return_value=False):",
            "            self.assertFalse(drvr._has_uefi_support())",
            "",
            "    def test_has_uefi_support_not_supported_arch(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"alpha\"",
            "        self.assertFalse(drvr._has_uefi_support())",
            "",
            "    @mock.patch('os.path.exists', return_value=False)",
            "    def test_has_uefi_support_with_no_loader_existed(self, mock_exist):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertFalse(drvr._has_uefi_support())",
            "",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    def test_has_uefi_support(self, mock_has_version):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "",
            "        with mock.patch.object(drvr._host,",
            "                               'has_min_version', return_value=True):",
            "            self.assertTrue(drvr._has_uefi_support())",
            "",
            "    def test_get_guest_config_with_uefi(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_firmware_type\": \"uefi\"}})",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        with test.nested(",
            "                mock.patch.object(drvr, \"_has_uefi_support\",",
            "                                  return_value=True)):",
            "            cfg = drvr._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "            self.assertEqual(cfg.os_loader_type, \"pflash\")",
            "",
            "    def test_get_guest_config_with_block_device(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        conn_info = {'driver_volume_type': 'fake'}",
            "        bdms = block_device_obj.block_device_make_list_from_dicts(",
            "            self.context, [",
            "                fake_block_device.FakeDbBlockDeviceDict(",
            "                    {'id': 1,",
            "                     'source_type': 'volume', 'destination_type': 'volume',",
            "                     'device_name': '/dev/vdc'}),",
            "                fake_block_device.FakeDbBlockDeviceDict(",
            "                    {'id': 2,",
            "                     'source_type': 'volume', 'destination_type': 'volume',",
            "                     'device_name': '/dev/vdd'}),",
            "            ]",
            "        )",
            "        info = {'block_device_mapping': driver_block_device.convert_volumes(",
            "            bdms",
            "        )}",
            "        info['block_device_mapping'][0]['connection_info'] = conn_info",
            "        info['block_device_mapping'][1]['connection_info'] = conn_info",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta,",
            "                                            info)",
            "        with mock.patch.object(",
            "                driver_block_device.DriverVolumeBlockDevice, 'save'",
            "        ) as mock_save:",
            "            cfg = drvr._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info,",
            "                                         None, info)",
            "            self.assertIsInstance(cfg.devices[2],",
            "                                  vconfig.LibvirtConfigGuestDisk)",
            "            self.assertEqual(cfg.devices[2].target_dev, 'vdc')",
            "            self.assertIsInstance(cfg.devices[3],",
            "                                  vconfig.LibvirtConfigGuestDisk)",
            "            self.assertEqual(cfg.devices[3].target_dev, 'vdd')",
            "            mock_save.assert_called_with()",
            "",
            "    def test_get_guest_config_lxc_with_attached_volume(self):",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        conn_info = {'driver_volume_type': 'fake'}",
            "        bdms = block_device_obj.block_device_make_list_from_dicts(",
            "            self.context, [",
            "              fake_block_device.FakeDbBlockDeviceDict(",
            "                    {'id': 1,",
            "                     'source_type': 'volume', 'destination_type': 'volume',",
            "                     'boot_index': 0}),",
            "              fake_block_device.FakeDbBlockDeviceDict(",
            "                    {'id': 2,",
            "                     'source_type': 'volume', 'destination_type': 'volume',",
            "                    }),",
            "              fake_block_device.FakeDbBlockDeviceDict(",
            "                    {'id': 3,",
            "                     'source_type': 'volume', 'destination_type': 'volume',",
            "                    }),",
            "           ]",
            "        )",
            "        info = {'block_device_mapping': driver_block_device.convert_volumes(",
            "            bdms",
            "        )}",
            "",
            "        info['block_device_mapping'][0]['connection_info'] = conn_info",
            "        info['block_device_mapping'][1]['connection_info'] = conn_info",
            "        info['block_device_mapping'][2]['connection_info'] = conn_info",
            "        info['block_device_mapping'][0]['mount_device'] = '/dev/vda'",
            "        info['block_device_mapping'][1]['mount_device'] = '/dev/vdc'",
            "        info['block_device_mapping'][2]['mount_device'] = '/dev/vdd'",
            "        with mock.patch.object(",
            "                driver_block_device.DriverVolumeBlockDevice, 'save'",
            "        ) as mock_save:",
            "            disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                                instance_ref,",
            "                                                image_meta,",
            "                                                info)",
            "            cfg = drvr._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info,",
            "                                         None, info)",
            "            self.assertIsInstance(cfg.devices[1],",
            "                                  vconfig.LibvirtConfigGuestDisk)",
            "            self.assertEqual(cfg.devices[1].target_dev, 'vdc')",
            "            self.assertIsInstance(cfg.devices[2],",
            "                                  vconfig.LibvirtConfigGuestDisk)",
            "            self.assertEqual(cfg.devices[2].target_dev, 'vdd')",
            "            mock_save.assert_called_with()",
            "",
            "    def test_get_guest_config_with_configdrive(self):",
            "        # It's necessary to check if the architecture is power, because",
            "        # power doesn't have support to ide, and so libvirt translate",
            "        # all ide calls to scsi",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        # make configdrive.required_by() return True",
            "        instance_ref['config_drive'] = True",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "",
            "        # The last device is selected for this. on x86 is the last ide",
            "        # device (hdd). Since power only support scsi, the last device",
            "        # is sdz",
            "",
            "        expect = {\"ppc\": \"sdz\", \"ppc64\": \"sdz\"}",
            "        disk = expect.get(blockinfo.libvirt_utils.get_arch({}), \"hdd\")",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertEqual(cfg.devices[2].target_dev, disk)",
            "",
            "    def test_get_guest_config_with_virtio_scsi_bus(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_scsi_model\": \"virtio-scsi\"}})",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta,",
            "                                            [])",
            "        cfg = drvr._get_guest_config(instance_ref, [], image_meta, disk_info)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                         vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                         vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                         vconfig.LibvirtConfigGuestController)",
            "        self.assertEqual(cfg.devices[2].model, 'virtio-scsi')",
            "",
            "    def test_get_guest_config_with_virtio_scsi_bus_bdm(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_scsi_model\": \"virtio-scsi\"}})",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        conn_info = {'driver_volume_type': 'fake'}",
            "        bdms = block_device_obj.block_device_make_list_from_dicts(",
            "            self.context, [",
            "                fake_block_device.FakeDbBlockDeviceDict(",
            "                    {'id': 1,",
            "                     'source_type': 'volume', 'destination_type': 'volume',",
            "                     'device_name': '/dev/sdc', 'disk_bus': 'scsi'}),",
            "                fake_block_device.FakeDbBlockDeviceDict(",
            "                    {'id': 2,",
            "                     'source_type': 'volume', 'destination_type': 'volume',",
            "                     'device_name': '/dev/sdd', 'disk_bus': 'scsi'}),",
            "                ]",
            "        )",
            "        bd_info = {",
            "            'block_device_mapping': driver_block_device.convert_volumes(bdms)}",
            "        bd_info['block_device_mapping'][0]['connection_info'] = conn_info",
            "        bd_info['block_device_mapping'][1]['connection_info'] = conn_info",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta,",
            "                                            bd_info)",
            "        with mock.patch.object(",
            "                driver_block_device.DriverVolumeBlockDevice, 'save'",
            "        ) as mock_save:",
            "            cfg = drvr._get_guest_config(instance_ref, [], image_meta,",
            "                    disk_info, [], bd_info)",
            "            self.assertIsInstance(cfg.devices[2],",
            "                             vconfig.LibvirtConfigGuestDisk)",
            "            self.assertEqual(cfg.devices[2].target_dev, 'sdc')",
            "            self.assertEqual(cfg.devices[2].target_bus, 'scsi')",
            "            self.assertIsInstance(cfg.devices[3],",
            "                             vconfig.LibvirtConfigGuestDisk)",
            "            self.assertEqual(cfg.devices[3].target_dev, 'sdd')",
            "            self.assertEqual(cfg.devices[3].target_bus, 'scsi')",
            "            self.assertIsInstance(cfg.devices[4],",
            "                             vconfig.LibvirtConfigGuestController)",
            "            self.assertEqual(cfg.devices[4].model, 'virtio-scsi')",
            "            mock_save.assert_called_with()",
            "",
            "    def test_get_guest_config_with_vnc(self):",
            "        self.flags(enabled=True, group='vnc')",
            "        self.flags(virt_type='kvm',",
            "                   use_usb_tablet=False,",
            "                   group='libvirt')",
            "        self.flags(enabled=False, group='spice')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 7)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[4].type, \"vnc\")",
            "",
            "    def test_get_guest_config_with_vnc_and_tablet(self):",
            "        self.flags(enabled=True, group='vnc')",
            "        self.flags(virt_type='kvm',",
            "                   use_usb_tablet=True,",
            "                   group='libvirt')",
            "        self.flags(enabled=False, group='spice')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 8)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[4].type, \"tablet\")",
            "        self.assertEqual(cfg.devices[5].type, \"vnc\")",
            "",
            "    def test_get_guest_config_with_spice_and_tablet(self):",
            "        self.flags(enabled=False, group='vnc')",
            "        self.flags(virt_type='kvm',",
            "                   use_usb_tablet=True,",
            "                   group='libvirt')",
            "        self.flags(enabled=True,",
            "                   agent_enabled=False,",
            "                   group='spice')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 8)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[4].type, \"tablet\")",
            "        self.assertEqual(cfg.devices[5].type, \"spice\")",
            "",
            "    def test_get_guest_config_with_spice_and_agent(self):",
            "        self.flags(enabled=False, group='vnc')",
            "        self.flags(virt_type='kvm',",
            "                   use_usb_tablet=True,",
            "                   group='libvirt')",
            "        self.flags(enabled=True,",
            "                   agent_enabled=True,",
            "                   group='spice')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 8)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestChannel)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[4].target_name, \"com.redhat.spice.0\")",
            "        self.assertEqual(cfg.devices[5].type, \"spice\")",
            "        self.assertEqual(cfg.devices[6].type, \"qxl\")",
            "",
            "    @mock.patch('nova.console.serial.acquire_port')",
            "    @mock.patch('nova.virt.hardware.get_number_of_serial_ports',",
            "                return_value=1)",
            "    @mock.patch.object(libvirt_driver.libvirt_utils, 'get_arch',)",
            "    def test_create_serial_console_devices_based_on_arch(self, mock_get_arch,",
            "                                           mock_get_port_number,",
            "                                           mock_acquire_port):",
            "        self.flags(enabled=True, group='serial_console')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        expected = {arch.X86_64: vconfig.LibvirtConfigGuestSerial,",
            "                    arch.S390: vconfig.LibvirtConfigGuestConsole,",
            "                    arch.S390X: vconfig.LibvirtConfigGuestConsole}",
            "",
            "        for guest_arch, device_type in expected.items():",
            "            mock_get_arch.return_value = guest_arch",
            "            guest = vconfig.LibvirtConfigGuest()",
            "            drvr._create_serial_console_devices(guest, instance=None,",
            "                                                flavor={}, image_meta={})",
            "            self.assertEqual(1, len(guest.devices))",
            "            console_device = guest.devices[0]",
            "            self.assertIsInstance(console_device, device_type)",
            "            self.assertEqual(\"tcp\", console_device.type)",
            "",
            "    @mock.patch('nova.console.serial.acquire_port')",
            "    def test_get_guest_config_serial_console(self, acquire_port):",
            "        self.flags(enabled=True, group='serial_console')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        acquire_port.return_value = 11111",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(8, len(cfg.devices))",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(\"tcp\", cfg.devices[2].type)",
            "        self.assertEqual(11111, cfg.devices[2].listen_port)",
            "",
            "    def test_get_guest_config_serial_console_through_flavor(self):",
            "        self.flags(enabled=True, group='serial_console')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'hw:serial_port_count': 3}",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(10, len(cfg.devices))",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[8],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[9],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(\"tcp\", cfg.devices[2].type)",
            "        self.assertEqual(\"tcp\", cfg.devices[3].type)",
            "        self.assertEqual(\"tcp\", cfg.devices[4].type)",
            "",
            "    def test_get_guest_config_serial_console_invalid_flavor(self):",
            "        self.flags(enabled=True, group='serial_console')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'hw:serial_port_count': \"a\"}",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        self.assertRaises(",
            "            exception.ImageSerialPortNumberInvalid,",
            "            drvr._get_guest_config, instance_ref, [],",
            "            image_meta, disk_info)",
            "",
            "    def test_get_guest_config_serial_console_image_and_flavor(self):",
            "        self.flags(enabled=True, group='serial_console')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_serial_port_count\": \"3\"}})",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'hw:serial_port_count': 4}",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [], image_meta,",
            "                                     disk_info)",
            "        self.assertEqual(10, len(cfg.devices), cfg.devices)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[8],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[9],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(\"tcp\", cfg.devices[2].type)",
            "        self.assertEqual(\"tcp\", cfg.devices[3].type)",
            "        self.assertEqual(\"tcp\", cfg.devices[4].type)",
            "",
            "    @mock.patch('nova.console.serial.acquire_port')",
            "    def test_get_guest_config_serial_console_through_port_rng_exhausted(",
            "            self, acquire_port):",
            "        self.flags(enabled=True, group='serial_console')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        acquire_port.side_effect = exception.SocketPortRangeExhaustedException(",
            "            '127.0.0.1')",
            "        self.assertRaises(",
            "            exception.SocketPortRangeExhaustedException,",
            "            drvr._get_guest_config, instance_ref, [],",
            "            image_meta, disk_info)",
            "",
            "    @mock.patch('os.path.getsize', return_value=0)  # size doesn't matter",
            "    @mock.patch('nova.virt.libvirt.storage.lvm.get_volume_size',",
            "                return_value='fake-size')",
            "    def test_detach_encrypted_volumes(self, mock_getsize,",
            "                                      mock_get_volume_size):",
            "        \"\"\"Test that unencrypted volumes are not disconnected with dmcrypt.\"\"\"",
            "        instance = objects.Instance(**self.test_instance)",
            "        xml = \"\"\"",
            "              <domain type='kvm'>",
            "                  <devices>",
            "                      <disk type='file'>",
            "                          <driver name='fake-driver' type='fake-type' />",
            "                          <source file='filename'/>",
            "                          <target dev='vdc' bus='virtio'/>",
            "                      </disk>",
            "                      <disk type='block' device='disk'>",
            "                          <driver name='fake-driver' type='fake-type' />",
            "                          <source dev='/dev/mapper/disk'/>",
            "                          <target dev='vda'/>",
            "                      </disk>",
            "                      <disk type='block' device='disk'>",
            "                          <driver name='fake-driver' type='fake-type' />",
            "                          <source dev='/dev/mapper/swap'/>",
            "                          <target dev='vdb'/>",
            "                      </disk>",
            "                  </devices>",
            "              </domain>",
            "              \"\"\"",
            "        dom = FakeVirtDomain(fake_xml=xml)",
            "        instance.ephemeral_key_uuid = 'fake-id'  # encrypted",
            "",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        @mock.patch.object(dmcrypt, 'delete_volume')",
            "        @mock.patch.object(conn._host, 'get_domain', return_value=dom)",
            "        def detach_encrypted_volumes(block_device_info, mock_get_domain,",
            "                                     mock_delete_volume):",
            "            conn._detach_encrypted_volumes(instance, block_device_info)",
            "",
            "            mock_get_domain.assert_called_once_with(instance)",
            "            self.assertFalse(mock_delete_volume.called)",
            "",
            "        block_device_info = {'root_device_name': '/dev/vda',",
            "                             'ephemerals': [],",
            "                             'block_device_mapping': []}",
            "",
            "        detach_encrypted_volumes(block_device_info)",
            "",
            "    @mock.patch.object(libvirt_guest.Guest, \"get_xml_desc\")",
            "    def test_get_serial_ports_from_guest(self, mock_get_xml_desc):",
            "        i = self._test_get_serial_ports_from_guest(None,",
            "                                                   mock_get_xml_desc)",
            "        self.assertEqual([",
            "            ('127.0.0.1', 100),",
            "            ('127.0.0.1', 101),",
            "            ('127.0.0.2', 100),",
            "            ('127.0.0.2', 101)], list(i))",
            "",
            "    @mock.patch.object(libvirt_guest.Guest, \"get_xml_desc\")",
            "    def test_get_serial_ports_from_guest_bind_only(self, mock_get_xml_desc):",
            "        i = self._test_get_serial_ports_from_guest('bind',",
            "                                                   mock_get_xml_desc)",
            "        self.assertEqual([",
            "            ('127.0.0.1', 101),",
            "            ('127.0.0.2', 100)], list(i))",
            "",
            "    @mock.patch.object(libvirt_guest.Guest, \"get_xml_desc\")",
            "    def test_get_serial_ports_from_guest_connect_only(self,",
            "                                                      mock_get_xml_desc):",
            "        i = self._test_get_serial_ports_from_guest('connect',",
            "                                                   mock_get_xml_desc)",
            "        self.assertEqual([",
            "            ('127.0.0.1', 100),",
            "            ('127.0.0.2', 101)], list(i))",
            "",
            "    @mock.patch.object(libvirt_guest.Guest, \"get_xml_desc\")",
            "    def test_get_serial_ports_from_guest_on_s390(self, mock_get_xml_desc):",
            "        i = self._test_get_serial_ports_from_guest(None,",
            "                                                   mock_get_xml_desc,",
            "                                                   'console')",
            "        self.assertEqual([",
            "            ('127.0.0.1', 100),",
            "            ('127.0.0.1', 101),",
            "            ('127.0.0.2', 100),",
            "            ('127.0.0.2', 101)], list(i))",
            "",
            "    def _test_get_serial_ports_from_guest(self, mode, mock_get_xml_desc,",
            "                                          dev_name='serial'):",
            "        xml = \"\"\"",
            "        <domain type='kvm'>",
            "          <devices>",
            "            <%(dev_name)s type=\"tcp\">",
            "              <source host=\"127.0.0.1\" service=\"100\" mode=\"connect\"/>",
            "            </%(dev_name)s>",
            "            <%(dev_name)s type=\"tcp\">",
            "              <source host=\"127.0.0.1\" service=\"101\" mode=\"bind\"/>",
            "            </%(dev_name)s>",
            "            <%(dev_name)s type=\"tcp\">",
            "              <source host=\"127.0.0.2\" service=\"100\" mode=\"bind\"/>",
            "            </%(dev_name)s>",
            "            <%(dev_name)s type=\"tcp\">",
            "              <source host=\"127.0.0.2\" service=\"101\" mode=\"connect\"/>",
            "            </%(dev_name)s>",
            "          </devices>",
            "        </domain>\"\"\" % {'dev_name': dev_name}",
            "",
            "        mock_get_xml_desc.return_value = xml",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        guest = libvirt_guest.Guest(FakeVirtDomain())",
            "        return drvr._get_serial_ports_from_guest(guest, mode=mode)",
            "",
            "    def test_get_guest_config_with_type_xen(self):",
            "        self.flags(enabled=True, group='vnc')",
            "        self.flags(virt_type='xen',",
            "                   use_usb_tablet=False,",
            "                   group='libvirt')",
            "        self.flags(enabled=False,",
            "                   group='spice')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 6)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestConsole)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[3].type, \"vnc\")",
            "        self.assertEqual(cfg.devices[4].type, \"xen\")",
            "",
            "    @mock.patch.object(libvirt_driver.libvirt_utils, 'get_arch',",
            "                       return_value=arch.S390X)",
            "    def test_get_guest_config_with_type_kvm_on_s390(self, mock_get_arch):",
            "        self.flags(enabled=False, group='vnc')",
            "        self.flags(virt_type='kvm',",
            "                   use_usb_tablet=False,",
            "                   group='libvirt')",
            "",
            "        self._stub_host_capabilities_cpu_arch(arch.S390X)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "",
            "        cfg = self._get_guest_config_via_fake_api(instance_ref)",
            "",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        log_file_device = cfg.devices[2]",
            "        self.assertIsInstance(log_file_device,",
            "                              vconfig.LibvirtConfigGuestConsole)",
            "        self.assertEqual(\"sclplm\", log_file_device.target_type)",
            "        self.assertEqual(\"file\", log_file_device.type)",
            "        terminal_device = cfg.devices[3]",
            "        self.assertIsInstance(terminal_device,",
            "                              vconfig.LibvirtConfigGuestConsole)",
            "        self.assertEqual(\"sclp\", terminal_device.target_type)",
            "        self.assertEqual(\"pty\", terminal_device.type)",
            "        self.assertEqual(\"s390-ccw-virtio\", cfg.os_mach_type)",
            "",
            "    def _stub_host_capabilities_cpu_arch(self, cpu_arch):",
            "        def get_host_capabilities_stub(self):",
            "            cpu = vconfig.LibvirtConfigGuestCPU()",
            "            cpu.arch = cpu_arch",
            "",
            "            caps = vconfig.LibvirtConfigCaps()",
            "            caps.host = vconfig.LibvirtConfigCapsHost()",
            "            caps.host.cpu = cpu",
            "            return caps",
            "",
            "        self.stubs.Set(host.Host, \"get_capabilities\",",
            "                       get_host_capabilities_stub)",
            "",
            "    def _get_guest_config_via_fake_api(self, instance):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta)",
            "        return drvr._get_guest_config(instance, [],",
            "                                      image_meta, disk_info)",
            "",
            "    def test_get_guest_config_with_type_xen_pae_hvm(self):",
            "        self.flags(enabled=True, group='vnc')",
            "        self.flags(virt_type='xen',",
            "                   use_usb_tablet=False,",
            "                   group='libvirt')",
            "        self.flags(enabled=False,",
            "                   group='spice')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref['vm_mode'] = vm_mode.HVM",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "",
            "        self.assertEqual(cfg.os_type, vm_mode.HVM)",
            "        self.assertEqual(cfg.os_loader, CONF.libvirt.xen_hvmloader_path)",
            "        self.assertEqual(3, len(cfg.features))",
            "        self.assertIsInstance(cfg.features[0],",
            "                              vconfig.LibvirtConfigGuestFeaturePAE)",
            "        self.assertIsInstance(cfg.features[1],",
            "                              vconfig.LibvirtConfigGuestFeatureACPI)",
            "        self.assertIsInstance(cfg.features[2],",
            "                              vconfig.LibvirtConfigGuestFeatureAPIC)",
            "",
            "    def test_get_guest_config_with_type_xen_pae_pvm(self):",
            "        self.flags(enabled=True, group='vnc')",
            "        self.flags(virt_type='xen',",
            "                   use_usb_tablet=False,",
            "                   group='libvirt')",
            "        self.flags(enabled=False,",
            "                   group='spice')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "",
            "        self.assertEqual(cfg.os_type, vm_mode.XEN)",
            "        self.assertEqual(1, len(cfg.features))",
            "        self.assertIsInstance(cfg.features[0],",
            "                              vconfig.LibvirtConfigGuestFeaturePAE)",
            "",
            "    def test_get_guest_config_with_vnc_and_spice(self):",
            "        self.flags(enabled=True, group='vnc')",
            "        self.flags(virt_type='kvm',",
            "                   use_usb_tablet=True,",
            "                   group='libvirt')",
            "        self.flags(enabled=True,",
            "                   agent_enabled=True,",
            "                   group='spice')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 10)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestChannel)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[8],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[9],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[4].type, \"tablet\")",
            "        self.assertEqual(cfg.devices[5].target_name, \"com.redhat.spice.0\")",
            "        self.assertEqual(cfg.devices[6].type, \"vnc\")",
            "        self.assertEqual(cfg.devices[7].type, \"spice\")",
            "",
            "    def test_get_guest_config_with_watchdog_action_image_meta(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_watchdog_action\": \"none\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [], image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 9)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigGuestWatchdog)",
            "        self.assertIsInstance(cfg.devices[8],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(\"none\", cfg.devices[7].action)",
            "",
            "    def _test_get_guest_usb_tablet(self, vnc_enabled, spice_enabled, os_type,",
            "                                   agent_enabled=False):",
            "        self.flags(enabled=vnc_enabled, group='vnc')",
            "        self.flags(enabled=spice_enabled,",
            "                   agent_enabled=agent_enabled, group='spice')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        return drvr._get_guest_usb_tablet(os_type)",
            "",
            "    def test_get_guest_usb_tablet_wipe(self):",
            "        self.flags(use_usb_tablet=True, group='libvirt')",
            "",
            "        tablet = self._test_get_guest_usb_tablet(True, True, vm_mode.HVM)",
            "        self.assertIsNotNone(tablet)",
            "",
            "        tablet = self._test_get_guest_usb_tablet(True, False, vm_mode.HVM)",
            "        self.assertIsNotNone(tablet)",
            "",
            "        tablet = self._test_get_guest_usb_tablet(False, True, vm_mode.HVM)",
            "        self.assertIsNotNone(tablet)",
            "",
            "        tablet = self._test_get_guest_usb_tablet(False, False, vm_mode.HVM)",
            "        self.assertIsNone(tablet)",
            "",
            "        tablet = self._test_get_guest_usb_tablet(True, True, \"foo\")",
            "        self.assertIsNone(tablet)",
            "",
            "        tablet = self._test_get_guest_usb_tablet(",
            "            False, True, vm_mode.HVM, True)",
            "        self.assertIsNone(tablet)",
            "",
            "    def _test_get_guest_config_with_watchdog_action_flavor(self,",
            "            hw_watchdog_action=\"hw:watchdog_action\"):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {hw_watchdog_action: 'none'}",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "",
            "        self.assertEqual(9, len(cfg.devices))",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                            vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigGuestWatchdog)",
            "        self.assertIsInstance(cfg.devices[8],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(\"none\", cfg.devices[7].action)",
            "",
            "    def test_get_guest_config_with_watchdog_action_through_flavor(self):",
            "        self._test_get_guest_config_with_watchdog_action_flavor()",
            "",
            "    # TODO(pkholkin): the test accepting old property name 'hw_watchdog_action'",
            "    #                should be removed in the next release",
            "    def test_get_guest_config_with_watchdog_action_through_flavor_no_scope(",
            "            self):",
            "        self._test_get_guest_config_with_watchdog_action_flavor(",
            "            hw_watchdog_action=\"hw_watchdog_action\")",
            "",
            "    def test_get_guest_config_with_watchdog_overrides_flavor(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'hw_watchdog_action': 'none'}",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_watchdog_action\": \"pause\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "",
            "        self.assertEqual(9, len(cfg.devices))",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigGuestWatchdog)",
            "        self.assertIsInstance(cfg.devices[8],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(\"pause\", cfg.devices[7].action)",
            "",
            "    def test_get_guest_config_with_video_driver_image_meta(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_video_model\": \"vmvga\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [], image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 8)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[5].type, \"vnc\")",
            "        self.assertEqual(cfg.devices[6].type, \"vmvga\")",
            "",
            "    def test_get_guest_config_with_qga_through_image_meta(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_qemu_guest_agent\": \"yes\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [], image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 9)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigGuestChannel)",
            "        self.assertIsInstance(cfg.devices[8],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[4].type, \"tablet\")",
            "        self.assertEqual(cfg.devices[5].type, \"vnc\")",
            "        self.assertEqual(cfg.devices[7].type, \"unix\")",
            "        self.assertEqual(cfg.devices[7].target_name, \"org.qemu.guest_agent.0\")",
            "",
            "    def test_get_guest_config_with_video_driver_vram(self):",
            "        self.flags(enabled=False, group='vnc')",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        self.flags(enabled=True,",
            "                   agent_enabled=True,",
            "                   group='spice')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'hw_video:ram_max_mb': \"100\"}",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_video_model\": \"qxl\",",
            "                           \"hw_video_ram\": \"64\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 8)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestChannel)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[5].type, \"spice\")",
            "        self.assertEqual(cfg.devices[6].type, \"qxl\")",
            "        self.assertEqual(cfg.devices[6].vram, 64 * units.Mi / units.Ki)",
            "",
            "    @mock.patch('nova.virt.disk.api.teardown_container')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.get_info')",
            "    @mock.patch('nova.virt.disk.api.setup_container')",
            "    @mock.patch('oslo_utils.fileutils.ensure_tree')",
            "    @mock.patch.object(fake_libvirt_utils, 'get_instance_path')",
            "    def test_unmount_fs_if_error_during_lxc_create_domain(self,",
            "            mock_get_inst_path, mock_ensure_tree, mock_setup_container,",
            "            mock_get_info, mock_teardown):",
            "        \"\"\"If we hit an error during a `_create_domain` call to `libvirt+lxc`",
            "        we need to ensure the guest FS is unmounted from the host so that any",
            "        future `lvremove` calls will work.",
            "        \"\"\"",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        mock_instance = mock.MagicMock()",
            "        mock_get_inst_path.return_value = '/tmp/'",
            "        mock_image_backend = mock.MagicMock()",
            "        drvr.image_backend = mock_image_backend",
            "        mock_image = mock.MagicMock()",
            "        mock_image.path = '/tmp/test.img'",
            "        drvr.image_backend.image.return_value = mock_image",
            "        mock_setup_container.return_value = '/dev/nbd0'",
            "        mock_get_info.side_effect = exception.InstanceNotFound(",
            "                                                   instance_id='foo')",
            "        drvr._conn.defineXML = mock.Mock()",
            "        drvr._conn.defineXML.side_effect = ValueError('somethingbad')",
            "        with test.nested(",
            "              mock.patch.object(drvr, '_is_booted_from_volume',",
            "                                return_value=False),",
            "              mock.patch.object(drvr, 'plug_vifs'),",
            "              mock.patch.object(drvr, 'firewall_driver'),",
            "              mock.patch.object(drvr, 'cleanup')):",
            "            self.assertRaises(ValueError,",
            "                              drvr._create_domain_and_network,",
            "                              self.context,",
            "                              'xml',",
            "                              mock_instance, None, None)",
            "",
            "            mock_teardown.assert_called_with(container_dir='/tmp/rootfs')",
            "",
            "    def test_video_driver_flavor_limit_not_set(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        self.flags(enabled=True,",
            "                   agent_enabled=True,",
            "                   group='spice')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_video_model\": \"qxl\",",
            "                           \"hw_video_ram\": \"64\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        with mock.patch.object(objects.Instance, 'save'):",
            "            self.assertRaises(exception.RequestedVRamTooHigh,",
            "                              drvr._get_guest_config,",
            "                              instance_ref,",
            "                              [],",
            "                              image_meta,",
            "                              disk_info)",
            "",
            "    def test_video_driver_ram_above_flavor_limit(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        self.flags(enabled=True,",
            "                   agent_enabled=True,",
            "                   group='spice')",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_type = instance_ref.get_flavor()",
            "        instance_type.extra_specs = {'hw_video:ram_max_mb': \"50\"}",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_video_model\": \"qxl\",",
            "                           \"hw_video_ram\": \"64\"}})",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        with mock.patch.object(objects.Instance, 'save'):",
            "            self.assertRaises(exception.RequestedVRamTooHigh,",
            "                              drvr._get_guest_config,",
            "                              instance_ref,",
            "                              [],",
            "                              image_meta,",
            "                              disk_info)",
            "",
            "    def test_get_guest_config_without_qga_through_image_meta(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_qemu_guest_agent\": \"no\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [], image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 8)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[4].type, \"tablet\")",
            "        self.assertEqual(cfg.devices[5].type, \"vnc\")",
            "",
            "    def test_get_guest_config_with_rng_device(self):",
            "        self.flags(virt_type='kvm',",
            "                   use_usb_tablet=False,",
            "                   group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'hw_rng:allowed': 'True'}",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_rng_model\": \"virtio\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 8)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                            vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestRng)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[6].model, 'random')",
            "        self.assertIsNone(cfg.devices[6].backend)",
            "        self.assertIsNone(cfg.devices[6].rate_bytes)",
            "        self.assertIsNone(cfg.devices[6].rate_period)",
            "",
            "    def test_get_guest_config_with_rng_not_allowed(self):",
            "        self.flags(virt_type='kvm',",
            "                   use_usb_tablet=False,",
            "                   group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_rng_model\": \"virtio\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 7)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "    def test_get_guest_config_with_rng_limits(self):",
            "        self.flags(virt_type='kvm',",
            "                   use_usb_tablet=False,",
            "                   group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'hw_rng:allowed': 'True',",
            "                                           'hw_rng:rate_bytes': '1024',",
            "                                           'hw_rng:rate_period': '2'}",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_rng_model\": \"virtio\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 8)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestRng)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                            vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[6].model, 'random')",
            "        self.assertIsNone(cfg.devices[6].backend)",
            "        self.assertEqual(cfg.devices[6].rate_bytes, 1024)",
            "        self.assertEqual(cfg.devices[6].rate_period, 2)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.os.path.exists')",
            "    def test_get_guest_config_with_rng_backend(self, mock_path):",
            "        self.flags(virt_type='kvm',",
            "                   use_usb_tablet=False,",
            "                   rng_dev_path='/dev/hw_rng',",
            "                   group='libvirt')",
            "        mock_path.return_value = True",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'hw_rng:allowed': 'True'}",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_rng_model\": \"virtio\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 8)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                            vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestRng)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[6].model, 'random')",
            "        self.assertEqual(cfg.devices[6].backend, '/dev/hw_rng')",
            "        self.assertIsNone(cfg.devices[6].rate_bytes)",
            "        self.assertIsNone(cfg.devices[6].rate_period)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.os.path.exists')",
            "    def test_get_guest_config_with_rng_dev_not_present(self, mock_path):",
            "        self.flags(virt_type='kvm',",
            "                   use_usb_tablet=False,",
            "                   rng_dev_path='/dev/hw_rng',",
            "                   group='libvirt')",
            "        mock_path.return_value = False",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'hw_rng:allowed': 'True'}",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_rng_model\": \"virtio\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        self.assertRaises(exception.RngDeviceNotExist,",
            "                          drvr._get_guest_config,",
            "                          instance_ref,",
            "                          [],",
            "                          image_meta, disk_info)",
            "",
            "    @mock.patch.object(",
            "        host.Host, \"is_cpu_control_policy_capable\", return_value=True)",
            "    def test_guest_cpu_shares_with_multi_vcpu(self, is_able):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.vcpus = 4",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "",
            "        self.assertEqual(4096, cfg.cputune.shares)",
            "",
            "    @mock.patch.object(",
            "        host.Host, \"is_cpu_control_policy_capable\", return_value=True)",
            "    def test_get_guest_config_with_cpu_quota(self, is_able):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'quota:cpu_shares': '10000',",
            "                                           'quota:cpu_period': '20000'}",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "",
            "        self.assertEqual(10000, cfg.cputune.shares)",
            "        self.assertEqual(20000, cfg.cputune.period)",
            "",
            "    @mock.patch.object(",
            "        host.Host, \"is_cpu_control_policy_capable\", return_value=True)",
            "    def test_get_guest_config_with_bogus_cpu_quota(self, is_able):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'quota:cpu_shares': 'fishfood',",
            "                                           'quota:cpu_period': '20000'}",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        self.assertRaises(ValueError,",
            "                          drvr._get_guest_config,",
            "                          instance_ref, [], image_meta, disk_info)",
            "",
            "    @mock.patch.object(",
            "        host.Host, \"is_cpu_control_policy_capable\", return_value=False)",
            "    def test_get_update_guest_cputune(self, is_able):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'quota:cpu_shares': '10000',",
            "                                           'quota:cpu_period': '20000'}",
            "        self.assertRaises(",
            "            exception.UnsupportedHostCPUControlPolicy,",
            "            drvr._update_guest_cputune, {}, instance_ref.flavor, \"kvm\")",
            "",
            "    def _test_get_guest_config_sysinfo_serial(self, expected_serial):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "",
            "        cfg = drvr._get_guest_config_sysinfo(instance_ref)",
            "",
            "        self.assertIsInstance(cfg, vconfig.LibvirtConfigGuestSysinfo)",
            "        self.assertEqual(version.vendor_string(),",
            "                         cfg.system_manufacturer)",
            "        self.assertEqual(version.product_string(),",
            "                         cfg.system_product)",
            "        self.assertEqual(version.version_string_with_package(),",
            "                         cfg.system_version)",
            "        self.assertEqual(expected_serial,",
            "                         cfg.system_serial)",
            "        self.assertEqual(instance_ref['uuid'],",
            "                         cfg.system_uuid)",
            "        self.assertEqual(\"Virtual Machine\",",
            "                         cfg.system_family)",
            "",
            "    def test_get_guest_config_sysinfo_serial_none(self):",
            "        self.flags(sysinfo_serial=\"none\", group=\"libvirt\")",
            "        self._test_get_guest_config_sysinfo_serial(None)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver,",
            "                       \"_get_host_sysinfo_serial_hardware\")",
            "    def test_get_guest_config_sysinfo_serial_hardware(self, mock_uuid):",
            "        self.flags(sysinfo_serial=\"hardware\", group=\"libvirt\")",
            "",
            "        theuuid = \"56b40135-a973-4eb3-87bb-a2382a3e6dbc\"",
            "        mock_uuid.return_value = theuuid",
            "",
            "        self._test_get_guest_config_sysinfo_serial(theuuid)",
            "",
            "    @contextlib.contextmanager",
            "    def patch_exists(self, result):",
            "        real_exists = os.path.exists",
            "",
            "        def fake_exists(filename):",
            "            if filename == \"/etc/machine-id\":",
            "                return result",
            "            return real_exists(filename)",
            "",
            "        with mock.patch.object(os.path, \"exists\") as mock_exists:",
            "            mock_exists.side_effect = fake_exists",
            "            yield mock_exists",
            "",
            "    def test_get_guest_config_sysinfo_serial_os(self):",
            "        self.flags(sysinfo_serial=\"os\", group=\"libvirt\")",
            "        theuuid = \"56b40135-a973-4eb3-87bb-a2382a3e6dbc\"",
            "        with test.nested(",
            "                mock.patch.object(six.moves.builtins, \"open\",",
            "                    mock.mock_open(read_data=theuuid)),",
            "                self.patch_exists(True)):",
            "            self._test_get_guest_config_sysinfo_serial(theuuid)",
            "",
            "    def test_get_guest_config_sysinfo_serial_os_empty_machine_id(self):",
            "        self.flags(sysinfo_serial=\"os\", group=\"libvirt\")",
            "        with test.nested(",
            "                mock.patch.object(six.moves.builtins, \"open\",",
            "                                  mock.mock_open(read_data=\"\")),",
            "                self.patch_exists(True)):",
            "            self.assertRaises(exception.NovaException,",
            "                    self._test_get_guest_config_sysinfo_serial,",
            "                    None)",
            "",
            "    def test_get_guest_config_sysinfo_serial_os_no_machine_id_file(self):",
            "        self.flags(sysinfo_serial=\"os\", group=\"libvirt\")",
            "        with self.patch_exists(False):",
            "            self.assertRaises(exception.NovaException,",
            "                    self._test_get_guest_config_sysinfo_serial,",
            "                    None)",
            "",
            "    def test_get_guest_config_sysinfo_serial_auto_hardware(self):",
            "        self.flags(sysinfo_serial=\"auto\", group=\"libvirt\")",
            "",
            "        real_exists = os.path.exists",
            "        with test.nested(",
            "                mock.patch.object(os.path, \"exists\"),",
            "                mock.patch.object(libvirt_driver.LibvirtDriver,",
            "                                  \"_get_host_sysinfo_serial_hardware\")",
            "        ) as (mock_exists, mock_uuid):",
            "            def fake_exists(filename):",
            "                if filename == \"/etc/machine-id\":",
            "                    return False",
            "                return real_exists(filename)",
            "",
            "            mock_exists.side_effect = fake_exists",
            "",
            "            theuuid = \"56b40135-a973-4eb3-87bb-a2382a3e6dbc\"",
            "            mock_uuid.return_value = theuuid",
            "",
            "            self._test_get_guest_config_sysinfo_serial(theuuid)",
            "",
            "    def test_get_guest_config_sysinfo_serial_auto_os(self):",
            "        self.flags(sysinfo_serial=\"auto\", group=\"libvirt\")",
            "",
            "        real_exists = os.path.exists",
            "        real_open = builtins.open",
            "        with test.nested(",
            "                mock.patch.object(os.path, \"exists\"),",
            "                mock.patch.object(builtins, \"open\"),",
            "        ) as (mock_exists, mock_open):",
            "            def fake_exists(filename):",
            "                if filename == \"/etc/machine-id\":",
            "                    return True",
            "                return real_exists(filename)",
            "",
            "            mock_exists.side_effect = fake_exists",
            "",
            "            theuuid = \"56b40135-a973-4eb3-87bb-a2382a3e6dbc\"",
            "",
            "            def fake_open(filename, *args, **kwargs):",
            "                if filename == \"/etc/machine-id\":",
            "                    h = mock.MagicMock()",
            "                    h.read.return_value = theuuid",
            "                    h.__enter__.return_value = h",
            "                    return h",
            "                return real_open(filename, *args, **kwargs)",
            "",
            "            mock_open.side_effect = fake_open",
            "",
            "            self._test_get_guest_config_sysinfo_serial(theuuid)",
            "",
            "    def _create_fake_service_compute(self):",
            "        service_info = {",
            "            'id': 1729,",
            "            'host': 'fake',",
            "            'report_count': 0",
            "        }",
            "        service_ref = objects.Service(**service_info)",
            "",
            "        compute_info = {",
            "            'id': 1729,",
            "            'vcpus': 2,",
            "            'memory_mb': 1024,",
            "            'local_gb': 2048,",
            "            'vcpus_used': 0,",
            "            'memory_mb_used': 0,",
            "            'local_gb_used': 0,",
            "            'free_ram_mb': 1024,",
            "            'free_disk_gb': 2048,",
            "            'hypervisor_type': 'xen',",
            "            'hypervisor_version': 1,",
            "            'running_vms': 0,",
            "            'cpu_info': '',",
            "            'current_workload': 0,",
            "            'service_id': service_ref['id'],",
            "            'host': service_ref['host']",
            "        }",
            "        compute_ref = objects.ComputeNode(**compute_info)",
            "        return (service_ref, compute_ref)",
            "",
            "    def test_get_guest_config_with_pci_passthrough_kvm(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        service_ref, compute_ref = self._create_fake_service_compute()",
            "",
            "        instance = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        pci_device_info = dict(test_pci_device.fake_db_dev)",
            "        pci_device_info.update(compute_node_id=1,",
            "                               label='fake',",
            "                               status=fields.PciDeviceStatus.ALLOCATED,",
            "                               address='0000:00:00.1',",
            "                               compute_id=compute_ref['id'],",
            "                               instance_uuid=instance.uuid,",
            "                               request_id=None,",
            "                               extra_info={})",
            "        pci_device = objects.PciDevice(**pci_device_info)",
            "        pci_list = objects.PciDeviceList()",
            "        pci_list.objects.append(pci_device)",
            "        instance.pci_devices = pci_list",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance, [],",
            "                                     image_meta, disk_info)",
            "",
            "        had_pci = 0",
            "        # care only about the PCI devices",
            "        for dev in cfg.devices:",
            "            if type(dev) == vconfig.LibvirtConfigGuestHostdevPCI:",
            "                had_pci += 1",
            "                self.assertEqual(dev.type, 'pci')",
            "                self.assertEqual(dev.managed, 'yes')",
            "                self.assertEqual(dev.mode, 'subsystem')",
            "",
            "                self.assertEqual(dev.domain, \"0000\")",
            "                self.assertEqual(dev.bus, \"00\")",
            "                self.assertEqual(dev.slot, \"00\")",
            "                self.assertEqual(dev.function, \"1\")",
            "        self.assertEqual(had_pci, 1)",
            "",
            "    def test_get_guest_config_with_pci_passthrough_xen(self):",
            "        self.flags(virt_type='xen', group='libvirt')",
            "        service_ref, compute_ref = self._create_fake_service_compute()",
            "",
            "        instance = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        pci_device_info = dict(test_pci_device.fake_db_dev)",
            "        pci_device_info.update(compute_node_id=1,",
            "                               label='fake',",
            "                               status=fields.PciDeviceStatus.ALLOCATED,",
            "                               address='0000:00:00.2',",
            "                               compute_id=compute_ref['id'],",
            "                               instance_uuid=instance.uuid,",
            "                               request_id=None,",
            "                               extra_info={})",
            "        pci_device = objects.PciDevice(**pci_device_info)",
            "        pci_list = objects.PciDeviceList()",
            "        pci_list.objects.append(pci_device)",
            "        instance.pci_devices = pci_list",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance, [],",
            "                                     image_meta, disk_info)",
            "        had_pci = 0",
            "        # care only about the PCI devices",
            "        for dev in cfg.devices:",
            "            if type(dev) == vconfig.LibvirtConfigGuestHostdevPCI:",
            "                had_pci += 1",
            "                self.assertEqual(dev.type, 'pci')",
            "                self.assertEqual(dev.managed, 'no')",
            "                self.assertEqual(dev.mode, 'subsystem')",
            "",
            "                self.assertEqual(dev.domain, \"0000\")",
            "                self.assertEqual(dev.bus, \"00\")",
            "                self.assertEqual(dev.slot, \"00\")",
            "                self.assertEqual(dev.function, \"2\")",
            "        self.assertEqual(had_pci, 1)",
            "",
            "    def test_get_guest_config_os_command_line_through_image_meta(self):",
            "        self.flags(virt_type=\"kvm\",",
            "                   cpu_mode=None,",
            "                   group='libvirt')",
            "",
            "        self.test_instance['kernel_id'] = \"fake_kernel_id\"",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"os_command_line\":",
            "                           \"fake_os_command_line\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(cfg.os_cmdline, \"fake_os_command_line\")",
            "",
            "    def test_get_guest_config_os_command_line_without_kernel_id(self):",
            "        self.flags(virt_type=\"kvm\",",
            "                cpu_mode=None,",
            "                group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"os_command_line\":",
            "                           \"fake_os_command_line\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info)",
            "        self.assertIsNone(cfg.os_cmdline)",
            "",
            "    def test_get_guest_config_os_command_empty(self):",
            "        self.flags(virt_type=\"kvm\",",
            "                   cpu_mode=None,",
            "                   group='libvirt')",
            "",
            "        self.test_instance['kernel_id'] = \"fake_kernel_id\"",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"os_command_line\": \"\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        # the instance has 'root=/dev/vda console=tty0 console=ttyS0' set by",
            "        # default, so testing an empty string and None value in the",
            "        # os_command_line image property must pass",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info)",
            "        self.assertNotEqual(cfg.os_cmdline, \"\")",
            "",
            "    def test_get_guest_config_armv7(self):",
            "        def get_host_capabilities_stub(self):",
            "            cpu = vconfig.LibvirtConfigGuestCPU()",
            "            cpu.arch = arch.ARMV7",
            "",
            "            caps = vconfig.LibvirtConfigCaps()",
            "            caps.host = vconfig.LibvirtConfigCapsHost()",
            "            caps.host.cpu = cpu",
            "            return caps",
            "",
            "        self.flags(virt_type=\"kvm\",",
            "                   group=\"libvirt\")",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        self.stubs.Set(host.Host, \"get_capabilities\",",
            "                       get_host_capabilities_stub)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(cfg.os_mach_type, \"vexpress-a15\")",
            "",
            "    def test_get_guest_config_aarch64(self):",
            "        def get_host_capabilities_stub(self):",
            "            cpu = vconfig.LibvirtConfigGuestCPU()",
            "            cpu.arch = arch.AARCH64",
            "",
            "            caps = vconfig.LibvirtConfigCaps()",
            "            caps.host = vconfig.LibvirtConfigCapsHost()",
            "            caps.host.cpu = cpu",
            "            return caps",
            "",
            "        self.flags(virt_type=\"kvm\",",
            "                   group=\"libvirt\")",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        self.stubs.Set(host.Host, \"get_capabilities\",",
            "                       get_host_capabilities_stub)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(cfg.os_mach_type, \"virt\")",
            "",
            "    def test_get_guest_config_machine_type_s390(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigGuestCPU()",
            "",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        host_cpu_archs = (arch.S390, arch.S390X)",
            "        for host_cpu_arch in host_cpu_archs:",
            "            caps.host.cpu.arch = host_cpu_arch",
            "            os_mach_type = drvr._get_machine_type(image_meta, caps)",
            "            self.assertEqual('s390-ccw-virtio', os_mach_type)",
            "",
            "    def test_get_guest_config_machine_type_through_image_meta(self):",
            "        self.flags(virt_type=\"kvm\",",
            "                   group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_machine_type\":",
            "                           \"fake_machine_type\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(cfg.os_mach_type, \"fake_machine_type\")",
            "",
            "    def test_get_guest_config_machine_type_from_config(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        self.flags(hw_machine_type=['x86_64=fake_machine_type'],",
            "                group='libvirt')",
            "",
            "        def fake_getCapabilities():",
            "            return \"\"\"",
            "            <capabilities>",
            "                <host>",
            "                    <uuid>cef19ce0-0ca2-11df-855d-b19fbce37686</uuid>",
            "                    <cpu>",
            "                      <arch>x86_64</arch>",
            "                      <model>Penryn</model>",
            "                      <vendor>Intel</vendor>",
            "                      <topology sockets='1' cores='2' threads='1'/>",
            "                      <feature name='xtpr'/>",
            "                    </cpu>",
            "                </host>",
            "            </capabilities>",
            "            \"\"\"",
            "",
            "        def fake_baselineCPU(cpu, flag):",
            "            return \"\"\"<cpu mode='custom' match='exact'>",
            "                        <model fallback='allow'>Penryn</model>",
            "                        <vendor>Intel</vendor>",
            "                        <feature policy='require' name='xtpr'/>",
            "                      </cpu>",
            "                   \"\"\"",
            "",
            "        # Make sure the host arch is mocked as x86_64",
            "        self.create_fake_libvirt_mock(getCapabilities=fake_getCapabilities,",
            "                                      baselineCPU=fake_baselineCPU,",
            "                                      getVersion=lambda: 1005001)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(cfg.os_mach_type, \"fake_machine_type\")",
            "",
            "    def _test_get_guest_config_ppc64(self, device_index):",
            "        \"\"\"Test for nova.virt.libvirt.driver.LibvirtDriver._get_guest_config.",
            "        \"\"\"",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        expected = (arch.PPC64, arch.PPC)",
            "        for guestarch in expected:",
            "            with mock.patch.object(libvirt_driver.libvirt_utils,",
            "                                   'get_arch',",
            "                                   return_value=guestarch):",
            "                cfg = drvr._get_guest_config(instance_ref, [],",
            "                                            image_meta,",
            "                                            disk_info)",
            "                self.assertIsInstance(cfg.devices[device_index],",
            "                                      vconfig.LibvirtConfigGuestVideo)",
            "                self.assertEqual(cfg.devices[device_index].type, 'vga')",
            "",
            "    def test_get_guest_config_ppc64_through_image_meta_vnc_enabled(self):",
            "        self.flags(enabled=True, group='vnc')",
            "        self._test_get_guest_config_ppc64(6)",
            "",
            "    def test_get_guest_config_ppc64_through_image_meta_spice_enabled(self):",
            "        self.flags(enabled=True,",
            "                   agent_enabled=True,",
            "                   group='spice')",
            "        self._test_get_guest_config_ppc64(8)",
            "",
            "    def _test_get_guest_config_bootmenu(self, image_meta, extra_specs):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = extra_specs",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref, image_meta)",
            "        conf = conn._get_guest_config(instance_ref, [], image_meta, disk_info)",
            "        self.assertTrue(conf.os_bootmenu)",
            "",
            "    def test_get_guest_config_bootmenu_via_image_meta(self):",
            "        image_meta = objects.ImageMeta.from_dict(",
            "            {\"disk_format\": \"raw\",",
            "             \"properties\": {\"hw_boot_menu\": \"True\"}})",
            "        self._test_get_guest_config_bootmenu(image_meta, {})",
            "",
            "    def test_get_guest_config_bootmenu_via_extra_specs(self):",
            "        image_meta = objects.ImageMeta.from_dict(",
            "            self.test_image_meta)",
            "        self._test_get_guest_config_bootmenu(image_meta,",
            "                                             {'hw:boot_menu': 'True'})",
            "",
            "    def test_get_guest_cpu_config_none(self):",
            "        self.flags(cpu_mode=\"none\", group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        conf = drvr._get_guest_config(instance_ref,",
            "                                      _fake_network_info(self, 1),",
            "                                      image_meta, disk_info)",
            "        self.assertIsInstance(conf.cpu,",
            "                              vconfig.LibvirtConfigGuestCPU)",
            "        self.assertIsNone(conf.cpu.mode)",
            "        self.assertIsNone(conf.cpu.model)",
            "        self.assertEqual(conf.cpu.sockets, 1)",
            "        self.assertEqual(conf.cpu.cores, 1)",
            "        self.assertEqual(conf.cpu.threads, 1)",
            "",
            "    def test_get_guest_cpu_config_default_kvm(self):",
            "        self.flags(virt_type=\"kvm\",",
            "                   cpu_mode=None,",
            "                   group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        conf = drvr._get_guest_config(instance_ref,",
            "                                      _fake_network_info(self, 1),",
            "                                      image_meta, disk_info)",
            "        self.assertIsInstance(conf.cpu,",
            "                              vconfig.LibvirtConfigGuestCPU)",
            "        self.assertEqual(conf.cpu.mode, \"host-model\")",
            "        self.assertIsNone(conf.cpu.model)",
            "        self.assertEqual(conf.cpu.sockets, 1)",
            "        self.assertEqual(conf.cpu.cores, 1)",
            "        self.assertEqual(conf.cpu.threads, 1)",
            "",
            "    def test_get_guest_cpu_config_default_uml(self):",
            "        self.flags(virt_type=\"uml\",",
            "                   cpu_mode=None,",
            "                   group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        conf = drvr._get_guest_config(instance_ref,",
            "                                      _fake_network_info(self, 1),",
            "                                      image_meta, disk_info)",
            "        self.assertIsNone(conf.cpu)",
            "",
            "    def test_get_guest_cpu_config_default_lxc(self):",
            "        self.flags(virt_type=\"lxc\",",
            "                   cpu_mode=None,",
            "                   group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        conf = drvr._get_guest_config(instance_ref,",
            "                                      _fake_network_info(self, 1),",
            "                                      image_meta, disk_info)",
            "        self.assertIsNone(conf.cpu)",
            "",
            "    def test_get_guest_cpu_config_host_passthrough(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        self.flags(cpu_mode=\"host-passthrough\", group='libvirt')",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        conf = drvr._get_guest_config(instance_ref,",
            "                                      _fake_network_info(self, 1),",
            "                                      image_meta, disk_info)",
            "        self.assertIsInstance(conf.cpu,",
            "                              vconfig.LibvirtConfigGuestCPU)",
            "        self.assertEqual(conf.cpu.mode, \"host-passthrough\")",
            "        self.assertIsNone(conf.cpu.model)",
            "        self.assertEqual(conf.cpu.sockets, 1)",
            "        self.assertEqual(conf.cpu.cores, 1)",
            "        self.assertEqual(conf.cpu.threads, 1)",
            "",
            "    def test_get_guest_cpu_config_host_model(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        self.flags(cpu_mode=\"host-model\", group='libvirt')",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        conf = drvr._get_guest_config(instance_ref,",
            "                                      _fake_network_info(self, 1),",
            "                                      image_meta, disk_info)",
            "        self.assertIsInstance(conf.cpu,",
            "                              vconfig.LibvirtConfigGuestCPU)",
            "        self.assertEqual(conf.cpu.mode, \"host-model\")",
            "        self.assertIsNone(conf.cpu.model)",
            "        self.assertEqual(conf.cpu.sockets, 1)",
            "        self.assertEqual(conf.cpu.cores, 1)",
            "        self.assertEqual(conf.cpu.threads, 1)",
            "",
            "    def test_get_guest_cpu_config_custom(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        self.flags(cpu_mode=\"custom\",",
            "                   cpu_model=\"Penryn\",",
            "                   group='libvirt')",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        conf = drvr._get_guest_config(instance_ref,",
            "                                      _fake_network_info(self, 1),",
            "                                      image_meta, disk_info)",
            "        self.assertIsInstance(conf.cpu,",
            "                              vconfig.LibvirtConfigGuestCPU)",
            "        self.assertEqual(conf.cpu.mode, \"custom\")",
            "        self.assertEqual(conf.cpu.model, \"Penryn\")",
            "        self.assertEqual(conf.cpu.sockets, 1)",
            "        self.assertEqual(conf.cpu.cores, 1)",
            "        self.assertEqual(conf.cpu.threads, 1)",
            "",
            "    def test_get_guest_cpu_topology(self):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.vcpus = 8",
            "        instance_ref.flavor.extra_specs = {'hw:cpu_max_sockets': '4'}",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        conf = drvr._get_guest_config(instance_ref,",
            "                                      _fake_network_info(self, 1),",
            "                                      image_meta, disk_info)",
            "        self.assertIsInstance(conf.cpu,",
            "                              vconfig.LibvirtConfigGuestCPU)",
            "        self.assertEqual(conf.cpu.mode, \"host-model\")",
            "        self.assertEqual(conf.cpu.sockets, 4)",
            "        self.assertEqual(conf.cpu.cores, 2)",
            "        self.assertEqual(conf.cpu.threads, 1)",
            "",
            "    def test_get_guest_memory_balloon_config_by_default(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        for device in cfg.devices:",
            "            if device.root_name == 'memballoon':",
            "                self.assertIsInstance(device,",
            "                                      vconfig.LibvirtConfigMemoryBalloon)",
            "                self.assertEqual('virtio', device.model)",
            "                self.assertEqual(10, device.period)",
            "",
            "    def test_get_guest_memory_balloon_config_disable(self):",
            "        self.flags(mem_stats_period_seconds=0, group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        no_exist = True",
            "        for device in cfg.devices:",
            "            if device.root_name == 'memballoon':",
            "                no_exist = False",
            "                break",
            "        self.assertTrue(no_exist)",
            "",
            "    def test_get_guest_memory_balloon_config_period_value(self):",
            "        self.flags(mem_stats_period_seconds=21, group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        for device in cfg.devices:",
            "            if device.root_name == 'memballoon':",
            "                self.assertIsInstance(device,",
            "                                      vconfig.LibvirtConfigMemoryBalloon)",
            "                self.assertEqual('virtio', device.model)",
            "                self.assertEqual(21, device.period)",
            "",
            "    def test_get_guest_memory_balloon_config_qemu(self):",
            "        self.flags(virt_type='qemu', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        for device in cfg.devices:",
            "            if device.root_name == 'memballoon':",
            "                self.assertIsInstance(device,",
            "                                      vconfig.LibvirtConfigMemoryBalloon)",
            "                self.assertEqual('virtio', device.model)",
            "                self.assertEqual(10, device.period)",
            "",
            "    def test_get_guest_memory_balloon_config_xen(self):",
            "        self.flags(virt_type='xen', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        for device in cfg.devices:",
            "            if device.root_name == 'memballoon':",
            "                self.assertIsInstance(device,",
            "                                      vconfig.LibvirtConfigMemoryBalloon)",
            "                self.assertEqual('xen', device.model)",
            "                self.assertEqual(10, device.period)",
            "",
            "    def test_get_guest_memory_balloon_config_lxc(self):",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        no_exist = True",
            "        for device in cfg.devices:",
            "            if device.root_name == 'memballoon':",
            "                no_exist = False",
            "                break",
            "        self.assertTrue(no_exist)",
            "",
            "    def test_xml_and_uri_no_ramdisk_no_kernel(self):",
            "        instance_data = dict(self.test_instance)",
            "        self._check_xml_and_uri(instance_data,",
            "                                expect_kernel=False, expect_ramdisk=False)",
            "",
            "    def test_xml_and_uri_no_ramdisk_no_kernel_xen_hvm(self):",
            "        instance_data = dict(self.test_instance)",
            "        instance_data.update({'vm_mode': vm_mode.HVM})",
            "        self._check_xml_and_uri(instance_data, expect_kernel=False,",
            "                                expect_ramdisk=False, expect_xen_hvm=True)",
            "",
            "    def test_xml_and_uri_no_ramdisk_no_kernel_xen_pv(self):",
            "        instance_data = dict(self.test_instance)",
            "        instance_data.update({'vm_mode': vm_mode.XEN})",
            "        self._check_xml_and_uri(instance_data, expect_kernel=False,",
            "                                expect_ramdisk=False, expect_xen_hvm=False,",
            "                                xen_only=True)",
            "",
            "    def test_xml_and_uri_no_ramdisk(self):",
            "        instance_data = dict(self.test_instance)",
            "        instance_data['kernel_id'] = 'aki-deadbeef'",
            "        self._check_xml_and_uri(instance_data,",
            "                                expect_kernel=True, expect_ramdisk=False)",
            "",
            "    def test_xml_and_uri_no_kernel(self):",
            "        instance_data = dict(self.test_instance)",
            "        instance_data['ramdisk_id'] = 'ari-deadbeef'",
            "        self._check_xml_and_uri(instance_data,",
            "                                expect_kernel=False, expect_ramdisk=False)",
            "",
            "    def test_xml_and_uri(self):",
            "        instance_data = dict(self.test_instance)",
            "        instance_data['ramdisk_id'] = 'ari-deadbeef'",
            "        instance_data['kernel_id'] = 'aki-deadbeef'",
            "        self._check_xml_and_uri(instance_data,",
            "                                expect_kernel=True, expect_ramdisk=True)",
            "",
            "    def test_xml_and_uri_rescue(self):",
            "        instance_data = dict(self.test_instance)",
            "        instance_data['ramdisk_id'] = 'ari-deadbeef'",
            "        instance_data['kernel_id'] = 'aki-deadbeef'",
            "        self._check_xml_and_uri(instance_data, expect_kernel=True,",
            "                                expect_ramdisk=True, rescue=instance_data)",
            "",
            "    def test_xml_and_uri_rescue_no_kernel_no_ramdisk(self):",
            "        instance_data = dict(self.test_instance)",
            "        self._check_xml_and_uri(instance_data, expect_kernel=False,",
            "                                expect_ramdisk=False, rescue=instance_data)",
            "",
            "    def test_xml_and_uri_rescue_no_kernel(self):",
            "        instance_data = dict(self.test_instance)",
            "        instance_data['ramdisk_id'] = 'aki-deadbeef'",
            "        self._check_xml_and_uri(instance_data, expect_kernel=False,",
            "                                expect_ramdisk=True, rescue=instance_data)",
            "",
            "    def test_xml_and_uri_rescue_no_ramdisk(self):",
            "        instance_data = dict(self.test_instance)",
            "        instance_data['kernel_id'] = 'aki-deadbeef'",
            "        self._check_xml_and_uri(instance_data, expect_kernel=True,",
            "                                expect_ramdisk=False, rescue=instance_data)",
            "",
            "    def test_xml_uuid(self):",
            "        self._check_xml_and_uuid(self.test_image_meta)",
            "",
            "    def test_lxc_container_and_uri(self):",
            "        instance_data = dict(self.test_instance)",
            "        self._check_xml_and_container(instance_data)",
            "",
            "    def test_xml_disk_prefix(self):",
            "        instance_data = dict(self.test_instance)",
            "        self._check_xml_and_disk_prefix(instance_data, None)",
            "",
            "    def test_xml_user_specified_disk_prefix(self):",
            "        instance_data = dict(self.test_instance)",
            "        self._check_xml_and_disk_prefix(instance_data, 'sd')",
            "",
            "    def test_xml_disk_driver(self):",
            "        instance_data = dict(self.test_instance)",
            "        self._check_xml_and_disk_driver(instance_data)",
            "",
            "    def test_xml_disk_bus_virtio(self):",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        self._check_xml_and_disk_bus(image_meta,",
            "                                     None,",
            "                                     ((\"disk\", \"virtio\", \"vda\"),))",
            "",
            "    def test_xml_disk_bus_ide(self):",
            "        # It's necessary to check if the architecture is power, because",
            "        # power doesn't have support to ide, and so libvirt translate",
            "        # all ide calls to scsi",
            "",
            "        expected = {arch.PPC: (\"cdrom\", \"scsi\", \"sda\"),",
            "                    arch.PPC64: (\"cdrom\", \"scsi\", \"sda\")}",
            "",
            "        expec_val = expected.get(blockinfo.libvirt_utils.get_arch({}),",
            "                                  (\"cdrom\", \"ide\", \"hda\"))",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"iso\"})",
            "        self._check_xml_and_disk_bus(image_meta,",
            "                                     None,",
            "                                     (expec_val,))",
            "",
            "    def test_xml_disk_bus_ide_and_virtio(self):",
            "        # It's necessary to check if the architecture is power, because",
            "        # power doesn't have support to ide, and so libvirt translate",
            "        # all ide calls to scsi",
            "",
            "        expected = {arch.PPC: (\"cdrom\", \"scsi\", \"sda\"),",
            "                    arch.PPC64: (\"cdrom\", \"scsi\", \"sda\")}",
            "",
            "        swap = {'device_name': '/dev/vdc',",
            "                'swap_size': 1}",
            "        ephemerals = [{'device_type': 'disk',",
            "                       'disk_bus': 'virtio',",
            "                       'device_name': '/dev/vdb',",
            "                       'size': 1}]",
            "        block_device_info = {",
            "                'swap': swap,",
            "                'ephemerals': ephemerals}",
            "        expec_val = expected.get(blockinfo.libvirt_utils.get_arch({}),",
            "                                  (\"cdrom\", \"ide\", \"hda\"))",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"iso\"})",
            "        self._check_xml_and_disk_bus(image_meta,",
            "                                     block_device_info,",
            "                                     (expec_val,",
            "                                      (\"disk\", \"virtio\", \"vdb\"),",
            "                                      (\"disk\", \"virtio\", \"vdc\")))",
            "",
            "    @mock.patch.object(host.Host, \"list_instance_domains\")",
            "    def test_list_instances(self, mock_list):",
            "        vm1 = FakeVirtDomain(id=3, name=\"instance00000001\")",
            "        vm2 = FakeVirtDomain(id=17, name=\"instance00000002\")",
            "        vm3 = FakeVirtDomain(name=\"instance00000003\")",
            "        vm4 = FakeVirtDomain(name=\"instance00000004\")",
            "",
            "        mock_list.return_value = [vm1, vm2, vm3, vm4]",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        names = drvr.list_instances()",
            "        self.assertEqual(names[0], vm1.name())",
            "        self.assertEqual(names[1], vm2.name())",
            "        self.assertEqual(names[2], vm3.name())",
            "        self.assertEqual(names[3], vm4.name())",
            "        mock_list.assert_called_with(only_guests=True, only_running=False)",
            "",
            "    @mock.patch.object(host.Host, \"list_instance_domains\")",
            "    def test_list_instance_uuids(self, mock_list):",
            "        vm1 = FakeVirtDomain(id=3, name=\"instance00000001\")",
            "        vm2 = FakeVirtDomain(id=17, name=\"instance00000002\")",
            "        vm3 = FakeVirtDomain(name=\"instance00000003\")",
            "        vm4 = FakeVirtDomain(name=\"instance00000004\")",
            "",
            "        mock_list.return_value = [vm1, vm2, vm3, vm4]",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        uuids = drvr.list_instance_uuids()",
            "        self.assertEqual(len(uuids), 4)",
            "        self.assertEqual(uuids[0], vm1.UUIDString())",
            "        self.assertEqual(uuids[1], vm2.UUIDString())",
            "        self.assertEqual(uuids[2], vm3.UUIDString())",
            "        self.assertEqual(uuids[3], vm4.UUIDString())",
            "        mock_list.assert_called_with(only_guests=True, only_running=False)",
            "",
            "    @mock.patch.object(host.Host, \"list_instance_domains\")",
            "    def test_get_all_block_devices(self, mock_list):",
            "        xml = [",
            "            \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                        </disk>",
            "                        <disk type='block'>",
            "                            <source dev='/path/to/dev/1'/>",
            "                        </disk>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\",",
            "            \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                        </disk>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\",",
            "            \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                        </disk>",
            "                        <disk type='block'>",
            "                            <source dev='/path/to/dev/3'/>",
            "                        </disk>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\",",
            "        ]",
            "",
            "        mock_list.return_value = [",
            "            FakeVirtDomain(xml[0], id=3, name=\"instance00000001\"),",
            "            FakeVirtDomain(xml[1], id=1, name=\"instance00000002\"),",
            "            FakeVirtDomain(xml[2], id=5, name=\"instance00000003\")]",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        devices = drvr._get_all_block_devices()",
            "        self.assertEqual(devices, ['/path/to/dev/1', '/path/to/dev/3'])",
            "        mock_list.assert_called_with(only_guests=True, only_running=True)",
            "",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_online_cpus')",
            "    def test_get_host_vcpus(self, get_online_cpus):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.flags(vcpu_pin_set=\"4-5\")",
            "        get_online_cpus.return_value = set([4, 5, 6])",
            "        expected_vcpus = 2",
            "        vcpus = drvr._get_vcpu_total()",
            "        self.assertEqual(expected_vcpus, vcpus)",
            "",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_online_cpus')",
            "    def test_get_host_vcpus_out_of_range(self, get_online_cpus):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.flags(vcpu_pin_set=\"4-6\")",
            "        get_online_cpus.return_value = set([4, 5])",
            "        self.assertRaises(exception.Invalid, drvr._get_vcpu_total)",
            "",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_online_cpus')",
            "    def test_get_host_vcpus_libvirt_error(self, get_online_cpus):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        not_supported_exc = fakelibvirt.make_libvirtError(",
            "            fakelibvirt.libvirtError,",
            "            'this function is not supported by the connection driver:'",
            "            ' virNodeNumOfDevices',",
            "            error_code=fakelibvirt.VIR_ERR_NO_SUPPORT)",
            "        self.flags(vcpu_pin_set=\"4-6\")",
            "        get_online_cpus.side_effect = not_supported_exc",
            "        self.assertRaises(exception.Invalid, drvr._get_vcpu_total)",
            "",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_online_cpus')",
            "    def test_get_host_vcpus_libvirt_error_success(self, get_online_cpus):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        not_supported_exc = fakelibvirt.make_libvirtError(",
            "            fakelibvirt.libvirtError,",
            "            'this function is not supported by the connection driver:'",
            "            ' virNodeNumOfDevices',",
            "            error_code=fakelibvirt.VIR_ERR_NO_SUPPORT)",
            "        self.flags(vcpu_pin_set=\"1\")",
            "        get_online_cpus.side_effect = not_supported_exc",
            "        expected_vcpus = 1",
            "        vcpus = drvr._get_vcpu_total()",
            "        self.assertEqual(expected_vcpus, vcpus)",
            "",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_cpu_count')",
            "    def test_get_host_vcpus_after_hotplug(self, get_cpu_count):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        get_cpu_count.return_value = 2",
            "        expected_vcpus = 2",
            "        vcpus = drvr._get_vcpu_total()",
            "        self.assertEqual(expected_vcpus, vcpus)",
            "        get_cpu_count.return_value = 3",
            "        expected_vcpus = 3",
            "        vcpus = drvr._get_vcpu_total()",
            "        self.assertEqual(expected_vcpus, vcpus)",
            "",
            "    @mock.patch.object(host.Host, \"has_min_version\", return_value=True)",
            "    def test_quiesce(self, mock_has_min_version):",
            "        self.create_fake_libvirt_mock(lookupByName=self.fake_lookup)",
            "        with mock.patch.object(FakeVirtDomain, \"fsFreeze\") as mock_fsfreeze:",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "            instance = objects.Instance(**self.test_instance)",
            "            image_meta = objects.ImageMeta.from_dict(",
            "                {\"properties\": {\"hw_qemu_guest_agent\": \"yes\"}})",
            "            self.assertIsNone(drvr.quiesce(self.context, instance, image_meta))",
            "            mock_fsfreeze.assert_called_once_with()",
            "",
            "    def test_quiesce_not_supported(self):",
            "        self.create_fake_libvirt_mock()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "        instance = objects.Instance(**self.test_instance)",
            "        self.assertRaises(exception.InstanceQuiesceNotSupported,",
            "                      drvr.quiesce, self.context, instance, None)",
            "",
            "    @mock.patch.object(host.Host, \"has_min_version\", return_value=True)",
            "    def test_unquiesce(self, mock_has_min_version):",
            "        self.create_fake_libvirt_mock(getLibVersion=lambda: 1002005,",
            "                                      lookupByName=self.fake_lookup)",
            "        with mock.patch.object(FakeVirtDomain, \"fsThaw\") as mock_fsthaw:",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "            instance = objects.Instance(**self.test_instance)",
            "            image_meta = objects.ImageMeta.from_dict(",
            "                {\"properties\": {\"hw_qemu_guest_agent\": \"yes\"}})",
            "            self.assertIsNone(drvr.unquiesce(self.context, instance,",
            "                                             image_meta))",
            "            mock_fsthaw.assert_called_once_with()",
            "",
            "    def test_create_snapshot_metadata(self):",
            "        base = objects.ImageMeta.from_dict(",
            "            {'disk_format': 'raw'})",
            "        instance_data = {'kernel_id': 'kernel',",
            "                    'project_id': 'prj_id',",
            "                    'ramdisk_id': 'ram_id',",
            "                    'os_type': None}",
            "        instance = objects.Instance(**instance_data)",
            "        img_fmt = 'raw'",
            "        snp_name = 'snapshot_name'",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        ret = drvr._create_snapshot_metadata(base, instance, img_fmt, snp_name)",
            "        expected = {'is_public': False,",
            "                    'status': 'active',",
            "                    'name': snp_name,",
            "                    'properties': {",
            "                                   'kernel_id': instance['kernel_id'],",
            "                                   'image_location': 'snapshot',",
            "                                   'image_state': 'available',",
            "                                   'owner_id': instance['project_id'],",
            "                                   'ramdisk_id': instance['ramdisk_id'],",
            "                                   },",
            "                    'disk_format': img_fmt,",
            "                    'container_format': 'bare',",
            "                    }",
            "        self.assertEqual(ret, expected)",
            "",
            "        # simulate an instance with os_type field defined",
            "        # disk format equals to ami",
            "        # container format not equals to bare",
            "        instance['os_type'] = 'linux'",
            "        base = objects.ImageMeta.from_dict(",
            "            {'disk_format': 'ami',",
            "             'container_format': 'test_container'})",
            "        expected['properties']['os_type'] = instance['os_type']",
            "        expected['disk_format'] = base.disk_format",
            "        expected['container_format'] = base.container_format",
            "        ret = drvr._create_snapshot_metadata(base, instance, img_fmt, snp_name)",
            "        self.assertEqual(ret, expected)",
            "",
            "    def test_get_volume_driver(self):",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        connection_info = {'driver_volume_type': 'fake',",
            "                           'data': {'device_path': '/fake',",
            "                                    'access_mode': 'rw'}}",
            "        driver = conn._get_volume_driver(connection_info)",
            "        result = isinstance(driver, volume_drivers.LibvirtFakeVolumeDriver)",
            "        self.assertTrue(result)",
            "",
            "    def test_get_volume_driver_unknown(self):",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        connection_info = {'driver_volume_type': 'unknown',",
            "                           'data': {'device_path': '/fake',",
            "                                    'access_mode': 'rw'}}",
            "        self.assertRaises(",
            "            exception.VolumeDriverNotFound,",
            "            conn._get_volume_driver,",
            "            connection_info",
            "        )",
            "",
            "    @mock.patch.object(volume_drivers.LibvirtFakeVolumeDriver,",
            "                       'connect_volume')",
            "    @mock.patch.object(volume_drivers.LibvirtFakeVolumeDriver, 'get_config')",
            "    def test_get_volume_config(self, get_config, connect_volume):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        connection_info = {'driver_volume_type': 'fake',",
            "                           'data': {'device_path': '/fake',",
            "                                    'access_mode': 'rw'}}",
            "        bdm = {'device_name': 'vdb',",
            "               'disk_bus': 'fake-bus',",
            "               'device_type': 'fake-type'}",
            "        disk_info = {'bus': bdm['disk_bus'], 'type': bdm['device_type'],",
            "                     'dev': 'vdb'}",
            "        mock_config = mock.MagicMock()",
            "",
            "        get_config.return_value = mock_config",
            "        config = drvr._get_volume_config(connection_info, disk_info)",
            "        get_config.assert_called_once_with(connection_info, disk_info)",
            "        self.assertEqual(mock_config, config)",
            "",
            "    def test_attach_invalid_volume_type(self):",
            "        self.create_fake_libvirt_mock()",
            "        libvirt_driver.LibvirtDriver._conn.lookupByName = self.fake_lookup",
            "        instance = objects.Instance(**self.test_instance)",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertRaises(exception.VolumeDriverNotFound,",
            "                          drvr.attach_volume, None,",
            "                          {\"driver_volume_type\": \"badtype\"},",
            "                          instance,",
            "                          \"/dev/sda\")",
            "",
            "    def test_attach_blockio_invalid_hypervisor(self):",
            "        self.flags(virt_type='fake_type', group='libvirt')",
            "        self.create_fake_libvirt_mock()",
            "        libvirt_driver.LibvirtDriver._conn.lookupByName = self.fake_lookup",
            "        instance = objects.Instance(**self.test_instance)",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertRaises(exception.InvalidHypervisorType,",
            "                          drvr.attach_volume, None,",
            "                          {\"driver_volume_type\": \"fake\",",
            "                           \"data\": {\"logical_block_size\": \"4096\",",
            "                                    \"physical_block_size\": \"4096\"}",
            "                          },",
            "                          instance,",
            "                          \"/dev/sda\")",
            "",
            "    def _test_check_discard(self, mock_log, driver_discard=None,",
            "                            bus=None, should_log=False):",
            "        mock_config = mock.Mock()",
            "        mock_config.driver_discard = driver_discard",
            "        mock_config.target_bus = bus",
            "        mock_instance = mock.Mock()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr._check_discard_for_attach_volume(mock_config, mock_instance)",
            "        self.assertEqual(should_log, mock_log.called)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG.debug')",
            "    def test_check_discard_for_attach_volume_no_unmap(self, mock_log):",
            "        self._test_check_discard(mock_log, driver_discard=None,",
            "                                 bus='scsi', should_log=False)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG.debug')",
            "    def test_check_discard_for_attach_volume_blk_controller(self, mock_log):",
            "        self._test_check_discard(mock_log, driver_discard='unmap',",
            "                                 bus='virtio', should_log=True)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG.debug')",
            "    def test_check_discard_for_attach_volume_valid_controller(self, mock_log):",
            "        self._test_check_discard(mock_log, driver_discard='unmap',",
            "                                 bus='scsi', should_log=False)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG.debug')",
            "    def test_check_discard_for_attach_volume_blk_controller_no_unmap(self,",
            "                                                                     mock_log):",
            "        self._test_check_discard(mock_log, driver_discard=None,",
            "                                 bus='virtio', should_log=False)",
            "",
            "    @mock.patch('nova.utils.get_image_from_system_metadata')",
            "    @mock.patch('nova.virt.libvirt.blockinfo.get_info_from_bdm')",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_domain')",
            "    def test_attach_volume_with_vir_domain_affect_live_flag(self,",
            "            mock_get_domain, mock_get_info, get_image):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        image_meta = {}",
            "        get_image.return_value = image_meta",
            "        mock_dom = mock.MagicMock()",
            "        mock_get_domain.return_value = mock_dom",
            "",
            "        connection_info = {\"driver_volume_type\": \"fake\",",
            "                           \"data\": {\"device_path\": \"/fake\",",
            "                                    \"access_mode\": \"rw\"}}",
            "        bdm = {'device_name': 'vdb',",
            "               'disk_bus': 'fake-bus',",
            "               'device_type': 'fake-type'}",
            "        disk_info = {'bus': bdm['disk_bus'], 'type': bdm['device_type'],",
            "                     'dev': 'vdb'}",
            "        mock_get_info.return_value = disk_info",
            "        mock_conf = mock.MagicMock()",
            "        flags = (fakelibvirt.VIR_DOMAIN_AFFECT_CONFIG |",
            "                 fakelibvirt.VIR_DOMAIN_AFFECT_LIVE)",
            "",
            "        with test.nested(",
            "            mock.patch.object(drvr, '_connect_volume'),",
            "            mock.patch.object(drvr, '_get_volume_config',",
            "                              return_value=mock_conf),",
            "            mock.patch.object(drvr, '_set_cache_mode'),",
            "            mock.patch.object(drvr, '_check_discard_for_attach_volume')",
            "        ) as (mock_connect_volume, mock_get_volume_config,",
            "              mock_set_cache_mode, mock_check_discard):",
            "            for state in (power_state.RUNNING, power_state.PAUSED):",
            "                mock_dom.info.return_value = [state, 512, 512, 2, 1234, 5678]",
            "",
            "                drvr.attach_volume(self.context, connection_info, instance,",
            "                                   \"/dev/vdb\", disk_bus=bdm['disk_bus'],",
            "                                   device_type=bdm['device_type'])",
            "",
            "                mock_get_domain.assert_called_with(instance)",
            "                mock_get_info.assert_called_with(",
            "                    instance,",
            "                    CONF.libvirt.virt_type,",
            "                    test.MatchType(objects.ImageMeta),",
            "                    bdm)",
            "                mock_connect_volume.assert_called_with(",
            "                    connection_info, disk_info)",
            "                mock_get_volume_config.assert_called_with(",
            "                    connection_info, disk_info)",
            "                mock_set_cache_mode.assert_called_with(mock_conf)",
            "                mock_dom.attachDeviceFlags.assert_called_with(",
            "                    mock_conf.to_xml(), flags=flags)",
            "                mock_check_discard.assert_called_with(mock_conf, instance)",
            "",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_domain')",
            "    def test_detach_volume_with_vir_domain_affect_live_flag(self,",
            "            mock_get_domain):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_xml_with_disk = \"\"\"<domain>",
            "  <devices>",
            "    <disk type='file'>",
            "      <source file='/path/to/fake-volume'/>",
            "      <target dev='vdc' bus='virtio'/>",
            "    </disk>",
            "  </devices>",
            "</domain>\"\"\"",
            "        mock_xml_without_disk = \"\"\"<domain>",
            "  <devices>",
            "  </devices>",
            "</domain>\"\"\"",
            "        mock_dom = mock.MagicMock()",
            "",
            "        # Second time don't return anything about disk vdc so it looks removed",
            "        return_list = [mock_xml_with_disk, mock_xml_without_disk]",
            "        # Doubling the size of return list because we test with two guest power",
            "        # states",
            "        mock_dom.XMLDesc.side_effect = return_list + return_list",
            "",
            "        connection_info = {\"driver_volume_type\": \"fake\",",
            "                           \"data\": {\"device_path\": \"/fake\",",
            "                                    \"access_mode\": \"rw\"}}",
            "        flags = (fakelibvirt.VIR_DOMAIN_AFFECT_CONFIG |",
            "                 fakelibvirt.VIR_DOMAIN_AFFECT_LIVE)",
            "",
            "        with mock.patch.object(drvr, '_disconnect_volume') as \\",
            "                mock_disconnect_volume:",
            "            for state in (power_state.RUNNING, power_state.PAUSED):",
            "                mock_dom.info.return_value = [state, 512, 512, 2, 1234, 5678]",
            "                mock_get_domain.return_value = mock_dom",
            "                drvr.detach_volume(connection_info, instance, '/dev/vdc')",
            "",
            "                mock_get_domain.assert_called_with(instance)",
            "                mock_dom.detachDeviceFlags.assert_called_with(\"\"\"<disk type=\"file\" device=\"disk\">",
            "  <source file=\"/path/to/fake-volume\"/>",
            "  <target bus=\"virtio\" dev=\"vdc\"/>",
            "</disk>",
            "\"\"\", flags=flags)",
            "                mock_disconnect_volume.assert_called_with(",
            "                    connection_info, 'vdc')",
            "",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_domain')",
            "    def test_detach_volume_disk_not_found(self, mock_get_domain):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_xml_without_disk = \"\"\"<domain>",
            "  <devices>",
            "  </devices>",
            "</domain>\"\"\"",
            "        mock_dom = mock.MagicMock(return_value=mock_xml_without_disk)",
            "",
            "        connection_info = {\"driver_volume_type\": \"fake\",",
            "                           \"data\": {\"device_path\": \"/fake\",",
            "                                    \"access_mode\": \"rw\"}}",
            "",
            "        mock_dom.info.return_value = [power_state.RUNNING, 512, 512, 2, 1234,",
            "                                      5678]",
            "        mock_get_domain.return_value = mock_dom",
            "        self.assertRaises(exception.DiskNotFound, drvr.detach_volume,",
            "                          connection_info, instance, '/dev/vdc')",
            "",
            "        mock_get_domain.assert_called_once_with(instance)",
            "",
            "    def test_multi_nic(self):",
            "        network_info = _fake_network_info(self, 2)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        xml = drvr._get_guest_xml(self.context, instance_ref,",
            "                                  network_info, disk_info,",
            "                                  image_meta)",
            "        tree = etree.fromstring(xml)",
            "        interfaces = tree.findall(\"./devices/interface\")",
            "        self.assertEqual(len(interfaces), 2)",
            "        self.assertEqual(interfaces[0].get('type'), 'bridge')",
            "",
            "    def _behave_supports_direct_io(self, raise_open=False, raise_write=False,",
            "                                   exc=ValueError()):",
            "        open_behavior = os.open(os.path.join('.', '.directio.test'),",
            "                                os.O_CREAT | os.O_WRONLY | os.O_DIRECT)",
            "        if raise_open:",
            "            open_behavior.AndRaise(exc)",
            "        else:",
            "            open_behavior.AndReturn(3)",
            "            write_bahavior = os.write(3, mox.IgnoreArg())",
            "            if raise_write:",
            "                write_bahavior.AndRaise(exc)",
            "            else:",
            "                os.close(3)",
            "        os.unlink(3)",
            "",
            "    def test_supports_direct_io(self):",
            "        # O_DIRECT is not supported on all Python runtimes, so on platforms",
            "        # where it's not supported (e.g. Mac), we can still test the code-path",
            "        # by stubbing out the value.",
            "        if not hasattr(os, 'O_DIRECT'):",
            "            # `mock` seems to have trouble stubbing an attr that doesn't",
            "            # originally exist, so falling back to stubbing out the attribute",
            "            # directly.",
            "            os.O_DIRECT = 16384",
            "            self.addCleanup(delattr, os, 'O_DIRECT')",
            "",
            "        einval = OSError()",
            "        einval.errno = errno.EINVAL",
            "        self.mox.StubOutWithMock(os, 'open')",
            "        self.mox.StubOutWithMock(os, 'write')",
            "        self.mox.StubOutWithMock(os, 'close')",
            "        self.mox.StubOutWithMock(os, 'unlink')",
            "        _supports_direct_io = libvirt_driver.LibvirtDriver._supports_direct_io",
            "",
            "        self._behave_supports_direct_io()",
            "        self._behave_supports_direct_io(raise_write=True)",
            "        self._behave_supports_direct_io(raise_open=True)",
            "        self._behave_supports_direct_io(raise_write=True, exc=einval)",
            "        self._behave_supports_direct_io(raise_open=True, exc=einval)",
            "",
            "        self.mox.ReplayAll()",
            "        self.assertTrue(_supports_direct_io('.'))",
            "        self.assertRaises(ValueError, _supports_direct_io, '.')",
            "        self.assertRaises(ValueError, _supports_direct_io, '.')",
            "        self.assertFalse(_supports_direct_io('.'))",
            "        self.assertFalse(_supports_direct_io('.'))",
            "        self.mox.VerifyAll()",
            "",
            "    def _check_xml_and_container(self, instance):",
            "        instance_ref = objects.Instance(**instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        self.assertEqual(drvr._uri(), 'lxc:///')",
            "",
            "        network_info = _fake_network_info(self, 1)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        xml = drvr._get_guest_xml(self.context, instance_ref,",
            "                                  network_info, disk_info,",
            "                                  image_meta)",
            "        tree = etree.fromstring(xml)",
            "",
            "        check = [",
            "            (lambda t: t.find('.').get('type'), 'lxc'),",
            "            (lambda t: t.find('./os/type').text, 'exe'),",
            "            (lambda t: t.find('./devices/filesystem/target').get('dir'), '/')]",
            "",
            "        for i, (check, expected_result) in enumerate(check):",
            "            self.assertEqual(check(tree),",
            "                             expected_result,",
            "                             '%s failed common check %d' % (xml, i))",
            "",
            "        target = tree.find('./devices/filesystem/source').get('dir')",
            "        self.assertTrue(len(target) > 0)",
            "",
            "    def _check_xml_and_disk_prefix(self, instance, prefix):",
            "        instance_ref = objects.Instance(**instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        def _get_prefix(p, default):",
            "            if p:",
            "                return p + 'a'",
            "            return default",
            "",
            "        type_disk_map = {",
            "            'qemu': [",
            "                (lambda t: t.find('.').get('type'), 'qemu'),",
            "                (lambda t: t.find('./devices/disk/target').get('dev'),",
            "                 _get_prefix(prefix, 'vda'))],",
            "            'xen': [",
            "                (lambda t: t.find('.').get('type'), 'xen'),",
            "                (lambda t: t.find('./devices/disk/target').get('dev'),",
            "                 _get_prefix(prefix, 'xvda'))],",
            "            'kvm': [",
            "                (lambda t: t.find('.').get('type'), 'kvm'),",
            "                (lambda t: t.find('./devices/disk/target').get('dev'),",
            "                 _get_prefix(prefix, 'vda'))],",
            "            'uml': [",
            "                (lambda t: t.find('.').get('type'), 'uml'),",
            "                (lambda t: t.find('./devices/disk/target').get('dev'),",
            "                 _get_prefix(prefix, 'ubda'))]",
            "            }",
            "",
            "        for (virt_type, checks) in six.iteritems(type_disk_map):",
            "            self.flags(virt_type=virt_type, group='libvirt')",
            "            if prefix:",
            "                self.flags(disk_prefix=prefix, group='libvirt')",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "            network_info = _fake_network_info(self, 1)",
            "            disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                                instance_ref,",
            "                                                image_meta)",
            "",
            "            xml = drvr._get_guest_xml(self.context, instance_ref,",
            "                                      network_info, disk_info,",
            "                                      image_meta)",
            "            tree = etree.fromstring(xml)",
            "",
            "            for i, (check, expected_result) in enumerate(checks):",
            "                self.assertEqual(check(tree),",
            "                                 expected_result,",
            "                                 '%s != %s failed check %d' %",
            "                                 (check(tree), expected_result, i))",
            "",
            "    def _check_xml_and_disk_driver(self, image_meta):",
            "        os_open = os.open",
            "        directio_supported = True",
            "",
            "        def os_open_stub(path, flags, *args, **kwargs):",
            "            if flags & os.O_DIRECT:",
            "                if not directio_supported:",
            "                    raise OSError(errno.EINVAL,",
            "                                  '%s: %s' % (os.strerror(errno.EINVAL), path))",
            "                flags &= ~os.O_DIRECT",
            "            return os_open(path, flags, *args, **kwargs)",
            "",
            "        self.stub_out('os.open', os_open_stub)",
            "",
            "        @staticmethod",
            "        def connection_supports_direct_io_stub(dirpath):",
            "            return directio_supported",
            "",
            "        self.stubs.Set(libvirt_driver.LibvirtDriver,",
            "            '_supports_direct_io', connection_supports_direct_io_stub)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        network_info = _fake_network_info(self, 1)",
            "",
            "        drv = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        xml = drv._get_guest_xml(self.context, instance_ref,",
            "                                 network_info, disk_info, image_meta)",
            "        tree = etree.fromstring(xml)",
            "        disks = tree.findall('./devices/disk/driver')",
            "        for guest_disk in disks:",
            "            self.assertEqual(guest_disk.get(\"cache\"), \"none\")",
            "",
            "        directio_supported = False",
            "",
            "        # The O_DIRECT availability is cached on first use in",
            "        # LibvirtDriver, hence we re-create it here",
            "        drv = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        xml = drv._get_guest_xml(self.context, instance_ref,",
            "                                 network_info, disk_info, image_meta)",
            "        tree = etree.fromstring(xml)",
            "        disks = tree.findall('./devices/disk/driver')",
            "        for guest_disk in disks:",
            "            self.assertEqual(guest_disk.get(\"cache\"), \"writethrough\")",
            "",
            "    def _check_xml_and_disk_bus(self, image_meta,",
            "                                block_device_info, wantConfig):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        network_info = _fake_network_info(self, 1)",
            "",
            "        drv = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta,",
            "                                            block_device_info)",
            "",
            "        xml = drv._get_guest_xml(self.context, instance_ref,",
            "                                 network_info, disk_info, image_meta,",
            "                                 block_device_info=block_device_info)",
            "        tree = etree.fromstring(xml)",
            "",
            "        got_disks = tree.findall('./devices/disk')",
            "        got_disk_targets = tree.findall('./devices/disk/target')",
            "        for i in range(len(wantConfig)):",
            "            want_device_type = wantConfig[i][0]",
            "            want_device_bus = wantConfig[i][1]",
            "            want_device_dev = wantConfig[i][2]",
            "",
            "            got_device_type = got_disks[i].get('device')",
            "            got_device_bus = got_disk_targets[i].get('bus')",
            "            got_device_dev = got_disk_targets[i].get('dev')",
            "",
            "            self.assertEqual(got_device_type, want_device_type)",
            "            self.assertEqual(got_device_bus, want_device_bus)",
            "            self.assertEqual(got_device_dev, want_device_dev)",
            "",
            "    def _check_xml_and_uuid(self, image_meta):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        network_info = _fake_network_info(self, 1)",
            "",
            "        drv = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        xml = drv._get_guest_xml(self.context, instance_ref,",
            "                                 network_info, disk_info, image_meta)",
            "        tree = etree.fromstring(xml)",
            "        self.assertEqual(tree.find('./uuid').text,",
            "                         instance_ref['uuid'])",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver,",
            "                       \"_get_host_sysinfo_serial_hardware\",)",
            "    def _check_xml_and_uri(self, instance, mock_serial,",
            "                           expect_ramdisk=False, expect_kernel=False,",
            "                           rescue=None, expect_xen_hvm=False, xen_only=False):",
            "        mock_serial.return_value = \"cef19ce0-0ca2-11df-855d-b19fbce37686\"",
            "        instance_ref = objects.Instance(**instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        xen_vm_mode = vm_mode.XEN",
            "        if expect_xen_hvm:",
            "            xen_vm_mode = vm_mode.HVM",
            "",
            "        type_uri_map = {'qemu': ('qemu:///system',",
            "                             [(lambda t: t.find('.').get('type'), 'qemu'),",
            "                              (lambda t: t.find('./os/type').text,",
            "                               vm_mode.HVM),",
            "                              (lambda t: t.find('./devices/emulator'), None)]),",
            "                        'kvm': ('qemu:///system',",
            "                             [(lambda t: t.find('.').get('type'), 'kvm'),",
            "                              (lambda t: t.find('./os/type').text,",
            "                               vm_mode.HVM),",
            "                              (lambda t: t.find('./devices/emulator'), None)]),",
            "                        'uml': ('uml:///system',",
            "                             [(lambda t: t.find('.').get('type'), 'uml'),",
            "                              (lambda t: t.find('./os/type').text,",
            "                               vm_mode.UML)]),",
            "                        'xen': ('xen:///',",
            "                             [(lambda t: t.find('.').get('type'), 'xen'),",
            "                              (lambda t: t.find('./os/type').text,",
            "                               xen_vm_mode)])}",
            "",
            "        if expect_xen_hvm or xen_only:",
            "            hypervisors_to_check = ['xen']",
            "        else:",
            "            hypervisors_to_check = ['qemu', 'kvm', 'xen']",
            "",
            "        for hypervisor_type in hypervisors_to_check:",
            "            check_list = type_uri_map[hypervisor_type][1]",
            "",
            "            if rescue:",
            "                suffix = '.rescue'",
            "            else:",
            "                suffix = ''",
            "            if expect_kernel:",
            "                check = (lambda t: self.relpath(t.find('./os/kernel').text).",
            "                         split('/')[1], 'kernel' + suffix)",
            "            else:",
            "                check = (lambda t: t.find('./os/kernel'), None)",
            "            check_list.append(check)",
            "",
            "            if expect_kernel:",
            "                check = (lambda t: \"no_timer_check\" in t.find('./os/cmdline').",
            "                         text, hypervisor_type == \"qemu\")",
            "                check_list.append(check)",
            "            # Hypervisors that only support vm_mode.HVM and Xen",
            "            # should not produce configuration that results in kernel",
            "            # arguments",
            "            if not expect_kernel and (hypervisor_type in",
            "                                      ['qemu', 'kvm', 'xen']):",
            "                check = (lambda t: t.find('./os/root'), None)",
            "                check_list.append(check)",
            "                check = (lambda t: t.find('./os/cmdline'), None)",
            "                check_list.append(check)",
            "",
            "            if expect_ramdisk:",
            "                check = (lambda t: self.relpath(t.find('./os/initrd').text).",
            "                         split('/')[1], 'ramdisk' + suffix)",
            "            else:",
            "                check = (lambda t: t.find('./os/initrd'), None)",
            "            check_list.append(check)",
            "",
            "            if hypervisor_type in ['qemu', 'kvm']:",
            "                xpath = \"./sysinfo/system/entry\"",
            "                check = (lambda t: t.findall(xpath)[0].get(\"name\"),",
            "                         \"manufacturer\")",
            "                check_list.append(check)",
            "                check = (lambda t: t.findall(xpath)[0].text,",
            "                         version.vendor_string())",
            "                check_list.append(check)",
            "",
            "                check = (lambda t: t.findall(xpath)[1].get(\"name\"),",
            "                         \"product\")",
            "                check_list.append(check)",
            "                check = (lambda t: t.findall(xpath)[1].text,",
            "                         version.product_string())",
            "                check_list.append(check)",
            "",
            "                check = (lambda t: t.findall(xpath)[2].get(\"name\"),",
            "                         \"version\")",
            "                check_list.append(check)",
            "                # NOTE(sirp): empty strings don't roundtrip in lxml (they are",
            "                # converted to None), so we need an `or ''` to correct for that",
            "                check = (lambda t: t.findall(xpath)[2].text or '',",
            "                         version.version_string_with_package())",
            "                check_list.append(check)",
            "",
            "                check = (lambda t: t.findall(xpath)[3].get(\"name\"),",
            "                         \"serial\")",
            "                check_list.append(check)",
            "                check = (lambda t: t.findall(xpath)[3].text,",
            "                         \"cef19ce0-0ca2-11df-855d-b19fbce37686\")",
            "                check_list.append(check)",
            "",
            "                check = (lambda t: t.findall(xpath)[4].get(\"name\"),",
            "                         \"uuid\")",
            "                check_list.append(check)",
            "                check = (lambda t: t.findall(xpath)[4].text,",
            "                         instance['uuid'])",
            "                check_list.append(check)",
            "",
            "            if hypervisor_type in ['qemu', 'kvm']:",
            "                check = (lambda t: t.findall('./devices/serial')[0].get(",
            "                        'type'), 'file')",
            "                check_list.append(check)",
            "                check = (lambda t: t.findall('./devices/serial')[1].get(",
            "                        'type'), 'pty')",
            "                check_list.append(check)",
            "                check = (lambda t: self.relpath(t.findall(",
            "                         './devices/serial/source')[0].get('path')).",
            "                         split('/')[1], 'console.log')",
            "                check_list.append(check)",
            "            else:",
            "                check = (lambda t: t.find('./devices/console').get(",
            "                        'type'), 'pty')",
            "                check_list.append(check)",
            "",
            "        common_checks = [",
            "            (lambda t: t.find('.').tag, 'domain'),",
            "            (lambda t: t.find('./memory').text, '2097152')]",
            "        if rescue:",
            "            common_checks += [",
            "                (lambda t: self.relpath(t.findall('./devices/disk/source')[0].",
            "                    get('file')).split('/')[1], 'disk.rescue'),",
            "                (lambda t: self.relpath(t.findall('./devices/disk/source')[1].",
            "                    get('file')).split('/')[1], 'disk')]",
            "        else:",
            "            common_checks += [(lambda t: self.relpath(t.findall(",
            "                './devices/disk/source')[0].get('file')).split('/')[1],",
            "                               'disk')]",
            "            common_checks += [(lambda t: self.relpath(t.findall(",
            "                './devices/disk/source')[1].get('file')).split('/')[1],",
            "                               'disk.local')]",
            "",
            "        for virt_type in hypervisors_to_check:",
            "            expected_uri = type_uri_map[virt_type][0]",
            "            checks = type_uri_map[virt_type][1]",
            "            self.flags(virt_type=virt_type, group='libvirt')",
            "",
            "            with mock.patch('nova.virt.libvirt.driver.libvirt') as old_virt:",
            "                del old_virt.VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES",
            "",
            "                drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "                self.assertEqual(drvr._uri(), expected_uri)",
            "",
            "                network_info = _fake_network_info(self, 1)",
            "                disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                                    instance_ref,",
            "                                                    image_meta,",
            "                                                    rescue=rescue)",
            "",
            "                xml = drvr._get_guest_xml(self.context, instance_ref,",
            "                                          network_info, disk_info,",
            "                                          image_meta,",
            "                                          rescue=rescue)",
            "                tree = etree.fromstring(xml)",
            "                for i, (check, expected_result) in enumerate(checks):",
            "                    self.assertEqual(check(tree),",
            "                                     expected_result,",
            "                                     '%s != %s failed check %d' %",
            "                                     (check(tree), expected_result, i))",
            "",
            "                for i, (check, expected_result) in enumerate(common_checks):",
            "                    self.assertEqual(check(tree),",
            "                                     expected_result,",
            "                                     '%s != %s failed common check %d' %",
            "                                     (check(tree), expected_result, i))",
            "",
            "                filterref = './devices/interface/filterref'",
            "                vif = network_info[0]",
            "                nic_id = vif['address'].replace(':', '')",
            "                fw = firewall.NWFilterFirewall(drvr)",
            "                instance_filter_name = fw._instance_filter_name(instance_ref,",
            "                                                                nic_id)",
            "                self.assertEqual(tree.find(filterref).get('filter'),",
            "                                 instance_filter_name)",
            "",
            "        # This test is supposed to make sure we don't",
            "        # override a specifically set uri",
            "        #",
            "        # Deliberately not just assigning this string to CONF.connection_uri",
            "        # and checking against that later on. This way we make sure the",
            "        # implementation doesn't fiddle around with the CONF.",
            "        testuri = 'something completely different'",
            "        self.flags(connection_uri=testuri, group='libvirt')",
            "        for (virt_type, (expected_uri, checks)) in six.iteritems(type_uri_map):",
            "            self.flags(virt_type=virt_type, group='libvirt')",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "            self.assertEqual(drvr._uri(), testuri)",
            "",
            "    def test_ensure_filtering_rules_for_instance_timeout(self):",
            "        # ensure_filtering_fules_for_instance() finishes with timeout.",
            "        # Preparing mocks",
            "        def fake_none(self, *args):",
            "            return",
            "",
            "        class FakeTime(object):",
            "            def __init__(self):",
            "                self.counter = 0",
            "",
            "            def sleep(self, t):",
            "                self.counter += t",
            "",
            "        fake_timer = FakeTime()",
            "",
            "        def fake_sleep(t):",
            "            fake_timer.sleep(t)",
            "",
            "        # _fake_network_info must be called before create_fake_libvirt_mock(),",
            "        # as _fake_network_info calls importutils.import_class() and",
            "        # create_fake_libvirt_mock() mocks importutils.import_class().",
            "        network_info = _fake_network_info(self, 1)",
            "        self.create_fake_libvirt_mock()",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "",
            "        # Start test",
            "        self.mox.ReplayAll()",
            "        try:",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "            self.stubs.Set(drvr.firewall_driver,",
            "                           'setup_basic_filtering',",
            "                           fake_none)",
            "            self.stubs.Set(drvr.firewall_driver,",
            "                           'prepare_instance_filter',",
            "                           fake_none)",
            "            self.stubs.Set(drvr.firewall_driver,",
            "                           'instance_filter_exists',",
            "                           fake_none)",
            "            self.stubs.Set(greenthread,",
            "                           'sleep',",
            "                           fake_sleep)",
            "            drvr.ensure_filtering_rules_for_instance(instance_ref,",
            "                                                     network_info)",
            "        except exception.NovaException as e:",
            "            msg = ('The firewall filter for %s does not exist' %",
            "                   instance_ref['name'])",
            "            c1 = (0 <= six.text_type(e).find(msg))",
            "        self.assertTrue(c1)",
            "",
            "        self.assertEqual(29, fake_timer.counter, \"Didn't wait the expected \"",
            "                                                 \"amount of time\")",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver,",
            "        '_create_shared_storage_test_file')",
            "    @mock.patch.object(fakelibvirt.Connection, 'compareCPU')",
            "    def test_check_can_live_migrate_dest_all_pass_with_block_migration(",
            "            self, mock_cpu, mock_test_file):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.vcpu_model = test_vcpu_model.fake_vcpumodel",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        compute_info = {'disk_available_least': 400,",
            "                        'cpu_info': 'asdf',",
            "                        }",
            "        filename = \"file\"",
            "",
            "        # _check_cpu_match",
            "        mock_cpu.return_value = 1",
            "",
            "        # mounted_on_same_shared_storage",
            "        mock_test_file.return_value = filename",
            "",
            "        # No need for the src_compute_info",
            "        return_value = drvr.check_can_live_migrate_destination(self.context,",
            "                instance_ref, None, compute_info, True)",
            "        return_value.is_volume_backed = False",
            "        self.assertThat({\"filename\": \"file\",",
            "                         'image_type': 'default',",
            "                         'disk_available_mb': 409600,",
            "                         \"disk_over_commit\": False,",
            "                         \"block_migration\": True,",
            "                         \"is_volume_backed\": False},",
            "                        matchers.DictMatches(return_value.to_legacy_dict()))",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver,",
            "        '_create_shared_storage_test_file')",
            "    @mock.patch.object(fakelibvirt.Connection, 'compareCPU')",
            "    def test_check_can_live_migrate_dest_all_pass_no_block_migration(",
            "            self, mock_cpu, mock_test_file):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.vcpu_model = test_vcpu_model.fake_vcpumodel",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        compute_info = {'disk_available_least': 400,",
            "                        'cpu_info': 'asdf',",
            "                        }",
            "        filename = \"file\"",
            "",
            "        # _check_cpu_match",
            "        mock_cpu.return_value = 1",
            "        # mounted_on_same_shared_storage",
            "        mock_test_file.return_value = filename",
            "        # No need for the src_compute_info",
            "        return_value = drvr.check_can_live_migrate_destination(self.context,",
            "                instance_ref, None, compute_info, False)",
            "        return_value.is_volume_backed = False",
            "        self.assertThat({\"filename\": \"file\",",
            "                         \"image_type\": 'default',",
            "                         \"block_migration\": False,",
            "                         \"disk_over_commit\": False,",
            "                         \"disk_available_mb\": 409600,",
            "                         \"is_volume_backed\": False},",
            "                        matchers.DictMatches(return_value.to_legacy_dict()))",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver,",
            "                       '_create_shared_storage_test_file',",
            "                       return_value='fake')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_compare_cpu')",
            "    def test_check_can_live_migrate_guest_cpu_none_model(",
            "            self, mock_cpu, mock_test_file):",
            "        # Tests that when instance.vcpu_model.model is None, the host cpu",
            "        # model is used for live migration.",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.vcpu_model = test_vcpu_model.fake_vcpumodel",
            "        instance_ref.vcpu_model.model = None",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        compute_info = {'cpu_info': 'asdf', 'disk_available_least': 1}",
            "        result = drvr.check_can_live_migrate_destination(",
            "            self.context, instance_ref, compute_info, compute_info)",
            "        result.is_volume_backed = False",
            "        mock_cpu.assert_called_once_with(None, 'asdf')",
            "        expected_result = {\"filename\": 'fake',",
            "                           \"image_type\": CONF.libvirt.images_type,",
            "                           \"block_migration\": False,",
            "                           \"disk_over_commit\": False,",
            "                           \"disk_available_mb\": 1024,",
            "                           \"is_volume_backed\": False}",
            "        self.assertDictEqual(expected_result, result.to_legacy_dict())",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver,",
            "        '_create_shared_storage_test_file')",
            "    @mock.patch.object(fakelibvirt.Connection, 'compareCPU')",
            "    def test_check_can_live_migrate_dest_no_instance_cpu_info(",
            "            self, mock_cpu, mock_test_file):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        compute_info = {'cpu_info': jsonutils.dumps({",
            "            \"vendor\": \"AMD\",",
            "            \"arch\": arch.I686,",
            "            \"features\": [\"sse3\"],",
            "            \"model\": \"Opteron_G3\",",
            "            \"topology\": {\"cores\": 2, \"threads\": 1, \"sockets\": 4}",
            "        }), 'disk_available_least': 1}",
            "        filename = \"file\"",
            "",
            "        # _check_cpu_match",
            "        mock_cpu.return_value = 1",
            "        # mounted_on_same_shared_storage",
            "        mock_test_file.return_value = filename",
            "",
            "        return_value = drvr.check_can_live_migrate_destination(self.context,",
            "                instance_ref, compute_info, compute_info, False)",
            "        # NOTE(danms): Compute manager would have set this, so set it here",
            "        return_value.is_volume_backed = False",
            "        self.assertThat({\"filename\": \"file\",",
            "                         \"image_type\": 'default',",
            "                         \"block_migration\": False,",
            "                         \"disk_over_commit\": False,",
            "                         \"disk_available_mb\": 1024,",
            "                         \"is_volume_backed\": False},",
            "                        matchers.DictMatches(return_value.to_legacy_dict()))",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'compareCPU')",
            "    def test_check_can_live_migrate_dest_incompatible_cpu_raises(",
            "            self, mock_cpu):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.vcpu_model = test_vcpu_model.fake_vcpumodel",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        compute_info = {'cpu_info': 'asdf', 'disk_available_least': 1}",
            "",
            "        mock_cpu.side_effect = exception.InvalidCPUInfo(reason='foo')",
            "        self.assertRaises(exception.InvalidCPUInfo,",
            "                          drvr.check_can_live_migrate_destination,",
            "                          self.context, instance_ref,",
            "                          compute_info, compute_info, False)",
            "",
            "    @mock.patch.object(host.Host, 'compare_cpu')",
            "    @mock.patch.object(nova.virt.libvirt, 'config')",
            "    def test_compare_cpu_compatible_host_cpu(self, mock_vconfig, mock_compare):",
            "        mock_compare.return_value = 5",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        ret = conn._compare_cpu(None, jsonutils.dumps(_fake_cpu_info))",
            "        self.assertIsNone(ret)",
            "",
            "    @mock.patch.object(host.Host, 'compare_cpu')",
            "    @mock.patch.object(nova.virt.libvirt, 'config')",
            "    def test_compare_cpu_handles_not_supported_error_gracefully(self,",
            "                                                                mock_vconfig,",
            "                                                                mock_compare):",
            "        not_supported_exc = fakelibvirt.make_libvirtError(",
            "                fakelibvirt.libvirtError,",
            "                'this function is not supported by the connection driver:'",
            "                ' virCompareCPU',",
            "                error_code=fakelibvirt.VIR_ERR_NO_SUPPORT)",
            "        mock_compare.side_effect = not_supported_exc",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        ret = conn._compare_cpu(None, jsonutils.dumps(_fake_cpu_info))",
            "        self.assertIsNone(ret)",
            "",
            "    @mock.patch.object(host.Host, 'compare_cpu')",
            "    @mock.patch.object(nova.virt.libvirt.LibvirtDriver,",
            "                       '_vcpu_model_to_cpu_config')",
            "    def test_compare_cpu_compatible_guest_cpu(self, mock_vcpu_to_cpu,",
            "                                              mock_compare):",
            "        mock_compare.return_value = 6",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        ret = conn._compare_cpu(jsonutils.dumps(_fake_cpu_info), None)",
            "        self.assertIsNone(ret)",
            "",
            "    def test_compare_cpu_virt_type_xen(self):",
            "        self.flags(virt_type='xen', group='libvirt')",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        ret = conn._compare_cpu(None, None)",
            "        self.assertIsNone(ret)",
            "",
            "    @mock.patch.object(host.Host, 'compare_cpu')",
            "    @mock.patch.object(nova.virt.libvirt, 'config')",
            "    def test_compare_cpu_invalid_cpuinfo_raises(self, mock_vconfig,",
            "                                                mock_compare):",
            "        mock_compare.return_value = 0",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertRaises(exception.InvalidCPUInfo,",
            "                          conn._compare_cpu, None,",
            "                          jsonutils.dumps(_fake_cpu_info))",
            "",
            "    @mock.patch.object(host.Host, 'compare_cpu')",
            "    @mock.patch.object(nova.virt.libvirt, 'config')",
            "    def test_compare_cpu_incompatible_cpu_raises(self, mock_vconfig,",
            "                                                 mock_compare):",
            "        mock_compare.side_effect = fakelibvirt.libvirtError('cpu')",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertRaises(exception.MigrationPreCheckError,",
            "                          conn._compare_cpu, None,",
            "                          jsonutils.dumps(_fake_cpu_info))",
            "",
            "    def test_check_can_live_migrate_dest_cleanup_works_correctly(self):",
            "        objects.Instance(**self.test_instance)",
            "        dest_check_data = objects.LibvirtLiveMigrateData(",
            "            filename=\"file\",",
            "            block_migration=True,",
            "            disk_over_commit=False,",
            "            disk_available_mb=1024)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        self.mox.StubOutWithMock(drvr, '_cleanup_shared_storage_test_file')",
            "        drvr._cleanup_shared_storage_test_file(\"file\")",
            "",
            "        self.mox.ReplayAll()",
            "        drvr.check_can_live_migrate_destination_cleanup(self.context,",
            "                                                        dest_check_data)",
            "",
            "    def _mock_can_live_migrate_source(self, block_migration=False,",
            "                                      is_shared_block_storage=False,",
            "                                      is_shared_instance_path=False,",
            "                                      is_booted_from_volume=False,",
            "                                      disk_available_mb=1024,",
            "                                      block_device_info=None,",
            "                                      block_device_text=None):",
            "        instance = objects.Instance(**self.test_instance)",
            "        dest_check_data = objects.LibvirtLiveMigrateData(",
            "            filename='file',",
            "            image_type='default',",
            "            block_migration=block_migration,",
            "            disk_over_commit=False,",
            "            disk_available_mb=disk_available_mb)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        self.mox.StubOutWithMock(drvr, '_is_shared_block_storage')",
            "        drvr._is_shared_block_storage(instance, dest_check_data,",
            "                block_device_info).AndReturn(is_shared_block_storage)",
            "        self.mox.StubOutWithMock(drvr, '_check_shared_storage_test_file')",
            "        drvr._check_shared_storage_test_file('file').AndReturn(",
            "                is_shared_instance_path)",
            "        self.mox.StubOutWithMock(drvr, \"get_instance_disk_info\")",
            "        drvr.get_instance_disk_info(instance,",
            "                                    block_device_info=block_device_info).\\",
            "                                    AndReturn(block_device_text)",
            "        self.mox.StubOutWithMock(drvr, '_is_booted_from_volume')",
            "        drvr._is_booted_from_volume(instance, block_device_text).AndReturn(",
            "            is_booted_from_volume)",
            "",
            "        return (instance, dest_check_data, drvr)",
            "",
            "    def test_check_can_live_migrate_source_block_migration(self):",
            "        instance, dest_check_data, drvr = self._mock_can_live_migrate_source(",
            "                block_migration=True)",
            "",
            "        self.mox.StubOutWithMock(drvr, \"_assert_dest_node_has_enough_disk\")",
            "        drvr._assert_dest_node_has_enough_disk(",
            "            self.context, instance, dest_check_data.disk_available_mb,",
            "            False, None)",
            "",
            "        self.mox.ReplayAll()",
            "        ret = drvr.check_can_live_migrate_source(self.context, instance,",
            "                                                 dest_check_data)",
            "        self.assertIsInstance(ret, objects.LibvirtLiveMigrateData)",
            "        self.assertIn('is_shared_block_storage', ret)",
            "        self.assertIn('is_shared_instance_path', ret)",
            "",
            "    def test_check_can_live_migrate_source_shared_block_storage(self):",
            "        instance, dest_check_data, drvr = self._mock_can_live_migrate_source(",
            "                is_shared_block_storage=True)",
            "        self.mox.ReplayAll()",
            "        drvr.check_can_live_migrate_source(self.context, instance,",
            "                                           dest_check_data)",
            "",
            "    def test_check_can_live_migrate_source_shared_instance_path(self):",
            "        instance, dest_check_data, drvr = self._mock_can_live_migrate_source(",
            "                is_shared_instance_path=True)",
            "        self.mox.ReplayAll()",
            "        drvr.check_can_live_migrate_source(self.context, instance,",
            "                                           dest_check_data)",
            "",
            "    def test_check_can_live_migrate_source_non_shared_fails(self):",
            "        instance, dest_check_data, drvr = self._mock_can_live_migrate_source()",
            "        self.mox.ReplayAll()",
            "        self.assertRaises(exception.InvalidSharedStorage,",
            "                          drvr.check_can_live_migrate_source, self.context,",
            "                          instance, dest_check_data)",
            "",
            "    def test_check_can_live_migrate_source_shared_block_migration_fails(self):",
            "        instance, dest_check_data, drvr = self._mock_can_live_migrate_source(",
            "                block_migration=True,",
            "                is_shared_block_storage=True)",
            "",
            "        self.mox.ReplayAll()",
            "        self.assertRaises(exception.InvalidLocalStorage,",
            "                          drvr.check_can_live_migrate_source,",
            "                          self.context, instance, dest_check_data)",
            "",
            "    def test_check_can_live_migrate_shared_path_block_migration_fails(self):",
            "        instance, dest_check_data, drvr = self._mock_can_live_migrate_source(",
            "                block_migration=True,",
            "                is_shared_instance_path=True)",
            "",
            "        self.mox.ReplayAll()",
            "        self.assertRaises(exception.InvalidLocalStorage,",
            "                          drvr.check_can_live_migrate_source,",
            "                          self.context, instance, dest_check_data, None)",
            "",
            "    def test_check_can_live_migrate_non_shared_non_block_migration_fails(self):",
            "        instance, dest_check_data, drvr = self._mock_can_live_migrate_source()",
            "        self.mox.ReplayAll()",
            "        self.assertRaises(exception.InvalidSharedStorage,",
            "                          drvr.check_can_live_migrate_source,",
            "                          self.context, instance, dest_check_data)",
            "",
            "    def test_check_can_live_migrate_source_with_dest_not_enough_disk(self):",
            "        instance, dest_check_data, drvr = self._mock_can_live_migrate_source(",
            "                block_migration=True,",
            "                disk_available_mb=0)",
            "",
            "        drvr.get_instance_disk_info(instance,",
            "                                    block_device_info=None).AndReturn(",
            "                                        '[{\"virt_disk_size\":2}]')",
            "",
            "        self.mox.ReplayAll()",
            "        self.assertRaises(exception.MigrationError,",
            "                          drvr.check_can_live_migrate_source,",
            "                          self.context, instance, dest_check_data)",
            "",
            "    def test_check_can_live_migrate_source_booted_from_volume(self):",
            "        instance, dest_check_data, drvr = self._mock_can_live_migrate_source(",
            "                is_booted_from_volume=True,",
            "                block_device_text='[]')",
            "        self.mox.ReplayAll()",
            "        drvr.check_can_live_migrate_source(self.context, instance,",
            "                                           dest_check_data)",
            "",
            "    def test_check_can_live_migrate_source_booted_from_volume_with_swap(self):",
            "        instance, dest_check_data, drvr = self._mock_can_live_migrate_source(",
            "                is_booted_from_volume=True,",
            "                block_device_text='[{\"path\":\"disk.swap\"}]')",
            "        self.mox.ReplayAll()",
            "        self.assertRaises(exception.InvalidSharedStorage,",
            "                          drvr.check_can_live_migrate_source,",
            "                          self.context, instance, dest_check_data)",
            "",
            "    @mock.patch.object(host.Host, 'has_min_version', return_value=False)",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_assert_dest_node_has_enough_disk')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_has_local_disk')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_is_booted_from_volume')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                'get_instance_disk_info')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_is_shared_block_storage', return_value=False)",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_check_shared_storage_test_file', return_value=False)",
            "    def test_check_can_live_migrate_source_block_migration_with_bdm_error(",
            "            self, mock_check, mock_shared_block, mock_get_bdi,",
            "            mock_booted_from_volume, mock_has_local, mock_enough,",
            "            mock_min_version):",
            "",
            "        bdi = {'block_device_mapping': ['bdm']}",
            "        instance = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        dest_check_data = objects.LibvirtLiveMigrateData(",
            "            filename='file',",
            "            image_type='default',",
            "            block_migration=True,",
            "            disk_over_commit=False,",
            "            disk_available_mb=100)",
            "        self.assertRaises(exception.MigrationPreCheckError,",
            "                          drvr.check_can_live_migrate_source,",
            "                          self.context, instance, dest_check_data,",
            "                          block_device_info=bdi)",
            "",
            "    @mock.patch.object(host.Host, 'has_min_version', return_value=True)",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_assert_dest_node_has_enough_disk')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_has_local_disk')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_is_booted_from_volume')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                'get_instance_disk_info')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_is_shared_block_storage')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_check_shared_storage_test_file')",
            "    def _test_check_can_live_migrate_source_block_migration_none(",
            "            self, block_migrate, is_shared_instance_path, is_share_block,",
            "            mock_check, mock_shared_block, mock_get_bdi,",
            "            mock_booted_from_volume, mock_has_local, mock_enough, mock_verson):",
            "",
            "        mock_check.return_value = is_shared_instance_path",
            "        mock_shared_block.return_value = is_share_block",
            "        instance = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        dest_check_data = objects.LibvirtLiveMigrateData(",
            "            filename='file',",
            "            image_type='default',",
            "            disk_over_commit=False,",
            "            disk_available_mb=100)",
            "        dest_check_data_ret = drvr.check_can_live_migrate_source(",
            "                          self.context, instance, dest_check_data)",
            "        self.assertEqual(block_migrate, dest_check_data_ret.block_migration)",
            "",
            "    def test_check_can_live_migrate_source_block_migration_none_shared1(self):",
            "        self._test_check_can_live_migrate_source_block_migration_none(",
            "            False,",
            "            True,",
            "            False)",
            "",
            "    def test_check_can_live_migrate_source_block_migration_none_shared2(self):",
            "        self._test_check_can_live_migrate_source_block_migration_none(",
            "            False,",
            "            False,",
            "            True)",
            "",
            "    def test_check_can_live_migrate_source_block_migration_none_no_share(self):",
            "        self._test_check_can_live_migrate_source_block_migration_none(",
            "            True,",
            "            False,",
            "            False)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_assert_dest_node_has_enough_disk')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_assert_dest_node_has_enough_disk')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_has_local_disk')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_is_booted_from_volume')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                'get_instance_disk_info')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_is_shared_block_storage')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_check_shared_storage_test_file')",
            "    def test_check_can_live_migration_source_disk_over_commit_none(self,",
            "            mock_check, mock_shared_block, mock_get_bdi,",
            "            mock_booted_from_volume, mock_has_local,",
            "            mock_enough, mock_disk_check):",
            "",
            "        mock_check.return_value = False",
            "        mock_shared_block.return_value = False",
            "        instance = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        dest_check_data = objects.LibvirtLiveMigrateData(",
            "            filename='file',",
            "            image_type='default',",
            "            disk_available_mb=100)",
            "",
            "        drvr.check_can_live_migrate_source(",
            "            self.context, instance, dest_check_data)",
            "",
            "        self.assertFalse(mock_disk_check.called)",
            "",
            "    def _is_shared_block_storage_test_create_mocks(self, disks):",
            "        # Test data",
            "        instance_xml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                        \"<devices>{}</devices></domain>\")",
            "        disks_xml = ''",
            "        for dsk in disks:",
            "            if dsk['type'] is not 'network':",
            "                disks_xml = ''.join([disks_xml,",
            "                                \"<disk type='{type}'>\"",
            "                                \"<driver name='qemu' type='{driver}'/>\"",
            "                                \"<source {source}='{source_path}'/>\"",
            "                                \"<target dev='{target_dev}' bus='virtio'/>\"",
            "                                \"</disk>\".format(**dsk)])",
            "            else:",
            "                disks_xml = ''.join([disks_xml,",
            "                                \"<disk type='{type}'>\"",
            "                                \"<driver name='qemu' type='{driver}'/>\"",
            "                                \"<source protocol='{source_proto}'\"",
            "                                \"name='{source_image}' >\"",
            "                                \"<host name='hostname' port='7000'/>\"",
            "                                \"<config file='/path/to/file'/>\"",
            "                                \"</source>\"",
            "                                \"<target dev='{target_dev}'\"",
            "                                \"bus='ide'/>\".format(**dsk)])",
            "",
            "        # Preparing mocks",
            "        mock_virDomain = mock.Mock(fakelibvirt.virDomain)",
            "        mock_virDomain.XMLDesc = mock.Mock()",
            "        mock_virDomain.XMLDesc.return_value = (instance_xml.format(disks_xml))",
            "",
            "        mock_lookup = mock.Mock()",
            "",
            "        def mock_lookup_side_effect(name):",
            "            return mock_virDomain",
            "        mock_lookup.side_effect = mock_lookup_side_effect",
            "",
            "        mock_getsize = mock.Mock()",
            "        mock_getsize.return_value = \"10737418240\"",
            "",
            "        return (mock_getsize, mock_lookup)",
            "",
            "    def test_is_shared_block_storage_rbd(self):",
            "        self.flags(images_type='rbd', group='libvirt')",
            "        bdi = {'block_device_mapping': []}",
            "        instance = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        mock_get_instance_disk_info = mock.Mock()",
            "        data = objects.LibvirtLiveMigrateData(image_type='rbd')",
            "        with mock.patch.object(drvr, 'get_instance_disk_info',",
            "                               mock_get_instance_disk_info):",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "            self.assertTrue(drvr._is_shared_block_storage(instance, data,",
            "                                  block_device_info=bdi))",
            "        self.assertEqual(0, mock_get_instance_disk_info.call_count)",
            "",
            "    def test_is_shared_block_storage_lvm(self):",
            "        self.flags(images_type='lvm', group='libvirt')",
            "        bdi = {'block_device_mapping': []}",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_get_instance_disk_info = mock.Mock()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        data = objects.LibvirtLiveMigrateData(image_type='lvm',",
            "                                              is_volume_backed=False,",
            "                                              is_shared_instance_path=False)",
            "        with mock.patch.object(drvr, 'get_instance_disk_info',",
            "                               mock_get_instance_disk_info):",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "            self.assertFalse(drvr._is_shared_block_storage(",
            "                                    instance, data,",
            "                                    block_device_info=bdi))",
            "        self.assertEqual(0, mock_get_instance_disk_info.call_count)",
            "",
            "    def test_is_shared_block_storage_qcow2(self):",
            "        self.flags(images_type='qcow2', group='libvirt')",
            "        bdi = {'block_device_mapping': []}",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_get_instance_disk_info = mock.Mock()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        data = objects.LibvirtLiveMigrateData(image_type='qcow2',",
            "                                              is_volume_backed=False,",
            "                                              is_shared_instance_path=False)",
            "        with mock.patch.object(drvr, 'get_instance_disk_info',",
            "                               mock_get_instance_disk_info):",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "            self.assertFalse(drvr._is_shared_block_storage(",
            "                                    instance, data,",
            "                                    block_device_info=bdi))",
            "        self.assertEqual(0, mock_get_instance_disk_info.call_count)",
            "",
            "    def test_is_shared_block_storage_rbd_only_source(self):",
            "        self.flags(images_type='rbd', group='libvirt')",
            "        bdi = {'block_device_mapping': []}",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_get_instance_disk_info = mock.Mock()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        data = objects.LibvirtLiveMigrateData(is_shared_instance_path=False,",
            "                                              is_volume_backed=False)",
            "        with mock.patch.object(drvr, 'get_instance_disk_info',",
            "                               mock_get_instance_disk_info):",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "            self.assertFalse(drvr._is_shared_block_storage(",
            "                                  instance, data,",
            "                                  block_device_info=bdi))",
            "        self.assertEqual(0, mock_get_instance_disk_info.call_count)",
            "",
            "    def test_is_shared_block_storage_rbd_only_dest(self):",
            "        bdi = {'block_device_mapping': []}",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_get_instance_disk_info = mock.Mock()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        data = objects.LibvirtLiveMigrateData(image_type='rbd',",
            "                                              is_volume_backed=False,",
            "                                              is_shared_instance_path=False)",
            "        with mock.patch.object(drvr, 'get_instance_disk_info',",
            "                               mock_get_instance_disk_info):",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "            self.assertFalse(drvr._is_shared_block_storage(",
            "                                    instance, data,",
            "                                    block_device_info=bdi))",
            "        self.assertEqual(0, mock_get_instance_disk_info.call_count)",
            "",
            "    def test_is_shared_block_storage_volume_backed(self):",
            "        disks = [{'type': 'block',",
            "                 'driver': 'raw',",
            "                 'source': 'dev',",
            "                 'source_path': '/dev/disk',",
            "                 'target_dev': 'vda'}]",
            "        bdi = {'block_device_mapping': [",
            "                  {'connection_info': 'info', 'mount_device': '/dev/vda'}]}",
            "        instance = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        (mock_getsize, mock_lookup) =\\",
            "            self._is_shared_block_storage_test_create_mocks(disks)",
            "        data = objects.LibvirtLiveMigrateData(is_volume_backed=True,",
            "                                              is_shared_instance_path=False)",
            "        with mock.patch.object(host.Host, 'get_domain', mock_lookup):",
            "            self.assertTrue(drvr._is_shared_block_storage(instance, data,",
            "                                  block_device_info = bdi))",
            "        mock_lookup.assert_called_once_with(instance)",
            "",
            "    def test_is_shared_block_storage_volume_backed_with_disk(self):",
            "        disks = [{'type': 'block',",
            "                 'driver': 'raw',",
            "                 'source': 'dev',",
            "                 'source_path': '/dev/disk',",
            "                 'target_dev': 'vda'},",
            "                {'type': 'file',",
            "                 'driver': 'raw',",
            "                 'source': 'file',",
            "                 'source_path': '/instance/disk.local',",
            "                 'target_dev': 'vdb'}]",
            "        bdi = {'block_device_mapping': [",
            "                  {'connection_info': 'info', 'mount_device': '/dev/vda'}]}",
            "        instance = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        (mock_getsize, mock_lookup) =\\",
            "            self._is_shared_block_storage_test_create_mocks(disks)",
            "        data = objects.LibvirtLiveMigrateData(is_volume_backed=True,",
            "                                              is_shared_instance_path=False)",
            "        with test.nested(",
            "                mock.patch.object(os.path, 'getsize', mock_getsize),",
            "                mock.patch.object(host.Host, 'get_domain', mock_lookup)):",
            "            self.assertFalse(drvr._is_shared_block_storage(",
            "                                    instance, data,",
            "                                    block_device_info = bdi))",
            "        mock_getsize.assert_called_once_with('/instance/disk.local')",
            "        mock_lookup.assert_called_once_with(instance)",
            "",
            "    def test_is_shared_block_storage_nfs(self):",
            "        bdi = {'block_device_mapping': []}",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        mock_image_backend = mock.MagicMock()",
            "        drvr.image_backend = mock_image_backend",
            "        mock_backend = mock.MagicMock()",
            "        mock_image_backend.backend.return_value = mock_backend",
            "        mock_backend.is_file_in_instance_path.return_value = True",
            "        mock_get_instance_disk_info = mock.Mock()",
            "        data = objects.LibvirtLiveMigrateData(",
            "            is_shared_instance_path=True,",
            "            image_type='foo')",
            "        with mock.patch.object(drvr, 'get_instance_disk_info',",
            "                               mock_get_instance_disk_info):",
            "            self.assertTrue(drvr._is_shared_block_storage(",
            "                'instance', data, block_device_info=bdi))",
            "        self.assertEqual(0, mock_get_instance_disk_info.call_count)",
            "",
            "    def test_live_migration_update_graphics_xml(self):",
            "        self.compute = importutils.import_object(CONF.compute_manager)",
            "        instance_dict = dict(self.test_instance)",
            "        instance_dict.update({'host': 'fake',",
            "                              'power_state': power_state.RUNNING,",
            "                              'vm_state': vm_states.ACTIVE})",
            "        instance_ref = objects.Instance(**instance_dict)",
            "",
            "        xml_tmpl = (\"<domain type='kvm'>\"",
            "                    \"<devices>\"",
            "                    \"<graphics type='vnc' listen='{vnc}'>\"",
            "                    \"<listen address='{vnc}'/>\"",
            "                    \"</graphics>\"",
            "                    \"<graphics type='spice' listen='{spice}'>\"",
            "                    \"<listen address='{spice}'/>\"",
            "                    \"</graphics>\"",
            "                    \"</devices>\"",
            "                    \"</domain>\")",
            "",
            "        initial_xml = xml_tmpl.format(vnc='1.2.3.4',",
            "                                      spice='5.6.7.8')",
            "",
            "        target_xml = xml_tmpl.format(vnc='10.0.0.1',",
            "                                     spice='10.0.0.2')",
            "        target_xml = etree.tostring(etree.fromstring(target_xml))",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        # Preparing mocks",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"migrateToURI2\")",
            "        _bandwidth = CONF.libvirt.live_migration_bandwidth",
            "        vdmock.XMLDesc(flags=fakelibvirt.VIR_DOMAIN_XML_MIGRATABLE).AndReturn(",
            "                initial_xml)",
            "        vdmock.migrateToURI2(drvr._live_migration_uri('dest'),",
            "                             None,",
            "                             target_xml,",
            "                             mox.IgnoreArg(),",
            "                             None,",
            "                             _bandwidth).AndRaise(",
            "                                fakelibvirt.libvirtError(\"ERR\"))",
            "",
            "        # start test",
            "        migrate_data = {'pre_live_migration_result':",
            "                {'graphics_listen_addrs':",
            "                    {'vnc': '10.0.0.1', 'spice': '10.0.0.2'}}}",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            graphics_listen_addr_vnc='10.0.0.1',",
            "            graphics_listen_addr_spice='10.0.0.2',",
            "            serial_listen_addr='127.0.0.1',",
            "            target_connect_addr=None,",
            "            bdms=[])",
            "        self.mox.ReplayAll()",
            "        self.assertRaises(fakelibvirt.libvirtError,",
            "                          drvr._live_migration_operation,",
            "                          self.context, instance_ref, 'dest',",
            "                          False, migrate_data, vdmock, [])",
            "",
            "    def test_live_migration_update_volume_xml(self):",
            "        self.compute = importutils.import_object(CONF.compute_manager)",
            "        instance_dict = dict(self.test_instance)",
            "        instance_dict.update({'host': 'fake',",
            "                              'power_state': power_state.RUNNING,",
            "                              'vm_state': vm_states.ACTIVE})",
            "        instance_ref = objects.Instance(**instance_dict)",
            "        target_xml = self.device_xml_tmpl.format(",
            "            device_path='/dev/disk/by-path/'",
            "            'ip-1.2.3.4:3260-iqn.'",
            "            'cde.67890.opst-lun-Z')",
            "        # start test",
            "        connection_info = {",
            "            u'driver_volume_type': u'iscsi',",
            "            u'serial': u'58a84f6d-3f0c-4e19-a0af-eb657b790657',",
            "            u'data': {",
            "                u'access_mode': u'rw', u'target_discovered': False,",
            "                u'target_iqn': u'ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z',",
            "                u'volume_id': u'58a84f6d-3f0c-4e19-a0af-eb657b790657',",
            "                'device_path':",
            "                u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z',",
            "            },",
            "        }",
            "        bdm = objects.LibvirtLiveMigrateBDMInfo(",
            "            serial='58a84f6d-3f0c-4e19-a0af-eb657b790657',",
            "            bus='virtio', type='disk', dev='vdb',",
            "            connection_info=connection_info)",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            serial_listen_addr='',",
            "            target_connect_addr=None,",
            "            bdms=[bdm])",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        test_mock = mock.MagicMock()",
            "",
            "        with mock.patch.object(libvirt_driver.LibvirtDriver, 'get_info') as \\",
            "                mget_info,\\",
            "                mock.patch.object(drvr._host, 'get_domain') as mget_domain,\\",
            "                mock.patch.object(fakelibvirt.virDomain, 'migrateToURI2'),\\",
            "                mock.patch.object(drvr, '_update_xml') as mupdate:",
            "",
            "            mget_info.side_effect = exception.InstanceNotFound(",
            "                                     instance_id='foo')",
            "            mget_domain.return_value = test_mock",
            "            test_mock.XMLDesc.return_value = target_xml",
            "            self.assertFalse(drvr._live_migration_operation(",
            "                             self.context, instance_ref, 'dest', False,",
            "                             migrate_data, test_mock, []))",
            "            mupdate.assert_called_once_with(target_xml, migrate_data.bdms,",
            "                                            {}, '')",
            "",
            "    def test_live_migration_with_valid_target_connect_addr(self):",
            "        self.compute = importutils.import_object(CONF.compute_manager)",
            "        instance_dict = dict(self.test_instance)",
            "        instance_dict.update({'host': 'fake',",
            "                              'power_state': power_state.RUNNING,",
            "                              'vm_state': vm_states.ACTIVE})",
            "        instance_ref = objects.Instance(**instance_dict)",
            "        target_xml = self.device_xml_tmpl.format(",
            "            device_path='/dev/disk/by-path/'",
            "            'ip-1.2.3.4:3260-iqn.'",
            "            'cde.67890.opst-lun-Z')",
            "        # start test",
            "        connection_info = {",
            "            u'driver_volume_type': u'iscsi',",
            "            u'serial': u'58a84f6d-3f0c-4e19-a0af-eb657b790657',",
            "            u'data': {",
            "                u'access_mode': u'rw', u'target_discovered': False,",
            "                u'target_iqn': u'ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z',",
            "                u'volume_id': u'58a84f6d-3f0c-4e19-a0af-eb657b790657',",
            "                'device_path':",
            "                u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z',",
            "            },",
            "        }",
            "        bdm = objects.LibvirtLiveMigrateBDMInfo(",
            "            serial='58a84f6d-3f0c-4e19-a0af-eb657b790657',",
            "            bus='virtio', type='disk', dev='vdb',",
            "            connection_info=connection_info)",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            serial_listen_addr='',",
            "            target_connect_addr='127.0.0.2',",
            "            bdms=[bdm])",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        test_mock = mock.MagicMock()",
            "",
            "        with mock.patch.object(drvr, '_update_xml') as mupdate:",
            "",
            "            test_mock.XMLDesc.return_value = target_xml",
            "            drvr._live_migration_operation(self.context, instance_ref,",
            "                                           'dest', False, migrate_data,",
            "                                           test_mock, [])",
            "            test_mock.migrateToURI2.assert_called_once_with(",
            "                'qemu+tcp://127.0.0.2/system',",
            "                None, mupdate(), None, None, 0)",
            "",
            "    def test_update_volume_xml(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        initial_xml = self.device_xml_tmpl.format(",
            "            device_path='/dev/disk/by-path/'",
            "            'ip-1.2.3.4:3260-iqn.'",
            "            'abc.12345.opst-lun-X')",
            "        target_xml = self.device_xml_tmpl.format(",
            "            device_path='/dev/disk/by-path/'",
            "            'ip-1.2.3.4:3260-iqn.'",
            "            'cde.67890.opst-lun-Z')",
            "        target_xml = etree.tostring(etree.fromstring(target_xml))",
            "        serial = \"58a84f6d-3f0c-4e19-a0af-eb657b790657\"",
            "",
            "        bdmi = objects.LibvirtLiveMigrateBDMInfo(serial=serial,",
            "                                                 bus='virtio',",
            "                                                 type='disk',",
            "                                                 dev='vdb')",
            "        bdmi.connection_info = {u'driver_volume_type': u'iscsi',",
            "           'serial': u'58a84f6d-3f0c-4e19-a0af-eb657b790657',",
            "            u'data': {u'access_mode': u'rw', u'target_discovered': False,",
            "            u'target_iqn': u'ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z',",
            "            u'volume_id': u'58a84f6d-3f0c-4e19-a0af-eb657b790657',",
            "           'device_path':",
            "              u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z'}}",
            "",
            "        conf = vconfig.LibvirtConfigGuestDisk()",
            "        conf.source_device = bdmi.type",
            "        conf.driver_name = \"qemu\"",
            "        conf.driver_format = \"raw\"",
            "        conf.driver_cache = \"none\"",
            "        conf.target_dev = bdmi.dev",
            "        conf.target_bus = bdmi.bus",
            "        conf.serial = bdmi.connection_info.get('serial')",
            "        conf.source_type = \"block\"",
            "        conf.source_path = bdmi.connection_info['data'].get('device_path')",
            "",
            "        with mock.patch.object(drvr, '_get_volume_config',",
            "                               return_value=conf):",
            "            parser = etree.XMLParser(remove_blank_text=True)",
            "            xml_doc = etree.fromstring(initial_xml, parser)",
            "            config = drvr._update_volume_xml(xml_doc, [bdmi])",
            "            xml_doc = etree.fromstring(target_xml, parser)",
            "            self.assertEqual(etree.tostring(xml_doc), etree.tostring(config))",
            "",
            "    def test_live_migration_uri(self):",
            "        hypervisor_uri_map = (",
            "            ('xen', 'xenmigr://%s/system'),",
            "            ('kvm', 'qemu+tcp://%s/system'),",
            "            ('qemu', 'qemu+tcp://%s/system'),",
            "            # anything else will return None",
            "            ('lxc', None),",
            "            ('parallels', None),",
            "            ('', None),",
            "        )",
            "        dest = 'destination'",
            "        for hyperv, uri in hypervisor_uri_map:",
            "            self.flags(virt_type=hyperv, group='libvirt')",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "            if uri is not None:",
            "                uri = uri % dest",
            "                self.assertEqual(uri, drvr._live_migration_uri(dest))",
            "            else:",
            "                self.assertRaises(exception.LiveMigrationURINotAvailable,",
            "                                  drvr._live_migration_uri,",
            "                                  dest)",
            "",
            "    def test_live_migration_uri_forced(self):",
            "        dest = 'destination'",
            "        for hyperv in ('kvm', 'xen'):",
            "            self.flags(virt_type=hyperv, group='libvirt')",
            "",
            "            forced_uri = 'foo://%s/bar'",
            "            self.flags(live_migration_uri=forced_uri, group='libvirt')",
            "",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "            self.assertEqual(forced_uri % dest, drvr._live_migration_uri(dest))",
            "",
            "    def test_update_volume_xml_no_serial(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        xml_tmpl = \"\"\"",
            "        <domain type='kvm'>",
            "          <devices>",
            "            <disk type='block' device='disk'>",
            "              <driver name='qemu' type='raw' cache='none'/>",
            "              <source dev='{device_path}'/>",
            "              <target bus='virtio' dev='vdb'/>",
            "              <serial></serial>",
            "              <address type='pci' domain='0x0' bus='0x0' slot='0x04' \\",
            "              function='0x0'/>",
            "            </disk>",
            "          </devices>",
            "        </domain>",
            "        \"\"\"",
            "",
            "        initial_xml = xml_tmpl.format(device_path='/dev/disk/by-path/'",
            "                                      'ip-1.2.3.4:3260-iqn.'",
            "                                      'abc.12345.opst-lun-X')",
            "        target_xml = xml_tmpl.format(device_path='/dev/disk/by-path/'",
            "                                     'ip-1.2.3.4:3260-iqn.'",
            "                                     'abc.12345.opst-lun-X')",
            "        target_xml = etree.tostring(etree.fromstring(target_xml))",
            "        serial = \"58a84f6d-3f0c-4e19-a0af-eb657b790657\"",
            "        connection_info = {",
            "            u'driver_volume_type': u'iscsi',",
            "            'serial': u'58a84f6d-3f0c-4e19-a0af-eb657b790657',",
            "            u'data': {",
            "                u'access_mode': u'rw', u'target_discovered': False,",
            "                u'target_iqn': u'ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z',",
            "                u'volume_id': u'58a84f6d-3f0c-4e19-a0af-eb657b790657',",
            "                u'device_path':",
            "                u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z',",
            "            },",
            "        }",
            "        bdmi = objects.LibvirtLiveMigrateBDMInfo(serial=serial,",
            "                                                 bus='virtio',",
            "                                                 dev='vdb',",
            "                                                 type='disk')",
            "        bdmi.connection_info = connection_info",
            "",
            "        conf = vconfig.LibvirtConfigGuestDisk()",
            "        conf.source_device = bdmi.type",
            "        conf.driver_name = \"qemu\"",
            "        conf.driver_format = \"raw\"",
            "        conf.driver_cache = \"none\"",
            "        conf.target_dev = bdmi.dev",
            "        conf.target_bus = bdmi.bus",
            "        conf.serial = bdmi.connection_info.get('serial')",
            "        conf.source_type = \"block\"",
            "        conf.source_path = bdmi.connection_info['data'].get('device_path')",
            "",
            "        with mock.patch.object(drvr, '_get_volume_config',",
            "                               return_value=conf):",
            "            xml_doc = etree.fromstring(initial_xml)",
            "            config = drvr._update_volume_xml(xml_doc, [bdmi])",
            "            self.assertEqual(target_xml, etree.tostring(config))",
            "",
            "    def test_update_volume_xml_no_connection_info(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        initial_xml = self.device_xml_tmpl.format(",
            "            device_path='/dev/disk/by-path/'",
            "            'ip-1.2.3.4:3260-iqn.'",
            "            'abc.12345.opst-lun-X')",
            "        target_xml = self.device_xml_tmpl.format(",
            "            device_path='/dev/disk/by-path/'",
            "            'ip-1.2.3.4:3260-iqn.'",
            "            'abc.12345.opst-lun-X')",
            "        target_xml = etree.tostring(etree.fromstring(target_xml))",
            "        serial = \"58a84f6d-3f0c-4e19-a0af-eb657b790657\"",
            "        bdmi = objects.LibvirtLiveMigrateBDMInfo(serial=serial,",
            "                                                 dev='vdb',",
            "                                                 type='disk',",
            "                                                 bus='scsi',",
            "                                                 format='qcow')",
            "        bdmi.connection_info = {}",
            "        conf = vconfig.LibvirtConfigGuestDisk()",
            "        with mock.patch.object(drvr, '_get_volume_config',",
            "                               return_value=conf):",
            "            xml_doc = etree.fromstring(initial_xml)",
            "            config = drvr._update_volume_xml(xml_doc, [bdmi])",
            "            self.assertEqual(target_xml, etree.tostring(config))",
            "",
            "    @mock.patch.object(fakelibvirt.virDomain, \"migrateToURI2\")",
            "    @mock.patch.object(fakelibvirt.virDomain, \"XMLDesc\")",
            "    def test_live_migration_update_serial_console_xml(self, mock_xml,",
            "                                                      mock_migrate):",
            "        self.compute = importutils.import_object(CONF.compute_manager)",
            "        instance_ref = self.test_instance",
            "",
            "        xml_tmpl = (\"<domain type='kvm'>\"",
            "                    \"<devices>\"",
            "                    \"<console type='tcp'>\"",
            "                    \"<source mode='bind' host='{addr}' service='10000'/>\"",
            "                    \"</console>\"",
            "                    \"</devices>\"",
            "                    \"</domain>\")",
            "",
            "        initial_xml = xml_tmpl.format(addr='9.0.0.1')",
            "",
            "        target_xml = xml_tmpl.format(addr='9.0.0.12')",
            "        target_xml = etree.tostring(etree.fromstring(target_xml))",
            "",
            "        # Preparing mocks",
            "        mock_xml.return_value = initial_xml",
            "        mock_migrate.side_effect = fakelibvirt.libvirtError(\"ERR\")",
            "",
            "        # start test",
            "        bandwidth = CONF.libvirt.live_migration_bandwidth",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            graphics_listen_addr_vnc='10.0.0.1',",
            "            graphics_listen_addr_spice='10.0.0.2',",
            "            serial_listen_addr='9.0.0.12',",
            "            target_connect_addr=None,",
            "            bdms=[])",
            "        dom = fakelibvirt.virDomain",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertRaises(fakelibvirt.libvirtError,",
            "                          drvr._live_migration_operation,",
            "                          self.context, instance_ref, 'dest',",
            "                          False, migrate_data, dom, [])",
            "        mock_xml.assert_called_once_with(",
            "                flags=fakelibvirt.VIR_DOMAIN_XML_MIGRATABLE)",
            "        mock_migrate.assert_called_once_with(",
            "                drvr._live_migration_uri('dest'),",
            "                None, target_xml, mock.ANY, None, bandwidth)",
            "",
            "    @mock.patch.object(fakelibvirt, 'VIR_DOMAIN_XML_MIGRATABLE', None,",
            "                       create=True)",
            "    def test_live_migration_fails_with_serial_console_without_migratable(self):",
            "        self.compute = importutils.import_object(CONF.compute_manager)",
            "        instance_ref = self.test_instance",
            "",
            "        CONF.set_override(\"enabled\", True, \"serial_console\")",
            "        dom = fakelibvirt.virDomain",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            serial_listen_addr='', target_connect_addr=None)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertRaises(exception.MigrationError,",
            "                          drvr._live_migration_operation,",
            "                          self.context, instance_ref, 'dest',",
            "                          False, migrate_data, dom, [])",
            "",
            "    @mock.patch.object(fakelibvirt, 'VIR_DOMAIN_XML_MIGRATABLE', None,",
            "                       create=True)",
            "    def test_live_migration_uses_migrateToURI_without_migratable_flag(self):",
            "        self.compute = importutils.import_object(CONF.compute_manager)",
            "        instance_dict = dict(self.test_instance)",
            "        instance_dict.update({'host': 'fake',",
            "                              'power_state': power_state.RUNNING,",
            "                              'vm_state': vm_states.ACTIVE})",
            "        instance_ref = objects.Instance(**instance_dict)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        # Preparing mocks",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"migrateToURI\")",
            "        _bandwidth = CONF.libvirt.live_migration_bandwidth",
            "        vdmock.migrateToURI(drvr._live_migration_uri('dest'),",
            "                            mox.IgnoreArg(),",
            "                            None,",
            "                            _bandwidth).AndRaise(",
            "                                fakelibvirt.libvirtError(\"ERR\"))",
            "",
            "        # start test",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            graphics_listen_addr_vnc='0.0.0.0',",
            "            graphics_listen_addr_spice='0.0.0.0',",
            "            serial_listen_addr='127.0.0.1',",
            "            target_connect_addr=None,",
            "            bdms=[])",
            "        self.mox.ReplayAll()",
            "        self.assertRaises(fakelibvirt.libvirtError,",
            "                          drvr._live_migration_operation,",
            "                          self.context, instance_ref, 'dest',",
            "                          False, migrate_data, vdmock, [])",
            "",
            "    def test_live_migration_uses_migrateToURI_without_dest_listen_addrs(self):",
            "        self.compute = importutils.import_object(CONF.compute_manager)",
            "        instance_dict = dict(self.test_instance)",
            "        instance_dict.update({'host': 'fake',",
            "                              'power_state': power_state.RUNNING,",
            "                              'vm_state': vm_states.ACTIVE})",
            "        instance_ref = objects.Instance(**instance_dict)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        # Preparing mocks",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"migrateToURI\")",
            "        _bandwidth = CONF.libvirt.live_migration_bandwidth",
            "        vdmock.migrateToURI(drvr._live_migration_uri('dest'),",
            "                            mox.IgnoreArg(),",
            "                            None,",
            "                            _bandwidth).AndRaise(",
            "                                fakelibvirt.libvirtError(\"ERR\"))",
            "",
            "        # start test",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            serial_listen_addr='',",
            "            target_connect_addr=None,",
            "            bdms=[])",
            "        self.mox.ReplayAll()",
            "        self.assertRaises(fakelibvirt.libvirtError,",
            "                          drvr._live_migration_operation,",
            "                          self.context, instance_ref, 'dest',",
            "                          False, migrate_data, vdmock, [])",
            "",
            "    @mock.patch.object(host.Host, 'has_min_version', return_value=True)",
            "    @mock.patch.object(fakelibvirt.virDomain, \"migrateToURI3\")",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._update_xml',",
            "                return_value='')",
            "    @mock.patch('nova.virt.libvirt.guest.Guest.get_xml_desc', return_value='')",
            "    def test_live_migration_uses_migrateToURI3(",
            "            self, mock_old_xml, mock_new_xml, mock_migrateToURI3,",
            "            mock_min_version):",
            "        # Preparing mocks",
            "        disk_paths = ['vda', 'vdb']",
            "        params = {",
            "            'migrate_disks': ['vda', 'vdb'],",
            "            'bandwidth': CONF.libvirt.live_migration_bandwidth,",
            "            'destination_xml': '',",
            "        }",
            "        mock_migrateToURI3.side_effect = fakelibvirt.libvirtError(\"ERR\")",
            "",
            "        # Start test",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            graphics_listen_addr_vnc='0.0.0.0',",
            "            graphics_listen_addr_spice='0.0.0.0',",
            "            serial_listen_addr='127.0.0.1',",
            "            target_connect_addr=None,",
            "            bdms=[])",
            "",
            "        dom = fakelibvirt.virDomain",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        self.assertRaises(fakelibvirt.libvirtError,",
            "                          drvr._live_migration_operation,",
            "                          self.context, instance, 'dest',",
            "                          False, migrate_data, dom, disk_paths)",
            "        mock_migrateToURI3.assert_called_once_with(",
            "                drvr._live_migration_uri('dest'), params, None)",
            "",
            "    @mock.patch.object(fakelibvirt, 'VIR_DOMAIN_XML_MIGRATABLE', None,",
            "                       create=True)",
            "    def test_live_migration_fails_without_migratable_flag_or_0_addr(self):",
            "        self.flags(enabled=True, vncserver_listen='1.2.3.4', group='vnc')",
            "        self.compute = importutils.import_object(CONF.compute_manager)",
            "        instance_dict = dict(self.test_instance)",
            "        instance_dict.update({'host': 'fake',",
            "                              'power_state': power_state.RUNNING,",
            "                              'vm_state': vm_states.ACTIVE})",
            "        instance_ref = objects.Instance(**instance_dict)",
            "",
            "        # Preparing mocks",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"migrateToURI\")",
            "",
            "        # start test",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            graphics_listen_addr_vnc='1.2.3.4',",
            "            graphics_listen_addr_spice='1.2.3.4',",
            "            serial_listen_addr='127.0.0.1',",
            "            target_connect_addr=None)",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertRaises(exception.MigrationError,",
            "                          drvr._live_migration_operation,",
            "                          self.context, instance_ref, 'dest',",
            "                          False, migrate_data, vdmock, [])",
            "",
            "    def test_live_migration_raises_exception(self):",
            "        # Confirms recover method is called when exceptions are raised.",
            "        # Preparing data",
            "        self.compute = importutils.import_object(CONF.compute_manager)",
            "        instance_dict = dict(self.test_instance)",
            "        instance_dict.update({'host': 'fake',",
            "                              'power_state': power_state.RUNNING,",
            "                              'vm_state': vm_states.ACTIVE})",
            "        instance_ref = objects.Instance(**instance_dict)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        # Preparing mocks",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"migrateToURI2\")",
            "        _bandwidth = CONF.libvirt.live_migration_bandwidth",
            "        if getattr(fakelibvirt, 'VIR_DOMAIN_XML_MIGRATABLE', None) is None:",
            "            vdmock.migrateToURI(drvr._live_migration_uri('dest'),",
            "                                mox.IgnoreArg(),",
            "                                None,",
            "                                _bandwidth).AndRaise(",
            "                                        fakelibvirt.libvirtError('ERR'))",
            "        else:",
            "            vdmock.XMLDesc(flags=fakelibvirt.VIR_DOMAIN_XML_MIGRATABLE",
            "            ).AndReturn(FakeVirtDomain().XMLDesc(flags=0))",
            "            vdmock.migrateToURI2(drvr._live_migration_uri('dest'),",
            "                                 None,",
            "                                 mox.IgnoreArg(),",
            "                                 mox.IgnoreArg(),",
            "                                 None,",
            "                                 _bandwidth).AndRaise(",
            "                                         fakelibvirt.libvirtError('ERR'))",
            "",
            "        # start test",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            graphics_listen_addr_vnc='127.0.0.1',",
            "            graphics_listen_addr_spice='127.0.0.1',",
            "            serial_listen_addr='127.0.0.1',",
            "            target_connect_addr=None,",
            "            bdms=[])",
            "        self.mox.ReplayAll()",
            "        self.assertRaises(fakelibvirt.libvirtError,",
            "                          drvr._live_migration_operation,",
            "                          self.context, instance_ref, 'dest',",
            "                          False, migrate_data, vdmock, [])",
            "",
            "        self.assertEqual(vm_states.ACTIVE, instance_ref.vm_state)",
            "        self.assertEqual(power_state.RUNNING, instance_ref.power_state)",
            "",
            "    def test_live_migration_raises_unsupported_config_exception(self):",
            "        # Tests that when migrateToURI2 fails with VIR_ERR_CONFIG_UNSUPPORTED,",
            "        # migrateToURI is used instead.",
            "",
            "        # Preparing data",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        # Preparing mocks",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, 'migrateToURI2')",
            "        self.mox.StubOutWithMock(vdmock, 'migrateToURI')",
            "        _bandwidth = CONF.libvirt.live_migration_bandwidth",
            "        vdmock.XMLDesc(flags=fakelibvirt.VIR_DOMAIN_XML_MIGRATABLE).AndReturn(",
            "                FakeVirtDomain().XMLDesc(flags=0))",
            "        unsupported_config_error = fakelibvirt.libvirtError('ERR')",
            "        unsupported_config_error.err = (",
            "            fakelibvirt.VIR_ERR_CONFIG_UNSUPPORTED,)",
            "        # This is the first error we hit but since the error code is",
            "        # VIR_ERR_CONFIG_UNSUPPORTED we'll try migrateToURI.",
            "        vdmock.migrateToURI2(drvr._live_migration_uri('dest'), None,",
            "                             mox.IgnoreArg(), mox.IgnoreArg(), None,",
            "                             _bandwidth).AndRaise(unsupported_config_error)",
            "        # This is the second and final error that will actually kill the run,",
            "        # we use TestingException to make sure it's not the same libvirtError",
            "        # above.",
            "        vdmock.migrateToURI(drvr._live_migration_uri('dest'),",
            "                            mox.IgnoreArg(), None,",
            "                            _bandwidth).AndRaise(test.TestingException('oops'))",
            "",
            "        graphics_listen_addrs = {'vnc': '0.0.0.0', 'spice': '127.0.0.1'}",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            graphics_listen_addr_vnc='0.0.0.0',",
            "            graphics_listen_addr_spice='127.0.0.1',",
            "            serial_listen_addr='127.0.0.1',",
            "            target_connect_addr=None,",
            "            bdms=[])",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        self.mox.StubOutWithMock(",
            "            drvr, '_check_graphics_addresses_can_live_migrate')",
            "        drvr._check_graphics_addresses_can_live_migrate(graphics_listen_addrs)",
            "        self.mox.ReplayAll()",
            "",
            "        # start test",
            "        self.assertRaises(test.TestingException,",
            "                          drvr._live_migration_operation,",
            "                          self.context, instance_ref, 'dest',",
            "                          False, migrate_data, vdmock, [])",
            "",
            "    @mock.patch('shutil.rmtree')",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path_at_destination')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.destroy')",
            "    def test_rollback_live_migration_at_dest_not_shared(self, mock_destroy,",
            "                                                        mock_get_instance_path,",
            "                                                        mock_exist,",
            "                                                        mock_shutil",
            "                                                        ):",
            "        # destroy method may raise InstanceTerminationFailure or",
            "        # InstancePowerOffFailure, here use their base class Invalid.",
            "        mock_destroy.side_effect = exception.Invalid(reason='just test')",
            "        fake_instance_path = os.path.join(cfg.CONF.instances_path,",
            "                                          '/fake_instance_uuid')",
            "        mock_get_instance_path.return_value = fake_instance_path",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            is_shared_instance_path=False,",
            "            instance_relative_path=False)",
            "        self.assertRaises(exception.Invalid,",
            "                          drvr.rollback_live_migration_at_destination,",
            "                          \"context\", \"instance\", [], None, True, migrate_data)",
            "        mock_exist.assert_called_once_with(fake_instance_path)",
            "        mock_shutil.assert_called_once_with(fake_instance_path)",
            "",
            "    @mock.patch('shutil.rmtree')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path_at_destination')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.destroy')",
            "    def test_rollback_live_migration_at_dest_shared(self, mock_destroy,",
            "                                                    mock_get_instance_path,",
            "                                                    mock_exist,",
            "                                                    mock_shutil",
            "                                                    ):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            is_shared_instance_path=True,",
            "            instance_relative_path=False)",
            "        drvr.rollback_live_migration_at_destination(\"context\", \"instance\", [],",
            "                                                    None, True, migrate_data)",
            "        mock_destroy.assert_called_once_with(\"context\", \"instance\", [],",
            "                                             None, True, migrate_data)",
            "        self.assertFalse(mock_get_instance_path.called)",
            "        self.assertFalse(mock_exist.called)",
            "        self.assertFalse(mock_shutil.called)",
            "",
            "    @mock.patch.object(host.Host, \"has_min_version\", return_value=False)",
            "    @mock.patch.object(fakelibvirt.Domain, \"XMLDesc\")",
            "    def test_live_migration_copy_disk_paths(self, mock_xml, mock_version):",
            "        xml = \"\"\"",
            "        <domain>",
            "          <name>dummy</name>",
            "          <uuid>d4e13113-918e-42fe-9fc9-861693ffd432</uuid>",
            "          <devices>",
            "            <disk type=\"file\">",
            "               <source file=\"/var/lib/nova/instance/123/disk.root\"/>",
            "               <target dev=\"vda\"/>",
            "            </disk>",
            "            <disk type=\"file\">",
            "               <source file=\"/var/lib/nova/instance/123/disk.shared\"/>",
            "               <target dev=\"vdb\"/>",
            "               <shareable/>",
            "            </disk>",
            "            <disk type=\"file\">",
            "               <source file=\"/var/lib/nova/instance/123/disk.config\"/>",
            "               <target dev=\"vdc\"/>",
            "               <readonly/>",
            "            </disk>",
            "            <disk type=\"block\">",
            "               <source dev=\"/dev/mapper/somevol\"/>",
            "               <target dev=\"vdd\"/>",
            "            </disk>",
            "            <disk type=\"network\">",
            "               <source protocol=\"https\" name=\"url_path\">",
            "                 <host name=\"hostname\" port=\"443\"/>",
            "               </source>",
            "            </disk>",
            "          </devices>",
            "        </domain>\"\"\"",
            "        mock_xml.return_value = xml",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        dom = fakelibvirt.Domain(drvr._get_connection(), xml, False)",
            "        guest = libvirt_guest.Guest(dom)",
            "",
            "        paths = drvr._live_migration_copy_disk_paths(None, None, guest)",
            "        self.assertEqual(([\"/var/lib/nova/instance/123/disk.root\",",
            "                          \"/dev/mapper/somevol\"], ['vda', 'vdd']), paths)",
            "",
            "    @mock.patch.object(host.Host, \"has_min_version\", return_value=True)",
            "    @mock.patch('nova.virt.driver.get_block_device_info')",
            "    @mock.patch('nova.objects.BlockDeviceMappingList.get_by_instance_uuid')",
            "    @mock.patch.object(fakelibvirt.Domain, \"XMLDesc\")",
            "    def test_live_migration_copy_disk_paths_selective_block_migration(",
            "            self, mock_xml, mock_get_instance,",
            "            mock_block_device_info, mock_version):",
            "        xml = \"\"\"",
            "        <domain>",
            "          <name>dummy</name>",
            "          <uuid>d4e13113-918e-42fe-9fc9-861693ffd432</uuid>",
            "          <devices>",
            "            <disk type=\"file\">",
            "               <source file=\"/var/lib/nova/instance/123/disk.root\"/>",
            "               <target dev=\"vda\"/>",
            "            </disk>",
            "            <disk type=\"file\">",
            "               <source file=\"/var/lib/nova/instance/123/disk.shared\"/>",
            "               <target dev=\"vdb\"/>",
            "            </disk>",
            "            <disk type=\"file\">",
            "               <source file=\"/var/lib/nova/instance/123/disk.config\"/>",
            "               <target dev=\"vdc\"/>",
            "            </disk>",
            "            <disk type=\"block\">",
            "               <source dev=\"/dev/mapper/somevol\"/>",
            "               <target dev=\"vdd\"/>",
            "            </disk>",
            "            <disk type=\"network\">",
            "               <source protocol=\"https\" name=\"url_path\">",
            "                 <host name=\"hostname\" port=\"443\"/>",
            "               </source>",
            "            </disk>",
            "          </devices>",
            "        </domain>\"\"\"",
            "        mock_xml.return_value = xml",
            "        instance = objects.Instance(**self.test_instance)",
            "        instance.root_device_name = '/dev/vda'",
            "        block_device_info = {",
            "            'swap': {",
            "                'disk_bus': u'virtio',",
            "                'swap_size': 10,",
            "                'device_name': u'/dev/vdc'",
            "            },",
            "            'root_device_name': u'/dev/vda',",
            "            'ephemerals': [{",
            "                'guest_format': u'ext3',",
            "                'device_name': u'/dev/vdb',",
            "                'disk_bus': u'virtio',",
            "                'device_type': u'disk',",
            "                'size': 1",
            "            }],",
            "            'block_device_mapping': [{",
            "                'guest_format': None,",
            "                'boot_index': None,",
            "                'mount_device': u'/dev/vdd',",
            "                'connection_info': {",
            "                    u'driver_volume_type': u'iscsi',",
            "                    'serial': u'147df29f-aec2-4851-b3fe-f68dad151834',",
            "                    u'data': {",
            "                        u'access_mode': u'rw',",
            "                        u'target_discovered': False,",
            "                        u'encrypted': False,",
            "                        u'qos_specs': None,",
            "                        u'target_iqn': u'iqn.2010-10.org.openstack:'",
            "                                       u'volume-147df29f-aec2-4851-b3fe-'",
            "                                       u'f68dad151834',",
            "                        u'target_portal': u'10.102.44.141:3260', u'volume_id':",
            "                            u'147df29f-aec2-4851-b3fe-f68dad151834',",
            "                        u'target_lun': 1,",
            "                        u'auth_password': u'cXELT66FngwzTwpf',",
            "                        u'auth_username': u'QbQQjj445uWgeQkFKcVw',",
            "                        u'auth_method': u'CHAP'",
            "                    }",
            "                },",
            "                'disk_bus': None,",
            "                'device_type': None,",
            "                'delete_on_termination': False",
            "            }]",
            "        }",
            "        mock_block_device_info.return_value = block_device_info",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        dom = fakelibvirt.Domain(drvr._get_connection(), xml, False)",
            "        guest = libvirt_guest.Guest(dom)",
            "        return_value = drvr._live_migration_copy_disk_paths(context, instance,",
            "                                                            guest)",
            "        expected = (['/var/lib/nova/instance/123/disk.root',",
            "                     '/var/lib/nova/instance/123/disk.shared',",
            "                     '/var/lib/nova/instance/123/disk.config'],",
            "                    ['vda', 'vdb', 'vdc'])",
            "        self.assertEqual(expected, return_value)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver,",
            "                       \"_live_migration_copy_disk_paths\")",
            "    def test_live_migration_data_gb_plain(self, mock_paths):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        data_gb = drvr._live_migration_data_gb(instance, [])",
            "        self.assertEqual(2, data_gb)",
            "        self.assertEqual(0, mock_paths.call_count)",
            "",
            "    def test_live_migration_data_gb_block(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        def fake_stat(path):",
            "            class StatResult(object):",
            "                def __init__(self, size):",
            "                    self._size = size",
            "",
            "                @property",
            "                def st_size(self):",
            "                    return self._size",
            "",
            "            if path == \"/var/lib/nova/instance/123/disk.root\":",
            "                return StatResult(10 * units.Gi)",
            "            elif path == \"/dev/mapper/somevol\":",
            "                return StatResult(1.5 * units.Gi)",
            "            else:",
            "                raise Exception(\"Should not be reached\")",
            "",
            "        disk_paths = [\"/var/lib/nova/instance/123/disk.root\",",
            "                      \"/dev/mapper/somevol\"]",
            "        with mock.patch.object(os, \"stat\") as mock_stat:",
            "            mock_stat.side_effect = fake_stat",
            "            data_gb = drvr._live_migration_data_gb(instance, disk_paths)",
            "            # Expecting 2 GB for RAM, plus 10 GB for disk.root",
            "            # and 1.5 GB rounded to 2 GB for somevol, so 14 GB",
            "            self.assertEqual(14, data_gb)",
            "",
            "    EXPECT_SUCCESS = 1",
            "    EXPECT_FAILURE = 2",
            "    EXPECT_ABORT = 3",
            "",
            "    @mock.patch.object(time, \"time\")",
            "    @mock.patch.object(time, \"sleep\",",
            "                       side_effect=lambda x: eventlet.sleep(0))",
            "    @mock.patch.object(host.DomainJobInfo, \"for_domain\")",
            "    @mock.patch.object(objects.Instance, \"save\")",
            "    @mock.patch.object(objects.Migration, \"save\")",
            "    @mock.patch.object(fakelibvirt.Connection, \"_mark_running\")",
            "    @mock.patch.object(fakelibvirt.virDomain, \"abortJob\")",
            "    def _test_live_migration_monitoring(self,",
            "                                        job_info_records,",
            "                                        time_records,",
            "                                        expect_result,",
            "                                        mock_abort,",
            "                                        mock_running,",
            "                                        mock_save,",
            "                                        mock_mig_save,",
            "                                        mock_job_info,",
            "                                        mock_sleep,",
            "                                        mock_time,",
            "                                        expected_mig_status=None):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        dom = fakelibvirt.Domain(drvr._get_connection(), \"<domain/>\", True)",
            "        guest = libvirt_guest.Guest(dom)",
            "        finish_event = eventlet.event.Event()",
            "",
            "        def fake_job_info(hostself):",
            "            while True:",
            "                self.assertTrue(len(job_info_records) > 0)",
            "                rec = job_info_records.pop(0)",
            "",
            "                if type(rec) == str:",
            "                    if rec == \"thread-finish\":",
            "                        finish_event.send()",
            "                    elif rec == \"domain-stop\":",
            "                        dom.destroy()",
            "                else:",
            "                    if len(time_records) > 0:",
            "                        time_records.pop(0)",
            "                    return rec",
            "            return rec",
            "",
            "        def fake_time():",
            "            if len(time_records) > 0:",
            "                return time_records[0]",
            "            else:",
            "                return int(",
            "                    datetime.datetime(2001, 1, 20, 20, 1, 0)",
            "                    .strftime('%s'))",
            "",
            "        mock_job_info.side_effect = fake_job_info",
            "        mock_time.side_effect = fake_time",
            "",
            "        dest = mock.sentinel.migrate_dest",
            "        migration = objects.Migration(context=self.context, id=1)",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            migration=migration)",
            "",
            "        fake_post_method = mock.MagicMock()",
            "        fake_recover_method = mock.MagicMock()",
            "        drvr._live_migration_monitor(self.context, instance,",
            "                                     guest, dest,",
            "                                     fake_post_method,",
            "                                     fake_recover_method,",
            "                                     False,",
            "                                     migrate_data,",
            "                                     dom,",
            "                                     finish_event,",
            "                                     [])",
            "",
            "        mock_mig_save.assert_called_with()",
            "",
            "        if expect_result == self.EXPECT_SUCCESS:",
            "            self.assertFalse(fake_recover_method.called,",
            "                             'Recover method called when success expected')",
            "            self.assertFalse(mock_abort.called,",
            "                             'abortJob not called when success expected')",
            "            fake_post_method.assert_called_once_with(",
            "                self.context, instance, dest, False, migrate_data)",
            "        else:",
            "            if expect_result == self.EXPECT_ABORT:",
            "                self.assertTrue(mock_abort.called,",
            "                                'abortJob called when abort expected')",
            "            else:",
            "                self.assertFalse(mock_abort.called,",
            "                                 'abortJob not called when failure expected')",
            "            self.assertFalse(fake_post_method.called,",
            "                             'Post method called when success not expected')",
            "            if expected_mig_status:",
            "                fake_recover_method.assert_called_once_with(",
            "                    self.context, instance, dest, False, migrate_data,",
            "                    migration_status=expected_mig_status)",
            "            else:",
            "                fake_recover_method.assert_called_once_with(",
            "                    self.context, instance, dest, False, migrate_data)",
            "",
            "    def test_live_migration_monitor_success(self):",
            "        # A normal sequence where see all the normal job states",
            "        domain_info_records = [",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_NONE),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            \"thread-finish\",",
            "            \"domain-stop\",",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_COMPLETED),",
            "        ]",
            "",
            "        self._test_live_migration_monitoring(domain_info_records, [],",
            "                                             self.EXPECT_SUCCESS)",
            "",
            "    def test_live_migration_monitor_success_race(self):",
            "        # A normalish sequence but we're too slow to see the",
            "        # completed job state",
            "        domain_info_records = [",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_NONE),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            \"thread-finish\",",
            "            \"domain-stop\",",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_NONE),",
            "        ]",
            "",
            "        self._test_live_migration_monitoring(domain_info_records, [],",
            "                                             self.EXPECT_SUCCESS)",
            "",
            "    def test_live_migration_monitor_failed(self):",
            "        # A failed sequence where we see all the expected events",
            "        domain_info_records = [",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_NONE),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            \"thread-finish\",",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_FAILED),",
            "        ]",
            "",
            "        self._test_live_migration_monitoring(domain_info_records, [],",
            "                                             self.EXPECT_FAILURE)",
            "",
            "    def test_live_migration_monitor_failed_race(self):",
            "        # A failed sequence where we are too slow to see the",
            "        # failed event",
            "        domain_info_records = [",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_NONE),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            \"thread-finish\",",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_NONE),",
            "        ]",
            "",
            "        self._test_live_migration_monitoring(domain_info_records, [],",
            "                                             self.EXPECT_FAILURE)",
            "",
            "    def test_live_migration_monitor_cancelled(self):",
            "        # A cancelled sequence where we see all the events",
            "        domain_info_records = [",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_NONE),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            \"thread-finish\",",
            "            \"domain-stop\",",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_CANCELLED),",
            "        ]",
            "",
            "        self._test_live_migration_monitoring(domain_info_records, [],",
            "                                             self.EXPECT_FAILURE,",
            "                                             expected_mig_status='cancelled')",
            "",
            "    @mock.patch.object(fakelibvirt.virDomain, \"migrateSetMaxDowntime\")",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver,",
            "                       \"_migration_downtime_steps\")",
            "    def test_live_migration_monitor_downtime(self, mock_downtime_steps,",
            "                                             mock_set_downtime):",
            "        self.flags(live_migration_completion_timeout=1000000,",
            "                   live_migration_progress_timeout=1000000,",
            "                   group='libvirt')",
            "        # We've setup 4 fake downtime steps - first value is the",
            "        # time delay, second is the downtime value",
            "        downtime_steps = [",
            "            (90, 10),",
            "            (180, 50),",
            "            (270, 200),",
            "            (500, 300),",
            "        ]",
            "        mock_downtime_steps.return_value = downtime_steps",
            "",
            "        # Each one of these fake times is used for time.time()",
            "        # when a new domain_info_records entry is consumed.",
            "        # Times are chosen so that only the first 3 downtime",
            "        # steps are needed.",
            "        fake_times = [0, 1, 30, 95, 150, 200, 300]",
            "",
            "        # A normal sequence where see all the normal job states",
            "        domain_info_records = [",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_NONE),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            \"thread-finish\",",
            "            \"domain-stop\",",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_COMPLETED),",
            "        ]",
            "",
            "        self._test_live_migration_monitoring(domain_info_records,",
            "                                             fake_times, self.EXPECT_SUCCESS)",
            "",
            "        mock_set_downtime.assert_has_calls([mock.call(10),",
            "                                            mock.call(50),",
            "                                            mock.call(200)])",
            "",
            "    def test_live_migration_monitor_completion(self):",
            "        self.flags(live_migration_completion_timeout=100,",
            "                   live_migration_progress_timeout=1000000,",
            "                   group='libvirt')",
            "        # Each one of these fake times is used for time.time()",
            "        # when a new domain_info_records entry is consumed.",
            "        fake_times = [0, 40, 80, 120, 160, 200, 240, 280, 320]",
            "",
            "        # A normal sequence where see all the normal job states",
            "        domain_info_records = [",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_NONE),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            \"thread-finish\",",
            "            \"domain-stop\",",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_CANCELLED),",
            "        ]",
            "",
            "        self._test_live_migration_monitoring(domain_info_records,",
            "                                             fake_times, self.EXPECT_ABORT,",
            "                                             expected_mig_status='cancelled')",
            "",
            "    def test_live_migration_monitor_progress(self):",
            "        self.flags(live_migration_completion_timeout=1000000,",
            "                   live_migration_progress_timeout=150,",
            "                   group='libvirt')",
            "        # Each one of these fake times is used for time.time()",
            "        # when a new domain_info_records entry is consumed.",
            "        fake_times = [0, 40, 80, 120, 160, 200, 240, 280, 320]",
            "",
            "        # A normal sequence where see all the normal job states",
            "        domain_info_records = [",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_NONE),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            \"thread-finish\",",
            "            \"domain-stop\",",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_CANCELLED),",
            "        ]",
            "",
            "        self._test_live_migration_monitoring(domain_info_records,",
            "                                             fake_times, self.EXPECT_ABORT,",
            "                                             expected_mig_status='cancelled')",
            "",
            "    def test_live_migration_downtime_steps(self):",
            "        self.flags(live_migration_downtime=400, group='libvirt')",
            "        self.flags(live_migration_downtime_steps=10, group='libvirt')",
            "        self.flags(live_migration_downtime_delay=30, group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        steps = drvr._migration_downtime_steps(3.0)",
            "",
            "        self.assertEqual([",
            "            (0, 37),",
            "            (90, 38),",
            "            (180, 39),",
            "            (270, 42),",
            "            (360, 46),",
            "            (450, 55),",
            "            (540, 70),",
            "            (630, 98),",
            "            (720, 148),",
            "            (810, 238),",
            "            (900, 400),",
            "        ], list(steps))",
            "",
            "    @mock.patch.object(utils, \"spawn\")",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, \"_live_migration_monitor\")",
            "    @mock.patch.object(host.Host, \"get_guest\")",
            "    @mock.patch.object(fakelibvirt.Connection, \"_mark_running\")",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver,",
            "                       \"_live_migration_copy_disk_paths\")",
            "    def test_live_migration_main(self, mock_copy_disk_path, mock_running,",
            "                                 mock_guest, mock_monitor, mock_thread):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        dom = fakelibvirt.Domain(drvr._get_connection(),",
            "                                 \"<domain><name>demo</name></domain>\", True)",
            "        guest = libvirt_guest.Guest(dom)",
            "        migrate_data = {}",
            "        disks_to_copy = (['/some/path/one', '/test/path/two'],",
            "                         ['vda', 'vdb'])",
            "        mock_copy_disk_path.return_value = disks_to_copy",
            "",
            "        mock_guest.return_value = guest",
            "",
            "        def fake_post():",
            "            pass",
            "",
            "        def fake_recover():",
            "            pass",
            "",
            "        drvr._live_migration(self.context, instance, \"fakehost\",",
            "                             fake_post, fake_recover, True,",
            "                             migrate_data)",
            "        mock_copy_disk_path.assert_called_once_with(self.context, instance,",
            "                                                    guest)",
            "",
            "        class AnyEventletEvent(object):",
            "            def __eq__(self, other):",
            "                return type(other) == eventlet.event.Event",
            "",
            "        mock_thread.assert_called_once_with(",
            "            drvr._live_migration_operation,",
            "            self.context, instance, \"fakehost\", True,",
            "            migrate_data, dom, disks_to_copy[1])",
            "        mock_monitor.assert_called_once_with(",
            "            self.context, instance, guest, \"fakehost\",",
            "            fake_post, fake_recover, True,",
            "            migrate_data, dom, AnyEventletEvent(), disks_to_copy[0])",
            "",
            "    def _do_test_create_images_and_backing(self, disk_type):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.mox.StubOutWithMock(drvr, '_fetch_instance_kernel_ramdisk')",
            "        self.mox.StubOutWithMock(libvirt_driver.libvirt_utils, 'create_image')",
            "",
            "        disk_info = {'path': 'foo', 'type': disk_type,",
            "                     'disk_size': 1 * 1024 ** 3,",
            "                     'virt_disk_size': 20 * 1024 ** 3,",
            "                     'backing_file': None}",
            "",
            "        libvirt_driver.libvirt_utils.create_image(",
            "            disk_info['type'], mox.IgnoreArg(), disk_info['virt_disk_size'])",
            "        drvr._fetch_instance_kernel_ramdisk(self.context, self.test_instance,",
            "                                            fallback_from_host=None)",
            "        self.mox.ReplayAll()",
            "",
            "        self.stub_out('os.path.exists', lambda *args: False)",
            "        drvr._create_images_and_backing(self.context, self.test_instance,",
            "                                        \"/fake/instance/dir\", [disk_info])",
            "",
            "    def test_create_images_and_backing_qcow2(self):",
            "        self._do_test_create_images_and_backing('qcow2')",
            "",
            "    def test_create_images_and_backing_raw(self):",
            "        self._do_test_create_images_and_backing('raw')",
            "",
            "    def test_create_images_and_backing_images_not_exist_no_fallback(self):",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        disk_info = [",
            "            {u'backing_file': u'fake_image_backing_file',",
            "             u'disk_size': 10747904,",
            "             u'path': u'disk_path',",
            "             u'type': u'qcow2',",
            "             u'virt_disk_size': 25165824}]",
            "",
            "        self.test_instance.update({'user_id': 'fake-user',",
            "                                   'os_type': None,",
            "                                   'project_id': 'fake-project'})",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        with mock.patch.object(libvirt_driver.libvirt_utils, 'fetch_image',",
            "                               side_effect=exception.ImageNotFound(",
            "                                   image_id=\"fake_id\")):",
            "            self.assertRaises(exception.ImageNotFound,",
            "                              conn._create_images_and_backing,",
            "                              self.context, instance,",
            "                              \"/fake/instance/dir\", disk_info)",
            "",
            "    def test_create_images_and_backing_images_not_exist_fallback(self):",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        disk_info = [",
            "            {u'backing_file': u'fake_image_backing_file',",
            "             u'disk_size': 10747904,",
            "             u'path': u'disk_path',",
            "             u'type': u'qcow2',",
            "             u'virt_disk_size': 25165824}]",
            "",
            "        base_dir = os.path.join(CONF.instances_path,",
            "                                CONF.image_cache_subdirectory_name)",
            "        self.test_instance.update({'user_id': 'fake-user',",
            "                                   'os_type': None,",
            "                                   'kernel_id': 'fake_kernel_id',",
            "                                   'ramdisk_id': 'fake_ramdisk_id',",
            "                                   'project_id': 'fake-project'})",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        with test.nested(",
            "            mock.patch.object(libvirt_driver.libvirt_utils, 'copy_image'),",
            "            mock.patch.object(libvirt_driver.libvirt_utils, 'fetch_image',",
            "                              side_effect=exception.ImageNotFound(",
            "                                  image_id=\"fake_id\")),",
            "        ) as (copy_image_mock, fetch_image_mock):",
            "            conn._create_images_and_backing(self.context, instance,",
            "                                            \"/fake/instance/dir\", disk_info,",
            "                                            fallback_from_host=\"fake_host\")",
            "            backfile_path = os.path.join(base_dir, 'fake_image_backing_file')",
            "            kernel_path = os.path.join(CONF.instances_path,",
            "                                       self.test_instance['uuid'],",
            "                                       'kernel')",
            "            ramdisk_path = os.path.join(CONF.instances_path,",
            "                                        self.test_instance['uuid'],",
            "                                        'ramdisk')",
            "            copy_image_mock.assert_has_calls([",
            "                mock.call(dest=backfile_path, src=backfile_path,",
            "                          host='fake_host', receive=True),",
            "                mock.call(dest=kernel_path, src=kernel_path,",
            "                          host='fake_host', receive=True),",
            "                mock.call(dest=ramdisk_path, src=ramdisk_path,",
            "                          host='fake_host', receive=True)",
            "            ])",
            "            fetch_image_mock.assert_has_calls([",
            "                mock.call(context=self.context,",
            "                          target=backfile_path,",
            "                          image_id=self.test_instance['image_ref'],",
            "                          user_id=self.test_instance['user_id'],",
            "                          project_id=self.test_instance['project_id'],",
            "                          max_size=25165824),",
            "                mock.call(self.context, kernel_path,",
            "                          self.test_instance['kernel_id'],",
            "                          self.test_instance['user_id'],",
            "                          self.test_instance['project_id']),",
            "                mock.call(self.context, ramdisk_path,",
            "                          self.test_instance['ramdisk_id'],",
            "                          self.test_instance['user_id'],",
            "                          self.test_instance['project_id']),",
            "            ])",
            "",
            "    @mock.patch.object(libvirt_driver.libvirt_utils, 'fetch_image')",
            "    @mock.patch.object(os.path, 'exists', return_value=True)",
            "    def test_create_images_and_backing_images_exist(self, mock_exists,",
            "                                                    mock_fetch_image):",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        disk_info = [",
            "            {u'backing_file': u'fake_image_backing_file',",
            "             u'disk_size': 10747904,",
            "             u'path': u'disk_path',",
            "             u'type': u'qcow2',",
            "             u'virt_disk_size': 25165824}]",
            "",
            "        self.test_instance.update({'user_id': 'fake-user',",
            "                                   'os_type': None,",
            "                                   'kernel_id': 'fake_kernel_id',",
            "                                   'ramdisk_id': 'fake_ramdisk_id',",
            "                                   'project_id': 'fake-project'})",
            "        instance = objects.Instance(**self.test_instance)",
            "        with mock.patch.object(imagebackend.Image, 'get_disk_size'):",
            "            conn._create_images_and_backing(self.context, instance,",
            "                                            '/fake/instance/dir', disk_info)",
            "        self.assertFalse(mock_fetch_image.called)",
            "",
            "    def test_create_images_and_backing_ephemeral_gets_created(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        disk_info = [",
            "            {u'backing_file': u'fake_image_backing_file',",
            "             u'disk_size': 10747904,",
            "             u'path': u'disk_path',",
            "             u'type': u'qcow2',",
            "             u'virt_disk_size': 25165824},",
            "            {u'backing_file': u'ephemeral_1_default',",
            "             u'disk_size': 393216,",
            "             u'over_committed_disk_size': 1073348608,",
            "             u'path': u'disk_eph_path',",
            "             u'type': u'qcow2',",
            "             u'virt_disk_size': 1073741824}]",
            "",
            "        base_dir = os.path.join(CONF.instances_path,",
            "                                CONF.image_cache_subdirectory_name)",
            "        instance = objects.Instance(**self.test_instance)",
            "        with test.nested(",
            "            mock.patch.object(drvr, '_fetch_instance_kernel_ramdisk'),",
            "            mock.patch.object(libvirt_driver.libvirt_utils, 'fetch_image'),",
            "            mock.patch.object(drvr, '_create_ephemeral'),",
            "            mock.patch.object(imagebackend.Image, 'verify_base_size'),",
            "            mock.patch.object(imagebackend.Image, 'get_disk_size')",
            "        ) as (fetch_kernel_ramdisk_mock, fetch_image_mock,",
            "                create_ephemeral_mock, verify_base_size_mock, disk_size_mock):",
            "            drvr._create_images_and_backing(self.context, instance,",
            "                                            \"/fake/instance/dir\",",
            "                                            disk_info)",
            "            self.assertEqual(len(create_ephemeral_mock.call_args_list), 1)",
            "            m_args, m_kwargs = create_ephemeral_mock.call_args_list[0]",
            "            self.assertEqual(",
            "                    os.path.join(base_dir, 'ephemeral_1_default'),",
            "                    m_kwargs['target'])",
            "            self.assertEqual(len(fetch_image_mock.call_args_list), 1)",
            "            m_args, m_kwargs = fetch_image_mock.call_args_list[0]",
            "            self.assertEqual(",
            "                    os.path.join(base_dir, 'fake_image_backing_file'),",
            "                    m_kwargs['target'])",
            "            verify_base_size_mock.assert_has_calls([",
            "                mock.call(os.path.join(base_dir, 'fake_image_backing_file'),",
            "                          25165824),",
            "                mock.call(os.path.join(base_dir, 'ephemeral_1_default'),",
            "                          1073741824)",
            "            ])",
            "",
            "    def test_create_images_and_backing_disk_info_none(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.mox.StubOutWithMock(drvr, '_fetch_instance_kernel_ramdisk')",
            "",
            "        drvr._fetch_instance_kernel_ramdisk(self.context, self.test_instance,",
            "                                            fallback_from_host=None)",
            "        self.mox.ReplayAll()",
            "",
            "        drvr._create_images_and_backing(self.context, self.test_instance,",
            "                                        \"/fake/instance/dir\", None)",
            "",
            "    def _generate_target_ret(self, target_connect_addr=None):",
            "        target_ret = {",
            "        'graphics_listen_addrs': {'spice': '127.0.0.1', 'vnc': '127.0.0.1'},",
            "        'target_connect_addr': target_connect_addr,",
            "        'serial_listen_addr': '127.0.0.1',",
            "        'volume': {",
            "         '12345': {'connection_info': {u'data': {'device_path':",
            "              u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.abc.12345.opst-lun-X'},",
            "                   'serial': '12345'},",
            "                   'disk_info': {'bus': 'scsi',",
            "                                 'dev': 'sda',",
            "                                 'type': 'disk'}},",
            "         '67890': {'connection_info': {u'data': {'device_path':",
            "              u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z'},",
            "                   'serial': '67890'},",
            "                   'disk_info': {'bus': 'scsi',",
            "                                 'dev': 'sdb',",
            "                                 'type': 'disk'}}}}",
            "        return target_ret",
            "",
            "    def test_pre_live_migration_works_correctly_mocked(self):",
            "        self._test_pre_live_migration_works_correctly_mocked()",
            "",
            "    def test_pre_live_migration_with_transport_ip(self):",
            "        self.flags(live_migration_inbound_addr='127.0.0.2',",
            "                   group='libvirt')",
            "        target_ret = self._generate_target_ret('127.0.0.2')",
            "        self._test_pre_live_migration_works_correctly_mocked(target_ret)",
            "",
            "    def _test_pre_live_migration_works_correctly_mocked(self,",
            "                                                        target_ret=None):",
            "        # Creating testdata",
            "        vol = {'block_device_mapping': [",
            "           {'connection_info': {'serial': '12345', u'data':",
            "            {'device_path':",
            "             u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.abc.12345.opst-lun-X'}},",
            "             'mount_device': '/dev/sda'},",
            "           {'connection_info': {'serial': '67890', u'data':",
            "            {'device_path':",
            "             u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z'}},",
            "             'mount_device': '/dev/sdb'}]}",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        class FakeNetworkInfo(object):",
            "            def fixed_ips(self):",
            "                return [\"test_ip_addr\"]",
            "",
            "        def fake_none(*args, **kwargs):",
            "            return",
            "",
            "        self.stubs.Set(drvr, '_create_images_and_backing', fake_none)",
            "",
            "        instance = objects.Instance(**self.test_instance)",
            "        c = context.get_admin_context()",
            "        nw_info = FakeNetworkInfo()",
            "",
            "        # Creating mocks",
            "        self.mox.StubOutWithMock(driver, \"block_device_info_get_mapping\")",
            "        driver.block_device_info_get_mapping(vol",
            "            ).AndReturn(vol['block_device_mapping'])",
            "        self.mox.StubOutWithMock(drvr, \"_connect_volume\")",
            "        for v in vol['block_device_mapping']:",
            "            disk_info = {",
            "                'bus': \"scsi\",",
            "                'dev': v['mount_device'].rpartition(\"/\")[2],",
            "                'type': \"disk\"",
            "                }",
            "            drvr._connect_volume(v['connection_info'],",
            "                                 disk_info)",
            "        self.mox.StubOutWithMock(drvr, 'plug_vifs')",
            "        drvr.plug_vifs(mox.IsA(instance), nw_info)",
            "",
            "        self.mox.ReplayAll()",
            "        migrate_data = {",
            "            \"block_migration\": False,",
            "            \"instance_relative_path\": \"foo\",",
            "            \"is_shared_block_storage\": False,",
            "            \"is_shared_instance_path\": False,",
            "        }",
            "        result = drvr.pre_live_migration(",
            "            c, instance, vol, nw_info, None,",
            "            migrate_data=migrate_data)",
            "        if not target_ret:",
            "            target_ret = self._generate_target_ret()",
            "        self.assertEqual(",
            "            result.to_legacy_dict(",
            "                pre_migration_result=True)['pre_live_migration_result'],",
            "            target_ret)",
            "",
            "    def test_pre_live_migration_block_with_config_drive_mocked(self):",
            "        # Creating testdata",
            "        vol = {'block_device_mapping': [",
            "                  {'connection_info': 'dummy', 'mount_device': '/dev/sda'},",
            "                  {'connection_info': 'dummy', 'mount_device': '/dev/sdb'}]}",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        def fake_true(*args, **kwargs):",
            "            return True",
            "",
            "        self.stubs.Set(configdrive, 'required_by', fake_true)",
            "",
            "        instance = objects.Instance(**self.test_instance)",
            "        c = context.get_admin_context()",
            "",
            "        self.assertRaises(exception.NoLiveMigrationForConfigDriveInLibVirt,",
            "                          drvr.pre_live_migration, c, instance, vol, None,",
            "                          None, {'is_shared_instance_path': False,",
            "                                 'is_shared_block_storage': False,",
            "                                 'block_migration': False,",
            "                                 'instance_relative_path': 'foo'})",
            "",
            "    @mock.patch('nova.virt.driver.block_device_info_get_mapping',",
            "                return_value=())",
            "    @mock.patch('nova.virt.configdrive.required_by',",
            "                return_value=True)",
            "    def test_pre_live_migration_block_with_config_drive_mocked_with_vfat(",
            "            self, mock_required_by, block_device_info_get_mapping):",
            "        self.flags(config_drive_format='vfat')",
            "        # Creating testdata",
            "        vol = {'block_device_mapping': [",
            "            {'connection_info': 'dummy', 'mount_device': '/dev/sda'},",
            "            {'connection_info': 'dummy', 'mount_device': '/dev/sdb'}]}",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        res_data = drvr.pre_live_migration(",
            "            self.context, instance, vol, [], None,",
            "            {'is_shared_instance_path': False,",
            "             'is_shared_block_storage': False,",
            "             'block_migration': False,",
            "             'instance_relative_path': 'foo'})",
            "        res_data = res_data.to_legacy_dict(pre_migration_result=True)",
            "        block_device_info_get_mapping.assert_called_once_with(",
            "            {'block_device_mapping': [",
            "                {'connection_info': 'dummy', 'mount_device': '/dev/sda'},",
            "                {'connection_info': 'dummy', 'mount_device': '/dev/sdb'}",
            "            ]}",
            "        )",
            "        self.assertEqual({'graphics_listen_addrs': {'spice': '127.0.0.1',",
            "                                                    'vnc': '127.0.0.1'},",
            "                          'target_connect_addr': None,",
            "                          'serial_listen_addr': '127.0.0.1',",
            "                          'volume': {}}, res_data['pre_live_migration_result'])",
            "",
            "    def test_pre_live_migration_vol_backed_works_correctly_mocked(self):",
            "        # Creating testdata, using temp dir.",
            "        with utils.tempdir() as tmpdir:",
            "            self.flags(instances_path=tmpdir)",
            "            vol = {'block_device_mapping': [",
            "             {'connection_info': {'serial': '12345', u'data':",
            "             {'device_path':",
            "              u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.abc.12345.opst-lun-X'}},",
            "             'mount_device': '/dev/sda'},",
            "             {'connection_info': {'serial': '67890', u'data':",
            "             {'device_path':",
            "             u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z'}},",
            "             'mount_device': '/dev/sdb'}]}",
            "",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "            def fake_none(*args, **kwargs):",
            "                return",
            "",
            "            self.stubs.Set(drvr, '_create_images_and_backing', fake_none)",
            "",
            "            class FakeNetworkInfo(object):",
            "                def fixed_ips(self):",
            "                    return [\"test_ip_addr\"]",
            "            inst_ref = objects.Instance(**self.test_instance)",
            "            c = context.get_admin_context()",
            "            nw_info = FakeNetworkInfo()",
            "            # Creating mocks",
            "            self.mox.StubOutWithMock(drvr, \"_connect_volume\")",
            "            for v in vol['block_device_mapping']:",
            "                disk_info = {",
            "                    'bus': \"scsi\",",
            "                    'dev': v['mount_device'].rpartition(\"/\")[2],",
            "                    'type': \"disk\"",
            "                    }",
            "                drvr._connect_volume(v['connection_info'],",
            "                                     disk_info)",
            "            self.mox.StubOutWithMock(drvr, 'plug_vifs')",
            "            drvr.plug_vifs(mox.IsA(inst_ref), nw_info)",
            "            self.mox.ReplayAll()",
            "            migrate_data = {'is_shared_instance_path': False,",
            "                            'is_shared_block_storage': False,",
            "                            'is_volume_backed': True,",
            "                            'block_migration': False,",
            "                            'instance_relative_path': inst_ref['name'],",
            "                            'disk_over_commit': False,",
            "                            'disk_available_mb': 123,",
            "                            'image_type': 'qcow2',",
            "                            'filename': 'foo',",
            "                        }",
            "            ret = drvr.pre_live_migration(c, inst_ref, vol, nw_info, None,",
            "                                          migrate_data)",
            "            target_ret = {",
            "            'graphics_listen_addrs': {'spice': '127.0.0.1',",
            "                                      'vnc': '127.0.0.1'},",
            "            'target_connect_addr': None,",
            "            'serial_listen_addr': '127.0.0.1',",
            "            'volume': {",
            "            '12345': {'connection_info': {u'data': {'device_path':",
            "              u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.abc.12345.opst-lun-X'},",
            "                      'serial': '12345'},",
            "                      'disk_info': {'bus': 'scsi',",
            "                                    'dev': 'sda',",
            "                                    'type': 'disk'}},",
            "            '67890': {'connection_info': {u'data': {'device_path':",
            "              u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z'},",
            "                      'serial': '67890'},",
            "                      'disk_info': {'bus': 'scsi',",
            "                                    'dev': 'sdb',",
            "                                    'type': 'disk'}}}}",
            "            self.assertEqual(",
            "                ret.to_legacy_dict(True)['pre_live_migration_result'],",
            "                target_ret)",
            "            self.assertTrue(os.path.exists('%s/%s/' % (tmpdir,",
            "                                                       inst_ref['name'])))",
            "",
            "    def test_pre_live_migration_plug_vifs_retry_fails(self):",
            "        self.flags(live_migration_retry_count=3)",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        def fake_plug_vifs(instance, network_info):",
            "            raise processutils.ProcessExecutionError()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr, 'plug_vifs', fake_plug_vifs)",
            "        self.stubs.Set(eventlet.greenthread, 'sleep',",
            "                       lambda x: eventlet.sleep(0))",
            "        disk_info_json = jsonutils.dumps({})",
            "        self.assertRaises(processutils.ProcessExecutionError,",
            "                          drvr.pre_live_migration,",
            "                          self.context, instance, block_device_info=None,",
            "                          network_info=[], disk_info=disk_info_json)",
            "",
            "    def test_pre_live_migration_plug_vifs_retry_works(self):",
            "        self.flags(live_migration_retry_count=3)",
            "        called = {'count': 0}",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        def fake_plug_vifs(instance, network_info):",
            "            called['count'] += 1",
            "            if called['count'] < CONF.live_migration_retry_count:",
            "                raise processutils.ProcessExecutionError()",
            "            else:",
            "                return",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr, 'plug_vifs', fake_plug_vifs)",
            "        self.stubs.Set(eventlet.greenthread, 'sleep',",
            "                       lambda x: eventlet.sleep(0))",
            "        disk_info_json = jsonutils.dumps({})",
            "        drvr.pre_live_migration(self.context, instance, block_device_info=None,",
            "                                network_info=[], disk_info=disk_info_json)",
            "",
            "    def test_pre_live_migration_image_not_created_with_shared_storage(self):",
            "        migrate_data_set = [{'is_shared_block_storage': False,",
            "                             'is_shared_instance_path': True,",
            "                             'is_volume_backed': False,",
            "                             'filename': 'foo',",
            "                             'instance_relative_path': 'bar',",
            "                             'disk_over_commit': False,",
            "                             'disk_available_mb': 123,",
            "                             'image_type': 'qcow2',",
            "                             'block_migration': False},",
            "                            {'is_shared_block_storage': True,",
            "                             'is_shared_instance_path': True,",
            "                             'is_volume_backed': False,",
            "                             'filename': 'foo',",
            "                             'instance_relative_path': 'bar',",
            "                             'disk_over_commit': False,",
            "                             'disk_available_mb': 123,",
            "                             'image_type': 'qcow2',",
            "                             'block_migration': False},",
            "                            {'is_shared_block_storage': False,",
            "                             'is_shared_instance_path': True,",
            "                             'is_volume_backed': False,",
            "                             'filename': 'foo',",
            "                             'instance_relative_path': 'bar',",
            "                             'disk_over_commit': False,",
            "                             'disk_available_mb': 123,",
            "                             'image_type': 'qcow2',",
            "                             'block_migration': True}]",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        # creating mocks",
            "        with test.nested(",
            "            mock.patch.object(drvr,",
            "                              '_create_images_and_backing'),",
            "            mock.patch.object(drvr,",
            "                              'ensure_filtering_rules_for_instance'),",
            "            mock.patch.object(drvr, 'plug_vifs'),",
            "        ) as (",
            "            create_image_mock,",
            "            rules_mock,",
            "            plug_mock,",
            "        ):",
            "            disk_info_json = jsonutils.dumps({})",
            "            for migrate_data in migrate_data_set:",
            "                res = drvr.pre_live_migration(self.context, instance,",
            "                                              block_device_info=None,",
            "                                              network_info=[],",
            "                                              disk_info=disk_info_json,",
            "                                              migrate_data=migrate_data)",
            "                self.assertFalse(create_image_mock.called)",
            "                self.assertIsInstance(res,",
            "                                      objects.LibvirtLiveMigrateData)",
            "",
            "    def test_pre_live_migration_with_not_shared_instance_path(self):",
            "        migrate_data = {'is_shared_block_storage': False,",
            "                        'is_shared_instance_path': False,",
            "                        'block_migration': False,",
            "                        'instance_relative_path': 'foo'}",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        def check_instance_dir(context, instance,",
            "                               instance_dir, disk_info,",
            "                               fallback_from_host=False):",
            "            self.assertTrue(instance_dir)",
            "        # creating mocks",
            "        with test.nested(",
            "            mock.patch.object(drvr,",
            "                              '_create_images_and_backing',",
            "                              side_effect=check_instance_dir),",
            "            mock.patch.object(drvr,",
            "                              'ensure_filtering_rules_for_instance'),",
            "            mock.patch.object(drvr, 'plug_vifs'),",
            "        ) as (",
            "            create_image_mock,",
            "            rules_mock,",
            "            plug_mock,",
            "        ):",
            "            disk_info_json = jsonutils.dumps({})",
            "            res = drvr.pre_live_migration(self.context, instance,",
            "                                          block_device_info=None,",
            "                                          network_info=[],",
            "                                          disk_info=disk_info_json,",
            "                                          migrate_data=migrate_data)",
            "            create_image_mock.assert_has_calls(",
            "                [mock.call(self.context, instance, mock.ANY, {},",
            "                           fallback_from_host=instance.host)])",
            "            self.assertIsInstance(res, objects.LibvirtLiveMigrateData)",
            "",
            "    def test_get_instance_disk_info_works_correctly(self):",
            "        # Test data",
            "        instance = objects.Instance(**self.test_instance)",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices>\"",
            "                    \"<disk type='file'><driver name='qemu' type='raw'/>\"",
            "                    \"<source file='/test/disk'/>\"",
            "                    \"<target dev='vda' bus='virtio'/></disk>\"",
            "                    \"<disk type='file'><driver name='qemu' type='qcow2'/>\"",
            "                    \"<source file='/test/disk.local'/>\"",
            "                    \"<target dev='vdb' bus='virtio'/></disk>\"",
            "                    \"</devices></domain>\")",
            "",
            "        # Preparing mocks",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"XMLDesc\")",
            "        vdmock.XMLDesc(flags=0).AndReturn(dummyxml)",
            "",
            "        def fake_lookup(instance_name):",
            "            if instance_name == instance.name:",
            "                return vdmock",
            "        self.create_fake_libvirt_mock(lookupByName=fake_lookup)",
            "",
            "        fake_libvirt_utils.disk_sizes['/test/disk'] = 10 * units.Gi",
            "        fake_libvirt_utils.disk_sizes['/test/disk.local'] = 20 * units.Gi",
            "        fake_libvirt_utils.disk_backing_files['/test/disk.local'] = 'file'",
            "",
            "        self.mox.StubOutWithMock(os.path, \"getsize\")",
            "        os.path.getsize('/test/disk').AndReturn((10737418240))",
            "        os.path.getsize('/test/disk.local').AndReturn((3328599655))",
            "",
            "        ret = (\"image: /test/disk\\n\"",
            "               \"file format: raw\\n\"",
            "               \"virtual size: 20G (21474836480 bytes)\\n\"",
            "               \"disk size: 3.1G\\n\"",
            "               \"cluster_size: 2097152\\n\"",
            "               \"backing file: /test/dummy (actual path: /backing/file)\\n\")",
            "",
            "        self.mox.StubOutWithMock(os.path, \"exists\")",
            "        os.path.exists('/test/disk.local').AndReturn(True)",
            "",
            "        self.mox.StubOutWithMock(utils, \"execute\")",
            "        utils.execute('env', 'LC_ALL=C', 'LANG=C', 'qemu-img', 'info',",
            "                      '/test/disk.local').AndReturn((ret, ''))",
            "",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        info = drvr.get_instance_disk_info(instance)",
            "        info = jsonutils.loads(info)",
            "        self.assertEqual(info[0]['type'], 'raw')",
            "        self.assertEqual(info[0]['path'], '/test/disk')",
            "        self.assertEqual(info[0]['disk_size'], 10737418240)",
            "        self.assertEqual(info[0]['backing_file'], \"\")",
            "        self.assertEqual(info[0]['over_committed_disk_size'], 0)",
            "        self.assertEqual(info[1]['type'], 'qcow2')",
            "        self.assertEqual(info[1]['path'], '/test/disk.local')",
            "        self.assertEqual(info[1]['virt_disk_size'], 21474836480)",
            "        self.assertEqual(info[1]['backing_file'], \"file\")",
            "        self.assertEqual(info[1]['over_committed_disk_size'], 18146236825)",
            "",
            "    def test_post_live_migration(self):",
            "        vol = {'block_device_mapping': [",
            "                  {'connection_info': {",
            "                       'data': {'multipath_id': 'dummy1'},",
            "                       'serial': 'fake_serial1'},",
            "                    'mount_device': '/dev/sda',",
            "                   },",
            "                  {'connection_info': {",
            "                       'data': {},",
            "                       'serial': 'fake_serial2'},",
            "                    'mount_device': '/dev/sdb', }]}",
            "",
            "        def fake_initialize_connection(context, volume_id, connector):",
            "            return {'data': {}}",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        fake_connector = {'host': 'fake'}",
            "        inst_ref = {'id': 'foo'}",
            "        cntx = context.get_admin_context()",
            "",
            "        # Set up the mock expectations",
            "        with test.nested(",
            "            mock.patch.object(driver, 'block_device_info_get_mapping',",
            "                              return_value=vol['block_device_mapping']),",
            "            mock.patch.object(drvr, \"get_volume_connector\",",
            "                              return_value=fake_connector),",
            "            mock.patch.object(drvr._volume_api, \"initialize_connection\",",
            "                              side_effect=fake_initialize_connection),",
            "            mock.patch.object(drvr, '_disconnect_volume')",
            "        ) as (block_device_info_get_mapping, get_volume_connector,",
            "              initialize_connection, _disconnect_volume):",
            "            drvr.post_live_migration(cntx, inst_ref, vol)",
            "",
            "            block_device_info_get_mapping.assert_has_calls([",
            "                mock.call(vol)])",
            "            get_volume_connector.assert_has_calls([",
            "                mock.call(inst_ref)])",
            "            _disconnect_volume.assert_has_calls([",
            "                mock.call({'data': {'multipath_id': 'dummy1'}}, 'sda'),",
            "                mock.call({'data': {}}, 'sdb')])",
            "",
            "    def test_get_instance_disk_info_excludes_volumes(self):",
            "        # Test data",
            "        instance = objects.Instance(**self.test_instance)",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices>\"",
            "                    \"<disk type='file'><driver name='qemu' type='raw'/>\"",
            "                    \"<source file='/test/disk'/>\"",
            "                    \"<target dev='vda' bus='virtio'/></disk>\"",
            "                    \"<disk type='file'><driver name='qemu' type='qcow2'/>\"",
            "                    \"<source file='/test/disk.local'/>\"",
            "                    \"<target dev='vdb' bus='virtio'/></disk>\"",
            "                    \"<disk type='file'><driver name='qemu' type='qcow2'/>\"",
            "                    \"<source file='/fake/path/to/volume1'/>\"",
            "                    \"<target dev='vdc' bus='virtio'/></disk>\"",
            "                    \"<disk type='file'><driver name='qemu' type='qcow2'/>\"",
            "                    \"<source file='/fake/path/to/volume2'/>\"",
            "                    \"<target dev='vdd' bus='virtio'/></disk>\"",
            "                    \"</devices></domain>\")",
            "",
            "        # Preparing mocks",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"XMLDesc\")",
            "        vdmock.XMLDesc(flags=0).AndReturn(dummyxml)",
            "",
            "        def fake_lookup(instance_name):",
            "            if instance_name == instance.name:",
            "                return vdmock",
            "        self.create_fake_libvirt_mock(lookupByName=fake_lookup)",
            "",
            "        fake_libvirt_utils.disk_sizes['/test/disk'] = 10 * units.Gi",
            "        fake_libvirt_utils.disk_sizes['/test/disk.local'] = 20 * units.Gi",
            "        fake_libvirt_utils.disk_backing_files['/test/disk.local'] = 'file'",
            "",
            "        self.mox.StubOutWithMock(os.path, \"getsize\")",
            "        os.path.getsize('/test/disk').AndReturn((10737418240))",
            "        os.path.getsize('/test/disk.local').AndReturn((3328599655))",
            "",
            "        ret = (\"image: /test/disk\\n\"",
            "               \"file format: raw\\n\"",
            "               \"virtual size: 20G (21474836480 bytes)\\n\"",
            "               \"disk size: 3.1G\\n\"",
            "               \"cluster_size: 2097152\\n\"",
            "               \"backing file: /test/dummy (actual path: /backing/file)\\n\")",
            "",
            "        self.mox.StubOutWithMock(os.path, \"exists\")",
            "        os.path.exists('/test/disk.local').AndReturn(True)",
            "",
            "        self.mox.StubOutWithMock(utils, \"execute\")",
            "        utils.execute('env', 'LC_ALL=C', 'LANG=C', 'qemu-img', 'info',",
            "                      '/test/disk.local').AndReturn((ret, ''))",
            "",
            "        self.mox.ReplayAll()",
            "        conn_info = {'driver_volume_type': 'fake'}",
            "        info = {'block_device_mapping': [",
            "                  {'connection_info': conn_info, 'mount_device': '/dev/vdc'},",
            "                  {'connection_info': conn_info, 'mount_device': '/dev/vdd'}]}",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        info = drvr.get_instance_disk_info(instance,",
            "                                           block_device_info=info)",
            "        info = jsonutils.loads(info)",
            "        self.assertEqual(info[0]['type'], 'raw')",
            "        self.assertEqual(info[0]['path'], '/test/disk')",
            "        self.assertEqual(info[0]['disk_size'], 10737418240)",
            "        self.assertEqual(info[0]['backing_file'], \"\")",
            "        self.assertEqual(info[0]['over_committed_disk_size'], 0)",
            "        self.assertEqual(info[1]['type'], 'qcow2')",
            "        self.assertEqual(info[1]['path'], '/test/disk.local')",
            "        self.assertEqual(info[1]['virt_disk_size'], 21474836480)",
            "        self.assertEqual(info[1]['backing_file'], \"file\")",
            "        self.assertEqual(info[1]['over_committed_disk_size'], 18146236825)",
            "",
            "    def test_get_instance_disk_info_no_bdinfo_passed(self):",
            "        # NOTE(ndipanov): _get_disk_overcomitted_size_total calls this method",
            "        # without access to Nova's block device information. We want to make",
            "        # sure that we guess volumes mostly correctly in that case as well",
            "        instance = objects.Instance(**self.test_instance)",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices>\"",
            "                    \"<disk type='file'><driver name='qemu' type='raw'/>\"",
            "                    \"<source file='/test/disk'/>\"",
            "                    \"<target dev='vda' bus='virtio'/></disk>\"",
            "                    \"<disk type='block'><driver name='qemu' type='raw'/>\"",
            "                    \"<source file='/fake/path/to/volume1'/>\"",
            "                    \"<target dev='vdb' bus='virtio'/></disk>\"",
            "                    \"</devices></domain>\")",
            "",
            "        # Preparing mocks",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"XMLDesc\")",
            "        vdmock.XMLDesc(flags=0).AndReturn(dummyxml)",
            "",
            "        def fake_lookup(instance_name):",
            "            if instance_name == instance.name:",
            "                return vdmock",
            "        self.create_fake_libvirt_mock(lookupByName=fake_lookup)",
            "",
            "        fake_libvirt_utils.disk_sizes['/test/disk'] = 10 * units.Gi",
            "",
            "        self.mox.StubOutWithMock(os.path, \"getsize\")",
            "        os.path.getsize('/test/disk').AndReturn((10737418240))",
            "",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        info = drvr.get_instance_disk_info(instance)",
            "",
            "        info = jsonutils.loads(info)",
            "        self.assertEqual(1, len(info))",
            "        self.assertEqual(info[0]['type'], 'raw')",
            "        self.assertEqual(info[0]['path'], '/test/disk')",
            "        self.assertEqual(info[0]['disk_size'], 10737418240)",
            "        self.assertEqual(info[0]['backing_file'], \"\")",
            "        self.assertEqual(info[0]['over_committed_disk_size'], 0)",
            "",
            "    def test_spawn_with_network_info(self):",
            "        # Preparing mocks",
            "        def fake_none(*args, **kwargs):",
            "            return",
            "",
            "        def fake_getLibVersion():",
            "            return fakelibvirt.FAKE_LIBVIRT_VERSION",
            "",
            "        def fake_getCapabilities():",
            "            return \"\"\"",
            "            <capabilities>",
            "                <host>",
            "                    <uuid>cef19ce0-0ca2-11df-855d-b19fbce37686</uuid>",
            "                    <cpu>",
            "                      <arch>x86_64</arch>",
            "                      <model>Penryn</model>",
            "                      <vendor>Intel</vendor>",
            "                      <topology sockets='1' cores='2' threads='1'/>",
            "                      <feature name='xtpr'/>",
            "                    </cpu>",
            "                </host>",
            "            </capabilities>",
            "            \"\"\"",
            "",
            "        def fake_baselineCPU(cpu, flag):",
            "            return \"\"\"<cpu mode='custom' match='exact'>",
            "                        <model fallback='allow'>Penryn</model>",
            "                        <vendor>Intel</vendor>",
            "                        <feature policy='require' name='xtpr'/>",
            "                      </cpu>",
            "                   \"\"\"",
            "",
            "        # _fake_network_info must be called before create_fake_libvirt_mock(),",
            "        # as _fake_network_info calls importutils.import_class() and",
            "        # create_fake_libvirt_mock() mocks importutils.import_class().",
            "        network_info = _fake_network_info(self, 1)",
            "        self.create_fake_libvirt_mock(getLibVersion=fake_getLibVersion,",
            "                                      getCapabilities=fake_getCapabilities,",
            "                                      getVersion=lambda: 1005001,",
            "                                      baselineCPU=fake_baselineCPU)",
            "",
            "        instance_ref = self.test_instance",
            "        instance_ref['image_ref'] = 123456  # we send an int to test sha1 call",
            "        instance = objects.Instance(**instance_ref)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        # Mock out the get_info method of the LibvirtDriver so that the polling",
            "        # in the spawn method of the LibvirtDriver returns immediately",
            "        self.mox.StubOutWithMock(libvirt_driver.LibvirtDriver, 'get_info')",
            "        libvirt_driver.LibvirtDriver.get_info(instance",
            "            ).AndReturn(hardware.InstanceInfo(state=power_state.RUNNING))",
            "",
            "        # Start test",
            "        self.mox.ReplayAll()",
            "",
            "        with mock.patch('nova.virt.libvirt.driver.libvirt') as old_virt:",
            "            del old_virt.VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES",
            "",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "            self.stubs.Set(drvr.firewall_driver,",
            "                        'setup_basic_filtering',",
            "                        fake_none)",
            "            self.stubs.Set(drvr.firewall_driver,",
            "                        'prepare_instance_filter',",
            "                        fake_none)",
            "            self.stubs.Set(imagebackend.Image,",
            "                        'cache',",
            "                        fake_none)",
            "",
            "            drvr.spawn(self.context, instance, image_meta, [], 'herp',",
            "                        network_info=network_info)",
            "",
            "        path = os.path.join(CONF.instances_path, instance['name'])",
            "        if os.path.isdir(path):",
            "            shutil.rmtree(path)",
            "",
            "        path = os.path.join(CONF.instances_path,",
            "                            CONF.image_cache_subdirectory_name)",
            "        if os.path.isdir(path):",
            "            shutil.rmtree(os.path.join(CONF.instances_path,",
            "                                       CONF.image_cache_subdirectory_name))",
            "",
            "    def test_spawn_without_image_meta(self):",
            "        self.create_image_called = False",
            "",
            "        def fake_none(*args, **kwargs):",
            "            return",
            "",
            "        def fake_create_image(*args, **kwargs):",
            "            self.create_image_called = True",
            "",
            "        def fake_get_info(instance):",
            "            return hardware.InstanceInfo(state=power_state.RUNNING)",
            "",
            "        instance_ref = self.test_instance",
            "        instance_ref['image_ref'] = 1",
            "        instance = objects.Instance(**instance_ref)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr, '_get_guest_xml', fake_none)",
            "        self.stubs.Set(drvr, '_create_image', fake_create_image)",
            "        self.stubs.Set(drvr, '_create_domain_and_network', fake_none)",
            "        self.stubs.Set(drvr, 'get_info', fake_get_info)",
            "",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        drvr.spawn(self.context, instance,",
            "                   image_meta, [], None)",
            "        self.assertTrue(self.create_image_called)",
            "",
            "        drvr.spawn(self.context, instance,",
            "                   image_meta, [], None)",
            "        self.assertTrue(self.create_image_called)",
            "",
            "    def test_spawn_from_volume_calls_cache(self):",
            "        self.cache_called_for_disk = False",
            "",
            "        def fake_none(*args, **kwargs):",
            "            return",
            "",
            "        def fake_cache(*args, **kwargs):",
            "            if kwargs.get('image_id') == 'my_fake_image':",
            "                self.cache_called_for_disk = True",
            "",
            "        def fake_get_info(instance):",
            "            return hardware.InstanceInfo(state=power_state.RUNNING)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr, '_get_guest_xml', fake_none)",
            "",
            "        self.stubs.Set(imagebackend.Image, 'cache', fake_cache)",
            "        self.stubs.Set(drvr, '_create_domain_and_network', fake_none)",
            "        self.stubs.Set(drvr, 'get_info', fake_get_info)",
            "",
            "        block_device_info = {'root_device_name': '/dev/vda',",
            "                             'block_device_mapping': [",
            "                                {'mount_device': 'vda',",
            "                                 'boot_index': 0}",
            "                                ]",
            "                            }",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        # Volume-backed instance created without image",
            "        instance_ref = self.test_instance",
            "        instance_ref['image_ref'] = ''",
            "        instance_ref['root_device_name'] = '/dev/vda'",
            "        instance_ref['uuid'] = uuidutils.generate_uuid()",
            "        instance = objects.Instance(**instance_ref)",
            "",
            "        drvr.spawn(self.context, instance,",
            "                   image_meta, [], None,",
            "                   block_device_info=block_device_info)",
            "        self.assertFalse(self.cache_called_for_disk)",
            "",
            "        # Booted from volume but with placeholder image",
            "        instance_ref = self.test_instance",
            "        instance_ref['image_ref'] = 'my_fake_image'",
            "        instance_ref['root_device_name'] = '/dev/vda'",
            "        instance_ref['uuid'] = uuidutils.generate_uuid()",
            "        instance = objects.Instance(**instance_ref)",
            "",
            "        drvr.spawn(self.context, instance,",
            "                   image_meta, [], None,",
            "                   block_device_info=block_device_info)",
            "        self.assertFalse(self.cache_called_for_disk)",
            "",
            "        # Booted from an image",
            "        instance_ref['image_ref'] = 'my_fake_image'",
            "        instance_ref['uuid'] = uuidutils.generate_uuid()",
            "        instance = objects.Instance(**instance_ref)",
            "        drvr.spawn(self.context, instance,",
            "                   image_meta, [], None)",
            "        self.assertTrue(self.cache_called_for_disk)",
            "",
            "    def test_start_lxc_from_volume(self):",
            "        self.flags(virt_type=\"lxc\",",
            "                   group='libvirt')",
            "",
            "        def check_setup_container(image, container_dir=None):",
            "            self.assertIsInstance(image, imgmodel.LocalBlockImage)",
            "            self.assertEqual(image.path, '/dev/path/to/dev')",
            "            return '/dev/nbd1'",
            "",
            "        bdm = {",
            "                  'guest_format': None,",
            "                  'boot_index': 0,",
            "                  'mount_device': '/dev/sda',",
            "                  'connection_info': {",
            "                      'driver_volume_type': 'iscsi',",
            "                      'serial': 'afc1',",
            "                      'data': {",
            "                          'access_mode': 'rw',",
            "                          'target_discovered': False,",
            "                          'encrypted': False,",
            "                          'qos_specs': None,",
            "                          'target_iqn': 'iqn: volume-afc1',",
            "                          'target_portal': 'ip: 3260',",
            "                          'volume_id': 'afc1',",
            "                          'target_lun': 1,",
            "                          'auth_password': 'uj',",
            "                          'auth_username': '47',",
            "                          'auth_method': 'CHAP'",
            "                      }",
            "                  },",
            "                  'disk_bus': 'scsi',",
            "                  'device_type': 'disk',",
            "                  'delete_on_termination': False",
            "              }",
            "",
            "        def _connect_volume_side_effect(connection_info, disk_info):",
            "            bdm['connection_info']['data']['device_path'] = '/dev/path/to/dev'",
            "",
            "        def _get(key, opt=None):",
            "            return bdm.get(key, opt)",
            "",
            "        def getitem(key):",
            "            return bdm[key]",
            "",
            "        def setitem(key, val):",
            "            bdm[key] = val",
            "",
            "        bdm_mock = mock.MagicMock()",
            "        bdm_mock.__getitem__.side_effect = getitem",
            "        bdm_mock.__setitem__.side_effect = setitem",
            "        bdm_mock.get = _get",
            "",
            "        disk_mock = mock.MagicMock()",
            "        disk_mock.source_path = '/dev/path/to/dev'",
            "",
            "        block_device_info = {'block_device_mapping': [bdm_mock],",
            "                             'root_device_name': '/dev/sda'}",
            "",
            "        # Volume-backed instance created without image",
            "        instance_ref = self.test_instance",
            "        instance_ref['image_ref'] = ''",
            "        instance_ref['root_device_name'] = '/dev/sda'",
            "        instance_ref['ephemeral_gb'] = 0",
            "        instance_ref['uuid'] = uuidutils.generate_uuid()",
            "        inst_obj = objects.Instance(**instance_ref)",
            "        image_meta = objects.ImageMeta.from_dict({})",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        with test.nested(",
            "            mock.patch.object(drvr, '_create_images_and_backing'),",
            "            mock.patch.object(drvr, 'plug_vifs'),",
            "            mock.patch.object(drvr.firewall_driver, 'setup_basic_filtering'),",
            "            mock.patch.object(drvr.firewall_driver, 'prepare_instance_filter'),",
            "            mock.patch.object(drvr.firewall_driver, 'apply_instance_filter'),",
            "            mock.patch.object(drvr, '_create_domain'),",
            "            mock.patch.object(drvr, '_connect_volume',",
            "                              side_effect=_connect_volume_side_effect),",
            "            mock.patch.object(drvr, '_get_volume_config',",
            "                                     return_value=disk_mock),",
            "            mock.patch.object(drvr, 'get_info',",
            "                              return_value=hardware.InstanceInfo(",
            "                              state=power_state.RUNNING)),",
            "            mock.patch('nova.virt.disk.api.setup_container',",
            "                       side_effect=check_setup_container),",
            "            mock.patch('nova.virt.disk.api.teardown_container'),",
            "            mock.patch.object(objects.Instance, 'save')):",
            "",
            "            drvr.spawn(self.context, inst_obj, image_meta, [], None,",
            "                       network_info=[],",
            "                       block_device_info=block_device_info)",
            "            self.assertEqual('/dev/nbd1',",
            "                             inst_obj.system_metadata.get(",
            "                             'rootfs_device_name'))",
            "",
            "    def test_spawn_with_pci_devices(self):",
            "        def fake_none(*args, **kwargs):",
            "            return None",
            "",
            "        def fake_get_info(instance):",
            "            return hardware.InstanceInfo(state=power_state.RUNNING)",
            "",
            "        class FakeLibvirtPciDevice(object):",
            "            def dettach(self):",
            "                return None",
            "",
            "            def reset(self):",
            "                return None",
            "",
            "        def fake_node_device_lookup_by_name(address):",
            "            pattern = (\"pci_%(hex)s{4}_%(hex)s{2}_%(hex)s{2}_%(oct)s{1}\"",
            "                       % dict(hex='[\\da-f]', oct='[0-8]'))",
            "            pattern = re.compile(pattern)",
            "            if pattern.match(address) is None:",
            "                raise fakelibvirt.libvirtError()",
            "            return FakeLibvirtPciDevice()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr, '_get_guest_xml', fake_none)",
            "        self.stubs.Set(drvr, '_create_image', fake_none)",
            "        self.stubs.Set(drvr, '_create_domain_and_network', fake_none)",
            "        self.stubs.Set(drvr, 'get_info', fake_get_info)",
            "",
            "        drvr._conn.nodeDeviceLookupByName = \\",
            "                    fake_node_device_lookup_by_name",
            "",
            "        instance_ref = self.test_instance",
            "        instance_ref['image_ref'] = 'my_fake_image'",
            "        instance = objects.Instance(**instance_ref)",
            "        instance['pci_devices'] = objects.PciDeviceList(",
            "            objects=[objects.PciDevice(address='0000:00:00.0')])",
            "",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        drvr.spawn(self.context, instance,",
            "                   image_meta, [], None)",
            "",
            "    def test_chown_disk_config_for_instance(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        self.mox.StubOutWithMock(fake_libvirt_utils, 'get_instance_path')",
            "        self.mox.StubOutWithMock(os.path, 'exists')",
            "        self.mox.StubOutWithMock(fake_libvirt_utils, 'chown')",
            "        fake_libvirt_utils.get_instance_path(instance).AndReturn('/tmp/uuid')",
            "        os.path.exists('/tmp/uuid/disk.config').AndReturn(True)",
            "        fake_libvirt_utils.chown('/tmp/uuid/disk.config', os.getuid())",
            "",
            "        self.mox.ReplayAll()",
            "        drvr._chown_disk_config_for_instance(instance)",
            "",
            "    def _test_create_image_plain(self, os_type='', filename='', mkfs=False):",
            "        gotFiles = []",
            "",
            "        def fake_image(self, instance, name, image_type=''):",
            "            class FakeImage(imagebackend.Image):",
            "                def __init__(self, instance, name, is_block_dev=False):",
            "                    self.path = os.path.join(instance['name'], name)",
            "                    self.is_block_dev = is_block_dev",
            "",
            "                def create_image(self, prepare_template, base,",
            "                                 size, *args, **kwargs):",
            "                    pass",
            "",
            "                def resize_image(self, size):",
            "                    pass",
            "",
            "                def cache(self, fetch_func, filename, size=None,",
            "                          *args, **kwargs):",
            "                    gotFiles.append({'filename': filename,",
            "                                     'size': size})",
            "",
            "                def snapshot(self, name):",
            "                    pass",
            "",
            "            return FakeImage(instance, name)",
            "",
            "        def fake_none(*args, **kwargs):",
            "            return",
            "",
            "        def fake_get_info(instance):",
            "            return hardware.InstanceInfo(state=power_state.RUNNING)",
            "",
            "        # Stop 'libvirt_driver._create_image' touching filesystem",
            "        self.stubs.Set(nova.virt.libvirt.imagebackend.Backend, \"image\",",
            "                       fake_image)",
            "",
            "        instance_ref = self.test_instance",
            "        instance_ref['image_ref'] = 1",
            "        instance = objects.Instance(**instance_ref)",
            "        instance['os_type'] = os_type",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr, '_get_guest_xml', fake_none)",
            "        self.stubs.Set(drvr, '_create_domain_and_network', fake_none)",
            "        self.stubs.Set(drvr, 'get_info', fake_get_info)",
            "        if mkfs:",
            "            self.stubs.Set(nova.virt.disk.api, '_MKFS_COMMAND',",
            "                       {os_type: 'mkfs.ext4 --label %(fs_label)s %(target)s'})",
            "",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta)",
            "        drvr._create_image(context, instance, disk_info['mapping'])",
            "        drvr._get_guest_xml(self.context, instance, None,",
            "                            disk_info, image_meta)",
            "",
            "        wantFiles = [",
            "            {'filename': '356a192b7913b04c54574d18c28d46e6395428ab',",
            "             'size': 10 * units.Gi},",
            "            {'filename': filename,",
            "             'size': 20 * units.Gi},",
            "            ]",
            "        self.assertEqual(gotFiles, wantFiles)",
            "",
            "    def test_create_image_plain_os_type_blank(self):",
            "        self._test_create_image_plain(os_type='',",
            "                                      filename=self._EPHEMERAL_20_DEFAULT,",
            "                                      mkfs=False)",
            "",
            "    def test_create_image_plain_os_type_none(self):",
            "        self._test_create_image_plain(os_type=None,",
            "                                      filename=self._EPHEMERAL_20_DEFAULT,",
            "                                      mkfs=False)",
            "",
            "    def test_create_image_plain_os_type_set_no_fs(self):",
            "        self._test_create_image_plain(os_type='test',",
            "                                      filename=self._EPHEMERAL_20_DEFAULT,",
            "                                      mkfs=False)",
            "",
            "    def test_create_image_plain_os_type_set_with_fs(self):",
            "        ephemeral_file_name = ('ephemeral_20_%s' % utils.get_hash_str(",
            "            'mkfs.ext4 --label %(fs_label)s %(target)s')[:7])",
            "",
            "        self._test_create_image_plain(os_type='test',",
            "                                      filename=ephemeral_file_name,",
            "                                      mkfs=True)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.imagecache')",
            "    def test_create_image_initrd(self, mock_imagecache):",
            "        INITRD = self._EPHEMERAL_20_DEFAULT + '.initrd'",
            "        KERNEL = 'vmlinuz.' + self._EPHEMERAL_20_DEFAULT",
            "",
            "        mock_imagecache.get_cache_fname.side_effect = \\",
            "                [KERNEL,",
            "                 INITRD,",
            "                 self._EPHEMERAL_20_DEFAULT + '.img']",
            "        filename = self._EPHEMERAL_20_DEFAULT",
            "",
            "        gotFiles = []",
            "",
            "        outer = self",
            "",
            "        def fake_image(self, instance, name, image_type=''):",
            "            class FakeImage(imagebackend.Image):",
            "                def __init__(self, instance, name, is_block_dev=False):",
            "                    self.path = os.path.join(instance['name'], name)",
            "                    self.is_block_dev = is_block_dev",
            "",
            "                def create_image(self, prepare_template, base,",
            "                                 size, *args, **kwargs):",
            "                    pass",
            "",
            "                def cache(self, fetch_func, filename, size=None,",
            "                          *args, **kwargs):",
            "                    gotFiles.append({'filename': filename,",
            "                                     'size': size})",
            "                    if filename == INITRD:",
            "                        outer.assertEqual(fetch_func,",
            "                                fake_libvirt_utils.fetch_raw_image)",
            "                    if filename == KERNEL:",
            "                        outer.assertEqual(fetch_func,",
            "                                fake_libvirt_utils.fetch_raw_image)",
            "",
            "                def resize_image(self, size):",
            "                    pass",
            "",
            "                def snapshot(self, name):",
            "                    pass",
            "",
            "            return FakeImage(instance, name)",
            "",
            "        instance_ref = self.test_instance",
            "        instance_ref['image_ref'] = 1",
            "        instance_ref['kernel_id'] = 2",
            "        instance_ref['ramdisk_id'] = 3",
            "        instance_ref['os_type'] = 'test'",
            "        instance = objects.Instance(**instance_ref)",
            "",
            "        driver = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        with test.nested(",
            "            mock.patch.object(nova.virt.libvirt.imagebackend.Backend,",
            "              \"image\", fake_image),",
            "            mock.patch.object(driver, '_get_guest_xml'),",
            "            mock.patch.object(driver, '_create_domain_and_network'),",
            "            mock.patch.object(driver, 'get_info',",
            "              return_value=[hardware.InstanceInfo(state=power_state.RUNNING)])",
            "            ):",
            "            image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "            disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                                instance,",
            "                                                image_meta)",
            "            driver._create_image(context, instance, disk_info['mapping'])",
            "",
            "        wantFiles = [",
            "            {'filename': KERNEL,",
            "             'size': None},",
            "            {'filename': INITRD,",
            "             'size': None},",
            "            {'filename': self._EPHEMERAL_20_DEFAULT + '.img',",
            "             'size': 10 * units.Gi},",
            "            {'filename': filename,",
            "             'size': 20 * units.Gi},",
            "            ]",
            "        self.assertEqual(wantFiles, gotFiles)",
            "",
            "    def _create_image_helper(self, callback, suffix=''):",
            "        gotFiles = []",
            "        imported_files = []",
            "",
            "        def fake_image(self, instance, name, image_type=''):",
            "            class FakeImage(imagebackend.Image):",
            "                def __init__(self, instance, name, is_block_dev=False):",
            "                    self.path = os.path.join(instance['name'], name)",
            "                    self.is_block_dev = is_block_dev",
            "",
            "                def create_image(self, prepare_template, base,",
            "                                 size, *args, **kwargs):",
            "                    pass",
            "",
            "                def resize_image(self, size):",
            "                    pass",
            "",
            "                def cache(self, fetch_func, filename, size=None,",
            "                          *args, **kwargs):",
            "                    gotFiles.append({'filename': filename,",
            "                                     'size': size})",
            "",
            "                def import_file(self, instance, local_filename,",
            "                                remote_filename):",
            "                    imported_files.append((local_filename, remote_filename))",
            "",
            "                def snapshot(self, name):",
            "                    pass",
            "",
            "            return FakeImage(instance, name)",
            "",
            "        def fake_none(*args, **kwargs):",
            "            return",
            "",
            "        def fake_get_info(instance):",
            "            return hardware.InstanceInfo(state=power_state.RUNNING)",
            "",
            "        # Stop 'libvirt_driver._create_image' touching filesystem",
            "        self.stubs.Set(nova.virt.libvirt.imagebackend.Backend, \"image\",",
            "                       fake_image)",
            "",
            "        instance_ref = self.test_instance",
            "        instance_ref['image_ref'] = 1",
            "        # NOTE(mikal): use this callback to tweak the instance to match",
            "        # what you're trying to test",
            "        callback(instance_ref)",
            "        instance = objects.Instance(**instance_ref)",
            "        # Turn on some swap to exercise that codepath in _create_image",
            "        instance.flavor.swap = 500",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr, '_get_guest_xml', fake_none)",
            "        self.stubs.Set(drvr, '_create_domain_and_network', fake_none)",
            "        self.stubs.Set(drvr, 'get_info', fake_get_info)",
            "        self.stubs.Set(instance_metadata, 'InstanceMetadata', fake_none)",
            "        self.stubs.Set(nova.virt.configdrive.ConfigDriveBuilder,",
            "                       'make_drive', fake_none)",
            "",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta)",
            "        drvr._create_image(context, instance, disk_info['mapping'],",
            "                           suffix=suffix)",
            "        drvr._get_guest_xml(self.context, instance, None,",
            "                            disk_info, image_meta)",
            "",
            "        return gotFiles, imported_files",
            "",
            "    def test_create_image_with_swap(self):",
            "        def enable_swap(instance_ref):",
            "            # Turn on some swap to exercise that codepath in _create_image",
            "            instance_ref['system_metadata']['instance_type_swap'] = 500",
            "",
            "        gotFiles, _ = self._create_image_helper(enable_swap)",
            "        wantFiles = [",
            "            {'filename': '356a192b7913b04c54574d18c28d46e6395428ab',",
            "             'size': 10 * units.Gi},",
            "            {'filename': self._EPHEMERAL_20_DEFAULT,",
            "             'size': 20 * units.Gi},",
            "            {'filename': 'swap_500',",
            "             'size': 500 * units.Mi},",
            "            ]",
            "        self.assertEqual(gotFiles, wantFiles)",
            "",
            "    def test_create_image_with_configdrive(self):",
            "        def enable_configdrive(instance_ref):",
            "            instance_ref['config_drive'] = 'true'",
            "",
            "        # Ensure that we create a config drive and then import it into the",
            "        # image backend store",
            "        _, imported_files = self._create_image_helper(enable_configdrive)",
            "        self.assertTrue(imported_files[0][0].endswith('/disk.config'))",
            "        self.assertEqual('disk.config', imported_files[0][1])",
            "",
            "    def test_create_image_with_configdrive_rescue(self):",
            "        def enable_configdrive(instance_ref):",
            "            instance_ref['config_drive'] = 'true'",
            "",
            "        # Ensure that we create a config drive and then import it into the",
            "        # image backend store",
            "        _, imported_files = self._create_image_helper(enable_configdrive,",
            "                                                      suffix='.rescue')",
            "        self.assertTrue(imported_files[0][0].endswith('/disk.config.rescue'))",
            "        self.assertEqual('disk.config.rescue', imported_files[0][1])",
            "",
            "    @mock.patch.object(nova.virt.libvirt.imagebackend.Image, 'cache',",
            "                       side_effect=exception.ImageNotFound(image_id='fake-id'))",
            "    def test_create_image_not_exist_no_fallback(self, mock_cache):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta)",
            "        self.assertRaises(exception.ImageNotFound,",
            "                          drvr._create_image,",
            "                          self.context, instance, disk_info['mapping'])",
            "",
            "    @mock.patch.object(nova.virt.libvirt.imagebackend.Image, 'cache')",
            "    def test_create_image_not_exist_fallback(self, mock_cache):",
            "",
            "        def side_effect(fetch_func, filename, size=None, *args, **kwargs):",
            "            def second_call(fetch_func, filename, size=None, *args, **kwargs):",
            "                # call copy_from_host ourselves because we mocked image.cache()",
            "                fetch_func('fake-target', 'fake-max-size')",
            "                # further calls have no side effect",
            "                mock_cache.side_effect = None",
            "            mock_cache.side_effect = second_call",
            "            # raise an error only the first call",
            "            raise exception.ImageNotFound(image_id='fake-id')",
            "",
            "        mock_cache.side_effect = side_effect",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta)",
            "",
            "        with mock.patch.object(libvirt_driver.libvirt_utils,",
            "                               'copy_image') as mock_copy:",
            "            drvr._create_image(self.context, instance, disk_info['mapping'],",
            "                               fallback_from_host='fake-source-host')",
            "            mock_copy.assert_called_once_with(src='fake-target',",
            "                                              dest='fake-target',",
            "                                              host='fake-source-host',",
            "                                              receive=True)",
            "",
            "    @mock.patch.object(nova.virt.libvirt.imagebackend.Image, 'cache')",
            "    def test_create_image_resize_snap_backend(self, mock_cache):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr.image_backend = mock.Mock()",
            "        drvr.image_backend.image.return_value = drvr.image_backend",
            "        instance = objects.Instance(**self.test_instance)",
            "        instance.task_state = task_states.RESIZE_FINISH",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta)",
            "        with mock.patch.object(drvr.image_backend, 'create_snap') as mock_crt:",
            "            drvr._create_image(self.context, instance, disk_info['mapping'])",
            "            mock_crt.assert_called_once_with(",
            "                    libvirt_utils.RESIZE_SNAPSHOT_NAME)",
            "",
            "    @mock.patch.object(utils, 'execute')",
            "    def test_create_ephemeral_specified_fs(self, mock_exec):",
            "        self.flags(default_ephemeral_format='ext3')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr._create_ephemeral('/dev/something', 20, 'myVol', 'linux',",
            "                               is_block_dev=True, max_size=20,",
            "                               specified_fs='ext4')",
            "        mock_exec.assert_called_once_with('mkfs', '-t', 'ext4', '-F', '-L',",
            "                                          'myVol', '/dev/something',",
            "                                          run_as_root=True)",
            "",
            "    def test_create_ephemeral_specified_fs_not_valid(self):",
            "        CONF.set_override('default_ephemeral_format', 'ext4')",
            "        ephemerals = [{'device_type': 'disk',",
            "                       'disk_bus': 'virtio',",
            "                       'device_name': '/dev/vdb',",
            "                       'guest_format': 'dummy',",
            "                       'size': 1}]",
            "        block_device_info = {",
            "                'ephemerals': ephemerals}",
            "        instance_ref = self.test_instance",
            "        instance_ref['image_ref'] = 1",
            "        instance = objects.Instance(**instance_ref)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        image_meta = objects.ImageMeta.from_dict({'disk_format': 'raw'})",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta)",
            "        disk_info['mapping'].pop('disk.local')",
            "",
            "        with test.nested(",
            "            mock.patch.object(utils, 'execute'),",
            "            mock.patch.object(drvr, 'get_info'),",
            "            mock.patch.object(drvr, '_create_domain_and_network'),",
            "            mock.patch.object(imagebackend.Image, 'verify_base_size'),",
            "            mock.patch.object(imagebackend.Image, 'get_disk_size')):",
            "            self.assertRaises(exception.InvalidBDMFormat, drvr._create_image,",
            "                              context, instance, disk_info['mapping'],",
            "                              block_device_info=block_device_info)",
            "",
            "    def test_create_ephemeral_default(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.mox.StubOutWithMock(utils, 'execute')",
            "        utils.execute('mkfs', '-t', 'ext4', '-F', '-L', 'myVol',",
            "                      '/dev/something', run_as_root=True)",
            "        self.mox.ReplayAll()",
            "        drvr._create_ephemeral('/dev/something', 20, 'myVol', 'linux',",
            "                               is_block_dev=True, max_size=20)",
            "",
            "    def test_create_ephemeral_with_conf(self):",
            "        CONF.set_override('default_ephemeral_format', 'ext4')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.mox.StubOutWithMock(utils, 'execute')",
            "        utils.execute('mkfs', '-t', 'ext4', '-F', '-L', 'myVol',",
            "                      '/dev/something', run_as_root=True)",
            "        self.mox.ReplayAll()",
            "        drvr._create_ephemeral('/dev/something', 20, 'myVol', 'linux',",
            "                               is_block_dev=True)",
            "",
            "    def test_create_ephemeral_with_arbitrary(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(nova.virt.disk.api, '_MKFS_COMMAND',",
            "                       {'linux': 'mkfs.ext4 --label %(fs_label)s %(target)s'})",
            "        self.mox.StubOutWithMock(utils, 'execute')",
            "        utils.execute('mkfs.ext4', '--label', 'myVol', '/dev/something',",
            "                      run_as_root=True)",
            "        self.mox.ReplayAll()",
            "        drvr._create_ephemeral('/dev/something', 20, 'myVol', 'linux',",
            "                               is_block_dev=True)",
            "",
            "    def test_create_ephemeral_with_ext3(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(nova.virt.disk.api, '_MKFS_COMMAND',",
            "                       {'linux': 'mkfs.ext3 --label %(fs_label)s %(target)s'})",
            "        self.mox.StubOutWithMock(utils, 'execute')",
            "        utils.execute('mkfs.ext3', '--label', 'myVol', '/dev/something',",
            "                      run_as_root=True)",
            "        self.mox.ReplayAll()",
            "        drvr._create_ephemeral('/dev/something', 20, 'myVol', 'linux',",
            "                               is_block_dev=True)",
            "",
            "    def test_create_swap_default(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.mox.StubOutWithMock(utils, 'execute')",
            "        utils.execute('mkswap', '/dev/something', run_as_root=False)",
            "        self.mox.ReplayAll()",
            "",
            "        drvr._create_swap('/dev/something', 1, max_size=20)",
            "",
            "    def test_get_console_output_file(self):",
            "        fake_libvirt_utils.files['console.log'] = '01234567890'",
            "",
            "        with utils.tempdir() as tmpdir:",
            "            self.flags(instances_path=tmpdir)",
            "",
            "            instance_ref = self.test_instance",
            "            instance_ref['image_ref'] = 123456",
            "            instance = objects.Instance(**instance_ref)",
            "",
            "            console_dir = (os.path.join(tmpdir, instance['name']))",
            "            console_log = '%s/console.log' % (console_dir)",
            "            fake_dom_xml = \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                        </disk>",
            "                        <console type='file'>",
            "                            <source path='%s'/>",
            "                            <target port='0'/>",
            "                        </console>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\" % console_log",
            "",
            "            def fake_lookup(id):",
            "                return FakeVirtDomain(fake_dom_xml)",
            "",
            "            self.create_fake_libvirt_mock()",
            "            libvirt_driver.LibvirtDriver._conn.lookupByName = fake_lookup",
            "",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "            try:",
            "                prev_max = libvirt_driver.MAX_CONSOLE_BYTES",
            "                libvirt_driver.MAX_CONSOLE_BYTES = 5",
            "                with mock.patch('os.path.exists', return_value=True):",
            "                    output = drvr.get_console_output(self.context, instance)",
            "            finally:",
            "                libvirt_driver.MAX_CONSOLE_BYTES = prev_max",
            "",
            "            self.assertEqual('67890', output)",
            "",
            "    def test_get_console_output_file_missing(self):",
            "        with utils.tempdir() as tmpdir:",
            "            self.flags(instances_path=tmpdir)",
            "",
            "            instance_ref = self.test_instance",
            "            instance_ref['image_ref'] = 123456",
            "            instance = objects.Instance(**instance_ref)",
            "",
            "            console_log = os.path.join(tmpdir, instance['name'],",
            "                                       'non-existent.log')",
            "            fake_dom_xml = \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                        </disk>",
            "                        <console type='file'>",
            "                            <source path='%s'/>",
            "                            <target port='0'/>",
            "                        </console>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\" % console_log",
            "",
            "            def fake_lookup(id):",
            "                return FakeVirtDomain(fake_dom_xml)",
            "",
            "            self.create_fake_libvirt_mock()",
            "            libvirt_driver.LibvirtDriver._conn.lookupByName = fake_lookup",
            "",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "            with mock.patch('os.path.exists', return_value=False):",
            "                output = drvr.get_console_output(self.context, instance)",
            "",
            "            self.assertEqual('', output)",
            "",
            "    def test_get_console_output_pty(self):",
            "        fake_libvirt_utils.files['pty'] = '01234567890'",
            "",
            "        with utils.tempdir() as tmpdir:",
            "            self.flags(instances_path=tmpdir)",
            "",
            "            instance_ref = self.test_instance",
            "            instance_ref['image_ref'] = 123456",
            "            instance = objects.Instance(**instance_ref)",
            "",
            "            console_dir = (os.path.join(tmpdir, instance['name']))",
            "            pty_file = '%s/fake_pty' % (console_dir)",
            "            fake_dom_xml = \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                        </disk>",
            "                        <console type='pty'>",
            "                            <source path='%s'/>",
            "                            <target port='0'/>",
            "                        </console>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\" % pty_file",
            "",
            "            def fake_lookup(id):",
            "                return FakeVirtDomain(fake_dom_xml)",
            "",
            "            def _fake_flush(self, fake_pty):",
            "                return 'foo'",
            "",
            "            def _fake_append_to_file(self, data, fpath):",
            "                return 'pty'",
            "",
            "            self.create_fake_libvirt_mock()",
            "            libvirt_driver.LibvirtDriver._conn.lookupByName = fake_lookup",
            "            libvirt_driver.LibvirtDriver._flush_libvirt_console = _fake_flush",
            "            libvirt_driver.LibvirtDriver._append_to_file = _fake_append_to_file",
            "",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "            try:",
            "                prev_max = libvirt_driver.MAX_CONSOLE_BYTES",
            "                libvirt_driver.MAX_CONSOLE_BYTES = 5",
            "                output = drvr.get_console_output(self.context, instance)",
            "            finally:",
            "                libvirt_driver.MAX_CONSOLE_BYTES = prev_max",
            "",
            "            self.assertEqual('67890', output)",
            "",
            "    def test_get_host_ip_addr(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        ip = drvr.get_host_ip_addr()",
            "        self.assertEqual(ip, CONF.my_ip)",
            "",
            "    @mock.patch.object(libvirt_driver.LOG, 'warn')",
            "    @mock.patch('nova.compute.utils.get_machine_ips')",
            "    def test_get_host_ip_addr_failure(self, mock_ips, mock_log):",
            "        mock_ips.return_value = ['8.8.8.8', '75.75.75.75']",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr.get_host_ip_addr()",
            "        mock_log.assert_called_once_with(u'my_ip address (%(my_ip)s) was '",
            "                                         u'not found on any of the '",
            "                                         u'interfaces: %(ifaces)s',",
            "                                         {'ifaces': '8.8.8.8, 75.75.75.75',",
            "                                          'my_ip': mock.ANY})",
            "",
            "    def test_conn_event_handler(self):",
            "        self.mox.UnsetStubs()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        service_mock = mock.MagicMock()",
            "        service_mock.disabled.return_value = False",
            "        with test.nested(",
            "            mock.patch.object(drvr._host, \"_connect\",",
            "                              side_effect=fakelibvirt.make_libvirtError(",
            "                                  fakelibvirt.libvirtError,",
            "                                  \"Failed to connect to host\",",
            "                                  error_code=",
            "                                  fakelibvirt.VIR_ERR_INTERNAL_ERROR)),",
            "            mock.patch.object(drvr._host, \"_init_events\",",
            "                              return_value=None),",
            "            mock.patch.object(objects.Service, \"get_by_compute_host\",",
            "                              return_value=service_mock)):",
            "",
            "            # verify that the driver registers for the close callback",
            "            # and re-connects after receiving the callback",
            "            self.assertRaises(exception.HypervisorUnavailable,",
            "                              drvr.init_host,",
            "                              \"wibble\")",
            "            self.assertTrue(service_mock.disabled)",
            "",
            "    def test_command_with_broken_connection(self):",
            "        self.mox.UnsetStubs()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        service_mock = mock.MagicMock()",
            "        service_mock.disabled.return_value = False",
            "        with test.nested(",
            "            mock.patch.object(drvr._host, \"_connect\",",
            "                              side_effect=fakelibvirt.make_libvirtError(",
            "                                  fakelibvirt.libvirtError,",
            "                                  \"Failed to connect to host\",",
            "                                  error_code=",
            "                                  fakelibvirt.VIR_ERR_INTERNAL_ERROR)),",
            "            mock.patch.object(drvr._host, \"_init_events\",",
            "                              return_value=None),",
            "            mock.patch.object(host.Host, \"has_min_version\",",
            "                              return_value=True),",
            "            mock.patch.object(drvr, \"_do_quality_warnings\",",
            "                              return_value=None),",
            "            mock.patch.object(objects.Service, \"get_by_compute_host\",",
            "                              return_value=service_mock)):",
            "",
            "            drvr.init_host(\"wibble\")",
            "            self.assertRaises(exception.HypervisorUnavailable,",
            "                              drvr.get_num_instances)",
            "            self.assertTrue(service_mock.disabled)",
            "",
            "    def test_service_resume_after_broken_connection(self):",
            "        self.mox.UnsetStubs()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        service_mock = mock.MagicMock()",
            "        service_mock.disabled.return_value = True",
            "        with test.nested(",
            "            mock.patch.object(drvr._host, \"_connect\",",
            "                              return_value=mock.MagicMock()),",
            "            mock.patch.object(drvr._host, \"_init_events\",",
            "                              return_value=None),",
            "            mock.patch.object(host.Host, \"has_min_version\",",
            "                              return_value=True),",
            "            mock.patch.object(drvr, \"_do_quality_warnings\",",
            "                              return_value=None),",
            "            mock.patch.object(objects.Service, \"get_by_compute_host\",",
            "                              return_value=service_mock)):",
            "",
            "            drvr.init_host(\"wibble\")",
            "            drvr.get_num_instances()",
            "            self.assertTrue(not service_mock.disabled and",
            "                            service_mock.disabled_reason is None)",
            "",
            "    @mock.patch.object(objects.Instance, 'save')",
            "    def test_immediate_delete(self, mock_save):",
            "        def fake_get_domain(instance):",
            "            raise exception.InstanceNotFound(instance_id=instance.uuid)",
            "",
            "        def fake_delete_instance_files(instance):",
            "            pass",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr._host, 'get_domain', fake_get_domain)",
            "        self.stubs.Set(drvr, 'delete_instance_files',",
            "                       fake_delete_instance_files)",
            "",
            "        instance = objects.Instance(self.context, **self.test_instance)",
            "        drvr.destroy(self.context, instance, {})",
            "        mock_save.assert_called_once_with()",
            "",
            "    @mock.patch.object(objects.Instance, 'get_by_uuid')",
            "    @mock.patch.object(objects.Instance, 'obj_load_attr', autospec=True)",
            "    @mock.patch.object(objects.Instance, 'save', autospec=True)",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_destroy')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, 'delete_instance_files')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_disconnect_volume')",
            "    @mock.patch.object(driver, 'block_device_info_get_mapping')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_undefine_domain')",
            "    def _test_destroy_removes_disk(self, mock_undefine_domain, mock_mapping,",
            "                                   mock_disconnect_volume,",
            "                                   mock_delete_instance_files, mock_destroy,",
            "                                   mock_inst_save, mock_inst_obj_load_attr,",
            "                                   mock_get_by_uuid, volume_fail=False):",
            "        instance = objects.Instance(self.context, **self.test_instance)",
            "        vol = {'block_device_mapping': [",
            "              {'connection_info': 'dummy', 'mount_device': '/dev/sdb'}]}",
            "",
            "        mock_mapping.return_value = vol['block_device_mapping']",
            "        mock_delete_instance_files.return_value = True",
            "        mock_get_by_uuid.return_value = instance",
            "        if volume_fail:",
            "            mock_disconnect_volume.return_value = (",
            "                exception.VolumeNotFound('vol'))",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr.destroy(self.context, instance, [], vol)",
            "",
            "    def test_destroy_removes_disk(self):",
            "        self._test_destroy_removes_disk(volume_fail=False)",
            "",
            "    def test_destroy_removes_disk_volume_fails(self):",
            "        self._test_destroy_removes_disk(volume_fail=True)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, 'unplug_vifs')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_destroy')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_undefine_domain')",
            "    def test_destroy_not_removes_disk(self, mock_undefine_domain, mock_destroy,",
            "                                      mock_unplug_vifs):",
            "        instance = fake_instance.fake_instance_obj(",
            "            None, name='instancename', id=1,",
            "            uuid='875a8070-d0b9-4949-8b31-104d125c9a64')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr.destroy(self.context, instance, [], None, False)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, 'cleanup')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_teardown_container')",
            "    @mock.patch.object(host.Host, 'get_domain')",
            "    def test_destroy_lxc_calls_teardown_container(self, mock_get_domain,",
            "                                                  mock_teardown_container,",
            "                                                  mock_cleanup):",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "        fake_domain = FakeVirtDomain()",
            "",
            "        def destroy_side_effect(*args, **kwargs):",
            "            fake_domain._info[0] = power_state.SHUTDOWN",
            "",
            "        with mock.patch.object(fake_domain, 'destroy',",
            "               side_effect=destroy_side_effect) as mock_domain_destroy:",
            "            mock_get_domain.return_value = fake_domain",
            "            instance = objects.Instance(**self.test_instance)",
            "",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "            network_info = []",
            "            drvr.destroy(self.context, instance, network_info, None, False)",
            "",
            "            mock_get_domain.assert_has_calls([mock.call(instance),",
            "                                              mock.call(instance)])",
            "            mock_domain_destroy.assert_called_once_with()",
            "            mock_teardown_container.assert_called_once_with(instance)",
            "            mock_cleanup.assert_called_once_with(self.context, instance,",
            "                                                 network_info, None, False,",
            "                                                 None)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, 'cleanup')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_teardown_container')",
            "    @mock.patch.object(host.Host, 'get_domain')",
            "    def test_destroy_lxc_calls_teardown_container_when_no_domain(self,",
            "            mock_get_domain, mock_teardown_container, mock_cleanup):",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "        instance = objects.Instance(**self.test_instance)",
            "        inf_exception = exception.InstanceNotFound(instance_id=instance.uuid)",
            "        mock_get_domain.side_effect = inf_exception",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        network_info = []",
            "        drvr.destroy(self.context, instance, network_info, None, False)",
            "",
            "        mock_get_domain.assert_has_calls([mock.call(instance),",
            "                                          mock.call(instance)])",
            "        mock_teardown_container.assert_called_once_with(instance)",
            "        mock_cleanup.assert_called_once_with(self.context, instance,",
            "                                             network_info, None, False,",
            "                                             None)",
            "",
            "    def test_reboot_different_ids(self):",
            "        class FakeLoopingCall(object):",
            "            def start(self, *a, **k):",
            "                return self",
            "",
            "            def wait(self):",
            "                return None",
            "",
            "        self.flags(wait_soft_reboot_seconds=1, group='libvirt')",
            "        info_tuple = ('fake', 'fake', 'fake', 'also_fake')",
            "        self.reboot_create_called = False",
            "",
            "        # Mock domain",
            "        mock_domain = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        mock_domain.info().AndReturn(",
            "            (libvirt_guest.VIR_DOMAIN_RUNNING,) + info_tuple)",
            "        mock_domain.ID().AndReturn('some_fake_id')",
            "        mock_domain.ID().AndReturn('some_fake_id')",
            "        mock_domain.shutdown()",
            "        mock_domain.info().AndReturn(",
            "            (libvirt_guest.VIR_DOMAIN_CRASHED,) + info_tuple)",
            "        mock_domain.ID().AndReturn('some_other_fake_id')",
            "        mock_domain.ID().AndReturn('some_other_fake_id')",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        def fake_get_domain(instance):",
            "            return mock_domain",
            "",
            "        def fake_create_domain(**kwargs):",
            "            self.reboot_create_called = True",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        self.stubs.Set(drvr._host, 'get_domain', fake_get_domain)",
            "        self.stubs.Set(drvr, '_create_domain', fake_create_domain)",
            "        self.stubs.Set(loopingcall, 'FixedIntervalLoopingCall',",
            "                       lambda *a, **k: FakeLoopingCall())",
            "        self.stubs.Set(pci_manager, 'get_instance_pci_devs', lambda *a: [])",
            "        drvr.reboot(None, instance, [], 'SOFT')",
            "        self.assertTrue(self.reboot_create_called)",
            "",
            "    @mock.patch.object(pci_manager, 'get_instance_pci_devs')",
            "    @mock.patch.object(loopingcall, 'FixedIntervalLoopingCall')",
            "    @mock.patch.object(greenthread, 'sleep')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_hard_reboot')",
            "    @mock.patch.object(host.Host, 'get_domain')",
            "    def test_reboot_same_ids(self, mock_get_domain, mock_hard_reboot,",
            "                             mock_sleep, mock_loopingcall,",
            "                             mock_get_instance_pci_devs):",
            "        class FakeLoopingCall(object):",
            "            def start(self, *a, **k):",
            "                return self",
            "",
            "            def wait(self):",
            "                return None",
            "",
            "        self.flags(wait_soft_reboot_seconds=1, group='libvirt')",
            "        info_tuple = ('fake', 'fake', 'fake', 'also_fake')",
            "        self.reboot_hard_reboot_called = False",
            "",
            "        # Mock domain",
            "        mock_domain = mock.Mock(fakelibvirt.virDomain)",
            "        return_values = [(libvirt_guest.VIR_DOMAIN_RUNNING,) + info_tuple,",
            "                         (libvirt_guest.VIR_DOMAIN_CRASHED,) + info_tuple]",
            "        mock_domain.info.side_effect = return_values",
            "        mock_domain.ID.return_value = 'some_fake_id'",
            "        mock_domain.shutdown.side_effect = mock.Mock()",
            "",
            "        def fake_hard_reboot(*args, **kwargs):",
            "            self.reboot_hard_reboot_called = True",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_get_domain.return_value = mock_domain",
            "        mock_hard_reboot.side_effect = fake_hard_reboot",
            "        mock_loopingcall.return_value = FakeLoopingCall()",
            "        mock_get_instance_pci_devs.return_value = []",
            "        drvr.reboot(None, instance, [], 'SOFT')",
            "        self.assertTrue(self.reboot_hard_reboot_called)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_hard_reboot')",
            "    @mock.patch.object(host.Host, 'get_domain')",
            "    def test_soft_reboot_libvirt_exception(self, mock_get_domain,",
            "                                           mock_hard_reboot):",
            "        # Tests that a hard reboot is performed when a soft reboot results",
            "        # in raising a libvirtError.",
            "        info_tuple = ('fake', 'fake', 'fake', 'also_fake')",
            "        # setup mocks",
            "        mock_virDomain = mock.Mock(fakelibvirt.virDomain)",
            "        mock_virDomain.info.return_value = (",
            "            (libvirt_guest.VIR_DOMAIN_RUNNING,) + info_tuple)",
            "        mock_virDomain.ID.return_value = 'some_fake_id'",
            "        mock_virDomain.shutdown.side_effect = fakelibvirt.libvirtError('Err')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        context = None",
            "        instance = objects.Instance(**self.test_instance)",
            "        network_info = []",
            "        mock_get_domain.return_value = mock_virDomain",
            "",
            "        drvr.reboot(context, instance, network_info, 'SOFT')",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_hard_reboot')",
            "    @mock.patch.object(host.Host, 'get_domain')",
            "    def _test_resume_state_on_host_boot_with_state(self, state,",
            "                                                   mock_get_domain,",
            "                                                   mock_hard_reboot):",
            "        mock_virDomain = mock.Mock(fakelibvirt.virDomain)",
            "        mock_virDomain.info.return_value = ([state, None, None, None, None])",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        mock_get_domain.return_value = mock_virDomain",
            "        instance = objects.Instance(**self.test_instance)",
            "        network_info = _fake_network_info(self, 1)",
            "",
            "        drvr.resume_state_on_host_boot(self.context, instance, network_info,",
            "                                       block_device_info=None)",
            "",
            "        ignored_states = (power_state.RUNNING,",
            "                          power_state.SUSPENDED,",
            "                          power_state.NOSTATE,",
            "                          power_state.PAUSED)",
            "        self.assertEqual(mock_hard_reboot.called, state not in ignored_states)",
            "",
            "    def test_resume_state_on_host_boot_with_running_state(self):",
            "        self._test_resume_state_on_host_boot_with_state(power_state.RUNNING)",
            "",
            "    def test_resume_state_on_host_boot_with_suspended_state(self):",
            "        self._test_resume_state_on_host_boot_with_state(power_state.SUSPENDED)",
            "",
            "    def test_resume_state_on_host_boot_with_paused_state(self):",
            "        self._test_resume_state_on_host_boot_with_state(power_state.PAUSED)",
            "",
            "    def test_resume_state_on_host_boot_with_nostate(self):",
            "        self._test_resume_state_on_host_boot_with_state(power_state.NOSTATE)",
            "",
            "    def test_resume_state_on_host_boot_with_shutdown_state(self):",
            "        self._test_resume_state_on_host_boot_with_state(power_state.RUNNING)",
            "",
            "    def test_resume_state_on_host_boot_with_crashed_state(self):",
            "        self._test_resume_state_on_host_boot_with_state(power_state.CRASHED)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_hard_reboot')",
            "    @mock.patch.object(host.Host, 'get_domain')",
            "    def test_resume_state_on_host_boot_with_instance_not_found_on_driver(",
            "            self, mock_get_domain, mock_hard_reboot):",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        mock_get_domain.side_effect = exception.InstanceNotFound(",
            "            instance_id='fake')",
            "        drvr.resume_state_on_host_boot(self.context, instance, network_info=[],",
            "                                       block_device_info=None)",
            "",
            "        mock_hard_reboot.assert_called_once_with(self.context,",
            "                                                 instance, [], None)",
            "",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver.get_info')",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver._create_domain_and_network')",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver._create_images_and_backing')",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver._get_guest_xml')",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver._get_instance_disk_info')",
            "    @mock.patch('nova.virt.libvirt.blockinfo.get_disk_info')",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver._destroy')",
            "    def test_hard_reboot(self, mock_destroy, mock_get_disk_info,",
            "                         mock_get_instance_disk_info, mock_get_guest_xml,",
            "                         mock_create_images_and_backing,",
            "                         mock_create_domain_and_network, mock_get_info):",
            "        self.context.auth_token = True  # any non-None value will suffice",
            "        instance = objects.Instance(**self.test_instance)",
            "        instance_path = libvirt_utils.get_instance_path(instance)",
            "        network_info = _fake_network_info(self, 1)",
            "        block_device_info = None",
            "",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices>\"",
            "                    \"<disk type='file'><driver name='qemu' type='raw'/>\"",
            "                    \"<source file='/test/disk'/>\"",
            "                    \"<target dev='vda' bus='virtio'/></disk>\"",
            "                    \"<disk type='file'><driver name='qemu' type='qcow2'/>\"",
            "                    \"<source file='/test/disk.local'/>\"",
            "                    \"<target dev='vdb' bus='virtio'/></disk>\"",
            "                    \"</devices></domain>\")",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        return_values = [hardware.InstanceInfo(state=power_state.SHUTDOWN),",
            "                         hardware.InstanceInfo(state=power_state.RUNNING)]",
            "        mock_get_info.side_effect = return_values",
            "",
            "        backing_disk_info = [{\"virt_disk_size\": 2}]",
            "",
            "        mock_get_disk_info.return_value = mock.sentinel.disk_info",
            "        mock_get_guest_xml.return_value = dummyxml",
            "        mock_get_instance_disk_info.return_value = backing_disk_info",
            "",
            "        drvr._hard_reboot(self.context, instance, network_info,",
            "                          block_device_info)",
            "",
            "        # make sure that _create_images_and_backing is passed the disk_info",
            "        # returned from _get_instance_disk_info and not the one that is in",
            "        # scope from blockinfo.get_disk_info",
            "        mock_create_images_and_backing.assert_called_once_with(self.context,",
            "            instance, instance_path, backing_disk_info)",
            "",
            "        # make sure that _create_domain_and_network is passed the disk_info",
            "        # returned from blockinfo.get_disk_info and not the one that's",
            "        # returned from _get_instance_disk_info",
            "        mock_create_domain_and_network.assert_called_once_with(self.context,",
            "            dummyxml, instance, network_info, mock.sentinel.disk_info,",
            "            block_device_info=block_device_info,",
            "            reboot=True, vifs_already_plugged=True)",
            "",
            "    @mock.patch('oslo_utils.fileutils.ensure_tree')",
            "    @mock.patch('oslo_service.loopingcall.FixedIntervalLoopingCall')",
            "    @mock.patch('nova.pci.manager.get_instance_pci_devs')",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver._prepare_pci_devices_for_use')",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver._create_domain_and_network')",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver._create_images_and_backing')",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver._get_instance_disk_info')",
            "    @mock.patch('nova.virt.libvirt.utils.write_to_file')",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path')",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver._get_guest_config')",
            "    @mock.patch('nova.virt.libvirt.blockinfo.get_disk_info')",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver._destroy')",
            "    def test_hard_reboot_does_not_call_glance_show(self,",
            "            mock_destroy, mock_get_disk_info, mock_get_guest_config,",
            "            mock_get_instance_path, mock_write_to_file,",
            "            mock_get_instance_disk_info, mock_create_images_and_backing,",
            "            mock_create_domand_and_network, mock_prepare_pci_devices_for_use,",
            "            mock_get_instance_pci_devs, mock_looping_call, mock_ensure_tree):",
            "        \"\"\"For a hard reboot, we shouldn't need an additional call to glance",
            "        to get the image metadata.",
            "",
            "        This is important for automatically spinning up instances on a",
            "        host-reboot, since we won't have a user request context that'll allow",
            "        the Glance request to go through. We have to rely on the cached image",
            "        metadata, instead.",
            "",
            "        https://bugs.launchpad.net/nova/+bug/1339386",
            "        \"\"\"",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        network_info = mock.MagicMock()",
            "        block_device_info = mock.MagicMock()",
            "        mock_get_disk_info.return_value = {}",
            "        mock_get_guest_config.return_value = mock.MagicMock()",
            "        mock_get_instance_path.return_value = '/foo'",
            "        mock_looping_call.return_value = mock.MagicMock()",
            "        drvr._image_api = mock.MagicMock()",
            "",
            "        drvr._hard_reboot(self.context, instance, network_info,",
            "                          block_device_info)",
            "",
            "        self.assertFalse(drvr._image_api.get.called)",
            "        mock_ensure_tree.assert_called_once_with('/foo')",
            "",
            "    def test_suspend(self):",
            "        guest = libvirt_guest.Guest(FakeVirtDomain(id=1))",
            "        dom = guest._domain",
            "",
            "        instance = objects.Instance(**self.test_instance)",
            "        instance.ephemeral_key_uuid = None",
            "",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        @mock.patch.object(dmcrypt, 'delete_volume')",
            "        @mock.patch.object(conn, '_get_instance_disk_info', return_value=[])",
            "        @mock.patch.object(conn, '_detach_sriov_ports')",
            "        @mock.patch.object(conn, '_detach_pci_devices')",
            "        @mock.patch.object(pci_manager, 'get_instance_pci_devs',",
            "                           return_value='pci devs')",
            "        @mock.patch.object(conn._host, 'get_guest', return_value=guest)",
            "        def suspend(mock_get_guest, mock_get_instance_pci_devs,",
            "                    mock_detach_pci_devices, mock_detach_sriov_ports,",
            "                    mock_get_instance_disk_info, mock_delete_volume):",
            "            mock_managedSave = mock.Mock()",
            "            dom.managedSave = mock_managedSave",
            "",
            "            conn.suspend(self.context, instance)",
            "",
            "            mock_managedSave.assert_called_once_with(0)",
            "            self.assertFalse(mock_get_instance_disk_info.called)",
            "            mock_delete_volume.assert_has_calls([mock.call(disk['path'])",
            "                for disk in mock_get_instance_disk_info.return_value], False)",
            "",
            "        suspend()",
            "",
            "    @mock.patch.object(time, 'sleep')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_create_domain')",
            "    @mock.patch.object(host.Host, 'get_domain')",
            "    def _test_clean_shutdown(self, mock_get_domain, mock_create_domain,",
            "                             mock_sleep, seconds_to_shutdown,",
            "                             timeout, retry_interval,",
            "                             shutdown_attempts, succeeds):",
            "        info_tuple = ('fake', 'fake', 'fake', 'also_fake')",
            "        shutdown_count = []",
            "",
            "        # Mock domain",
            "        mock_domain = mock.Mock(fakelibvirt.virDomain)",
            "        return_infos = [(libvirt_guest.VIR_DOMAIN_RUNNING,) + info_tuple]",
            "        return_shutdowns = [shutdown_count.append(\"shutdown\")]",
            "        retry_countdown = retry_interval",
            "        for x in range(min(seconds_to_shutdown, timeout)):",
            "            return_infos.append(",
            "                (libvirt_guest.VIR_DOMAIN_RUNNING,) + info_tuple)",
            "            if retry_countdown == 0:",
            "                return_shutdowns.append(shutdown_count.append(\"shutdown\"))",
            "                retry_countdown = retry_interval",
            "            else:",
            "                retry_countdown -= 1",
            "",
            "        if seconds_to_shutdown < timeout:",
            "            return_infos.append(",
            "                (libvirt_guest.VIR_DOMAIN_SHUTDOWN,) + info_tuple)",
            "",
            "        mock_domain.info.side_effect = return_infos",
            "        mock_domain.shutdown.side_effect = return_shutdowns",
            "",
            "        def fake_create_domain(**kwargs):",
            "            self.reboot_create_called = True",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_get_domain.return_value = mock_domain",
            "        mock_create_domain.side_effect = fake_create_domain",
            "        result = drvr._clean_shutdown(instance, timeout, retry_interval)",
            "",
            "        self.assertEqual(succeeds, result)",
            "        self.assertEqual(shutdown_attempts, len(shutdown_count))",
            "",
            "    def test_clean_shutdown_first_time(self):",
            "        self._test_clean_shutdown(seconds_to_shutdown=2,",
            "                                  timeout=5,",
            "                                  retry_interval=3,",
            "                                  shutdown_attempts=1,",
            "                                  succeeds=True)",
            "",
            "    def test_clean_shutdown_with_retry(self):",
            "        self._test_clean_shutdown(seconds_to_shutdown=4,",
            "                                  timeout=5,",
            "                                  retry_interval=3,",
            "                                  shutdown_attempts=2,",
            "                                  succeeds=True)",
            "",
            "    def test_clean_shutdown_failure(self):",
            "        self._test_clean_shutdown(seconds_to_shutdown=6,",
            "                                  timeout=5,",
            "                                  retry_interval=3,",
            "                                  shutdown_attempts=2,",
            "                                  succeeds=False)",
            "",
            "    def test_clean_shutdown_no_wait(self):",
            "        self._test_clean_shutdown(seconds_to_shutdown=6,",
            "                                  timeout=0,",
            "                                  retry_interval=3,",
            "                                  shutdown_attempts=1,",
            "                                  succeeds=False)",
            "",
            "    @mock.patch.object(FakeVirtDomain, 'attachDeviceFlags')",
            "    @mock.patch.object(FakeVirtDomain, 'ID', return_value=1)",
            "    @mock.patch.object(utils, 'get_image_from_system_metadata',",
            "                       return_value=None)",
            "    def test_attach_sriov_ports(self,",
            "                                mock_get_image_metadata,",
            "                                mock_ID,",
            "                                mock_attachDevice):",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        network_info = _fake_network_info(self, 1)",
            "        network_info[0]['vnic_type'] = network_model.VNIC_TYPE_DIRECT",
            "        guest = libvirt_guest.Guest(FakeVirtDomain())",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        drvr._attach_sriov_ports(self.context, instance, guest, network_info)",
            "        mock_get_image_metadata.assert_called_once_with(",
            "            instance.system_metadata)",
            "        self.assertTrue(mock_attachDevice.called)",
            "",
            "    @mock.patch.object(FakeVirtDomain, 'attachDeviceFlags')",
            "    @mock.patch.object(FakeVirtDomain, 'ID', return_value=1)",
            "    @mock.patch.object(utils, 'get_image_from_system_metadata',",
            "                       return_value=None)",
            "    def test_attach_sriov_ports_with_info_cache(self,",
            "                                                mock_get_image_metadata,",
            "                                                mock_ID,",
            "                                                mock_attachDevice):",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        network_info = _fake_network_info(self, 1)",
            "        network_info[0]['vnic_type'] = network_model.VNIC_TYPE_DIRECT",
            "        instance.info_cache = objects.InstanceInfoCache(",
            "            network_info=network_info)",
            "        guest = libvirt_guest.Guest(FakeVirtDomain())",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        drvr._attach_sriov_ports(self.context, instance, guest, None)",
            "        mock_get_image_metadata.assert_called_once_with(",
            "            instance.system_metadata)",
            "        self.assertTrue(mock_attachDevice.called)",
            "",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    @mock.patch.object(FakeVirtDomain, 'detachDeviceFlags')",
            "    @mock.patch.object(utils, 'get_image_from_system_metadata',",
            "                       return_value=None)",
            "    def test_detach_sriov_ports(self,",
            "                                mock_get_image_metadata,",
            "                                mock_detachDeviceFlags,",
            "                                mock_has_min_version):",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        network_info = _fake_network_info(self, 1)",
            "        network_info[0]['vnic_type'] = network_model.VNIC_TYPE_DIRECT",
            "        # some more adjustments for the fake network_info so that",
            "        # the correct get_config function will be executed (vif's",
            "        # get_config_hw_veb - which is according to the real SRIOV vif)",
            "        # and most importantly the pci_slot which is translated to",
            "        # cfg.source_dev, then to PciDevice.address and sent to",
            "        # _detach_pci_devices",
            "        network_info[0]['profile'] = dict(pci_slot=\"0000:00:00.0\")",
            "        network_info[0]['type'] = \"hw_veb\"",
            "        network_info[0]['details'] = dict(vlan=\"2145\")",
            "        instance.info_cache = objects.InstanceInfoCache(",
            "            network_info=network_info)",
            "        # fill the pci_devices of the instance so that",
            "        # pci_manager.get_instance_pci_devs will not return an empty list",
            "        # which will eventually fail the assertion for detachDeviceFlags",
            "        instance.pci_devices = objects.PciDeviceList()",
            "        instance.pci_devices.objects = [",
            "            objects.PciDevice(address='0000:00:00.0', request_id=None)",
            "        ]",
            "",
            "        domain = FakeVirtDomain()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        guest = libvirt_guest.Guest(domain)",
            "",
            "        drvr._detach_sriov_ports(self.context, instance, guest)",
            "        mock_get_image_metadata.assert_called_once_with(",
            "            instance.system_metadata)",
            "        self.assertTrue(mock_detachDeviceFlags.called)",
            "",
            "    @mock.patch.object(host.Host, 'has_min_version', return_value=True)",
            "    @mock.patch.object(FakeVirtDomain, 'detachDeviceFlags')",
            "    def test_detach_duplicate_mac_sriov_ports(self,",
            "                                              mock_detachDeviceFlags,",
            "                                              mock_has_min_version):",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        network_info = _fake_network_info(self, 2)",
            "",
            "        for network_info_inst in network_info:",
            "            network_info_inst['vnic_type'] = network_model.VNIC_TYPE_DIRECT",
            "            network_info_inst['type'] = \"hw_veb\"",
            "            network_info_inst['details'] = dict(vlan=\"2145\")",
            "            network_info_inst['address'] = \"fa:16:3e:96:2a:48\"",
            "",
            "        network_info[0]['profile'] = dict(pci_slot=\"0000:00:00.0\")",
            "        network_info[1]['profile'] = dict(pci_slot=\"0000:00:00.1\")",
            "",
            "        instance.info_cache = objects.InstanceInfoCache(",
            "            network_info=network_info)",
            "        # fill the pci_devices of the instance so that",
            "        # pci_manager.get_instance_pci_devs will not return an empty list",
            "        # which will eventually fail the assertion for detachDeviceFlags",
            "        instance.pci_devices = objects.PciDeviceList()",
            "        instance.pci_devices.objects = [",
            "            objects.PciDevice(address='0000:00:00.0', request_id=None),",
            "            objects.PciDevice(address='0000:00:00.1', request_id=None)",
            "        ]",
            "",
            "        domain = FakeVirtDomain()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        guest = libvirt_guest.Guest(domain)",
            "",
            "        drvr._detach_sriov_ports(self.context, instance, guest)",
            "",
            "        expected_xml = [",
            "            ('<hostdev mode=\"subsystem\" type=\"pci\" managed=\"yes\">\\n'",
            "             '  <source>\\n'",
            "             '    <address bus=\"0x00\" domain=\"0x0000\" \\",
            "                   function=\"0x0\" slot=\"0x00\"/>\\n'",
            "             '  </source>\\n'",
            "             '</hostdev>\\n'),",
            "            ('<hostdev mode=\"subsystem\" type=\"pci\" managed=\"yes\">\\n'",
            "             '  <source>\\n'",
            "             '    <address bus=\"0x00\" domain=\"0x0000\" \\",
            "                   function=\"0x1\" slot=\"0x00\"/>\\n'",
            "             '  </source>\\n'",
            "             '</hostdev>\\n')",
            "        ]",
            "",
            "        mock_detachDeviceFlags.has_calls([",
            "            mock.call(expected_xml[0], flags=1),",
            "            mock.call(expected_xml[1], flags=1)",
            "        ])",
            "",
            "    def test_resume(self):",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices>\"",
            "                    \"<disk type='file'><driver name='qemu' type='raw'/>\"",
            "                    \"<source file='/test/disk'/>\"",
            "                    \"<target dev='vda' bus='virtio'/></disk>\"",
            "                    \"<disk type='file'><driver name='qemu' type='qcow2'/>\"",
            "                    \"<source file='/test/disk.local'/>\"",
            "                    \"<target dev='vdb' bus='virtio'/></disk>\"",
            "                    \"</devices></domain>\")",
            "        instance = objects.Instance(**self.test_instance)",
            "        network_info = _fake_network_info(self, 1)",
            "        block_device_info = None",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        guest = libvirt_guest.Guest('fake_dom')",
            "        with test.nested(",
            "            mock.patch.object(drvr, '_get_existing_domain_xml',",
            "                              return_value=dummyxml),",
            "            mock.patch.object(drvr, '_create_domain_and_network',",
            "                              return_value=guest),",
            "            mock.patch.object(drvr, '_attach_pci_devices'),",
            "            mock.patch.object(pci_manager, 'get_instance_pci_devs',",
            "                              return_value='fake_pci_devs'),",
            "            mock.patch.object(utils, 'get_image_from_system_metadata'),",
            "            mock.patch.object(blockinfo, 'get_disk_info'),",
            "        ) as (_get_existing_domain_xml, _create_domain_and_network,",
            "              _attach_pci_devices, get_instance_pci_devs, get_image_metadata,",
            "              get_disk_info):",
            "            get_image_metadata.return_value = {'bar': 234}",
            "",
            "            disk_info = {'foo': 123}",
            "            get_disk_info.return_value = disk_info",
            "",
            "            drvr.resume(self.context, instance, network_info,",
            "                        block_device_info)",
            "            _get_existing_domain_xml.assert_has_calls([mock.call(instance,",
            "                                            network_info, block_device_info)])",
            "            _create_domain_and_network.assert_has_calls([mock.call(",
            "                                        self.context, dummyxml,",
            "                                        instance, network_info, disk_info,",
            "                                        block_device_info=block_device_info,",
            "                                        vifs_already_plugged=True)])",
            "            _attach_pci_devices.assert_has_calls([mock.call(guest,",
            "                                                 'fake_pci_devs')])",
            "",
            "    @mock.patch.object(host.Host, 'get_domain')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, 'get_info')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, 'delete_instance_files')",
            "    @mock.patch.object(objects.Instance, 'save')",
            "    def test_destroy_undefines(self, mock_save, mock_delete_instance_files,",
            "                               mock_get_info, mock_get_domain):",
            "        dom_mock = mock.MagicMock()",
            "        dom_mock.undefineFlags.return_value = 1",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        mock_get_domain.return_value = dom_mock",
            "        mock_get_info.return_value = hardware.InstanceInfo(",
            "            state=power_state.SHUTDOWN, id=-1)",
            "        mock_delete_instance_files.return_value = None",
            "",
            "        instance = objects.Instance(self.context, **self.test_instance)",
            "        drvr.destroy(self.context, instance, [])",
            "        mock_save.assert_called_once_with()",
            "",
            "    @mock.patch.object(rbd_utils, 'RBDDriver')",
            "    def test_cleanup_rbd(self, mock_driver):",
            "        driver = mock_driver.return_value",
            "        driver.cleanup_volumes = mock.Mock()",
            "        fake_instance = {'uuid': '875a8070-d0b9-4949-8b31-104d125c9a64'}",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        drvr._cleanup_rbd(fake_instance)",
            "",
            "        driver.cleanup_volumes.assert_called_once_with(fake_instance)",
            "",
            "    @mock.patch.object(objects.Instance, 'save')",
            "    def test_destroy_undefines_no_undefine_flags(self, mock_save):",
            "        mock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        mock.ID()",
            "        mock.destroy()",
            "        mock.undefineFlags(1).AndRaise(fakelibvirt.libvirtError('Err'))",
            "        mock.ID().AndReturn(123)",
            "        mock.undefine()",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        def fake_get_domain(instance):",
            "            return mock",
            "",
            "        def fake_get_info(instance_name):",
            "            return hardware.InstanceInfo(state=power_state.SHUTDOWN, id=-1)",
            "",
            "        def fake_delete_instance_files(instance):",
            "            return None",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr._host, 'get_domain', fake_get_domain)",
            "        self.stubs.Set(drvr, 'get_info', fake_get_info)",
            "        self.stubs.Set(drvr, 'delete_instance_files',",
            "                       fake_delete_instance_files)",
            "        instance = objects.Instance(self.context, **self.test_instance)",
            "        drvr.destroy(self.context, instance, [])",
            "        mock_save.assert_called_once_with()",
            "",
            "    @mock.patch.object(objects.Instance, 'save')",
            "    def test_destroy_undefines_no_attribute_with_managed_save(self, mock_save):",
            "        mock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        mock.ID()",
            "        mock.destroy()",
            "        mock.undefineFlags(1).AndRaise(AttributeError())",
            "        mock.hasManagedSaveImage(0).AndReturn(True)",
            "        mock.managedSaveRemove(0)",
            "        mock.undefine()",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        def fake_get_domain(instance):",
            "            return mock",
            "",
            "        def fake_get_info(instance_name):",
            "            return hardware.InstanceInfo(state=power_state.SHUTDOWN, id=-1)",
            "",
            "        def fake_delete_instance_files(instance):",
            "            return None",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr._host, 'get_domain', fake_get_domain)",
            "        self.stubs.Set(drvr, 'get_info', fake_get_info)",
            "        self.stubs.Set(drvr, 'delete_instance_files',",
            "                       fake_delete_instance_files)",
            "        instance = objects.Instance(self.context, **self.test_instance)",
            "        drvr.destroy(self.context, instance, [])",
            "        mock_save.assert_called_once_with()",
            "",
            "    @mock.patch.object(objects.Instance, 'save')",
            "    def test_destroy_undefines_no_attribute_no_managed_save(self, mock_save):",
            "        mock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        mock.ID()",
            "        mock.destroy()",
            "        mock.undefineFlags(1).AndRaise(AttributeError())",
            "        mock.hasManagedSaveImage(0).AndRaise(AttributeError())",
            "        mock.undefine()",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        def fake_get_domain(self, instance):",
            "            return mock",
            "",
            "        def fake_get_info(instance_name):",
            "            return hardware.InstanceInfo(state=power_state.SHUTDOWN)",
            "",
            "        def fake_delete_instance_files(instance):",
            "            return None",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(host.Host, 'get_domain', fake_get_domain)",
            "        self.stubs.Set(drvr, 'get_info', fake_get_info)",
            "        self.stubs.Set(drvr, 'delete_instance_files',",
            "                       fake_delete_instance_files)",
            "        instance = objects.Instance(self.context, **self.test_instance)",
            "        drvr.destroy(self.context, instance, [])",
            "        mock_save.assert_called_once_with()",
            "",
            "    def test_destroy_timed_out(self):",
            "        mock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        mock.ID()",
            "        mock.destroy().AndRaise(fakelibvirt.libvirtError(\"timed out\"))",
            "        self.mox.ReplayAll()",
            "",
            "        def fake_get_domain(self, instance):",
            "            return mock",
            "",
            "        def fake_get_error_code(self):",
            "            return fakelibvirt.VIR_ERR_OPERATION_TIMEOUT",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(host.Host, 'get_domain', fake_get_domain)",
            "        self.stubs.Set(fakelibvirt.libvirtError, 'get_error_code',",
            "                fake_get_error_code)",
            "        instance = objects.Instance(**self.test_instance)",
            "        self.assertRaises(exception.InstancePowerOffFailure,",
            "                drvr.destroy, self.context, instance, [])",
            "",
            "    def test_private_destroy_not_found(self):",
            "        ex = fakelibvirt.make_libvirtError(",
            "                fakelibvirt.libvirtError,",
            "                \"No such domain\",",
            "                error_code=fakelibvirt.VIR_ERR_NO_DOMAIN)",
            "        mock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        mock.ID()",
            "        mock.destroy().AndRaise(ex)",
            "        mock.info().AndRaise(ex)",
            "        mock.UUIDString()",
            "        self.mox.ReplayAll()",
            "",
            "        def fake_get_domain(instance):",
            "            return mock",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr._host, 'get_domain', fake_get_domain)",
            "        instance = objects.Instance(**self.test_instance)",
            "        # NOTE(vish): verifies destroy doesn't raise if the instance disappears",
            "        drvr._destroy(instance)",
            "",
            "    def test_private_destroy_lxc_processes_refused_to_die(self):",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "        ex = fakelibvirt.make_libvirtError(",
            "                fakelibvirt.libvirtError, \"\",",
            "                error_message=\"internal error: Some processes refused to die\",",
            "                error_code=fakelibvirt.VIR_ERR_INTERNAL_ERROR)",
            "",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        with mock.patch.object(conn._host, 'get_domain') as mock_get_domain, \\",
            "             mock.patch.object(conn, 'get_info') as mock_get_info:",
            "            mock_domain = mock.MagicMock()",
            "            mock_domain.ID.return_value = 1",
            "            mock_get_domain.return_value = mock_domain",
            "            mock_domain.destroy.side_effect = ex",
            "",
            "            mock_info = mock.MagicMock()",
            "            mock_info.id = 1",
            "            mock_info.state = power_state.SHUTDOWN",
            "            mock_get_info.return_value = mock_info",
            "",
            "            instance = objects.Instance(**self.test_instance)",
            "            conn._destroy(instance)",
            "",
            "    def test_private_destroy_processes_refused_to_die_still_raises(self):",
            "        ex = fakelibvirt.make_libvirtError(",
            "                fakelibvirt.libvirtError, \"\",",
            "                error_message=\"internal error: Some processes refused to die\",",
            "                error_code=fakelibvirt.VIR_ERR_INTERNAL_ERROR)",
            "",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        with mock.patch.object(conn._host, 'get_domain') as mock_get_domain:",
            "            mock_domain = mock.MagicMock()",
            "            mock_domain.ID.return_value = 1",
            "            mock_get_domain.return_value = mock_domain",
            "            mock_domain.destroy.side_effect = ex",
            "",
            "            instance = objects.Instance(**self.test_instance)",
            "            self.assertRaises(fakelibvirt.libvirtError, conn._destroy,",
            "                              instance)",
            "",
            "    def test_private_destroy_ebusy_timeout(self):",
            "        # Tests that _destroy will retry 3 times to destroy the guest when an",
            "        # EBUSY is raised, but eventually times out and raises the libvirtError",
            "        ex = fakelibvirt.make_libvirtError(",
            "                fakelibvirt.libvirtError,",
            "                (\"Failed to terminate process 26425 with SIGKILL: \"",
            "                 \"Device or resource busy\"),",
            "                error_code=fakelibvirt.VIR_ERR_SYSTEM_ERROR,",
            "                int1=errno.EBUSY)",
            "",
            "        mock_guest = mock.Mock(libvirt_guest.Guest, id=1)",
            "        mock_guest.poweroff = mock.Mock(side_effect=ex)",
            "",
            "        instance = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        with mock.patch.object(drvr._host, 'get_guest',",
            "                               return_value=mock_guest):",
            "            self.assertRaises(fakelibvirt.libvirtError, drvr._destroy,",
            "                              instance)",
            "",
            "        self.assertEqual(3, mock_guest.poweroff.call_count)",
            "",
            "    def test_private_destroy_ebusy_multiple_attempt_ok(self):",
            "        # Tests that the _destroy attempt loop is broken when EBUSY is no",
            "        # longer raised.",
            "        ex = fakelibvirt.make_libvirtError(",
            "                fakelibvirt.libvirtError,",
            "                (\"Failed to terminate process 26425 with SIGKILL: \"",
            "                 \"Device or resource busy\"),",
            "                error_code=fakelibvirt.VIR_ERR_SYSTEM_ERROR,",
            "                int1=errno.EBUSY)",
            "",
            "        mock_guest = mock.Mock(libvirt_guest.Guest, id=1)",
            "        mock_guest.poweroff = mock.Mock(side_effect=[ex, None])",
            "",
            "        inst_info = hardware.InstanceInfo(power_state.SHUTDOWN, id=1)",
            "        instance = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        with mock.patch.object(drvr._host, 'get_guest',",
            "                               return_value=mock_guest):",
            "            with mock.patch.object(drvr, 'get_info', return_value=inst_info):",
            "                drvr._destroy(instance)",
            "",
            "        self.assertEqual(2, mock_guest.poweroff.call_count)",
            "",
            "    def test_undefine_domain_with_not_found_instance(self):",
            "        def fake_get_domain(self, instance):",
            "            raise exception.InstanceNotFound(instance_id=instance.uuid)",
            "",
            "        self.stubs.Set(host.Host, 'get_domain', fake_get_domain)",
            "        self.mox.StubOutWithMock(fakelibvirt.libvirtError, \"get_error_code\")",
            "",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        # NOTE(wenjianhn): verifies undefine doesn't raise if the",
            "        # instance disappears",
            "        drvr._undefine_domain(instance)",
            "",
            "    @mock.patch.object(host.Host, \"list_instance_domains\")",
            "    @mock.patch.object(objects.BlockDeviceMappingList, \"bdms_by_instance_uuid\")",
            "    @mock.patch.object(objects.InstanceList, \"get_by_filters\")",
            "    def test_disk_over_committed_size_total(self, mock_get, mock_bdms,",
            "                                            mock_list):",
            "        # Ensure destroy calls managedSaveRemove for saved instance.",
            "        class DiagFakeDomain(object):",
            "            def __init__(self, name):",
            "                self._name = name",
            "                self._uuid = str(uuid.uuid4())",
            "",
            "            def ID(self):",
            "                return 1",
            "",
            "            def name(self):",
            "                return self._name",
            "",
            "            def UUIDString(self):",
            "                return self._uuid",
            "",
            "            def XMLDesc(self, flags):",
            "                return \"<domain/>\"",
            "",
            "        instance_domains = [",
            "            DiagFakeDomain(\"instance0000001\"),",
            "            DiagFakeDomain(\"instance0000002\")]",
            "        mock_list.return_value = instance_domains",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        fake_disks = {'instance0000001':",
            "                      [{'type': 'qcow2', 'path': '/somepath/disk1',",
            "                        'virt_disk_size': '10737418240',",
            "                        'backing_file': '/somepath/disk1',",
            "                        'disk_size': '83886080',",
            "                        'over_committed_disk_size': '10653532160'}],",
            "                      'instance0000002':",
            "                      [{'type': 'raw', 'path': '/somepath/disk2',",
            "                        'virt_disk_size': '0',",
            "                        'backing_file': '/somepath/disk2',",
            "                        'disk_size': '10737418240',",
            "                        'over_committed_disk_size': '0'}]}",
            "",
            "        def get_info(instance_name, xml, **kwargs):",
            "            return fake_disks.get(instance_name)",
            "",
            "        instance_uuids = [dom.UUIDString() for dom in instance_domains]",
            "        instances = [objects.Instance(",
            "            uuid=instance_uuids[0],",
            "            root_device_name='/dev/vda'),",
            "            objects.Instance(",
            "            uuid=instance_uuids[1],",
            "            root_device_name='/dev/vdb')",
            "        ]",
            "        mock_get.return_value = instances",
            "",
            "        with mock.patch.object(drvr,",
            "                               \"_get_instance_disk_info\") as mock_info:",
            "            mock_info.side_effect = get_info",
            "",
            "            result = drvr._get_disk_over_committed_size_total()",
            "            self.assertEqual(result, 10653532160)",
            "            mock_list.assert_called_once_with()",
            "            self.assertEqual(2, mock_info.call_count)",
            "",
            "        filters = {'uuid': instance_uuids}",
            "        mock_get.assert_called_once_with(mock.ANY, filters, use_slave=True)",
            "        mock_bdms.assert_called_with(mock.ANY, instance_uuids)",
            "",
            "    @mock.patch.object(host.Host, \"list_instance_domains\")",
            "    @mock.patch.object(objects.BlockDeviceMappingList, \"bdms_by_instance_uuid\")",
            "    @mock.patch.object(objects.InstanceList, \"get_by_filters\")",
            "    def test_disk_over_committed_size_total_eperm(self, mock_get, mock_bdms,",
            "                                                  mock_list):",
            "        # Ensure destroy calls managedSaveRemove for saved instance.",
            "        class DiagFakeDomain(object):",
            "            def __init__(self, name):",
            "                self._name = name",
            "                self._uuid = str(uuid.uuid4())",
            "",
            "            def ID(self):",
            "                return 1",
            "",
            "            def name(self):",
            "                return self._name",
            "",
            "            def UUIDString(self):",
            "                return self._uuid",
            "",
            "            def XMLDesc(self, flags):",
            "                return \"<domain/>\"",
            "",
            "        instance_domains = [",
            "            DiagFakeDomain(\"instance0000001\"),",
            "            DiagFakeDomain(\"instance0000002\")]",
            "        mock_list.return_value = instance_domains",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        fake_disks = {'instance0000001':",
            "                      [{'type': 'qcow2', 'path': '/somepath/disk1',",
            "                        'virt_disk_size': '10737418240',",
            "                        'backing_file': '/somepath/disk1',",
            "                        'disk_size': '83886080',",
            "                        'over_committed_disk_size': '10653532160'}],",
            "                      'instance0000002':",
            "                      [{'type': 'raw', 'path': '/somepath/disk2',",
            "                        'virt_disk_size': '0',",
            "                        'backing_file': '/somepath/disk2',",
            "                        'disk_size': '10737418240',",
            "                        'over_committed_disk_size': '21474836480'}]}",
            "",
            "        def side_effect(name, dom, block_device_info):",
            "            if name == 'instance0000001':",
            "                self.assertEqual('/dev/vda',",
            "                                 block_device_info['root_device_name'])",
            "                raise OSError(errno.EACCES, 'Permission denied')",
            "            if name == 'instance0000002':",
            "                self.assertEqual('/dev/vdb',",
            "                                 block_device_info['root_device_name'])",
            "                return fake_disks.get(name)",
            "        get_disk_info = mock.Mock()",
            "        get_disk_info.side_effect = side_effect",
            "        drvr._get_instance_disk_info = get_disk_info",
            "",
            "        instance_uuids = [dom.UUIDString() for dom in instance_domains]",
            "        instances = [objects.Instance(",
            "            uuid=instance_uuids[0],",
            "            root_device_name='/dev/vda'),",
            "            objects.Instance(",
            "            uuid=instance_uuids[1],",
            "            root_device_name='/dev/vdb')",
            "        ]",
            "        mock_get.return_value = instances",
            "",
            "        result = drvr._get_disk_over_committed_size_total()",
            "        self.assertEqual(21474836480, result)",
            "        mock_list.assert_called_once_with()",
            "        self.assertEqual(2, get_disk_info.call_count)",
            "        filters = {'uuid': instance_uuids}",
            "        mock_get.assert_called_once_with(mock.ANY, filters, use_slave=True)",
            "        mock_bdms.assert_called_with(mock.ANY, instance_uuids)",
            "",
            "    @mock.patch.object(host.Host, \"list_instance_domains\",",
            "                       return_value=[mock.MagicMock(name='foo')])",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, \"_get_instance_disk_info\",",
            "                       side_effect=exception.VolumeBDMPathNotFound(path='bar'))",
            "    @mock.patch.object(objects.BlockDeviceMappingList, \"bdms_by_instance_uuid\")",
            "    @mock.patch.object(objects.InstanceList, \"get_by_filters\")",
            "    def test_disk_over_committed_size_total_bdm_not_found(self,",
            "                                                          mock_get,",
            "                                                          mock_bdms,",
            "                                                          mock_get_disk_info,",
            "                                                          mock_list_domains):",
            "        # Tests that we handle VolumeBDMPathNotFound gracefully.",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertEqual(0, drvr._get_disk_over_committed_size_total())",
            "",
            "    def test_cpu_info(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        def get_host_capabilities_stub(self):",
            "            cpu = vconfig.LibvirtConfigCPU()",
            "            cpu.model = \"Opteron_G4\"",
            "            cpu.vendor = \"AMD\"",
            "            cpu.arch = arch.X86_64",
            "",
            "            cpu.cells = 1",
            "            cpu.cores = 2",
            "            cpu.threads = 1",
            "            cpu.sockets = 4",
            "",
            "            cpu.add_feature(vconfig.LibvirtConfigCPUFeature(\"extapic\"))",
            "            cpu.add_feature(vconfig.LibvirtConfigCPUFeature(\"3dnow\"))",
            "",
            "            caps = vconfig.LibvirtConfigCaps()",
            "            caps.host = vconfig.LibvirtConfigCapsHost()",
            "            caps.host.cpu = cpu",
            "",
            "            guest = vconfig.LibvirtConfigGuest()",
            "            guest.ostype = vm_mode.HVM",
            "            guest.arch = arch.X86_64",
            "            guest.domtype = [\"kvm\"]",
            "            caps.guests.append(guest)",
            "",
            "            guest = vconfig.LibvirtConfigGuest()",
            "            guest.ostype = vm_mode.HVM",
            "            guest.arch = arch.I686",
            "            guest.domtype = [\"kvm\"]",
            "            caps.guests.append(guest)",
            "",
            "            return caps",
            "",
            "        self.stubs.Set(host.Host, \"get_capabilities\",",
            "                       get_host_capabilities_stub)",
            "",
            "        want = {\"vendor\": \"AMD\",",
            "                \"features\": set([\"extapic\", \"3dnow\"]),",
            "                \"model\": \"Opteron_G4\",",
            "                \"arch\": arch.X86_64,",
            "                \"topology\": {\"cells\": 1, \"cores\": 2, \"threads\": 1,",
            "                             \"sockets\": 4}}",
            "        got = drvr._get_cpu_info()",
            "        self.assertEqual(want, got)",
            "",
            "    def test_get_pcidev_info(self):",
            "",
            "        def fake_nodeDeviceLookupByName(self, name):",
            "            return FakeNodeDevice(_fake_NodeDevXml[name])",
            "",
            "        self.mox.StubOutWithMock(host.Host, 'device_lookup_by_name')",
            "        host.Host.device_lookup_by_name = fake_nodeDeviceLookupByName",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        with mock.patch.object(",
            "            fakelibvirt.Connection, 'getLibVersion') as mock_lib_version:",
            "            mock_lib_version.return_value = (",
            "                versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_PF_WITH_NO_VFS_CAP_VERSION) - 1)",
            "",
            "            actualvf = drvr._get_pcidev_info(\"pci_0000_04_00_3\")",
            "            expect_vf = {",
            "                \"dev_id\": \"pci_0000_04_00_3\",",
            "                \"address\": \"0000:04:00.3\",",
            "                \"product_id\": '1521',",
            "                \"numa_node\": None,",
            "                \"vendor_id\": '8086',",
            "                \"label\": 'label_8086_1521',",
            "                \"dev_type\": fields.PciDeviceType.SRIOV_PF,",
            "                }",
            "",
            "            self.assertEqual(expect_vf, actualvf)",
            "            actualvf = drvr._get_pcidev_info(\"pci_0000_04_10_7\")",
            "            expect_vf = {",
            "                \"dev_id\": \"pci_0000_04_10_7\",",
            "                \"address\": \"0000:04:10.7\",",
            "                \"product_id\": '1520',",
            "                \"numa_node\": None,",
            "                \"vendor_id\": '8086',",
            "                \"label\": 'label_8086_1520',",
            "                \"dev_type\": fields.PciDeviceType.SRIOV_VF,",
            "                \"parent_addr\": '0000:04:00.3',",
            "                }",
            "            self.assertEqual(expect_vf, actualvf)",
            "",
            "            actualvf = drvr._get_pcidev_info(\"pci_0000_04_11_7\")",
            "            expect_vf = {",
            "                \"dev_id\": \"pci_0000_04_11_7\",",
            "                \"address\": \"0000:04:11.7\",",
            "                \"product_id\": '1520',",
            "                \"vendor_id\": '8086',",
            "                \"numa_node\": 0,",
            "                \"label\": 'label_8086_1520',",
            "                \"dev_type\": fields.PciDeviceType.SRIOV_VF,",
            "                \"parent_addr\": '0000:04:00.3',",
            "                }",
            "",
            "            self.assertEqual(expect_vf, actualvf)",
            "",
            "            with mock.patch.object(",
            "                pci_utils, 'is_physical_function', return_value=True):",
            "                actualvf = drvr._get_pcidev_info(\"pci_0000_04_00_1\")",
            "                expect_vf = {",
            "                    \"dev_id\": \"pci_0000_04_00_1\",",
            "                    \"address\": \"0000:04:00.1\",",
            "                    \"product_id\": '1013',",
            "                    \"numa_node\": 0,",
            "                    \"vendor_id\": '15b3',",
            "                    \"label\": 'label_15b3_1013',",
            "                    \"dev_type\": fields.PciDeviceType.SRIOV_PF,",
            "                    }",
            "                self.assertEqual(expect_vf, actualvf)",
            "",
            "            with mock.patch.object(",
            "                pci_utils, 'is_physical_function', return_value=False):",
            "                actualvf = drvr._get_pcidev_info(\"pci_0000_04_00_1\")",
            "                expect_vf = {",
            "                    \"dev_id\": \"pci_0000_04_00_1\",",
            "                    \"address\": \"0000:04:00.1\",",
            "                    \"product_id\": '1013',",
            "                    \"numa_node\": 0,",
            "                    \"vendor_id\": '15b3',",
            "                    \"label\": 'label_15b3_1013',",
            "                    \"dev_type\": fields.PciDeviceType.STANDARD,",
            "                    }",
            "                self.assertEqual(expect_vf, actualvf)",
            "",
            "        with mock.patch.object(",
            "            fakelibvirt.Connection, 'getLibVersion') as mock_lib_version:",
            "            mock_lib_version.return_value = (",
            "                versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_PF_WITH_NO_VFS_CAP_VERSION))",
            "            actualvf = drvr._get_pcidev_info(\"pci_0000_03_00_0\")",
            "            expect_vf = {",
            "                \"dev_id\": \"pci_0000_03_00_0\",",
            "                \"address\": \"0000:03:00.0\",",
            "                \"product_id\": '1013',",
            "                \"numa_node\": 0,",
            "                \"vendor_id\": '15b3',",
            "                \"label\": 'label_15b3_1013',",
            "                \"dev_type\": fields.PciDeviceType.SRIOV_PF,",
            "                }",
            "            self.assertEqual(expect_vf, actualvf)",
            "",
            "            actualvf = drvr._get_pcidev_info(\"pci_0000_03_00_1\")",
            "            expect_vf = {",
            "                \"dev_id\": \"pci_0000_03_00_1\",",
            "                \"address\": \"0000:03:00.1\",",
            "                \"product_id\": '1013',",
            "                \"numa_node\": 0,",
            "                \"vendor_id\": '15b3',",
            "                \"label\": 'label_15b3_1013',",
            "                \"dev_type\": fields.PciDeviceType.SRIOV_PF,",
            "                }",
            "",
            "            self.assertEqual(expect_vf, actualvf)",
            "",
            "    def test_list_devices_not_supported(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        # Handle just the NO_SUPPORT error",
            "        not_supported_exc = fakelibvirt.make_libvirtError(",
            "                fakelibvirt.libvirtError,",
            "                'this function is not supported by the connection driver:'",
            "                ' virNodeNumOfDevices',",
            "                error_code=fakelibvirt.VIR_ERR_NO_SUPPORT)",
            "",
            "        with mock.patch.object(drvr._conn, 'listDevices',",
            "                               side_effect=not_supported_exc):",
            "            self.assertEqual('[]', drvr._get_pci_passthrough_devices())",
            "",
            "        # We cache not supported status to avoid emitting too many logging",
            "        # messages. Clear this value to test the other exception case.",
            "        del drvr._list_devices_supported",
            "",
            "        # Other errors should not be caught",
            "        other_exc = fakelibvirt.make_libvirtError(",
            "            fakelibvirt.libvirtError,",
            "            'other exc',",
            "            error_code=fakelibvirt.VIR_ERR_NO_DOMAIN)",
            "",
            "        with mock.patch.object(drvr._conn, 'listDevices',",
            "                               side_effect=other_exc):",
            "            self.assertRaises(fakelibvirt.libvirtError,",
            "                              drvr._get_pci_passthrough_devices)",
            "",
            "    def test_get_pci_passthrough_devices(self):",
            "",
            "        def fakelistDevices(caps, fakeargs=0):",
            "            return ['pci_0000_04_00_3', 'pci_0000_04_10_7',",
            "                    'pci_0000_04_11_7']",
            "",
            "        self.mox.StubOutWithMock(libvirt_driver.LibvirtDriver, '_conn')",
            "",
            "        libvirt_driver.LibvirtDriver._conn.listDevices = fakelistDevices",
            "",
            "        def fake_nodeDeviceLookupByName(self, name):",
            "            return FakeNodeDevice(_fake_NodeDevXml[name])",
            "",
            "        self.mox.StubOutWithMock(host.Host, 'device_lookup_by_name')",
            "        host.Host.device_lookup_by_name = fake_nodeDeviceLookupByName",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        actjson = drvr._get_pci_passthrough_devices()",
            "",
            "        expectvfs = [",
            "            {",
            "                \"dev_id\": \"pci_0000_04_00_3\",",
            "                \"address\": \"0000:04:00.3\",",
            "                \"product_id\": '1521',",
            "                \"vendor_id\": '8086',",
            "                \"dev_type\": fields.PciDeviceType.SRIOV_PF,",
            "                \"phys_function\": None,",
            "                \"numa_node\": None},",
            "            {",
            "                \"dev_id\": \"pci_0000_04_10_7\",",
            "                \"domain\": 0,",
            "                \"address\": \"0000:04:10.7\",",
            "                \"product_id\": '1520',",
            "                \"vendor_id\": '8086',",
            "                \"numa_node\": None,",
            "                \"dev_type\": fields.PciDeviceType.SRIOV_VF,",
            "                \"phys_function\": [('0x0000', '0x04', '0x00', '0x3')]},",
            "            {",
            "                \"dev_id\": \"pci_0000_04_11_7\",",
            "                \"domain\": 0,",
            "                \"address\": \"0000:04:11.7\",",
            "                \"product_id\": '1520',",
            "                \"vendor_id\": '8086',",
            "                \"numa_node\": 0,",
            "                \"dev_type\": fields.PciDeviceType.SRIOV_VF,",
            "                \"phys_function\": [('0x0000', '0x04', '0x00', '0x3')],",
            "            }",
            "        ]",
            "",
            "        actualvfs = jsonutils.loads(actjson)",
            "        for dev in range(len(actualvfs)):",
            "            for key in actualvfs[dev].keys():",
            "                if key not in ['phys_function', 'virt_functions', 'label']:",
            "                    self.assertEqual(expectvfs[dev][key], actualvfs[dev][key])",
            "",
            "    def _fake_caps_numa_topology(self,",
            "                                 cells_per_host=4,",
            "                                 sockets_per_cell=1,",
            "                                 cores_per_socket=1,",
            "                                 threads_per_core=2,",
            "                                 kb_mem=1048576):",
            "",
            "        # Generate mempages list per cell",
            "        cell_mempages = list()",
            "        for cellid in range(cells_per_host):",
            "            mempages_0 = vconfig.LibvirtConfigCapsNUMAPages()",
            "            mempages_0.size = 4",
            "            mempages_0.total = 1024 * cellid",
            "",
            "            mempages_1 = vconfig.LibvirtConfigCapsNUMAPages()",
            "            mempages_1.size = 2048",
            "            mempages_1.total = 0 + cellid",
            "",
            "            cell_mempages.append([mempages_0, mempages_1])",
            "",
            "        topology = fakelibvirt.HostInfo._gen_numa_topology(cells_per_host,",
            "                                         sockets_per_cell,",
            "                                         cores_per_socket,",
            "                                         threads_per_core,",
            "                                         kb_mem=kb_mem,",
            "                                         numa_mempages_list=cell_mempages)",
            "",
            "        return topology",
            "",
            "    def _test_get_host_numa_topology(self, mempages):",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = arch.X86_64",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        expected_topo_dict = {'cells': [",
            "                                {'cpus': '0,1', 'cpu_usage': 0,",
            "                                  'mem': {'total': 256, 'used': 0},",
            "                                  'id': 0},",
            "                                {'cpus': '3', 'cpu_usage': 0,",
            "                                  'mem': {'total': 256, 'used': 0},",
            "                                  'id': 1},",
            "                                {'cpus': '', 'cpu_usage': 0,",
            "                                  'mem': {'total': 256, 'used': 0},",
            "                                  'id': 2},",
            "                                {'cpus': '', 'cpu_usage': 0,",
            "                                  'mem': {'total': 256, 'used': 0},",
            "                                  'id': 3}]}",
            "        with test.nested(",
            "                mock.patch.object(host.Host, \"get_capabilities\",",
            "                                  return_value=caps),",
            "                mock.patch.object(",
            "                    hardware, 'get_vcpu_pin_set',",
            "                    return_value=set([0, 1, 3, 4, 5])),",
            "                mock.patch.object(host.Host, 'get_online_cpus',",
            "                                  return_value=set([0, 1, 2, 3, 6])),",
            "                ):",
            "            got_topo = drvr._get_host_numa_topology()",
            "            got_topo_dict = got_topo._to_dict()",
            "            self.assertThat(",
            "                    expected_topo_dict, matchers.DictMatches(got_topo_dict))",
            "",
            "            if mempages:",
            "                # cells 0",
            "                self.assertEqual(4, got_topo.cells[0].mempages[0].size_kb)",
            "                self.assertEqual(0, got_topo.cells[0].mempages[0].total)",
            "                self.assertEqual(2048, got_topo.cells[0].mempages[1].size_kb)",
            "                self.assertEqual(0, got_topo.cells[0].mempages[1].total)",
            "                # cells 1",
            "                self.assertEqual(4, got_topo.cells[1].mempages[0].size_kb)",
            "                self.assertEqual(1024, got_topo.cells[1].mempages[0].total)",
            "                self.assertEqual(2048, got_topo.cells[1].mempages[1].size_kb)",
            "                self.assertEqual(1, got_topo.cells[1].mempages[1].total)",
            "            else:",
            "                self.assertEqual([], got_topo.cells[0].mempages)",
            "                self.assertEqual([], got_topo.cells[1].mempages)",
            "",
            "            self.assertEqual(expected_topo_dict, got_topo_dict)",
            "            self.assertEqual(set([]), got_topo.cells[0].pinned_cpus)",
            "            self.assertEqual(set([]), got_topo.cells[1].pinned_cpus)",
            "            self.assertEqual(set([]), got_topo.cells[2].pinned_cpus)",
            "            self.assertEqual(set([]), got_topo.cells[3].pinned_cpus)",
            "            self.assertEqual([set([0, 1])], got_topo.cells[0].siblings)",
            "            self.assertEqual([], got_topo.cells[1].siblings)",
            "",
            "    @mock.patch.object(host.Host, 'has_min_version', return_value=True)",
            "    def test_get_host_numa_topology(self, mock_version):",
            "        self._test_get_host_numa_topology(mempages=True)",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getType')",
            "    @mock.patch.object(fakelibvirt.Connection, 'getVersion')",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion')",
            "    def test_get_host_numa_topology_no_mempages(self, mock_lib_version,",
            "                                                mock_version, mock_type):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        mock_lib_version.return_value = versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_HUGEPAGE_VERSION) - 1",
            "        mock_version.return_value = versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_QEMU_NUMA_HUGEPAGE_VERSION)",
            "        mock_type.return_value = host.HV_DRIVER_QEMU",
            "        self._test_get_host_numa_topology(mempages=False)",
            "",
            "    def test_get_host_numa_topology_empty(self):",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = arch.X86_64",
            "        caps.host.topology = None",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        with test.nested(",
            "            mock.patch.object(host.Host, 'has_min_version', return_value=True),",
            "            mock.patch.object(host.Host, \"get_capabilities\",",
            "                              return_value=caps)",
            "        ) as (has_min_version, get_caps):",
            "            self.assertIsNone(drvr._get_host_numa_topology())",
            "        self.assertEqual(2, get_caps.call_count)",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getType')",
            "    @mock.patch.object(fakelibvirt.Connection, 'getVersion')",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion')",
            "    def test_get_host_numa_topology_old_version(self, mock_lib_version,",
            "                                                mock_version, mock_type):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        mock_lib_version.return_value = versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_NUMA_VERSION) - 1",
            "        mock_version.return_value = versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_QEMU_NUMA_HUGEPAGE_VERSION)",
            "        mock_type.return_value = host.HV_DRIVER_QEMU",
            "        self.assertIsNone(drvr._get_host_numa_topology())",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getType')",
            "    @mock.patch.object(fakelibvirt.Connection, 'getVersion')",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion')",
            "    def test_get_host_numa_topology_xen(self, mock_lib_version,",
            "                                        mock_version, mock_type):",
            "        self.flags(virt_type='xen', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        mock_lib_version.return_value = versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_NUMA_VERSION)",
            "        mock_version.return_value = versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_QEMU_NUMA_HUGEPAGE_VERSION)",
            "        mock_type.return_value = host.HV_DRIVER_XEN",
            "        self.assertIsNone(drvr._get_host_numa_topology())",
            "",
            "    def test_diagnostic_vcpus_exception(self):",
            "        xml = \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                            <target dev='vda' bus='virtio'/>",
            "                        </disk>",
            "                        <disk type='block'>",
            "                            <source dev='/path/to/dev/1'/>",
            "                            <target dev='vdb' bus='virtio'/>",
            "                        </disk>",
            "                        <interface type='network'>",
            "                            <mac address='52:54:00:a4:38:38'/>",
            "                            <source network='default'/>",
            "                            <target dev='vnet0'/>",
            "                        </interface>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\"",
            "",
            "        class DiagFakeDomain(FakeVirtDomain):",
            "",
            "            def __init__(self):",
            "                super(DiagFakeDomain, self).__init__(fake_xml=xml)",
            "",
            "            def vcpus(self):",
            "                raise fakelibvirt.libvirtError('vcpus missing')",
            "",
            "            def blockStats(self, path):",
            "                return (169, 688640, 0, 0, -1)",
            "",
            "            def interfaceStats(self, path):",
            "                return (4408, 82, 0, 0, 0, 0, 0, 0)",
            "",
            "            def memoryStats(self):",
            "                return {'actual': 220160, 'rss': 200164}",
            "",
            "            def maxMemory(self):",
            "                return 280160",
            "",
            "        def fake_get_domain(self, instance):",
            "            return DiagFakeDomain()",
            "",
            "        self.stubs.Set(host.Host, \"get_domain\", fake_get_domain)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        actual = drvr.get_diagnostics(instance)",
            "        expect = {'vda_read': 688640,",
            "                  'vda_read_req': 169,",
            "                  'vda_write': 0,",
            "                  'vda_write_req': 0,",
            "                  'vda_errors': -1,",
            "                  'vdb_read': 688640,",
            "                  'vdb_read_req': 169,",
            "                  'vdb_write': 0,",
            "                  'vdb_write_req': 0,",
            "                  'vdb_errors': -1,",
            "                  'memory': 280160,",
            "                  'memory-actual': 220160,",
            "                  'memory-rss': 200164,",
            "                  'vnet0_rx': 4408,",
            "                  'vnet0_rx_drop': 0,",
            "                  'vnet0_rx_errors': 0,",
            "                  'vnet0_rx_packets': 82,",
            "                  'vnet0_tx': 0,",
            "                  'vnet0_tx_drop': 0,",
            "                  'vnet0_tx_errors': 0,",
            "                  'vnet0_tx_packets': 0,",
            "                  }",
            "        self.assertEqual(actual, expect)",
            "",
            "        lt = datetime.datetime(2012, 11, 22, 12, 00, 00)",
            "        diags_time = datetime.datetime(2012, 11, 22, 12, 00, 10)",
            "        self.useFixture(utils_fixture.TimeFixture(diags_time))",
            "",
            "        instance.launched_at = lt",
            "        actual = drvr.get_instance_diagnostics(instance)",
            "        expected = {'config_drive': False,",
            "                    'cpu_details': [],",
            "                    'disk_details': [{'errors_count': 0,",
            "                                      'id': '',",
            "                                      'read_bytes': 688640,",
            "                                      'read_requests': 169,",
            "                                      'write_bytes': 0,",
            "                                      'write_requests': 0},",
            "                                     {'errors_count': 0,",
            "                                      'id': '',",
            "                                      'read_bytes': 688640,",
            "                                      'read_requests': 169,",
            "                                      'write_bytes': 0,",
            "                                      'write_requests': 0}],",
            "                    'driver': 'libvirt',",
            "                    'hypervisor_os': 'linux',",
            "                    'memory_details': {'maximum': 2048, 'used': 1234},",
            "                    'nic_details': [{'mac_address': '52:54:00:a4:38:38',",
            "                                     'rx_drop': 0,",
            "                                     'rx_errors': 0,",
            "                                     'rx_octets': 4408,",
            "                                     'rx_packets': 82,",
            "                                     'tx_drop': 0,",
            "                                     'tx_errors': 0,",
            "                                     'tx_octets': 0,",
            "                                     'tx_packets': 0}],",
            "                    'state': 'running',",
            "                    'uptime': 10,",
            "                    'version': '1.0'}",
            "        self.assertEqual(expected, actual.serialize())",
            "",
            "    def test_diagnostic_blockstats_exception(self):",
            "        xml = \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                            <target dev='vda' bus='virtio'/>",
            "                        </disk>",
            "                        <disk type='block'>",
            "                            <source dev='/path/to/dev/1'/>",
            "                            <target dev='vdb' bus='virtio'/>",
            "                        </disk>",
            "                        <interface type='network'>",
            "                            <mac address='52:54:00:a4:38:38'/>",
            "                            <source network='default'/>",
            "                            <target dev='vnet0'/>",
            "                        </interface>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\"",
            "",
            "        class DiagFakeDomain(FakeVirtDomain):",
            "",
            "            def __init__(self):",
            "                super(DiagFakeDomain, self).__init__(fake_xml=xml)",
            "",
            "            def vcpus(self):",
            "                return ([(0, 1, 15340000000, 0),",
            "                         (1, 1, 1640000000, 0),",
            "                         (2, 1, 3040000000, 0),",
            "                         (3, 1, 1420000000, 0)],",
            "                        [(True, False),",
            "                         (True, False),",
            "                         (True, False),",
            "                         (True, False)])",
            "",
            "            def blockStats(self, path):",
            "                raise fakelibvirt.libvirtError('blockStats missing')",
            "",
            "            def interfaceStats(self, path):",
            "                return (4408, 82, 0, 0, 0, 0, 0, 0)",
            "",
            "            def memoryStats(self):",
            "                return {'actual': 220160, 'rss': 200164}",
            "",
            "            def maxMemory(self):",
            "                return 280160",
            "",
            "        def fake_get_domain(self, instance):",
            "            return DiagFakeDomain()",
            "",
            "        self.stubs.Set(host.Host, \"get_domain\", fake_get_domain)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        actual = drvr.get_diagnostics(instance)",
            "        expect = {'cpu0_time': 15340000000,",
            "                  'cpu1_time': 1640000000,",
            "                  'cpu2_time': 3040000000,",
            "                  'cpu3_time': 1420000000,",
            "                  'memory': 280160,",
            "                  'memory-actual': 220160,",
            "                  'memory-rss': 200164,",
            "                  'vnet0_rx': 4408,",
            "                  'vnet0_rx_drop': 0,",
            "                  'vnet0_rx_errors': 0,",
            "                  'vnet0_rx_packets': 82,",
            "                  'vnet0_tx': 0,",
            "                  'vnet0_tx_drop': 0,",
            "                  'vnet0_tx_errors': 0,",
            "                  'vnet0_tx_packets': 0,",
            "                  }",
            "        self.assertEqual(actual, expect)",
            "",
            "        lt = datetime.datetime(2012, 11, 22, 12, 00, 00)",
            "        diags_time = datetime.datetime(2012, 11, 22, 12, 00, 10)",
            "        self.useFixture(utils_fixture.TimeFixture(diags_time))",
            "",
            "        instance.launched_at = lt",
            "        actual = drvr.get_instance_diagnostics(instance)",
            "        expected = {'config_drive': False,",
            "                    'cpu_details': [{'time': 15340000000},",
            "                                    {'time': 1640000000},",
            "                                    {'time': 3040000000},",
            "                                    {'time': 1420000000}],",
            "                    'disk_details': [],",
            "                    'driver': 'libvirt',",
            "                    'hypervisor_os': 'linux',",
            "                    'memory_details': {'maximum': 2048, 'used': 1234},",
            "                    'nic_details': [{'mac_address': '52:54:00:a4:38:38',",
            "                                     'rx_drop': 0,",
            "                                     'rx_errors': 0,",
            "                                     'rx_octets': 4408,",
            "                                     'rx_packets': 82,",
            "                                     'tx_drop': 0,",
            "                                     'tx_errors': 0,",
            "                                     'tx_octets': 0,",
            "                                     'tx_packets': 0}],",
            "                    'state': 'running',",
            "                    'uptime': 10,",
            "                    'version': '1.0'}",
            "        self.assertEqual(expected, actual.serialize())",
            "",
            "    def test_diagnostic_interfacestats_exception(self):",
            "        xml = \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                            <target dev='vda' bus='virtio'/>",
            "                        </disk>",
            "                        <disk type='block'>",
            "                            <source dev='/path/to/dev/1'/>",
            "                            <target dev='vdb' bus='virtio'/>",
            "                        </disk>",
            "                        <interface type='network'>",
            "                            <mac address='52:54:00:a4:38:38'/>",
            "                            <source network='default'/>",
            "                            <target dev='vnet0'/>",
            "                        </interface>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\"",
            "",
            "        class DiagFakeDomain(FakeVirtDomain):",
            "",
            "            def __init__(self):",
            "                super(DiagFakeDomain, self).__init__(fake_xml=xml)",
            "",
            "            def vcpus(self):",
            "                return ([(0, 1, 15340000000, 0),",
            "                         (1, 1, 1640000000, 0),",
            "                         (2, 1, 3040000000, 0),",
            "                         (3, 1, 1420000000, 0)],",
            "                        [(True, False),",
            "                         (True, False),",
            "                         (True, False),",
            "                         (True, False)])",
            "",
            "            def blockStats(self, path):",
            "                return (169, 688640, 0, 0, -1)",
            "",
            "            def interfaceStats(self, path):",
            "                raise fakelibvirt.libvirtError('interfaceStat missing')",
            "",
            "            def memoryStats(self):",
            "                return {'actual': 220160, 'rss': 200164}",
            "",
            "            def maxMemory(self):",
            "                return 280160",
            "",
            "        def fake_get_domain(self, instance):",
            "            return DiagFakeDomain()",
            "",
            "        self.stubs.Set(host.Host, \"get_domain\", fake_get_domain)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        actual = drvr.get_diagnostics(instance)",
            "        expect = {'cpu0_time': 15340000000,",
            "                  'cpu1_time': 1640000000,",
            "                  'cpu2_time': 3040000000,",
            "                  'cpu3_time': 1420000000,",
            "                  'vda_read': 688640,",
            "                  'vda_read_req': 169,",
            "                  'vda_write': 0,",
            "                  'vda_write_req': 0,",
            "                  'vda_errors': -1,",
            "                  'vdb_read': 688640,",
            "                  'vdb_read_req': 169,",
            "                  'vdb_write': 0,",
            "                  'vdb_write_req': 0,",
            "                  'vdb_errors': -1,",
            "                  'memory': 280160,",
            "                  'memory-actual': 220160,",
            "                  'memory-rss': 200164,",
            "                  }",
            "        self.assertEqual(actual, expect)",
            "",
            "        lt = datetime.datetime(2012, 11, 22, 12, 00, 00)",
            "        diags_time = datetime.datetime(2012, 11, 22, 12, 00, 10)",
            "        self.useFixture(utils_fixture.TimeFixture(diags_time))",
            "",
            "        instance.launched_at = lt",
            "        actual = drvr.get_instance_diagnostics(instance)",
            "        expected = {'config_drive': False,",
            "                    'cpu_details': [{'time': 15340000000},",
            "                                    {'time': 1640000000},",
            "                                    {'time': 3040000000},",
            "                                    {'time': 1420000000}],",
            "                    'disk_details': [{'errors_count': 0,",
            "                                      'id': '',",
            "                                      'read_bytes': 688640,",
            "                                      'read_requests': 169,",
            "                                      'write_bytes': 0,",
            "                                      'write_requests': 0},",
            "                                     {'errors_count': 0,",
            "                                      'id': '',",
            "                                      'read_bytes': 688640,",
            "                                      'read_requests': 169,",
            "                                      'write_bytes': 0,",
            "                                      'write_requests': 0}],",
            "                    'driver': 'libvirt',",
            "                    'hypervisor_os': 'linux',",
            "                    'memory_details': {'maximum': 2048, 'used': 1234},",
            "                    'nic_details': [],",
            "                    'state': 'running',",
            "                    'uptime': 10,",
            "                    'version': '1.0'}",
            "        self.assertEqual(expected, actual.serialize())",
            "",
            "    def test_diagnostic_memorystats_exception(self):",
            "        xml = \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                            <target dev='vda' bus='virtio'/>",
            "                        </disk>",
            "                        <disk type='block'>",
            "                            <source dev='/path/to/dev/1'/>",
            "                            <target dev='vdb' bus='virtio'/>",
            "                        </disk>",
            "                        <interface type='network'>",
            "                            <mac address='52:54:00:a4:38:38'/>",
            "                            <source network='default'/>",
            "                            <target dev='vnet0'/>",
            "                        </interface>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\"",
            "",
            "        class DiagFakeDomain(FakeVirtDomain):",
            "",
            "            def __init__(self):",
            "                super(DiagFakeDomain, self).__init__(fake_xml=xml)",
            "",
            "            def vcpus(self):",
            "                return ([(0, 1, 15340000000, 0),",
            "                         (1, 1, 1640000000, 0),",
            "                         (2, 1, 3040000000, 0),",
            "                         (3, 1, 1420000000, 0)],",
            "                        [(True, False),",
            "                         (True, False),",
            "                         (True, False),",
            "                         (True, False)])",
            "",
            "            def blockStats(self, path):",
            "                return (169, 688640, 0, 0, -1)",
            "",
            "            def interfaceStats(self, path):",
            "                return (4408, 82, 0, 0, 0, 0, 0, 0)",
            "",
            "            def memoryStats(self):",
            "                raise fakelibvirt.libvirtError('memoryStats missing')",
            "",
            "            def maxMemory(self):",
            "                return 280160",
            "",
            "        def fake_get_domain(self, instance):",
            "            return DiagFakeDomain()",
            "",
            "        self.stubs.Set(host.Host, \"get_domain\", fake_get_domain)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        actual = drvr.get_diagnostics(instance)",
            "        expect = {'cpu0_time': 15340000000,",
            "                  'cpu1_time': 1640000000,",
            "                  'cpu2_time': 3040000000,",
            "                  'cpu3_time': 1420000000,",
            "                  'vda_read': 688640,",
            "                  'vda_read_req': 169,",
            "                  'vda_write': 0,",
            "                  'vda_write_req': 0,",
            "                  'vda_errors': -1,",
            "                  'vdb_read': 688640,",
            "                  'vdb_read_req': 169,",
            "                  'vdb_write': 0,",
            "                  'vdb_write_req': 0,",
            "                  'vdb_errors': -1,",
            "                  'memory': 280160,",
            "                  'vnet0_rx': 4408,",
            "                  'vnet0_rx_drop': 0,",
            "                  'vnet0_rx_errors': 0,",
            "                  'vnet0_rx_packets': 82,",
            "                  'vnet0_tx': 0,",
            "                  'vnet0_tx_drop': 0,",
            "                  'vnet0_tx_errors': 0,",
            "                  'vnet0_tx_packets': 0,",
            "                  }",
            "        self.assertEqual(actual, expect)",
            "",
            "        lt = datetime.datetime(2012, 11, 22, 12, 00, 00)",
            "        diags_time = datetime.datetime(2012, 11, 22, 12, 00, 10)",
            "        self.useFixture(utils_fixture.TimeFixture(diags_time))",
            "",
            "        instance.launched_at = lt",
            "        actual = drvr.get_instance_diagnostics(instance)",
            "        expected = {'config_drive': False,",
            "                    'cpu_details': [{'time': 15340000000},",
            "                                    {'time': 1640000000},",
            "                                    {'time': 3040000000},",
            "                                    {'time': 1420000000}],",
            "                    'disk_details': [{'errors_count': 0,",
            "                                      'id': '',",
            "                                      'read_bytes': 688640,",
            "                                      'read_requests': 169,",
            "                                      'write_bytes': 0,",
            "                                      'write_requests': 0},",
            "                                     {'errors_count': 0,",
            "                                      'id': '',",
            "                                      'read_bytes': 688640,",
            "                                      'read_requests': 169,",
            "                                      'write_bytes': 0,",
            "                                      'write_requests': 0}],",
            "                    'driver': 'libvirt',",
            "                    'hypervisor_os': 'linux',",
            "                    'memory_details': {'maximum': 2048, 'used': 1234},",
            "                    'nic_details': [{'mac_address': '52:54:00:a4:38:38',",
            "                                     'rx_drop': 0,",
            "                                     'rx_errors': 0,",
            "                                     'rx_octets': 4408,",
            "                                     'rx_packets': 82,",
            "                                     'tx_drop': 0,",
            "                                     'tx_errors': 0,",
            "                                     'tx_octets': 0,",
            "                                     'tx_packets': 0}],",
            "                    'state': 'running',",
            "                    'uptime': 10,",
            "                    'version': '1.0'}",
            "        self.assertEqual(expected, actual.serialize())",
            "",
            "    def test_diagnostic_full(self):",
            "        xml = \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                            <target dev='vda' bus='virtio'/>",
            "                        </disk>",
            "                        <disk type='block'>",
            "                            <source dev='/path/to/dev/1'/>",
            "                            <target dev='vdb' bus='virtio'/>",
            "                        </disk>",
            "                        <interface type='network'>",
            "                            <mac address='52:54:00:a4:38:38'/>",
            "                            <source network='default'/>",
            "                            <target dev='vnet0'/>",
            "                        </interface>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\"",
            "",
            "        class DiagFakeDomain(FakeVirtDomain):",
            "",
            "            def __init__(self):",
            "                super(DiagFakeDomain, self).__init__(fake_xml=xml)",
            "",
            "            def vcpus(self):",
            "                return ([(0, 1, 15340000000, 0),",
            "                         (1, 1, 1640000000, 0),",
            "                         (2, 1, 3040000000, 0),",
            "                         (3, 1, 1420000000, 0)],",
            "                        [(True, False),",
            "                         (True, False),",
            "                         (True, False),",
            "                         (True, False)])",
            "",
            "            def blockStats(self, path):",
            "                return (169, 688640, 0, 0, -1)",
            "",
            "            def interfaceStats(self, path):",
            "                return (4408, 82, 0, 0, 0, 0, 0, 0)",
            "",
            "            def memoryStats(self):",
            "                return {'actual': 220160, 'rss': 200164}",
            "",
            "            def maxMemory(self):",
            "                return 280160",
            "",
            "        def fake_get_domain(self, instance):",
            "            return DiagFakeDomain()",
            "",
            "        self.stubs.Set(host.Host, \"get_domain\", fake_get_domain)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        actual = drvr.get_diagnostics(instance)",
            "        expect = {'cpu0_time': 15340000000,",
            "                  'cpu1_time': 1640000000,",
            "                  'cpu2_time': 3040000000,",
            "                  'cpu3_time': 1420000000,",
            "                  'vda_read': 688640,",
            "                  'vda_read_req': 169,",
            "                  'vda_write': 0,",
            "                  'vda_write_req': 0,",
            "                  'vda_errors': -1,",
            "                  'vdb_read': 688640,",
            "                  'vdb_read_req': 169,",
            "                  'vdb_write': 0,",
            "                  'vdb_write_req': 0,",
            "                  'vdb_errors': -1,",
            "                  'memory': 280160,",
            "                  'memory-actual': 220160,",
            "                  'memory-rss': 200164,",
            "                  'vnet0_rx': 4408,",
            "                  'vnet0_rx_drop': 0,",
            "                  'vnet0_rx_errors': 0,",
            "                  'vnet0_rx_packets': 82,",
            "                  'vnet0_tx': 0,",
            "                  'vnet0_tx_drop': 0,",
            "                  'vnet0_tx_errors': 0,",
            "                  'vnet0_tx_packets': 0,",
            "                  }",
            "        self.assertEqual(actual, expect)",
            "",
            "        lt = datetime.datetime(2012, 11, 22, 12, 00, 00)",
            "        diags_time = datetime.datetime(2012, 11, 22, 12, 00, 10)",
            "        self.useFixture(utils_fixture.TimeFixture(diags_time))",
            "",
            "        instance.launched_at = lt",
            "        actual = drvr.get_instance_diagnostics(instance)",
            "        expected = {'config_drive': False,",
            "                    'cpu_details': [{'time': 15340000000},",
            "                                    {'time': 1640000000},",
            "                                    {'time': 3040000000},",
            "                                    {'time': 1420000000}],",
            "                    'disk_details': [{'errors_count': 0,",
            "                                      'id': '',",
            "                                      'read_bytes': 688640,",
            "                                      'read_requests': 169,",
            "                                      'write_bytes': 0,",
            "                                      'write_requests': 0},",
            "                                     {'errors_count': 0,",
            "                                      'id': '',",
            "                                      'read_bytes': 688640,",
            "                                      'read_requests': 169,",
            "                                      'write_bytes': 0,",
            "                                      'write_requests': 0}],",
            "                    'driver': 'libvirt',",
            "                    'hypervisor_os': 'linux',",
            "                    'memory_details': {'maximum': 2048, 'used': 1234},",
            "                    'nic_details': [{'mac_address': '52:54:00:a4:38:38',",
            "                                     'rx_drop': 0,",
            "                                     'rx_errors': 0,",
            "                                     'rx_octets': 4408,",
            "                                     'rx_packets': 82,",
            "                                     'tx_drop': 0,",
            "                                     'tx_errors': 0,",
            "                                     'tx_octets': 0,",
            "                                     'tx_packets': 0}],",
            "                    'state': 'running',",
            "                    'uptime': 10,",
            "                    'version': '1.0'}",
            "        self.assertEqual(expected, actual.serialize())",
            "",
            "    @mock.patch.object(host.Host, 'get_domain')",
            "    def test_diagnostic_full_with_multiple_interfaces(self, mock_get_domain):",
            "        xml = \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                            <target dev='vda' bus='virtio'/>",
            "                        </disk>",
            "                        <disk type='block'>",
            "                            <source dev='/path/to/dev/1'/>",
            "                            <target dev='vdb' bus='virtio'/>",
            "                        </disk>",
            "                        <interface type='network'>",
            "                            <mac address='52:54:00:a4:38:38'/>",
            "                            <source network='default'/>",
            "                            <target dev='vnet0'/>",
            "                        </interface>",
            "                        <interface type=\"bridge\">",
            "                            <mac address=\"53:55:00:a5:39:39\"/>",
            "                            <model type=\"virtio\"/>",
            "                            <target dev=\"br0\"/>",
            "                        </interface>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\"",
            "",
            "        class DiagFakeDomain(FakeVirtDomain):",
            "",
            "            def __init__(self):",
            "                super(DiagFakeDomain, self).__init__(fake_xml=xml)",
            "",
            "            def vcpus(self):",
            "                return ([(0, 1, 15340000000, 0),",
            "                         (1, 1, 1640000000, 0),",
            "                         (2, 1, 3040000000, 0),",
            "                         (3, 1, 1420000000, 0)],",
            "                        [(True, False),",
            "                         (True, False),",
            "                         (True, False),",
            "                         (True, False)])",
            "",
            "            def blockStats(self, path):",
            "                return (169, 688640, 0, 0, -1)",
            "",
            "            def interfaceStats(self, path):",
            "                return (4408, 82, 0, 0, 0, 0, 0, 0)",
            "",
            "            def memoryStats(self):",
            "                return {'actual': 220160, 'rss': 200164}",
            "",
            "            def maxMemory(self):",
            "                return 280160",
            "",
            "        def fake_get_domain(self):",
            "            return DiagFakeDomain()",
            "",
            "        mock_get_domain.side_effect = fake_get_domain",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        actual = drvr.get_diagnostics(instance)",
            "        expect = {'cpu0_time': 15340000000,",
            "                  'cpu1_time': 1640000000,",
            "                  'cpu2_time': 3040000000,",
            "                  'cpu3_time': 1420000000,",
            "                  'vda_read': 688640,",
            "                  'vda_read_req': 169,",
            "                  'vda_write': 0,",
            "                  'vda_write_req': 0,",
            "                  'vda_errors': -1,",
            "                  'vdb_read': 688640,",
            "                  'vdb_read_req': 169,",
            "                  'vdb_write': 0,",
            "                  'vdb_write_req': 0,",
            "                  'vdb_errors': -1,",
            "                  'memory': 280160,",
            "                  'memory-actual': 220160,",
            "                  'memory-rss': 200164,",
            "                  'vnet0_rx': 4408,",
            "                  'vnet0_rx_drop': 0,",
            "                  'vnet0_rx_errors': 0,",
            "                  'vnet0_rx_packets': 82,",
            "                  'vnet0_tx': 0,",
            "                  'vnet0_tx_drop': 0,",
            "                  'vnet0_tx_errors': 0,",
            "                  'vnet0_tx_packets': 0,",
            "                  'br0_rx': 4408,",
            "                  'br0_rx_drop': 0,",
            "                  'br0_rx_errors': 0,",
            "                  'br0_rx_packets': 82,",
            "                  'br0_tx': 0,",
            "                  'br0_tx_drop': 0,",
            "                  'br0_tx_errors': 0,",
            "                  'br0_tx_packets': 0,",
            "                  }",
            "        self.assertEqual(actual, expect)",
            "",
            "        lt = datetime.datetime(2012, 11, 22, 12, 00, 00)",
            "        diags_time = datetime.datetime(2012, 11, 22, 12, 00, 10)",
            "        self.useFixture(utils_fixture.TimeFixture(diags_time))",
            "",
            "        instance.launched_at = lt",
            "        actual = drvr.get_instance_diagnostics(instance)",
            "        expected = {'config_drive': False,",
            "                    'cpu_details': [{'time': 15340000000},",
            "                                    {'time': 1640000000},",
            "                                    {'time': 3040000000},",
            "                                    {'time': 1420000000}],",
            "                    'disk_details': [{'errors_count': 0,",
            "                                      'id': '',",
            "                                      'read_bytes': 688640,",
            "                                      'read_requests': 169,",
            "                                      'write_bytes': 0,",
            "                                      'write_requests': 0},",
            "                                     {'errors_count': 0,",
            "                                      'id': '',",
            "                                      'read_bytes': 688640,",
            "                                      'read_requests': 169,",
            "                                      'write_bytes': 0,",
            "                                      'write_requests': 0}],",
            "                    'driver': 'libvirt',",
            "                    'hypervisor_os': 'linux',",
            "                    'memory_details': {'maximum': 2048, 'used': 1234},",
            "                    'nic_details': [{'mac_address': '52:54:00:a4:38:38',",
            "                                     'rx_drop': 0,",
            "                                     'rx_errors': 0,",
            "                                     'rx_octets': 4408,",
            "                                     'rx_packets': 82,",
            "                                     'tx_drop': 0,",
            "                                     'tx_errors': 0,",
            "                                     'tx_octets': 0,",
            "                                     'tx_packets': 0},",
            "                                    {'mac_address': '53:55:00:a5:39:39',",
            "                                     'rx_drop': 0,",
            "                                     'rx_errors': 0,",
            "                                     'rx_octets': 4408,",
            "                                     'rx_packets': 82,",
            "                                     'tx_drop': 0,",
            "                                     'tx_errors': 0,",
            "                                     'tx_octets': 0,",
            "                                     'tx_packets': 0}],",
            "                    'state': 'running',",
            "                    'uptime': 10.,",
            "                    'version': '1.0'}",
            "        self.assertEqual(expected, actual.serialize())",
            "",
            "    @mock.patch.object(host.Host, \"list_instance_domains\")",
            "    def test_failing_vcpu_count(self, mock_list):",
            "        \"\"\"Domain can fail to return the vcpu description in case it's",
            "        just starting up or shutting down. Make sure None is handled",
            "        gracefully.",
            "        \"\"\"",
            "",
            "        class DiagFakeDomain(object):",
            "            def __init__(self, vcpus):",
            "                self._vcpus = vcpus",
            "",
            "            def vcpus(self):",
            "                if self._vcpus is None:",
            "                    raise fakelibvirt.libvirtError(\"fake-error\")",
            "                else:",
            "                    return ([[1, 2, 3, 4]] * self._vcpus, [True] * self._vcpus)",
            "",
            "            def ID(self):",
            "                return 1",
            "",
            "            def name(self):",
            "                return \"instance000001\"",
            "",
            "            def UUIDString(self):",
            "                return \"19479fee-07a5-49bb-9138-d3738280d63c\"",
            "",
            "        mock_list.return_value = [",
            "            DiagFakeDomain(None), DiagFakeDomain(5)]",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        self.assertEqual(5, drvr._get_vcpu_used())",
            "        mock_list.assert_called_with(only_guests=True, only_running=True)",
            "",
            "    @mock.patch.object(host.Host, \"list_instance_domains\")",
            "    def test_failing_vcpu_count_none(self, mock_list):",
            "        \"\"\"Domain will return zero if the current number of vcpus used",
            "        is None. This is in case of VM state starting up or shutting",
            "        down. None type returned is counted as zero.",
            "        \"\"\"",
            "",
            "        class DiagFakeDomain(object):",
            "            def __init__(self):",
            "                pass",
            "",
            "            def vcpus(self):",
            "                return None",
            "",
            "            def ID(self):",
            "                return 1",
            "",
            "            def name(self):",
            "                return \"instance000001\"",
            "",
            "        mock_list.return_value = [DiagFakeDomain()]",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertEqual(0, drvr._get_vcpu_used())",
            "        mock_list.assert_called_with(only_guests=True, only_running=True)",
            "",
            "    def test_get_instance_capabilities(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        def get_host_capabilities_stub(self):",
            "            caps = vconfig.LibvirtConfigCaps()",
            "",
            "            guest = vconfig.LibvirtConfigGuest()",
            "            guest.ostype = 'hvm'",
            "            guest.arch = arch.X86_64",
            "            guest.domtype = ['kvm', 'qemu']",
            "            caps.guests.append(guest)",
            "",
            "            guest = vconfig.LibvirtConfigGuest()",
            "            guest.ostype = 'hvm'",
            "            guest.arch = arch.I686",
            "            guest.domtype = ['kvm']",
            "            caps.guests.append(guest)",
            "",
            "            return caps",
            "",
            "        self.stubs.Set(host.Host, \"get_capabilities\",",
            "                       get_host_capabilities_stub)",
            "",
            "        want = [(arch.X86_64, 'kvm', 'hvm'),",
            "                (arch.X86_64, 'qemu', 'hvm'),",
            "                (arch.I686, 'kvm', 'hvm')]",
            "        got = drvr._get_instance_capabilities()",
            "        self.assertEqual(want, got)",
            "",
            "    def test_set_cache_mode(self):",
            "        self.flags(disk_cachemodes=['file=directsync'], group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        fake_conf = FakeConfigGuestDisk()",
            "",
            "        fake_conf.source_type = 'file'",
            "        drvr._set_cache_mode(fake_conf)",
            "        self.assertEqual(fake_conf.driver_cache, 'directsync')",
            "",
            "    def test_set_cache_mode_invalid_mode(self):",
            "        self.flags(disk_cachemodes=['file=FAKE'], group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        fake_conf = FakeConfigGuestDisk()",
            "",
            "        fake_conf.source_type = 'file'",
            "        drvr._set_cache_mode(fake_conf)",
            "        self.assertIsNone(fake_conf.driver_cache)",
            "",
            "    def test_set_cache_mode_invalid_object(self):",
            "        self.flags(disk_cachemodes=['file=directsync'], group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        fake_conf = FakeConfigGuest()",
            "",
            "        fake_conf.driver_cache = 'fake'",
            "        drvr._set_cache_mode(fake_conf)",
            "        self.assertEqual(fake_conf.driver_cache, 'fake')",
            "",
            "    @mock.patch('os.unlink')",
            "    @mock.patch.object(os.path, 'exists')",
            "    def _test_shared_storage_detection(self, is_same,",
            "                                       mock_exists, mock_unlink):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        drvr.get_host_ip_addr = mock.MagicMock(return_value='bar')",
            "        mock_exists.return_value = is_same",
            "        with test.nested(",
            "            mock.patch.object(drvr._remotefs, 'create_file'),",
            "            mock.patch.object(drvr._remotefs, 'remove_file')",
            "        ) as (mock_rem_fs_create, mock_rem_fs_remove):",
            "            result = drvr._is_storage_shared_with('host', '/path')",
            "        mock_rem_fs_create.assert_any_call('host', mock.ANY)",
            "        create_args, create_kwargs = mock_rem_fs_create.call_args",
            "        self.assertTrue(create_args[1].startswith('/path'))",
            "        if is_same:",
            "            mock_unlink.assert_called_once_with(mock.ANY)",
            "        else:",
            "            mock_rem_fs_remove.assert_called_with('host', mock.ANY)",
            "            remove_args, remove_kwargs = mock_rem_fs_remove.call_args",
            "            self.assertTrue(remove_args[1].startswith('/path'))",
            "        return result",
            "",
            "    def test_shared_storage_detection_same_host(self):",
            "        self.assertTrue(self._test_shared_storage_detection(True))",
            "",
            "    def test_shared_storage_detection_different_host(self):",
            "        self.assertFalse(self._test_shared_storage_detection(False))",
            "",
            "    def test_shared_storage_detection_easy(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.mox.StubOutWithMock(drvr, 'get_host_ip_addr')",
            "        self.mox.StubOutWithMock(utils, 'execute')",
            "        self.mox.StubOutWithMock(os.path, 'exists')",
            "        self.mox.StubOutWithMock(os, 'unlink')",
            "        drvr.get_host_ip_addr().AndReturn('foo')",
            "        self.mox.ReplayAll()",
            "        self.assertTrue(drvr._is_storage_shared_with('foo', '/path'))",
            "",
            "    def test_store_pid_remove_pid(self):",
            "        instance = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        popen = mock.Mock(pid=3)",
            "        drvr.job_tracker.add_job(instance, popen.pid)",
            "        self.assertIn(3, drvr.job_tracker.jobs[instance.uuid])",
            "        drvr.job_tracker.remove_job(instance, popen.pid)",
            "        self.assertNotIn(instance.uuid, drvr.job_tracker.jobs)",
            "",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_domain')",
            "    def test_get_domain_info_with_more_return(self, mock_get_domain):",
            "        instance = objects.Instance(**self.test_instance)",
            "        dom_mock = mock.MagicMock()",
            "        dom_mock.info.return_value = [",
            "            1, 2048, 737, 8, 12345, 888888",
            "        ]",
            "        dom_mock.ID.return_value = mock.sentinel.instance_id",
            "        mock_get_domain.return_value = dom_mock",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        info = drvr.get_info(instance)",
            "        self.assertEqual(1, info.state)",
            "        self.assertEqual(2048, info.max_mem_kb)",
            "        self.assertEqual(737, info.mem_kb)",
            "        self.assertEqual(8, info.num_cpu)",
            "        self.assertEqual(12345, info.cpu_time_ns)",
            "        self.assertEqual(mock.sentinel.instance_id, info.id)",
            "        dom_mock.info.assert_called_once_with()",
            "        dom_mock.ID.assert_called_once_with()",
            "        mock_get_domain.assert_called_once_with(instance)",
            "",
            "    def test_create_domain(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        mock_domain = mock.MagicMock()",
            "",
            "        guest = drvr._create_domain(domain=mock_domain)",
            "",
            "        self.assertEqual(mock_domain, guest._domain)",
            "        mock_domain.createWithFlags.assert_has_calls([mock.call(0)])",
            "",
            "    @mock.patch('nova.virt.disk.api.clean_lxc_namespace')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.get_info')",
            "    @mock.patch('nova.virt.disk.api.setup_container')",
            "    @mock.patch('oslo_utils.fileutils.ensure_tree')",
            "    @mock.patch.object(fake_libvirt_utils, 'get_instance_path')",
            "    def test_create_domain_lxc(self, mock_get_inst_path, mock_ensure_tree,",
            "                           mock_setup_container, mock_get_info, mock_clean):",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        mock_instance = mock.MagicMock()",
            "        inst_sys_meta = dict()",
            "        mock_instance.system_metadata = inst_sys_meta",
            "        mock_get_inst_path.return_value = '/tmp/'",
            "        mock_image_backend = mock.MagicMock()",
            "        drvr.image_backend = mock_image_backend",
            "        mock_image = mock.MagicMock()",
            "        mock_image.path = '/tmp/test.img'",
            "        drvr.image_backend.image.return_value = mock_image",
            "        mock_setup_container.return_value = '/dev/nbd0'",
            "        mock_get_info.return_value = hardware.InstanceInfo(",
            "            state=power_state.RUNNING)",
            "",
            "        with test.nested(",
            "            mock.patch.object(drvr, '_create_images_and_backing'),",
            "            mock.patch.object(drvr, '_is_booted_from_volume',",
            "                              return_value=False),",
            "            mock.patch.object(drvr, '_create_domain'),",
            "            mock.patch.object(drvr, 'plug_vifs'),",
            "            mock.patch.object(drvr.firewall_driver, 'setup_basic_filtering'),",
            "            mock.patch.object(drvr.firewall_driver, 'prepare_instance_filter'),",
            "            mock.patch.object(drvr.firewall_driver, 'apply_instance_filter')):",
            "            drvr._create_domain_and_network(self.context, 'xml',",
            "                                            mock_instance, [], None)",
            "",
            "        self.assertEqual('/dev/nbd0', inst_sys_meta['rootfs_device_name'])",
            "        self.assertFalse(mock_instance.called)",
            "        mock_get_inst_path.assert_has_calls([mock.call(mock_instance)])",
            "        mock_ensure_tree.assert_has_calls([mock.call('/tmp/rootfs')])",
            "        drvr.image_backend.image.assert_has_calls([mock.call(mock_instance,",
            "                                                             'disk')])",
            "",
            "        setup_container_call = mock.call(",
            "            mock_image.get_model(),",
            "            container_dir='/tmp/rootfs')",
            "        mock_setup_container.assert_has_calls([setup_container_call])",
            "        mock_get_info.assert_has_calls([mock.call(mock_instance)])",
            "        mock_clean.assert_has_calls([mock.call(container_dir='/tmp/rootfs')])",
            "",
            "    @mock.patch('nova.virt.disk.api.clean_lxc_namespace')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.get_info')",
            "    @mock.patch.object(fake_libvirt_utils, 'chown_for_id_maps')",
            "    @mock.patch('nova.virt.disk.api.setup_container')",
            "    @mock.patch('oslo_utils.fileutils.ensure_tree')",
            "    @mock.patch.object(fake_libvirt_utils, 'get_instance_path')",
            "    def test_create_domain_lxc_id_maps(self, mock_get_inst_path,",
            "                                       mock_ensure_tree, mock_setup_container,",
            "                                       mock_chown, mock_get_info, mock_clean):",
            "        self.flags(virt_type='lxc', uid_maps=[\"0:1000:100\"],",
            "                   gid_maps=[\"0:1000:100\"], group='libvirt')",
            "",
            "        def chown_side_effect(path, id_maps):",
            "            self.assertEqual('/tmp/rootfs', path)",
            "            self.assertIsInstance(id_maps[0], vconfig.LibvirtConfigGuestUIDMap)",
            "            self.assertEqual(0, id_maps[0].start)",
            "            self.assertEqual(1000, id_maps[0].target)",
            "            self.assertEqual(100, id_maps[0].count)",
            "            self.assertIsInstance(id_maps[1], vconfig.LibvirtConfigGuestGIDMap)",
            "            self.assertEqual(0, id_maps[1].start)",
            "            self.assertEqual(1000, id_maps[1].target)",
            "            self.assertEqual(100, id_maps[1].count)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        mock_instance = mock.MagicMock()",
            "        inst_sys_meta = dict()",
            "        mock_instance.system_metadata = inst_sys_meta",
            "        mock_get_inst_path.return_value = '/tmp/'",
            "        mock_image_backend = mock.MagicMock()",
            "        drvr.image_backend = mock_image_backend",
            "        mock_image = mock.MagicMock()",
            "        mock_image.path = '/tmp/test.img'",
            "        drvr.image_backend.image.return_value = mock_image",
            "        mock_setup_container.return_value = '/dev/nbd0'",
            "        mock_chown.side_effect = chown_side_effect",
            "        mock_get_info.return_value = hardware.InstanceInfo(",
            "            state=power_state.RUNNING)",
            "",
            "        with test.nested(",
            "            mock.patch.object(drvr, '_create_images_and_backing'),",
            "            mock.patch.object(drvr, '_is_booted_from_volume',",
            "                              return_value=False),",
            "            mock.patch.object(drvr, '_create_domain'),",
            "            mock.patch.object(drvr, 'plug_vifs'),",
            "            mock.patch.object(drvr.firewall_driver, 'setup_basic_filtering'),",
            "            mock.patch.object(drvr.firewall_driver, 'prepare_instance_filter'),",
            "            mock.patch.object(drvr.firewall_driver, 'apply_instance_filter')",
            "        ) as (",
            "            mock_create_images_and_backing, mock_is_booted_from_volume,",
            "            mock_create_domain, mock_plug_vifs, mock_setup_basic_filtering,",
            "            mock_prepare_instance_filter, mock_apply_instance_filter",
            "        ):",
            "            drvr._create_domain_and_network(self.context, 'xml',",
            "                                            mock_instance, [], None)",
            "",
            "        self.assertEqual('/dev/nbd0', inst_sys_meta['rootfs_device_name'])",
            "        self.assertFalse(mock_instance.called)",
            "        mock_get_inst_path.assert_has_calls([mock.call(mock_instance)])",
            "        mock_is_booted_from_volume.assert_called_once_with(mock_instance, {})",
            "        mock_ensure_tree.assert_has_calls([mock.call('/tmp/rootfs')])",
            "        drvr.image_backend.image.assert_has_calls([mock.call(mock_instance,",
            "                                                             'disk')])",
            "",
            "        setup_container_call = mock.call(",
            "            mock_image.get_model(),",
            "            container_dir='/tmp/rootfs')",
            "        mock_setup_container.assert_has_calls([setup_container_call])",
            "        mock_get_info.assert_has_calls([mock.call(mock_instance)])",
            "        mock_clean.assert_has_calls([mock.call(container_dir='/tmp/rootfs')])",
            "",
            "    @mock.patch('nova.virt.disk.api.teardown_container')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.get_info')",
            "    @mock.patch('nova.virt.disk.api.setup_container')",
            "    @mock.patch('oslo_utils.fileutils.ensure_tree')",
            "    @mock.patch.object(fake_libvirt_utils, 'get_instance_path')",
            "    def test_create_domain_lxc_not_running(self, mock_get_inst_path,",
            "                                           mock_ensure_tree,",
            "                                           mock_setup_container,",
            "                                           mock_get_info, mock_teardown):",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        mock_instance = mock.MagicMock()",
            "        inst_sys_meta = dict()",
            "        mock_instance.system_metadata = inst_sys_meta",
            "        mock_get_inst_path.return_value = '/tmp/'",
            "        mock_image_backend = mock.MagicMock()",
            "        drvr.image_backend = mock_image_backend",
            "        mock_image = mock.MagicMock()",
            "        mock_image.path = '/tmp/test.img'",
            "        drvr.image_backend.image.return_value = mock_image",
            "        mock_setup_container.return_value = '/dev/nbd0'",
            "        mock_get_info.return_value = hardware.InstanceInfo(",
            "            state=power_state.SHUTDOWN)",
            "",
            "        with test.nested(",
            "            mock.patch.object(drvr, '_create_images_and_backing'),",
            "            mock.patch.object(drvr, '_is_booted_from_volume',",
            "                              return_value=False),",
            "            mock.patch.object(drvr, '_create_domain'),",
            "            mock.patch.object(drvr, 'plug_vifs'),",
            "            mock.patch.object(drvr.firewall_driver, 'setup_basic_filtering'),",
            "            mock.patch.object(drvr.firewall_driver, 'prepare_instance_filter'),",
            "            mock.patch.object(drvr.firewall_driver, 'apply_instance_filter')):",
            "            drvr._create_domain_and_network(self.context, 'xml',",
            "                                            mock_instance, [], None)",
            "",
            "        self.assertEqual('/dev/nbd0', inst_sys_meta['rootfs_device_name'])",
            "        self.assertFalse(mock_instance.called)",
            "        mock_get_inst_path.assert_has_calls([mock.call(mock_instance)])",
            "        mock_ensure_tree.assert_has_calls([mock.call('/tmp/rootfs')])",
            "        drvr.image_backend.image.assert_has_calls([mock.call(mock_instance,",
            "                                                             'disk')])",
            "",
            "        setup_container_call = mock.call(",
            "            mock_image.get_model(),",
            "            container_dir='/tmp/rootfs')",
            "        mock_setup_container.assert_has_calls([setup_container_call])",
            "        mock_get_info.assert_has_calls([mock.call(mock_instance)])",
            "        teardown_call = mock.call(container_dir='/tmp/rootfs')",
            "        mock_teardown.assert_has_calls([teardown_call])",
            "",
            "    def test_create_domain_define_xml_fails(self):",
            "        \"\"\"Tests that the xml is logged when defining the domain fails.\"\"\"",
            "        fake_xml = \"<test>this is a test</test>\"",
            "",
            "        def fake_defineXML(xml):",
            "            self.assertEqual(fake_xml, xml)",
            "            raise fakelibvirt.libvirtError('virDomainDefineXML() failed')",
            "",
            "        def fake_safe_decode(text, *args, **kwargs):",
            "            return text + 'safe decoded'",
            "",
            "        self.log_error_called = False",
            "",
            "        def fake_error(msg, *args, **kwargs):",
            "            self.log_error_called = True",
            "            self.assertIn(fake_xml, msg % args)",
            "            self.assertIn('safe decoded', msg % args)",
            "",
            "        self.stubs.Set(encodeutils, 'safe_decode', fake_safe_decode)",
            "        self.stubs.Set(nova.virt.libvirt.guest.LOG, 'error', fake_error)",
            "",
            "        self.create_fake_libvirt_mock(defineXML=fake_defineXML)",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        self.assertRaises(fakelibvirt.libvirtError, drvr._create_domain,",
            "                          fake_xml)",
            "        self.assertTrue(self.log_error_called)",
            "",
            "    def test_create_domain_with_flags_fails(self):",
            "        \"\"\"Tests that the xml is logged when creating the domain with flags",
            "        fails",
            "        \"\"\"",
            "        fake_xml = \"<test>this is a test</test>\"",
            "        fake_domain = FakeVirtDomain(fake_xml)",
            "",
            "        def fake_createWithFlags(launch_flags):",
            "            raise fakelibvirt.libvirtError('virDomainCreateWithFlags() failed')",
            "",
            "        self.log_error_called = False",
            "",
            "        def fake_error(msg, *args, **kwargs):",
            "            self.log_error_called = True",
            "            self.assertIn(fake_xml, msg % args)",
            "",
            "        self.stubs.Set(fake_domain, 'createWithFlags', fake_createWithFlags)",
            "        self.stubs.Set(nova.virt.libvirt.guest.LOG, 'error', fake_error)",
            "",
            "        self.create_fake_libvirt_mock()",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        self.assertRaises(fakelibvirt.libvirtError, drvr._create_domain,",
            "                          domain=fake_domain)",
            "        self.assertTrue(self.log_error_called)",
            "",
            "    def test_create_domain_enable_hairpin_fails(self):",
            "        \"\"\"Tests that the xml is logged when enabling hairpin mode for the",
            "        domain fails.",
            "        \"\"\"",
            "        fake_xml = \"<test>this is a test</test>\"",
            "        fake_domain = FakeVirtDomain(fake_xml)",
            "",
            "        def fake_execute(*args, **kwargs):",
            "            raise processutils.ProcessExecutionError('error')",
            "",
            "        def fake_get_interfaces(*args):",
            "            return [\"dev\"]",
            "",
            "        self.log_error_called = False",
            "",
            "        def fake_error(msg, *args, **kwargs):",
            "            self.log_error_called = True",
            "            self.assertIn(fake_xml, msg % args)",
            "",
            "        self.stubs.Set(nova.virt.libvirt.guest.LOG, 'error', fake_error)",
            "",
            "        self.create_fake_libvirt_mock()",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.stubs.Set(nova.utils, 'execute', fake_execute)",
            "        self.stubs.Set(",
            "            nova.virt.libvirt.guest.Guest, 'get_interfaces',",
            "            fake_get_interfaces)",
            "",
            "        self.assertRaises(processutils.ProcessExecutionError,",
            "                          drvr._create_domain,",
            "                          domain=fake_domain,",
            "                          power_on=False)",
            "        self.assertTrue(self.log_error_called)",
            "",
            "    def test_get_vnc_console(self):",
            "        instance = objects.Instance(**self.test_instance)",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices>\"",
            "                    \"<graphics type='vnc' port='5900'/>\"",
            "                    \"</devices></domain>\")",
            "",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"XMLDesc\")",
            "        vdmock.XMLDesc(flags=0).AndReturn(dummyxml)",
            "",
            "        def fake_lookup(instance_name):",
            "            if instance_name == instance['name']:",
            "                return vdmock",
            "        self.create_fake_libvirt_mock(lookupByName=fake_lookup)",
            "",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        vnc_dict = drvr.get_vnc_console(self.context, instance)",
            "        self.assertEqual(vnc_dict.port, '5900')",
            "",
            "    def test_get_vnc_console_unavailable(self):",
            "        instance = objects.Instance(**self.test_instance)",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices></devices></domain>\")",
            "",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"XMLDesc\")",
            "        vdmock.XMLDesc(flags=0).AndReturn(dummyxml)",
            "",
            "        def fake_lookup(instance_name):",
            "            if instance_name == instance['name']:",
            "                return vdmock",
            "        self.create_fake_libvirt_mock(lookupByName=fake_lookup)",
            "",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertRaises(exception.ConsoleTypeUnavailable,",
            "                          drvr.get_vnc_console, self.context, instance)",
            "",
            "    def test_get_spice_console(self):",
            "        instance = objects.Instance(**self.test_instance)",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices>\"",
            "                    \"<graphics type='spice' port='5950'/>\"",
            "                    \"</devices></domain>\")",
            "",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"XMLDesc\")",
            "        vdmock.XMLDesc(flags=0).AndReturn(dummyxml)",
            "",
            "        def fake_lookup(instance_name):",
            "            if instance_name == instance['name']:",
            "                return vdmock",
            "        self.create_fake_libvirt_mock(lookupByName=fake_lookup)",
            "",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        spice_dict = drvr.get_spice_console(self.context, instance)",
            "        self.assertEqual(spice_dict.port, '5950')",
            "",
            "    def test_get_spice_console_unavailable(self):",
            "        instance = objects.Instance(**self.test_instance)",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices></devices></domain>\")",
            "",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"XMLDesc\")",
            "        vdmock.XMLDesc(flags=0).AndReturn(dummyxml)",
            "",
            "        def fake_lookup(instance_name):",
            "            if instance_name == instance['name']:",
            "                return vdmock",
            "        self.create_fake_libvirt_mock(lookupByName=fake_lookup)",
            "",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertRaises(exception.ConsoleTypeUnavailable,",
            "                          drvr.get_spice_console, self.context, instance)",
            "",
            "    def test_detach_volume_with_instance_not_found(self):",
            "        # Test that detach_volume() method does not raise exception,",
            "        # if the instance does not exist.",
            "",
            "        instance = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        with test.nested(",
            "            mock.patch.object(host.Host, 'get_domain',",
            "                              side_effect=exception.InstanceNotFound(",
            "                                  instance_id=instance.uuid)),",
            "            mock.patch.object(drvr, '_disconnect_volume')",
            "        ) as (_get_domain, _disconnect_volume):",
            "            connection_info = {'driver_volume_type': 'fake'}",
            "            drvr.detach_volume(connection_info, instance, '/dev/sda')",
            "            _get_domain.assert_called_once_with(instance)",
            "            _disconnect_volume.assert_called_once_with(connection_info,",
            "                                                       'sda')",
            "",
            "    def _test_attach_detach_interface_get_config(self, method_name):",
            "        \"\"\"Tests that the get_config() method is properly called in",
            "        attach_interface() and detach_interface().",
            "",
            "        method_name: either \\\"attach_interface\\\" or \\\"detach_interface\\\"",
            "                     depending on the method to test.",
            "        \"\"\"",
            "        self.stubs.Set(host.Host, \"get_domain\", lambda a, b: FakeVirtDomain())",
            "",
            "        instance = objects.Instance(**self.test_instance)",
            "        network_info = _fake_network_info(self, 1)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        fake_image_meta = objects.ImageMeta.from_dict(",
            "            {'id': instance['image_ref']})",
            "",
            "        if method_name == \"attach_interface\":",
            "            self.mox.StubOutWithMock(drvr.firewall_driver,",
            "                                     'setup_basic_filtering')",
            "            drvr.firewall_driver.setup_basic_filtering(instance, network_info)",
            "",
            "        expected = drvr.vif_driver.get_config(instance, network_info[0],",
            "                                              fake_image_meta,",
            "                                              instance.get_flavor(),",
            "                                              CONF.libvirt.virt_type,",
            "                                              drvr._host)",
            "        self.mox.StubOutWithMock(drvr.vif_driver, 'get_config')",
            "        drvr.vif_driver.get_config(instance, network_info[0],",
            "                                   mox.IsA(objects.ImageMeta),",
            "                                   mox.IsA(objects.Flavor),",
            "                                   CONF.libvirt.virt_type,",
            "                                   drvr._host).\\",
            "                                   AndReturn(expected)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        if method_name == \"attach_interface\":",
            "            drvr.attach_interface(instance, fake_image_meta,",
            "                                  network_info[0])",
            "        elif method_name == \"detach_interface\":",
            "            drvr.detach_interface(instance, network_info[0])",
            "        else:",
            "            raise ValueError(\"Unhandled method %s\" % method_name)",
            "",
            "    @mock.patch.object(lockutils, \"external_lock\")",
            "    def test_attach_interface_get_config(self, mock_lock):",
            "        \"\"\"Tests that the get_config() method is properly called in",
            "        attach_interface().",
            "        \"\"\"",
            "        mock_lock.return_value = threading.Semaphore()",
            "",
            "        self._test_attach_detach_interface_get_config(\"attach_interface\")",
            "",
            "    def test_detach_interface_get_config(self):",
            "        \"\"\"Tests that the get_config() method is properly called in",
            "        detach_interface().",
            "        \"\"\"",
            "        self._test_attach_detach_interface_get_config(\"detach_interface\")",
            "",
            "    def test_default_root_device_name(self):",
            "        instance = {'uuid': 'fake_instance'}",
            "        image_meta = objects.ImageMeta.from_dict({'id': 'fake'})",
            "        root_bdm = {'source_type': 'image',",
            "                    'detination_type': 'volume',",
            "                    'image_id': 'fake_id'}",
            "        self.flags(virt_type='fake_libvirt_type', group='libvirt')",
            "",
            "        self.mox.StubOutWithMock(blockinfo, 'get_disk_bus_for_device_type')",
            "        self.mox.StubOutWithMock(blockinfo, 'get_root_info')",
            "",
            "        blockinfo.get_disk_bus_for_device_type(instance,",
            "                                               'fake_libvirt_type',",
            "                                               image_meta,",
            "                                               'disk').InAnyOrder().\\",
            "                                                AndReturn('virtio')",
            "        blockinfo.get_disk_bus_for_device_type(instance,",
            "                                               'fake_libvirt_type',",
            "                                               image_meta,",
            "                                               'cdrom').InAnyOrder().\\",
            "                                                AndReturn('ide')",
            "        blockinfo.get_root_info(instance, 'fake_libvirt_type',",
            "                                image_meta, root_bdm,",
            "                                'virtio', 'ide').AndReturn({'dev': 'vda'})",
            "        self.mox.ReplayAll()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertEqual(drvr.default_root_device_name(instance, image_meta,",
            "                                                       root_bdm), '/dev/vda')",
            "",
            "    @mock.patch.object(objects.BlockDeviceMapping, \"save\")",
            "    def test_default_device_names_for_instance(self, save_mock):",
            "        instance = objects.Instance(**self.test_instance)",
            "        instance.root_device_name = '/dev/vda'",
            "        ephemerals = [objects.BlockDeviceMapping(",
            "                        **fake_block_device.AnonFakeDbBlockDeviceDict(",
            "                            {'device_name': 'vdb',",
            "                             'source_type': 'blank',",
            "                             'volume_size': 2,",
            "                             'destination_type': 'local'}))]",
            "        swap = [objects.BlockDeviceMapping(",
            "                        **fake_block_device.AnonFakeDbBlockDeviceDict(",
            "                            {'device_name': 'vdg',",
            "                             'source_type': 'blank',",
            "                             'volume_size': 512,",
            "                             'guest_format': 'swap',",
            "                             'destination_type': 'local'}))]",
            "        block_device_mapping = [",
            "            objects.BlockDeviceMapping(",
            "                **fake_block_device.AnonFakeDbBlockDeviceDict(",
            "                    {'source_type': 'volume',",
            "                     'destination_type': 'volume',",
            "                     'volume_id': 'fake-image-id',",
            "                     'device_name': '/dev/vdxx',",
            "                     'disk_bus': 'scsi'}))]",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr.default_device_names_for_instance(instance,",
            "                                               instance.root_device_name,",
            "                                               ephemerals, swap,",
            "                                               block_device_mapping)",
            "",
            "        # Ephemeral device name was correct so no changes",
            "        self.assertEqual('/dev/vdb', ephemerals[0].device_name)",
            "        # Swap device name was incorrect so it was changed",
            "        self.assertEqual('/dev/vdc', swap[0].device_name)",
            "        # Volume device name was changed too, taking the bus into account",
            "        self.assertEqual('/dev/sda', block_device_mapping[0].device_name)",
            "",
            "        self.assertEqual(3, save_mock.call_count)",
            "",
            "    def _test_get_device_name_for_instance(self, new_bdm, expected_dev):",
            "        instance = objects.Instance(**self.test_instance)",
            "        instance.root_device_name = '/dev/vda'",
            "        instance.ephemeral_gb = 0",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        got_dev = drvr.get_device_name_for_instance(",
            "            instance, [], new_bdm)",
            "        self.assertEqual(expected_dev, got_dev)",
            "",
            "    def test_get_device_name_for_instance_simple(self):",
            "        new_bdm = objects.BlockDeviceMapping(",
            "            context=context,",
            "            source_type='volume', destination_type='volume',",
            "            boot_index=-1, volume_id='fake-id',",
            "            device_name=None, guest_format=None,",
            "            disk_bus=None, device_type=None)",
            "        self._test_get_device_name_for_instance(new_bdm, '/dev/vdb')",
            "",
            "    def test_get_device_name_for_instance_suggested(self):",
            "        new_bdm = objects.BlockDeviceMapping(",
            "            context=context,",
            "            source_type='volume', destination_type='volume',",
            "            boot_index=-1, volume_id='fake-id',",
            "            device_name='/dev/vdg', guest_format=None,",
            "            disk_bus=None, device_type=None)",
            "        self._test_get_device_name_for_instance(new_bdm, '/dev/vdb')",
            "",
            "    def test_get_device_name_for_instance_bus(self):",
            "        new_bdm = objects.BlockDeviceMapping(",
            "            context=context,",
            "            source_type='volume', destination_type='volume',",
            "            boot_index=-1, volume_id='fake-id',",
            "            device_name=None, guest_format=None,",
            "            disk_bus='scsi', device_type=None)",
            "        self._test_get_device_name_for_instance(new_bdm, '/dev/sda')",
            "",
            "    def test_get_device_name_for_instance_device_type(self):",
            "        new_bdm = objects.BlockDeviceMapping(",
            "            context=context,",
            "            source_type='volume', destination_type='volume',",
            "            boot_index=-1, volume_id='fake-id',",
            "            device_name=None, guest_format=None,",
            "            disk_bus=None, device_type='floppy')",
            "        self._test_get_device_name_for_instance(new_bdm, '/dev/fda')",
            "",
            "    def test_is_supported_fs_format(self):",
            "        supported_fs = [disk.FS_FORMAT_EXT2, disk.FS_FORMAT_EXT3,",
            "                        disk.FS_FORMAT_EXT4, disk.FS_FORMAT_XFS]",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        for fs in supported_fs:",
            "            self.assertTrue(drvr.is_supported_fs_format(fs))",
            "",
            "        supported_fs = ['', 'dummy']",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        for fs in supported_fs:",
            "            self.assertFalse(drvr.is_supported_fs_format(fs))",
            "",
            "    def test_post_live_migration_at_destination_with_block_device_info(self):",
            "        # Preparing mocks",
            "        mock_domain = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.resultXML = None",
            "",
            "        def fake_getLibVersion():",
            "            return fakelibvirt.FAKE_LIBVIRT_VERSION",
            "",
            "        def fake_getCapabilities():",
            "            return \"\"\"",
            "            <capabilities>",
            "                <host>",
            "                    <uuid>cef19ce0-0ca2-11df-855d-b19fbce37686</uuid>",
            "                    <cpu>",
            "                      <arch>x86_64</arch>",
            "                      <model>Penryn</model>",
            "                      <vendor>Intel</vendor>",
            "                      <topology sockets='1' cores='2' threads='1'/>",
            "                      <feature name='xtpr'/>",
            "                    </cpu>",
            "                </host>",
            "            </capabilities>",
            "            \"\"\"",
            "",
            "        def fake_to_xml(context, instance, network_info, disk_info,",
            "                        image_meta=None, rescue=None,",
            "                        block_device_info=None, write_to_disk=False):",
            "            if image_meta is None:",
            "                image_meta = objects.ImageMeta.from_dict({})",
            "            conf = drvr._get_guest_config(instance, network_info, image_meta,",
            "                                          disk_info, rescue, block_device_info)",
            "            self.resultXML = conf.to_xml()",
            "            return self.resultXML",
            "",
            "        def fake_get_domain(instance):",
            "            return mock_domain",
            "",
            "        def fake_baselineCPU(cpu, flag):",
            "            return \"\"\"<cpu mode='custom' match='exact'>",
            "                        <model fallback='allow'>Westmere</model>",
            "                        <vendor>Intel</vendor>",
            "                        <feature policy='require' name='aes'/>",
            "                      </cpu>",
            "                   \"\"\"",
            "",
            "        network_info = _fake_network_info(self, 1)",
            "        self.create_fake_libvirt_mock(getLibVersion=fake_getLibVersion,",
            "                                      getCapabilities=fake_getCapabilities,",
            "                                      getVersion=lambda: 1005001,",
            "                                      listDefinedDomains=lambda: [],",
            "                                      numOfDomains=lambda: 0,",
            "                                      baselineCPU=fake_baselineCPU)",
            "        instance_ref = self.test_instance",
            "        instance_ref['image_ref'] = 123456  # we send an int to test sha1 call",
            "        instance = objects.Instance(**instance_ref)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr,",
            "                       '_get_guest_xml',",
            "                       fake_to_xml)",
            "        self.stubs.Set(host.Host,",
            "                       'get_domain',",
            "                       fake_get_domain)",
            "        bdm = objects.BlockDeviceMapping(",
            "            self.context,",
            "            **fake_block_device.FakeDbBlockDeviceDict(",
            "                {'id': 1, 'guest_format': None,",
            "                 'boot_index': 0,",
            "                 'source_type': 'volume',",
            "                 'destination_type': 'volume',",
            "                 'device_name': '/dev/vda',",
            "                 'disk_bus': 'virtio',",
            "                 'device_type': 'disk',",
            "                 'delete_on_termination': False}))",
            "        block_device_info = {'block_device_mapping':",
            "                driver_block_device.convert_volumes([bdm])}",
            "        block_device_info['block_device_mapping'][0]['connection_info'] = (",
            "                {'driver_volume_type': 'iscsi'})",
            "        with test.nested(",
            "                mock.patch.object(",
            "                    driver_block_device.DriverVolumeBlockDevice, 'save'),",
            "                mock.patch.object(objects.Instance, 'save')",
            "        ) as (mock_volume_save, mock_instance_save):",
            "            drvr.post_live_migration_at_destination(",
            "                    self.context, instance, network_info, True,",
            "                    block_device_info=block_device_info)",
            "            self.assertIn('fake', self.resultXML)",
            "            mock_volume_save.assert_called_once_with()",
            "",
            "    def test_create_propagates_exceptions(self):",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(id=1, uuid='fake-uuid',",
            "                                    image_ref='my_fake_image')",
            "",
            "        with test.nested(",
            "              mock.patch.object(drvr, '_create_domain_setup_lxc'),",
            "              mock.patch.object(drvr, '_create_domain_cleanup_lxc'),",
            "              mock.patch.object(drvr, '_is_booted_from_volume',",
            "                                return_value=False),",
            "              mock.patch.object(drvr, 'plug_vifs'),",
            "              mock.patch.object(drvr, 'firewall_driver'),",
            "              mock.patch.object(drvr, '_create_domain',",
            "                                side_effect=exception.NovaException),",
            "              mock.patch.object(drvr, 'cleanup')):",
            "            self.assertRaises(exception.NovaException,",
            "                              drvr._create_domain_and_network,",
            "                              self.context,",
            "                              'xml',",
            "                              instance, None, None)",
            "",
            "    def test_create_without_pause(self):",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "",
            "        @contextlib.contextmanager",
            "        def fake_lxc_disk_handler(*args, **kwargs):",
            "            yield",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        with test.nested(",
            "              mock.patch.object(drvr, '_lxc_disk_handler',",
            "                                side_effect=fake_lxc_disk_handler),",
            "              mock.patch.object(drvr, 'plug_vifs'),",
            "              mock.patch.object(drvr, 'firewall_driver'),",
            "              mock.patch.object(drvr, '_create_domain'),",
            "              mock.patch.object(drvr, 'cleanup')) as (",
            "              _handler, cleanup, firewall_driver, create, plug_vifs):",
            "            domain = drvr._create_domain_and_network(self.context, 'xml',",
            "                                                     instance, None, None)",
            "            self.assertEqual(0, create.call_args_list[0][1]['pause'])",
            "            self.assertEqual(0, domain.resume.call_count)",
            "",
            "    def _test_create_with_network_events(self, neutron_failure=None,",
            "                                         power_on=True):",
            "        generated_events = []",
            "",
            "        def wait_timeout():",
            "            event = mock.MagicMock()",
            "            if neutron_failure == 'timeout':",
            "                raise eventlet.timeout.Timeout()",
            "            elif neutron_failure == 'error':",
            "                event.status = 'failed'",
            "            else:",
            "                event.status = 'completed'",
            "            return event",
            "",
            "        def fake_prepare(instance, event_name):",
            "            m = mock.MagicMock()",
            "            m.instance = instance",
            "            m.event_name = event_name",
            "            m.wait.side_effect = wait_timeout",
            "            generated_events.append(m)",
            "            return m",
            "",
            "        virtapi = manager.ComputeVirtAPI(mock.MagicMock())",
            "        prepare = virtapi._compute.instance_events.prepare_for_instance_event",
            "        prepare.side_effect = fake_prepare",
            "        drvr = libvirt_driver.LibvirtDriver(virtapi, False)",
            "",
            "        instance = objects.Instance(**self.test_instance)",
            "        vifs = [{'id': 'vif1', 'active': False},",
            "                {'id': 'vif2', 'active': False}]",
            "",
            "        @mock.patch.object(drvr, 'plug_vifs')",
            "        @mock.patch.object(drvr, 'firewall_driver')",
            "        @mock.patch.object(drvr, '_create_domain')",
            "        @mock.patch.object(drvr, 'cleanup')",
            "        def test_create(cleanup, create, fw_driver, plug_vifs):",
            "            domain = drvr._create_domain_and_network(self.context, 'xml',",
            "                                                     instance, vifs, None,",
            "                                                     power_on=power_on)",
            "            plug_vifs.assert_called_with(instance, vifs)",
            "",
            "            pause = self._get_pause_flag(drvr, vifs, power_on=power_on)",
            "            self.assertEqual(pause,",
            "                             create.call_args_list[0][1]['pause'])",
            "            if pause:",
            "                domain.resume.assert_called_once_with()",
            "            if neutron_failure and CONF.vif_plugging_is_fatal:",
            "                cleanup.assert_called_once_with(self.context,",
            "                                                instance, network_info=vifs,",
            "                                                block_device_info=None)",
            "",
            "        test_create()",
            "",
            "        if utils.is_neutron() and CONF.vif_plugging_timeout and power_on:",
            "            prepare.assert_has_calls([",
            "                mock.call(instance, 'network-vif-plugged-vif1'),",
            "                mock.call(instance, 'network-vif-plugged-vif2')])",
            "            for event in generated_events:",
            "                if neutron_failure and generated_events.index(event) != 0:",
            "                    self.assertEqual(0, event.call_count)",
            "                elif (neutron_failure == 'error' and",
            "                          not CONF.vif_plugging_is_fatal):",
            "                    event.wait.assert_called_once_with()",
            "        else:",
            "            self.assertEqual(0, prepare.call_count)",
            "",
            "    @mock.patch('nova.utils.is_neutron', return_value=True)",
            "    def test_create_with_network_events_neutron(self, is_neutron):",
            "        self._test_create_with_network_events()",
            "",
            "    @mock.patch('nova.utils.is_neutron', return_value=True)",
            "    def test_create_with_network_events_neutron_power_off(self,",
            "                                                          is_neutron):",
            "        # Tests that we don't wait for events if we don't start the instance.",
            "        self._test_create_with_network_events(power_on=False)",
            "",
            "    @mock.patch('nova.utils.is_neutron', return_value=True)",
            "    def test_create_with_network_events_neutron_nowait(self, is_neutron):",
            "        self.flags(vif_plugging_timeout=0)",
            "        self._test_create_with_network_events()",
            "",
            "    @mock.patch('nova.utils.is_neutron', return_value=True)",
            "    def test_create_with_network_events_neutron_failed_nonfatal_timeout(",
            "            self, is_neutron):",
            "        self.flags(vif_plugging_is_fatal=False)",
            "        self._test_create_with_network_events(neutron_failure='timeout')",
            "",
            "    @mock.patch('nova.utils.is_neutron', return_value=True)",
            "    def test_create_with_network_events_neutron_failed_fatal_timeout(",
            "            self, is_neutron):",
            "        self.assertRaises(exception.VirtualInterfaceCreateException,",
            "                          self._test_create_with_network_events,",
            "                          neutron_failure='timeout')",
            "",
            "    @mock.patch('nova.utils.is_neutron', return_value=True)",
            "    def test_create_with_network_events_neutron_failed_nonfatal_error(",
            "            self, is_neutron):",
            "        self.flags(vif_plugging_is_fatal=False)",
            "        self._test_create_with_network_events(neutron_failure='error')",
            "",
            "    @mock.patch('nova.utils.is_neutron', return_value=True)",
            "    def test_create_with_network_events_neutron_failed_fatal_error(",
            "            self, is_neutron):",
            "        self.assertRaises(exception.VirtualInterfaceCreateException,",
            "                          self._test_create_with_network_events,",
            "                          neutron_failure='error')",
            "",
            "    @mock.patch('nova.utils.is_neutron', return_value=False)",
            "    def test_create_with_network_events_non_neutron(self, is_neutron):",
            "        self._test_create_with_network_events()",
            "",
            "    @mock.patch('nova.volume.encryptors.get_encryption_metadata')",
            "    @mock.patch('nova.virt.libvirt.blockinfo.get_info_from_bdm')",
            "    def test_create_with_bdm(self, get_info_from_bdm, get_encryption_metadata):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_dom = mock.MagicMock()",
            "        mock_encryption_meta = mock.MagicMock()",
            "        get_encryption_metadata.return_value = mock_encryption_meta",
            "",
            "        fake_xml = \"\"\"",
            "            <domain>",
            "                <name>instance-00000001</name>",
            "                <memory>1048576</memory>",
            "                <vcpu>1</vcpu>",
            "                <devices>",
            "                    <disk type='file' device='disk'>",
            "                        <driver name='qemu' type='raw' cache='none'/>",
            "                        <source file='/path/fake-volume1'/>",
            "                        <target dev='vda' bus='virtio'/>",
            "                    </disk>",
            "                </devices>",
            "            </domain>",
            "        \"\"\"",
            "        fake_volume_id = \"fake-volume-id\"",
            "        connection_info = {\"driver_volume_type\": \"fake\",",
            "                           \"data\": {\"access_mode\": \"rw\",",
            "                                    \"volume_id\": fake_volume_id}}",
            "",
            "        def fake_getitem(*args, **kwargs):",
            "            fake_bdm = {'connection_info': connection_info,",
            "                        'mount_device': '/dev/vda'}",
            "            return fake_bdm.get(args[0])",
            "",
            "        mock_volume = mock.MagicMock()",
            "        mock_volume.__getitem__.side_effect = fake_getitem",
            "        block_device_info = {'block_device_mapping': [mock_volume]}",
            "        network_info = [network_model.VIF(id='1'),",
            "                        network_model.VIF(id='2', active=True)]",
            "",
            "        with test.nested(",
            "            mock.patch.object(drvr, '_get_volume_encryptor'),",
            "            mock.patch.object(drvr, 'plug_vifs'),",
            "            mock.patch.object(drvr.firewall_driver, 'setup_basic_filtering'),",
            "            mock.patch.object(drvr.firewall_driver,",
            "                              'prepare_instance_filter'),",
            "            mock.patch.object(drvr, '_create_domain'),",
            "            mock.patch.object(drvr.firewall_driver, 'apply_instance_filter'),",
            "        ) as (get_volume_encryptor, plug_vifs, setup_basic_filtering,",
            "              prepare_instance_filter, create_domain, apply_instance_filter):",
            "            create_domain.return_value = libvirt_guest.Guest(mock_dom)",
            "",
            "            guest = drvr._create_domain_and_network(",
            "                    self.context, fake_xml, instance, network_info, None,",
            "                    block_device_info=block_device_info)",
            "",
            "            get_encryption_metadata.assert_called_once_with(self.context,",
            "                drvr._volume_api, fake_volume_id, connection_info)",
            "            get_volume_encryptor.assert_called_once_with(connection_info,",
            "                                                         mock_encryption_meta)",
            "            plug_vifs.assert_called_once_with(instance, network_info)",
            "            setup_basic_filtering.assert_called_once_with(instance,",
            "                                                          network_info)",
            "            prepare_instance_filter.assert_called_once_with(instance,",
            "                                                          network_info)",
            "            pause = self._get_pause_flag(drvr, network_info)",
            "            create_domain.assert_called_once_with(",
            "                fake_xml, pause=pause, power_on=True)",
            "            self.assertEqual(mock_dom, guest._domain)",
            "",
            "    def test_get_guest_storage_config(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        test_instance = copy.deepcopy(self.test_instance)",
            "        test_instance[\"default_swap_device\"] = None",
            "        instance = objects.Instance(**test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = instance.get_flavor()",
            "        conn_info = {'driver_volume_type': 'fake', 'data': {}}",
            "        bdm = objects.BlockDeviceMapping(",
            "            self.context,",
            "            **fake_block_device.FakeDbBlockDeviceDict({",
            "                   'id': 1,",
            "                   'source_type': 'volume',",
            "                   'destination_type': 'volume',",
            "                   'device_name': '/dev/vdc'}))",
            "        bdi = {'block_device_mapping':",
            "               driver_block_device.convert_volumes([bdm])}",
            "        bdm = bdi['block_device_mapping'][0]",
            "        bdm['connection_info'] = conn_info",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta,",
            "                                            bdi)",
            "        mock_conf = mock.MagicMock(source_path='fake')",
            "",
            "        with test.nested(",
            "            mock.patch.object(driver_block_device.DriverVolumeBlockDevice,",
            "                              'save'),",
            "            mock.patch.object(drvr, '_connect_volume'),",
            "            mock.patch.object(drvr, '_get_volume_config',",
            "                              return_value=mock_conf),",
            "            mock.patch.object(drvr, '_set_cache_mode')",
            "        ) as (volume_save, connect_volume, get_volume_config, set_cache_mode):",
            "            devices = drvr._get_guest_storage_config(instance, image_meta,",
            "                disk_info, False, bdi, flavor, \"hvm\")",
            "",
            "            self.assertEqual(3, len(devices))",
            "            self.assertEqual('/dev/vdb', instance.default_ephemeral_device)",
            "            self.assertIsNone(instance.default_swap_device)",
            "            connect_volume.assert_called_with(bdm['connection_info'],",
            "                {'bus': 'virtio', 'type': 'disk', 'dev': 'vdc'})",
            "            get_volume_config.assert_called_with(bdm['connection_info'],",
            "                {'bus': 'virtio', 'type': 'disk', 'dev': 'vdc'})",
            "            volume_save.assert_called_once_with()",
            "            self.assertEqual(3, set_cache_mode.call_count)",
            "",
            "    def test_get_neutron_events(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        network_info = [network_model.VIF(id='1'),",
            "                        network_model.VIF(id='2', active=True)]",
            "        events = drvr._get_neutron_events(network_info)",
            "        self.assertEqual([('network-vif-plugged', '1')], events)",
            "",
            "    def test_unplug_vifs_ignores_errors(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "        with mock.patch.object(drvr, 'vif_driver') as vif_driver:",
            "            vif_driver.unplug.side_effect = exception.AgentError(",
            "                method='unplug')",
            "            drvr._unplug_vifs('inst', [1], ignore_errors=True)",
            "            vif_driver.unplug.assert_called_once_with('inst', 1)",
            "",
            "    def test_unplug_vifs_reports_errors(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "        with mock.patch.object(drvr, 'vif_driver') as vif_driver:",
            "            vif_driver.unplug.side_effect = exception.AgentError(",
            "                method='unplug')",
            "            self.assertRaises(exception.AgentError,",
            "                              drvr.unplug_vifs, 'inst', [1])",
            "            vif_driver.unplug.assert_called_once_with('inst', 1)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._unplug_vifs')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._undefine_domain')",
            "    def test_cleanup_pass_with_no_mount_device(self, undefine, unplug):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "        drvr.firewall_driver = mock.Mock()",
            "        drvr._disconnect_volume = mock.Mock()",
            "        fake_inst = {'name': 'foo'}",
            "        fake_bdms = [{'connection_info': 'foo',",
            "                     'mount_device': None}]",
            "        with mock.patch('nova.virt.driver'",
            "                        '.block_device_info_get_mapping',",
            "                        return_value=fake_bdms):",
            "            drvr.cleanup('ctxt', fake_inst, 'netinfo', destroy_disks=False)",
            "        self.assertTrue(drvr._disconnect_volume.called)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._unplug_vifs')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._undefine_domain')",
            "    def test_cleanup_wants_vif_errors_ignored(self, undefine, unplug):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "        fake_inst = {'name': 'foo'}",
            "        with mock.patch.object(drvr._conn, 'lookupByName') as lookup:",
            "            lookup.return_value = fake_inst",
            "            # NOTE(danms): Make unplug cause us to bail early, since",
            "            # we only care about how it was called",
            "            unplug.side_effect = test.TestingException",
            "            self.assertRaises(test.TestingException,",
            "                              drvr.cleanup, 'ctxt', fake_inst, 'netinfo')",
            "            unplug.assert_called_once_with(fake_inst, 'netinfo', True)",
            "",
            "    @mock.patch.object(driver, 'block_device_info_get_mapping')",
            "    @mock.patch.object(host.Host, \"get_guest\")",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver,",
            "                       '_get_serial_ports_from_guest')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_undefine_domain')",
            "    def test_cleanup_serial_console_enabled(",
            "            self, undefine, get_ports, get_guest,",
            "            block_device_info_get_mapping):",
            "        self.flags(enabled=\"True\", group='serial_console')",
            "        instance = 'i1'",
            "        network_info = {}",
            "        bdm_info = {}",
            "        firewall_driver = mock.MagicMock()",
            "",
            "        guest = mock.Mock(spec=libvirt_guest.Guest)",
            "        get_guest.return_value = guest",
            "        get_ports.return_value = iter([('127.0.0.1', 10000)])",
            "        block_device_info_get_mapping.return_value = ()",
            "",
            "        # We want to ensure undefine_domain is called after",
            "        # lookup_domain.",
            "        def undefine_domain(instance):",
            "            get_ports.side_effect = Exception(\"domain undefined\")",
            "        undefine.side_effect = undefine_domain",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "        drvr.firewall_driver = firewall_driver",
            "        drvr.cleanup(",
            "            'ctx', instance, network_info,",
            "            block_device_info=bdm_info,",
            "            destroy_disks=False, destroy_vifs=False)",
            "",
            "        get_ports.assert_called_once_with(guest)",
            "        undefine.assert_called_once_with(instance)",
            "        firewall_driver.unfilter_instance.assert_called_once_with(",
            "            instance, network_info=network_info)",
            "        block_device_info_get_mapping.assert_called_once_with(bdm_info)",
            "",
            "    @mock.patch.object(driver, 'block_device_info_get_mapping')",
            "    @mock.patch.object(host.Host, \"get_guest\")",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_undefine_domain')",
            "    def test_cleanup_serial_console_domain_gone(",
            "            self, undefine, get_guest, block_device_info_get_mapping):",
            "        self.flags(enabled=\"True\", group='serial_console')",
            "        instance = {'name': 'i1'}",
            "        network_info = {}",
            "        bdm_info = {}",
            "        firewall_driver = mock.MagicMock()",
            "",
            "        block_device_info_get_mapping.return_value = ()",
            "",
            "        # Ensure get_guest raises same exception that would have occurred",
            "        # if domain was gone.",
            "        get_guest.side_effect = exception.InstanceNotFound(\"domain undefined\")",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "        drvr.firewall_driver = firewall_driver",
            "        drvr.cleanup(",
            "            'ctx', instance, network_info,",
            "            block_device_info=bdm_info,",
            "            destroy_disks=False, destroy_vifs=False)",
            "",
            "        get_guest.assert_called_once_with(instance)",
            "        undefine.assert_called_once_with(instance)",
            "        firewall_driver.unfilter_instance.assert_called_once_with(",
            "            instance, network_info=network_info)",
            "        block_device_info_get_mapping.assert_called_once_with(bdm_info)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, 'unfilter_instance')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, 'delete_instance_files',",
            "                       return_value=True)",
            "    @mock.patch.object(objects.Instance, 'save')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_undefine_domain')",
            "    def test_cleanup_migrate_data_shared_block_storage(self,",
            "                                                       _undefine_domain,",
            "                                                       save,",
            "                                                       delete_instance_files,",
            "                                                       unfilter_instance):",
            "        # Tests the cleanup method when migrate_data has",
            "        # is_shared_block_storage=True and destroy_disks=False.",
            "        instance = objects.Instance(self.context, **self.test_instance)",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "                is_shared_block_storage=True)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "        drvr.cleanup(",
            "            self.context, instance, network_info={}, destroy_disks=False,",
            "            migrate_data=migrate_data, destroy_vifs=False)",
            "        delete_instance_files.assert_called_once_with(instance)",
            "        self.assertEqual(1, int(instance.system_metadata['clean_attempts']))",
            "        self.assertTrue(instance.cleaned)",
            "        save.assert_called_once_with()",
            "",
            "    def test_swap_volume(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "",
            "        mock_dom = mock.MagicMock()",
            "        guest = libvirt_guest.Guest(mock_dom)",
            "",
            "        with mock.patch.object(drvr._conn, 'defineXML',",
            "                               create=True) as mock_define:",
            "            xmldoc = \"<domain/>\"",
            "            srcfile = \"/first/path\"",
            "            dstfile = \"/second/path\"",
            "",
            "            mock_dom.XMLDesc.return_value = xmldoc",
            "            mock_dom.isPersistent.return_value = True",
            "            mock_dom.blockJobInfo.return_value = {}",
            "",
            "            drvr._swap_volume(guest, srcfile, dstfile, 1)",
            "",
            "            mock_dom.XMLDesc.assert_called_once_with(",
            "                flags=(fakelibvirt.VIR_DOMAIN_XML_INACTIVE |",
            "                       fakelibvirt.VIR_DOMAIN_XML_SECURE))",
            "            mock_dom.blockRebase.assert_called_once_with(",
            "                srcfile, dstfile, 0, flags=(",
            "                    fakelibvirt.VIR_DOMAIN_BLOCK_REBASE_COPY |",
            "                    fakelibvirt.VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT))",
            "            mock_dom.blockResize.assert_called_once_with(",
            "                srcfile, 1 * units.Gi / units.Ki)",
            "            mock_define.assert_called_once_with(xmldoc)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._disconnect_volume')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._swap_volume')",
            "    @mock.patch('nova.virt.block_device.DriverVolumeBlockDevice.save')",
            "    @mock.patch('nova.objects.block_device.BlockDeviceMapping.'",
            "                'get_by_volume_and_instance')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._get_volume_config')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._connect_volume')",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_guest')",
            "    def test_swap_volume_driver_bdm_save(self, get_guest,",
            "                                         connect_volume, get_volume_config,",
            "                                         get_by_volume_and_instance,",
            "                                         volume_save, swap_volume,",
            "                                         disconnect_volume):",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "        instance = objects.Instance(**self.test_instance)",
            "        old_connection_info = {'driver_volume_type': 'fake',",
            "                               'serial': 'old-volume-id',",
            "                               'data': {'device_path': '/fake-old-volume',",
            "                                        'access_mode': 'rw'}}",
            "        new_connection_info = {'driver_volume_type': 'fake',",
            "                               'serial': 'new-volume-id',",
            "                               'data': {'device_path': '/fake-new-volume',",
            "                                        'access_mode': 'rw'}}",
            "        mock_dom = mock.MagicMock()",
            "        guest = libvirt_guest.Guest(mock_dom)",
            "        mock_dom.XMLDesc.return_value = \"\"\"<domain>",
            "          <devices>",
            "            <disk type='file'>",
            "                <source file='/fake-old-volume'/>",
            "                <target dev='vdb' bus='virtio'/>",
            "            </disk>",
            "          </devices>",
            "        </domain>",
            "        \"\"\"",
            "        mock_dom.name.return_value = 'inst'",
            "        mock_dom.UUIDString.return_value = 'uuid'",
            "        get_guest.return_value = guest",
            "        disk_info = {'bus': 'virtio', 'type': 'disk', 'dev': 'vdb'}",
            "        get_volume_config.return_value = mock.MagicMock(",
            "            source_path='/fake-new-volume')",
            "",
            "        bdm = objects.BlockDeviceMapping(self.context,",
            "            **fake_block_device.FakeDbBlockDeviceDict(",
            "                {'id': 2, 'instance_uuid': 'fake-instance',",
            "                 'device_name': '/dev/vdb',",
            "                 'source_type': 'volume',",
            "                 'destination_type': 'volume',",
            "                 'volume_id': 'fake-volume-id-2',",
            "                 'boot_index': 0}))",
            "        get_by_volume_and_instance.return_value = bdm",
            "",
            "        conn.swap_volume(old_connection_info, new_connection_info, instance,",
            "                         '/dev/vdb', 1)",
            "",
            "        get_guest.assert_called_once_with(instance)",
            "        connect_volume.assert_called_once_with(new_connection_info, disk_info)",
            "",
            "        swap_volume.assert_called_once_with(guest, 'vdb',",
            "                                            '/fake-new-volume', 1)",
            "        disconnect_volume.assert_called_once_with(old_connection_info, 'vdb')",
            "        volume_save.assert_called_once_with()",
            "",
            "    def _test_live_snapshot(self, can_quiesce=False, require_quiesce=False):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "        mock_dom = mock.MagicMock()",
            "        test_image_meta = self.test_image_meta.copy()",
            "        if require_quiesce:",
            "            test_image_meta = {'properties': {'os_require_quiesce': 'yes'}}",
            "",
            "        with test.nested(",
            "                mock.patch.object(drvr._conn, 'defineXML', create=True),",
            "                mock.patch.object(fake_libvirt_utils, 'get_disk_size'),",
            "                mock.patch.object(fake_libvirt_utils, 'get_disk_backing_file'),",
            "                mock.patch.object(fake_libvirt_utils, 'create_cow_image'),",
            "                mock.patch.object(fake_libvirt_utils, 'chown'),",
            "                mock.patch.object(fake_libvirt_utils, 'extract_snapshot'),",
            "                mock.patch.object(drvr, '_set_quiesced')",
            "        ) as (mock_define, mock_size, mock_backing, mock_create_cow,",
            "              mock_chown, mock_snapshot, mock_quiesce):",
            "",
            "            xmldoc = \"<domain/>\"",
            "            srcfile = \"/first/path\"",
            "            dstfile = \"/second/path\"",
            "            bckfile = \"/other/path\"",
            "            dltfile = dstfile + \".delta\"",
            "",
            "            mock_dom.XMLDesc.return_value = xmldoc",
            "            mock_dom.isPersistent.return_value = True",
            "            mock_size.return_value = 1004009",
            "            mock_backing.return_value = bckfile",
            "            guest = libvirt_guest.Guest(mock_dom)",
            "",
            "            if not can_quiesce:",
            "                mock_quiesce.side_effect = (",
            "                    exception.InstanceQuiesceNotSupported(",
            "                        instance_id=self.test_instance['id'], reason='test'))",
            "",
            "            image_meta = objects.ImageMeta.from_dict(test_image_meta)",
            "            drvr._live_snapshot(self.context, self.test_instance, guest,",
            "                                srcfile, dstfile, \"qcow2\", \"qcow2\", image_meta)",
            "",
            "            mock_dom.XMLDesc.assert_called_once_with(flags=(",
            "                fakelibvirt.VIR_DOMAIN_XML_INACTIVE |",
            "                fakelibvirt.VIR_DOMAIN_XML_SECURE))",
            "            mock_dom.blockRebase.assert_called_once_with(",
            "                srcfile, dltfile, 0, flags=(",
            "                    fakelibvirt.VIR_DOMAIN_BLOCK_REBASE_COPY |",
            "                    fakelibvirt.VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT |",
            "                    fakelibvirt.VIR_DOMAIN_BLOCK_REBASE_SHALLOW))",
            "",
            "            mock_size.assert_called_once_with(srcfile, format=\"qcow2\")",
            "            mock_backing.assert_called_once_with(srcfile, basename=False,",
            "                                                 format=\"qcow2\")",
            "            mock_create_cow.assert_called_once_with(bckfile, dltfile, 1004009)",
            "            mock_chown.assert_called_once_with(dltfile, os.getuid())",
            "            mock_snapshot.assert_called_once_with(dltfile, \"qcow2\",",
            "                                                  dstfile, \"qcow2\")",
            "            mock_define.assert_called_once_with(xmldoc)",
            "            mock_quiesce.assert_any_call(mock.ANY, self.test_instance,",
            "                                         mock.ANY, True)",
            "            if can_quiesce:",
            "                mock_quiesce.assert_any_call(mock.ANY, self.test_instance,",
            "                                             mock.ANY, False)",
            "",
            "    def test_live_snapshot(self):",
            "        self._test_live_snapshot()",
            "",
            "    def test_live_snapshot_with_quiesce(self):",
            "        self._test_live_snapshot(can_quiesce=True)",
            "",
            "    def test_live_snapshot_with_require_quiesce(self):",
            "        self._test_live_snapshot(can_quiesce=True, require_quiesce=True)",
            "",
            "    def test_live_snapshot_with_require_quiesce_fails(self):",
            "        self.assertRaises(exception.InstanceQuiesceNotSupported,",
            "                          self._test_live_snapshot,",
            "                          can_quiesce=False, require_quiesce=True)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, \"_live_migration\")",
            "    def test_live_migration_hostname_valid(self, mock_lm):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr.live_migration(self.context, self.test_instance,",
            "                            \"host1.example.com\",",
            "                            lambda x: x,",
            "                            lambda x: x)",
            "        self.assertEqual(1, mock_lm.call_count)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, \"_live_migration\")",
            "    @mock.patch.object(fake_libvirt_utils, \"is_valid_hostname\")",
            "    def test_live_migration_hostname_invalid(self, mock_hostname, mock_lm):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        mock_hostname.return_value = False",
            "        self.assertRaises(exception.InvalidHostname,",
            "                          drvr.live_migration,",
            "                          self.context, self.test_instance,",
            "                          \"foo/?com=/bin/sh\",",
            "                          lambda x: x,",
            "                          lambda x: x)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, \"pause\")",
            "    def test_live_migration_force_complete(self, pause):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr.live_migration_force_complete(self.test_instance)",
            "        pause.assert_called_once_with(self.test_instance)",
            "",
            "    @mock.patch.object(fakelibvirt.virDomain, \"abortJob\")",
            "    def test_live_migration_abort(self, mock_abort):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        dom = fakelibvirt.Domain(drvr._get_connection(), \"<domain/>\", False)",
            "        guest = libvirt_guest.Guest(dom)",
            "        with mock.patch.object(nova.virt.libvirt.host.Host, 'get_guest',",
            "                               return_value=guest):",
            "            drvr.live_migration_abort(self.test_instance)",
            "            self.assertTrue(mock_abort.called)",
            "",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    @mock.patch('tempfile.mkstemp')",
            "    @mock.patch('os.close', return_value=None)",
            "    def test_check_instance_shared_storage_local_raw(self,",
            "                                                 mock_close,",
            "                                                 mock_mkstemp,",
            "                                                 mock_exists):",
            "        instance_uuid = str(uuid.uuid4())",
            "        self.flags(images_type='raw', group='libvirt')",
            "        self.flags(instances_path='/tmp')",
            "        mock_mkstemp.return_value = (-1,",
            "                                     '/tmp/{0}/file'.format(instance_uuid))",
            "        driver = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        temp_file = driver.check_instance_shared_storage_local(self.context,",
            "                                                               instance)",
            "        self.assertEqual('/tmp/{0}/file'.format(instance_uuid),",
            "                         temp_file['filename'])",
            "",
            "    def test_check_instance_shared_storage_local_rbd(self):",
            "        self.flags(images_type='rbd', group='libvirt')",
            "        driver = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        self.assertIsNone(driver.",
            "                          check_instance_shared_storage_local(self.context,",
            "                                                              instance))",
            "",
            "    def test_version_to_string(self):",
            "        driver = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        string_ver = driver._version_to_string((4, 33, 173))",
            "        self.assertEqual(\"4.33.173\", string_ver)",
            "",
            "    def test_parallels_min_version_fail(self):",
            "        self.flags(virt_type='parallels', group='libvirt')",
            "        driver = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        with mock.patch.object(driver._conn, 'getLibVersion',",
            "                               return_value=1002011):",
            "            self.assertRaises(exception.NovaException,",
            "                              driver.init_host, 'wibble')",
            "",
            "    def test_parallels_min_version_ok(self):",
            "        self.flags(virt_type='parallels', group='libvirt')",
            "        driver = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        with mock.patch.object(driver._conn, 'getLibVersion',",
            "                               return_value=1002012):",
            "            driver.init_host('wibble')",
            "",
            "    def test_get_guest_config_parallels_vm(self):",
            "        self.flags(virt_type='parallels', group='libvirt')",
            "        self.flags(images_type='ploop', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                    _fake_network_info(self, 1),",
            "                                    image_meta, disk_info)",
            "        self.assertEqual(\"parallels\", cfg.virt_type)",
            "        self.assertEqual(instance_ref[\"uuid\"], cfg.uuid)",
            "        self.assertEqual(2 * units.Mi, cfg.memory)",
            "        self.assertEqual(1, cfg.vcpus)",
            "        self.assertEqual(vm_mode.HVM, cfg.os_type)",
            "        self.assertIsNone(cfg.os_root)",
            "        self.assertEqual(6, len(cfg.devices))",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertEqual(cfg.devices[0].driver_format, \"ploop\")",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestInterface)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "",
            "    def test_get_guest_config_parallels_ct(self):",
            "        self.flags(virt_type='parallels', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        ct_instance = self.test_instance.copy()",
            "        ct_instance[\"vm_mode\"] = vm_mode.EXE",
            "        instance_ref = objects.Instance(**ct_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                    _fake_network_info(self, 1),",
            "                                    image_meta, {'mapping': {'disk': {}}})",
            "        self.assertEqual(\"parallels\", cfg.virt_type)",
            "        self.assertEqual(instance_ref[\"uuid\"], cfg.uuid)",
            "        self.assertEqual(2 * units.Mi, cfg.memory)",
            "        self.assertEqual(1, cfg.vcpus)",
            "        self.assertEqual(vm_mode.EXE, cfg.os_type)",
            "        self.assertEqual(\"/sbin/init\", cfg.os_init_path)",
            "        self.assertIsNone(cfg.os_root)",
            "        self.assertEqual(4, len(cfg.devices))",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestFilesys)",
            "        fs = cfg.devices[0]",
            "        self.assertEqual(fs.source_type, \"file\")",
            "        self.assertEqual(fs.driver_type, \"ploop\")",
            "        self.assertEqual(fs.target_dir, \"/\")",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestInterface)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "",
            "    def _test_get_guest_config_parallels_volume(self, vmmode, devices):",
            "        self.flags(virt_type='parallels', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        ct_instance = self.test_instance.copy()",
            "        ct_instance[\"vm_mode\"] = vmmode",
            "        instance_ref = objects.Instance(**ct_instance)",
            "",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        conn_info = {'driver_volume_type': 'fake'}",
            "        bdm = objects.BlockDeviceMapping(",
            "            self.context,",
            "            **fake_block_device.FakeDbBlockDeviceDict(",
            "                {'id': 0,",
            "                 'source_type': 'volume', 'destination_type': 'volume',",
            "                 'device_name': '/dev/sda'}))",
            "        info = {'block_device_mapping': driver_block_device.convert_volumes(",
            "                [bdm])}",
            "        info['block_device_mapping'][0]['connection_info'] = conn_info",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta,",
            "                                            info)",
            "",
            "        with mock.patch.object(",
            "                        driver_block_device.DriverVolumeBlockDevice, 'save'",
            "                                ) as mock_save:",
            "            cfg = drvr._get_guest_config(instance_ref,",
            "                                    _fake_network_info(self, 1),",
            "                                    image_meta, disk_info, None, info)",
            "            mock_save.assert_called_once_with()",
            "",
            "        self.assertEqual(\"parallels\", cfg.virt_type)",
            "        self.assertEqual(instance_ref[\"uuid\"], cfg.uuid)",
            "        self.assertEqual(2 * units.Mi, cfg.memory)",
            "        self.assertEqual(1, cfg.vcpus)",
            "        self.assertEqual(vmmode, cfg.os_type)",
            "        self.assertIsNone(cfg.os_root)",
            "        self.assertEqual(devices, len(cfg.devices))",
            "",
            "        disk_found = False",
            "",
            "        for dev in cfg.devices:",
            "            result = isinstance(dev, vconfig.LibvirtConfigGuestFilesys)",
            "            self.assertFalse(result)",
            "            if (isinstance(dev, vconfig.LibvirtConfigGuestDisk) and",
            "                (dev.source_path is None or",
            "               'disk.local' not in dev.source_path)):",
            "                self.assertEqual(\"disk\", dev.source_device)",
            "                self.assertEqual(\"sda\", dev.target_dev)",
            "                disk_found = True",
            "",
            "        self.assertTrue(disk_found)",
            "",
            "    def test_get_guest_config_parallels_volume(self):",
            "        self._test_get_guest_config_parallels_volume(vm_mode.EXE, 4)",
            "        self._test_get_guest_config_parallels_volume(vm_mode.HVM, 6)",
            "",
            "",
            "class HostStateTestCase(test.NoDBTestCase):",
            "",
            "    cpu_info = {\"vendor\": \"Intel\", \"model\": \"pentium\", \"arch\": \"i686\",",
            "                 \"features\": [\"ssse3\", \"monitor\", \"pni\", \"sse2\", \"sse\",",
            "                 \"fxsr\", \"clflush\", \"pse36\", \"pat\", \"cmov\", \"mca\", \"pge\",",
            "                 \"mtrr\", \"sep\", \"apic\"],",
            "                 \"topology\": {\"cores\": \"1\", \"threads\": \"1\", \"sockets\": \"1\"}}",
            "    instance_caps = [(arch.X86_64, \"kvm\", \"hvm\"),",
            "                     (arch.I686, \"kvm\", \"hvm\")]",
            "    pci_devices = [{",
            "        \"dev_id\": \"pci_0000_04_00_3\",",
            "        \"address\": \"0000:04:10.3\",",
            "        \"product_id\": '1521',",
            "        \"vendor_id\": '8086',",
            "        \"dev_type\": fields.PciDeviceType.SRIOV_PF,",
            "        \"phys_function\": None}]",
            "    numa_topology = objects.NUMATopology(",
            "                        cells=[objects.NUMACell(",
            "                            id=1, cpuset=set([1, 2]), memory=1024,",
            "                            cpu_usage=0, memory_usage=0,",
            "                            mempages=[], siblings=[],",
            "                            pinned_cpus=set([])),",
            "                               objects.NUMACell(",
            "                            id=2, cpuset=set([3, 4]), memory=1024,",
            "                            cpu_usage=0, memory_usage=0,",
            "                            mempages=[], siblings=[],",
            "                            pinned_cpus=set([]))])",
            "",
            "    class FakeConnection(libvirt_driver.LibvirtDriver):",
            "        \"\"\"Fake connection object.\"\"\"",
            "        def __init__(self):",
            "            super(HostStateTestCase.FakeConnection,",
            "                  self).__init__(fake.FakeVirtAPI(), True)",
            "",
            "            self._host = host.Host(\"qemu:///system\")",
            "",
            "            def _get_memory_mb_total():",
            "                return 497",
            "",
            "            def _get_memory_mb_used():",
            "                return 88",
            "",
            "            self._host.get_memory_mb_total = _get_memory_mb_total",
            "            self._host.get_memory_mb_used = _get_memory_mb_used",
            "",
            "        def _get_vcpu_total(self):",
            "            return 1",
            "",
            "        def _get_vcpu_used(self):",
            "            return 0",
            "",
            "        def _get_cpu_info(self):",
            "            return HostStateTestCase.cpu_info",
            "",
            "        def _get_disk_over_committed_size_total(self):",
            "            return 0",
            "",
            "        def _get_local_gb_info(self):",
            "            return {'total': 100, 'used': 20, 'free': 80}",
            "",
            "        def get_host_uptime(self):",
            "            return ('10:01:16 up  1:36,  6 users,  '",
            "                    'load average: 0.21, 0.16, 0.19')",
            "",
            "        def _get_disk_available_least(self):",
            "            return 13091",
            "",
            "        def _get_instance_capabilities(self):",
            "            return HostStateTestCase.instance_caps",
            "",
            "        def _get_pci_passthrough_devices(self):",
            "            return jsonutils.dumps(HostStateTestCase.pci_devices)",
            "",
            "        def _get_host_numa_topology(self):",
            "            return HostStateTestCase.numa_topology",
            "",
            "    @mock.patch.object(fakelibvirt, \"openAuth\")",
            "    def test_update_status(self, mock_open):",
            "        mock_open.return_value = fakelibvirt.Connection(\"qemu:///system\")",
            "",
            "        drvr = HostStateTestCase.FakeConnection()",
            "",
            "        stats = drvr.get_available_resource(\"compute1\")",
            "        self.assertEqual(stats[\"vcpus\"], 1)",
            "        self.assertEqual(stats[\"memory_mb\"], 497)",
            "        self.assertEqual(stats[\"local_gb\"], 100)",
            "        self.assertEqual(stats[\"vcpus_used\"], 0)",
            "        self.assertEqual(stats[\"memory_mb_used\"], 88)",
            "        self.assertEqual(stats[\"local_gb_used\"], 20)",
            "        self.assertEqual(stats[\"hypervisor_type\"], 'QEMU')",
            "        self.assertEqual(stats[\"hypervisor_version\"], 1001000)",
            "        self.assertEqual(stats[\"hypervisor_hostname\"], 'compute1')",
            "        cpu_info = jsonutils.loads(stats[\"cpu_info\"])",
            "        self.assertEqual(cpu_info,",
            "                {\"vendor\": \"Intel\", \"model\": \"pentium\",",
            "                 \"arch\": arch.I686,",
            "                 \"features\": [\"ssse3\", \"monitor\", \"pni\", \"sse2\", \"sse\",",
            "                              \"fxsr\", \"clflush\", \"pse36\", \"pat\", \"cmov\",",
            "                              \"mca\", \"pge\", \"mtrr\", \"sep\", \"apic\"],",
            "                 \"topology\": {\"cores\": \"1\", \"threads\": \"1\", \"sockets\": \"1\"}",
            "                })",
            "        self.assertEqual(stats[\"disk_available_least\"], 80)",
            "        self.assertEqual(jsonutils.loads(stats[\"pci_passthrough_devices\"]),",
            "                         HostStateTestCase.pci_devices)",
            "        self.assertThat(objects.NUMATopology.obj_from_db_obj(",
            "                            stats['numa_topology'])._to_dict(),",
            "                        matchers.DictMatches(",
            "                                HostStateTestCase.numa_topology._to_dict()))",
            "",
            "",
            "class LibvirtDriverTestCase(test.NoDBTestCase):",
            "    \"\"\"Test for nova.virt.libvirt.libvirt_driver.LibvirtDriver.\"\"\"",
            "    def setUp(self):",
            "        super(LibvirtDriverTestCase, self).setUp()",
            "        self.drvr = libvirt_driver.LibvirtDriver(",
            "            fake.FakeVirtAPI(), read_only=True)",
            "        self.context = context.get_admin_context()",
            "        self.test_image_meta = {",
            "            \"disk_format\": \"raw\",",
            "        }",
            "",
            "    def _create_instance(self, params=None):",
            "        \"\"\"Create a test instance.\"\"\"",
            "        if not params:",
            "            params = {}",
            "",
            "        flavor = objects.Flavor(memory_mb=512,",
            "                                swap=0,",
            "                                vcpu_weight=None,",
            "                                root_gb=10,",
            "                                id=2,",
            "                                name=u'm1.tiny',",
            "                                ephemeral_gb=20,",
            "                                rxtx_factor=1.0,",
            "                                flavorid=u'1',",
            "                                vcpus=1)",
            "",
            "        inst = {}",
            "        inst['id'] = 1",
            "        inst['uuid'] = '52d3b512-1152-431f-a8f7-28f0288a622b'",
            "        inst['os_type'] = 'linux'",
            "        inst['image_ref'] = '1'",
            "        inst['reservation_id'] = 'r-fakeres'",
            "        inst['user_id'] = 'fake'",
            "        inst['project_id'] = 'fake'",
            "        inst['instance_type_id'] = 2",
            "        inst['ami_launch_index'] = 0",
            "        inst['host'] = 'host1'",
            "        inst['root_gb'] = flavor.root_gb",
            "        inst['ephemeral_gb'] = flavor.ephemeral_gb",
            "        inst['config_drive'] = True",
            "        inst['kernel_id'] = 2",
            "        inst['ramdisk_id'] = 3",
            "        inst['key_data'] = 'ABCDEFG'",
            "        inst['system_metadata'] = {}",
            "        inst['metadata'] = {}",
            "        inst['task_state'] = None",
            "",
            "        inst.update(params)",
            "",
            "        return objects.Instance(flavor=flavor,",
            "                                old_flavor=None, new_flavor=None,",
            "                                **inst)",
            "",
            "    @staticmethod",
            "    def _disk_info():",
            "        # 10G root and 512M swap disk",
            "        disk_info = [{'disk_size': 1, 'type': 'qcow2',",
            "                      'virt_disk_size': 10737418240, 'path': '/test/disk',",
            "                      'backing_file': '/base/disk'},",
            "                     {'disk_size': 1, 'type': 'qcow2',",
            "                      'virt_disk_size': 536870912, 'path': '/test/disk.swap',",
            "                      'backing_file': '/base/swap_512'}]",
            "        return jsonutils.dumps(disk_info)",
            "",
            "    def test_migrate_disk_and_power_off_exception(self):",
            "        \"\"\"Test for nova.virt.libvirt.libvirt_driver.LivirtConnection",
            "        .migrate_disk_and_power_off.",
            "        \"\"\"",
            "",
            "        self.counter = 0",
            "        self.checked_shared_storage = False",
            "",
            "        def fake_get_instance_disk_info(instance,",
            "                                        block_device_info=None):",
            "            return '[]'",
            "",
            "        def fake_destroy(instance):",
            "            pass",
            "",
            "        def fake_get_host_ip_addr():",
            "            return '10.0.0.1'",
            "",
            "        def fake_execute(*args, **kwargs):",
            "            self.counter += 1",
            "            if self.counter == 1:",
            "                assert False, \"intentional failure\"",
            "",
            "        def fake_os_path_exists(path):",
            "            return True",
            "",
            "        def fake_is_storage_shared(dest, inst_base):",
            "            self.checked_shared_storage = True",
            "            return False",
            "",
            "        self.stubs.Set(self.drvr, 'get_instance_disk_info',",
            "                       fake_get_instance_disk_info)",
            "        self.stubs.Set(self.drvr, '_destroy', fake_destroy)",
            "        self.stubs.Set(self.drvr, 'get_host_ip_addr',",
            "                       fake_get_host_ip_addr)",
            "        self.stubs.Set(self.drvr, '_is_storage_shared_with',",
            "                       fake_is_storage_shared)",
            "        self.stubs.Set(utils, 'execute', fake_execute)",
            "        self.stub_out('os.path.exists', fake_os_path_exists)",
            "",
            "        ins_ref = self._create_instance()",
            "        flavor = {'root_gb': 10, 'ephemeral_gb': 20}",
            "        flavor_obj = objects.Flavor(**flavor)",
            "",
            "        self.assertRaises(AssertionError,",
            "                          self.drvr.migrate_disk_and_power_off,",
            "                          context.get_admin_context(), ins_ref, '10.0.0.2',",
            "                          flavor_obj, None)",
            "",
            "    def _test_migrate_disk_and_power_off(self, flavor_obj,",
            "                                         block_device_info=None,",
            "                                         params_for_instance=None):",
            "        \"\"\"Test for nova.virt.libvirt.libvirt_driver.LivirtConnection",
            "        .migrate_disk_and_power_off.",
            "        \"\"\"",
            "",
            "        disk_info = self._disk_info()",
            "",
            "        def fake_get_instance_disk_info(instance,",
            "                                        block_device_info=None):",
            "            return disk_info",
            "",
            "        def fake_destroy(instance):",
            "            pass",
            "",
            "        def fake_get_host_ip_addr():",
            "            return '10.0.0.1'",
            "",
            "        def fake_execute(*args, **kwargs):",
            "            pass",
            "",
            "        def fake_copy_image(src, dest, host=None, receive=False,",
            "                            on_execute=None, on_completion=None,",
            "                            compression=True):",
            "            self.assertIsNotNone(on_execute)",
            "            self.assertIsNotNone(on_completion)",
            "",
            "        self.stubs.Set(self.drvr, 'get_instance_disk_info',",
            "                       fake_get_instance_disk_info)",
            "        self.stubs.Set(self.drvr, '_destroy', fake_destroy)",
            "        self.stubs.Set(self.drvr, 'get_host_ip_addr',",
            "                       fake_get_host_ip_addr)",
            "        self.stubs.Set(utils, 'execute', fake_execute)",
            "        self.stubs.Set(libvirt_utils, 'copy_image', fake_copy_image)",
            "",
            "        ins_ref = self._create_instance(params=params_for_instance)",
            "",
            "        # dest is different host case",
            "        out = self.drvr.migrate_disk_and_power_off(",
            "               context.get_admin_context(), ins_ref, '10.0.0.2',",
            "               flavor_obj, None, block_device_info=block_device_info)",
            "        self.assertEqual(out, disk_info)",
            "",
            "        # dest is same host case",
            "        out = self.drvr.migrate_disk_and_power_off(",
            "               context.get_admin_context(), ins_ref, '10.0.0.1',",
            "               flavor_obj, None, block_device_info=block_device_info)",
            "        self.assertEqual(out, disk_info)",
            "",
            "    def test_migrate_disk_and_power_off(self):",
            "        flavor = {'root_gb': 10, 'ephemeral_gb': 20}",
            "        flavor_obj = objects.Flavor(**flavor)",
            "",
            "        self._test_migrate_disk_and_power_off(flavor_obj)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._disconnect_volume')",
            "    def test_migrate_disk_and_power_off_boot_from_volume(self,",
            "                                                         disconnect_volume):",
            "        info = {'block_device_mapping': [{'boot_index': None,",
            "                                          'mount_device': '/dev/vdd',",
            "                                          'connection_info': None},",
            "                                         {'boot_index': 0,",
            "                                          'mount_device': '/dev/vda',",
            "                                          'connection_info': None}]}",
            "        flavor = {'root_gb': 1, 'ephemeral_gb': 0}",
            "        flavor_obj = objects.Flavor(**flavor)",
            "        # Note(Mike_D): The size of instance's ephemeral_gb is 0 gb.",
            "        self._test_migrate_disk_and_power_off(",
            "            flavor_obj, block_device_info=info,",
            "            params_for_instance={'image_ref': None, 'ephemeral_gb': 0})",
            "        disconnect_volume.assert_called_with(",
            "            info['block_device_mapping'][1]['connection_info'], 'vda')",
            "",
            "    @mock.patch('nova.utils.execute')",
            "    @mock.patch('nova.virt.libvirt.utils.copy_image')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._destroy')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.get_host_ip_addr')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver'",
            "                '.get_instance_disk_info')",
            "    def test_migrate_disk_and_power_off_swap(self, mock_get_disk_info,",
            "                                             get_host_ip_addr,",
            "                                             mock_destroy,",
            "                                             mock_copy_image,",
            "                                             mock_execute):",
            "        \"\"\"Test for nova.virt.libvirt.libvirt_driver.LivirtConnection",
            "        .migrate_disk_and_power_off.",
            "        \"\"\"",
            "        self.copy_or_move_swap_called = False",
            "",
            "        disk_info = self._disk_info()",
            "        mock_get_disk_info.return_value = disk_info",
            "        get_host_ip_addr.return_value = '10.0.0.1'",
            "",
            "        def fake_copy_image(*args, **kwargs):",
            "            # disk.swap should not be touched since it is skipped over",
            "            if '/test/disk.swap' in list(args):",
            "                self.copy_or_move_swap_called = True",
            "",
            "        def fake_execute(*args, **kwargs):",
            "            # disk.swap should not be touched since it is skipped over",
            "            if set(['mv', '/test/disk.swap']).issubset(list(args)):",
            "                self.copy_or_move_swap_called = True",
            "",
            "        mock_copy_image.side_effect = fake_copy_image",
            "        mock_execute.side_effect = fake_execute",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        # Original instance config",
            "        instance = self._create_instance({'root_gb': 10,",
            "                                          'ephemeral_gb': 0})",
            "",
            "        # Re-size fake instance to 20G root and 1024M swap disk",
            "        flavor = {'root_gb': 20, 'ephemeral_gb': 0, 'swap': 1024}",
            "        flavor_obj = objects.Flavor(**flavor)",
            "",
            "        # Destination is same host",
            "        out = drvr.migrate_disk_and_power_off(context.get_admin_context(),",
            "                                              instance, '10.0.0.1',",
            "                                              flavor_obj, None)",
            "",
            "        mock_get_disk_info.assert_called_once_with(instance,",
            "                                                   block_device_info=None)",
            "        self.assertTrue(get_host_ip_addr.called)",
            "        mock_destroy.assert_called_once_with(instance)",
            "        self.assertFalse(self.copy_or_move_swap_called)",
            "        self.assertEqual(disk_info, out)",
            "",
            "    def _test_migrate_disk_and_power_off_resize_check(self, expected_exc):",
            "        \"\"\"Test for nova.virt.libvirt.libvirt_driver.LibvirtConnection",
            "        .migrate_disk_and_power_off.",
            "        \"\"\"",
            "",
            "        def fake_get_instance_disk_info(instance, xml=None,",
            "                                        block_device_info=None):",
            "            return self._disk_info()",
            "",
            "        def fake_destroy(instance):",
            "            pass",
            "",
            "        def fake_get_host_ip_addr():",
            "            return '10.0.0.1'",
            "",
            "        self.stubs.Set(self.drvr, 'get_instance_disk_info',",
            "                       fake_get_instance_disk_info)",
            "        self.stubs.Set(self.drvr, '_destroy', fake_destroy)",
            "        self.stubs.Set(self.drvr, 'get_host_ip_addr',",
            "                       fake_get_host_ip_addr)",
            "",
            "        ins_ref = self._create_instance()",
            "        flavor = {'root_gb': 10, 'ephemeral_gb': 20}",
            "        flavor_obj = objects.Flavor(**flavor)",
            "",
            "        # Migration is not implemented for LVM backed instances",
            "        self.assertRaises(expected_exc,",
            "              self.drvr.migrate_disk_and_power_off,",
            "              None, ins_ref, '10.0.0.1', flavor_obj, None)",
            "",
            "    @mock.patch('nova.utils.execute')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._destroy')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver'",
            "                '.get_instance_disk_info')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver'",
            "                '._is_storage_shared_with')",
            "    def _test_migrate_disk_and_power_off_backing_file(self,",
            "                                                      shared_storage,",
            "                                                      mock_is_shared_storage,",
            "                                                      mock_get_disk_info,",
            "                                                      mock_destroy,",
            "                                                      mock_execute):",
            "        self.convert_file_called = False",
            "        flavor = {'root_gb': 20, 'ephemeral_gb': 30, 'swap': 0}",
            "        flavor_obj = objects.Flavor(**flavor)",
            "        disk_info = [{'type': 'qcow2', 'path': '/test/disk',",
            "                      'virt_disk_size': '10737418240',",
            "                      'backing_file': '/base/disk',",
            "                      'disk_size': '83886080'}]",
            "        disk_info_text = jsonutils.dumps(disk_info)",
            "        mock_get_disk_info.return_value = disk_info_text",
            "        mock_is_shared_storage.return_value = shared_storage",
            "",
            "        def fake_execute(*args, **kwargs):",
            "            self.assertNotEqual(args[0:2], ['qemu-img', 'convert'])",
            "",
            "        mock_execute.side_effect = fake_execute",
            "",
            "        instance = self._create_instance()",
            "",
            "        out = self.drvr.migrate_disk_and_power_off(",
            "               context.get_admin_context(), instance, '10.0.0.2',",
            "               flavor_obj, None)",
            "",
            "        self.assertTrue(mock_is_shared_storage.called)",
            "        mock_destroy.assert_called_once_with(instance)",
            "        self.assertEqual(out, disk_info_text)",
            "",
            "    def test_migrate_disk_and_power_off_shared_storage(self):",
            "        self._test_migrate_disk_and_power_off_backing_file(True)",
            "",
            "    def test_migrate_disk_and_power_off_non_shared_storage(self):",
            "        self._test_migrate_disk_and_power_off_backing_file(False)",
            "",
            "    def test_migrate_disk_and_power_off_lvm(self):",
            "        self.flags(images_type='lvm', group='libvirt')",
            "",
            "        def fake_execute(*args, **kwargs):",
            "            pass",
            "",
            "        self.stubs.Set(utils, 'execute', fake_execute)",
            "",
            "        expected_exc = exception.InstanceFaultRollback",
            "        self._test_migrate_disk_and_power_off_resize_check(expected_exc)",
            "",
            "    def test_migrate_disk_and_power_off_resize_cannot_ssh(self):",
            "        def fake_execute(*args, **kwargs):",
            "            raise processutils.ProcessExecutionError()",
            "",
            "        def fake_is_storage_shared(dest, inst_base):",
            "            self.checked_shared_storage = True",
            "            return False",
            "",
            "        self.stubs.Set(self.drvr, '_is_storage_shared_with',",
            "                       fake_is_storage_shared)",
            "        self.stubs.Set(utils, 'execute', fake_execute)",
            "",
            "        expected_exc = exception.InstanceFaultRollback",
            "        self._test_migrate_disk_and_power_off_resize_check(expected_exc)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver'",
            "                '.get_instance_disk_info')",
            "    def test_migrate_disk_and_power_off_resize_error(self, mock_get_disk_info):",
            "        instance = self._create_instance()",
            "        flavor = {'root_gb': 5, 'ephemeral_gb': 10}",
            "        flavor_obj = objects.Flavor(**flavor)",
            "        mock_get_disk_info.return_value = self._disk_info()",
            "",
            "        self.assertRaises(",
            "            exception.InstanceFaultRollback,",
            "            self.drvr.migrate_disk_and_power_off,",
            "            'ctx', instance, '10.0.0.1', flavor_obj, None)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver'",
            "                '.get_instance_disk_info')",
            "    def test_migrate_disk_and_power_off_resize_error_default_ephemeral(",
            "            self, mock_get_disk_info):",
            "        # Note(Mike_D): The size of this instance's ephemeral_gb is 20 gb.",
            "        instance = self._create_instance()",
            "        flavor = {'root_gb': 10, 'ephemeral_gb': 0}",
            "        flavor_obj = objects.Flavor(**flavor)",
            "        mock_get_disk_info.return_value = self._disk_info()",
            "",
            "        self.assertRaises(exception.InstanceFaultRollback,",
            "                          self.drvr.migrate_disk_and_power_off,",
            "                          'ctx', instance, '10.0.0.1', flavor_obj, None)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver'",
            "                '.get_instance_disk_info')",
            "    @mock.patch('nova.virt.driver.block_device_info_get_ephemerals')",
            "    def test_migrate_disk_and_power_off_resize_error_eph(self, mock_get,",
            "                                                         mock_get_disk_info):",
            "        mappings = [",
            "            {",
            "                 'device_name': '/dev/sdb4',",
            "                 'source_type': 'blank',",
            "                 'destination_type': 'local',",
            "                 'device_type': 'disk',",
            "                 'guest_format': 'swap',",
            "                 'boot_index': -1,",
            "                 'volume_size': 1",
            "             },",
            "             {",
            "                 'device_name': '/dev/sda1',",
            "                 'source_type': 'volume',",
            "                 'destination_type': 'volume',",
            "                 'device_type': 'disk',",
            "                 'volume_id': 1,",
            "                 'guest_format': None,",
            "                 'boot_index': 1,",
            "                 'volume_size': 6",
            "             },",
            "             {",
            "                 'device_name': '/dev/sda2',",
            "                 'source_type': 'snapshot',",
            "                 'destination_type': 'volume',",
            "                 'snapshot_id': 1,",
            "                 'device_type': 'disk',",
            "                 'guest_format': None,",
            "                 'boot_index': 0,",
            "                 'volume_size': 4",
            "             },",
            "             {",
            "                 'device_name': '/dev/sda3',",
            "                 'source_type': 'blank',",
            "                 'destination_type': 'local',",
            "                 'device_type': 'disk',",
            "                 'guest_format': None,",
            "                 'boot_index': -1,",
            "                 'volume_size': 3",
            "             }",
            "        ]",
            "        mock_get.return_value = mappings",
            "        instance = self._create_instance()",
            "",
            "        # Old flavor, eph is 20, real disk is 3, target is 2, fail",
            "        flavor = {'root_gb': 10, 'ephemeral_gb': 2}",
            "        flavor_obj = objects.Flavor(**flavor)",
            "        mock_get_disk_info.return_value = self._disk_info()",
            "",
            "        self.assertRaises(",
            "            exception.InstanceFaultRollback,",
            "            self.drvr.migrate_disk_and_power_off,",
            "            'ctx', instance, '10.0.0.1', flavor_obj, None)",
            "",
            "        # Old flavor, eph is 20, real disk is 3, target is 4",
            "        flavor = {'root_gb': 10, 'ephemeral_gb': 4}",
            "        flavor_obj = objects.Flavor(**flavor)",
            "        self._test_migrate_disk_and_power_off(flavor_obj)",
            "",
            "    def test_wait_for_running(self):",
            "        def fake_get_info(instance):",
            "            if instance['name'] == \"not_found\":",
            "                raise exception.InstanceNotFound(instance_id=instance['uuid'])",
            "            elif instance['name'] == \"running\":",
            "                return hardware.InstanceInfo(state=power_state.RUNNING)",
            "            else:",
            "                return hardware.InstanceInfo(state=power_state.SHUTDOWN)",
            "",
            "        self.stubs.Set(self.drvr, 'get_info',",
            "                       fake_get_info)",
            "",
            "        # instance not found case",
            "        self.assertRaises(exception.InstanceNotFound,",
            "                self.drvr._wait_for_running,",
            "                    {'name': 'not_found',",
            "                     'uuid': 'not_found_uuid'})",
            "",
            "        # instance is running case",
            "        self.assertRaises(loopingcall.LoopingCallDone,",
            "                self.drvr._wait_for_running,",
            "                    {'name': 'running',",
            "                     'uuid': 'running_uuid'})",
            "",
            "        # else case",
            "        self.drvr._wait_for_running({'name': 'else',",
            "                                                  'uuid': 'other_uuid'})",
            "",
            "    def test_disk_size_from_instance_disk_info(self):",
            "        instance_data = {'root_gb': 10, 'ephemeral_gb': 20, 'swap_gb': 30}",
            "        inst = objects.Instance(**instance_data)",
            "        info = {'path': '/path/disk'}",
            "        self.assertEqual(10 * units.Gi,",
            "            self.drvr._disk_size_from_instance(inst, info))",
            "",
            "        info = {'path': '/path/disk.local'}",
            "        self.assertEqual(20 * units.Gi,",
            "            self.drvr._disk_size_from_instance(inst, info))",
            "",
            "        info = {'path': '/path/disk.swap'}",
            "        self.assertEqual(0,",
            "            self.drvr._disk_size_from_instance(inst, info))",
            "",
            "    @mock.patch('nova.utils.execute')",
            "    def test_disk_raw_to_qcow2(self, mock_execute):",
            "        path = '/test/disk'",
            "        _path_qcow = path + '_qcow'",
            "",
            "        self.drvr._disk_raw_to_qcow2(path)",
            "        mock_execute.assert_has_calls([",
            "            mock.call('qemu-img', 'convert', '-f', 'raw',",
            "                      '-O', 'qcow2', path, _path_qcow),",
            "            mock.call('mv', _path_qcow, path)])",
            "",
            "    @mock.patch('nova.utils.execute')",
            "    def test_disk_qcow2_to_raw(self, mock_execute):",
            "        path = '/test/disk'",
            "        _path_raw = path + '_raw'",
            "",
            "        self.drvr._disk_qcow2_to_raw(path)",
            "        mock_execute.assert_has_calls([",
            "            mock.call('qemu-img', 'convert', '-f', 'qcow2',",
            "                      '-O', 'raw', path, _path_raw),",
            "            mock.call('mv', _path_raw, path)])",
            "",
            "    @mock.patch('nova.virt.disk.api.extend')",
            "    def test_disk_resize_raw(self, mock_extend):",
            "        image = imgmodel.LocalFileImage(\"/test/disk\",",
            "                                        imgmodel.FORMAT_RAW)",
            "",
            "        self.drvr._disk_resize(image, 50)",
            "        mock_extend.assert_called_once_with(image, 50)",
            "",
            "    @mock.patch('nova.virt.disk.api.can_resize_image')",
            "    @mock.patch('nova.virt.disk.api.is_image_extendable')",
            "    @mock.patch('nova.virt.disk.api.extend')",
            "    def test_disk_resize_qcow2(",
            "            self, mock_extend, mock_can_resize, mock_is_image_extendable):",
            "",
            "        with test.nested(",
            "                mock.patch.object(",
            "                    self.drvr, '_disk_qcow2_to_raw'),",
            "                mock.patch.object(",
            "                    self.drvr, '_disk_raw_to_qcow2'))\\",
            "        as (mock_disk_qcow2_to_raw, mock_disk_raw_to_qcow2):",
            "",
            "            mock_can_resize.return_value = True",
            "            mock_is_image_extendable.return_value = True",
            "",
            "            imageqcow2 = imgmodel.LocalFileImage(\"/test/disk\",",
            "                                                 imgmodel.FORMAT_QCOW2)",
            "            imageraw = imgmodel.LocalFileImage(\"/test/disk\",",
            "                                               imgmodel.FORMAT_RAW)",
            "            self.drvr._disk_resize(imageqcow2, 50)",
            "",
            "            mock_disk_qcow2_to_raw.assert_called_once_with(imageqcow2.path)",
            "            mock_extend.assert_called_once_with(imageraw, 50)",
            "            mock_disk_raw_to_qcow2.assert_called_once_with(imageqcow2.path)",
            "",
            "    def _test_finish_migration(self, power_on, resize_instance=False):",
            "        \"\"\"Test for nova.virt.libvirt.libvirt_driver.LivirtConnection",
            "        .finish_migration.",
            "        \"\"\"",
            "",
            "        powered_on = power_on",
            "        self.fake_create_domain_called = False",
            "        self.fake_disk_resize_called = False",
            "",
            "        def fake_to_xml(context, instance, network_info, disk_info,",
            "                        image_meta=None, rescue=None,",
            "                        block_device_info=None, write_to_disk=False):",
            "            return \"\"",
            "",
            "        def fake_plug_vifs(instance, network_info):",
            "            pass",
            "",
            "        def fake_create_image(context, inst,",
            "                              disk_mapping, suffix='',",
            "                              disk_images=None, network_info=None,",
            "                              block_device_info=None, inject_files=True,",
            "                              fallback_from_host=None):",
            "            self.assertFalse(inject_files)",
            "",
            "        def fake_create_domain_and_network(",
            "            context, xml, instance, network_info, disk_info,",
            "            block_device_info=None, power_on=True, reboot=False,",
            "            vifs_already_plugged=False):",
            "            self.fake_create_domain_called = True",
            "            self.assertEqual(powered_on, power_on)",
            "            self.assertTrue(vifs_already_plugged)",
            "",
            "        def fake_enable_hairpin():",
            "            pass",
            "",
            "        def fake_execute(*args, **kwargs):",
            "            pass",
            "",
            "        def fake_get_info(instance):",
            "            if powered_on:",
            "                return hardware.InstanceInfo(state=power_state.RUNNING)",
            "            else:",
            "                return hardware.InstanceInfo(state=power_state.SHUTDOWN)",
            "",
            "        def fake_disk_resize(image, size):",
            "            self.fake_disk_resize_called = True",
            "",
            "        self.flags(use_cow_images=True)",
            "        self.stubs.Set(self.drvr, '_disk_resize',",
            "                       fake_disk_resize)",
            "        self.stubs.Set(self.drvr, '_get_guest_xml', fake_to_xml)",
            "        self.stubs.Set(self.drvr, 'plug_vifs', fake_plug_vifs)",
            "        self.stubs.Set(self.drvr, '_create_image',",
            "                       fake_create_image)",
            "        self.stubs.Set(self.drvr, '_create_domain_and_network',",
            "                       fake_create_domain_and_network)",
            "        self.stubs.Set(nova.virt.libvirt.guest.Guest, 'enable_hairpin',",
            "                       fake_enable_hairpin)",
            "        self.stubs.Set(utils, 'execute', fake_execute)",
            "        fw = base_firewall.NoopFirewallDriver()",
            "        self.stubs.Set(self.drvr, 'firewall_driver', fw)",
            "        self.stubs.Set(self.drvr, 'get_info',",
            "                       fake_get_info)",
            "",
            "        ins_ref = self._create_instance()",
            "",
            "        migration = objects.Migration()",
            "        migration.source_compute = 'fake-source-compute'",
            "        migration.dest_compute = 'fake-dest-compute'",
            "        migration.source_node = 'fake-source-node'",
            "        migration.dest_node = 'fake-dest-node'",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        self.drvr.finish_migration(",
            "                      context.get_admin_context(), migration, ins_ref,",
            "                      self._disk_info(), [], image_meta,",
            "                      resize_instance, None, power_on)",
            "        self.assertTrue(self.fake_create_domain_called)",
            "        self.assertEqual(",
            "            resize_instance, self.fake_disk_resize_called)",
            "",
            "    def test_finish_migration_resize(self):",
            "        self._test_finish_migration(True, resize_instance=True)",
            "",
            "    def test_finish_migration_power_on(self):",
            "        self._test_finish_migration(True)",
            "",
            "    def test_finish_migration_power_off(self):",
            "        self._test_finish_migration(False)",
            "",
            "    def _test_finish_revert_migration(self, power_on):",
            "        \"\"\"Test for nova.virt.libvirt.libvirt_driver.LivirtConnection",
            "        .finish_revert_migration.",
            "        \"\"\"",
            "        powered_on = power_on",
            "",
            "        self.fake_create_domain_called = False",
            "",
            "        def fake_execute(*args, **kwargs):",
            "            pass",
            "",
            "        def fake_plug_vifs(instance, network_info):",
            "            pass",
            "",
            "        def fake_create_domain(context, xml, instance, network_info,",
            "                               disk_info, block_device_info=None,",
            "                               power_on=None,",
            "                               vifs_already_plugged=None):",
            "            self.fake_create_domain_called = True",
            "            self.assertEqual(powered_on, power_on)",
            "            self.assertTrue(vifs_already_plugged)",
            "            return mock.MagicMock()",
            "",
            "        def fake_enable_hairpin():",
            "            pass",
            "",
            "        def fake_get_info(instance):",
            "            if powered_on:",
            "                return hardware.InstanceInfo(state=power_state.RUNNING)",
            "            else:",
            "                return hardware.InstanceInfo(state=power_state.SHUTDOWN)",
            "",
            "        def fake_to_xml(context, instance, network_info, disk_info,",
            "                        image_meta=None, rescue=None,",
            "                        block_device_info=None):",
            "            return \"\"",
            "",
            "        self.stubs.Set(self.drvr, '_get_guest_xml', fake_to_xml)",
            "        self.stubs.Set(self.drvr, 'plug_vifs', fake_plug_vifs)",
            "        self.stubs.Set(utils, 'execute', fake_execute)",
            "        fw = base_firewall.NoopFirewallDriver()",
            "        self.stubs.Set(self.drvr, 'firewall_driver', fw)",
            "        self.stubs.Set(self.drvr, '_create_domain_and_network',",
            "                       fake_create_domain)",
            "        self.stubs.Set(nova.virt.libvirt.guest.Guest, 'enable_hairpin',",
            "                       fake_enable_hairpin)",
            "        self.stubs.Set(self.drvr, 'get_info',",
            "                       fake_get_info)",
            "        self.stubs.Set(utils, 'get_image_from_system_metadata',",
            "                       lambda *a: self.test_image_meta)",
            "",
            "        with utils.tempdir() as tmpdir:",
            "            self.flags(instances_path=tmpdir)",
            "            ins_ref = self._create_instance()",
            "            os.mkdir(os.path.join(tmpdir, ins_ref['name']))",
            "            libvirt_xml_path = os.path.join(tmpdir,",
            "                                            ins_ref['name'],",
            "                                            'libvirt.xml')",
            "            f = open(libvirt_xml_path, 'w')",
            "            f.close()",
            "",
            "            self.drvr.finish_revert_migration(",
            "                                       context.get_admin_context(), ins_ref,",
            "                                       [], None, power_on)",
            "            self.assertTrue(self.fake_create_domain_called)",
            "",
            "    def test_finish_revert_migration_power_on(self):",
            "        self._test_finish_revert_migration(True)",
            "",
            "    def test_finish_revert_migration_power_off(self):",
            "        self._test_finish_revert_migration(False)",
            "",
            "    def _test_finish_revert_migration_after_crash(self, backup_made=True,",
            "                                                  del_inst_failed=False):",
            "        class FakeLoopingCall(object):",
            "            def start(self, *a, **k):",
            "                return self",
            "",
            "            def wait(self):",
            "                return None",
            "        context = 'fake_context'",
            "",
            "        instance = self._create_instance()",
            "        self.mox.StubOutWithMock(imagebackend.Backend, 'image')",
            "        self.mox.StubOutWithMock(libvirt_utils, 'get_instance_path')",
            "        self.mox.StubOutWithMock(os.path, 'exists')",
            "        self.mox.StubOutWithMock(shutil, 'rmtree')",
            "        self.mox.StubOutWithMock(utils, 'execute')",
            "",
            "        self.stubs.Set(blockinfo, 'get_disk_info', lambda *a: None)",
            "        self.stubs.Set(self.drvr, '_get_guest_xml',",
            "                       lambda *a, **k: None)",
            "        self.stubs.Set(self.drvr, '_create_domain_and_network',",
            "                       lambda *a, **kw: None)",
            "        self.stubs.Set(loopingcall, 'FixedIntervalLoopingCall',",
            "                       lambda *a, **k: FakeLoopingCall())",
            "",
            "        libvirt_utils.get_instance_path(instance).AndReturn('/fake/foo')",
            "        os.path.exists('/fake/foo_resize').AndReturn(backup_made)",
            "        if backup_made:",
            "            if del_inst_failed:",
            "                os_error = OSError(errno.ENOENT, 'No such file or directory')",
            "                shutil.rmtree('/fake/foo').AndRaise(os_error)",
            "            else:",
            "                shutil.rmtree('/fake/foo')",
            "            utils.execute('mv', '/fake/foo_resize', '/fake/foo')",
            "",
            "        imagebackend.Backend.image(mox.IgnoreArg(), 'disk').AndReturn(",
            "                fake_imagebackend.Raw())",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.drvr.finish_revert_migration(context, instance, [])",
            "",
            "    def test_finish_revert_migration_after_crash(self):",
            "        self._test_finish_revert_migration_after_crash(backup_made=True)",
            "",
            "    def test_finish_revert_migration_after_crash_before_new(self):",
            "        self._test_finish_revert_migration_after_crash(backup_made=True)",
            "",
            "    def test_finish_revert_migration_after_crash_before_backup(self):",
            "        self._test_finish_revert_migration_after_crash(backup_made=False)",
            "",
            "    def test_finish_revert_migration_after_crash_delete_failed(self):",
            "        self._test_finish_revert_migration_after_crash(backup_made=True,",
            "                                                       del_inst_failed=True)",
            "",
            "    def test_finish_revert_migration_preserves_disk_bus(self):",
            "",
            "        def fake_get_guest_xml(context, instance, network_info, disk_info,",
            "                               image_meta, block_device_info=None):",
            "            self.assertEqual('ide', disk_info['disk_bus'])",
            "",
            "        image_meta = {\"disk_format\": \"raw\",",
            "                      \"properties\": {\"hw_disk_bus\": \"ide\"}}",
            "        instance = self._create_instance()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        with test.nested(",
            "                mock.patch.object(drvr, '_create_domain_and_network'),",
            "                mock.patch.object(utils, 'get_image_from_system_metadata',",
            "                                  return_value=image_meta),",
            "                mock.patch.object(drvr, '_get_guest_xml',",
            "                                  side_effect=fake_get_guest_xml)):",
            "            drvr.finish_revert_migration('', instance, None, power_on=False)",
            "",
            "    def test_finish_revert_migration_snap_backend(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr.image_backend = mock.Mock()",
            "        drvr.image_backend.image.return_value = drvr.image_backend",
            "        ins_ref = self._create_instance()",
            "",
            "        with test.nested(",
            "                mock.patch.object(utils, 'get_image_from_system_metadata'),",
            "                mock.patch.object(drvr, '_create_domain_and_network'),",
            "                mock.patch.object(drvr, '_get_guest_xml')) as (",
            "                mock_image, mock_cdn, mock_ggx):",
            "            mock_image.return_value = {'disk_format': 'raw'}",
            "            drvr.finish_revert_migration('', ins_ref, None, power_on=False)",
            "",
            "            drvr.image_backend.rollback_to_snap.assert_called_once_with(",
            "                    libvirt_utils.RESIZE_SNAPSHOT_NAME)",
            "            drvr.image_backend.remove_snap.assert_called_once_with(",
            "                    libvirt_utils.RESIZE_SNAPSHOT_NAME, ignore_errors=True)",
            "",
            "    def test_finish_revert_migration_snap_backend_snapshot_not_found(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr.image_backend = mock.Mock()",
            "        drvr.image_backend.image.return_value = drvr.image_backend",
            "        ins_ref = self._create_instance()",
            "",
            "        with test.nested(",
            "                mock.patch.object(rbd_utils, 'RBDDriver'),",
            "                mock.patch.object(utils, 'get_image_from_system_metadata'),",
            "                mock.patch.object(drvr, '_create_domain_and_network'),",
            "                mock.patch.object(drvr, '_get_guest_xml')) as (",
            "                mock_rbd, mock_image, mock_cdn, mock_ggx):",
            "            mock_image.return_value = {'disk_format': 'raw'}",
            "            mock_rbd.rollback_to_snap.side_effect = exception.SnapshotNotFound(",
            "                    snapshot_id='testing')",
            "            drvr.finish_revert_migration('', ins_ref, None, power_on=False)",
            "",
            "            drvr.image_backend.remove_snap.assert_called_once_with(",
            "                    libvirt_utils.RESIZE_SNAPSHOT_NAME, ignore_errors=True)",
            "",
            "    def test_cleanup_failed_migration(self):",
            "        self.mox.StubOutWithMock(shutil, 'rmtree')",
            "        shutil.rmtree('/fake/inst')",
            "        self.mox.ReplayAll()",
            "        self.drvr._cleanup_failed_migration('/fake/inst')",
            "",
            "    def test_confirm_migration(self):",
            "        ins_ref = self._create_instance()",
            "",
            "        self.mox.StubOutWithMock(self.drvr, \"_cleanup_resize\")",
            "        self.drvr._cleanup_resize(ins_ref,",
            "                             _fake_network_info(self, 1))",
            "",
            "        self.mox.ReplayAll()",
            "        self.drvr.confirm_migration(\"migration_ref\", ins_ref,",
            "                                            _fake_network_info(self, 1))",
            "",
            "    def test_cleanup_resize_same_host(self):",
            "        CONF.set_override('policy_dirs', [], group='oslo_policy')",
            "        ins_ref = self._create_instance({'host': CONF.host})",
            "",
            "        def fake_os_path_exists(path):",
            "            return True",
            "",
            "        self.stub_out('os.path.exists', fake_os_path_exists)",
            "",
            "        self.mox.StubOutWithMock(imagebackend.Backend, 'image')",
            "        self.mox.StubOutWithMock(libvirt_utils, 'get_instance_path')",
            "        self.mox.StubOutWithMock(utils, 'execute')",
            "",
            "        libvirt_utils.get_instance_path(ins_ref,",
            "                forceold=True).AndReturn('/fake/inst')",
            "        utils.execute('rm', '-rf', '/fake/inst_resize', delay_on_retry=True,",
            "                      attempts=5)",
            "        imagebackend.Backend.image(ins_ref, 'disk').AndReturn(",
            "            fake_imagebackend.Raw())",
            "",
            "        self.mox.ReplayAll()",
            "        self.drvr._cleanup_resize(ins_ref,",
            "                                            _fake_network_info(self, 1))",
            "",
            "    def test_cleanup_resize_not_same_host(self):",
            "        CONF.set_override('policy_dirs', [], group='oslo_policy')",
            "        host = 'not' + CONF.host",
            "        ins_ref = self._create_instance({'host': host})",
            "",
            "        def fake_os_path_exists(path):",
            "            return True",
            "",
            "        def fake_undefine_domain(instance):",
            "            pass",
            "",
            "        def fake_unplug_vifs(instance, network_info, ignore_errors=False):",
            "            pass",
            "",
            "        def fake_unfilter_instance(instance, network_info):",
            "            pass",
            "",
            "        self.stub_out('os.path.exists', fake_os_path_exists)",
            "        self.stubs.Set(self.drvr, '_undefine_domain',",
            "                       fake_undefine_domain)",
            "        self.stubs.Set(self.drvr, 'unplug_vifs',",
            "                       fake_unplug_vifs)",
            "        self.stubs.Set(self.drvr.firewall_driver,",
            "                       'unfilter_instance', fake_unfilter_instance)",
            "",
            "        self.mox.StubOutWithMock(imagebackend.Backend, 'image')",
            "        self.mox.StubOutWithMock(libvirt_utils, 'get_instance_path')",
            "        self.mox.StubOutWithMock(utils, 'execute')",
            "",
            "        libvirt_utils.get_instance_path(ins_ref,",
            "                forceold=True).AndReturn('/fake/inst')",
            "        utils.execute('rm', '-rf', '/fake/inst_resize', delay_on_retry=True,",
            "                      attempts=5)",
            "        imagebackend.Backend.image(ins_ref, 'disk').AndReturn(",
            "                fake_imagebackend.Raw())",
            "",
            "        self.mox.ReplayAll()",
            "        self.drvr._cleanup_resize(ins_ref,",
            "                                            _fake_network_info(self, 1))",
            "",
            "    def test_cleanup_resize_snap_backend(self):",
            "        CONF.set_override('policy_dirs', [], group='oslo_policy')",
            "        ins_ref = self._create_instance({'host': CONF.host})",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr.image_backend = mock.Mock()",
            "        drvr.image_backend.image.return_value = drvr.image_backend",
            "",
            "        with test.nested(",
            "                mock.patch.object(os.path, 'exists'),",
            "                mock.patch.object(libvirt_utils, 'get_instance_path'),",
            "                mock.patch.object(utils, 'execute'),",
            "                mock.patch.object(drvr.image_backend, 'remove_snap')) as (",
            "                mock_exists, mock_get_path, mock_exec, mock_remove):",
            "            mock_exists.return_value = True",
            "            mock_get_path.return_value = '/fake/inst'",
            "",
            "            drvr._cleanup_resize(ins_ref, _fake_network_info(self, 1))",
            "            mock_get_path.assert_called_once_with(ins_ref, forceold=True)",
            "            mock_exec.assert_called_once_with('rm', '-rf', '/fake/inst_resize',",
            "                                              delay_on_retry=True, attempts=5)",
            "            mock_remove.assert_called_once_with(",
            "                    libvirt_utils.RESIZE_SNAPSHOT_NAME, ignore_errors=True)",
            "",
            "    def test_get_instance_disk_info_exception(self):",
            "        instance = self._create_instance()",
            "",
            "        class FakeExceptionDomain(FakeVirtDomain):",
            "            def __init__(self):",
            "                super(FakeExceptionDomain, self).__init__()",
            "",
            "            def XMLDesc(self, flags):",
            "                raise fakelibvirt.libvirtError(\"Libvirt error\")",
            "",
            "        def fake_get_domain(self, instance):",
            "            return FakeExceptionDomain()",
            "",
            "        self.stubs.Set(host.Host, 'get_domain',",
            "                       fake_get_domain)",
            "        self.assertRaises(exception.InstanceNotFound,",
            "            self.drvr.get_instance_disk_info,",
            "            instance)",
            "",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch.object(lvm, 'list_volumes')",
            "    def test_lvm_disks(self, listlvs, exists):",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "        self.flags(images_volume_group='vols', group='libvirt')",
            "        exists.return_value = True",
            "        listlvs.return_value = ['fake-uuid_foo',",
            "                                'other-uuid_foo']",
            "        disks = self.drvr._lvm_disks(instance)",
            "        self.assertEqual(['/dev/vols/fake-uuid_foo'], disks)",
            "",
            "    def test_is_booted_from_volume(self):",
            "        func = libvirt_driver.LibvirtDriver._is_booted_from_volume",
            "        instance, disk_mapping = {}, {}",
            "",
            "        self.assertTrue(func(instance, disk_mapping))",
            "        disk_mapping['disk'] = 'map'",
            "        self.assertTrue(func(instance, disk_mapping))",
            "",
            "        instance['image_ref'] = 'uuid'",
            "        self.assertFalse(func(instance, disk_mapping))",
            "",
            "    @mock.patch('nova.virt.netutils.get_injected_network_template')",
            "    @mock.patch('nova.virt.disk.api.inject_data')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, \"_conn\")",
            "    def _test_inject_data(self, driver_params, path, disk_params,",
            "                          mock_conn, disk_inject_data, inj_network,",
            "                          called=True):",
            "        class ImageBackend(object):",
            "            path = '/path'",
            "",
            "            def check_image_exists(self):",
            "                if self.path == '/fail/path':",
            "                    return False",
            "                return True",
            "",
            "            def get_model(self, connection):",
            "                return imgmodel.LocalFileImage(self.path,",
            "                                               imgmodel.FORMAT_RAW)",
            "",
            "        def fake_inj_network(*args, **kwds):",
            "            return args[0] or None",
            "        inj_network.side_effect = fake_inj_network",
            "",
            "        image_backend = ImageBackend()",
            "        image_backend.path = path",
            "",
            "        with mock.patch.object(",
            "                self.drvr.image_backend,",
            "                'image',",
            "                return_value=image_backend):",
            "            self.flags(inject_partition=0, group='libvirt')",
            "",
            "            self.drvr._inject_data(**driver_params)",
            "",
            "            if called:",
            "                disk_inject_data.assert_called_once_with(",
            "                    mock.ANY,",
            "                    *disk_params,",
            "                    partition=None, mandatory=('files',))",
            "",
            "            self.assertEqual(disk_inject_data.called, called)",
            "",
            "    def _test_inject_data_default_driver_params(self, **params):",
            "        return {",
            "            'instance': self._create_instance(params=params),",
            "            'network_info': None,",
            "            'admin_pass': None,",
            "            'files': None,",
            "            'suffix': ''",
            "        }",
            "",
            "    def test_inject_data_adminpass(self):",
            "        self.flags(inject_password=True, group='libvirt')",
            "        driver_params = self._test_inject_data_default_driver_params()",
            "        driver_params['admin_pass'] = 'foobar'",
            "        disk_params = [",
            "            None,  # key",
            "            None,  # net",
            "            {},  # metadata",
            "            'foobar',  # admin_pass",
            "            None,  # files",
            "        ]",
            "        self._test_inject_data(driver_params, \"/path\", disk_params)",
            "",
            "        # Test with the configuration setted to false.",
            "        self.flags(inject_password=False, group='libvirt')",
            "        self._test_inject_data(driver_params, \"/path\",",
            "                               disk_params, called=False)",
            "",
            "    def test_inject_data_key(self):",
            "        driver_params = self._test_inject_data_default_driver_params()",
            "        driver_params['instance']['key_data'] = 'key-content'",
            "",
            "        self.flags(inject_key=True, group='libvirt')",
            "        disk_params = [",
            "            'key-content',  # key",
            "            None,  # net",
            "            {},  # metadata",
            "            None,  # admin_pass",
            "            None,  # files",
            "        ]",
            "        self._test_inject_data(driver_params, \"/path\", disk_params)",
            "",
            "        # Test with the configuration setted to false.",
            "        self.flags(inject_key=False, group='libvirt')",
            "        self._test_inject_data(driver_params, \"/path\",",
            "                               disk_params, called=False)",
            "",
            "    def test_inject_data_metadata(self):",
            "        instance_metadata = {'metadata': {'data': 'foo'}}",
            "        driver_params = self._test_inject_data_default_driver_params(",
            "            **instance_metadata",
            "        )",
            "        disk_params = [",
            "            None,  # key",
            "            None,  # net",
            "            {'data': 'foo'},  # metadata",
            "            None,  # admin_pass",
            "            None,  # files",
            "        ]",
            "        self._test_inject_data(driver_params, \"/path\", disk_params)",
            "",
            "    def test_inject_data_files(self):",
            "        driver_params = self._test_inject_data_default_driver_params()",
            "        driver_params['files'] = ['file1', 'file2']",
            "        disk_params = [",
            "            None,  # key",
            "            None,  # net",
            "            {},  # metadata",
            "            None,  # admin_pass",
            "            ['file1', 'file2'],  # files",
            "        ]",
            "        self._test_inject_data(driver_params, \"/path\", disk_params)",
            "",
            "    def test_inject_data_net(self):",
            "        driver_params = self._test_inject_data_default_driver_params()",
            "        driver_params['network_info'] = {'net': 'eno1'}",
            "        disk_params = [",
            "            None,  # key",
            "            {'net': 'eno1'},  # net",
            "            {},  # metadata",
            "            None,  # admin_pass",
            "            None,  # files",
            "        ]",
            "        self._test_inject_data(driver_params, \"/path\", disk_params)",
            "",
            "    def test_inject_not_exist_image(self):",
            "        driver_params = self._test_inject_data_default_driver_params()",
            "        disk_params = [",
            "            'key-content',  # key",
            "            None,  # net",
            "            None,  # metadata",
            "            None,  # admin_pass",
            "            None,  # files",
            "        ]",
            "        self._test_inject_data(driver_params, \"/fail/path\",",
            "                               disk_params, called=False)",
            "",
            "    def _test_attach_detach_interface(self, method, power_state,",
            "                                      expected_flags):",
            "        instance = self._create_instance()",
            "        network_info = _fake_network_info(self, 1)",
            "        domain = FakeVirtDomain()",
            "        self.mox.StubOutWithMock(host.Host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr.firewall_driver,",
            "                                 'setup_basic_filtering')",
            "        self.mox.StubOutWithMock(domain, 'attachDeviceFlags')",
            "        self.mox.StubOutWithMock(domain, 'info')",
            "",
            "        host.Host.get_domain(instance).AndReturn(domain)",
            "        if method == 'attach_interface':",
            "            self.drvr.firewall_driver.setup_basic_filtering(",
            "                instance, [network_info[0]])",
            "",
            "        fake_image_meta = objects.ImageMeta.from_dict(",
            "            {'id': instance.image_ref})",
            "",
            "        expected = self.drvr.vif_driver.get_config(",
            "            instance, network_info[0], fake_image_meta, instance.flavor,",
            "            CONF.libvirt.virt_type, self.drvr._host)",
            "",
            "        self.mox.StubOutWithMock(self.drvr.vif_driver,",
            "                                 'get_config')",
            "        self.drvr.vif_driver.get_config(",
            "            instance, network_info[0],",
            "            mox.IsA(objects.ImageMeta),",
            "            mox.IsA(objects.Flavor),",
            "            CONF.libvirt.virt_type,",
            "            self.drvr._host).AndReturn(expected)",
            "        domain.info().AndReturn([power_state, 1, 2, 3, 4])",
            "        if method == 'attach_interface':",
            "            domain.attachDeviceFlags(expected.to_xml(), flags=expected_flags)",
            "        elif method == 'detach_interface':",
            "            domain.detachDeviceFlags(expected.to_xml(), expected_flags)",
            "",
            "        self.mox.ReplayAll()",
            "        if method == 'attach_interface':",
            "            self.drvr.attach_interface(",
            "                instance, fake_image_meta, network_info[0])",
            "        elif method == 'detach_interface':",
            "            self.drvr.detach_interface(",
            "                instance, network_info[0])",
            "        self.mox.VerifyAll()",
            "",
            "    def test_attach_interface_with_running_instance(self):",
            "        self._test_attach_detach_interface(",
            "            'attach_interface', power_state.RUNNING,",
            "            expected_flags=(fakelibvirt.VIR_DOMAIN_AFFECT_CONFIG |",
            "                            fakelibvirt.VIR_DOMAIN_AFFECT_LIVE))",
            "",
            "    def test_attach_interface_with_pause_instance(self):",
            "        self._test_attach_detach_interface(",
            "            'attach_interface', power_state.PAUSED,",
            "            expected_flags=(fakelibvirt.VIR_DOMAIN_AFFECT_CONFIG |",
            "                            fakelibvirt.VIR_DOMAIN_AFFECT_LIVE))",
            "",
            "    def test_attach_interface_with_shutdown_instance(self):",
            "        self._test_attach_detach_interface(",
            "            'attach_interface', power_state.SHUTDOWN,",
            "            expected_flags=(fakelibvirt.VIR_DOMAIN_AFFECT_CONFIG))",
            "",
            "    def test_detach_interface_with_running_instance(self):",
            "        self._test_attach_detach_interface(",
            "            'detach_interface', power_state.RUNNING,",
            "            expected_flags=(fakelibvirt.VIR_DOMAIN_AFFECT_CONFIG |",
            "                            fakelibvirt.VIR_DOMAIN_AFFECT_LIVE))",
            "",
            "    def test_detach_interface_with_pause_instance(self):",
            "        self._test_attach_detach_interface(",
            "            'detach_interface', power_state.PAUSED,",
            "            expected_flags=(fakelibvirt.VIR_DOMAIN_AFFECT_CONFIG |",
            "                            fakelibvirt.VIR_DOMAIN_AFFECT_LIVE))",
            "",
            "    def test_detach_interface_with_shutdown_instance(self):",
            "        self._test_attach_detach_interface(",
            "            'detach_interface', power_state.SHUTDOWN,",
            "            expected_flags=(fakelibvirt.VIR_DOMAIN_AFFECT_CONFIG))",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG')",
            "    def test_detach_interface_device_not_found(self, mock_log):",
            "        # Asserts that we don't log an error when the interface device is not",
            "        # found on the guest after a libvirt error during detach.",
            "        instance = self._create_instance()",
            "        vif = _fake_network_info(self, 1)[0]",
            "        guest = mock.Mock(spec='nova.virt.libvirt.guest.Guest')",
            "        guest.get_power_state = mock.Mock()",
            "        self.drvr._host.get_guest = mock.Mock(return_value=guest)",
            "        self.drvr.vif_driver = mock.Mock()",
            "        error = fakelibvirt.libvirtError(",
            "            'no matching network device was found')",
            "        error.err = (fakelibvirt.VIR_ERR_OPERATION_FAILED,)",
            "        guest.detach_device = mock.Mock(side_effect=error)",
            "        # mock out that get_interface_by_mac doesn't find the interface",
            "        guest.get_interface_by_mac = mock.Mock(return_value=None)",
            "        self.drvr.detach_interface(instance, vif)",
            "        guest.get_interface_by_mac.assert_called_once_with(vif['address'])",
            "        # an error shouldn't be logged, but a warning should be logged",
            "        self.assertFalse(mock_log.error.called)",
            "        self.assertEqual(1, mock_log.warning.call_count)",
            "        self.assertIn('the device is no longer found on the guest',",
            "                      six.text_type(mock_log.warning.call_args[0]))",
            "",
            "    def test_rescue(self):",
            "        instance = self._create_instance({'config_drive': None})",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices>\"",
            "                    \"<disk type='file'><driver name='qemu' type='raw'/>\"",
            "                    \"<source file='/test/disk'/>\"",
            "                    \"<target dev='vda' bus='virtio'/></disk>\"",
            "                    \"<disk type='file'><driver name='qemu' type='qcow2'/>\"",
            "                    \"<source file='/test/disk.local'/>\"",
            "                    \"<target dev='vdb' bus='virtio'/></disk>\"",
            "                    \"</devices></domain>\")",
            "        network_info = _fake_network_info(self, 1)",
            "",
            "        self.mox.StubOutWithMock(self.drvr,",
            "                                     '_get_existing_domain_xml')",
            "        self.mox.StubOutWithMock(libvirt_utils, 'write_to_file')",
            "        self.mox.StubOutWithMock(imagebackend.Backend, 'image')",
            "        self.mox.StubOutWithMock(imagebackend.Image, 'cache')",
            "        self.mox.StubOutWithMock(self.drvr, '_get_guest_xml')",
            "        self.mox.StubOutWithMock(self.drvr, '_destroy')",
            "        self.mox.StubOutWithMock(self.drvr, '_create_domain')",
            "",
            "        self.drvr._get_existing_domain_xml(mox.IgnoreArg(),",
            "                        mox.IgnoreArg()).MultipleTimes().AndReturn(dummyxml)",
            "        libvirt_utils.write_to_file(mox.IgnoreArg(), mox.IgnoreArg())",
            "        libvirt_utils.write_to_file(mox.IgnoreArg(), mox.IgnoreArg(),",
            "                               mox.IgnoreArg())",
            "        imagebackend.Backend.image(instance, 'kernel.rescue', 'raw'",
            "                                        ).AndReturn(fake_imagebackend.Raw())",
            "        imagebackend.Backend.image(instance, 'ramdisk.rescue', 'raw'",
            "                                        ).AndReturn(fake_imagebackend.Raw())",
            "        imagebackend.Backend.image(instance, 'disk.rescue', 'default'",
            "                                        ).AndReturn(fake_imagebackend.Raw())",
            "        imagebackend.Image.cache(context=mox.IgnoreArg(),",
            "                                fetch_func=mox.IgnoreArg(),",
            "                                filename=mox.IgnoreArg(),",
            "                                image_id=mox.IgnoreArg(),",
            "                                project_id=mox.IgnoreArg(),",
            "                                user_id=mox.IgnoreArg()).MultipleTimes()",
            "",
            "        imagebackend.Image.cache(context=mox.IgnoreArg(),",
            "                                fetch_func=mox.IgnoreArg(),",
            "                                filename=mox.IgnoreArg(),",
            "                                image_id=mox.IgnoreArg(),",
            "                                project_id=mox.IgnoreArg(),",
            "                                size=None, user_id=mox.IgnoreArg())",
            "",
            "        image_meta = objects.ImageMeta.from_dict(",
            "            {'id': 'fake', 'name': 'fake'})",
            "        self.drvr._get_guest_xml(mox.IgnoreArg(), instance,",
            "                                 network_info, mox.IgnoreArg(),",
            "                                 image_meta,",
            "                                 rescue=mox.IgnoreArg(),",
            "                                 write_to_disk=mox.IgnoreArg()",
            "                             ).AndReturn(dummyxml)",
            "",
            "        self.drvr._destroy(instance)",
            "        self.drvr._create_domain(mox.IgnoreArg())",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        rescue_password = 'fake_password'",
            "",
            "        self.drvr.rescue(self.context, instance,",
            "                    network_info, image_meta, rescue_password)",
            "        self.mox.VerifyAll()",
            "",
            "    @mock.patch.object(libvirt_utils, 'get_instance_path')",
            "    @mock.patch.object(libvirt_utils, 'load_file')",
            "    @mock.patch.object(host.Host, \"get_domain\")",
            "    def test_unrescue(self, mock_get_domain, mock_load_file,",
            "                                           mock_get_instance_path):",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices>\"",
            "                    \"<disk type='block' device='disk'>\"",
            "                    \"<source dev='/dev/some-vg/some-lv'/>\"",
            "                    \"<target dev='vda' bus='virtio'/></disk>\"",
            "                    \"</devices></domain>\")",
            "",
            "        mock_get_instance_path.return_value = '/path'",
            "        instance = objects.Instance(uuid='fake=uuid', id=1)",
            "        fake_dom = FakeVirtDomain(fake_xml=dummyxml)",
            "        mock_get_domain.return_value = fake_dom",
            "        mock_load_file.return_value = \"fake_unrescue_xml\"",
            "        unrescue_xml_path = os.path.join('/path', 'unrescue.xml')",
            "        rescue_file = os.path.join('/path', 'rescue.file')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        with test.nested(",
            "                mock.patch.object(drvr, '_destroy'),",
            "                mock.patch.object(drvr, '_create_domain'),",
            "                mock.patch.object(libvirt_utils, 'file_delete'),",
            "                mock.patch.object(drvr, '_lvm_disks',",
            "                                  return_value=['lvm.rescue']),",
            "                mock.patch.object(lvm, 'remove_volumes'),",
            "                mock.patch.object(glob, 'iglob', return_value=[rescue_file])",
            "                ) as (mock_destroy, mock_create, mock_del, mock_lvm_disks,",
            "                      mock_remove_volumes, mock_glob):",
            "            drvr.unrescue(instance, None)",
            "            mock_destroy.assert_called_once_with(instance)",
            "            mock_create.assert_called_once_with(\"fake_unrescue_xml\",",
            "                                                 fake_dom)",
            "            self.assertEqual(2, mock_del.call_count)",
            "            self.assertEqual(unrescue_xml_path,",
            "                             mock_del.call_args_list[0][0][0])",
            "            self.assertEqual(rescue_file, mock_del.call_args_list[1][0][0])",
            "            mock_remove_volumes.assert_called_once_with(['lvm.rescue'])",
            "",
            "    @mock.patch(",
            "        'nova.virt.configdrive.ConfigDriveBuilder.add_instance_metadata')",
            "    @mock.patch('nova.virt.configdrive.ConfigDriveBuilder.make_drive')",
            "    def test_rescue_config_drive(self, mock_make, mock_add):",
            "        instance = self._create_instance()",
            "        uuid = instance.uuid",
            "        configdrive_path = uuid + '/disk.config.rescue'",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices>\"",
            "                    \"<disk type='file'><driver name='qemu' type='raw'/>\"",
            "                    \"<source file='/test/disk'/>\"",
            "                    \"<target dev='vda' bus='virtio'/></disk>\"",
            "                    \"<disk type='file'><driver name='qemu' type='qcow2'/>\"",
            "                    \"<source file='/test/disk.local'/>\"",
            "                    \"<target dev='vdb' bus='virtio'/></disk>\"",
            "                    \"</devices></domain>\")",
            "        network_info = _fake_network_info(self, 1)",
            "",
            "        self.mox.StubOutWithMock(self.drvr,",
            "                                    '_get_existing_domain_xml')",
            "        self.mox.StubOutWithMock(libvirt_utils, 'write_to_file')",
            "        self.mox.StubOutWithMock(imagebackend.Backend, 'image')",
            "        self.mox.StubOutWithMock(imagebackend.Image, 'cache')",
            "        self.mox.StubOutWithMock(instance_metadata.InstanceMetadata,",
            "                                                            '__init__')",
            "        self.mox.StubOutWithMock(self.drvr, '_get_guest_xml')",
            "        self.mox.StubOutWithMock(self.drvr, '_destroy')",
            "        self.mox.StubOutWithMock(self.drvr, '_create_domain')",
            "",
            "        self.drvr._get_existing_domain_xml(mox.IgnoreArg(),",
            "                    mox.IgnoreArg()).MultipleTimes().AndReturn(dummyxml)",
            "        libvirt_utils.write_to_file(mox.IgnoreArg(), mox.IgnoreArg())",
            "        libvirt_utils.write_to_file(mox.IgnoreArg(), mox.IgnoreArg(),",
            "                                    mox.IgnoreArg())",
            "",
            "        imagebackend.Backend.image(instance, 'kernel.rescue', 'raw'",
            "                                    ).AndReturn(fake_imagebackend.Raw())",
            "        imagebackend.Backend.image(instance, 'ramdisk.rescue', 'raw'",
            "                                    ).AndReturn(fake_imagebackend.Raw())",
            "        imagebackend.Backend.image(instance, 'disk.rescue', 'default'",
            "                                    ).AndReturn(fake_imagebackend.Raw())",
            "        imagebackend.Backend.image(instance, 'disk.config.rescue', 'raw'",
            "                                   ).AndReturn(fake_imagebackend.Raw())",
            "",
            "        imagebackend.Image.cache(context=mox.IgnoreArg(),",
            "                                fetch_func=mox.IgnoreArg(),",
            "                                filename=mox.IgnoreArg(),",
            "                                image_id=mox.IgnoreArg(),",
            "                                project_id=mox.IgnoreArg(),",
            "                                user_id=mox.IgnoreArg()).MultipleTimes()",
            "",
            "        imagebackend.Image.cache(context=mox.IgnoreArg(),",
            "                                fetch_func=mox.IgnoreArg(),",
            "                                filename=mox.IgnoreArg(),",
            "                                image_id=mox.IgnoreArg(),",
            "                                project_id=mox.IgnoreArg(),",
            "                                size=None, user_id=mox.IgnoreArg())",
            "",
            "        instance_metadata.InstanceMetadata.__init__(mox.IgnoreArg(),",
            "                                            content=mox.IgnoreArg(),",
            "                                            extra_md=mox.IgnoreArg(),",
            "                                            network_info=mox.IgnoreArg())",
            "        image_meta = objects.ImageMeta.from_dict(",
            "            {'id': 'fake', 'name': 'fake'})",
            "        self.drvr._get_guest_xml(mox.IgnoreArg(), instance,",
            "                                 network_info, mox.IgnoreArg(),",
            "                                 image_meta,",
            "                                 rescue=mox.IgnoreArg(),",
            "                                 write_to_disk=mox.IgnoreArg()",
            "                                ).AndReturn(dummyxml)",
            "        self.drvr._destroy(instance)",
            "        self.drvr._create_domain(mox.IgnoreArg())",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        rescue_password = 'fake_password'",
            "",
            "        self.drvr.rescue(self.context, instance, network_info,",
            "                                                image_meta, rescue_password)",
            "        self.mox.VerifyAll()",
            "",
            "        mock_add.assert_any_call(mock.ANY)",
            "        expected_call = [mock.call(os.path.join(CONF.instances_path,",
            "                                                configdrive_path))]",
            "        mock_make.assert_has_calls(expected_call)",
            "",
            "    @mock.patch('shutil.rmtree')",
            "    @mock.patch('nova.utils.execute')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path')",
            "    def test_delete_instance_files(self, get_instance_path, exists, exe,",
            "                                   shutil):",
            "        get_instance_path.return_value = '/path'",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "",
            "        exists.side_effect = [False, False, True, False]",
            "",
            "        result = self.drvr.delete_instance_files(instance)",
            "        get_instance_path.assert_called_with(instance)",
            "        exe.assert_called_with('mv', '/path', '/path_del')",
            "        shutil.assert_called_with('/path_del')",
            "        self.assertTrue(result)",
            "",
            "    @mock.patch('shutil.rmtree')",
            "    @mock.patch('nova.utils.execute')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('os.kill')",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path')",
            "    def test_delete_instance_files_kill_running(",
            "            self, get_instance_path, kill, exists, exe, shutil):",
            "        get_instance_path.return_value = '/path'",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "        self.drvr.job_tracker.jobs[instance.uuid] = [3, 4]",
            "",
            "        exists.side_effect = [False, False, True, False]",
            "",
            "        result = self.drvr.delete_instance_files(instance)",
            "        get_instance_path.assert_called_with(instance)",
            "        exe.assert_called_with('mv', '/path', '/path_del')",
            "        kill.assert_has_calls([mock.call(3, signal.SIGKILL), mock.call(3, 0),",
            "                               mock.call(4, signal.SIGKILL), mock.call(4, 0)])",
            "        shutil.assert_called_with('/path_del')",
            "        self.assertTrue(result)",
            "        self.assertNotIn(instance.uuid, self.drvr.job_tracker.jobs)",
            "",
            "    @mock.patch('shutil.rmtree')",
            "    @mock.patch('nova.utils.execute')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path')",
            "    def test_delete_instance_files_resize(self, get_instance_path, exists,",
            "                                          exe, shutil):",
            "        get_instance_path.return_value = '/path'",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "",
            "        nova.utils.execute.side_effect = [Exception(), None]",
            "        exists.side_effect = [False, False, True, False]",
            "",
            "        result = self.drvr.delete_instance_files(instance)",
            "        get_instance_path.assert_called_with(instance)",
            "        expected = [mock.call('mv', '/path', '/path_del'),",
            "                    mock.call('mv', '/path_resize', '/path_del')]",
            "        self.assertEqual(expected, exe.mock_calls)",
            "        shutil.assert_called_with('/path_del')",
            "        self.assertTrue(result)",
            "",
            "    @mock.patch('shutil.rmtree')",
            "    @mock.patch('nova.utils.execute')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path')",
            "    def test_delete_instance_files_failed(self, get_instance_path, exists, exe,",
            "                                          shutil):",
            "        get_instance_path.return_value = '/path'",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "",
            "        exists.side_effect = [False, False, True, True]",
            "",
            "        result = self.drvr.delete_instance_files(instance)",
            "        get_instance_path.assert_called_with(instance)",
            "        exe.assert_called_with('mv', '/path', '/path_del')",
            "        shutil.assert_called_with('/path_del')",
            "        self.assertFalse(result)",
            "",
            "    @mock.patch('shutil.rmtree')",
            "    @mock.patch('nova.utils.execute')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path')",
            "    def test_delete_instance_files_mv_failed(self, get_instance_path, exists,",
            "                                             exe, shutil):",
            "        get_instance_path.return_value = '/path'",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "",
            "        nova.utils.execute.side_effect = Exception()",
            "        exists.side_effect = [True, True]",
            "",
            "        result = self.drvr.delete_instance_files(instance)",
            "        get_instance_path.assert_called_with(instance)",
            "        expected = [mock.call('mv', '/path', '/path_del'),",
            "                    mock.call('mv', '/path_resize', '/path_del')] * 2",
            "        self.assertEqual(expected, exe.mock_calls)",
            "        self.assertFalse(result)",
            "",
            "    @mock.patch('shutil.rmtree')",
            "    @mock.patch('nova.utils.execute')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path')",
            "    def test_delete_instance_files_resume(self, get_instance_path, exists,",
            "                                             exe, shutil):",
            "        get_instance_path.return_value = '/path'",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "",
            "        nova.utils.execute.side_effect = Exception()",
            "        exists.side_effect = [False, False, True, False]",
            "",
            "        result = self.drvr.delete_instance_files(instance)",
            "        get_instance_path.assert_called_with(instance)",
            "        expected = [mock.call('mv', '/path', '/path_del'),",
            "                    mock.call('mv', '/path_resize', '/path_del')] * 2",
            "        self.assertEqual(expected, exe.mock_calls)",
            "        self.assertTrue(result)",
            "",
            "    @mock.patch('shutil.rmtree')",
            "    @mock.patch('nova.utils.execute')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path')",
            "    def test_delete_instance_files_none(self, get_instance_path, exists,",
            "                                        exe, shutil):",
            "        get_instance_path.return_value = '/path'",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "",
            "        nova.utils.execute.side_effect = Exception()",
            "        exists.side_effect = [False, False, False, False]",
            "",
            "        result = self.drvr.delete_instance_files(instance)",
            "        get_instance_path.assert_called_with(instance)",
            "        expected = [mock.call('mv', '/path', '/path_del'),",
            "                    mock.call('mv', '/path_resize', '/path_del')] * 2",
            "        self.assertEqual(expected, exe.mock_calls)",
            "        self.assertEqual(0, len(shutil.mock_calls))",
            "        self.assertTrue(result)",
            "",
            "    @mock.patch('shutil.rmtree')",
            "    @mock.patch('nova.utils.execute')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path')",
            "    def test_delete_instance_files_concurrent(self, get_instance_path, exists,",
            "                                              exe, shutil):",
            "        get_instance_path.return_value = '/path'",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "",
            "        nova.utils.execute.side_effect = [Exception(), Exception(), None]",
            "        exists.side_effect = [False, False, True, False]",
            "",
            "        result = self.drvr.delete_instance_files(instance)",
            "        get_instance_path.assert_called_with(instance)",
            "        expected = [mock.call('mv', '/path', '/path_del'),",
            "                    mock.call('mv', '/path_resize', '/path_del')]",
            "        expected.append(expected[0])",
            "        self.assertEqual(expected, exe.mock_calls)",
            "        shutil.assert_called_with('/path_del')",
            "        self.assertTrue(result)",
            "",
            "    def _assert_on_id_map(self, idmap, klass, start, target, count):",
            "        self.assertIsInstance(idmap, klass)",
            "        self.assertEqual(start, idmap.start)",
            "        self.assertEqual(target, idmap.target)",
            "        self.assertEqual(count, idmap.count)",
            "",
            "    def test_get_id_maps(self):",
            "        self.flags(virt_type=\"lxc\", group=\"libvirt\")",
            "        CONF.libvirt.virt_type = \"lxc\"",
            "        CONF.libvirt.uid_maps = [\"0:10000:1\", \"1:20000:10\"]",
            "        CONF.libvirt.gid_maps = [\"0:10000:1\", \"1:20000:10\"]",
            "",
            "        idmaps = self.drvr._get_guest_idmaps()",
            "",
            "        self.assertEqual(len(idmaps), 4)",
            "        self._assert_on_id_map(idmaps[0],",
            "                               vconfig.LibvirtConfigGuestUIDMap,",
            "                               0, 10000, 1)",
            "        self._assert_on_id_map(idmaps[1],",
            "                               vconfig.LibvirtConfigGuestUIDMap,",
            "                               1, 20000, 10)",
            "        self._assert_on_id_map(idmaps[2],",
            "                               vconfig.LibvirtConfigGuestGIDMap,",
            "                               0, 10000, 1)",
            "        self._assert_on_id_map(idmaps[3],",
            "                               vconfig.LibvirtConfigGuestGIDMap,",
            "                               1, 20000, 10)",
            "",
            "    def test_get_id_maps_not_lxc(self):",
            "        CONF.libvirt.uid_maps = [\"0:10000:1\", \"1:20000:10\"]",
            "        CONF.libvirt.gid_maps = [\"0:10000:1\", \"1:20000:10\"]",
            "",
            "        idmaps = self.drvr._get_guest_idmaps()",
            "",
            "        self.assertEqual(0, len(idmaps))",
            "",
            "    def test_get_id_maps_only_uid(self):",
            "        self.flags(virt_type=\"lxc\", group=\"libvirt\")",
            "        CONF.libvirt.uid_maps = [\"0:10000:1\", \"1:20000:10\"]",
            "        CONF.libvirt.gid_maps = []",
            "",
            "        idmaps = self.drvr._get_guest_idmaps()",
            "",
            "        self.assertEqual(2, len(idmaps))",
            "        self._assert_on_id_map(idmaps[0],",
            "                               vconfig.LibvirtConfigGuestUIDMap,",
            "                               0, 10000, 1)",
            "        self._assert_on_id_map(idmaps[1],",
            "                               vconfig.LibvirtConfigGuestUIDMap,",
            "                               1, 20000, 10)",
            "",
            "    def test_get_id_maps_only_gid(self):",
            "        self.flags(virt_type=\"lxc\", group=\"libvirt\")",
            "        CONF.libvirt.uid_maps = []",
            "        CONF.libvirt.gid_maps = [\"0:10000:1\", \"1:20000:10\"]",
            "",
            "        idmaps = self.drvr._get_guest_idmaps()",
            "",
            "        self.assertEqual(2, len(idmaps))",
            "        self._assert_on_id_map(idmaps[0],",
            "                               vconfig.LibvirtConfigGuestGIDMap,",
            "                               0, 10000, 1)",
            "        self._assert_on_id_map(idmaps[1],",
            "                               vconfig.LibvirtConfigGuestGIDMap,",
            "                               1, 20000, 10)",
            "",
            "    def test_instance_on_disk(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "        self.assertFalse(drvr.instance_on_disk(instance))",
            "",
            "    def test_instance_on_disk_rbd(self):",
            "        self.flags(images_type='rbd', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "        self.assertTrue(drvr.instance_on_disk(instance))",
            "",
            "    def test_get_interfaces(self):",
            "        dom_xml = \"\"\"",
            "              <domain type=\"qemu\">",
            "                  <devices>",
            "                      <interface type=\"ethernet\">",
            "                          <mac address=\"fe:eb:da:ed:ef:ac\"/>",
            "                          <model type=\"virtio\"/>",
            "                          <target dev=\"eth0\"/>",
            "                      </interface>",
            "                      <interface type=\"bridge\">",
            "                          <mac address=\"ca:fe:de:ad:be:ef\"/>",
            "                          <model type=\"virtio\"/>",
            "                          <target dev=\"br0\"/>",
            "                      </interface>",
            "                  </devices>",
            "              </domain>\"\"\"",
            "",
            "        list_interfaces = ['eth0', 'br0']",
            "",
            "        drv = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        self.assertEqual(list_interfaces, drv._get_interfaces(dom_xml))",
            "",
            "    def test_get_disk_xml(self):",
            "        dom_xml = \"\"\"",
            "              <domain type=\"kvm\">",
            "                <devices>",
            "                  <disk type=\"file\">",
            "                     <source file=\"disk1_file\"/>",
            "                     <target dev=\"vda\" bus=\"virtio\"/>",
            "                     <serial>0e38683e-f0af-418f-a3f1-6b67ea0f919d</serial>",
            "                  </disk>",
            "                  <disk type=\"block\">",
            "                    <source dev=\"/path/to/dev/1\"/>",
            "                    <target dev=\"vdb\" bus=\"virtio\" serial=\"1234\"/>",
            "                  </disk>",
            "                </devices>",
            "              </domain>",
            "              \"\"\"",
            "",
            "        diska_xml = \"\"\"<disk type=\"file\" device=\"disk\">",
            "  <source file=\"disk1_file\"/>",
            "  <target bus=\"virtio\" dev=\"vda\"/>",
            "  <serial>0e38683e-f0af-418f-a3f1-6b67ea0f919d</serial>",
            "</disk>\"\"\"",
            "",
            "        diskb_xml = \"\"\"<disk type=\"block\" device=\"disk\">",
            "  <source dev=\"/path/to/dev/1\"/>",
            "  <target bus=\"virtio\" dev=\"vdb\"/>",
            "</disk>\"\"\"",
            "",
            "        dom = mock.MagicMock()",
            "        dom.XMLDesc.return_value = dom_xml",
            "        guest = libvirt_guest.Guest(dom)",
            "",
            "        # NOTE(gcb): etree.tostring(node) returns an extra line with",
            "        # some white spaces, need to strip it.",
            "        actual_diska_xml = guest.get_disk('vda').to_xml()",
            "        self.assertEqual(diska_xml.strip(), actual_diska_xml.strip())",
            "",
            "        actual_diskb_xml = guest.get_disk('vdb').to_xml()",
            "        self.assertEqual(diskb_xml.strip(), actual_diskb_xml.strip())",
            "",
            "        self.assertIsNone(guest.get_disk('vdc'))",
            "",
            "    def test_vcpu_model_from_config(self):",
            "        drv = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        vcpu_model = drv._cpu_config_to_vcpu_model(None, None)",
            "        self.assertIsNone(vcpu_model)",
            "",
            "        cpu = vconfig.LibvirtConfigGuestCPU()",
            "        feature1 = vconfig.LibvirtConfigGuestCPUFeature()",
            "        feature2 = vconfig.LibvirtConfigGuestCPUFeature()",
            "        feature1.name = 'sse'",
            "        feature1.policy = cpumodel.POLICY_REQUIRE",
            "        feature2.name = 'aes'",
            "        feature2.policy = cpumodel.POLICY_REQUIRE",
            "",
            "        cpu.features = set([feature1, feature2])",
            "        cpu.mode = cpumodel.MODE_CUSTOM",
            "        cpu.sockets = 1",
            "        cpu.cores = 2",
            "        cpu.threads = 4",
            "        vcpu_model = drv._cpu_config_to_vcpu_model(cpu, None)",
            "        self.assertEqual(cpumodel.MATCH_EXACT, vcpu_model.match)",
            "        self.assertEqual(cpumodel.MODE_CUSTOM, vcpu_model.mode)",
            "        self.assertEqual(4, vcpu_model.topology.threads)",
            "        self.assertEqual(set(['sse', 'aes']),",
            "                         set([f.name for f in vcpu_model.features]))",
            "",
            "        cpu.mode = cpumodel.MODE_HOST_MODEL",
            "        vcpu_model_1 = drv._cpu_config_to_vcpu_model(cpu, vcpu_model)",
            "        self.assertEqual(cpumodel.MODE_HOST_MODEL, vcpu_model.mode)",
            "        self.assertEqual(vcpu_model, vcpu_model_1)",
            "",
            "    @mock.patch.object(lvm, 'get_volume_size', return_value=10)",
            "    @mock.patch.object(host.Host, \"get_guest\")",
            "    @mock.patch.object(dmcrypt, 'delete_volume')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.unfilter_instance')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._undefine_domain')",
            "    @mock.patch.object(objects.Instance, 'save')",
            "    def test_cleanup_lvm_encrypted(self, mock_save, mock_undefine_domain,",
            "                                   mock_unfilter, mock_delete_volume,",
            "                                   mock_get_guest, mock_get_size):",
            "        drv = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance = objects.Instance(uuid='fake-uuid', id=1,",
            "                                    ephemeral_key_uuid='000-000-000')",
            "        instance.system_metadata = {}",
            "        block_device_info = {'root_device_name': '/dev/vda',",
            "                             'ephemerals': [],",
            "                             'block_device_mapping': []}",
            "        self.flags(images_type=\"lvm\",",
            "                   group='libvirt')",
            "        dom_xml = \"\"\"",
            "              <domain type=\"kvm\">",
            "                <devices>",
            "                  <disk type=\"block\">",
            "                    <driver name='qemu' type='raw' cache='none'/>",
            "                    <source dev=\"/dev/mapper/fake-dmcrypt\"/>",
            "                    <target dev=\"vda\" bus=\"virtio\" serial=\"1234\"/>",
            "                  </disk>",
            "                </devices>",
            "              </domain>",
            "              \"\"\"",
            "        dom = mock.MagicMock()",
            "        dom.XMLDesc.return_value = dom_xml",
            "        guest = libvirt_guest.Guest(dom)",
            "        mock_get_guest.return_value = guest",
            "        drv.cleanup(self.context, instance, 'fake_network', destroy_vifs=False,",
            "                        block_device_info=block_device_info)",
            "        mock_delete_volume.assert_called_once_with('/dev/mapper/fake-dmcrypt')",
            "",
            "    @mock.patch.object(lvm, 'get_volume_size', return_value=10)",
            "    @mock.patch.object(host.Host, \"get_guest\")",
            "    @mock.patch.object(dmcrypt, 'delete_volume')",
            "    def _test_cleanup_lvm(self, mock_delete_volume, mock_get_guest, mock_size,",
            "                          encrypted=False):",
            "",
            "        drv = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance = objects.Instance(uuid='fake-uuid', id=1,",
            "                                    ephemeral_key_uuid='000-000-000')",
            "        block_device_info = {'root_device_name': '/dev/vda',",
            "                             'ephemerals': [],",
            "                             'block_device_mapping': []}",
            "        dev_name = 'fake-dmcrypt' if encrypted else 'fake'",
            "        dom_xml = \"\"\"",
            "              <domain type=\"kvm\">",
            "                <devices>",
            "                  <disk type=\"block\">",
            "                    <driver name='qemu' type='raw' cache='none'/>",
            "                    <source dev=\"/dev/mapper/%s\"/>",
            "                    <target dev=\"vda\" bus=\"virtio\" serial=\"1234\"/>",
            "                  </disk>",
            "                </devices>",
            "              </domain>",
            "              \"\"\" % dev_name",
            "        dom = mock.MagicMock()",
            "        dom.XMLDesc.return_value = dom_xml",
            "        guest = libvirt_guest.Guest(dom)",
            "        mock_get_guest.return_value = guest",
            "        drv._cleanup_lvm(instance, block_device_info)",
            "",
            "        if encrypted:",
            "            mock_delete_volume.assert_called_once_with(",
            "                '/dev/mapper/fake-dmcrypt')",
            "        else:",
            "            self.assertFalse(mock_delete_volume.called)",
            "",
            "    def test_cleanup_lvm(self):",
            "        self._test_cleanup_lvm()",
            "",
            "    def test_cleanup_encrypted_lvm(self):",
            "        self._test_cleanup_lvm(encrypted=True)",
            "",
            "    def test_vcpu_model_to_config(self):",
            "        drv = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        feature = objects.VirtCPUFeature(policy=cpumodel.POLICY_REQUIRE,",
            "                                         name='sse')",
            "        feature_1 = objects.VirtCPUFeature(policy=cpumodel.POLICY_FORBID,",
            "                                           name='aes')",
            "        topo = objects.VirtCPUTopology(sockets=1, cores=2, threads=4)",
            "        vcpu_model = objects.VirtCPUModel(mode=cpumodel.MODE_HOST_MODEL,",
            "                                          features=[feature, feature_1],",
            "                                          topology=topo)",
            "",
            "        cpu = drv._vcpu_model_to_cpu_config(vcpu_model)",
            "        self.assertEqual(cpumodel.MODE_HOST_MODEL, cpu.mode)",
            "        self.assertEqual(1, cpu.sockets)",
            "        self.assertEqual(4, cpu.threads)",
            "        self.assertEqual(2, len(cpu.features))",
            "        self.assertEqual(set(['sse', 'aes']),",
            "                         set([f.name for f in cpu.features]))",
            "        self.assertEqual(set([cpumodel.POLICY_REQUIRE,",
            "                              cpumodel.POLICY_FORBID]),",
            "                         set([f.policy for f in cpu.features]))",
            "",
            "    def test_trigger_crash_dump(self):",
            "        mock_guest = mock.Mock(libvirt_guest.Guest, id=1)",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "",
            "        with mock.patch.object(self.drvr._host, 'get_guest',",
            "                               return_value=mock_guest):",
            "            self.drvr.trigger_crash_dump(instance)",
            "",
            "    def test_trigger_crash_dump_not_running(self):",
            "        ex = fakelibvirt.make_libvirtError(",
            "                fakelibvirt.libvirtError,",
            "                'Requested operation is not valid: domain is not running',",
            "                error_code=fakelibvirt.VIR_ERR_OPERATION_INVALID)",
            "",
            "        mock_guest = mock.Mock(libvirt_guest.Guest, id=1)",
            "        mock_guest.inject_nmi = mock.Mock(side_effect=ex)",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "",
            "        with mock.patch.object(self.drvr._host, 'get_guest',",
            "                               return_value=mock_guest):",
            "            self.assertRaises(exception.InstanceNotRunning,",
            "                              self.drvr.trigger_crash_dump, instance)",
            "",
            "    def test_trigger_crash_dump_not_supported(self):",
            "        ex = fakelibvirt.make_libvirtError(",
            "                fakelibvirt.libvirtError,",
            "                '',",
            "                error_code=fakelibvirt.VIR_ERR_NO_SUPPORT)",
            "",
            "        mock_guest = mock.Mock(libvirt_guest.Guest, id=1)",
            "        mock_guest.inject_nmi = mock.Mock(side_effect=ex)",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "",
            "        with mock.patch.object(self.drvr._host, 'get_guest',",
            "                               return_value=mock_guest):",
            "            self.assertRaises(exception.TriggerCrashDumpNotSupported,",
            "                              self.drvr.trigger_crash_dump, instance)",
            "",
            "    def test_trigger_crash_dump_unexpected_error(self):",
            "        ex = fakelibvirt.make_libvirtError(",
            "                fakelibvirt.libvirtError,",
            "                'UnexpectedError',",
            "                error_code=fakelibvirt.VIR_ERR_SYSTEM_ERROR)",
            "",
            "        mock_guest = mock.Mock(libvirt_guest.Guest, id=1)",
            "        mock_guest.inject_nmi = mock.Mock(side_effect=ex)",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "",
            "        with mock.patch.object(self.drvr._host, 'get_guest',",
            "                               return_value=mock_guest):",
            "            self.assertRaises(fakelibvirt.libvirtError,",
            "                              self.drvr.trigger_crash_dump, instance)",
            "",
            "",
            "class LibvirtVolumeUsageTestCase(test.NoDBTestCase):",
            "    \"\"\"Test for LibvirtDriver.get_all_volume_usage.\"\"\"",
            "",
            "    def setUp(self):",
            "        super(LibvirtVolumeUsageTestCase, self).setUp()",
            "        self.drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.c = context.get_admin_context()",
            "",
            "        self.ins_ref = objects.Instance(",
            "            id=1729,",
            "            uuid='875a8070-d0b9-4949-8b31-104d125c9a64'",
            "        )",
            "",
            "        # verify bootable volume device path also",
            "        self.bdms = [{'volume_id': 1,",
            "                      'device_name': '/dev/vde'},",
            "                     {'volume_id': 2,",
            "                      'device_name': 'vda'}]",
            "",
            "    def test_get_all_volume_usage(self):",
            "        def fake_block_stats(instance_name, disk):",
            "            return (169, 688640, 0, 0, -1)",
            "",
            "        self.stubs.Set(self.drvr, 'block_stats', fake_block_stats)",
            "        vol_usage = self.drvr.get_all_volume_usage(self.c,",
            "              [dict(instance=self.ins_ref, instance_bdms=self.bdms)])",
            "",
            "        expected_usage = [{'volume': 1,",
            "                           'instance': self.ins_ref,",
            "                           'rd_bytes': 688640, 'wr_req': 0,",
            "                           'rd_req': 169, 'wr_bytes': 0},",
            "                           {'volume': 2,",
            "                            'instance': self.ins_ref,",
            "                            'rd_bytes': 688640, 'wr_req': 0,",
            "                            'rd_req': 169, 'wr_bytes': 0}]",
            "        self.assertEqual(vol_usage, expected_usage)",
            "",
            "    def test_get_all_volume_usage_device_not_found(self):",
            "        def fake_get_domain(self, instance):",
            "            raise exception.InstanceNotFound(instance_id=\"fakedom\")",
            "",
            "        self.stubs.Set(host.Host, 'get_domain', fake_get_domain)",
            "        vol_usage = self.drvr.get_all_volume_usage(self.c,",
            "              [dict(instance=self.ins_ref, instance_bdms=self.bdms)])",
            "        self.assertEqual(vol_usage, [])",
            "",
            "",
            "class LibvirtNonblockingTestCase(test.NoDBTestCase):",
            "    \"\"\"Test libvirtd calls are nonblocking.\"\"\"",
            "",
            "    def setUp(self):",
            "        super(LibvirtNonblockingTestCase, self).setUp()",
            "        self.flags(connection_uri=\"test:///default\",",
            "                   group='libvirt')",
            "",
            "    def test_connection_to_primitive(self):",
            "        # Test bug 962840.",
            "        import nova.virt.libvirt.driver as libvirt_driver",
            "        drvr = libvirt_driver.LibvirtDriver('')",
            "        drvr.set_host_enabled = mock.Mock()",
            "        jsonutils.to_primitive(drvr._conn, convert_instances=True)",
            "",
            "    def test_tpool_execute_calls_libvirt(self):",
            "        conn = fakelibvirt.virConnect()",
            "        conn.is_expected = True",
            "",
            "        self.mox.StubOutWithMock(eventlet.tpool, 'execute')",
            "        eventlet.tpool.execute(",
            "            fakelibvirt.openAuth,",
            "            'test:///default',",
            "            mox.IgnoreArg(),",
            "            mox.IgnoreArg()).AndReturn(conn)",
            "        eventlet.tpool.execute(",
            "            conn.domainEventRegisterAny,",
            "            None,",
            "            fakelibvirt.VIR_DOMAIN_EVENT_ID_LIFECYCLE,",
            "            mox.IgnoreArg(),",
            "            mox.IgnoreArg())",
            "        if hasattr(fakelibvirt.virConnect, 'registerCloseCallback'):",
            "            eventlet.tpool.execute(",
            "                conn.registerCloseCallback,",
            "                mox.IgnoreArg(),",
            "                mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "",
            "        driver = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        c = driver._get_connection()",
            "        self.assertTrue(c.is_expected)",
            "",
            "",
            "class LibvirtVolumeSnapshotTestCase(test.NoDBTestCase):",
            "    \"\"\"Tests for libvirtDriver.volume_snapshot_create/delete.\"\"\"",
            "",
            "    def setUp(self):",
            "        super(LibvirtVolumeSnapshotTestCase, self).setUp()",
            "",
            "        self.drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.c = context.get_admin_context()",
            "",
            "        self.flags(instance_name_template='instance-%s')",
            "        self.flags(qemu_allowed_storage_drivers=[], group='libvirt')",
            "",
            "        # creating instance",
            "        self.inst = {}",
            "        self.inst['uuid'] = uuidutils.generate_uuid()",
            "        self.inst['id'] = '1'",
            "",
            "        # create domain info",
            "        self.dom_xml = \"\"\"",
            "              <domain type='kvm'>",
            "                <devices>",
            "                  <disk type='file'>",
            "                     <source file='disk1_file'/>",
            "                     <target dev='vda' bus='virtio'/>",
            "                     <serial>0e38683e-f0af-418f-a3f1-6b67ea0f919d</serial>",
            "                  </disk>",
            "                  <disk type='block'>",
            "                    <source dev='/path/to/dev/1'/>",
            "                    <target dev='vdb' bus='virtio' serial='1234'/>",
            "                  </disk>",
            "                </devices>",
            "              </domain>\"\"\"",
            "",
            "        # alternate domain info with network-backed snapshot chain",
            "        self.dom_netdisk_xml = \"\"\"",
            "              <domain type='kvm'>",
            "                <devices>",
            "                  <disk type='file'>",
            "                    <source file='disk1_file'/>",
            "                    <target dev='vda' bus='virtio'/>",
            "                    <serial>0e38683e-f0af-418f-a3f1-6b67eaffffff</serial>",
            "                  </disk>",
            "                  <disk type='network' device='disk'>",
            "                    <driver name='qemu' type='qcow2'/>",
            "                    <source protocol='gluster' name='vol1/root.img'>",
            "                      <host name='server1' port='24007'/>",
            "                    </source>",
            "                    <backingStore type='network' index='1'>",
            "                      <driver name='qemu' type='qcow2'/>",
            "                      <source protocol='gluster' name='vol1/snap.img'>",
            "                        <host name='server1' port='24007'/>",
            "                      </source>",
            "                      <backingStore type='network' index='2'>",
            "                        <driver name='qemu' type='qcow2'/>",
            "                        <source protocol='gluster' name='vol1/snap-b.img'>",
            "                          <host name='server1' port='24007'/>",
            "                        </source>",
            "                        <backingStore/>",
            "                      </backingStore>",
            "                    </backingStore>",
            "                    <target dev='vdb' bus='virtio'/>",
            "                    <serial>0e38683e-f0af-418f-a3f1-6b67ea0f919d</serial>",
            "                  </disk>",
            "                </devices>",
            "              </domain>",
            "        \"\"\"",
            "",
            "        # XML with netdisk attached, and 1 snapshot taken",
            "        self.dom_netdisk_xml_2 = \"\"\"",
            "              <domain type='kvm'>",
            "                <devices>",
            "                  <disk type='file'>",
            "                    <source file='disk1_file'/>",
            "                    <target dev='vda' bus='virtio'/>",
            "                    <serial>0e38683e-f0af-418f-a3f1-6b67eaffffff</serial>",
            "                  </disk>",
            "                  <disk type='network' device='disk'>",
            "                    <driver name='qemu' type='qcow2'/>",
            "                    <source protocol='gluster' name='vol1/snap.img'>",
            "                      <host name='server1' port='24007'/>",
            "                    </source>",
            "                    <backingStore type='network' index='1'>",
            "                      <driver name='qemu' type='qcow2'/>",
            "                      <source protocol='gluster' name='vol1/root.img'>",
            "                        <host name='server1' port='24007'/>",
            "                      </source>",
            "                      <backingStore/>",
            "                    </backingStore>",
            "                    <target dev='vdb' bus='virtio'/>",
            "                    <serial>0e38683e-f0af-418f-a3f1-6b67ea0f919d</serial>",
            "                  </disk>",
            "                </devices>",
            "              </domain>",
            "        \"\"\"",
            "",
            "        self.create_info = {'type': 'qcow2',",
            "                            'snapshot_id': '1234-5678',",
            "                            'new_file': 'new-file'}",
            "",
            "        self.volume_uuid = '0e38683e-f0af-418f-a3f1-6b67ea0f919d'",
            "        self.snapshot_id = '9c3ca9f4-9f4e-4dba-bedd-5c5e4b52b162'",
            "",
            "        self.delete_info_1 = {'type': 'qcow2',",
            "                              'file_to_merge': 'snap.img',",
            "                              'merge_target_file': None}",
            "",
            "        self.delete_info_2 = {'type': 'qcow2',",
            "                              'file_to_merge': 'snap.img',",
            "                              'merge_target_file': 'other-snap.img'}",
            "",
            "        self.delete_info_3 = {'type': 'qcow2',",
            "                              'file_to_merge': None,",
            "                              'merge_target_file': None}",
            "",
            "        self.delete_info_netdisk = {'type': 'qcow2',",
            "                                    'file_to_merge': 'snap.img',",
            "                                    'merge_target_file': 'root.img'}",
            "",
            "        self.delete_info_invalid_type = {'type': 'made_up_type',",
            "                                         'file_to_merge': 'some_file',",
            "                                         'merge_target_file':",
            "                                             'some_other_file'}",
            "",
            "    def tearDown(self):",
            "        super(LibvirtVolumeSnapshotTestCase, self).tearDown()",
            "",
            "    @mock.patch('nova.virt.block_device.DriverVolumeBlockDevice.'",
            "                'refresh_connection_info')",
            "    @mock.patch('nova.objects.block_device.BlockDeviceMapping.'",
            "                'get_by_volume_and_instance')",
            "    def test_volume_refresh_connection_info(self,",
            "                                            mock_get_by_volume_and_instance,",
            "                                            mock_refresh_connection_info):",
            "        instance = objects.Instance(**self.inst)",
            "        fake_bdm = fake_block_device.FakeDbBlockDeviceDict({",
            "            'id': 123,",
            "            'instance_uuid': 'fake-instance',",
            "            'device_name': '/dev/sdb',",
            "            'source_type': 'volume',",
            "            'destination_type': 'volume',",
            "            'volume_id': 'fake-volume-id-1',",
            "            'connection_info': '{\"fake\": \"connection_info\"}'})",
            "        fake_bdm = objects.BlockDeviceMapping(self.c, **fake_bdm)",
            "        mock_get_by_volume_and_instance.return_value = fake_bdm",
            "",
            "        self.drvr._volume_refresh_connection_info(self.c, instance,",
            "                                                  self.volume_uuid)",
            "",
            "        mock_get_by_volume_and_instance.assert_called_once_with(",
            "            self.c, self.volume_uuid, instance.uuid)",
            "        mock_refresh_connection_info.assert_called_once_with(self.c, instance,",
            "            self.drvr._volume_api, self.drvr)",
            "",
            "    def test_volume_snapshot_create(self, quiesce=True):",
            "        \"\"\"Test snapshot creation with file-based disk.\"\"\"",
            "        self.flags(instance_name_template='instance-%s')",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_api')",
            "",
            "        instance = objects.Instance(**self.inst)",
            "",
            "        new_file = 'new-file'",
            "",
            "        domain = FakeVirtDomain(fake_xml=self.dom_xml)",
            "        self.mox.StubOutWithMock(domain, 'XMLDesc')",
            "        self.mox.StubOutWithMock(domain, 'snapshotCreateXML')",
            "        domain.XMLDesc(flags=0).AndReturn(self.dom_xml)",
            "",
            "        snap_xml_src = (",
            "           '<domainsnapshot>\\n'",
            "           '  <disks>\\n'",
            "           '    <disk name=\"disk1_file\" snapshot=\"external\" type=\"file\">\\n'",
            "           '      <source file=\"new-file\"/>\\n'",
            "           '    </disk>\\n'",
            "           '    <disk name=\"vdb\" snapshot=\"no\"/>\\n'",
            "           '  </disks>\\n'",
            "           '</domainsnapshot>\\n')",
            "",
            "        # Older versions of libvirt may be missing these.",
            "        fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT = 32",
            "        fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE = 64",
            "",
            "        snap_flags = (fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY |",
            "                      fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA |",
            "                      fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT)",
            "",
            "        snap_flags_q = (snap_flags |",
            "                        fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE)",
            "",
            "        if quiesce:",
            "            domain.snapshotCreateXML(snap_xml_src, flags=snap_flags_q)",
            "        else:",
            "            domain.snapshotCreateXML(snap_xml_src, flags=snap_flags_q).\\",
            "                AndRaise(fakelibvirt.libvirtError(",
            "                            'quiescing failed, no qemu-ga'))",
            "            domain.snapshotCreateXML(snap_xml_src, flags=snap_flags)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        guest = libvirt_guest.Guest(domain)",
            "        self.drvr._volume_snapshot_create(self.c, instance, guest,",
            "                                          self.volume_uuid, new_file)",
            "",
            "        self.mox.VerifyAll()",
            "",
            "    def test_volume_snapshot_create_libgfapi(self, quiesce=True):",
            "        \"\"\"Test snapshot creation with libgfapi network disk.\"\"\"",
            "        self.flags(instance_name_template = 'instance-%s')",
            "        self.flags(qemu_allowed_storage_drivers = ['gluster'], group='libvirt')",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_api')",
            "",
            "        self.dom_xml = \"\"\"",
            "              <domain type='kvm'>",
            "                <devices>",
            "                  <disk type='file'>",
            "                    <source file='disk1_file'/>",
            "                    <target dev='vda' bus='virtio'/>",
            "                    <serial>0e38683e-f0af-418f-a3f1-6b67ea0f919d</serial>",
            "                  </disk>",
            "                  <disk type='block'>",
            "                    <source protocol='gluster' name='gluster1/volume-1234'>",
            "                      <host name='127.3.4.5' port='24007'/>",
            "                    </source>",
            "                    <target dev='vdb' bus='virtio' serial='1234'/>",
            "                  </disk>",
            "                </devices>",
            "              </domain>\"\"\"",
            "",
            "        instance = objects.Instance(**self.inst)",
            "",
            "        new_file = 'new-file'",
            "",
            "        domain = FakeVirtDomain(fake_xml=self.dom_xml)",
            "        self.mox.StubOutWithMock(domain, 'XMLDesc')",
            "        self.mox.StubOutWithMock(domain, 'snapshotCreateXML')",
            "        domain.XMLDesc(flags=0).AndReturn(self.dom_xml)",
            "",
            "        snap_xml_src = (",
            "           '<domainsnapshot>\\n'",
            "           '  <disks>\\n'",
            "           '    <disk name=\"disk1_file\" snapshot=\"external\" type=\"file\">\\n'",
            "           '      <source file=\"new-file\"/>\\n'",
            "           '    </disk>\\n'",
            "           '    <disk name=\"vdb\" snapshot=\"no\"/>\\n'",
            "           '  </disks>\\n'",
            "           '</domainsnapshot>\\n')",
            "",
            "        # Older versions of libvirt may be missing these.",
            "        fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT = 32",
            "        fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE = 64",
            "",
            "        snap_flags = (fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY |",
            "                      fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA |",
            "                      fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT)",
            "",
            "        snap_flags_q = (snap_flags |",
            "                        fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE)",
            "",
            "        if quiesce:",
            "            domain.snapshotCreateXML(snap_xml_src, flags=snap_flags_q)",
            "        else:",
            "            domain.snapshotCreateXML(snap_xml_src, flags=snap_flags_q).\\",
            "                AndRaise(fakelibvirt.libvirtError(",
            "                    'quiescing failed, no qemu-ga'))",
            "            domain.snapshotCreateXML(snap_xml_src, flags=snap_flags)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        guest = libvirt_guest.Guest(domain)",
            "        self.drvr._volume_snapshot_create(self.c, instance, guest,",
            "                                          self.volume_uuid, new_file)",
            "",
            "        self.mox.VerifyAll()",
            "",
            "    def test_volume_snapshot_create_noquiesce(self):",
            "        self.test_volume_snapshot_create(quiesce=False)",
            "",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    def test_can_quiesce(self, ver):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        instance = objects.Instance(**self.inst)",
            "        image_meta = objects.ImageMeta.from_dict(",
            "            {\"properties\": {",
            "                \"hw_qemu_guest_agent\": \"yes\"}})",
            "        self.assertIsNone(self.drvr._can_quiesce(instance, image_meta))",
            "",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    def test_can_quiesce_bad_hyp(self, ver):",
            "        self.flags(virt_type='xxx', group='libvirt')",
            "        instance = objects.Instance(**self.inst)",
            "        image_meta = objects.ImageMeta.from_dict(",
            "            {\"properties\": {",
            "                \"hw_qemu_guest_agent\": \"yes\"}})",
            "        self.assertRaises(exception.InstanceQuiesceNotSupported,",
            "                          self.drvr._can_quiesce, instance, image_meta)",
            "",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=False)",
            "    def test_can_quiesce_bad_ver(self, ver):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        instance = objects.Instance(**self.inst)",
            "        image_meta = {\"properties\": {",
            "            \"hw_qemu_guest_agent\": \"yes\"}}",
            "        self.assertRaises(exception.InstanceQuiesceNotSupported,",
            "                          self.drvr._can_quiesce, instance, image_meta)",
            "",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    def test_can_quiesce_agent_not_enable(self, ver):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        instance = objects.Instance(**self.inst)",
            "        image_meta = objects.ImageMeta.from_dict({})",
            "        self.assertRaises(exception.QemuGuestAgentNotEnabled,",
            "                          self.drvr._can_quiesce, instance, image_meta)",
            "",
            "    def test_volume_snapshot_create_outer_success(self):",
            "        instance = objects.Instance(**self.inst)",
            "",
            "        domain = FakeVirtDomain(fake_xml=self.dom_xml, id=1)",
            "        guest = libvirt_guest.Guest(domain)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_guest')",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_api')",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_snapshot_create')",
            "",
            "        self.drvr._host.get_guest(instance).AndReturn(guest)",
            "",
            "        self.drvr._volume_snapshot_create(self.c,",
            "                                          instance,",
            "                                          guest,",
            "                                          self.volume_uuid,",
            "                                          self.create_info['new_file'])",
            "",
            "        self.drvr._volume_api.update_snapshot_status(",
            "            self.c, self.create_info['snapshot_id'], 'creating')",
            "",
            "        self.mox.StubOutWithMock(self.drvr._volume_api, 'get_snapshot')",
            "        self.drvr._volume_api.get_snapshot(self.c,",
            "            self.create_info['snapshot_id']).AndReturn({'status': 'available'})",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_refresh_connection_info')",
            "        self.drvr._volume_refresh_connection_info(self.c, instance,",
            "                                                  self.volume_uuid)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.drvr.volume_snapshot_create(self.c, instance, self.volume_uuid,",
            "                                         self.create_info)",
            "",
            "    def test_volume_snapshot_create_outer_failure(self):",
            "        instance = objects.Instance(**self.inst)",
            "",
            "        domain = FakeVirtDomain(fake_xml=self.dom_xml, id=1)",
            "        guest = libvirt_guest.Guest(domain)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_guest')",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_api')",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_snapshot_create')",
            "",
            "        self.drvr._host.get_guest(instance).AndReturn(guest)",
            "",
            "        self.drvr._volume_snapshot_create(self.c,",
            "                                          instance,",
            "                                          guest,",
            "                                          self.volume_uuid,",
            "                                          self.create_info['new_file']).\\",
            "            AndRaise(exception.NovaException('oops'))",
            "",
            "        self.drvr._volume_api.update_snapshot_status(",
            "            self.c, self.create_info['snapshot_id'], 'error')",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(exception.NovaException,",
            "                          self.drvr.volume_snapshot_create,",
            "                          self.c,",
            "                          instance,",
            "                          self.volume_uuid,",
            "                          self.create_info)",
            "",
            "    def test_volume_snapshot_delete_1(self):",
            "        \"\"\"Deleting newest snapshot -- blockRebase.\"\"\"",
            "",
            "        # libvirt lib doesn't have VIR_DOMAIN_BLOCK_REBASE_RELATIVE flag",
            "        fakelibvirt.__dict__.pop('VIR_DOMAIN_BLOCK_REBASE_RELATIVE')",
            "        self.stubs.Set(libvirt_driver, 'libvirt', fakelibvirt)",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "",
            "        domain = FakeVirtDomain(fake_xml=self.dom_xml)",
            "        self.mox.StubOutWithMock(domain, 'XMLDesc')",
            "        domain.XMLDesc(flags=0).AndReturn(self.dom_xml)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr._host, 'has_min_version')",
            "        self.mox.StubOutWithMock(domain, 'blockRebase')",
            "        self.mox.StubOutWithMock(domain, 'blockCommit')",
            "        self.mox.StubOutWithMock(domain, 'blockJobInfo')",
            "",
            "        self.drvr._host.get_domain(instance).AndReturn(domain)",
            "        self.drvr._host.has_min_version(mox.IgnoreArg()).AndReturn(True)",
            "",
            "        domain.blockRebase('vda', 'snap.img', 0, flags=0)",
            "",
            "        domain.blockJobInfo('vda', flags=0).AndReturn({'cur': 1, 'end': 1000})",
            "        domain.blockJobInfo('vda', flags=0).AndReturn(",
            "            {'cur': 1000, 'end': 1000})",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.drvr._volume_snapshot_delete(self.c, instance, self.volume_uuid,",
            "                                          snapshot_id, self.delete_info_1)",
            "",
            "        self.mox.VerifyAll()",
            "        fakelibvirt.__dict__.update({'VIR_DOMAIN_BLOCK_REBASE_RELATIVE': 8})",
            "",
            "    def test_volume_snapshot_delete_relative_1(self):",
            "        \"\"\"Deleting newest snapshot -- blockRebase using relative flag\"\"\"",
            "",
            "        self.stubs.Set(libvirt_driver, 'libvirt', fakelibvirt)",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "",
            "        domain = FakeVirtDomain(fake_xml=self.dom_xml)",
            "        guest = libvirt_guest.Guest(domain)",
            "        self.mox.StubOutWithMock(domain, 'XMLDesc')",
            "        domain.XMLDesc(flags=0).AndReturn(self.dom_xml)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_guest')",
            "        self.mox.StubOutWithMock(self.drvr._host, 'has_min_version')",
            "        self.mox.StubOutWithMock(domain, 'blockRebase')",
            "        self.mox.StubOutWithMock(domain, 'blockCommit')",
            "        self.mox.StubOutWithMock(domain, 'blockJobInfo')",
            "",
            "        self.drvr._host.get_guest(instance).AndReturn(guest)",
            "        self.drvr._host.has_min_version(mox.IgnoreArg()).AndReturn(True)",
            "",
            "        domain.blockRebase('vda', 'snap.img', 0,",
            "                           flags=fakelibvirt.VIR_DOMAIN_BLOCK_REBASE_RELATIVE)",
            "",
            "        domain.blockJobInfo('vda', flags=0).AndReturn({'cur': 1, 'end': 1000})",
            "        domain.blockJobInfo('vda', flags=0).AndReturn(",
            "            {'cur': 1000, 'end': 1000})",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.drvr._volume_snapshot_delete(self.c, instance, self.volume_uuid,",
            "                                          snapshot_id, self.delete_info_1)",
            "",
            "        self.mox.VerifyAll()",
            "",
            "    def _setup_block_rebase_domain_and_guest_mocks(self, dom_xml):",
            "        mock_domain = mock.Mock(spec=fakelibvirt.virDomain)",
            "        mock_domain.XMLDesc.return_value = dom_xml",
            "        guest = libvirt_guest.Guest(mock_domain)",
            "",
            "        exc = fakelibvirt.make_libvirtError(",
            "            fakelibvirt.libvirtError, 'virDomainBlockRebase() failed',",
            "            error_code=fakelibvirt.VIR_ERR_OPERATION_INVALID)",
            "        mock_domain.blockRebase.side_effect = exc",
            "",
            "        return mock_domain, guest",
            "",
            "    @mock.patch.object(host.Host, \"has_min_version\",",
            "                       mock.Mock(return_value=True))",
            "    @mock.patch(\"nova.virt.libvirt.guest.Guest.is_active\",",
            "                 mock.Mock(return_value=False))",
            "    @mock.patch('nova.virt.images.qemu_img_info',",
            "                return_value=mock.Mock(file_format=\"fake_fmt\"))",
            "    @mock.patch('nova.utils.execute')",
            "    def test_volume_snapshot_delete_when_dom_not_running(self, mock_execute,",
            "                                                         mock_qemu_img_info):",
            "        \"\"\"Deleting newest snapshot of a file-based image when the domain is",
            "        not running should trigger a blockRebase using qemu-img not libvirt.",
            "        In this test, we rebase the image with another image as backing file.",
            "        \"\"\"",
            "        mock_domain, guest = self._setup_block_rebase_domain_and_guest_mocks(",
            "                                self.dom_xml)",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "        with mock.patch.object(self.drvr._host, 'get_guest',",
            "                               return_value=guest):",
            "            self.drvr._volume_snapshot_delete(self.c, instance,",
            "                                              self.volume_uuid, snapshot_id,",
            "                                              self.delete_info_1)",
            "",
            "        mock_qemu_img_info.assert_called_once_with(\"snap.img\")",
            "        mock_execute.assert_called_once_with('qemu-img', 'rebase',",
            "                                             '-b', 'snap.img', '-F',",
            "                                             'fake_fmt', 'disk1_file')",
            "",
            "    @mock.patch.object(host.Host, \"has_min_version\",",
            "                       mock.Mock(return_value=True))",
            "    @mock.patch(\"nova.virt.libvirt.guest.Guest.is_active\",",
            "                 mock.Mock(return_value=False))",
            "    @mock.patch('nova.virt.images.qemu_img_info',",
            "                return_value=mock.Mock(file_format=\"fake_fmt\"))",
            "    @mock.patch('nova.utils.execute')",
            "    def test_volume_snapshot_delete_when_dom_not_running_and_no_rebase_base(",
            "        self, mock_execute, mock_qemu_img_info):",
            "        \"\"\"Deleting newest snapshot of a file-based image when the domain is",
            "        not running should trigger a blockRebase using qemu-img not libvirt.",
            "        In this test, the image is rebased onto no backing file (i.e.",
            "        it will exist independently of any backing file)",
            "        \"\"\"",
            "        mock_domain, mock_guest = (",
            "            self._setup_block_rebase_domain_and_guest_mocks(self.dom_xml))",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "        with mock.patch.object(self.drvr._host, 'get_guest',",
            "                               return_value=mock_guest):",
            "            self.drvr._volume_snapshot_delete(self.c, instance,",
            "                                              self.volume_uuid, snapshot_id,",
            "                                              self.delete_info_3)",
            "",
            "        self.assertEqual(0, mock_qemu_img_info.call_count)",
            "        mock_execute.assert_called_once_with('qemu-img', 'rebase',",
            "                                             '-b', '', 'disk1_file')",
            "",
            "    @mock.patch.object(host.Host, \"has_min_version\",",
            "                       mock.Mock(return_value=True))",
            "    @mock.patch(\"nova.virt.libvirt.guest.Guest.is_active\",",
            "                 mock.Mock(return_value=False))",
            "    def test_volume_snapshot_delete_when_dom_with_nw_disk_not_running(self):",
            "        \"\"\"Deleting newest snapshot of a network disk when the domain is not",
            "        running should raise a NovaException.",
            "        \"\"\"",
            "        mock_domain, mock_guest = (",
            "            self._setup_block_rebase_domain_and_guest_mocks(",
            "                self.dom_netdisk_xml))",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "        with mock.patch.object(self.drvr._host, 'get_guest',",
            "                               return_value=mock_guest):",
            "            ex = self.assertRaises(exception.NovaException,",
            "                                   self.drvr._volume_snapshot_delete,",
            "                                   self.c, instance, self.volume_uuid,",
            "                                   snapshot_id, self.delete_info_1)",
            "            self.assertIn('has not been fully tested', six.text_type(ex))",
            "",
            "    def test_volume_snapshot_delete_2(self):",
            "        \"\"\"Deleting older snapshot -- blockCommit.\"\"\"",
            "",
            "        # libvirt lib doesn't have VIR_DOMAIN_BLOCK_COMMIT_RELATIVE",
            "        fakelibvirt.__dict__.pop('VIR_DOMAIN_BLOCK_COMMIT_RELATIVE')",
            "        self.stubs.Set(libvirt_driver, 'libvirt', fakelibvirt)",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "",
            "        domain = FakeVirtDomain(fake_xml=self.dom_xml)",
            "        self.mox.StubOutWithMock(domain, 'XMLDesc')",
            "        domain.XMLDesc(flags=0).AndReturn(self.dom_xml)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr._host, 'has_min_version')",
            "        self.mox.StubOutWithMock(domain, 'blockRebase')",
            "        self.mox.StubOutWithMock(domain, 'blockCommit')",
            "        self.mox.StubOutWithMock(domain, 'blockJobInfo')",
            "",
            "        self.drvr._host.get_domain(instance).AndReturn(domain)",
            "        self.drvr._host.has_min_version(mox.IgnoreArg()).AndReturn(True)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(exception.Invalid,",
            "                          self.drvr._volume_snapshot_delete,",
            "                          self.c,",
            "                          instance,",
            "                          self.volume_uuid,",
            "                          snapshot_id,",
            "                          self.delete_info_2)",
            "",
            "        fakelibvirt.__dict__.update({'VIR_DOMAIN_BLOCK_COMMIT_RELATIVE': 4})",
            "",
            "    def test_volume_snapshot_delete_relative_2(self):",
            "        \"\"\"Deleting older snapshot -- blockCommit using relative flag\"\"\"",
            "",
            "        self.stubs.Set(libvirt_driver, 'libvirt', fakelibvirt)",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "",
            "        domain = FakeVirtDomain(fake_xml=self.dom_xml)",
            "        self.mox.StubOutWithMock(domain, 'XMLDesc')",
            "        domain.XMLDesc(flags=0).AndReturn(self.dom_xml)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr._host, 'has_min_version')",
            "        self.mox.StubOutWithMock(domain, 'blockRebase')",
            "        self.mox.StubOutWithMock(domain, 'blockCommit')",
            "        self.mox.StubOutWithMock(domain, 'blockJobInfo')",
            "",
            "        self.drvr._host.get_domain(instance).AndReturn(domain)",
            "        self.drvr._host.has_min_version(mox.IgnoreArg()).AndReturn(True)",
            "",
            "        domain.blockCommit('vda', 'other-snap.img', 'snap.img', 0,",
            "                           flags=fakelibvirt.VIR_DOMAIN_BLOCK_COMMIT_RELATIVE)",
            "",
            "        domain.blockJobInfo('vda', flags=0).AndReturn({'cur': 1, 'end': 1000})",
            "        domain.blockJobInfo('vda', flags=0).AndReturn({})",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.drvr._volume_snapshot_delete(self.c, instance, self.volume_uuid,",
            "                                          snapshot_id, self.delete_info_2)",
            "",
            "        self.mox.VerifyAll()",
            "",
            "    def test_volume_snapshot_delete_nonrelative_null_base(self):",
            "        # Deleting newest and last snapshot of a volume",
            "        # with blockRebase. So base of the new image will be null.",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "",
            "        domain = FakeVirtDomain(fake_xml=self.dom_xml)",
            "        guest = libvirt_guest.Guest(domain)",
            "",
            "        with test.nested(",
            "            mock.patch.object(domain, 'XMLDesc', return_value=self.dom_xml),",
            "            mock.patch.object(self.drvr._host, 'get_guest',",
            "                              return_value=guest),",
            "            mock.patch.object(self.drvr._host, 'has_min_version',",
            "                              return_value=True),",
            "            mock.patch.object(domain, 'blockRebase'),",
            "            mock.patch.object(domain, 'blockJobInfo',",
            "                              return_value={'cur': 1000, 'end': 1000})",
            "        ) as (mock_xmldesc, mock_get_guest, mock_has_min_version,",
            "              mock_rebase, mock_job_info):",
            "",
            "            self.drvr._volume_snapshot_delete(self.c, instance,",
            "                                              self.volume_uuid, snapshot_id,",
            "                                              self.delete_info_3)",
            "",
            "            mock_xmldesc.assert_called_once_with(flags=0)",
            "            mock_get_guest.assert_called_once_with(instance)",
            "            mock_has_min_version.assert_called_once_with((1, 1, 1,))",
            "            mock_rebase.assert_called_once_with('vda', None, 0, flags=0)",
            "            mock_job_info.assert_called_once_with('vda', flags=0)",
            "",
            "    def test_volume_snapshot_delete_netdisk_nonrelative_null_base(self):",
            "        # Deleting newest and last snapshot of a network attached volume",
            "        # with blockRebase. So base of the new image will be null.",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "",
            "        domain = FakeVirtDomain(fake_xml=self.dom_netdisk_xml_2)",
            "        guest = libvirt_guest.Guest(domain)",
            "",
            "        with test.nested(",
            "            mock.patch.object(domain, 'XMLDesc',",
            "                              return_value=self.dom_netdisk_xml_2),",
            "            mock.patch.object(self.drvr._host, 'get_guest',",
            "                              return_value=guest),",
            "            mock.patch.object(self.drvr._host, 'has_min_version',",
            "                              return_value=True),",
            "            mock.patch.object(domain, 'blockRebase'),",
            "            mock.patch.object(domain, 'blockJobInfo',",
            "                              return_value={'cur': 1000, 'end': 1000})",
            "        ) as (mock_xmldesc, mock_get_guest, mock_has_min_version,",
            "              mock_rebase, mock_job_info):",
            "",
            "            self.drvr._volume_snapshot_delete(self.c, instance,",
            "                                              self.volume_uuid, snapshot_id,",
            "                                              self.delete_info_3)",
            "",
            "            mock_xmldesc.assert_called_once_with(flags=0)",
            "            mock_get_guest.assert_called_once_with(instance)",
            "            mock_has_min_version.assert_called_once_with((1, 1, 1,))",
            "            mock_rebase.assert_called_once_with('vdb', None, 0, flags=0)",
            "            mock_job_info.assert_called_once_with('vdb', flags=0)",
            "",
            "    def test_volume_snapshot_delete_outer_success(self):",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "",
            "        FakeVirtDomain(fake_xml=self.dom_xml)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_api')",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_snapshot_delete')",
            "",
            "        self.drvr._volume_snapshot_delete(self.c,",
            "                                          instance,",
            "                                          self.volume_uuid,",
            "                                          snapshot_id,",
            "                                          delete_info=self.delete_info_1)",
            "",
            "        self.drvr._volume_api.update_snapshot_status(",
            "            self.c, snapshot_id, 'deleting')",
            "",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_refresh_connection_info')",
            "        self.drvr._volume_refresh_connection_info(self.c, instance,",
            "                                                  self.volume_uuid)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.drvr.volume_snapshot_delete(self.c, instance, self.volume_uuid,",
            "                                         snapshot_id,",
            "                                         self.delete_info_1)",
            "",
            "        self.mox.VerifyAll()",
            "",
            "    def test_volume_snapshot_delete_outer_failure(self):",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = '1234-9876'",
            "",
            "        FakeVirtDomain(fake_xml=self.dom_xml)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_api')",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_snapshot_delete')",
            "",
            "        self.drvr._volume_snapshot_delete(self.c,",
            "                                          instance,",
            "                                          self.volume_uuid,",
            "                                          snapshot_id,",
            "                                          delete_info=self.delete_info_1).\\",
            "            AndRaise(exception.NovaException('oops'))",
            "",
            "        self.drvr._volume_api.update_snapshot_status(",
            "            self.c, snapshot_id, 'error_deleting')",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(exception.NovaException,",
            "                          self.drvr.volume_snapshot_delete,",
            "                          self.c,",
            "                          instance,",
            "                          self.volume_uuid,",
            "                          snapshot_id,",
            "                          self.delete_info_1)",
            "",
            "        self.mox.VerifyAll()",
            "",
            "    def test_volume_snapshot_delete_invalid_type(self):",
            "        instance = objects.Instance(**self.inst)",
            "",
            "        FakeVirtDomain(fake_xml=self.dom_xml)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_api')",
            "        self.mox.StubOutWithMock(self.drvr._host, 'has_min_version')",
            "",
            "        self.drvr._host.has_min_version(mox.IgnoreArg()).AndReturn(True)",
            "",
            "        self.drvr._volume_api.update_snapshot_status(",
            "            self.c, self.snapshot_id, 'error_deleting')",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(exception.NovaException,",
            "                          self.drvr.volume_snapshot_delete,",
            "                          self.c,",
            "                          instance,",
            "                          self.volume_uuid,",
            "                          self.snapshot_id,",
            "                          self.delete_info_invalid_type)",
            "",
            "    def test_volume_snapshot_delete_netdisk_1(self):",
            "        \"\"\"Delete newest snapshot -- blockRebase for libgfapi/network disk.\"\"\"",
            "",
            "        class FakeNetdiskDomain(FakeVirtDomain):",
            "            def __init__(self, *args, **kwargs):",
            "                super(FakeNetdiskDomain, self).__init__(*args, **kwargs)",
            "",
            "            def XMLDesc(self, flags):",
            "                return self.dom_netdisk_xml",
            "",
            "        # libvirt lib doesn't have VIR_DOMAIN_BLOCK_REBASE_RELATIVE",
            "        fakelibvirt.__dict__.pop('VIR_DOMAIN_BLOCK_REBASE_RELATIVE')",
            "        self.stubs.Set(libvirt_driver, 'libvirt', fakelibvirt)",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "",
            "        domain = FakeNetdiskDomain(fake_xml=self.dom_netdisk_xml)",
            "        self.mox.StubOutWithMock(domain, 'XMLDesc')",
            "        domain.XMLDesc(flags=0).AndReturn(self.dom_netdisk_xml)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr._host, 'has_min_version')",
            "        self.mox.StubOutWithMock(domain, 'blockRebase')",
            "        self.mox.StubOutWithMock(domain, 'blockCommit')",
            "        self.mox.StubOutWithMock(domain, 'blockJobInfo')",
            "",
            "        self.drvr._host.get_domain(instance).AndReturn(domain)",
            "        self.drvr._host.has_min_version(mox.IgnoreArg()).AndReturn(True)",
            "",
            "        domain.blockRebase('vdb', 'vdb[1]', 0, flags=0)",
            "",
            "        domain.blockJobInfo('vdb', flags=0).AndReturn({'cur': 1, 'end': 1000})",
            "        domain.blockJobInfo('vdb', flags=0).AndReturn(",
            "            {'cur': 1000, 'end': 1000})",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.drvr._volume_snapshot_delete(self.c, instance, self.volume_uuid,",
            "                                          snapshot_id, self.delete_info_1)",
            "        self.mox.VerifyAll()",
            "        fakelibvirt.__dict__.update({'VIR_DOMAIN_BLOCK_REBASE_RELATIVE': 8})",
            "",
            "    def test_volume_snapshot_delete_netdisk_relative_1(self):",
            "        \"\"\"Delete newest snapshot -- blockRebase for libgfapi/network disk.\"\"\"",
            "",
            "        class FakeNetdiskDomain(FakeVirtDomain):",
            "            def __init__(self, *args, **kwargs):",
            "                super(FakeNetdiskDomain, self).__init__(*args, **kwargs)",
            "",
            "            def XMLDesc(self, flags):",
            "                return self.dom_netdisk_xml",
            "",
            "        self.stubs.Set(libvirt_driver, 'libvirt', fakelibvirt)",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "",
            "        domain = FakeNetdiskDomain(fake_xml=self.dom_netdisk_xml)",
            "        self.mox.StubOutWithMock(domain, 'XMLDesc')",
            "        domain.XMLDesc(flags=0).AndReturn(self.dom_netdisk_xml)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr._host, 'has_min_version')",
            "        self.mox.StubOutWithMock(domain, 'blockRebase')",
            "        self.mox.StubOutWithMock(domain, 'blockCommit')",
            "        self.mox.StubOutWithMock(domain, 'blockJobInfo')",
            "",
            "        self.drvr._host.get_domain(instance).AndReturn(domain)",
            "        self.drvr._host.has_min_version(mox.IgnoreArg()).AndReturn(True)",
            "",
            "        domain.blockRebase('vdb', 'vdb[1]', 0,",
            "                           flags=fakelibvirt.VIR_DOMAIN_BLOCK_REBASE_RELATIVE)",
            "",
            "        domain.blockJobInfo('vdb', flags=0).AndReturn({'cur': 1, 'end': 1000})",
            "        domain.blockJobInfo('vdb', flags=0).AndReturn(",
            "            {'cur': 1000, 'end': 1000})",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.drvr._volume_snapshot_delete(self.c, instance, self.volume_uuid,",
            "                                          snapshot_id, self.delete_info_1)",
            "",
            "        self.mox.VerifyAll()",
            "",
            "    def test_volume_snapshot_delete_netdisk_2(self):",
            "        \"\"\"Delete older snapshot -- blockCommit for libgfapi/network disk.\"\"\"",
            "",
            "        class FakeNetdiskDomain(FakeVirtDomain):",
            "            def __init__(self, *args, **kwargs):",
            "                super(FakeNetdiskDomain, self).__init__(*args, **kwargs)",
            "",
            "            def XMLDesc(self, flags):",
            "                return self.dom_netdisk_xml",
            "",
            "        # libvirt lib doesn't have VIR_DOMAIN_BLOCK_COMMIT_RELATIVE",
            "        fakelibvirt.__dict__.pop('VIR_DOMAIN_BLOCK_COMMIT_RELATIVE')",
            "        self.stubs.Set(libvirt_driver, 'libvirt', fakelibvirt)",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "",
            "        domain = FakeNetdiskDomain(fake_xml=self.dom_netdisk_xml)",
            "        self.mox.StubOutWithMock(domain, 'XMLDesc')",
            "        domain.XMLDesc(flags=0).AndReturn(self.dom_netdisk_xml)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr._host, 'has_min_version')",
            "        self.mox.StubOutWithMock(domain, 'blockRebase')",
            "        self.mox.StubOutWithMock(domain, 'blockCommit')",
            "        self.mox.StubOutWithMock(domain, 'blockJobInfo')",
            "",
            "        self.drvr._host.get_domain(instance).AndReturn(domain)",
            "        self.drvr._host.has_min_version(mox.IgnoreArg()).AndReturn(True)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(exception.Invalid,",
            "                          self.drvr._volume_snapshot_delete,",
            "                          self.c,",
            "                          instance,",
            "                          self.volume_uuid,",
            "                          snapshot_id,",
            "                          self.delete_info_netdisk)",
            "        fakelibvirt.__dict__.update({'VIR_DOMAIN_BLOCK_COMMIT_RELATIVE': 4})",
            "",
            "    def test_volume_snapshot_delete_netdisk_relative_2(self):",
            "        \"\"\"Delete older snapshot -- blockCommit for libgfapi/network disk.\"\"\"",
            "",
            "        class FakeNetdiskDomain(FakeVirtDomain):",
            "            def __init__(self, *args, **kwargs):",
            "                super(FakeNetdiskDomain, self).__init__(*args, **kwargs)",
            "",
            "            def XMLDesc(self, flags):",
            "                return self.dom_netdisk_xml",
            "",
            "        self.stubs.Set(libvirt_driver, 'libvirt', fakelibvirt)",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "",
            "        domain = FakeNetdiskDomain(fake_xml=self.dom_netdisk_xml)",
            "        self.mox.StubOutWithMock(domain, 'XMLDesc')",
            "        domain.XMLDesc(flags=0).AndReturn(self.dom_netdisk_xml)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr._host, 'has_min_version')",
            "        self.mox.StubOutWithMock(domain, 'blockRebase')",
            "        self.mox.StubOutWithMock(domain, 'blockCommit')",
            "        self.mox.StubOutWithMock(domain, 'blockJobInfo')",
            "",
            "        self.drvr._host.get_domain(instance).AndReturn(domain)",
            "        self.drvr._host.has_min_version(mox.IgnoreArg()).AndReturn(True)",
            "",
            "        domain.blockCommit('vdb', 'vdb[0]', 'vdb[1]', 0,",
            "                           flags=fakelibvirt.VIR_DOMAIN_BLOCK_COMMIT_RELATIVE)",
            "",
            "        domain.blockJobInfo('vdb', flags=0).AndReturn({'cur': 1, 'end': 1000})",
            "        domain.blockJobInfo('vdb', flags=0).AndReturn(",
            "            {'cur': 1000, 'end': 1000})",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.drvr._volume_snapshot_delete(self.c, instance, self.volume_uuid,",
            "                                          snapshot_id,",
            "                                          self.delete_info_netdisk)",
            "",
            "        self.mox.VerifyAll()",
            "",
            "",
            "def _fake_convert_image(source, dest, in_format, out_format,",
            "                               run_as_root=True):",
            "    libvirt_driver.libvirt_utils.files[dest] = ''",
            "",
            "",
            "class _BaseSnapshotTests(test.NoDBTestCase):",
            "    def setUp(self):",
            "        super(_BaseSnapshotTests, self).setUp()",
            "        self.flags(snapshots_directory='./', group='libvirt')",
            "        self.context = context.get_admin_context()",
            "",
            "        self.useFixture(fixtures.MonkeyPatch(",
            "            'nova.virt.libvirt.driver.libvirt_utils',",
            "            fake_libvirt_utils))",
            "        self.useFixture(fixtures.MonkeyPatch(",
            "            'nova.virt.libvirt.imagebackend.libvirt_utils',",
            "            fake_libvirt_utils))",
            "",
            "        self.image_service = nova.tests.unit.image.fake.stub_out_image_service(",
            "                self)",
            "",
            "        self.mock_update_task_state = mock.Mock()",
            "",
            "        test_instance = _create_test_instance()",
            "        self.instance_ref = objects.Instance(**test_instance)",
            "        self.instance_ref.info_cache = objects.InstanceInfoCache(",
            "            network_info=None)",
            "",
            "    def _assert_snapshot(self, snapshot, disk_format,",
            "                         expected_properties=None):",
            "        self.mock_update_task_state.assert_has_calls([",
            "            mock.call(task_state=task_states.IMAGE_PENDING_UPLOAD),",
            "            mock.call(task_state=task_states.IMAGE_UPLOADING,",
            "                      expected_state=task_states.IMAGE_PENDING_UPLOAD)])",
            "",
            "        props = snapshot['properties']",
            "        self.assertEqual(props['image_state'], 'available')",
            "        self.assertEqual(snapshot['status'], 'active')",
            "        self.assertEqual(snapshot['disk_format'], disk_format)",
            "        self.assertEqual(snapshot['name'], 'test-snap')",
            "",
            "        if expected_properties:",
            "            for expected_key, expected_value in \\",
            "                    six.iteritems(expected_properties):",
            "                self.assertEqual(expected_value, props[expected_key])",
            "",
            "    def _create_image(self, extra_properties=None):",
            "        properties = {'instance_id': self.instance_ref['id'],",
            "                      'user_id': str(self.context.user_id)}",
            "        if extra_properties:",
            "            properties.update(extra_properties)",
            "",
            "        sent_meta = {'name': 'test-snap',",
            "                     'is_public': False,",
            "                     'status': 'creating',",
            "                     'properties': properties}",
            "",
            "        # Create new image. It will be updated in snapshot method",
            "        # To work with it from snapshot, the single image_service is needed",
            "        recv_meta = self.image_service.create(self.context, sent_meta)",
            "        return recv_meta",
            "",
            "    @mock.patch.object(imagebackend.Image, 'resolve_driver_format')",
            "    @mock.patch.object(host.Host, 'get_domain')",
            "    def _snapshot(self, image_id, mock_get_domain, mock_resolve):",
            "        mock_get_domain.return_value = FakeVirtDomain()",
            "        driver = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        driver.snapshot(self.context, self.instance_ref, image_id,",
            "                        self.mock_update_task_state)",
            "        snapshot = self.image_service.show(self.context, image_id)",
            "        return snapshot",
            "",
            "    def _test_snapshot(self, disk_format, extra_properties=None):",
            "        recv_meta = self._create_image(extra_properties=extra_properties)",
            "        snapshot = self._snapshot(recv_meta['id'])",
            "        self._assert_snapshot(snapshot, disk_format=disk_format,",
            "                              expected_properties=extra_properties)",
            "",
            "",
            "class LibvirtSnapshotTests(_BaseSnapshotTests):",
            "    def test_ami(self):",
            "        # Assign different image_ref from nova/images/fakes for testing ami",
            "        self.instance_ref.image_ref = 'c905cedb-7281-47e4-8a62-f26bc5fc4c77'",
            "        self.instance_ref.system_metadata = \\",
            "          utils.get_system_metadata_from_image(",
            "            {'disk_format': 'ami'})",
            "",
            "        self._test_snapshot(disk_format='ami')",
            "",
            "    @mock.patch.object(fake_libvirt_utils, 'disk_type', new='raw')",
            "    @mock.patch.object(libvirt_driver.imagebackend.images,",
            "                       'convert_image',",
            "                       side_effect=_fake_convert_image)",
            "    def test_raw(self, mock_convert_image):",
            "        self._test_snapshot(disk_format='raw')",
            "",
            "    def test_qcow2(self):",
            "        self._test_snapshot(disk_format='qcow2')",
            "",
            "    @mock.patch.object(fake_libvirt_utils, 'disk_type', new='ploop')",
            "    @mock.patch.object(libvirt_driver.imagebackend.images,",
            "                       'convert_image',",
            "                       side_effect=_fake_convert_image)",
            "    def test_ploop(self, mock_convert_image):",
            "        self._test_snapshot(disk_format='ploop')",
            "",
            "    def test_no_image_architecture(self):",
            "        self.instance_ref.image_ref = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "        self._test_snapshot(disk_format='qcow2')",
            "",
            "    def test_no_original_image(self):",
            "        self.instance_ref.image_ref = '661122aa-1234-dede-fefe-babababababa'",
            "        self._test_snapshot(disk_format='qcow2')",
            "",
            "    def test_snapshot_metadata_image(self):",
            "        # Assign an image with an architecture defined (x86_64)",
            "        self.instance_ref.image_ref = 'a440c04b-79fa-479c-bed1-0b816eaec379'",
            "",
            "        extra_properties = {'architecture': 'fake_arch',",
            "                            'key_a': 'value_a',",
            "                            'key_b': 'value_b',",
            "                            'os_type': 'linux'}",
            "",
            "        self._test_snapshot(disk_format='qcow2',",
            "                            extra_properties=extra_properties)",
            "",
            "    @mock.patch.object(rbd_utils, 'RBDDriver')",
            "    @mock.patch.object(rbd_utils, 'rbd')",
            "    def test_raw_with_rbd_clone(self, mock_rbd, mock_driver):",
            "        self.flags(images_type='rbd', group='libvirt')",
            "        rbd = mock_driver.return_value",
            "        rbd.parent_info = mock.Mock(return_value=['test-pool', '', ''])",
            "        rbd.parse_url = mock.Mock(return_value=['a', 'b', 'c', 'd'])",
            "        with mock.patch.object(fake_libvirt_utils, 'find_disk',",
            "                               return_value=('rbd://some/fake/rbd/image',",
            "                                             'raw')):",
            "            with mock.patch.object(fake_libvirt_utils, 'disk_type', new='rbd'):",
            "                self._test_snapshot(disk_format='raw')",
            "        rbd.clone.assert_called_with(mock.ANY, mock.ANY, dest_pool='test-pool')",
            "        rbd.flatten.assert_called_with(mock.ANY, pool='test-pool')",
            "",
            "    @mock.patch.object(rbd_utils, 'RBDDriver')",
            "    @mock.patch.object(rbd_utils, 'rbd')",
            "    def test_raw_with_rbd_clone_graceful_fallback(self, mock_rbd, mock_driver):",
            "        self.flags(images_type='rbd', group='libvirt')",
            "        rbd = mock_driver.return_value",
            "        rbd.parent_info = mock.Mock(side_effect=exception.ImageUnacceptable(",
            "            image_id='fake_id', reason='rbd testing'))",
            "        with test.nested(",
            "                mock.patch.object(libvirt_driver.imagebackend.images,",
            "                                  'convert_image',",
            "                                  side_effect=_fake_convert_image),",
            "                mock.patch.object(fake_libvirt_utils, 'find_disk',",
            "                                  return_value=('rbd://some/fake/rbd/image',",
            "                                                'raw')),",
            "                mock.patch.object(fake_libvirt_utils, 'disk_type', new='rbd')):",
            "            self._test_snapshot(disk_format='raw')",
            "            self.assertFalse(rbd.clone.called)",
            "",
            "    @mock.patch.object(rbd_utils, 'RBDDriver')",
            "    @mock.patch.object(rbd_utils, 'rbd')",
            "    def test_raw_with_rbd_clone_eperm(self, mock_rbd, mock_driver):",
            "        self.flags(images_type='rbd', group='libvirt')",
            "        rbd = mock_driver.return_value",
            "        rbd.parent_info = mock.Mock(return_value=['test-pool', '', ''])",
            "        rbd.parse_url = mock.Mock(return_value=['a', 'b', 'c', 'd'])",
            "        rbd.clone = mock.Mock(side_effect=exception.Forbidden(",
            "                image_id='fake_id', reason='rbd testing'))",
            "        with test.nested(",
            "                mock.patch.object(libvirt_driver.imagebackend.images,",
            "                                  'convert_image',",
            "                                  side_effect=_fake_convert_image),",
            "                mock.patch.object(fake_libvirt_utils, 'find_disk',",
            "                                  return_value=('rbd://some/fake/rbd/image',",
            "                                                'raw')),",
            "                mock.patch.object(fake_libvirt_utils, 'disk_type', new='rbd')):",
            "            self._test_snapshot(disk_format='raw')",
            "            # Ensure that the direct_snapshot attempt was cleaned up",
            "            rbd.remove_snap.assert_called_with('c', 'd', ignore_errors=False,",
            "                                               pool='b', force=True)",
            "",
            "    @mock.patch.object(rbd_utils, 'RBDDriver')",
            "    @mock.patch.object(rbd_utils, 'rbd')",
            "    def test_raw_with_rbd_clone_post_process_fails(self, mock_rbd,",
            "                                                   mock_driver):",
            "        self.flags(images_type='rbd', group='libvirt')",
            "        rbd = mock_driver.return_value",
            "        rbd.parent_info = mock.Mock(return_value=['test-pool', '', ''])",
            "        rbd.parse_url = mock.Mock(return_value=['a', 'b', 'c', 'd'])",
            "        with test.nested(",
            "                mock.patch.object(fake_libvirt_utils, 'find_disk',",
            "                                  return_value=('rbd://some/fake/rbd/image',",
            "                                                'raw')),",
            "                mock.patch.object(fake_libvirt_utils, 'disk_type', new='rbd'),",
            "                mock.patch.object(self.image_service, 'update',",
            "                                  side_effect=test.TestingException)):",
            "            self.assertRaises(test.TestingException, self._test_snapshot,",
            "                              disk_format='raw')",
            "        rbd.clone.assert_called_with(mock.ANY, mock.ANY, dest_pool='test-pool')",
            "        rbd.flatten.assert_called_with(mock.ANY, pool='test-pool')",
            "        # Ensure that the direct_snapshot attempt was cleaned up",
            "        rbd.remove_snap.assert_called_with('c', 'd', ignore_errors=True,",
            "                                           pool='b', force=True)",
            "",
            "",
            "class LXCSnapshotTests(LibvirtSnapshotTests):",
            "    \"\"\"Repeat all of the Libvirt snapshot tests, but with LXC enabled\"\"\"",
            "    def setUp(self):",
            "        super(LXCSnapshotTests, self).setUp()",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "",
            "",
            "class LVMSnapshotTests(_BaseSnapshotTests):",
            "    @mock.patch.object(fake_libvirt_utils, 'disk_type', new='lvm')",
            "    @mock.patch.object(libvirt_driver.imagebackend.images,",
            "                       'convert_image',",
            "                       side_effect=_fake_convert_image)",
            "    @mock.patch.object(libvirt_driver.imagebackend.lvm, 'volume_info')",
            "    def _test_lvm_snapshot(self, disk_format, mock_volume_info,",
            "                           mock_convert_image):",
            "        self.flags(images_type='lvm',",
            "                   images_volume_group='nova-vg', group='libvirt')",
            "",
            "        self._test_snapshot(disk_format=disk_format)",
            "",
            "        mock_volume_info.assert_has_calls([mock.call('/dev/nova-vg/lv')])",
            "        mock_convert_image.assert_called_once_with(",
            "            '/dev/nova-vg/lv', mock.ANY, 'raw', disk_format,",
            "            run_as_root=True)",
            "",
            "    def test_raw(self):",
            "        self._test_lvm_snapshot('raw')",
            "",
            "    def test_qcow2(self):",
            "        self.flags(snapshot_image_format='qcow2', group='libvirt')",
            "        self._test_lvm_snapshot('qcow2')"
        ],
        "afterPatchFile": [
            "#    Copyright 2010 OpenStack Foundation",
            "#    Copyright 2012 University Of Minho",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import contextlib",
            "import copy",
            "import datetime",
            "import errno",
            "import glob",
            "import os",
            "import random",
            "import re",
            "import shutil",
            "import signal",
            "import threading",
            "import time",
            "import uuid",
            "",
            "import eventlet",
            "from eventlet import greenthread",
            "import fixtures",
            "from lxml import etree",
            "import mock",
            "from mox3 import mox",
            "from os_brick.initiator import connector",
            "from oslo_concurrency import lockutils",
            "from oslo_concurrency import processutils",
            "from oslo_config import cfg",
            "from oslo_serialization import jsonutils",
            "from oslo_service import loopingcall",
            "from oslo_utils import encodeutils",
            "from oslo_utils import fileutils",
            "from oslo_utils import fixture as utils_fixture",
            "from oslo_utils import importutils",
            "from oslo_utils import units",
            "from oslo_utils import uuidutils",
            "from oslo_utils import versionutils",
            "import six",
            "from six.moves import builtins",
            "from six.moves import range",
            "",
            "from nova.api.metadata import base as instance_metadata",
            "from nova.compute import arch",
            "from nova.compute import cpumodel",
            "from nova.compute import manager",
            "from nova.compute import power_state",
            "from nova.compute import task_states",
            "from nova.compute import vm_mode",
            "from nova.compute import vm_states",
            "from nova import context",
            "from nova import db",
            "from nova import exception",
            "from nova.network import model as network_model",
            "from nova import objects",
            "from nova.objects import block_device as block_device_obj",
            "from nova.objects import fields",
            "from nova.pci import manager as pci_manager",
            "from nova.pci import utils as pci_utils",
            "from nova import test",
            "from nova.tests.unit import fake_block_device",
            "from nova.tests.unit import fake_instance",
            "from nova.tests.unit import fake_network",
            "import nova.tests.unit.image.fake",
            "from nova.tests.unit import matchers",
            "from nova.tests.unit.objects import test_pci_device",
            "from nova.tests.unit.objects import test_vcpu_model",
            "from nova.tests.unit.virt.libvirt import fake_imagebackend",
            "from nova.tests.unit.virt.libvirt import fake_libvirt_utils",
            "from nova.tests.unit.virt.libvirt import fakelibvirt",
            "from nova import utils",
            "from nova import version",
            "from nova.virt import block_device as driver_block_device",
            "from nova.virt import configdrive",
            "from nova.virt.disk import api as disk",
            "from nova.virt import driver",
            "from nova.virt import fake",
            "from nova.virt import firewall as base_firewall",
            "from nova.virt import hardware",
            "from nova.virt.image import model as imgmodel",
            "from nova.virt.libvirt import blockinfo",
            "from nova.virt.libvirt import config as vconfig",
            "from nova.virt.libvirt import driver as libvirt_driver",
            "from nova.virt.libvirt import firewall",
            "from nova.virt.libvirt import guest as libvirt_guest",
            "from nova.virt.libvirt import host",
            "from nova.virt.libvirt import imagebackend",
            "from nova.virt.libvirt.storage import dmcrypt",
            "from nova.virt.libvirt.storage import lvm",
            "from nova.virt.libvirt.storage import rbd_utils",
            "from nova.virt.libvirt import utils as libvirt_utils",
            "from nova.virt.libvirt.volume import volume as volume_drivers",
            "",
            "libvirt_driver.libvirt = fakelibvirt",
            "host.libvirt = fakelibvirt",
            "libvirt_guest.libvirt = fakelibvirt",
            "",
            "",
            "CONF = cfg.CONF",
            "CONF.import_opt('compute_manager', 'nova.service')",
            "CONF.import_opt('host', 'nova.netconf')",
            "CONF.import_opt('my_ip', 'nova.netconf')",
            "CONF.import_opt('image_cache_subdirectory_name', 'nova.virt.imagecache')",
            "CONF.import_opt('instances_path', 'nova.compute.manager')",
            "",
            "_fake_network_info = fake_network.fake_get_instance_nw_info",
            "",
            "_fake_NodeDevXml = \\",
            "    {\"pci_0000_04_00_3\": \"\"\"",
            "        <device>",
            "        <name>pci_0000_04_00_3</name>",
            "        <parent>pci_0000_00_01_1</parent>",
            "        <driver>",
            "            <name>igb</name>",
            "        </driver>",
            "        <capability type='pci'>",
            "            <domain>0</domain>",
            "            <bus>4</bus>",
            "            <slot>0</slot>",
            "            <function>3</function>",
            "            <product id='0x1521'>I350 Gigabit Network Connection</product>",
            "            <vendor id='0x8086'>Intel Corporation</vendor>",
            "            <capability type='virt_functions'>",
            "              <address domain='0x0000' bus='0x04' slot='0x10' function='0x3'/>",
            "              <address domain='0x0000' bus='0x04' slot='0x10' function='0x7'/>",
            "              <address domain='0x0000' bus='0x04' slot='0x11' function='0x3'/>",
            "              <address domain='0x0000' bus='0x04' slot='0x11' function='0x7'/>",
            "            </capability>",
            "        </capability>",
            "      </device>\"\"\",",
            "    \"pci_0000_04_10_7\": \"\"\"",
            "      <device>",
            "         <name>pci_0000_04_10_7</name>",
            "         <parent>pci_0000_00_01_1</parent>",
            "         <driver>",
            "         <name>igbvf</name>",
            "         </driver>",
            "         <capability type='pci'>",
            "          <domain>0</domain>",
            "          <bus>4</bus>",
            "          <slot>16</slot>",
            "          <function>7</function>",
            "          <product id='0x1520'>I350 Ethernet Controller Virtual Function",
            "            </product>",
            "          <vendor id='0x8086'>Intel Corporation</vendor>",
            "          <capability type='phys_function'>",
            "             <address domain='0x0000' bus='0x04' slot='0x00' function='0x3'/>",
            "          </capability>",
            "          <capability type='virt_functions'>",
            "          </capability>",
            "        </capability>",
            "    </device>\"\"\",",
            "    \"pci_0000_04_11_7\": \"\"\"",
            "      <device>",
            "         <name>pci_0000_04_11_7</name>",
            "         <parent>pci_0000_00_01_1</parent>",
            "         <driver>",
            "         <name>igbvf</name>",
            "         </driver>",
            "         <capability type='pci'>",
            "          <domain>0</domain>",
            "          <bus>4</bus>",
            "          <slot>17</slot>",
            "          <function>7</function>",
            "          <product id='0x1520'>I350 Ethernet Controller Virtual Function",
            "            </product>",
            "          <vendor id='0x8086'>Intel Corporation</vendor>",
            "          <numa node='0'/>",
            "          <capability type='phys_function'>",
            "             <address domain='0x0000' bus='0x04' slot='0x00' function='0x3'/>",
            "          </capability>",
            "          <capability type='virt_functions'>",
            "          </capability>",
            "        </capability>",
            "    </device>\"\"\",",
            "    \"pci_0000_04_00_1\": \"\"\"",
            "    <device>",
            "      <name>pci_0000_04_00_1</name>",
            "      <path>/sys/devices/pci0000:00/0000:00:02.0/0000:04:00.1</path>",
            "      <parent>pci_0000_00_02_0</parent>",
            "      <driver>",
            "        <name>mlx5_core</name>",
            "      </driver>",
            "      <capability type='pci'>",
            "        <domain>0</domain>",
            "        <bus>4</bus>",
            "        <slot>0</slot>",
            "        <function>1</function>",
            "        <product id='0x1013'>MT27700 Family [ConnectX-4]</product>",
            "        <vendor id='0x15b3'>Mellanox Technologies</vendor>",
            "        <iommuGroup number='15'>",
            "          <address domain='0x0000' bus='0x03' slot='0x00' function='0x0'/>",
            "          <address domain='0x0000' bus='0x03' slot='0x00' function='0x1'/>",
            "        </iommuGroup>",
            "        <numa node='0'/>",
            "        <pci-express>",
            "          <link validity='cap' port='0' speed='8' width='16'/>",
            "          <link validity='sta' speed='8' width='16'/>",
            "        </pci-express>",
            "      </capability>",
            "    </device>\"\"\",",
            "    # libvirt  >= 1.3.0 nodedev-dumpxml",
            "    \"pci_0000_03_00_0\": \"\"\"",
            "    <device>",
            "        <name>pci_0000_03_00_0</name>",
            "        <path>/sys/devices/pci0000:00/0000:00:02.0/0000:03:00.0</path>",
            "        <parent>pci_0000_00_02_0</parent>",
            "        <driver>",
            "        <name>mlx5_core</name>",
            "        </driver>",
            "        <capability type='pci'>",
            "        <domain>0</domain>",
            "        <bus>3</bus>",
            "        <slot>0</slot>",
            "        <function>0</function>",
            "        <product id='0x1013'>MT27700 Family [ConnectX-4]</product>",
            "        <vendor id='0x15b3'>Mellanox Technologies</vendor>",
            "        <capability type='virt_functions' maxCount='16'>",
            "          <address domain='0x0000' bus='0x03' slot='0x00' function='0x2'/>",
            "          <address domain='0x0000' bus='0x03' slot='0x00' function='0x3'/>",
            "          <address domain='0x0000' bus='0x03' slot='0x00' function='0x4'/>",
            "          <address domain='0x0000' bus='0x03' slot='0x00' function='0x5'/>",
            "        </capability>",
            "        <iommuGroup number='15'>",
            "          <address domain='0x0000' bus='0x03' slot='0x00' function='0x0'/>",
            "          <address domain='0x0000' bus='0x03' slot='0x00' function='0x1'/>",
            "        </iommuGroup>",
            "        <numa node='0'/>",
            "        <pci-express>",
            "          <link validity='cap' port='0' speed='8' width='16'/>",
            "          <link validity='sta' speed='8' width='16'/>",
            "        </pci-express>",
            "      </capability>",
            "    </device>\"\"\",",
            "    \"pci_0000_03_00_1\": \"\"\"",
            "    <device>",
            "      <name>pci_0000_03_00_1</name>",
            "      <path>/sys/devices/pci0000:00/0000:00:02.0/0000:03:00.1</path>",
            "      <parent>pci_0000_00_02_0</parent>",
            "      <driver>",
            "        <name>mlx5_core</name>",
            "      </driver>",
            "      <capability type='pci'>",
            "        <domain>0</domain>",
            "        <bus>3</bus>",
            "        <slot>0</slot>",
            "        <function>1</function>",
            "        <product id='0x1013'>MT27700 Family [ConnectX-4]</product>",
            "        <vendor id='0x15b3'>Mellanox Technologies</vendor>",
            "        <capability type='virt_functions' maxCount='16'/>",
            "        <iommuGroup number='15'>",
            "          <address domain='0x0000' bus='0x03' slot='0x00' function='0x0'/>",
            "          <address domain='0x0000' bus='0x03' slot='0x00' function='0x1'/>",
            "        </iommuGroup>",
            "        <numa node='0'/>",
            "        <pci-express>",
            "          <link validity='cap' port='0' speed='8' width='16'/>",
            "          <link validity='sta' speed='8' width='16'/>",
            "        </pci-express>",
            "      </capability>",
            "    </device>\"\"\",",
            "    }",
            "",
            "_fake_cpu_info = {",
            "    \"arch\": \"test_arch\",",
            "    \"model\": \"test_model\",",
            "    \"vendor\": \"test_vendor\",",
            "    \"topology\": {",
            "        \"sockets\": 1,",
            "        \"cores\": 8,",
            "        \"threads\": 16",
            "    },",
            "    \"features\": [\"feature1\", \"feature2\"]",
            "}",
            "",
            "",
            "def _concurrency(signal, wait, done, target, is_block_dev=False):",
            "    signal.send()",
            "    wait.wait()",
            "    done.send()",
            "",
            "",
            "class FakeVirtDomain(object):",
            "",
            "    def __init__(self, fake_xml=None, uuidstr=None, id=None, name=None):",
            "        if uuidstr is None:",
            "            uuidstr = str(uuid.uuid4())",
            "        self.uuidstr = uuidstr",
            "        self.id = id",
            "        self.domname = name",
            "        self._info = [power_state.RUNNING, 2048 * units.Mi, 1234 * units.Mi,",
            "                     None, None]",
            "        if fake_xml:",
            "            self._fake_dom_xml = fake_xml",
            "        else:",
            "            self._fake_dom_xml = \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                        </disk>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\"",
            "",
            "    def name(self):",
            "        if self.domname is None:",
            "            return \"fake-domain %s\" % self",
            "        else:",
            "            return self.domname",
            "",
            "    def ID(self):",
            "        return self.id",
            "",
            "    def info(self):",
            "        return self._info",
            "",
            "    def create(self):",
            "        pass",
            "",
            "    def managedSave(self, *args):",
            "        pass",
            "",
            "    def createWithFlags(self, launch_flags):",
            "        pass",
            "",
            "    def XMLDesc(self, flags):",
            "        return self._fake_dom_xml",
            "",
            "    def UUIDString(self):",
            "        return self.uuidstr",
            "",
            "    def attachDeviceFlags(self, xml, flags):",
            "        pass",
            "",
            "    def attachDevice(self, xml):",
            "        pass",
            "",
            "    def detachDeviceFlags(self, xml, flags):",
            "        pass",
            "",
            "    def snapshotCreateXML(self, xml, flags):",
            "        pass",
            "",
            "    def blockCommit(self, disk, base, top, bandwidth=0, flags=0):",
            "        pass",
            "",
            "    def blockRebase(self, disk, base, bandwidth=0, flags=0):",
            "        pass",
            "",
            "    def blockJobInfo(self, path, flags):",
            "        pass",
            "",
            "    def resume(self):",
            "        pass",
            "",
            "    def destroy(self):",
            "        pass",
            "",
            "    def fsFreeze(self, disks=None, flags=0):",
            "        pass",
            "",
            "    def fsThaw(self, disks=None, flags=0):",
            "        pass",
            "",
            "    def isActive(self):",
            "        return True",
            "",
            "",
            "class CacheConcurrencyTestCase(test.NoDBTestCase):",
            "    def setUp(self):",
            "        super(CacheConcurrencyTestCase, self).setUp()",
            "",
            "        self.flags(instances_path=self.useFixture(fixtures.TempDir()).path)",
            "",
            "        # utils.synchronized() will create the lock_path for us if it",
            "        # doesn't already exist. It will also delete it when it's done,",
            "        # which can cause race conditions with the multiple threads we",
            "        # use for tests. So, create the path here so utils.synchronized()",
            "        # won't delete it out from under one of the threads.",
            "        self.lock_path = os.path.join(CONF.instances_path, 'locks')",
            "        fileutils.ensure_tree(self.lock_path)",
            "",
            "        def fake_exists(fname):",
            "            basedir = os.path.join(CONF.instances_path,",
            "                                   CONF.image_cache_subdirectory_name)",
            "            if fname == basedir or fname == self.lock_path:",
            "                return True",
            "            return False",
            "",
            "        def fake_execute(*args, **kwargs):",
            "            pass",
            "",
            "        def fake_extend(image, size, use_cow=False):",
            "            pass",
            "",
            "        self.stub_out('os.path.exists', fake_exists)",
            "        self.stubs.Set(utils, 'execute', fake_execute)",
            "        self.stubs.Set(imagebackend.disk, 'extend', fake_extend)",
            "        self.useFixture(fixtures.MonkeyPatch(",
            "            'nova.virt.libvirt.imagebackend.libvirt_utils',",
            "            fake_libvirt_utils))",
            "",
            "    def _fake_instance(self, uuid):",
            "        return objects.Instance(id=1, uuid=uuid)",
            "",
            "    def test_same_fname_concurrency(self):",
            "        # Ensures that the same fname cache runs at a sequentially.",
            "        uuid = uuidutils.generate_uuid()",
            "",
            "        backend = imagebackend.Backend(False)",
            "        wait1 = eventlet.event.Event()",
            "        done1 = eventlet.event.Event()",
            "        sig1 = eventlet.event.Event()",
            "        thr1 = eventlet.spawn(backend.image(self._fake_instance(uuid),",
            "                                            'name').cache,",
            "                _concurrency, 'fname', None,",
            "                signal=sig1, wait=wait1, done=done1)",
            "        eventlet.sleep(0)",
            "        # Thread 1 should run before thread 2.",
            "        sig1.wait()",
            "",
            "        wait2 = eventlet.event.Event()",
            "        done2 = eventlet.event.Event()",
            "        sig2 = eventlet.event.Event()",
            "        thr2 = eventlet.spawn(backend.image(self._fake_instance(uuid),",
            "                                            'name').cache,",
            "                _concurrency, 'fname', None,",
            "                signal=sig2, wait=wait2, done=done2)",
            "",
            "        wait2.send()",
            "        eventlet.sleep(0)",
            "        try:",
            "            self.assertFalse(done2.ready())",
            "        finally:",
            "            wait1.send()",
            "        done1.wait()",
            "        eventlet.sleep(0)",
            "        self.assertTrue(done2.ready())",
            "        # Wait on greenthreads to assert they didn't raise exceptions",
            "        # during execution",
            "        thr1.wait()",
            "        thr2.wait()",
            "",
            "    def test_different_fname_concurrency(self):",
            "        # Ensures that two different fname caches are concurrent.",
            "        uuid = uuidutils.generate_uuid()",
            "",
            "        backend = imagebackend.Backend(False)",
            "        wait1 = eventlet.event.Event()",
            "        done1 = eventlet.event.Event()",
            "        sig1 = eventlet.event.Event()",
            "        thr1 = eventlet.spawn(backend.image(self._fake_instance(uuid),",
            "                                            'name').cache,",
            "                _concurrency, 'fname2', None,",
            "                signal=sig1, wait=wait1, done=done1)",
            "        eventlet.sleep(0)",
            "        # Thread 1 should run before thread 2.",
            "        sig1.wait()",
            "",
            "        wait2 = eventlet.event.Event()",
            "        done2 = eventlet.event.Event()",
            "        sig2 = eventlet.event.Event()",
            "        thr2 = eventlet.spawn(backend.image(self._fake_instance(uuid),",
            "                                            'name').cache,",
            "                _concurrency, 'fname1', None,",
            "                signal=sig2, wait=wait2, done=done2)",
            "        eventlet.sleep(0)",
            "        # Wait for thread 2 to start.",
            "        sig2.wait()",
            "",
            "        wait2.send()",
            "        tries = 0",
            "        while not done2.ready() and tries < 10:",
            "            eventlet.sleep(0)",
            "            tries += 1",
            "        try:",
            "            self.assertTrue(done2.ready())",
            "        finally:",
            "            wait1.send()",
            "            eventlet.sleep(0)",
            "        # Wait on greenthreads to assert they didn't raise exceptions",
            "        # during execution",
            "        thr1.wait()",
            "        thr2.wait()",
            "",
            "",
            "class FakeVolumeDriver(object):",
            "    def __init__(self, *args, **kwargs):",
            "        pass",
            "",
            "    def attach_volume(self, *args):",
            "        pass",
            "",
            "    def detach_volume(self, *args):",
            "        pass",
            "",
            "    def get_xml(self, *args):",
            "        return \"\"",
            "",
            "    def get_config(self, *args):",
            "        \"\"\"Connect the volume to a fake device.\"\"\"",
            "        conf = vconfig.LibvirtConfigGuestDisk()",
            "        conf.source_type = \"network\"",
            "        conf.source_protocol = \"fake\"",
            "        conf.source_name = \"fake\"",
            "        conf.target_dev = \"fake\"",
            "        conf.target_bus = \"fake\"",
            "        return conf",
            "",
            "    def connect_volume(self, *args):",
            "        \"\"\"Connect the volume to a fake device.\"\"\"",
            "        pass",
            "",
            "",
            "class FakeConfigGuestDisk(object):",
            "    def __init__(self, *args, **kwargs):",
            "        self.source_type = None",
            "        self.driver_cache = None",
            "",
            "",
            "class FakeConfigGuest(object):",
            "    def __init__(self, *args, **kwargs):",
            "        self.driver_cache = None",
            "",
            "",
            "class FakeNodeDevice(object):",
            "    def __init__(self, fakexml):",
            "        self.xml = fakexml",
            "",
            "    def XMLDesc(self, flags):",
            "        return self.xml",
            "",
            "",
            "def _create_test_instance():",
            "    flavor = objects.Flavor(memory_mb=2048,",
            "                            swap=0,",
            "                            vcpu_weight=None,",
            "                            root_gb=1,",
            "                            id=2,",
            "                            name=u'm1.small',",
            "                            ephemeral_gb=0,",
            "                            rxtx_factor=1.0,",
            "                            flavorid=u'1',",
            "                            vcpus=1,",
            "                            extra_specs={})",
            "    return {",
            "        'id': 1,",
            "        'uuid': '32dfcb37-5af1-552b-357c-be8c3aa38310',",
            "        'memory_kb': '1024000',",
            "        'basepath': '/some/path',",
            "        'bridge_name': 'br100',",
            "        'display_name': \"Acme webserver\",",
            "        'vcpus': 2,",
            "        'project_id': 'fake',",
            "        'bridge': 'br101',",
            "        'image_ref': '155d900f-4e14-4e4c-a73d-069cbf4541e6',",
            "        'root_gb': 10,",
            "        'ephemeral_gb': 20,",
            "        'instance_type_id': '5',  # m1.small",
            "        'extra_specs': {},",
            "        'system_metadata': {",
            "            'image_disk_format': 'raw',",
            "        },",
            "        'flavor': flavor,",
            "        'new_flavor': None,",
            "        'old_flavor': None,",
            "        'pci_devices': objects.PciDeviceList(),",
            "        'numa_topology': None,",
            "        'config_drive': None,",
            "        'vm_mode': None,",
            "        'kernel_id': None,",
            "        'ramdisk_id': None,",
            "        'os_type': 'linux',",
            "        'user_id': '838a72b0-0d54-4827-8fd6-fb1227633ceb',",
            "        'ephemeral_key_uuid': None,",
            "        'vcpu_model': None,",
            "        'host': 'fake-host',",
            "        'task_state': None,",
            "    }",
            "",
            "",
            "class LibvirtConnTestCase(test.NoDBTestCase):",
            "",
            "    REQUIRES_LOCKING = True",
            "",
            "    _EPHEMERAL_20_DEFAULT = ('ephemeral_20_%s' %",
            "                             utils.get_hash_str(disk._DEFAULT_FILE_SYSTEM)[:7])",
            "",
            "    def setUp(self):",
            "        super(LibvirtConnTestCase, self).setUp()",
            "        self.flags(fake_call=True)",
            "        self.user_id = 'fake'",
            "        self.project_id = 'fake'",
            "        self.context = context.get_admin_context()",
            "        temp_dir = self.useFixture(fixtures.TempDir()).path",
            "        self.flags(instances_path=temp_dir)",
            "        self.flags(snapshots_directory=temp_dir, group='libvirt')",
            "        self.useFixture(fixtures.MonkeyPatch(",
            "            'nova.virt.libvirt.driver.libvirt_utils',",
            "            fake_libvirt_utils))",
            "",
            "        self.flags(sysinfo_serial=\"hardware\", group=\"libvirt\")",
            "",
            "        self.useFixture(fixtures.MonkeyPatch(",
            "            'nova.virt.libvirt.imagebackend.libvirt_utils',",
            "            fake_libvirt_utils))",
            "",
            "        def fake_extend(image, size, use_cow=False):",
            "            pass",
            "",
            "        self.stubs.Set(libvirt_driver.disk, 'extend', fake_extend)",
            "",
            "        self.stubs.Set(imagebackend.Image, 'resolve_driver_format',",
            "                       imagebackend.Image._get_driver_format)",
            "",
            "        self.useFixture(fakelibvirt.FakeLibvirtFixture())",
            "        self.test_instance = _create_test_instance()",
            "        self.test_image_meta = {",
            "            \"disk_format\": \"raw\",",
            "        }",
            "        self.image_service = nova.tests.unit.image.fake.stub_out_image_service(",
            "                self)",
            "        self.device_xml_tmpl = \"\"\"",
            "        <domain type='kvm'>",
            "          <devices>",
            "            <disk type='block' device='disk'>",
            "              <driver name='qemu' type='raw' cache='none'/>",
            "              <source dev='{device_path}'/>",
            "              <target bus='virtio' dev='vdb'/>",
            "              <serial>58a84f6d-3f0c-4e19-a0af-eb657b790657</serial>",
            "              <address type='pci' domain='0x0' bus='0x0' slot='0x04' \\",
            "              function='0x0'/>",
            "            </disk>",
            "          </devices>",
            "        </domain>",
            "        \"\"\"",
            "",
            "    def relpath(self, path):",
            "        return os.path.relpath(path, CONF.instances_path)",
            "",
            "    def tearDown(self):",
            "        nova.tests.unit.image.fake.FakeImageService_reset()",
            "        super(LibvirtConnTestCase, self).tearDown()",
            "",
            "    def test_driver_capabilities(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertTrue(drvr.capabilities['has_imagecache'],",
            "                        'Driver capabilities for \\'has_imagecache\\' '",
            "                        'is invalid')",
            "        self.assertTrue(drvr.capabilities['supports_recreate'],",
            "                        'Driver capabilities for \\'supports_recreate\\' '",
            "                        'is invalid')",
            "        self.assertFalse(drvr.capabilities['supports_migrate_to_same_host'],",
            "                         'Driver capabilities for '",
            "                         '\\'supports_migrate_to_same_host\\' is invalid')",
            "",
            "    def create_fake_libvirt_mock(self, **kwargs):",
            "        \"\"\"Defining mocks for LibvirtDriver(libvirt is not used).\"\"\"",
            "",
            "        # A fake libvirt.virConnect",
            "        class FakeLibvirtDriver(object):",
            "            def defineXML(self, xml):",
            "                return FakeVirtDomain()",
            "",
            "        # Creating mocks",
            "        volume_driver = ['iscsi=nova.tests.unit.virt.libvirt.test_driver'",
            "                         '.FakeVolumeDriver']",
            "        fake = FakeLibvirtDriver()",
            "        # Customizing above fake if necessary",
            "        for key, val in kwargs.items():",
            "            fake.__setattr__(key, val)",
            "",
            "        self.stubs.Set(libvirt_driver.LibvirtDriver, '_conn', fake)",
            "        self.stubs.Set(libvirt_driver.LibvirtDriver, '_get_volume_drivers',",
            "            lambda x: volume_driver)",
            "        self.stubs.Set(host.Host, 'get_connection', lambda x: fake)",
            "",
            "    def fake_lookup(self, instance_name):",
            "        return FakeVirtDomain()",
            "",
            "    def fake_execute(self, *args, **kwargs):",
            "        open(args[-1], \"a\").close()",
            "",
            "    def _create_service(self, **kwargs):",
            "        service_ref = {'host': kwargs.get('host', 'dummy'),",
            "                       'disabled': kwargs.get('disabled', False),",
            "                       'binary': 'nova-compute',",
            "                       'topic': 'compute',",
            "                       'report_count': 0}",
            "",
            "        return objects.Service(**service_ref)",
            "",
            "    def _get_pause_flag(self, drvr, network_info, power_on=True,",
            "                          vifs_already_plugged=False):",
            "        timeout = CONF.vif_plugging_timeout",
            "",
            "        events = []",
            "        if (drvr._conn_supports_start_paused and",
            "            utils.is_neutron() and",
            "            not vifs_already_plugged and",
            "            power_on and timeout):",
            "            events = drvr._get_neutron_events(network_info)",
            "",
            "        return bool(events)",
            "",
            "    def test_public_api_signatures(self):",
            "        baseinst = driver.ComputeDriver(None)",
            "        inst = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertPublicAPISignatures(baseinst, inst)",
            "",
            "    def test_legacy_block_device_info(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertFalse(drvr.need_legacy_block_device_info)",
            "",
            "    @mock.patch.object(host.Host, \"has_min_version\")",
            "    def test_min_version_start_ok(self, mock_version):",
            "        mock_version.return_value = True",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        drvr.init_host(\"dummyhost\")",
            "",
            "    @mock.patch.object(host.Host, \"has_min_version\")",
            "    def test_min_version_start_abort(self, mock_version):",
            "        mock_version.return_value = False",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertRaises(exception.NovaException,",
            "                          drvr.init_host,",
            "                          \"dummyhost\")",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                            libvirt_driver.NEXT_MIN_LIBVIRT_VERSION) - 1)",
            "    @mock.patch.object(libvirt_driver.LOG, 'warning')",
            "    def test_next_min_version_deprecation_warning(self, mock_warning,",
            "                                                  mock_get_libversion):",
            "        # Skip test if there's no currently planned new min version",
            "        if (versionutils.convert_version_to_int(",
            "                libvirt_driver.NEXT_MIN_LIBVIRT_VERSION) ==",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_VERSION)):",
            "            self.skipTest(\"NEXT_MIN_LIBVIRT_VERSION == MIN_LIBVIRT_VERSION\")",
            "",
            "        # Test that a warning is logged if the libvirt version is less than",
            "        # the next required minimum version.",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        drvr.init_host(\"dummyhost\")",
            "        # assert that the next min version is in a warning message",
            "        expected_arg = {'version': versionutils.convert_version_to_str(",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.NEXT_MIN_LIBVIRT_VERSION))}",
            "        version_arg_found = False",
            "        for call in mock_warning.call_args_list:",
            "            if call[0][1] == expected_arg:",
            "                version_arg_found = True",
            "                break",
            "        self.assertTrue(version_arg_found)",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                            libvirt_driver.NEXT_MIN_LIBVIRT_VERSION))",
            "    @mock.patch.object(libvirt_driver.LOG, 'warning')",
            "    def test_next_min_version_ok(self, mock_warning, mock_get_libversion):",
            "        # Skip test if there's no currently planned new min version",
            "",
            "        if (versionutils.convert_version_to_int(",
            "                libvirt_driver.NEXT_MIN_LIBVIRT_VERSION) ==",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_VERSION)):",
            "            self.skipTest(\"NEXT_MIN_LIBVIRT_VERSION == MIN_LIBVIRT_VERSION\")",
            "",
            "        # Test that a warning is not logged if the libvirt version is greater",
            "        # than or equal to NEXT_MIN_LIBVIRT_VERSION.",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        drvr.init_host(\"dummyhost\")",
            "        # assert that the next min version is in a warning message",
            "        expected_arg = {'version': versionutils.convert_version_to_str(",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.NEXT_MIN_LIBVIRT_VERSION))}",
            "        version_arg_found = False",
            "        for call in mock_warning.call_args_list:",
            "            if call[0][1] == expected_arg:",
            "                version_arg_found = True",
            "                break",
            "        self.assertFalse(version_arg_found)",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_LIBVIRT_OTHER_ARCH.get(",
            "                               arch.PPC64)) - 1)",
            "    @mock.patch.object(fakelibvirt.Connection, 'getVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_QEMU_OTHER_ARCH.get(",
            "                               arch.PPC64)))",
            "    @mock.patch.object(arch, \"from_host\", return_value=arch.PPC64)",
            "    def test_min_version_ppc_old_libvirt(self, mock_libv, mock_qemu,",
            "                                         mock_arch):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertRaises(exception.NovaException,",
            "                          drvr.init_host,",
            "                          \"dummyhost\")",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_LIBVIRT_OTHER_ARCH.get(",
            "                               arch.PPC64)))",
            "    @mock.patch.object(fakelibvirt.Connection, 'getVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_QEMU_OTHER_ARCH.get(",
            "                               arch.PPC64)) - 1)",
            "    @mock.patch.object(arch, \"from_host\", return_value=arch.PPC64)",
            "    def test_min_version_ppc_old_qemu(self, mock_libv, mock_qemu,",
            "                                      mock_arch):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertRaises(exception.NovaException,",
            "                          drvr.init_host,",
            "                          \"dummyhost\")",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_LIBVIRT_OTHER_ARCH.get(",
            "                               arch.PPC64)))",
            "    @mock.patch.object(fakelibvirt.Connection, 'getVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_QEMU_OTHER_ARCH.get(",
            "                               arch.PPC64)))",
            "    @mock.patch.object(arch, \"from_host\", return_value=arch.PPC64)",
            "    def test_min_version_ppc_ok(self, mock_libv, mock_qemu, mock_arch):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        drvr.init_host(\"dummyhost\")",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_LIBVIRT_OTHER_ARCH.get(",
            "                               arch.S390X)) - 1)",
            "    @mock.patch.object(fakelibvirt.Connection, 'getVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_QEMU_OTHER_ARCH.get(",
            "                               arch.S390X)))",
            "    @mock.patch.object(arch, \"from_host\", return_value=arch.S390X)",
            "    def test_min_version_s390_old_libvirt(self, mock_libv, mock_qemu,",
            "                                          mock_arch):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertRaises(exception.NovaException,",
            "                          drvr.init_host,",
            "                          \"dummyhost\")",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_LIBVIRT_OTHER_ARCH.get(",
            "                               arch.S390X)))",
            "    @mock.patch.object(fakelibvirt.Connection, 'getVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_QEMU_OTHER_ARCH.get(",
            "                               arch.S390X)) - 1)",
            "    @mock.patch.object(arch, \"from_host\", return_value=arch.S390X)",
            "    def test_min_version_s390_old_qemu(self, mock_libv, mock_qemu,",
            "                                       mock_arch):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertRaises(exception.NovaException,",
            "                          drvr.init_host,",
            "                          \"dummyhost\")",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_LIBVIRT_OTHER_ARCH.get(",
            "                               arch.S390X)))",
            "    @mock.patch.object(fakelibvirt.Connection, 'getVersion',",
            "                       return_value=versionutils.convert_version_to_int(",
            "                           libvirt_driver.MIN_QEMU_OTHER_ARCH.get(",
            "                               arch.S390X)))",
            "    @mock.patch.object(arch, \"from_host\", return_value=arch.S390X)",
            "    def test_min_version_s390_ok(self, mock_libv, mock_qemu, mock_arch):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        drvr.init_host(\"dummyhost\")",
            "",
            "    def _do_test_parse_migration_flags(self, lm_config=None, lm_expected=None,",
            "                                       bm_config=None, bm_expected=None):",
            "        if lm_config is not None:",
            "            self.flags(live_migration_flag=lm_config, group='libvirt')",
            "        if bm_config is not None:",
            "            self.flags(block_migration_flag=bm_config, group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        drvr._parse_migration_flags()",
            "",
            "        if lm_expected is not None:",
            "            self.assertEqual(lm_expected, drvr._live_migration_flags)",
            "        if bm_expected is not None:",
            "            self.assertEqual(bm_expected, drvr._block_migration_flags)",
            "",
            "    def test_parse_live_migration_flags_default(self):",
            "        self._do_test_parse_migration_flags(",
            "            lm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, VIR_MIGRATE_TUNNELLED'),",
            "            lm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED))",
            "",
            "    def test_parse_live_migration_flags(self):",
            "        self._do_test_parse_migration_flags(",
            "            lm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE'),",
            "            lm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE))",
            "",
            "    def test_parse_block_migration_flags_default(self):",
            "        self._do_test_parse_migration_flags(",
            "            bm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, VIR_MIGRATE_TUNNELLED, '",
            "                       'VIR_MIGRATE_NON_SHARED_INC'),",
            "            bm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_NON_SHARED_INC))",
            "",
            "    def test_parse_block_migration_flags(self):",
            "        self._do_test_parse_migration_flags(",
            "            bm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, VIR_MIGRATE_NON_SHARED_INC'),",
            "            bm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_NON_SHARED_INC))",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG')",
            "    def test_parse_live_migration_flag_with_invalid_flag(self, mock_log):",
            "        self._do_test_parse_migration_flags(",
            "            lm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, VIR_MIGRATE_TUNNELLED, '",
            "                       'VIR_MIGRATE_FOO_BAR'),",
            "            lm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED),",
            "            bm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, VIR_MIGRATE_TUNNELLED, '",
            "                       'VIR_MIGRATE_NON_SHARED_INC, VIR_MIGRATE_FOO_BAR'),",
            "            bm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_NON_SHARED_INC))",
            "",
            "        msg = mock_log.warning.call_args_list[0]",
            "        self.assertIn(\"unknown libvirt live migration flag\", msg[0][0])",
            "        msg = mock_log.warning.call_args_list[1]",
            "        self.assertIn(\"unknown libvirt live migration flag\", msg[0][0])",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG')",
            "    def test_parse_migration_flags_unsafe_block(self, mock_log):",
            "        '''Test if the driver logs a warning if the live_migration_flag",
            "        and/or block_migration_flag config option uses a value which can",
            "        cause potential damage.",
            "        '''",
            "        self._do_test_parse_migration_flags(",
            "            lm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, '",
            "                       'VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, '",
            "                       'VIR_MIGRATE_TUNNELLED, '",
            "                       'VIR_MIGRATE_NON_SHARED_INC'),",
            "            bm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, '",
            "                       'VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, '",
            "                       'VIR_MIGRATE_TUNNELLED'),",
            "            lm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED),",
            "            bm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_NON_SHARED_INC))",
            "",
            "        msg = mock_log.warning.call_args_list[0]",
            "        self.assertIn('Removing the VIR_MIGRATE_NON_SHARED_INC', msg[0][0])",
            "        msg = mock_log.warning.call_args_list[1]",
            "        self.assertIn('Adding the VIR_MIGRATE_NON_SHARED_INC', msg[0][0])",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG')",
            "    def test_parse_migration_flags_p2p_missing(self, mock_log):",
            "        self._do_test_parse_migration_flags(",
            "            lm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, '",
            "                       'VIR_MIGRATE_LIVE, '",
            "                       'VIR_MIGRATE_TUNNELLED'),",
            "            bm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, '",
            "                       'VIR_MIGRATE_LIVE, '",
            "                       'VIR_MIGRATE_TUNNELLED, '",
            "                       'VIR_MIGRATE_NON_SHARED_INC'),",
            "            lm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED),",
            "            bm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_NON_SHARED_INC))",
            "",
            "        msg = mock_log.warning.call_args_list[0]",
            "        self.assertIn('Adding the VIR_MIGRATE_PEER2PEER flag', msg[0][0])",
            "        msg = mock_log.warning.call_args_list[1]",
            "        self.assertIn('Adding the VIR_MIGRATE_PEER2PEER flag', msg[0][0])",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG')",
            "    def test_parse_migration_flags_p2p_xen(self, mock_log):",
            "        self.flags(virt_type='xen', group='libvirt')",
            "",
            "        self._do_test_parse_migration_flags(",
            "            lm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, '",
            "                       'VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, '",
            "                       'VIR_MIGRATE_TUNNELLED'),",
            "            bm_config=('VIR_MIGRATE_UNDEFINE_SOURCE, '",
            "                       'VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, '",
            "                       'VIR_MIGRATE_TUNNELLED, '",
            "                       'VIR_MIGRATE_NON_SHARED_INC'),",
            "            lm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED),",
            "            bm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_NON_SHARED_INC))",
            "",
            "        msg = mock_log.warning.call_args_list[0]",
            "        self.assertIn('Removing the VIR_MIGRATE_PEER2PEER flag', msg[0][0])",
            "        msg = mock_log.warning.call_args_list[1]",
            "        self.assertIn('Removing the VIR_MIGRATE_PEER2PEER flag', msg[0][0])",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG')",
            "    def test_parse_migration_flags_config_mgmt(self, mock_log):",
            "        self._do_test_parse_migration_flags(",
            "            lm_config=('VIR_MIGRATE_PERSIST_DEST, '",
            "                       'VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, '",
            "                       'VIR_MIGRATE_TUNNELLED'),",
            "            bm_config=('VIR_MIGRATE_PERSIST_DEST, '",
            "                       'VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, '",
            "                       'VIR_MIGRATE_TUNNELLED, '",
            "                       'VIR_MIGRATE_NON_SHARED_INC'),",
            "            lm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED),",
            "            bm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_NON_SHARED_INC))",
            "",
            "        msg = mock_log.warning.call_args_list[0]",
            "        self.assertIn('Adding the VIR_MIGRATE_UNDEFINE_SOURCE flag', msg[0][0])",
            "        msg = mock_log.warning.call_args_list[1]",
            "        self.assertIn('Removing the VIR_MIGRATE_PERSIST_DEST flag', msg[0][0])",
            "        msg = mock_log.warning.call_args_list[2]",
            "        self.assertIn('Adding the VIR_MIGRATE_UNDEFINE_SOURCE flag', msg[0][0])",
            "        msg = mock_log.warning.call_args_list[3]",
            "        self.assertIn('Removing the VIR_MIGRATE_PERSIST_DEST flag', msg[0][0])",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG')",
            "    def test_live_migration_tunnelled_true(self, mock_log):",
            "        self.flags(live_migration_tunnelled=True, group='libvirt')",
            "",
            "        self._do_test_parse_migration_flags(",
            "            lm_config=('VIR_MIGRATE_PEER2PEER, VIR_MIGRATE_UNDEFINE_SOURCE, '",
            "                       'VIR_MIGRATE_LIVE'),",
            "            bm_config=('VIR_MIGRATE_PEER2PEER, VIR_MIGRATE_UNDEFINE_SOURCE, '",
            "                       'VIR_MIGRATE_LIVE, VIR_MIGRATE_NON_SHARED_INC'),",
            "            lm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED),",
            "            bm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_NON_SHARED_INC |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_TUNNELLED))",
            "",
            "        msg = mock_log.warning.call_args_list[0]",
            "        self.assertIn('does not contain the VIR_MIGRATE_TUNNELLED', msg[0][0])",
            "        msg = mock_log.warning.call_args_list[1]",
            "        self.assertIn('does not contain the VIR_MIGRATE_TUNNELLED', msg[0][0])",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG')",
            "    def test_live_migration_tunnelled_false(self, mock_log):",
            "        self.flags(live_migration_tunnelled=False, group='libvirt')",
            "",
            "        self._do_test_parse_migration_flags(",
            "            lm_config=('VIR_MIGRATE_PEER2PEER, VIR_MIGRATE_UNDEFINE_SOURCE, '",
            "                       'VIR_MIGRATE_LIVE, VIR_MIGRATE_TUNNELLED'),",
            "            bm_config=('VIR_MIGRATE_PEER2PEER, VIR_MIGRATE_UNDEFINE_SOURCE, '",
            "                       'VIR_MIGRATE_LIVE, VIR_MIGRATE_NON_SHARED_INC, '",
            "                       'VIR_MIGRATE_TUNNELLED'),",
            "            lm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE),",
            "            bm_expected=(libvirt_driver.libvirt.VIR_MIGRATE_LIVE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_PEER2PEER |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_UNDEFINE_SOURCE |",
            "                         libvirt_driver.libvirt.VIR_MIGRATE_NON_SHARED_INC))",
            "",
            "        msg = mock_log.warning.call_args_list[0]",
            "        self.assertIn('contains the VIR_MIGRATE_TUNNELLED flag', msg[0][0])",
            "        msg = mock_log.warning.call_args_list[1]",
            "        self.assertIn('contains the VIR_MIGRATE_TUNNELLED flag', msg[0][0])",
            "",
            "    @mock.patch('nova.utils.get_image_from_system_metadata')",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_guest')",
            "    def test_set_admin_password(self, mock_get_guest, ver, mock_image):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_image.return_value = {\"properties\": {",
            "            \"hw_qemu_guest_agent\": \"yes\"}}",
            "        mock_guest = mock.Mock(spec=libvirt_guest.Guest)",
            "        mock_get_guest.return_value = mock_guest",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        drvr.set_admin_password(instance, \"123\")",
            "",
            "        mock_guest.set_user_password.assert_called_once_with(\"root\", \"123\")",
            "",
            "    @mock.patch('nova.utils.get_image_from_system_metadata')",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_guest')",
            "    def test_set_admin_password_windows(self, mock_get_guest, ver, mock_image):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        instance = objects.Instance(**self.test_instance)",
            "        instance.os_type = \"windows\"",
            "        mock_image.return_value = {\"properties\": {",
            "            \"hw_qemu_guest_agent\": \"yes\"}}",
            "        mock_guest = mock.Mock(spec=libvirt_guest.Guest)",
            "        mock_get_guest.return_value = mock_guest",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        drvr.set_admin_password(instance, \"123\")",
            "",
            "        mock_guest.set_user_password.assert_called_once_with(",
            "            \"Administrator\", \"123\")",
            "",
            "    @mock.patch('nova.utils.get_image_from_system_metadata')",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_guest')",
            "    def test_set_admin_password_image(self, mock_get_guest, ver, mock_image):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_image.return_value = {\"properties\": {",
            "            \"hw_qemu_guest_agent\": \"yes\",",
            "            \"os_admin_user\": \"foo\"",
            "        }}",
            "        mock_guest = mock.Mock(spec=libvirt_guest.Guest)",
            "        mock_get_guest.return_value = mock_guest",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        drvr.set_admin_password(instance, \"123\")",
            "",
            "        mock_guest.set_user_password.assert_called_once_with(\"foo\", \"123\")",
            "",
            "    @mock.patch('nova.utils.get_image_from_system_metadata')",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=False)",
            "    def test_set_admin_password_bad_version(self, mock_svc, mock_image):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_image.return_value = {\"properties\": {",
            "            \"hw_qemu_guest_agent\": \"yes\"}}",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertRaises(exception.SetAdminPasswdNotSupported,",
            "                          drvr.set_admin_password, instance, \"123\")",
            "",
            "    @mock.patch('nova.utils.get_image_from_system_metadata')",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    def test_set_admin_password_bad_hyp(self, mock_svc, mock_image):",
            "        self.flags(virt_type='foo', group='libvirt')",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_image.return_value = {\"properties\": {",
            "            \"hw_qemu_guest_agent\": \"yes\"}}",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertRaises(exception.SetAdminPasswdNotSupported,",
            "                          drvr.set_admin_password, instance, \"123\")",
            "",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    def test_set_admin_password_guest_agent_not_running(self, mock_svc):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        instance = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertRaises(exception.QemuGuestAgentNotEnabled,",
            "                          drvr.set_admin_password, instance, \"123\")",
            "",
            "    @mock.patch('nova.utils.get_image_from_system_metadata')",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_guest')",
            "    def test_set_admin_password_error(self, mock_get_guest, ver, mock_image):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_image.return_value = {\"properties\": {",
            "            \"hw_qemu_guest_agent\": \"yes\"}}",
            "        mock_guest = mock.Mock(spec=libvirt_guest.Guest)",
            "        mock_guest.set_user_password.side_effect = (",
            "            fakelibvirt.libvirtError(\"error\"))",
            "        mock_get_guest.return_value = mock_guest",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertRaises(exception.NovaException,",
            "                          drvr.set_admin_password, instance, \"123\")",
            "",
            "    @mock.patch.object(objects.Service, 'get_by_compute_host')",
            "    def test_set_host_enabled_with_disable(self, mock_svc):",
            "        # Tests disabling an enabled host.",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        svc = self._create_service(host='fake-mini')",
            "        mock_svc.return_value = svc",
            "        drvr._set_host_enabled(False)",
            "        self.assertTrue(svc.disabled)",
            "",
            "    @mock.patch.object(objects.Service, 'get_by_compute_host')",
            "    def test_set_host_enabled_with_enable(self, mock_svc):",
            "        # Tests enabling a disabled host.",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        svc = self._create_service(disabled=True, host='fake-mini')",
            "        mock_svc.return_value = svc",
            "        drvr._set_host_enabled(True)",
            "        self.assertTrue(svc.disabled)",
            "",
            "    @mock.patch.object(objects.Service, 'get_by_compute_host')",
            "    def test_set_host_enabled_with_enable_state_enabled(self, mock_svc):",
            "        # Tests enabling an enabled host.",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        svc = self._create_service(disabled=False, host='fake-mini')",
            "        mock_svc.return_value = svc",
            "        drvr._set_host_enabled(True)",
            "        self.assertFalse(svc.disabled)",
            "",
            "    @mock.patch.object(objects.Service, 'get_by_compute_host')",
            "    def test_set_host_enabled_with_disable_state_disabled(self, mock_svc):",
            "        # Tests disabling a disabled host.",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        svc = self._create_service(disabled=True, host='fake-mini')",
            "        mock_svc.return_value = svc",
            "        drvr._set_host_enabled(False)",
            "        self.assertTrue(svc.disabled)",
            "",
            "    def test_set_host_enabled_swallows_exceptions(self):",
            "        # Tests that set_host_enabled will swallow exceptions coming from the",
            "        # db_api code so they don't break anything calling it, e.g. the",
            "        # _get_new_connection method.",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        with mock.patch.object(db, 'service_get_by_compute_host') as db_mock:",
            "            # Make db.service_get_by_compute_host raise NovaException; this",
            "            # is more robust than just raising ComputeHostNotFound.",
            "            db_mock.side_effect = exception.NovaException",
            "            drvr._set_host_enabled(False)",
            "",
            "    @mock.patch.object(fakelibvirt.virConnect, \"nodeDeviceLookupByName\")",
            "    def test_prepare_pci_device(self, mock_lookup):",
            "",
            "        pci_devices = [dict(hypervisor_name='xxx')]",
            "",
            "        self.flags(virt_type='xen', group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        conn = drvr._host.get_connection()",
            "",
            "        mock_lookup.side_effect = lambda x: fakelibvirt.NodeDevice(conn)",
            "        drvr._prepare_pci_devices_for_use(pci_devices)",
            "",
            "    @mock.patch.object(fakelibvirt.virConnect, \"nodeDeviceLookupByName\")",
            "    @mock.patch.object(fakelibvirt.virNodeDevice, \"dettach\")",
            "    def test_prepare_pci_device_exception(self, mock_detach, mock_lookup):",
            "",
            "        pci_devices = [dict(hypervisor_name='xxx',",
            "                            id='id1',",
            "                            instance_uuid='uuid')]",
            "",
            "        self.flags(virt_type='xen', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        conn = drvr._host.get_connection()",
            "",
            "        mock_lookup.side_effect = lambda x: fakelibvirt.NodeDevice(conn)",
            "        mock_detach.side_effect = fakelibvirt.libvirtError(\"xxxx\")",
            "",
            "        self.assertRaises(exception.PciDevicePrepareFailed,",
            "                          drvr._prepare_pci_devices_for_use, pci_devices)",
            "",
            "    def test_detach_pci_devices_exception(self):",
            "",
            "        pci_devices = [dict(hypervisor_name='xxx',",
            "                            id='id1',",
            "                            instance_uuid='uuid')]",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.mox.StubOutWithMock(host.Host,",
            "                                 'has_min_version')",
            "        host.Host.has_min_version = lambda x, y: False",
            "",
            "        self.assertRaises(exception.PciDeviceDetachFailed,",
            "                          drvr._detach_pci_devices, None, pci_devices)",
            "",
            "    def test_detach_pci_devices(self):",
            "",
            "        fake_domXML1 =\\",
            "            \"\"\"<domain> <devices>",
            "            <disk type='file' device='disk'>",
            "            <driver name='qemu' type='qcow2' cache='none'/>",
            "            <source file='xxx'/>",
            "            <target dev='vda' bus='virtio'/>",
            "            <alias name='virtio-disk0'/>",
            "            <address type='pci' domain='0x0000' bus='0x00'",
            "            slot='0x04' function='0x0'/>",
            "            </disk>",
            "            <hostdev mode=\"subsystem\" type=\"pci\" managed=\"yes\">",
            "            <source>",
            "            <address function=\"0x1\" slot=\"0x10\" domain=\"0x0000\"",
            "             bus=\"0x04\"/>",
            "            </source>",
            "            </hostdev></devices></domain>\"\"\"",
            "",
            "        pci_devices = [dict(hypervisor_name='xxx',",
            "                            id='id1',",
            "                            instance_uuid='uuid',",
            "                            address=\"0001:04:10:1\")]",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.mox.StubOutWithMock(host.Host,",
            "                                 'has_min_version')",
            "        host.Host.has_min_version = lambda x, y: True",
            "",
            "        self.mox.StubOutWithMock(libvirt_driver.LibvirtDriver,",
            "                                 '_get_guest_pci_device')",
            "",
            "        class FakeDev(object):",
            "            def to_xml(self):",
            "                pass",
            "",
            "        libvirt_driver.LibvirtDriver._get_guest_pci_device =\\",
            "            lambda x, y: FakeDev()",
            "",
            "        class FakeDomain(object):",
            "            def detachDeviceFlags(self, xml, flags):",
            "                pci_devices[0]['hypervisor_name'] = 'marked'",
            "                pass",
            "",
            "            def XMLDesc(self, flags):",
            "                return fake_domXML1",
            "",
            "        guest = libvirt_guest.Guest(FakeDomain())",
            "        drvr._detach_pci_devices(guest, pci_devices)",
            "        self.assertEqual(pci_devices[0]['hypervisor_name'], 'marked')",
            "",
            "    def test_detach_pci_devices_timeout(self):",
            "",
            "        fake_domXML1 =\\",
            "            \"\"\"<domain>",
            "                <devices>",
            "                  <hostdev mode=\"subsystem\" type=\"pci\" managed=\"yes\">",
            "                    <source>",
            "            <address function=\"0x1\" slot=\"0x10\" domain=\"0x0000\" bus=\"0x04\"/>",
            "                    </source>",
            "                  </hostdev>",
            "                </devices>",
            "            </domain>\"\"\"",
            "",
            "        pci_devices = [dict(hypervisor_name='xxx',",
            "                            id='id1',",
            "                            instance_uuid='uuid',",
            "                            address=\"0000:04:10:1\")]",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.mox.StubOutWithMock(host.Host,",
            "                                 'has_min_version')",
            "        host.Host.has_min_version = lambda x, y: True",
            "",
            "        self.mox.StubOutWithMock(libvirt_driver.LibvirtDriver,",
            "                                 '_get_guest_pci_device')",
            "",
            "        class FakeDev(object):",
            "            def to_xml(self):",
            "                pass",
            "",
            "        libvirt_driver.LibvirtDriver._get_guest_pci_device =\\",
            "            lambda x, y: FakeDev()",
            "",
            "        class FakeDomain(object):",
            "            def detachDeviceFlags(self, xml, flags):",
            "                pass",
            "",
            "            def XMLDesc(self, flags):",
            "                return fake_domXML1",
            "",
            "        guest = libvirt_guest.Guest(FakeDomain())",
            "        self.assertRaises(exception.PciDeviceDetachFailed,",
            "                          drvr._detach_pci_devices, guest, pci_devices)",
            "",
            "    @mock.patch.object(connector, 'get_connector_properties')",
            "    def test_get_connector(self, fake_get_connector):",
            "        initiator = 'fake.initiator.iqn'",
            "        ip = 'fakeip'",
            "        host = 'fakehost'",
            "        wwpns = ['100010604b019419']",
            "        wwnns = ['200010604b019419']",
            "        self.flags(my_ip=ip)",
            "        self.flags(host=host)",
            "",
            "        expected = {",
            "            'ip': ip,",
            "            'initiator': initiator,",
            "            'host': host,",
            "            'wwpns': wwpns,",
            "            'wwnns': wwnns",
            "        }",
            "        volume = {",
            "            'id': 'fake'",
            "        }",
            "",
            "        # TODO(walter-boring) add the fake in os-brick",
            "        fake_get_connector.return_value = expected",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        result = drvr.get_volume_connector(volume)",
            "        self.assertThat(expected, matchers.DictMatches(result))",
            "",
            "    @mock.patch.object(connector, 'get_connector_properties')",
            "    def test_get_connector_storage_ip(self, fake_get_connector):",
            "        ip = '100.100.100.100'",
            "        storage_ip = '101.101.101.101'",
            "        self.flags(my_block_storage_ip=storage_ip, my_ip=ip)",
            "        volume = {",
            "            'id': 'fake'",
            "        }",
            "        expected = {",
            "            'ip': storage_ip",
            "        }",
            "        # TODO(walter-boring) add the fake in os-brick",
            "        fake_get_connector.return_value = expected",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        result = drvr.get_volume_connector(volume)",
            "        self.assertEqual(storage_ip, result['ip'])",
            "",
            "    def test_lifecycle_event_registration(self):",
            "        calls = []",
            "",
            "        def fake_registerErrorHandler(*args, **kwargs):",
            "            calls.append('fake_registerErrorHandler')",
            "",
            "        def fake_get_host_capabilities(**args):",
            "            cpu = vconfig.LibvirtConfigGuestCPU()",
            "            cpu.arch = arch.ARMV7",
            "",
            "            caps = vconfig.LibvirtConfigCaps()",
            "            caps.host = vconfig.LibvirtConfigCapsHost()",
            "            caps.host.cpu = cpu",
            "            calls.append('fake_get_host_capabilities')",
            "            return caps",
            "",
            "        @mock.patch.object(fakelibvirt, 'registerErrorHandler',",
            "                           side_effect=fake_registerErrorHandler)",
            "        @mock.patch.object(host.Host, \"get_capabilities\",",
            "                            side_effect=fake_get_host_capabilities)",
            "        def test_init_host(get_host_capabilities, register_error_handler):",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "            drvr.init_host(\"test_host\")",
            "",
            "        test_init_host()",
            "        # NOTE(dkliban): Will fail if get_host_capabilities is called before",
            "        # registerErrorHandler",
            "        self.assertEqual(['fake_registerErrorHandler',",
            "                          'fake_get_host_capabilities'], calls)",
            "",
            "    def test_sanitize_log_to_xml(self):",
            "        # setup fake data",
            "        data = {'auth_password': 'scrubme'}",
            "        bdm = [{'connection_info': {'data': data}}]",
            "        bdi = {'block_device_mapping': bdm}",
            "",
            "        # Tests that the parameters to the _get_guest_xml method",
            "        # are sanitized for passwords when logged.",
            "        def fake_debug(*args, **kwargs):",
            "            if 'auth_password' in args[0]:",
            "                self.assertNotIn('scrubme', args[0])",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        conf = mock.Mock()",
            "        with test.nested(",
            "            mock.patch.object(libvirt_driver.LOG, 'debug',",
            "                              side_effect=fake_debug),",
            "            mock.patch.object(drvr, '_get_guest_config', return_value=conf)",
            "        ) as (",
            "            debug_mock, conf_mock",
            "        ):",
            "            drvr._get_guest_xml(self.context, self.test_instance,",
            "                                network_info={}, disk_info={},",
            "                                image_meta={}, block_device_info=bdi)",
            "            # we don't care what the log message is, we just want to make sure",
            "            # our stub method is called which asserts the password is scrubbed",
            "            self.assertTrue(debug_mock.called)",
            "",
            "    @mock.patch.object(time, \"time\")",
            "    def test_get_guest_config(self, time_mock):",
            "        time_mock.return_value = 1234567.89",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        test_instance = copy.deepcopy(self.test_instance)",
            "        test_instance[\"display_name\"] = \"purple tomatoes\"",
            "",
            "        ctxt = context.RequestContext(project_id=123,",
            "                                      project_name=\"aubergine\",",
            "                                      user_id=456,",
            "                                      user_name=\"pie\")",
            "",
            "        flavor = objects.Flavor(name='m1.small',",
            "                                memory_mb=6,",
            "                                vcpus=28,",
            "                                root_gb=496,",
            "                                ephemeral_gb=8128,",
            "                                swap=33550336,",
            "                                extra_specs={})",
            "        instance_ref = objects.Instance(**test_instance)",
            "        instance_ref.flavor = flavor",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info,",
            "                                     context=ctxt)",
            "",
            "        self.assertEqual(cfg.uuid, instance_ref[\"uuid\"])",
            "        self.assertEqual(2, len(cfg.features))",
            "        self.assertIsInstance(cfg.features[0],",
            "                              vconfig.LibvirtConfigGuestFeatureACPI)",
            "        self.assertIsInstance(cfg.features[1],",
            "                              vconfig.LibvirtConfigGuestFeatureAPIC)",
            "        self.assertEqual(cfg.memory, 6 * units.Ki)",
            "        self.assertEqual(cfg.vcpus, 28)",
            "        self.assertEqual(cfg.os_type, vm_mode.HVM)",
            "        self.assertEqual(cfg.os_boot_dev, [\"hd\"])",
            "        self.assertIsNone(cfg.os_root)",
            "        self.assertEqual(len(cfg.devices), 10)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestInterface)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[8],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[9],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "        self.assertEqual(len(cfg.metadata), 1)",
            "        self.assertIsInstance(cfg.metadata[0],",
            "                              vconfig.LibvirtConfigGuestMetaNovaInstance)",
            "        self.assertEqual(version.version_string_with_package(),",
            "                         cfg.metadata[0].package)",
            "        self.assertEqual(\"purple tomatoes\",",
            "                         cfg.metadata[0].name)",
            "        self.assertEqual(1234567.89,",
            "                         cfg.metadata[0].creationTime)",
            "        self.assertEqual(\"image\",",
            "                         cfg.metadata[0].roottype)",
            "        self.assertEqual(str(instance_ref[\"image_ref\"]),",
            "                         cfg.metadata[0].rootid)",
            "",
            "        self.assertIsInstance(cfg.metadata[0].owner,",
            "                              vconfig.LibvirtConfigGuestMetaNovaOwner)",
            "        self.assertEqual(456,",
            "                         cfg.metadata[0].owner.userid)",
            "        self.assertEqual(\"pie\",",
            "                         cfg.metadata[0].owner.username)",
            "        self.assertEqual(123,",
            "                         cfg.metadata[0].owner.projectid)",
            "        self.assertEqual(\"aubergine\",",
            "                         cfg.metadata[0].owner.projectname)",
            "",
            "        self.assertIsInstance(cfg.metadata[0].flavor,",
            "                              vconfig.LibvirtConfigGuestMetaNovaFlavor)",
            "        self.assertEqual(\"m1.small\",",
            "                         cfg.metadata[0].flavor.name)",
            "        self.assertEqual(6,",
            "                         cfg.metadata[0].flavor.memory)",
            "        self.assertEqual(28,",
            "                         cfg.metadata[0].flavor.vcpus)",
            "        self.assertEqual(496,",
            "                         cfg.metadata[0].flavor.disk)",
            "        self.assertEqual(8128,",
            "                         cfg.metadata[0].flavor.ephemeral)",
            "        self.assertEqual(33550336,",
            "                         cfg.metadata[0].flavor.swap)",
            "",
            "    def test_get_guest_config_lxc(self):",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, {'mapping': {}})",
            "        self.assertEqual(instance_ref[\"uuid\"], cfg.uuid)",
            "        self.assertEqual(2 * units.Mi, cfg.memory)",
            "        self.assertEqual(1, cfg.vcpus)",
            "        self.assertEqual(vm_mode.EXE, cfg.os_type)",
            "        self.assertEqual(\"/sbin/init\", cfg.os_init_path)",
            "        self.assertEqual(\"console=tty0 console=ttyS0\", cfg.os_cmdline)",
            "        self.assertIsNone(cfg.os_root)",
            "        self.assertEqual(3, len(cfg.devices))",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestFilesys)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestInterface)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestConsole)",
            "",
            "    def test_get_guest_config_lxc_with_id_maps(self):",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "        self.flags(uid_maps=['0:1000:100'], group='libvirt')",
            "        self.flags(gid_maps=['0:1000:100'], group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, {'mapping': {}})",
            "        self.assertEqual(instance_ref[\"uuid\"], cfg.uuid)",
            "        self.assertEqual(2 * units.Mi, cfg.memory)",
            "        self.assertEqual(1, cfg.vcpus)",
            "        self.assertEqual(vm_mode.EXE, cfg.os_type)",
            "        self.assertEqual(\"/sbin/init\", cfg.os_init_path)",
            "        self.assertEqual(\"console=tty0 console=ttyS0\", cfg.os_cmdline)",
            "        self.assertIsNone(cfg.os_root)",
            "        self.assertEqual(3, len(cfg.devices))",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestFilesys)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestInterface)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestConsole)",
            "        self.assertEqual(len(cfg.idmaps), 2)",
            "        self.assertIsInstance(cfg.idmaps[0],",
            "                              vconfig.LibvirtConfigGuestUIDMap)",
            "        self.assertIsInstance(cfg.idmaps[1],",
            "                              vconfig.LibvirtConfigGuestGIDMap)",
            "",
            "    @mock.patch.object(",
            "        host.Host, \"is_cpu_control_policy_capable\", return_value=True)",
            "    def test_get_guest_config_numa_host_instance_fits(self, is_able):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=1, vcpus=2, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={})",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        with test.nested(",
            "                mock.patch.object(host.Host, 'has_min_version',",
            "                                  return_value=True),",
            "                mock.patch.object(host.Host, \"get_capabilities\",",
            "                                  return_value=caps)):",
            "            cfg = drvr._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "            self.assertIsNone(cfg.cpuset)",
            "            self.assertEqual(0, len(cfg.cputune.vcpupin))",
            "            self.assertIsNone(cfg.cpu.numa)",
            "",
            "    @mock.patch.object(",
            "        host.Host, \"is_cpu_control_policy_capable\", return_value=True)",
            "    def test_get_guest_config_numa_host_instance_no_fit(self, is_able):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=4096, vcpus=4, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={})",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        with test.nested(",
            "                mock.patch.object(host.Host, \"get_capabilities\",",
            "                                  return_value=caps),",
            "                mock.patch.object(",
            "                    hardware, 'get_vcpu_pin_set', return_value=set([3])),",
            "                mock.patch.object(random, 'choice')",
            "            ) as (get_host_cap_mock,",
            "                  get_vcpu_pin_set_mock, choice_mock):",
            "            cfg = drvr._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "            self.assertFalse(choice_mock.called)",
            "            self.assertEqual(set([3]), cfg.cpuset)",
            "            self.assertEqual(0, len(cfg.cputune.vcpupin))",
            "            self.assertIsNone(cfg.cpu.numa)",
            "",
            "    def _test_get_guest_memory_backing_config(",
            "            self, host_topology, inst_topology, numatune):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        with mock.patch.object(",
            "                drvr, \"_get_host_numa_topology\",",
            "                return_value=host_topology):",
            "            return drvr._get_guest_memory_backing_config(",
            "                inst_topology, numatune, {})",
            "",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    def test_get_guest_memory_backing_config_large_success(self, mock_version):",
            "        host_topology = objects.NUMATopology(",
            "            cells=[",
            "                objects.NUMACell(",
            "                    id=3, cpuset=set([1]), memory=1024, mempages=[",
            "                        objects.NUMAPagesTopology(size_kb=4, total=2000,",
            "                                                  used=0),",
            "                        objects.NUMAPagesTopology(size_kb=2048, total=512,",
            "                                                  used=0),",
            "                        objects.NUMAPagesTopology(size_kb=1048576, total=0,",
            "                                                  used=0),",
            "                    ])])",
            "        inst_topology = objects.InstanceNUMATopology(cells=[",
            "            objects.InstanceNUMACell(",
            "                id=3, cpuset=set([0, 1]), memory=1024, pagesize=2048)])",
            "",
            "        numa_tune = vconfig.LibvirtConfigGuestNUMATune()",
            "        numa_tune.memnodes = [vconfig.LibvirtConfigGuestNUMATuneMemNode()]",
            "        numa_tune.memnodes[0].cellid = 0",
            "        numa_tune.memnodes[0].nodeset = [3]",
            "",
            "        result = self._test_get_guest_memory_backing_config(",
            "            host_topology, inst_topology, numa_tune)",
            "        self.assertEqual(1, len(result.hugepages))",
            "        self.assertEqual(2048, result.hugepages[0].size_kb)",
            "        self.assertEqual([0], result.hugepages[0].nodeset)",
            "",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    def test_get_guest_memory_backing_config_smallest(self, mock_version):",
            "        host_topology = objects.NUMATopology(",
            "            cells=[",
            "                objects.NUMACell(",
            "                    id=3, cpuset=set([1]), memory=1024, mempages=[",
            "                        objects.NUMAPagesTopology(size_kb=4, total=2000,",
            "                                                  used=0),",
            "                        objects.NUMAPagesTopology(size_kb=2048, total=512,",
            "                                                  used=0),",
            "                        objects.NUMAPagesTopology(size_kb=1048576, total=0,",
            "                                                  used=0),",
            "                    ])])",
            "        inst_topology = objects.InstanceNUMATopology(cells=[",
            "            objects.InstanceNUMACell(",
            "                id=3, cpuset=set([0, 1]), memory=1024, pagesize=4)])",
            "",
            "        numa_tune = vconfig.LibvirtConfigGuestNUMATune()",
            "        numa_tune.memnodes = [vconfig.LibvirtConfigGuestNUMATuneMemNode()]",
            "        numa_tune.memnodes[0].cellid = 0",
            "        numa_tune.memnodes[0].nodeset = [3]",
            "",
            "        result = self._test_get_guest_memory_backing_config(",
            "            host_topology, inst_topology, numa_tune)",
            "        self.assertIsNone(result)",
            "",
            "    def test_get_guest_memory_backing_config_realtime(self):",
            "        flavor = {\"extra_specs\": {",
            "            \"hw:cpu_realtime\": \"yes\",",
            "            \"hw:cpu_policy\": \"dedicated\"",
            "        }}",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        membacking = drvr._get_guest_memory_backing_config(",
            "            None, None, flavor)",
            "        self.assertTrue(membacking.locked)",
            "        self.assertFalse(membacking.sharedpages)",
            "",
            "    @mock.patch.object(",
            "        host.Host, \"is_cpu_control_policy_capable\", return_value=True)",
            "    def test_get_guest_config_numa_host_instance_pci_no_numa_info(",
            "            self, is_able):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=1, vcpus=2, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={})",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        pci_device_info = dict(test_pci_device.fake_db_dev)",
            "        pci_device_info.update(compute_node_id=1,",
            "                               label='fake',",
            "                               status=fields.PciDeviceStatus.AVAILABLE,",
            "                               address='0000:00:00.1',",
            "                               instance_uuid=None,",
            "                               request_id=None,",
            "                               extra_info={},",
            "                               numa_node=None)",
            "        pci_device = objects.PciDevice(**pci_device_info)",
            "",
            "        with test.nested(",
            "                mock.patch.object(host.Host, 'has_min_version',",
            "                                  return_value=True),",
            "                mock.patch.object(",
            "                    host.Host, \"get_capabilities\", return_value=caps),",
            "                mock.patch.object(",
            "                    hardware, 'get_vcpu_pin_set', return_value=set([3])),",
            "                mock.patch.object(host.Host, 'get_online_cpus',",
            "                                  return_value=set(range(8))),",
            "                mock.patch.object(pci_manager, \"get_instance_pci_devs\",",
            "                                  return_value=[pci_device])):",
            "            cfg = conn._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "            self.assertEqual(set([3]), cfg.cpuset)",
            "            self.assertEqual(0, len(cfg.cputune.vcpupin))",
            "            self.assertIsNone(cfg.cpu.numa)",
            "",
            "    @mock.patch.object(",
            "        host.Host, \"is_cpu_control_policy_capable\", return_value=True)",
            "    def test_get_guest_config_numa_host_instance_2pci_no_fit(self, is_able):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=4096, vcpus=4, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={})",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        pci_device_info = dict(test_pci_device.fake_db_dev)",
            "        pci_device_info.update(compute_node_id=1,",
            "                               label='fake',",
            "                               status=fields.PciDeviceStatus.AVAILABLE,",
            "                               address='0000:00:00.1',",
            "                               instance_uuid=None,",
            "                               request_id=None,",
            "                               extra_info={},",
            "                               numa_node=1)",
            "        pci_device = objects.PciDevice(**pci_device_info)",
            "        pci_device_info.update(numa_node=0, address='0000:00:00.2')",
            "        pci_device2 = objects.PciDevice(**pci_device_info)",
            "        with test.nested(",
            "                mock.patch.object(",
            "                    host.Host, \"get_capabilities\", return_value=caps),",
            "                mock.patch.object(",
            "                    hardware, 'get_vcpu_pin_set', return_value=set([3])),",
            "                mock.patch.object(random, 'choice'),",
            "                mock.patch.object(pci_manager, \"get_instance_pci_devs\",",
            "                                  return_value=[pci_device, pci_device2])",
            "            ) as (get_host_cap_mock,",
            "                  get_vcpu_pin_set_mock, choice_mock, pci_mock):",
            "            cfg = conn._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "            self.assertFalse(choice_mock.called)",
            "            self.assertEqual(set([3]), cfg.cpuset)",
            "            self.assertEqual(0, len(cfg.cputune.vcpupin))",
            "            self.assertIsNone(cfg.cpu.numa)",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getType')",
            "    @mock.patch.object(fakelibvirt.Connection, 'getVersion')",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion')",
            "    @mock.patch.object(host.Host, 'get_capabilities')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_set_host_enabled')",
            "    def _test_get_guest_config_numa_unsupported(self, fake_lib_version,",
            "                                                fake_version, fake_type,",
            "                                                fake_arch, exception_class,",
            "                                                pagesize, mock_host,",
            "                                                mock_caps, mock_lib_version,",
            "                                                mock_version, mock_type):",
            "        instance_topology = objects.InstanceNUMATopology(",
            "                    cells=[objects.InstanceNUMACell(",
            "                        id=0, cpuset=set([0]),",
            "                        memory=1024, pagesize=pagesize)])",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.numa_topology = instance_topology",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=1, vcpus=2, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={})",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = fake_arch",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        mock_type.return_value = fake_type",
            "        mock_version.return_value = fake_version",
            "        mock_lib_version.return_value = fake_lib_version",
            "        mock_caps.return_value = caps",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        self.assertRaises(exception_class,",
            "                          drvr._get_guest_config,",
            "                          instance_ref, [],",
            "                          image_meta, disk_info)",
            "",
            "    def test_get_guest_config_numa_old_version_libvirt(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        self._test_get_guest_config_numa_unsupported(",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_NUMA_VERSION) - 1,",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_QEMU_NUMA_HUGEPAGE_VERSION),",
            "            host.HV_DRIVER_QEMU,",
            "            arch.X86_64,",
            "            exception.NUMATopologyUnsupported,",
            "            None)",
            "",
            "    def test_get_guest_config_numa_old_version_libvirt_ppc(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        self._test_get_guest_config_numa_unsupported(",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_NUMA_VERSION_PPC) - 1,",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_QEMU_NUMA_HUGEPAGE_VERSION),",
            "            host.HV_DRIVER_QEMU,",
            "            arch.PPC64LE,",
            "            exception.NUMATopologyUnsupported,",
            "            None)",
            "",
            "    def test_get_guest_config_numa_bad_version_libvirt(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        self._test_get_guest_config_numa_unsupported(",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.BAD_LIBVIRT_NUMA_VERSIONS[0]),",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_QEMU_NUMA_HUGEPAGE_VERSION),",
            "            host.HV_DRIVER_QEMU,",
            "            arch.X86_64,",
            "            exception.NUMATopologyUnsupported,",
            "            None)",
            "",
            "    @mock.patch.object(libvirt_driver.LOG, 'warn')",
            "    def test_has_numa_support_bad_version_libvirt_log(self, mock_warn):",
            "        # Tests that a warning is logged once and only once when there is a bad",
            "        # BAD_LIBVIRT_NUMA_VERSIONS detected.",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertFalse(hasattr(drvr, '_bad_libvirt_numa_version_warn'))",
            "        with mock.patch.object(drvr._host, 'has_version', return_value=True):",
            "            for i in range(2):",
            "                self.assertFalse(drvr._has_numa_support())",
            "        self.assertTrue(drvr._bad_libvirt_numa_version_warn)",
            "        self.assertEqual(1, mock_warn.call_count)",
            "        # assert the version is logged properly",
            "        self.assertEqual('1.2.9.2', mock_warn.call_args[0][1])",
            "",
            "    def test_get_guest_config_numa_old_version_qemu(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        self._test_get_guest_config_numa_unsupported(",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_NUMA_VERSION),",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_QEMU_NUMA_HUGEPAGE_VERSION) - 1,",
            "            host.HV_DRIVER_QEMU,",
            "            arch.X86_64,",
            "            exception.NUMATopologyUnsupported,",
            "            None)",
            "",
            "    def test_get_guest_config_numa_other_arch_qemu(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        self._test_get_guest_config_numa_unsupported(",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_NUMA_VERSION),",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_QEMU_NUMA_HUGEPAGE_VERSION),",
            "            host.HV_DRIVER_QEMU,",
            "            arch.S390,",
            "            exception.NUMATopologyUnsupported,",
            "            None)",
            "",
            "    def test_get_guest_config_numa_xen(self):",
            "        self.flags(virt_type='xen', group='libvirt')",
            "        self._test_get_guest_config_numa_unsupported(",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_NUMA_VERSION),",
            "            versionutils.convert_version_to_int((4, 5, 0)),",
            "            'XEN',",
            "            arch.X86_64,",
            "            exception.NUMATopologyUnsupported,",
            "            None)",
            "",
            "    def test_get_guest_config_numa_old_pages_libvirt(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        self._test_get_guest_config_numa_unsupported(",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_HUGEPAGE_VERSION) - 1,",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_QEMU_NUMA_HUGEPAGE_VERSION),",
            "            host.HV_DRIVER_QEMU,",
            "            arch.X86_64,",
            "            exception.MemoryPagesUnsupported,",
            "            2048)",
            "",
            "    def test_get_guest_config_numa_old_pages_qemu(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        self._test_get_guest_config_numa_unsupported(",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_HUGEPAGE_VERSION),",
            "            versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_QEMU_NUMA_HUGEPAGE_VERSION) - 1,",
            "            host.HV_DRIVER_QEMU,",
            "            arch.X86_64,",
            "            exception.NUMATopologyUnsupported,",
            "            2048)",
            "",
            "    @mock.patch.object(",
            "        host.Host, \"is_cpu_control_policy_capable\", return_value=True)",
            "    def test_get_guest_config_numa_host_instance_fit_w_cpu_pinset(",
            "            self, is_able):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=1024, vcpus=2, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={})",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology(kb_mem=4194304)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        with test.nested(",
            "                mock.patch.object(host.Host, 'has_min_version',",
            "                                  return_value=True),",
            "                mock.patch.object(host.Host, \"get_capabilities\",",
            "                                  return_value=caps),",
            "                mock.patch.object(",
            "                    hardware, 'get_vcpu_pin_set', return_value=set([2, 3])),",
            "                mock.patch.object(host.Host, 'get_online_cpus',",
            "                                  return_value=set(range(8)))",
            "                ) as (has_min_version_mock, get_host_cap_mock,",
            "                        get_vcpu_pin_set_mock, get_online_cpus_mock):",
            "            cfg = drvr._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "            # NOTE(ndipanov): we make sure that pin_set was taken into account",
            "            # when choosing viable cells",
            "            self.assertEqual(set([2, 3]), cfg.cpuset)",
            "            self.assertEqual(0, len(cfg.cputune.vcpupin))",
            "            self.assertIsNone(cfg.cpu.numa)",
            "",
            "    @mock.patch.object(",
            "        host.Host, \"is_cpu_control_policy_capable\", return_value=True)",
            "    def test_get_guest_config_non_numa_host_instance_topo(self, is_able):",
            "        instance_topology = objects.InstanceNUMATopology(",
            "                    cells=[objects.InstanceNUMACell(",
            "                        id=0, cpuset=set([0]), memory=1024),",
            "                           objects.InstanceNUMACell(",
            "                        id=1, cpuset=set([2]), memory=1024)])",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.numa_topology = instance_topology",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=2048, vcpus=2, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={})",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = None",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        with test.nested(",
            "                mock.patch.object(",
            "                    objects.InstanceNUMATopology, \"get_by_instance_uuid\",",
            "                    return_value=instance_topology),",
            "                mock.patch.object(host.Host, 'has_min_version',",
            "                                  return_value=True),",
            "                mock.patch.object(host.Host, \"get_capabilities\",",
            "                                  return_value=caps)):",
            "            cfg = drvr._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "            self.assertIsNone(cfg.cpuset)",
            "            self.assertEqual(0, len(cfg.cputune.vcpupin))",
            "            self.assertIsNone(cfg.numatune)",
            "            self.assertIsNotNone(cfg.cpu.numa)",
            "            for instance_cell, numa_cfg_cell in zip(",
            "                    instance_topology.cells, cfg.cpu.numa.cells):",
            "                self.assertEqual(instance_cell.id, numa_cfg_cell.id)",
            "                self.assertEqual(instance_cell.cpuset, numa_cfg_cell.cpus)",
            "                self.assertEqual(instance_cell.memory * units.Ki,",
            "                                 numa_cfg_cell.memory)",
            "",
            "    @mock.patch.object(",
            "        host.Host, \"is_cpu_control_policy_capable\", return_value=True)",
            "    def test_get_guest_config_numa_host_instance_topo(self, is_able):",
            "        instance_topology = objects.InstanceNUMATopology(",
            "                    cells=[objects.InstanceNUMACell(",
            "                        id=1, cpuset=set([0, 1]), memory=1024, pagesize=None),",
            "                           objects.InstanceNUMACell(",
            "                               id=2, cpuset=set([2, 3]), memory=1024,",
            "                               pagesize=None)])",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.numa_topology = instance_topology",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=2048, vcpus=4, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={})",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        with test.nested(",
            "                mock.patch.object(",
            "                    objects.InstanceNUMATopology, \"get_by_instance_uuid\",",
            "                    return_value=instance_topology),",
            "                mock.patch.object(host.Host, 'has_min_version',",
            "                                  return_value=True),",
            "                mock.patch.object(host.Host, \"get_capabilities\",",
            "                                  return_value=caps),",
            "                mock.patch.object(",
            "                    hardware, 'get_vcpu_pin_set',",
            "                    return_value=set([2, 3, 4, 5])),",
            "                mock.patch.object(host.Host, 'get_online_cpus',",
            "                                  return_value=set(range(8))),",
            "                ):",
            "            cfg = drvr._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "            self.assertIsNone(cfg.cpuset)",
            "            # Test that the pinning is correct and limited to allowed only",
            "            self.assertEqual(0, cfg.cputune.vcpupin[0].id)",
            "            self.assertEqual(set([2, 3]), cfg.cputune.vcpupin[0].cpuset)",
            "            self.assertEqual(1, cfg.cputune.vcpupin[1].id)",
            "            self.assertEqual(set([2, 3]), cfg.cputune.vcpupin[1].cpuset)",
            "            self.assertEqual(2, cfg.cputune.vcpupin[2].id)",
            "            self.assertEqual(set([4, 5]), cfg.cputune.vcpupin[2].cpuset)",
            "            self.assertEqual(3, cfg.cputune.vcpupin[3].id)",
            "            self.assertEqual(set([4, 5]), cfg.cputune.vcpupin[3].cpuset)",
            "            self.assertIsNotNone(cfg.cpu.numa)",
            "",
            "            self.assertIsInstance(cfg.cputune.emulatorpin,",
            "                                  vconfig.LibvirtConfigGuestCPUTuneEmulatorPin)",
            "            self.assertEqual(set([2, 3, 4, 5]), cfg.cputune.emulatorpin.cpuset)",
            "",
            "            for instance_cell, numa_cfg_cell, index in zip(",
            "                    instance_topology.cells,",
            "                    cfg.cpu.numa.cells,",
            "                    range(len(instance_topology.cells))):",
            "                self.assertEqual(index, numa_cfg_cell.id)",
            "                self.assertEqual(instance_cell.cpuset, numa_cfg_cell.cpus)",
            "                self.assertEqual(instance_cell.memory * units.Ki,",
            "                                 numa_cfg_cell.memory)",
            "",
            "            allnodes = [cell.id for cell in instance_topology.cells]",
            "            self.assertEqual(allnodes, cfg.numatune.memory.nodeset)",
            "            self.assertEqual(\"strict\", cfg.numatune.memory.mode)",
            "",
            "            for instance_cell, memnode, index in zip(",
            "                    instance_topology.cells,",
            "                    cfg.numatune.memnodes,",
            "                    range(len(instance_topology.cells))):",
            "                self.assertEqual(index, memnode.cellid)",
            "                self.assertEqual([instance_cell.id], memnode.nodeset)",
            "                self.assertEqual(\"strict\", memnode.mode)",
            "",
            "    def test_get_guest_config_numa_host_instance_topo_reordered(self):",
            "        instance_topology = objects.InstanceNUMATopology(",
            "                    cells=[objects.InstanceNUMACell(",
            "                        id=3, cpuset=set([0, 1]), memory=1024),",
            "                           objects.InstanceNUMACell(",
            "                        id=0, cpuset=set([2, 3]), memory=1024)])",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.numa_topology = instance_topology",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=2048, vcpus=4, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={})",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        with test.nested(",
            "                mock.patch.object(",
            "                    objects.InstanceNUMATopology, \"get_by_instance_uuid\",",
            "                    return_value=instance_topology),",
            "                mock.patch.object(host.Host, 'has_min_version',",
            "                                  return_value=True),",
            "                mock.patch.object(host.Host, \"get_capabilities\",",
            "                                  return_value=caps),",
            "                mock.patch.object(host.Host, 'get_online_cpus',",
            "                                  return_value=set(range(8))),",
            "                ):",
            "            cfg = drvr._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "            self.assertIsNone(cfg.cpuset)",
            "            # Test that the pinning is correct and limited to allowed only",
            "            self.assertEqual(0, cfg.cputune.vcpupin[0].id)",
            "            self.assertEqual(set([6, 7]), cfg.cputune.vcpupin[0].cpuset)",
            "            self.assertEqual(1, cfg.cputune.vcpupin[1].id)",
            "            self.assertEqual(set([6, 7]), cfg.cputune.vcpupin[1].cpuset)",
            "            self.assertEqual(2, cfg.cputune.vcpupin[2].id)",
            "            self.assertEqual(set([0, 1]), cfg.cputune.vcpupin[2].cpuset)",
            "            self.assertEqual(3, cfg.cputune.vcpupin[3].id)",
            "            self.assertEqual(set([0, 1]), cfg.cputune.vcpupin[3].cpuset)",
            "            self.assertIsNotNone(cfg.cpu.numa)",
            "",
            "            self.assertIsInstance(cfg.cputune.emulatorpin,",
            "                                  vconfig.LibvirtConfigGuestCPUTuneEmulatorPin)",
            "            self.assertEqual(set([0, 1, 6, 7]), cfg.cputune.emulatorpin.cpuset)",
            "",
            "            for index, (instance_cell, numa_cfg_cell) in enumerate(zip(",
            "                    instance_topology.cells,",
            "                    cfg.cpu.numa.cells)):",
            "                self.assertEqual(index, numa_cfg_cell.id)",
            "                self.assertEqual(instance_cell.cpuset, numa_cfg_cell.cpus)",
            "                self.assertEqual(instance_cell.memory * units.Ki,",
            "                                 numa_cfg_cell.memory)",
            "                self.assertIsNone(numa_cfg_cell.memAccess)",
            "",
            "            allnodes = set([cell.id for cell in instance_topology.cells])",
            "            self.assertEqual(allnodes, set(cfg.numatune.memory.nodeset))",
            "            self.assertEqual(\"strict\", cfg.numatune.memory.mode)",
            "",
            "            for index, (instance_cell, memnode) in enumerate(zip(",
            "                    instance_topology.cells,",
            "                    cfg.numatune.memnodes)):",
            "                self.assertEqual(index, memnode.cellid)",
            "                self.assertEqual([instance_cell.id], memnode.nodeset)",
            "                self.assertEqual(\"strict\", memnode.mode)",
            "",
            "    def test_get_guest_config_numa_host_instance_topo_cpu_pinning(self):",
            "        instance_topology = objects.InstanceNUMATopology(",
            "                    cells=[objects.InstanceNUMACell(",
            "                        id=1, cpuset=set([0, 1]), memory=1024,",
            "                        cpu_pinning={0: 24, 1: 25}),",
            "                           objects.InstanceNUMACell(",
            "                        id=0, cpuset=set([2, 3]), memory=1024,",
            "                        cpu_pinning={2: 0, 3: 1})])",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.numa_topology = instance_topology",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=2048, vcpus=2, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={})",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology(",
            "            sockets_per_cell=4, cores_per_socket=3, threads_per_core=2)",
            "",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        with test.nested(",
            "                mock.patch.object(",
            "                    objects.InstanceNUMATopology, \"get_by_instance_uuid\",",
            "                    return_value=instance_topology),",
            "                mock.patch.object(host.Host, 'has_min_version',",
            "                                  return_value=True),",
            "                mock.patch.object(host.Host, \"get_capabilities\",",
            "                                  return_value=caps),",
            "                mock.patch.object(host.Host, 'get_online_cpus',",
            "                                  return_value=set(range(8))),",
            "                ):",
            "            cfg = conn._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "            self.assertIsNone(cfg.cpuset)",
            "            # Test that the pinning is correct and limited to allowed only",
            "            self.assertEqual(0, cfg.cputune.vcpupin[0].id)",
            "            self.assertEqual(set([24]), cfg.cputune.vcpupin[0].cpuset)",
            "            self.assertEqual(1, cfg.cputune.vcpupin[1].id)",
            "            self.assertEqual(set([25]), cfg.cputune.vcpupin[1].cpuset)",
            "            self.assertEqual(2, cfg.cputune.vcpupin[2].id)",
            "            self.assertEqual(set([0]), cfg.cputune.vcpupin[2].cpuset)",
            "            self.assertEqual(3, cfg.cputune.vcpupin[3].id)",
            "            self.assertEqual(set([1]), cfg.cputune.vcpupin[3].cpuset)",
            "            self.assertIsNotNone(cfg.cpu.numa)",
            "",
            "            # Emulator must be pinned to union of cfg.cputune.vcpupin[*].cpuset",
            "            self.assertIsInstance(cfg.cputune.emulatorpin,",
            "                                  vconfig.LibvirtConfigGuestCPUTuneEmulatorPin)",
            "            self.assertEqual(set([0, 1, 24, 25]),",
            "                             cfg.cputune.emulatorpin.cpuset)",
            "",
            "            for i, (instance_cell, numa_cfg_cell) in enumerate(zip(",
            "                    instance_topology.cells, cfg.cpu.numa.cells)):",
            "                self.assertEqual(i, numa_cfg_cell.id)",
            "                self.assertEqual(instance_cell.cpuset, numa_cfg_cell.cpus)",
            "                self.assertEqual(instance_cell.memory * units.Ki,",
            "                                 numa_cfg_cell.memory)",
            "                self.assertIsNone(numa_cfg_cell.memAccess)",
            "",
            "            allnodes = set([cell.id for cell in instance_topology.cells])",
            "            self.assertEqual(allnodes, set(cfg.numatune.memory.nodeset))",
            "            self.assertEqual(\"strict\", cfg.numatune.memory.mode)",
            "",
            "            for i, (instance_cell, memnode) in enumerate(zip(",
            "                    instance_topology.cells, cfg.numatune.memnodes)):",
            "                self.assertEqual(i, memnode.cellid)",
            "                self.assertEqual([instance_cell.id], memnode.nodeset)",
            "                self.assertEqual(\"strict\", memnode.mode)",
            "",
            "    def test_get_guest_config_numa_host_mempages_shared(self):",
            "        instance_topology = objects.InstanceNUMATopology(",
            "            cells=[",
            "                objects.InstanceNUMACell(",
            "                    id=1, cpuset=set([0, 1]),",
            "                    memory=1024, pagesize=2048),",
            "                objects.InstanceNUMACell(",
            "                    id=2, cpuset=set([2, 3]),",
            "                    memory=1024, pagesize=2048)])",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.numa_topology = instance_topology",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=2048, vcpus=4, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={})",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        with test.nested(",
            "                mock.patch.object(",
            "                    objects.InstanceNUMATopology, \"get_by_instance_uuid\",",
            "                    return_value=instance_topology),",
            "                mock.patch.object(host.Host, 'has_min_version',",
            "                                  return_value=True),",
            "                mock.patch.object(host.Host, \"get_capabilities\",",
            "                                  return_value=caps),",
            "                mock.patch.object(",
            "                    hardware, 'get_vcpu_pin_set',",
            "                    return_value=set([2, 3, 4, 5])),",
            "                mock.patch.object(host.Host, 'get_online_cpus',",
            "                                  return_value=set(range(8))),",
            "                ):",
            "            cfg = drvr._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "",
            "            for instance_cell, numa_cfg_cell, index in zip(",
            "                    instance_topology.cells,",
            "                    cfg.cpu.numa.cells,",
            "                    range(len(instance_topology.cells))):",
            "                self.assertEqual(index, numa_cfg_cell.id)",
            "                self.assertEqual(instance_cell.cpuset, numa_cfg_cell.cpus)",
            "                self.assertEqual(instance_cell.memory * units.Ki,",
            "                                 numa_cfg_cell.memory)",
            "                self.assertEqual(\"shared\", numa_cfg_cell.memAccess)",
            "",
            "            allnodes = [cell.id for cell in instance_topology.cells]",
            "            self.assertEqual(allnodes, cfg.numatune.memory.nodeset)",
            "            self.assertEqual(\"strict\", cfg.numatune.memory.mode)",
            "",
            "            for instance_cell, memnode, index in zip(",
            "                    instance_topology.cells,",
            "                    cfg.numatune.memnodes,",
            "                    range(len(instance_topology.cells))):",
            "                self.assertEqual(index, memnode.cellid)",
            "                self.assertEqual([instance_cell.id], memnode.nodeset)",
            "                self.assertEqual(\"strict\", memnode.mode)",
            "",
            "            self.assertEqual(0, len(cfg.cputune.vcpusched))",
            "            self.assertEqual(set([2, 3, 4, 5]), cfg.cputune.emulatorpin.cpuset)",
            "",
            "    def test_get_guest_config_numa_host_instance_cpu_pinning_realtime(self):",
            "        instance_topology = objects.InstanceNUMATopology(",
            "            cells=[",
            "                objects.InstanceNUMACell(",
            "                    id=1, cpuset=set([0, 1]),",
            "                    memory=1024, pagesize=2048),",
            "                objects.InstanceNUMACell(",
            "                    id=2, cpuset=set([2, 3]),",
            "                    memory=1024, pagesize=2048)])",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.numa_topology = instance_topology",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = objects.Flavor(memory_mb=2048, vcpus=2, root_gb=496,",
            "                                ephemeral_gb=8128, swap=33550336, name='fake',",
            "                                extra_specs={",
            "                                    \"hw:cpu_realtime\": \"yes\",",
            "                                    \"hw:cpu_policy\": \"dedicated\",",
            "                                    \"hw:cpu_realtime_mask\": \"^0-1\"",
            "                                })",
            "        instance_ref.flavor = flavor",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        with test.nested(",
            "                mock.patch.object(",
            "                    objects.InstanceNUMATopology, \"get_by_instance_uuid\",",
            "                    return_value=instance_topology),",
            "                mock.patch.object(host.Host, 'has_min_version',",
            "                                  return_value=True),",
            "                mock.patch.object(host.Host, \"get_capabilities\",",
            "                                  return_value=caps),",
            "                mock.patch.object(",
            "                    hardware, 'get_vcpu_pin_set',",
            "                    return_value=set([2, 3, 4, 5])),",
            "                mock.patch.object(host.Host, 'get_online_cpus',",
            "                                  return_value=set(range(8))),",
            "                ):",
            "            cfg = drvr._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "",
            "            for instance_cell, numa_cfg_cell, index in zip(",
            "                    instance_topology.cells,",
            "                    cfg.cpu.numa.cells,",
            "                    range(len(instance_topology.cells))):",
            "                self.assertEqual(index, numa_cfg_cell.id)",
            "                self.assertEqual(instance_cell.cpuset, numa_cfg_cell.cpus)",
            "                self.assertEqual(instance_cell.memory * units.Ki,",
            "                                 numa_cfg_cell.memory)",
            "                self.assertEqual(\"shared\", numa_cfg_cell.memAccess)",
            "",
            "            allnodes = [cell.id for cell in instance_topology.cells]",
            "            self.assertEqual(allnodes, cfg.numatune.memory.nodeset)",
            "            self.assertEqual(\"strict\", cfg.numatune.memory.mode)",
            "",
            "            for instance_cell, memnode, index in zip(",
            "                    instance_topology.cells,",
            "                    cfg.numatune.memnodes,",
            "                    range(len(instance_topology.cells))):",
            "                self.assertEqual(index, memnode.cellid)",
            "                self.assertEqual([instance_cell.id], memnode.nodeset)",
            "                self.assertEqual(\"strict\", memnode.mode)",
            "",
            "            self.assertEqual(1, len(cfg.cputune.vcpusched))",
            "            self.assertEqual(\"fifo\", cfg.cputune.vcpusched[0].scheduler)",
            "            self.assertEqual(set([2, 3]), cfg.cputune.vcpusched[0].vcpus)",
            "            self.assertEqual(set([0, 1]), cfg.cputune.emulatorpin.cpuset)",
            "",
            "    def test_get_cpu_numa_config_from_instance(self):",
            "        topology = objects.InstanceNUMATopology(cells=[",
            "            objects.InstanceNUMACell(id=0, cpuset=set([1, 2]), memory=128),",
            "            objects.InstanceNUMACell(id=1, cpuset=set([3, 4]), memory=128),",
            "        ])",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        conf = drvr._get_cpu_numa_config_from_instance(topology, True)",
            "",
            "        self.assertIsInstance(conf, vconfig.LibvirtConfigGuestCPUNUMA)",
            "        self.assertEqual(0, conf.cells[0].id)",
            "        self.assertEqual(set([1, 2]), conf.cells[0].cpus)",
            "        self.assertEqual(131072, conf.cells[0].memory)",
            "        self.assertEqual(\"shared\", conf.cells[0].memAccess)",
            "        self.assertEqual(1, conf.cells[1].id)",
            "        self.assertEqual(set([3, 4]), conf.cells[1].cpus)",
            "        self.assertEqual(131072, conf.cells[1].memory)",
            "        self.assertEqual(\"shared\", conf.cells[1].memAccess)",
            "",
            "    def test_get_cpu_numa_config_from_instance_none(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        conf = drvr._get_cpu_numa_config_from_instance(None, False)",
            "        self.assertIsNone(conf)",
            "",
            "    @mock.patch.object(host.Host, 'has_version', return_value=True)",
            "    def test_has_cpu_policy_support(self, mock_has_version):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertRaises(exception.CPUPinningNotSupported,",
            "                          drvr._has_cpu_policy_support)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, \"_has_numa_support\",",
            "                       return_value=True)",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, \"_has_hugepage_support\",",
            "                       return_value=True)",
            "    @mock.patch.object(host.Host, \"get_capabilities\")",
            "    def test_does_not_want_hugepages(self, mock_caps, mock_numa, mock_hp):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_topology = objects.InstanceNUMATopology(",
            "            cells=[",
            "                objects.InstanceNUMACell(",
            "                    id=1, cpuset=set([0, 1]),",
            "                    memory=1024, pagesize=4),",
            "                objects.InstanceNUMACell(",
            "                    id=2, cpuset=set([2, 3]),",
            "                    memory=1024, pagesize=4)])",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        mock_caps.return_value = caps",
            "",
            "        host_topology = drvr._get_host_numa_topology()",
            "",
            "        self.assertFalse(drvr._wants_hugepages(None, None))",
            "        self.assertFalse(drvr._wants_hugepages(host_topology, None))",
            "        self.assertFalse(drvr._wants_hugepages(None, instance_topology))",
            "        self.assertFalse(drvr._wants_hugepages(host_topology,",
            "                                               instance_topology))",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, \"_has_numa_support\",",
            "                       return_value=True)",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, \"_has_hugepage_support\",",
            "                       return_value=True)",
            "    @mock.patch.object(host.Host, \"get_capabilities\")",
            "    def test_does_want_hugepages(self, mock_caps, mock_numa, mock_hp):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_topology = objects.InstanceNUMATopology(",
            "            cells=[",
            "                objects.InstanceNUMACell(",
            "                    id=1, cpuset=set([0, 1]),",
            "                    memory=1024, pagesize=2048),",
            "                objects.InstanceNUMACell(",
            "                    id=2, cpuset=set([2, 3]),",
            "                    memory=1024, pagesize=2048)])",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        mock_caps.return_value = caps",
            "",
            "        host_topology = drvr._get_host_numa_topology()",
            "",
            "        self.assertTrue(drvr._wants_hugepages(host_topology,",
            "                                              instance_topology))",
            "",
            "    def test_get_guest_config_clock(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        hpet_map = {",
            "            arch.X86_64: True,",
            "            arch.I686: True,",
            "            arch.PPC: False,",
            "            arch.PPC64: False,",
            "            arch.ARMV7: False,",
            "            arch.AARCH64: False,",
            "            }",
            "",
            "        for guestarch, expect_hpet in hpet_map.items():",
            "            with mock.patch.object(libvirt_driver.libvirt_utils,",
            "                                   'get_arch',",
            "                                   return_value=guestarch):",
            "                cfg = drvr._get_guest_config(instance_ref, [],",
            "                                             image_meta,",
            "                                             disk_info)",
            "                self.assertIsInstance(cfg.clock,",
            "                                      vconfig.LibvirtConfigGuestClock)",
            "                self.assertEqual(cfg.clock.offset, \"utc\")",
            "                self.assertIsInstance(cfg.clock.timers[0],",
            "                                      vconfig.LibvirtConfigGuestTimer)",
            "                self.assertIsInstance(cfg.clock.timers[1],",
            "                                      vconfig.LibvirtConfigGuestTimer)",
            "                self.assertEqual(cfg.clock.timers[0].name, \"pit\")",
            "                self.assertEqual(cfg.clock.timers[0].tickpolicy,",
            "                                      \"delay\")",
            "                self.assertEqual(cfg.clock.timers[1].name, \"rtc\")",
            "                self.assertEqual(cfg.clock.timers[1].tickpolicy,",
            "                                      \"catchup\")",
            "                if expect_hpet:",
            "                    self.assertEqual(3, len(cfg.clock.timers))",
            "                    self.assertIsInstance(cfg.clock.timers[2],",
            "                                          vconfig.LibvirtConfigGuestTimer)",
            "                    self.assertEqual('hpet', cfg.clock.timers[2].name)",
            "                    self.assertFalse(cfg.clock.timers[2].present)",
            "                else:",
            "                    self.assertEqual(2, len(cfg.clock.timers))",
            "",
            "    @mock.patch.object(libvirt_utils, 'get_arch')",
            "    @mock.patch.object(host.Host, 'has_min_version')",
            "    def test_get_guest_config_windows(self, mock_version, mock_get_arch):",
            "        mock_version.return_value = False",
            "        mock_get_arch.return_value = arch.I686",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref['os_type'] = 'windows'",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info)",
            "",
            "        self.assertIsInstance(cfg.clock,",
            "                              vconfig.LibvirtConfigGuestClock)",
            "        self.assertEqual(cfg.clock.offset, \"localtime\")",
            "",
            "        self.assertEqual(3, len(cfg.clock.timers), cfg.clock.timers)",
            "        self.assertEqual(\"pit\", cfg.clock.timers[0].name)",
            "        self.assertEqual(\"rtc\", cfg.clock.timers[1].name)",
            "        self.assertEqual(\"hpet\", cfg.clock.timers[2].name)",
            "        self.assertFalse(cfg.clock.timers[2].present)",
            "",
            "    @mock.patch.object(libvirt_utils, 'get_arch')",
            "    @mock.patch.object(host.Host, 'has_min_version')",
            "    def test_get_guest_config_windows_timer(self, mock_version, mock_get_arch):",
            "        mock_version.return_value = True",
            "        mock_get_arch.return_value = arch.I686",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref['os_type'] = 'windows'",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info)",
            "",
            "        self.assertIsInstance(cfg.clock,",
            "                              vconfig.LibvirtConfigGuestClock)",
            "        self.assertEqual(cfg.clock.offset, \"localtime\")",
            "",
            "        self.assertEqual(4, len(cfg.clock.timers), cfg.clock.timers)",
            "        self.assertEqual(\"pit\", cfg.clock.timers[0].name)",
            "        self.assertEqual(\"rtc\", cfg.clock.timers[1].name)",
            "        self.assertEqual(\"hpet\", cfg.clock.timers[2].name)",
            "        self.assertFalse(cfg.clock.timers[2].present)",
            "        self.assertEqual(\"hypervclock\", cfg.clock.timers[3].name)",
            "        self.assertTrue(cfg.clock.timers[3].present)",
            "",
            "        self.assertEqual(3, len(cfg.features))",
            "        self.assertIsInstance(cfg.features[0],",
            "                              vconfig.LibvirtConfigGuestFeatureACPI)",
            "        self.assertIsInstance(cfg.features[1],",
            "                              vconfig.LibvirtConfigGuestFeatureAPIC)",
            "        self.assertIsInstance(cfg.features[2],",
            "                              vconfig.LibvirtConfigGuestFeatureHyperV)",
            "",
            "    @mock.patch.object(host.Host, 'has_min_version')",
            "    def test_get_guest_config_windows_hyperv_feature1(self, mock_version):",
            "        def fake_version(lv_ver=None, hv_ver=None, hv_type=None):",
            "            if lv_ver == (1, 0, 0) and hv_ver == (1, 1, 0):",
            "                return True",
            "            return False",
            "",
            "        mock_version.side_effect = fake_version",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref['os_type'] = 'windows'",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info)",
            "",
            "        self.assertIsInstance(cfg.clock,",
            "                              vconfig.LibvirtConfigGuestClock)",
            "        self.assertEqual(cfg.clock.offset, \"localtime\")",
            "",
            "        self.assertEqual(3, len(cfg.features))",
            "        self.assertIsInstance(cfg.features[0],",
            "                              vconfig.LibvirtConfigGuestFeatureACPI)",
            "        self.assertIsInstance(cfg.features[1],",
            "                              vconfig.LibvirtConfigGuestFeatureAPIC)",
            "        self.assertIsInstance(cfg.features[2],",
            "                              vconfig.LibvirtConfigGuestFeatureHyperV)",
            "",
            "        self.assertTrue(cfg.features[2].relaxed)",
            "        self.assertFalse(cfg.features[2].spinlocks)",
            "        self.assertFalse(cfg.features[2].vapic)",
            "",
            "    @mock.patch.object(host.Host, 'has_min_version')",
            "    def test_get_guest_config_windows_hyperv_feature2(self, mock_version):",
            "        mock_version.return_value = True",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref['os_type'] = 'windows'",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info)",
            "",
            "        self.assertIsInstance(cfg.clock,",
            "                              vconfig.LibvirtConfigGuestClock)",
            "        self.assertEqual(cfg.clock.offset, \"localtime\")",
            "",
            "        self.assertEqual(3, len(cfg.features))",
            "        self.assertIsInstance(cfg.features[0],",
            "                              vconfig.LibvirtConfigGuestFeatureACPI)",
            "        self.assertIsInstance(cfg.features[1],",
            "                              vconfig.LibvirtConfigGuestFeatureAPIC)",
            "        self.assertIsInstance(cfg.features[2],",
            "                              vconfig.LibvirtConfigGuestFeatureHyperV)",
            "",
            "        self.assertTrue(cfg.features[2].relaxed)",
            "        self.assertTrue(cfg.features[2].spinlocks)",
            "        self.assertEqual(8191, cfg.features[2].spinlock_retries)",
            "        self.assertTrue(cfg.features[2].vapic)",
            "",
            "    def test_get_guest_config_with_two_nics(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 2),",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(2, len(cfg.features))",
            "        self.assertIsInstance(cfg.features[0],",
            "                              vconfig.LibvirtConfigGuestFeatureACPI)",
            "        self.assertIsInstance(cfg.features[1],",
            "                              vconfig.LibvirtConfigGuestFeatureAPIC)",
            "        self.assertEqual(cfg.memory, 2 * units.Mi)",
            "        self.assertEqual(cfg.vcpus, 1)",
            "        self.assertEqual(cfg.os_type, vm_mode.HVM)",
            "        self.assertEqual(cfg.os_boot_dev, [\"hd\"])",
            "        self.assertIsNone(cfg.os_root)",
            "        self.assertEqual(len(cfg.devices), 10)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestInterface)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestInterface)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[8],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[9],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "    def test_get_guest_config_bug_1118829(self):",
            "        self.flags(virt_type='uml', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "",
            "        disk_info = {'disk_bus': 'virtio',",
            "                     'cdrom_bus': 'ide',",
            "                     'mapping': {u'vda': {'bus': 'virtio',",
            "                                          'type': 'disk',",
            "                                          'dev': u'vda'},",
            "                                 'root': {'bus': 'virtio',",
            "                                          'type': 'disk',",
            "                                          'dev': 'vda'}}}",
            "",
            "        # NOTE(jdg): For this specific test leave this blank",
            "        # This will exercise the failed code path still,",
            "        # and won't require fakes and stubs of the iscsi discovery",
            "        block_device_info = {}",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        drvr._get_guest_config(instance_ref, [], image_meta, disk_info,",
            "                               None, block_device_info)",
            "        self.assertEqual(instance_ref['root_device_name'], '/dev/vda')",
            "",
            "    def test_get_guest_config_with_root_device_name(self):",
            "        self.flags(virt_type='uml', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        block_device_info = {'root_device_name': '/dev/vdb'}",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta,",
            "                                            block_device_info)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info,",
            "                                     None, block_device_info)",
            "        self.assertEqual(0, len(cfg.features))",
            "        self.assertEqual(cfg.memory, 2 * units.Mi)",
            "        self.assertEqual(cfg.vcpus, 1)",
            "        self.assertEqual(cfg.os_type, \"uml\")",
            "        self.assertEqual(cfg.os_boot_dev, [])",
            "        self.assertEqual(cfg.os_root, '/dev/vdb')",
            "        self.assertEqual(len(cfg.devices), 3)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestConsole)",
            "",
            "    def test_has_uefi_support_with_invalid_version(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        with mock.patch.object(drvr._host,",
            "                               'has_min_version', return_value=False):",
            "            self.assertFalse(drvr._has_uefi_support())",
            "",
            "    def test_has_uefi_support_not_supported_arch(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"alpha\"",
            "        self.assertFalse(drvr._has_uefi_support())",
            "",
            "    @mock.patch('os.path.exists', return_value=False)",
            "    def test_has_uefi_support_with_no_loader_existed(self, mock_exist):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.assertFalse(drvr._has_uefi_support())",
            "",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    def test_has_uefi_support(self, mock_has_version):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = \"x86_64\"",
            "",
            "        with mock.patch.object(drvr._host,",
            "                               'has_min_version', return_value=True):",
            "            self.assertTrue(drvr._has_uefi_support())",
            "",
            "    def test_get_guest_config_with_uefi(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_firmware_type\": \"uefi\"}})",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        with test.nested(",
            "                mock.patch.object(drvr, \"_has_uefi_support\",",
            "                                  return_value=True)):",
            "            cfg = drvr._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info)",
            "            self.assertEqual(cfg.os_loader_type, \"pflash\")",
            "",
            "    def test_get_guest_config_with_block_device(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        conn_info = {'driver_volume_type': 'fake'}",
            "        bdms = block_device_obj.block_device_make_list_from_dicts(",
            "            self.context, [",
            "                fake_block_device.FakeDbBlockDeviceDict(",
            "                    {'id': 1,",
            "                     'source_type': 'volume', 'destination_type': 'volume',",
            "                     'device_name': '/dev/vdc'}),",
            "                fake_block_device.FakeDbBlockDeviceDict(",
            "                    {'id': 2,",
            "                     'source_type': 'volume', 'destination_type': 'volume',",
            "                     'device_name': '/dev/vdd'}),",
            "            ]",
            "        )",
            "        info = {'block_device_mapping': driver_block_device.convert_volumes(",
            "            bdms",
            "        )}",
            "        info['block_device_mapping'][0]['connection_info'] = conn_info",
            "        info['block_device_mapping'][1]['connection_info'] = conn_info",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta,",
            "                                            info)",
            "        with mock.patch.object(",
            "                driver_block_device.DriverVolumeBlockDevice, 'save'",
            "        ) as mock_save:",
            "            cfg = drvr._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info,",
            "                                         None, info)",
            "            self.assertIsInstance(cfg.devices[2],",
            "                                  vconfig.LibvirtConfigGuestDisk)",
            "            self.assertEqual(cfg.devices[2].target_dev, 'vdc')",
            "            self.assertIsInstance(cfg.devices[3],",
            "                                  vconfig.LibvirtConfigGuestDisk)",
            "            self.assertEqual(cfg.devices[3].target_dev, 'vdd')",
            "            mock_save.assert_called_with()",
            "",
            "    def test_get_guest_config_lxc_with_attached_volume(self):",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        conn_info = {'driver_volume_type': 'fake'}",
            "        bdms = block_device_obj.block_device_make_list_from_dicts(",
            "            self.context, [",
            "              fake_block_device.FakeDbBlockDeviceDict(",
            "                    {'id': 1,",
            "                     'source_type': 'volume', 'destination_type': 'volume',",
            "                     'boot_index': 0}),",
            "              fake_block_device.FakeDbBlockDeviceDict(",
            "                    {'id': 2,",
            "                     'source_type': 'volume', 'destination_type': 'volume',",
            "                    }),",
            "              fake_block_device.FakeDbBlockDeviceDict(",
            "                    {'id': 3,",
            "                     'source_type': 'volume', 'destination_type': 'volume',",
            "                    }),",
            "           ]",
            "        )",
            "        info = {'block_device_mapping': driver_block_device.convert_volumes(",
            "            bdms",
            "        )}",
            "",
            "        info['block_device_mapping'][0]['connection_info'] = conn_info",
            "        info['block_device_mapping'][1]['connection_info'] = conn_info",
            "        info['block_device_mapping'][2]['connection_info'] = conn_info",
            "        info['block_device_mapping'][0]['mount_device'] = '/dev/vda'",
            "        info['block_device_mapping'][1]['mount_device'] = '/dev/vdc'",
            "        info['block_device_mapping'][2]['mount_device'] = '/dev/vdd'",
            "        with mock.patch.object(",
            "                driver_block_device.DriverVolumeBlockDevice, 'save'",
            "        ) as mock_save:",
            "            disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                                instance_ref,",
            "                                                image_meta,",
            "                                                info)",
            "            cfg = drvr._get_guest_config(instance_ref, [],",
            "                                         image_meta, disk_info,",
            "                                         None, info)",
            "            self.assertIsInstance(cfg.devices[1],",
            "                                  vconfig.LibvirtConfigGuestDisk)",
            "            self.assertEqual(cfg.devices[1].target_dev, 'vdc')",
            "            self.assertIsInstance(cfg.devices[2],",
            "                                  vconfig.LibvirtConfigGuestDisk)",
            "            self.assertEqual(cfg.devices[2].target_dev, 'vdd')",
            "            mock_save.assert_called_with()",
            "",
            "    def test_get_guest_config_with_configdrive(self):",
            "        # It's necessary to check if the architecture is power, because",
            "        # power doesn't have support to ide, and so libvirt translate",
            "        # all ide calls to scsi",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        # make configdrive.required_by() return True",
            "        instance_ref['config_drive'] = True",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "",
            "        # The last device is selected for this. on x86 is the last ide",
            "        # device (hdd). Since power only support scsi, the last device",
            "        # is sdz",
            "",
            "        expect = {\"ppc\": \"sdz\", \"ppc64\": \"sdz\"}",
            "        disk = expect.get(blockinfo.libvirt_utils.get_arch({}), \"hdd\")",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertEqual(cfg.devices[2].target_dev, disk)",
            "",
            "    def test_get_guest_config_with_virtio_scsi_bus(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_scsi_model\": \"virtio-scsi\"}})",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta,",
            "                                            [])",
            "        cfg = drvr._get_guest_config(instance_ref, [], image_meta, disk_info)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                         vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                         vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                         vconfig.LibvirtConfigGuestController)",
            "        self.assertEqual(cfg.devices[2].model, 'virtio-scsi')",
            "",
            "    def test_get_guest_config_with_virtio_scsi_bus_bdm(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_scsi_model\": \"virtio-scsi\"}})",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        conn_info = {'driver_volume_type': 'fake'}",
            "        bdms = block_device_obj.block_device_make_list_from_dicts(",
            "            self.context, [",
            "                fake_block_device.FakeDbBlockDeviceDict(",
            "                    {'id': 1,",
            "                     'source_type': 'volume', 'destination_type': 'volume',",
            "                     'device_name': '/dev/sdc', 'disk_bus': 'scsi'}),",
            "                fake_block_device.FakeDbBlockDeviceDict(",
            "                    {'id': 2,",
            "                     'source_type': 'volume', 'destination_type': 'volume',",
            "                     'device_name': '/dev/sdd', 'disk_bus': 'scsi'}),",
            "                ]",
            "        )",
            "        bd_info = {",
            "            'block_device_mapping': driver_block_device.convert_volumes(bdms)}",
            "        bd_info['block_device_mapping'][0]['connection_info'] = conn_info",
            "        bd_info['block_device_mapping'][1]['connection_info'] = conn_info",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta,",
            "                                            bd_info)",
            "        with mock.patch.object(",
            "                driver_block_device.DriverVolumeBlockDevice, 'save'",
            "        ) as mock_save:",
            "            cfg = drvr._get_guest_config(instance_ref, [], image_meta,",
            "                    disk_info, [], bd_info)",
            "            self.assertIsInstance(cfg.devices[2],",
            "                             vconfig.LibvirtConfigGuestDisk)",
            "            self.assertEqual(cfg.devices[2].target_dev, 'sdc')",
            "            self.assertEqual(cfg.devices[2].target_bus, 'scsi')",
            "            self.assertIsInstance(cfg.devices[3],",
            "                             vconfig.LibvirtConfigGuestDisk)",
            "            self.assertEqual(cfg.devices[3].target_dev, 'sdd')",
            "            self.assertEqual(cfg.devices[3].target_bus, 'scsi')",
            "            self.assertIsInstance(cfg.devices[4],",
            "                             vconfig.LibvirtConfigGuestController)",
            "            self.assertEqual(cfg.devices[4].model, 'virtio-scsi')",
            "            mock_save.assert_called_with()",
            "",
            "    def test_get_guest_config_with_vnc(self):",
            "        self.flags(enabled=True, group='vnc')",
            "        self.flags(virt_type='kvm',",
            "                   use_usb_tablet=False,",
            "                   group='libvirt')",
            "        self.flags(enabled=False, group='spice')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 7)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[4].type, \"vnc\")",
            "",
            "    def test_get_guest_config_with_vnc_and_tablet(self):",
            "        self.flags(enabled=True, group='vnc')",
            "        self.flags(virt_type='kvm',",
            "                   use_usb_tablet=True,",
            "                   group='libvirt')",
            "        self.flags(enabled=False, group='spice')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 8)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[4].type, \"tablet\")",
            "        self.assertEqual(cfg.devices[5].type, \"vnc\")",
            "",
            "    def test_get_guest_config_with_spice_and_tablet(self):",
            "        self.flags(enabled=False, group='vnc')",
            "        self.flags(virt_type='kvm',",
            "                   use_usb_tablet=True,",
            "                   group='libvirt')",
            "        self.flags(enabled=True,",
            "                   agent_enabled=False,",
            "                   group='spice')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 8)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[4].type, \"tablet\")",
            "        self.assertEqual(cfg.devices[5].type, \"spice\")",
            "",
            "    def test_get_guest_config_with_spice_and_agent(self):",
            "        self.flags(enabled=False, group='vnc')",
            "        self.flags(virt_type='kvm',",
            "                   use_usb_tablet=True,",
            "                   group='libvirt')",
            "        self.flags(enabled=True,",
            "                   agent_enabled=True,",
            "                   group='spice')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 8)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestChannel)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[4].target_name, \"com.redhat.spice.0\")",
            "        self.assertEqual(cfg.devices[5].type, \"spice\")",
            "        self.assertEqual(cfg.devices[6].type, \"qxl\")",
            "",
            "    @mock.patch('nova.console.serial.acquire_port')",
            "    @mock.patch('nova.virt.hardware.get_number_of_serial_ports',",
            "                return_value=1)",
            "    @mock.patch.object(libvirt_driver.libvirt_utils, 'get_arch',)",
            "    def test_create_serial_console_devices_based_on_arch(self, mock_get_arch,",
            "                                           mock_get_port_number,",
            "                                           mock_acquire_port):",
            "        self.flags(enabled=True, group='serial_console')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        expected = {arch.X86_64: vconfig.LibvirtConfigGuestSerial,",
            "                    arch.S390: vconfig.LibvirtConfigGuestConsole,",
            "                    arch.S390X: vconfig.LibvirtConfigGuestConsole}",
            "",
            "        for guest_arch, device_type in expected.items():",
            "            mock_get_arch.return_value = guest_arch",
            "            guest = vconfig.LibvirtConfigGuest()",
            "            drvr._create_serial_console_devices(guest, instance=None,",
            "                                                flavor={}, image_meta={})",
            "            self.assertEqual(1, len(guest.devices))",
            "            console_device = guest.devices[0]",
            "            self.assertIsInstance(console_device, device_type)",
            "            self.assertEqual(\"tcp\", console_device.type)",
            "",
            "    @mock.patch('nova.console.serial.acquire_port')",
            "    def test_get_guest_config_serial_console(self, acquire_port):",
            "        self.flags(enabled=True, group='serial_console')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        acquire_port.return_value = 11111",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(8, len(cfg.devices))",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(\"tcp\", cfg.devices[2].type)",
            "        self.assertEqual(11111, cfg.devices[2].listen_port)",
            "",
            "    def test_get_guest_config_serial_console_through_flavor(self):",
            "        self.flags(enabled=True, group='serial_console')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'hw:serial_port_count': 3}",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(10, len(cfg.devices))",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[8],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[9],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(\"tcp\", cfg.devices[2].type)",
            "        self.assertEqual(\"tcp\", cfg.devices[3].type)",
            "        self.assertEqual(\"tcp\", cfg.devices[4].type)",
            "",
            "    def test_get_guest_config_serial_console_invalid_flavor(self):",
            "        self.flags(enabled=True, group='serial_console')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'hw:serial_port_count': \"a\"}",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        self.assertRaises(",
            "            exception.ImageSerialPortNumberInvalid,",
            "            drvr._get_guest_config, instance_ref, [],",
            "            image_meta, disk_info)",
            "",
            "    def test_get_guest_config_serial_console_image_and_flavor(self):",
            "        self.flags(enabled=True, group='serial_console')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_serial_port_count\": \"3\"}})",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'hw:serial_port_count': 4}",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [], image_meta,",
            "                                     disk_info)",
            "        self.assertEqual(10, len(cfg.devices), cfg.devices)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[8],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[9],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(\"tcp\", cfg.devices[2].type)",
            "        self.assertEqual(\"tcp\", cfg.devices[3].type)",
            "        self.assertEqual(\"tcp\", cfg.devices[4].type)",
            "",
            "    @mock.patch('nova.console.serial.acquire_port')",
            "    def test_get_guest_config_serial_console_through_port_rng_exhausted(",
            "            self, acquire_port):",
            "        self.flags(enabled=True, group='serial_console')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        acquire_port.side_effect = exception.SocketPortRangeExhaustedException(",
            "            '127.0.0.1')",
            "        self.assertRaises(",
            "            exception.SocketPortRangeExhaustedException,",
            "            drvr._get_guest_config, instance_ref, [],",
            "            image_meta, disk_info)",
            "",
            "    @mock.patch('os.path.getsize', return_value=0)  # size doesn't matter",
            "    @mock.patch('nova.virt.libvirt.storage.lvm.get_volume_size',",
            "                return_value='fake-size')",
            "    def test_detach_encrypted_volumes(self, mock_getsize,",
            "                                      mock_get_volume_size):",
            "        \"\"\"Test that unencrypted volumes are not disconnected with dmcrypt.\"\"\"",
            "        instance = objects.Instance(**self.test_instance)",
            "        xml = \"\"\"",
            "              <domain type='kvm'>",
            "                  <devices>",
            "                      <disk type='file'>",
            "                          <driver name='fake-driver' type='fake-type' />",
            "                          <source file='filename'/>",
            "                          <target dev='vdc' bus='virtio'/>",
            "                      </disk>",
            "                      <disk type='block' device='disk'>",
            "                          <driver name='fake-driver' type='fake-type' />",
            "                          <source dev='/dev/mapper/disk'/>",
            "                          <target dev='vda'/>",
            "                      </disk>",
            "                      <disk type='block' device='disk'>",
            "                          <driver name='fake-driver' type='fake-type' />",
            "                          <source dev='/dev/mapper/swap'/>",
            "                          <target dev='vdb'/>",
            "                      </disk>",
            "                  </devices>",
            "              </domain>",
            "              \"\"\"",
            "        dom = FakeVirtDomain(fake_xml=xml)",
            "        instance.ephemeral_key_uuid = 'fake-id'  # encrypted",
            "",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        @mock.patch.object(dmcrypt, 'delete_volume')",
            "        @mock.patch.object(conn._host, 'get_domain', return_value=dom)",
            "        def detach_encrypted_volumes(block_device_info, mock_get_domain,",
            "                                     mock_delete_volume):",
            "            conn._detach_encrypted_volumes(instance, block_device_info)",
            "",
            "            mock_get_domain.assert_called_once_with(instance)",
            "            self.assertFalse(mock_delete_volume.called)",
            "",
            "        block_device_info = {'root_device_name': '/dev/vda',",
            "                             'ephemerals': [],",
            "                             'block_device_mapping': []}",
            "",
            "        detach_encrypted_volumes(block_device_info)",
            "",
            "    @mock.patch.object(libvirt_guest.Guest, \"get_xml_desc\")",
            "    def test_get_serial_ports_from_guest(self, mock_get_xml_desc):",
            "        i = self._test_get_serial_ports_from_guest(None,",
            "                                                   mock_get_xml_desc)",
            "        self.assertEqual([",
            "            ('127.0.0.1', 100),",
            "            ('127.0.0.1', 101),",
            "            ('127.0.0.2', 100),",
            "            ('127.0.0.2', 101)], list(i))",
            "",
            "    @mock.patch.object(libvirt_guest.Guest, \"get_xml_desc\")",
            "    def test_get_serial_ports_from_guest_bind_only(self, mock_get_xml_desc):",
            "        i = self._test_get_serial_ports_from_guest('bind',",
            "                                                   mock_get_xml_desc)",
            "        self.assertEqual([",
            "            ('127.0.0.1', 101),",
            "            ('127.0.0.2', 100)], list(i))",
            "",
            "    @mock.patch.object(libvirt_guest.Guest, \"get_xml_desc\")",
            "    def test_get_serial_ports_from_guest_connect_only(self,",
            "                                                      mock_get_xml_desc):",
            "        i = self._test_get_serial_ports_from_guest('connect',",
            "                                                   mock_get_xml_desc)",
            "        self.assertEqual([",
            "            ('127.0.0.1', 100),",
            "            ('127.0.0.2', 101)], list(i))",
            "",
            "    @mock.patch.object(libvirt_guest.Guest, \"get_xml_desc\")",
            "    def test_get_serial_ports_from_guest_on_s390(self, mock_get_xml_desc):",
            "        i = self._test_get_serial_ports_from_guest(None,",
            "                                                   mock_get_xml_desc,",
            "                                                   'console')",
            "        self.assertEqual([",
            "            ('127.0.0.1', 100),",
            "            ('127.0.0.1', 101),",
            "            ('127.0.0.2', 100),",
            "            ('127.0.0.2', 101)], list(i))",
            "",
            "    def _test_get_serial_ports_from_guest(self, mode, mock_get_xml_desc,",
            "                                          dev_name='serial'):",
            "        xml = \"\"\"",
            "        <domain type='kvm'>",
            "          <devices>",
            "            <%(dev_name)s type=\"tcp\">",
            "              <source host=\"127.0.0.1\" service=\"100\" mode=\"connect\"/>",
            "            </%(dev_name)s>",
            "            <%(dev_name)s type=\"tcp\">",
            "              <source host=\"127.0.0.1\" service=\"101\" mode=\"bind\"/>",
            "            </%(dev_name)s>",
            "            <%(dev_name)s type=\"tcp\">",
            "              <source host=\"127.0.0.2\" service=\"100\" mode=\"bind\"/>",
            "            </%(dev_name)s>",
            "            <%(dev_name)s type=\"tcp\">",
            "              <source host=\"127.0.0.2\" service=\"101\" mode=\"connect\"/>",
            "            </%(dev_name)s>",
            "          </devices>",
            "        </domain>\"\"\" % {'dev_name': dev_name}",
            "",
            "        mock_get_xml_desc.return_value = xml",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        guest = libvirt_guest.Guest(FakeVirtDomain())",
            "        return drvr._get_serial_ports_from_guest(guest, mode=mode)",
            "",
            "    def test_get_guest_config_with_type_xen(self):",
            "        self.flags(enabled=True, group='vnc')",
            "        self.flags(virt_type='xen',",
            "                   use_usb_tablet=False,",
            "                   group='libvirt')",
            "        self.flags(enabled=False,",
            "                   group='spice')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 6)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestConsole)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[3].type, \"vnc\")",
            "        self.assertEqual(cfg.devices[4].type, \"xen\")",
            "",
            "    @mock.patch.object(libvirt_driver.libvirt_utils, 'get_arch',",
            "                       return_value=arch.S390X)",
            "    def test_get_guest_config_with_type_kvm_on_s390(self, mock_get_arch):",
            "        self.flags(enabled=False, group='vnc')",
            "        self.flags(virt_type='kvm',",
            "                   use_usb_tablet=False,",
            "                   group='libvirt')",
            "",
            "        self._stub_host_capabilities_cpu_arch(arch.S390X)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "",
            "        cfg = self._get_guest_config_via_fake_api(instance_ref)",
            "",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        log_file_device = cfg.devices[2]",
            "        self.assertIsInstance(log_file_device,",
            "                              vconfig.LibvirtConfigGuestConsole)",
            "        self.assertEqual(\"sclplm\", log_file_device.target_type)",
            "        self.assertEqual(\"file\", log_file_device.type)",
            "        terminal_device = cfg.devices[3]",
            "        self.assertIsInstance(terminal_device,",
            "                              vconfig.LibvirtConfigGuestConsole)",
            "        self.assertEqual(\"sclp\", terminal_device.target_type)",
            "        self.assertEqual(\"pty\", terminal_device.type)",
            "        self.assertEqual(\"s390-ccw-virtio\", cfg.os_mach_type)",
            "",
            "    def _stub_host_capabilities_cpu_arch(self, cpu_arch):",
            "        def get_host_capabilities_stub(self):",
            "            cpu = vconfig.LibvirtConfigGuestCPU()",
            "            cpu.arch = cpu_arch",
            "",
            "            caps = vconfig.LibvirtConfigCaps()",
            "            caps.host = vconfig.LibvirtConfigCapsHost()",
            "            caps.host.cpu = cpu",
            "            return caps",
            "",
            "        self.stubs.Set(host.Host, \"get_capabilities\",",
            "                       get_host_capabilities_stub)",
            "",
            "    def _get_guest_config_via_fake_api(self, instance):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta)",
            "        return drvr._get_guest_config(instance, [],",
            "                                      image_meta, disk_info)",
            "",
            "    def test_get_guest_config_with_type_xen_pae_hvm(self):",
            "        self.flags(enabled=True, group='vnc')",
            "        self.flags(virt_type='xen',",
            "                   use_usb_tablet=False,",
            "                   group='libvirt')",
            "        self.flags(enabled=False,",
            "                   group='spice')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref['vm_mode'] = vm_mode.HVM",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "",
            "        self.assertEqual(cfg.os_type, vm_mode.HVM)",
            "        self.assertEqual(cfg.os_loader, CONF.libvirt.xen_hvmloader_path)",
            "        self.assertEqual(3, len(cfg.features))",
            "        self.assertIsInstance(cfg.features[0],",
            "                              vconfig.LibvirtConfigGuestFeaturePAE)",
            "        self.assertIsInstance(cfg.features[1],",
            "                              vconfig.LibvirtConfigGuestFeatureACPI)",
            "        self.assertIsInstance(cfg.features[2],",
            "                              vconfig.LibvirtConfigGuestFeatureAPIC)",
            "",
            "    def test_get_guest_config_with_type_xen_pae_pvm(self):",
            "        self.flags(enabled=True, group='vnc')",
            "        self.flags(virt_type='xen',",
            "                   use_usb_tablet=False,",
            "                   group='libvirt')",
            "        self.flags(enabled=False,",
            "                   group='spice')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "",
            "        self.assertEqual(cfg.os_type, vm_mode.XEN)",
            "        self.assertEqual(1, len(cfg.features))",
            "        self.assertIsInstance(cfg.features[0],",
            "                              vconfig.LibvirtConfigGuestFeaturePAE)",
            "",
            "    def test_get_guest_config_with_vnc_and_spice(self):",
            "        self.flags(enabled=True, group='vnc')",
            "        self.flags(virt_type='kvm',",
            "                   use_usb_tablet=True,",
            "                   group='libvirt')",
            "        self.flags(enabled=True,",
            "                   agent_enabled=True,",
            "                   group='spice')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 10)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestChannel)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[8],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[9],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[4].type, \"tablet\")",
            "        self.assertEqual(cfg.devices[5].target_name, \"com.redhat.spice.0\")",
            "        self.assertEqual(cfg.devices[6].type, \"vnc\")",
            "        self.assertEqual(cfg.devices[7].type, \"spice\")",
            "",
            "    def test_get_guest_config_with_watchdog_action_image_meta(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_watchdog_action\": \"none\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [], image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 9)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigGuestWatchdog)",
            "        self.assertIsInstance(cfg.devices[8],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(\"none\", cfg.devices[7].action)",
            "",
            "    def _test_get_guest_usb_tablet(self, vnc_enabled, spice_enabled, os_type,",
            "                                   agent_enabled=False):",
            "        self.flags(enabled=vnc_enabled, group='vnc')",
            "        self.flags(enabled=spice_enabled,",
            "                   agent_enabled=agent_enabled, group='spice')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        return drvr._get_guest_usb_tablet(os_type)",
            "",
            "    def test_get_guest_usb_tablet_wipe(self):",
            "        self.flags(use_usb_tablet=True, group='libvirt')",
            "",
            "        tablet = self._test_get_guest_usb_tablet(True, True, vm_mode.HVM)",
            "        self.assertIsNotNone(tablet)",
            "",
            "        tablet = self._test_get_guest_usb_tablet(True, False, vm_mode.HVM)",
            "        self.assertIsNotNone(tablet)",
            "",
            "        tablet = self._test_get_guest_usb_tablet(False, True, vm_mode.HVM)",
            "        self.assertIsNotNone(tablet)",
            "",
            "        tablet = self._test_get_guest_usb_tablet(False, False, vm_mode.HVM)",
            "        self.assertIsNone(tablet)",
            "",
            "        tablet = self._test_get_guest_usb_tablet(True, True, \"foo\")",
            "        self.assertIsNone(tablet)",
            "",
            "        tablet = self._test_get_guest_usb_tablet(",
            "            False, True, vm_mode.HVM, True)",
            "        self.assertIsNone(tablet)",
            "",
            "    def _test_get_guest_config_with_watchdog_action_flavor(self,",
            "            hw_watchdog_action=\"hw:watchdog_action\"):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {hw_watchdog_action: 'none'}",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "",
            "        self.assertEqual(9, len(cfg.devices))",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                            vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigGuestWatchdog)",
            "        self.assertIsInstance(cfg.devices[8],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(\"none\", cfg.devices[7].action)",
            "",
            "    def test_get_guest_config_with_watchdog_action_through_flavor(self):",
            "        self._test_get_guest_config_with_watchdog_action_flavor()",
            "",
            "    # TODO(pkholkin): the test accepting old property name 'hw_watchdog_action'",
            "    #                should be removed in the next release",
            "    def test_get_guest_config_with_watchdog_action_through_flavor_no_scope(",
            "            self):",
            "        self._test_get_guest_config_with_watchdog_action_flavor(",
            "            hw_watchdog_action=\"hw_watchdog_action\")",
            "",
            "    def test_get_guest_config_with_watchdog_overrides_flavor(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'hw_watchdog_action': 'none'}",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_watchdog_action\": \"pause\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "",
            "        self.assertEqual(9, len(cfg.devices))",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigGuestWatchdog)",
            "        self.assertIsInstance(cfg.devices[8],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(\"pause\", cfg.devices[7].action)",
            "",
            "    def test_get_guest_config_with_video_driver_image_meta(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_video_model\": \"vmvga\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [], image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 8)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[5].type, \"vnc\")",
            "        self.assertEqual(cfg.devices[6].type, \"vmvga\")",
            "",
            "    def test_get_guest_config_with_qga_through_image_meta(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_qemu_guest_agent\": \"yes\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [], image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 9)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigGuestChannel)",
            "        self.assertIsInstance(cfg.devices[8],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[4].type, \"tablet\")",
            "        self.assertEqual(cfg.devices[5].type, \"vnc\")",
            "        self.assertEqual(cfg.devices[7].type, \"unix\")",
            "        self.assertEqual(cfg.devices[7].target_name, \"org.qemu.guest_agent.0\")",
            "",
            "    def test_get_guest_config_with_video_driver_vram(self):",
            "        self.flags(enabled=False, group='vnc')",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        self.flags(enabled=True,",
            "                   agent_enabled=True,",
            "                   group='spice')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'hw_video:ram_max_mb': \"100\"}",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_video_model\": \"qxl\",",
            "                           \"hw_video_ram\": \"64\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 8)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestChannel)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[5].type, \"spice\")",
            "        self.assertEqual(cfg.devices[6].type, \"qxl\")",
            "        self.assertEqual(cfg.devices[6].vram, 64 * units.Mi / units.Ki)",
            "",
            "    @mock.patch('nova.virt.disk.api.teardown_container')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.get_info')",
            "    @mock.patch('nova.virt.disk.api.setup_container')",
            "    @mock.patch('oslo_utils.fileutils.ensure_tree')",
            "    @mock.patch.object(fake_libvirt_utils, 'get_instance_path')",
            "    def test_unmount_fs_if_error_during_lxc_create_domain(self,",
            "            mock_get_inst_path, mock_ensure_tree, mock_setup_container,",
            "            mock_get_info, mock_teardown):",
            "        \"\"\"If we hit an error during a `_create_domain` call to `libvirt+lxc`",
            "        we need to ensure the guest FS is unmounted from the host so that any",
            "        future `lvremove` calls will work.",
            "        \"\"\"",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        mock_instance = mock.MagicMock()",
            "        mock_get_inst_path.return_value = '/tmp/'",
            "        mock_image_backend = mock.MagicMock()",
            "        drvr.image_backend = mock_image_backend",
            "        mock_image = mock.MagicMock()",
            "        mock_image.path = '/tmp/test.img'",
            "        drvr.image_backend.image.return_value = mock_image",
            "        mock_setup_container.return_value = '/dev/nbd0'",
            "        mock_get_info.side_effect = exception.InstanceNotFound(",
            "                                                   instance_id='foo')",
            "        drvr._conn.defineXML = mock.Mock()",
            "        drvr._conn.defineXML.side_effect = ValueError('somethingbad')",
            "        with test.nested(",
            "              mock.patch.object(drvr, '_is_booted_from_volume',",
            "                                return_value=False),",
            "              mock.patch.object(drvr, 'plug_vifs'),",
            "              mock.patch.object(drvr, 'firewall_driver'),",
            "              mock.patch.object(drvr, 'cleanup')):",
            "            self.assertRaises(ValueError,",
            "                              drvr._create_domain_and_network,",
            "                              self.context,",
            "                              'xml',",
            "                              mock_instance, None, None)",
            "",
            "            mock_teardown.assert_called_with(container_dir='/tmp/rootfs')",
            "",
            "    def test_video_driver_flavor_limit_not_set(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        self.flags(enabled=True,",
            "                   agent_enabled=True,",
            "                   group='spice')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_video_model\": \"qxl\",",
            "                           \"hw_video_ram\": \"64\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        with mock.patch.object(objects.Instance, 'save'):",
            "            self.assertRaises(exception.RequestedVRamTooHigh,",
            "                              drvr._get_guest_config,",
            "                              instance_ref,",
            "                              [],",
            "                              image_meta,",
            "                              disk_info)",
            "",
            "    def test_video_driver_ram_above_flavor_limit(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        self.flags(enabled=True,",
            "                   agent_enabled=True,",
            "                   group='spice')",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_type = instance_ref.get_flavor()",
            "        instance_type.extra_specs = {'hw_video:ram_max_mb': \"50\"}",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_video_model\": \"qxl\",",
            "                           \"hw_video_ram\": \"64\"}})",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        with mock.patch.object(objects.Instance, 'save'):",
            "            self.assertRaises(exception.RequestedVRamTooHigh,",
            "                              drvr._get_guest_config,",
            "                              instance_ref,",
            "                              [],",
            "                              image_meta,",
            "                              disk_info)",
            "",
            "    def test_get_guest_config_without_qga_through_image_meta(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_qemu_guest_agent\": \"no\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [], image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 8)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[4].type, \"tablet\")",
            "        self.assertEqual(cfg.devices[5].type, \"vnc\")",
            "",
            "    def test_get_guest_config_with_rng_device(self):",
            "        self.flags(virt_type='kvm',",
            "                   use_usb_tablet=False,",
            "                   group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'hw_rng:allowed': 'True'}",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_rng_model\": \"virtio\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 8)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                            vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestRng)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[6].model, 'random')",
            "        self.assertIsNone(cfg.devices[6].backend)",
            "        self.assertIsNone(cfg.devices[6].rate_bytes)",
            "        self.assertIsNone(cfg.devices[6].rate_period)",
            "",
            "    def test_get_guest_config_with_rng_not_allowed(self):",
            "        self.flags(virt_type='kvm',",
            "                   use_usb_tablet=False,",
            "                   group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_rng_model\": \"virtio\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 7)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "    def test_get_guest_config_with_rng_limits(self):",
            "        self.flags(virt_type='kvm',",
            "                   use_usb_tablet=False,",
            "                   group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'hw_rng:allowed': 'True',",
            "                                           'hw_rng:rate_bytes': '1024',",
            "                                           'hw_rng:rate_period': '2'}",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_rng_model\": \"virtio\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 8)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestRng)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                            vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[6].model, 'random')",
            "        self.assertIsNone(cfg.devices[6].backend)",
            "        self.assertEqual(cfg.devices[6].rate_bytes, 1024)",
            "        self.assertEqual(cfg.devices[6].rate_period, 2)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.os.path.exists')",
            "    def test_get_guest_config_with_rng_backend(self, mock_path):",
            "        self.flags(virt_type='kvm',",
            "                   use_usb_tablet=False,",
            "                   rng_dev_path='/dev/hw_rng',",
            "                   group='libvirt')",
            "        mock_path.return_value = True",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'hw_rng:allowed': 'True'}",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_rng_model\": \"virtio\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(len(cfg.devices), 8)",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[1],",
            "                            vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestSerial)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "        self.assertIsInstance(cfg.devices[6],",
            "                              vconfig.LibvirtConfigGuestRng)",
            "        self.assertIsInstance(cfg.devices[7],",
            "                              vconfig.LibvirtConfigMemoryBalloon)",
            "",
            "        self.assertEqual(cfg.devices[6].model, 'random')",
            "        self.assertEqual(cfg.devices[6].backend, '/dev/hw_rng')",
            "        self.assertIsNone(cfg.devices[6].rate_bytes)",
            "        self.assertIsNone(cfg.devices[6].rate_period)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.os.path.exists')",
            "    def test_get_guest_config_with_rng_dev_not_present(self, mock_path):",
            "        self.flags(virt_type='kvm',",
            "                   use_usb_tablet=False,",
            "                   rng_dev_path='/dev/hw_rng',",
            "                   group='libvirt')",
            "        mock_path.return_value = False",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'hw_rng:allowed': 'True'}",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_rng_model\": \"virtio\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        self.assertRaises(exception.RngDeviceNotExist,",
            "                          drvr._get_guest_config,",
            "                          instance_ref,",
            "                          [],",
            "                          image_meta, disk_info)",
            "",
            "    @mock.patch.object(",
            "        host.Host, \"is_cpu_control_policy_capable\", return_value=True)",
            "    def test_guest_cpu_shares_with_multi_vcpu(self, is_able):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.vcpus = 4",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "",
            "        self.assertEqual(4096, cfg.cputune.shares)",
            "",
            "    @mock.patch.object(",
            "        host.Host, \"is_cpu_control_policy_capable\", return_value=True)",
            "    def test_get_guest_config_with_cpu_quota(self, is_able):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'quota:cpu_shares': '10000',",
            "                                           'quota:cpu_period': '20000'}",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "",
            "        self.assertEqual(10000, cfg.cputune.shares)",
            "        self.assertEqual(20000, cfg.cputune.period)",
            "",
            "    @mock.patch.object(",
            "        host.Host, \"is_cpu_control_policy_capable\", return_value=True)",
            "    def test_get_guest_config_with_bogus_cpu_quota(self, is_able):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'quota:cpu_shares': 'fishfood',",
            "                                           'quota:cpu_period': '20000'}",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        self.assertRaises(ValueError,",
            "                          drvr._get_guest_config,",
            "                          instance_ref, [], image_meta, disk_info)",
            "",
            "    @mock.patch.object(",
            "        host.Host, \"is_cpu_control_policy_capable\", return_value=False)",
            "    def test_get_update_guest_cputune(self, is_able):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = {'quota:cpu_shares': '10000',",
            "                                           'quota:cpu_period': '20000'}",
            "        self.assertRaises(",
            "            exception.UnsupportedHostCPUControlPolicy,",
            "            drvr._update_guest_cputune, {}, instance_ref.flavor, \"kvm\")",
            "",
            "    def _test_get_guest_config_sysinfo_serial(self, expected_serial):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "",
            "        cfg = drvr._get_guest_config_sysinfo(instance_ref)",
            "",
            "        self.assertIsInstance(cfg, vconfig.LibvirtConfigGuestSysinfo)",
            "        self.assertEqual(version.vendor_string(),",
            "                         cfg.system_manufacturer)",
            "        self.assertEqual(version.product_string(),",
            "                         cfg.system_product)",
            "        self.assertEqual(version.version_string_with_package(),",
            "                         cfg.system_version)",
            "        self.assertEqual(expected_serial,",
            "                         cfg.system_serial)",
            "        self.assertEqual(instance_ref['uuid'],",
            "                         cfg.system_uuid)",
            "        self.assertEqual(\"Virtual Machine\",",
            "                         cfg.system_family)",
            "",
            "    def test_get_guest_config_sysinfo_serial_none(self):",
            "        self.flags(sysinfo_serial=\"none\", group=\"libvirt\")",
            "        self._test_get_guest_config_sysinfo_serial(None)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver,",
            "                       \"_get_host_sysinfo_serial_hardware\")",
            "    def test_get_guest_config_sysinfo_serial_hardware(self, mock_uuid):",
            "        self.flags(sysinfo_serial=\"hardware\", group=\"libvirt\")",
            "",
            "        theuuid = \"56b40135-a973-4eb3-87bb-a2382a3e6dbc\"",
            "        mock_uuid.return_value = theuuid",
            "",
            "        self._test_get_guest_config_sysinfo_serial(theuuid)",
            "",
            "    @contextlib.contextmanager",
            "    def patch_exists(self, result):",
            "        real_exists = os.path.exists",
            "",
            "        def fake_exists(filename):",
            "            if filename == \"/etc/machine-id\":",
            "                return result",
            "            return real_exists(filename)",
            "",
            "        with mock.patch.object(os.path, \"exists\") as mock_exists:",
            "            mock_exists.side_effect = fake_exists",
            "            yield mock_exists",
            "",
            "    def test_get_guest_config_sysinfo_serial_os(self):",
            "        self.flags(sysinfo_serial=\"os\", group=\"libvirt\")",
            "        theuuid = \"56b40135-a973-4eb3-87bb-a2382a3e6dbc\"",
            "        with test.nested(",
            "                mock.patch.object(six.moves.builtins, \"open\",",
            "                    mock.mock_open(read_data=theuuid)),",
            "                self.patch_exists(True)):",
            "            self._test_get_guest_config_sysinfo_serial(theuuid)",
            "",
            "    def test_get_guest_config_sysinfo_serial_os_empty_machine_id(self):",
            "        self.flags(sysinfo_serial=\"os\", group=\"libvirt\")",
            "        with test.nested(",
            "                mock.patch.object(six.moves.builtins, \"open\",",
            "                                  mock.mock_open(read_data=\"\")),",
            "                self.patch_exists(True)):",
            "            self.assertRaises(exception.NovaException,",
            "                    self._test_get_guest_config_sysinfo_serial,",
            "                    None)",
            "",
            "    def test_get_guest_config_sysinfo_serial_os_no_machine_id_file(self):",
            "        self.flags(sysinfo_serial=\"os\", group=\"libvirt\")",
            "        with self.patch_exists(False):",
            "            self.assertRaises(exception.NovaException,",
            "                    self._test_get_guest_config_sysinfo_serial,",
            "                    None)",
            "",
            "    def test_get_guest_config_sysinfo_serial_auto_hardware(self):",
            "        self.flags(sysinfo_serial=\"auto\", group=\"libvirt\")",
            "",
            "        real_exists = os.path.exists",
            "        with test.nested(",
            "                mock.patch.object(os.path, \"exists\"),",
            "                mock.patch.object(libvirt_driver.LibvirtDriver,",
            "                                  \"_get_host_sysinfo_serial_hardware\")",
            "        ) as (mock_exists, mock_uuid):",
            "            def fake_exists(filename):",
            "                if filename == \"/etc/machine-id\":",
            "                    return False",
            "                return real_exists(filename)",
            "",
            "            mock_exists.side_effect = fake_exists",
            "",
            "            theuuid = \"56b40135-a973-4eb3-87bb-a2382a3e6dbc\"",
            "            mock_uuid.return_value = theuuid",
            "",
            "            self._test_get_guest_config_sysinfo_serial(theuuid)",
            "",
            "    def test_get_guest_config_sysinfo_serial_auto_os(self):",
            "        self.flags(sysinfo_serial=\"auto\", group=\"libvirt\")",
            "",
            "        real_exists = os.path.exists",
            "        real_open = builtins.open",
            "        with test.nested(",
            "                mock.patch.object(os.path, \"exists\"),",
            "                mock.patch.object(builtins, \"open\"),",
            "        ) as (mock_exists, mock_open):",
            "            def fake_exists(filename):",
            "                if filename == \"/etc/machine-id\":",
            "                    return True",
            "                return real_exists(filename)",
            "",
            "            mock_exists.side_effect = fake_exists",
            "",
            "            theuuid = \"56b40135-a973-4eb3-87bb-a2382a3e6dbc\"",
            "",
            "            def fake_open(filename, *args, **kwargs):",
            "                if filename == \"/etc/machine-id\":",
            "                    h = mock.MagicMock()",
            "                    h.read.return_value = theuuid",
            "                    h.__enter__.return_value = h",
            "                    return h",
            "                return real_open(filename, *args, **kwargs)",
            "",
            "            mock_open.side_effect = fake_open",
            "",
            "            self._test_get_guest_config_sysinfo_serial(theuuid)",
            "",
            "    def _create_fake_service_compute(self):",
            "        service_info = {",
            "            'id': 1729,",
            "            'host': 'fake',",
            "            'report_count': 0",
            "        }",
            "        service_ref = objects.Service(**service_info)",
            "",
            "        compute_info = {",
            "            'id': 1729,",
            "            'vcpus': 2,",
            "            'memory_mb': 1024,",
            "            'local_gb': 2048,",
            "            'vcpus_used': 0,",
            "            'memory_mb_used': 0,",
            "            'local_gb_used': 0,",
            "            'free_ram_mb': 1024,",
            "            'free_disk_gb': 2048,",
            "            'hypervisor_type': 'xen',",
            "            'hypervisor_version': 1,",
            "            'running_vms': 0,",
            "            'cpu_info': '',",
            "            'current_workload': 0,",
            "            'service_id': service_ref['id'],",
            "            'host': service_ref['host']",
            "        }",
            "        compute_ref = objects.ComputeNode(**compute_info)",
            "        return (service_ref, compute_ref)",
            "",
            "    def test_get_guest_config_with_pci_passthrough_kvm(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        service_ref, compute_ref = self._create_fake_service_compute()",
            "",
            "        instance = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        pci_device_info = dict(test_pci_device.fake_db_dev)",
            "        pci_device_info.update(compute_node_id=1,",
            "                               label='fake',",
            "                               status=fields.PciDeviceStatus.ALLOCATED,",
            "                               address='0000:00:00.1',",
            "                               compute_id=compute_ref['id'],",
            "                               instance_uuid=instance.uuid,",
            "                               request_id=None,",
            "                               extra_info={})",
            "        pci_device = objects.PciDevice(**pci_device_info)",
            "        pci_list = objects.PciDeviceList()",
            "        pci_list.objects.append(pci_device)",
            "        instance.pci_devices = pci_list",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance, [],",
            "                                     image_meta, disk_info)",
            "",
            "        had_pci = 0",
            "        # care only about the PCI devices",
            "        for dev in cfg.devices:",
            "            if type(dev) == vconfig.LibvirtConfigGuestHostdevPCI:",
            "                had_pci += 1",
            "                self.assertEqual(dev.type, 'pci')",
            "                self.assertEqual(dev.managed, 'yes')",
            "                self.assertEqual(dev.mode, 'subsystem')",
            "",
            "                self.assertEqual(dev.domain, \"0000\")",
            "                self.assertEqual(dev.bus, \"00\")",
            "                self.assertEqual(dev.slot, \"00\")",
            "                self.assertEqual(dev.function, \"1\")",
            "        self.assertEqual(had_pci, 1)",
            "",
            "    def test_get_guest_config_with_pci_passthrough_xen(self):",
            "        self.flags(virt_type='xen', group='libvirt')",
            "        service_ref, compute_ref = self._create_fake_service_compute()",
            "",
            "        instance = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        pci_device_info = dict(test_pci_device.fake_db_dev)",
            "        pci_device_info.update(compute_node_id=1,",
            "                               label='fake',",
            "                               status=fields.PciDeviceStatus.ALLOCATED,",
            "                               address='0000:00:00.2',",
            "                               compute_id=compute_ref['id'],",
            "                               instance_uuid=instance.uuid,",
            "                               request_id=None,",
            "                               extra_info={})",
            "        pci_device = objects.PciDevice(**pci_device_info)",
            "        pci_list = objects.PciDeviceList()",
            "        pci_list.objects.append(pci_device)",
            "        instance.pci_devices = pci_list",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance, [],",
            "                                     image_meta, disk_info)",
            "        had_pci = 0",
            "        # care only about the PCI devices",
            "        for dev in cfg.devices:",
            "            if type(dev) == vconfig.LibvirtConfigGuestHostdevPCI:",
            "                had_pci += 1",
            "                self.assertEqual(dev.type, 'pci')",
            "                self.assertEqual(dev.managed, 'no')",
            "                self.assertEqual(dev.mode, 'subsystem')",
            "",
            "                self.assertEqual(dev.domain, \"0000\")",
            "                self.assertEqual(dev.bus, \"00\")",
            "                self.assertEqual(dev.slot, \"00\")",
            "                self.assertEqual(dev.function, \"2\")",
            "        self.assertEqual(had_pci, 1)",
            "",
            "    def test_get_guest_config_os_command_line_through_image_meta(self):",
            "        self.flags(virt_type=\"kvm\",",
            "                   cpu_mode=None,",
            "                   group='libvirt')",
            "",
            "        self.test_instance['kernel_id'] = \"fake_kernel_id\"",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"os_command_line\":",
            "                           \"fake_os_command_line\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(cfg.os_cmdline, \"fake_os_command_line\")",
            "",
            "    def test_get_guest_config_os_command_line_without_kernel_id(self):",
            "        self.flags(virt_type=\"kvm\",",
            "                cpu_mode=None,",
            "                group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"os_command_line\":",
            "                           \"fake_os_command_line\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info)",
            "        self.assertIsNone(cfg.os_cmdline)",
            "",
            "    def test_get_guest_config_os_command_empty(self):",
            "        self.flags(virt_type=\"kvm\",",
            "                   cpu_mode=None,",
            "                   group='libvirt')",
            "",
            "        self.test_instance['kernel_id'] = \"fake_kernel_id\"",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"os_command_line\": \"\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        # the instance has 'root=/dev/vda console=tty0 console=ttyS0' set by",
            "        # default, so testing an empty string and None value in the",
            "        # os_command_line image property must pass",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info)",
            "        self.assertNotEqual(cfg.os_cmdline, \"\")",
            "",
            "    def test_get_guest_config_armv7(self):",
            "        def get_host_capabilities_stub(self):",
            "            cpu = vconfig.LibvirtConfigGuestCPU()",
            "            cpu.arch = arch.ARMV7",
            "",
            "            caps = vconfig.LibvirtConfigCaps()",
            "            caps.host = vconfig.LibvirtConfigCapsHost()",
            "            caps.host.cpu = cpu",
            "            return caps",
            "",
            "        self.flags(virt_type=\"kvm\",",
            "                   group=\"libvirt\")",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        self.stubs.Set(host.Host, \"get_capabilities\",",
            "                       get_host_capabilities_stub)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(cfg.os_mach_type, \"vexpress-a15\")",
            "",
            "    def test_get_guest_config_aarch64(self):",
            "        def get_host_capabilities_stub(self):",
            "            cpu = vconfig.LibvirtConfigGuestCPU()",
            "            cpu.arch = arch.AARCH64",
            "",
            "            caps = vconfig.LibvirtConfigCaps()",
            "            caps.host = vconfig.LibvirtConfigCapsHost()",
            "            caps.host.cpu = cpu",
            "            return caps",
            "",
            "        self.flags(virt_type=\"kvm\",",
            "                   group=\"libvirt\")",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        self.stubs.Set(host.Host, \"get_capabilities\",",
            "                       get_host_capabilities_stub)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(cfg.os_mach_type, \"virt\")",
            "",
            "    def test_get_guest_config_machine_type_s390(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigGuestCPU()",
            "",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        host_cpu_archs = (arch.S390, arch.S390X)",
            "        for host_cpu_arch in host_cpu_archs:",
            "            caps.host.cpu.arch = host_cpu_arch",
            "            os_mach_type = drvr._get_machine_type(image_meta, caps)",
            "            self.assertEqual('s390-ccw-virtio', os_mach_type)",
            "",
            "    def test_get_guest_config_machine_type_through_image_meta(self):",
            "        self.flags(virt_type=\"kvm\",",
            "                   group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"raw\",",
            "            \"properties\": {\"hw_machine_type\":",
            "                           \"fake_machine_type\"}})",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(cfg.os_mach_type, \"fake_machine_type\")",
            "",
            "    def test_get_guest_config_machine_type_from_config(self):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        self.flags(hw_machine_type=['x86_64=fake_machine_type'],",
            "                group='libvirt')",
            "",
            "        def fake_getCapabilities():",
            "            return \"\"\"",
            "            <capabilities>",
            "                <host>",
            "                    <uuid>cef19ce0-0ca2-11df-855d-b19fbce37686</uuid>",
            "                    <cpu>",
            "                      <arch>x86_64</arch>",
            "                      <model>Penryn</model>",
            "                      <vendor>Intel</vendor>",
            "                      <topology sockets='1' cores='2' threads='1'/>",
            "                      <feature name='xtpr'/>",
            "                    </cpu>",
            "                </host>",
            "            </capabilities>",
            "            \"\"\"",
            "",
            "        def fake_baselineCPU(cpu, flag):",
            "            return \"\"\"<cpu mode='custom' match='exact'>",
            "                        <model fallback='allow'>Penryn</model>",
            "                        <vendor>Intel</vendor>",
            "                        <feature policy='require' name='xtpr'/>",
            "                      </cpu>",
            "                   \"\"\"",
            "",
            "        # Make sure the host arch is mocked as x86_64",
            "        self.create_fake_libvirt_mock(getCapabilities=fake_getCapabilities,",
            "                                      baselineCPU=fake_baselineCPU,",
            "                                      getVersion=lambda: 1005001)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                     _fake_network_info(self, 1),",
            "                                     image_meta, disk_info)",
            "        self.assertEqual(cfg.os_mach_type, \"fake_machine_type\")",
            "",
            "    def _test_get_guest_config_ppc64(self, device_index):",
            "        \"\"\"Test for nova.virt.libvirt.driver.LibvirtDriver._get_guest_config.",
            "        \"\"\"",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        expected = (arch.PPC64, arch.PPC)",
            "        for guestarch in expected:",
            "            with mock.patch.object(libvirt_driver.libvirt_utils,",
            "                                   'get_arch',",
            "                                   return_value=guestarch):",
            "                cfg = drvr._get_guest_config(instance_ref, [],",
            "                                            image_meta,",
            "                                            disk_info)",
            "                self.assertIsInstance(cfg.devices[device_index],",
            "                                      vconfig.LibvirtConfigGuestVideo)",
            "                self.assertEqual(cfg.devices[device_index].type, 'vga')",
            "",
            "    def test_get_guest_config_ppc64_through_image_meta_vnc_enabled(self):",
            "        self.flags(enabled=True, group='vnc')",
            "        self._test_get_guest_config_ppc64(6)",
            "",
            "    def test_get_guest_config_ppc64_through_image_meta_spice_enabled(self):",
            "        self.flags(enabled=True,",
            "                   agent_enabled=True,",
            "                   group='spice')",
            "        self._test_get_guest_config_ppc64(8)",
            "",
            "    def _test_get_guest_config_bootmenu(self, image_meta, extra_specs):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.extra_specs = extra_specs",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref, image_meta)",
            "        conf = conn._get_guest_config(instance_ref, [], image_meta, disk_info)",
            "        self.assertTrue(conf.os_bootmenu)",
            "",
            "    def test_get_guest_config_bootmenu_via_image_meta(self):",
            "        image_meta = objects.ImageMeta.from_dict(",
            "            {\"disk_format\": \"raw\",",
            "             \"properties\": {\"hw_boot_menu\": \"True\"}})",
            "        self._test_get_guest_config_bootmenu(image_meta, {})",
            "",
            "    def test_get_guest_config_bootmenu_via_extra_specs(self):",
            "        image_meta = objects.ImageMeta.from_dict(",
            "            self.test_image_meta)",
            "        self._test_get_guest_config_bootmenu(image_meta,",
            "                                             {'hw:boot_menu': 'True'})",
            "",
            "    def test_get_guest_cpu_config_none(self):",
            "        self.flags(cpu_mode=\"none\", group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        conf = drvr._get_guest_config(instance_ref,",
            "                                      _fake_network_info(self, 1),",
            "                                      image_meta, disk_info)",
            "        self.assertIsInstance(conf.cpu,",
            "                              vconfig.LibvirtConfigGuestCPU)",
            "        self.assertIsNone(conf.cpu.mode)",
            "        self.assertIsNone(conf.cpu.model)",
            "        self.assertEqual(conf.cpu.sockets, 1)",
            "        self.assertEqual(conf.cpu.cores, 1)",
            "        self.assertEqual(conf.cpu.threads, 1)",
            "",
            "    def test_get_guest_cpu_config_default_kvm(self):",
            "        self.flags(virt_type=\"kvm\",",
            "                   cpu_mode=None,",
            "                   group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        conf = drvr._get_guest_config(instance_ref,",
            "                                      _fake_network_info(self, 1),",
            "                                      image_meta, disk_info)",
            "        self.assertIsInstance(conf.cpu,",
            "                              vconfig.LibvirtConfigGuestCPU)",
            "        self.assertEqual(conf.cpu.mode, \"host-model\")",
            "        self.assertIsNone(conf.cpu.model)",
            "        self.assertEqual(conf.cpu.sockets, 1)",
            "        self.assertEqual(conf.cpu.cores, 1)",
            "        self.assertEqual(conf.cpu.threads, 1)",
            "",
            "    def test_get_guest_cpu_config_default_uml(self):",
            "        self.flags(virt_type=\"uml\",",
            "                   cpu_mode=None,",
            "                   group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        conf = drvr._get_guest_config(instance_ref,",
            "                                      _fake_network_info(self, 1),",
            "                                      image_meta, disk_info)",
            "        self.assertIsNone(conf.cpu)",
            "",
            "    def test_get_guest_cpu_config_default_lxc(self):",
            "        self.flags(virt_type=\"lxc\",",
            "                   cpu_mode=None,",
            "                   group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        conf = drvr._get_guest_config(instance_ref,",
            "                                      _fake_network_info(self, 1),",
            "                                      image_meta, disk_info)",
            "        self.assertIsNone(conf.cpu)",
            "",
            "    def test_get_guest_cpu_config_host_passthrough(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        self.flags(cpu_mode=\"host-passthrough\", group='libvirt')",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        conf = drvr._get_guest_config(instance_ref,",
            "                                      _fake_network_info(self, 1),",
            "                                      image_meta, disk_info)",
            "        self.assertIsInstance(conf.cpu,",
            "                              vconfig.LibvirtConfigGuestCPU)",
            "        self.assertEqual(conf.cpu.mode, \"host-passthrough\")",
            "        self.assertIsNone(conf.cpu.model)",
            "        self.assertEqual(conf.cpu.sockets, 1)",
            "        self.assertEqual(conf.cpu.cores, 1)",
            "        self.assertEqual(conf.cpu.threads, 1)",
            "",
            "    def test_get_guest_cpu_config_host_model(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        self.flags(cpu_mode=\"host-model\", group='libvirt')",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        conf = drvr._get_guest_config(instance_ref,",
            "                                      _fake_network_info(self, 1),",
            "                                      image_meta, disk_info)",
            "        self.assertIsInstance(conf.cpu,",
            "                              vconfig.LibvirtConfigGuestCPU)",
            "        self.assertEqual(conf.cpu.mode, \"host-model\")",
            "        self.assertIsNone(conf.cpu.model)",
            "        self.assertEqual(conf.cpu.sockets, 1)",
            "        self.assertEqual(conf.cpu.cores, 1)",
            "        self.assertEqual(conf.cpu.threads, 1)",
            "",
            "    def test_get_guest_cpu_config_custom(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        self.flags(cpu_mode=\"custom\",",
            "                   cpu_model=\"Penryn\",",
            "                   group='libvirt')",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        conf = drvr._get_guest_config(instance_ref,",
            "                                      _fake_network_info(self, 1),",
            "                                      image_meta, disk_info)",
            "        self.assertIsInstance(conf.cpu,",
            "                              vconfig.LibvirtConfigGuestCPU)",
            "        self.assertEqual(conf.cpu.mode, \"custom\")",
            "        self.assertEqual(conf.cpu.model, \"Penryn\")",
            "        self.assertEqual(conf.cpu.sockets, 1)",
            "        self.assertEqual(conf.cpu.cores, 1)",
            "        self.assertEqual(conf.cpu.threads, 1)",
            "",
            "    def test_get_guest_cpu_topology(self):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.flavor.vcpus = 8",
            "        instance_ref.flavor.extra_specs = {'hw:cpu_max_sockets': '4'}",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        conf = drvr._get_guest_config(instance_ref,",
            "                                      _fake_network_info(self, 1),",
            "                                      image_meta, disk_info)",
            "        self.assertIsInstance(conf.cpu,",
            "                              vconfig.LibvirtConfigGuestCPU)",
            "        self.assertEqual(conf.cpu.mode, \"host-model\")",
            "        self.assertEqual(conf.cpu.sockets, 4)",
            "        self.assertEqual(conf.cpu.cores, 2)",
            "        self.assertEqual(conf.cpu.threads, 1)",
            "",
            "    def test_get_guest_memory_balloon_config_by_default(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        for device in cfg.devices:",
            "            if device.root_name == 'memballoon':",
            "                self.assertIsInstance(device,",
            "                                      vconfig.LibvirtConfigMemoryBalloon)",
            "                self.assertEqual('virtio', device.model)",
            "                self.assertEqual(10, device.period)",
            "",
            "    def test_get_guest_memory_balloon_config_disable(self):",
            "        self.flags(mem_stats_period_seconds=0, group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        no_exist = True",
            "        for device in cfg.devices:",
            "            if device.root_name == 'memballoon':",
            "                no_exist = False",
            "                break",
            "        self.assertTrue(no_exist)",
            "",
            "    def test_get_guest_memory_balloon_config_period_value(self):",
            "        self.flags(mem_stats_period_seconds=21, group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        for device in cfg.devices:",
            "            if device.root_name == 'memballoon':",
            "                self.assertIsInstance(device,",
            "                                      vconfig.LibvirtConfigMemoryBalloon)",
            "                self.assertEqual('virtio', device.model)",
            "                self.assertEqual(21, device.period)",
            "",
            "    def test_get_guest_memory_balloon_config_qemu(self):",
            "        self.flags(virt_type='qemu', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        for device in cfg.devices:",
            "            if device.root_name == 'memballoon':",
            "                self.assertIsInstance(device,",
            "                                      vconfig.LibvirtConfigMemoryBalloon)",
            "                self.assertEqual('virtio', device.model)",
            "                self.assertEqual(10, device.period)",
            "",
            "    def test_get_guest_memory_balloon_config_xen(self):",
            "        self.flags(virt_type='xen', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        for device in cfg.devices:",
            "            if device.root_name == 'memballoon':",
            "                self.assertIsInstance(device,",
            "                                      vconfig.LibvirtConfigMemoryBalloon)",
            "                self.assertEqual('xen', device.model)",
            "                self.assertEqual(10, device.period)",
            "",
            "    def test_get_guest_memory_balloon_config_lxc(self):",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        cfg = drvr._get_guest_config(instance_ref, [],",
            "                                     image_meta, disk_info)",
            "        no_exist = True",
            "        for device in cfg.devices:",
            "            if device.root_name == 'memballoon':",
            "                no_exist = False",
            "                break",
            "        self.assertTrue(no_exist)",
            "",
            "    def test_xml_and_uri_no_ramdisk_no_kernel(self):",
            "        instance_data = dict(self.test_instance)",
            "        self._check_xml_and_uri(instance_data,",
            "                                expect_kernel=False, expect_ramdisk=False)",
            "",
            "    def test_xml_and_uri_no_ramdisk_no_kernel_xen_hvm(self):",
            "        instance_data = dict(self.test_instance)",
            "        instance_data.update({'vm_mode': vm_mode.HVM})",
            "        self._check_xml_and_uri(instance_data, expect_kernel=False,",
            "                                expect_ramdisk=False, expect_xen_hvm=True)",
            "",
            "    def test_xml_and_uri_no_ramdisk_no_kernel_xen_pv(self):",
            "        instance_data = dict(self.test_instance)",
            "        instance_data.update({'vm_mode': vm_mode.XEN})",
            "        self._check_xml_and_uri(instance_data, expect_kernel=False,",
            "                                expect_ramdisk=False, expect_xen_hvm=False,",
            "                                xen_only=True)",
            "",
            "    def test_xml_and_uri_no_ramdisk(self):",
            "        instance_data = dict(self.test_instance)",
            "        instance_data['kernel_id'] = 'aki-deadbeef'",
            "        self._check_xml_and_uri(instance_data,",
            "                                expect_kernel=True, expect_ramdisk=False)",
            "",
            "    def test_xml_and_uri_no_kernel(self):",
            "        instance_data = dict(self.test_instance)",
            "        instance_data['ramdisk_id'] = 'ari-deadbeef'",
            "        self._check_xml_and_uri(instance_data,",
            "                                expect_kernel=False, expect_ramdisk=False)",
            "",
            "    def test_xml_and_uri(self):",
            "        instance_data = dict(self.test_instance)",
            "        instance_data['ramdisk_id'] = 'ari-deadbeef'",
            "        instance_data['kernel_id'] = 'aki-deadbeef'",
            "        self._check_xml_and_uri(instance_data,",
            "                                expect_kernel=True, expect_ramdisk=True)",
            "",
            "    def test_xml_and_uri_rescue(self):",
            "        instance_data = dict(self.test_instance)",
            "        instance_data['ramdisk_id'] = 'ari-deadbeef'",
            "        instance_data['kernel_id'] = 'aki-deadbeef'",
            "        self._check_xml_and_uri(instance_data, expect_kernel=True,",
            "                                expect_ramdisk=True, rescue=instance_data)",
            "",
            "    def test_xml_and_uri_rescue_no_kernel_no_ramdisk(self):",
            "        instance_data = dict(self.test_instance)",
            "        self._check_xml_and_uri(instance_data, expect_kernel=False,",
            "                                expect_ramdisk=False, rescue=instance_data)",
            "",
            "    def test_xml_and_uri_rescue_no_kernel(self):",
            "        instance_data = dict(self.test_instance)",
            "        instance_data['ramdisk_id'] = 'aki-deadbeef'",
            "        self._check_xml_and_uri(instance_data, expect_kernel=False,",
            "                                expect_ramdisk=True, rescue=instance_data)",
            "",
            "    def test_xml_and_uri_rescue_no_ramdisk(self):",
            "        instance_data = dict(self.test_instance)",
            "        instance_data['kernel_id'] = 'aki-deadbeef'",
            "        self._check_xml_and_uri(instance_data, expect_kernel=True,",
            "                                expect_ramdisk=False, rescue=instance_data)",
            "",
            "    def test_xml_uuid(self):",
            "        self._check_xml_and_uuid(self.test_image_meta)",
            "",
            "    def test_lxc_container_and_uri(self):",
            "        instance_data = dict(self.test_instance)",
            "        self._check_xml_and_container(instance_data)",
            "",
            "    def test_xml_disk_prefix(self):",
            "        instance_data = dict(self.test_instance)",
            "        self._check_xml_and_disk_prefix(instance_data, None)",
            "",
            "    def test_xml_user_specified_disk_prefix(self):",
            "        instance_data = dict(self.test_instance)",
            "        self._check_xml_and_disk_prefix(instance_data, 'sd')",
            "",
            "    def test_xml_disk_driver(self):",
            "        instance_data = dict(self.test_instance)",
            "        self._check_xml_and_disk_driver(instance_data)",
            "",
            "    def test_xml_disk_bus_virtio(self):",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        self._check_xml_and_disk_bus(image_meta,",
            "                                     None,",
            "                                     ((\"disk\", \"virtio\", \"vda\"),))",
            "",
            "    def test_xml_disk_bus_ide(self):",
            "        # It's necessary to check if the architecture is power, because",
            "        # power doesn't have support to ide, and so libvirt translate",
            "        # all ide calls to scsi",
            "",
            "        expected = {arch.PPC: (\"cdrom\", \"scsi\", \"sda\"),",
            "                    arch.PPC64: (\"cdrom\", \"scsi\", \"sda\")}",
            "",
            "        expec_val = expected.get(blockinfo.libvirt_utils.get_arch({}),",
            "                                  (\"cdrom\", \"ide\", \"hda\"))",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"iso\"})",
            "        self._check_xml_and_disk_bus(image_meta,",
            "                                     None,",
            "                                     (expec_val,))",
            "",
            "    def test_xml_disk_bus_ide_and_virtio(self):",
            "        # It's necessary to check if the architecture is power, because",
            "        # power doesn't have support to ide, and so libvirt translate",
            "        # all ide calls to scsi",
            "",
            "        expected = {arch.PPC: (\"cdrom\", \"scsi\", \"sda\"),",
            "                    arch.PPC64: (\"cdrom\", \"scsi\", \"sda\")}",
            "",
            "        swap = {'device_name': '/dev/vdc',",
            "                'swap_size': 1}",
            "        ephemerals = [{'device_type': 'disk',",
            "                       'disk_bus': 'virtio',",
            "                       'device_name': '/dev/vdb',",
            "                       'size': 1}]",
            "        block_device_info = {",
            "                'swap': swap,",
            "                'ephemerals': ephemerals}",
            "        expec_val = expected.get(blockinfo.libvirt_utils.get_arch({}),",
            "                                  (\"cdrom\", \"ide\", \"hda\"))",
            "        image_meta = objects.ImageMeta.from_dict({",
            "            \"disk_format\": \"iso\"})",
            "        self._check_xml_and_disk_bus(image_meta,",
            "                                     block_device_info,",
            "                                     (expec_val,",
            "                                      (\"disk\", \"virtio\", \"vdb\"),",
            "                                      (\"disk\", \"virtio\", \"vdc\")))",
            "",
            "    @mock.patch.object(host.Host, \"list_instance_domains\")",
            "    def test_list_instances(self, mock_list):",
            "        vm1 = FakeVirtDomain(id=3, name=\"instance00000001\")",
            "        vm2 = FakeVirtDomain(id=17, name=\"instance00000002\")",
            "        vm3 = FakeVirtDomain(name=\"instance00000003\")",
            "        vm4 = FakeVirtDomain(name=\"instance00000004\")",
            "",
            "        mock_list.return_value = [vm1, vm2, vm3, vm4]",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        names = drvr.list_instances()",
            "        self.assertEqual(names[0], vm1.name())",
            "        self.assertEqual(names[1], vm2.name())",
            "        self.assertEqual(names[2], vm3.name())",
            "        self.assertEqual(names[3], vm4.name())",
            "        mock_list.assert_called_with(only_guests=True, only_running=False)",
            "",
            "    @mock.patch.object(host.Host, \"list_instance_domains\")",
            "    def test_list_instance_uuids(self, mock_list):",
            "        vm1 = FakeVirtDomain(id=3, name=\"instance00000001\")",
            "        vm2 = FakeVirtDomain(id=17, name=\"instance00000002\")",
            "        vm3 = FakeVirtDomain(name=\"instance00000003\")",
            "        vm4 = FakeVirtDomain(name=\"instance00000004\")",
            "",
            "        mock_list.return_value = [vm1, vm2, vm3, vm4]",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        uuids = drvr.list_instance_uuids()",
            "        self.assertEqual(len(uuids), 4)",
            "        self.assertEqual(uuids[0], vm1.UUIDString())",
            "        self.assertEqual(uuids[1], vm2.UUIDString())",
            "        self.assertEqual(uuids[2], vm3.UUIDString())",
            "        self.assertEqual(uuids[3], vm4.UUIDString())",
            "        mock_list.assert_called_with(only_guests=True, only_running=False)",
            "",
            "    @mock.patch.object(host.Host, \"list_instance_domains\")",
            "    def test_get_all_block_devices(self, mock_list):",
            "        xml = [",
            "            \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                        </disk>",
            "                        <disk type='block'>",
            "                            <source dev='/path/to/dev/1'/>",
            "                        </disk>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\",",
            "            \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                        </disk>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\",",
            "            \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                        </disk>",
            "                        <disk type='block'>",
            "                            <source dev='/path/to/dev/3'/>",
            "                        </disk>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\",",
            "        ]",
            "",
            "        mock_list.return_value = [",
            "            FakeVirtDomain(xml[0], id=3, name=\"instance00000001\"),",
            "            FakeVirtDomain(xml[1], id=1, name=\"instance00000002\"),",
            "            FakeVirtDomain(xml[2], id=5, name=\"instance00000003\")]",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        devices = drvr._get_all_block_devices()",
            "        self.assertEqual(devices, ['/path/to/dev/1', '/path/to/dev/3'])",
            "        mock_list.assert_called_with(only_guests=True, only_running=True)",
            "",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_online_cpus')",
            "    def test_get_host_vcpus(self, get_online_cpus):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.flags(vcpu_pin_set=\"4-5\")",
            "        get_online_cpus.return_value = set([4, 5, 6])",
            "        expected_vcpus = 2",
            "        vcpus = drvr._get_vcpu_total()",
            "        self.assertEqual(expected_vcpus, vcpus)",
            "",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_online_cpus')",
            "    def test_get_host_vcpus_out_of_range(self, get_online_cpus):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.flags(vcpu_pin_set=\"4-6\")",
            "        get_online_cpus.return_value = set([4, 5])",
            "        self.assertRaises(exception.Invalid, drvr._get_vcpu_total)",
            "",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_online_cpus')",
            "    def test_get_host_vcpus_libvirt_error(self, get_online_cpus):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        not_supported_exc = fakelibvirt.make_libvirtError(",
            "            fakelibvirt.libvirtError,",
            "            'this function is not supported by the connection driver:'",
            "            ' virNodeNumOfDevices',",
            "            error_code=fakelibvirt.VIR_ERR_NO_SUPPORT)",
            "        self.flags(vcpu_pin_set=\"4-6\")",
            "        get_online_cpus.side_effect = not_supported_exc",
            "        self.assertRaises(exception.Invalid, drvr._get_vcpu_total)",
            "",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_online_cpus')",
            "    def test_get_host_vcpus_libvirt_error_success(self, get_online_cpus):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        not_supported_exc = fakelibvirt.make_libvirtError(",
            "            fakelibvirt.libvirtError,",
            "            'this function is not supported by the connection driver:'",
            "            ' virNodeNumOfDevices',",
            "            error_code=fakelibvirt.VIR_ERR_NO_SUPPORT)",
            "        self.flags(vcpu_pin_set=\"1\")",
            "        get_online_cpus.side_effect = not_supported_exc",
            "        expected_vcpus = 1",
            "        vcpus = drvr._get_vcpu_total()",
            "        self.assertEqual(expected_vcpus, vcpus)",
            "",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_cpu_count')",
            "    def test_get_host_vcpus_after_hotplug(self, get_cpu_count):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        get_cpu_count.return_value = 2",
            "        expected_vcpus = 2",
            "        vcpus = drvr._get_vcpu_total()",
            "        self.assertEqual(expected_vcpus, vcpus)",
            "        get_cpu_count.return_value = 3",
            "        expected_vcpus = 3",
            "        vcpus = drvr._get_vcpu_total()",
            "        self.assertEqual(expected_vcpus, vcpus)",
            "",
            "    @mock.patch.object(host.Host, \"has_min_version\", return_value=True)",
            "    def test_quiesce(self, mock_has_min_version):",
            "        self.create_fake_libvirt_mock(lookupByName=self.fake_lookup)",
            "        with mock.patch.object(FakeVirtDomain, \"fsFreeze\") as mock_fsfreeze:",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "            instance = objects.Instance(**self.test_instance)",
            "            image_meta = objects.ImageMeta.from_dict(",
            "                {\"properties\": {\"hw_qemu_guest_agent\": \"yes\"}})",
            "            self.assertIsNone(drvr.quiesce(self.context, instance, image_meta))",
            "            mock_fsfreeze.assert_called_once_with()",
            "",
            "    def test_quiesce_not_supported(self):",
            "        self.create_fake_libvirt_mock()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "        instance = objects.Instance(**self.test_instance)",
            "        self.assertRaises(exception.InstanceQuiesceNotSupported,",
            "                      drvr.quiesce, self.context, instance, None)",
            "",
            "    @mock.patch.object(host.Host, \"has_min_version\", return_value=True)",
            "    def test_unquiesce(self, mock_has_min_version):",
            "        self.create_fake_libvirt_mock(getLibVersion=lambda: 1002005,",
            "                                      lookupByName=self.fake_lookup)",
            "        with mock.patch.object(FakeVirtDomain, \"fsThaw\") as mock_fsthaw:",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "            instance = objects.Instance(**self.test_instance)",
            "            image_meta = objects.ImageMeta.from_dict(",
            "                {\"properties\": {\"hw_qemu_guest_agent\": \"yes\"}})",
            "            self.assertIsNone(drvr.unquiesce(self.context, instance,",
            "                                             image_meta))",
            "            mock_fsthaw.assert_called_once_with()",
            "",
            "    def test_create_snapshot_metadata(self):",
            "        base = objects.ImageMeta.from_dict(",
            "            {'disk_format': 'raw'})",
            "        instance_data = {'kernel_id': 'kernel',",
            "                    'project_id': 'prj_id',",
            "                    'ramdisk_id': 'ram_id',",
            "                    'os_type': None}",
            "        instance = objects.Instance(**instance_data)",
            "        img_fmt = 'raw'",
            "        snp_name = 'snapshot_name'",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        ret = drvr._create_snapshot_metadata(base, instance, img_fmt, snp_name)",
            "        expected = {'is_public': False,",
            "                    'status': 'active',",
            "                    'name': snp_name,",
            "                    'properties': {",
            "                                   'kernel_id': instance['kernel_id'],",
            "                                   'image_location': 'snapshot',",
            "                                   'image_state': 'available',",
            "                                   'owner_id': instance['project_id'],",
            "                                   'ramdisk_id': instance['ramdisk_id'],",
            "                                   },",
            "                    'disk_format': img_fmt,",
            "                    'container_format': 'bare',",
            "                    }",
            "        self.assertEqual(ret, expected)",
            "",
            "        # simulate an instance with os_type field defined",
            "        # disk format equals to ami",
            "        # container format not equals to bare",
            "        instance['os_type'] = 'linux'",
            "        base = objects.ImageMeta.from_dict(",
            "            {'disk_format': 'ami',",
            "             'container_format': 'test_container'})",
            "        expected['properties']['os_type'] = instance['os_type']",
            "        expected['disk_format'] = base.disk_format",
            "        expected['container_format'] = base.container_format",
            "        ret = drvr._create_snapshot_metadata(base, instance, img_fmt, snp_name)",
            "        self.assertEqual(ret, expected)",
            "",
            "    def test_get_volume_driver(self):",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        connection_info = {'driver_volume_type': 'fake',",
            "                           'data': {'device_path': '/fake',",
            "                                    'access_mode': 'rw'}}",
            "        driver = conn._get_volume_driver(connection_info)",
            "        result = isinstance(driver, volume_drivers.LibvirtFakeVolumeDriver)",
            "        self.assertTrue(result)",
            "",
            "    def test_get_volume_driver_unknown(self):",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        connection_info = {'driver_volume_type': 'unknown',",
            "                           'data': {'device_path': '/fake',",
            "                                    'access_mode': 'rw'}}",
            "        self.assertRaises(",
            "            exception.VolumeDriverNotFound,",
            "            conn._get_volume_driver,",
            "            connection_info",
            "        )",
            "",
            "    @mock.patch.object(volume_drivers.LibvirtFakeVolumeDriver,",
            "                       'connect_volume')",
            "    @mock.patch.object(volume_drivers.LibvirtFakeVolumeDriver, 'get_config')",
            "    def test_get_volume_config(self, get_config, connect_volume):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        connection_info = {'driver_volume_type': 'fake',",
            "                           'data': {'device_path': '/fake',",
            "                                    'access_mode': 'rw'}}",
            "        bdm = {'device_name': 'vdb',",
            "               'disk_bus': 'fake-bus',",
            "               'device_type': 'fake-type'}",
            "        disk_info = {'bus': bdm['disk_bus'], 'type': bdm['device_type'],",
            "                     'dev': 'vdb'}",
            "        mock_config = mock.MagicMock()",
            "",
            "        get_config.return_value = mock_config",
            "        config = drvr._get_volume_config(connection_info, disk_info)",
            "        get_config.assert_called_once_with(connection_info, disk_info)",
            "        self.assertEqual(mock_config, config)",
            "",
            "    def test_attach_invalid_volume_type(self):",
            "        self.create_fake_libvirt_mock()",
            "        libvirt_driver.LibvirtDriver._conn.lookupByName = self.fake_lookup",
            "        instance = objects.Instance(**self.test_instance)",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertRaises(exception.VolumeDriverNotFound,",
            "                          drvr.attach_volume, None,",
            "                          {\"driver_volume_type\": \"badtype\"},",
            "                          instance,",
            "                          \"/dev/sda\")",
            "",
            "    def test_attach_blockio_invalid_hypervisor(self):",
            "        self.flags(virt_type='fake_type', group='libvirt')",
            "        self.create_fake_libvirt_mock()",
            "        libvirt_driver.LibvirtDriver._conn.lookupByName = self.fake_lookup",
            "        instance = objects.Instance(**self.test_instance)",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertRaises(exception.InvalidHypervisorType,",
            "                          drvr.attach_volume, None,",
            "                          {\"driver_volume_type\": \"fake\",",
            "                           \"data\": {\"logical_block_size\": \"4096\",",
            "                                    \"physical_block_size\": \"4096\"}",
            "                          },",
            "                          instance,",
            "                          \"/dev/sda\")",
            "",
            "    def _test_check_discard(self, mock_log, driver_discard=None,",
            "                            bus=None, should_log=False):",
            "        mock_config = mock.Mock()",
            "        mock_config.driver_discard = driver_discard",
            "        mock_config.target_bus = bus",
            "        mock_instance = mock.Mock()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr._check_discard_for_attach_volume(mock_config, mock_instance)",
            "        self.assertEqual(should_log, mock_log.called)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG.debug')",
            "    def test_check_discard_for_attach_volume_no_unmap(self, mock_log):",
            "        self._test_check_discard(mock_log, driver_discard=None,",
            "                                 bus='scsi', should_log=False)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG.debug')",
            "    def test_check_discard_for_attach_volume_blk_controller(self, mock_log):",
            "        self._test_check_discard(mock_log, driver_discard='unmap',",
            "                                 bus='virtio', should_log=True)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG.debug')",
            "    def test_check_discard_for_attach_volume_valid_controller(self, mock_log):",
            "        self._test_check_discard(mock_log, driver_discard='unmap',",
            "                                 bus='scsi', should_log=False)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG.debug')",
            "    def test_check_discard_for_attach_volume_blk_controller_no_unmap(self,",
            "                                                                     mock_log):",
            "        self._test_check_discard(mock_log, driver_discard=None,",
            "                                 bus='virtio', should_log=False)",
            "",
            "    @mock.patch('nova.utils.get_image_from_system_metadata')",
            "    @mock.patch('nova.virt.libvirt.blockinfo.get_info_from_bdm')",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_domain')",
            "    def test_attach_volume_with_vir_domain_affect_live_flag(self,",
            "            mock_get_domain, mock_get_info, get_image):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        image_meta = {}",
            "        get_image.return_value = image_meta",
            "        mock_dom = mock.MagicMock()",
            "        mock_get_domain.return_value = mock_dom",
            "",
            "        connection_info = {\"driver_volume_type\": \"fake\",",
            "                           \"data\": {\"device_path\": \"/fake\",",
            "                                    \"access_mode\": \"rw\"}}",
            "        bdm = {'device_name': 'vdb',",
            "               'disk_bus': 'fake-bus',",
            "               'device_type': 'fake-type'}",
            "        disk_info = {'bus': bdm['disk_bus'], 'type': bdm['device_type'],",
            "                     'dev': 'vdb'}",
            "        mock_get_info.return_value = disk_info",
            "        mock_conf = mock.MagicMock()",
            "        flags = (fakelibvirt.VIR_DOMAIN_AFFECT_CONFIG |",
            "                 fakelibvirt.VIR_DOMAIN_AFFECT_LIVE)",
            "",
            "        with test.nested(",
            "            mock.patch.object(drvr, '_connect_volume'),",
            "            mock.patch.object(drvr, '_get_volume_config',",
            "                              return_value=mock_conf),",
            "            mock.patch.object(drvr, '_set_cache_mode'),",
            "            mock.patch.object(drvr, '_check_discard_for_attach_volume')",
            "        ) as (mock_connect_volume, mock_get_volume_config,",
            "              mock_set_cache_mode, mock_check_discard):",
            "            for state in (power_state.RUNNING, power_state.PAUSED):",
            "                mock_dom.info.return_value = [state, 512, 512, 2, 1234, 5678]",
            "",
            "                drvr.attach_volume(self.context, connection_info, instance,",
            "                                   \"/dev/vdb\", disk_bus=bdm['disk_bus'],",
            "                                   device_type=bdm['device_type'])",
            "",
            "                mock_get_domain.assert_called_with(instance)",
            "                mock_get_info.assert_called_with(",
            "                    instance,",
            "                    CONF.libvirt.virt_type,",
            "                    test.MatchType(objects.ImageMeta),",
            "                    bdm)",
            "                mock_connect_volume.assert_called_with(",
            "                    connection_info, disk_info)",
            "                mock_get_volume_config.assert_called_with(",
            "                    connection_info, disk_info)",
            "                mock_set_cache_mode.assert_called_with(mock_conf)",
            "                mock_dom.attachDeviceFlags.assert_called_with(",
            "                    mock_conf.to_xml(), flags=flags)",
            "                mock_check_discard.assert_called_with(mock_conf, instance)",
            "",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_domain')",
            "    def test_detach_volume_with_vir_domain_affect_live_flag(self,",
            "            mock_get_domain):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_xml_with_disk = \"\"\"<domain>",
            "  <devices>",
            "    <disk type='file'>",
            "      <source file='/path/to/fake-volume'/>",
            "      <target dev='vdc' bus='virtio'/>",
            "    </disk>",
            "  </devices>",
            "</domain>\"\"\"",
            "        mock_xml_without_disk = \"\"\"<domain>",
            "  <devices>",
            "  </devices>",
            "</domain>\"\"\"",
            "        mock_dom = mock.MagicMock()",
            "",
            "        # Second time don't return anything about disk vdc so it looks removed",
            "        return_list = [mock_xml_with_disk, mock_xml_without_disk]",
            "        # Doubling the size of return list because we test with two guest power",
            "        # states",
            "        mock_dom.XMLDesc.side_effect = return_list + return_list",
            "",
            "        connection_info = {\"driver_volume_type\": \"fake\",",
            "                           \"data\": {\"device_path\": \"/fake\",",
            "                                    \"access_mode\": \"rw\"}}",
            "        flags = (fakelibvirt.VIR_DOMAIN_AFFECT_CONFIG |",
            "                 fakelibvirt.VIR_DOMAIN_AFFECT_LIVE)",
            "",
            "        with mock.patch.object(drvr, '_disconnect_volume') as \\",
            "                mock_disconnect_volume:",
            "            for state in (power_state.RUNNING, power_state.PAUSED):",
            "                mock_dom.info.return_value = [state, 512, 512, 2, 1234, 5678]",
            "                mock_get_domain.return_value = mock_dom",
            "                drvr.detach_volume(connection_info, instance, '/dev/vdc')",
            "",
            "                mock_get_domain.assert_called_with(instance)",
            "                mock_dom.detachDeviceFlags.assert_called_with(\"\"\"<disk type=\"file\" device=\"disk\">",
            "  <source file=\"/path/to/fake-volume\"/>",
            "  <target bus=\"virtio\" dev=\"vdc\"/>",
            "</disk>",
            "\"\"\", flags=flags)",
            "                mock_disconnect_volume.assert_called_with(",
            "                    connection_info, 'vdc')",
            "",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_domain')",
            "    def test_detach_volume_disk_not_found(self, mock_get_domain):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_xml_without_disk = \"\"\"<domain>",
            "  <devices>",
            "  </devices>",
            "</domain>\"\"\"",
            "        mock_dom = mock.MagicMock(return_value=mock_xml_without_disk)",
            "",
            "        connection_info = {\"driver_volume_type\": \"fake\",",
            "                           \"data\": {\"device_path\": \"/fake\",",
            "                                    \"access_mode\": \"rw\"}}",
            "",
            "        mock_dom.info.return_value = [power_state.RUNNING, 512, 512, 2, 1234,",
            "                                      5678]",
            "        mock_get_domain.return_value = mock_dom",
            "        self.assertRaises(exception.DiskNotFound, drvr.detach_volume,",
            "                          connection_info, instance, '/dev/vdc')",
            "",
            "        mock_get_domain.assert_called_once_with(instance)",
            "",
            "    def test_multi_nic(self):",
            "        network_info = _fake_network_info(self, 2)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        xml = drvr._get_guest_xml(self.context, instance_ref,",
            "                                  network_info, disk_info,",
            "                                  image_meta)",
            "        tree = etree.fromstring(xml)",
            "        interfaces = tree.findall(\"./devices/interface\")",
            "        self.assertEqual(len(interfaces), 2)",
            "        self.assertEqual(interfaces[0].get('type'), 'bridge')",
            "",
            "    def _behave_supports_direct_io(self, raise_open=False, raise_write=False,",
            "                                   exc=ValueError()):",
            "        open_behavior = os.open(os.path.join('.', '.directio.test'),",
            "                                os.O_CREAT | os.O_WRONLY | os.O_DIRECT)",
            "        if raise_open:",
            "            open_behavior.AndRaise(exc)",
            "        else:",
            "            open_behavior.AndReturn(3)",
            "            write_bahavior = os.write(3, mox.IgnoreArg())",
            "            if raise_write:",
            "                write_bahavior.AndRaise(exc)",
            "            else:",
            "                os.close(3)",
            "        os.unlink(3)",
            "",
            "    def test_supports_direct_io(self):",
            "        # O_DIRECT is not supported on all Python runtimes, so on platforms",
            "        # where it's not supported (e.g. Mac), we can still test the code-path",
            "        # by stubbing out the value.",
            "        if not hasattr(os, 'O_DIRECT'):",
            "            # `mock` seems to have trouble stubbing an attr that doesn't",
            "            # originally exist, so falling back to stubbing out the attribute",
            "            # directly.",
            "            os.O_DIRECT = 16384",
            "            self.addCleanup(delattr, os, 'O_DIRECT')",
            "",
            "        einval = OSError()",
            "        einval.errno = errno.EINVAL",
            "        self.mox.StubOutWithMock(os, 'open')",
            "        self.mox.StubOutWithMock(os, 'write')",
            "        self.mox.StubOutWithMock(os, 'close')",
            "        self.mox.StubOutWithMock(os, 'unlink')",
            "        _supports_direct_io = libvirt_driver.LibvirtDriver._supports_direct_io",
            "",
            "        self._behave_supports_direct_io()",
            "        self._behave_supports_direct_io(raise_write=True)",
            "        self._behave_supports_direct_io(raise_open=True)",
            "        self._behave_supports_direct_io(raise_write=True, exc=einval)",
            "        self._behave_supports_direct_io(raise_open=True, exc=einval)",
            "",
            "        self.mox.ReplayAll()",
            "        self.assertTrue(_supports_direct_io('.'))",
            "        self.assertRaises(ValueError, _supports_direct_io, '.')",
            "        self.assertRaises(ValueError, _supports_direct_io, '.')",
            "        self.assertFalse(_supports_direct_io('.'))",
            "        self.assertFalse(_supports_direct_io('.'))",
            "        self.mox.VerifyAll()",
            "",
            "    def _check_xml_and_container(self, instance):",
            "        instance_ref = objects.Instance(**instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        self.assertEqual(drvr._uri(), 'lxc:///')",
            "",
            "        network_info = _fake_network_info(self, 1)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        xml = drvr._get_guest_xml(self.context, instance_ref,",
            "                                  network_info, disk_info,",
            "                                  image_meta)",
            "        tree = etree.fromstring(xml)",
            "",
            "        check = [",
            "            (lambda t: t.find('.').get('type'), 'lxc'),",
            "            (lambda t: t.find('./os/type').text, 'exe'),",
            "            (lambda t: t.find('./devices/filesystem/target').get('dir'), '/')]",
            "",
            "        for i, (check, expected_result) in enumerate(check):",
            "            self.assertEqual(check(tree),",
            "                             expected_result,",
            "                             '%s failed common check %d' % (xml, i))",
            "",
            "        target = tree.find('./devices/filesystem/source').get('dir')",
            "        self.assertTrue(len(target) > 0)",
            "",
            "    def _check_xml_and_disk_prefix(self, instance, prefix):",
            "        instance_ref = objects.Instance(**instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        def _get_prefix(p, default):",
            "            if p:",
            "                return p + 'a'",
            "            return default",
            "",
            "        type_disk_map = {",
            "            'qemu': [",
            "                (lambda t: t.find('.').get('type'), 'qemu'),",
            "                (lambda t: t.find('./devices/disk/target').get('dev'),",
            "                 _get_prefix(prefix, 'vda'))],",
            "            'xen': [",
            "                (lambda t: t.find('.').get('type'), 'xen'),",
            "                (lambda t: t.find('./devices/disk/target').get('dev'),",
            "                 _get_prefix(prefix, 'xvda'))],",
            "            'kvm': [",
            "                (lambda t: t.find('.').get('type'), 'kvm'),",
            "                (lambda t: t.find('./devices/disk/target').get('dev'),",
            "                 _get_prefix(prefix, 'vda'))],",
            "            'uml': [",
            "                (lambda t: t.find('.').get('type'), 'uml'),",
            "                (lambda t: t.find('./devices/disk/target').get('dev'),",
            "                 _get_prefix(prefix, 'ubda'))]",
            "            }",
            "",
            "        for (virt_type, checks) in six.iteritems(type_disk_map):",
            "            self.flags(virt_type=virt_type, group='libvirt')",
            "            if prefix:",
            "                self.flags(disk_prefix=prefix, group='libvirt')",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "            network_info = _fake_network_info(self, 1)",
            "            disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                                instance_ref,",
            "                                                image_meta)",
            "",
            "            xml = drvr._get_guest_xml(self.context, instance_ref,",
            "                                      network_info, disk_info,",
            "                                      image_meta)",
            "            tree = etree.fromstring(xml)",
            "",
            "            for i, (check, expected_result) in enumerate(checks):",
            "                self.assertEqual(check(tree),",
            "                                 expected_result,",
            "                                 '%s != %s failed check %d' %",
            "                                 (check(tree), expected_result, i))",
            "",
            "    def _check_xml_and_disk_driver(self, image_meta):",
            "        os_open = os.open",
            "        directio_supported = True",
            "",
            "        def os_open_stub(path, flags, *args, **kwargs):",
            "            if flags & os.O_DIRECT:",
            "                if not directio_supported:",
            "                    raise OSError(errno.EINVAL,",
            "                                  '%s: %s' % (os.strerror(errno.EINVAL), path))",
            "                flags &= ~os.O_DIRECT",
            "            return os_open(path, flags, *args, **kwargs)",
            "",
            "        self.stub_out('os.open', os_open_stub)",
            "",
            "        @staticmethod",
            "        def connection_supports_direct_io_stub(dirpath):",
            "            return directio_supported",
            "",
            "        self.stubs.Set(libvirt_driver.LibvirtDriver,",
            "            '_supports_direct_io', connection_supports_direct_io_stub)",
            "",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        network_info = _fake_network_info(self, 1)",
            "",
            "        drv = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        xml = drv._get_guest_xml(self.context, instance_ref,",
            "                                 network_info, disk_info, image_meta)",
            "        tree = etree.fromstring(xml)",
            "        disks = tree.findall('./devices/disk/driver')",
            "        for guest_disk in disks:",
            "            self.assertEqual(guest_disk.get(\"cache\"), \"none\")",
            "",
            "        directio_supported = False",
            "",
            "        # The O_DIRECT availability is cached on first use in",
            "        # LibvirtDriver, hence we re-create it here",
            "        drv = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        xml = drv._get_guest_xml(self.context, instance_ref,",
            "                                 network_info, disk_info, image_meta)",
            "        tree = etree.fromstring(xml)",
            "        disks = tree.findall('./devices/disk/driver')",
            "        for guest_disk in disks:",
            "            self.assertEqual(guest_disk.get(\"cache\"), \"writethrough\")",
            "",
            "    def _check_xml_and_disk_bus(self, image_meta,",
            "                                block_device_info, wantConfig):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        network_info = _fake_network_info(self, 1)",
            "",
            "        drv = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta,",
            "                                            block_device_info)",
            "",
            "        xml = drv._get_guest_xml(self.context, instance_ref,",
            "                                 network_info, disk_info, image_meta,",
            "                                 block_device_info=block_device_info)",
            "        tree = etree.fromstring(xml)",
            "",
            "        got_disks = tree.findall('./devices/disk')",
            "        got_disk_targets = tree.findall('./devices/disk/target')",
            "        for i in range(len(wantConfig)):",
            "            want_device_type = wantConfig[i][0]",
            "            want_device_bus = wantConfig[i][1]",
            "            want_device_dev = wantConfig[i][2]",
            "",
            "            got_device_type = got_disks[i].get('device')",
            "            got_device_bus = got_disk_targets[i].get('bus')",
            "            got_device_dev = got_disk_targets[i].get('dev')",
            "",
            "            self.assertEqual(got_device_type, want_device_type)",
            "            self.assertEqual(got_device_bus, want_device_bus)",
            "            self.assertEqual(got_device_dev, want_device_dev)",
            "",
            "    def _check_xml_and_uuid(self, image_meta):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        network_info = _fake_network_info(self, 1)",
            "",
            "        drv = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "        xml = drv._get_guest_xml(self.context, instance_ref,",
            "                                 network_info, disk_info, image_meta)",
            "        tree = etree.fromstring(xml)",
            "        self.assertEqual(tree.find('./uuid').text,",
            "                         instance_ref['uuid'])",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver,",
            "                       \"_get_host_sysinfo_serial_hardware\",)",
            "    def _check_xml_and_uri(self, instance, mock_serial,",
            "                           expect_ramdisk=False, expect_kernel=False,",
            "                           rescue=None, expect_xen_hvm=False, xen_only=False):",
            "        mock_serial.return_value = \"cef19ce0-0ca2-11df-855d-b19fbce37686\"",
            "        instance_ref = objects.Instance(**instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        xen_vm_mode = vm_mode.XEN",
            "        if expect_xen_hvm:",
            "            xen_vm_mode = vm_mode.HVM",
            "",
            "        type_uri_map = {'qemu': ('qemu:///system',",
            "                             [(lambda t: t.find('.').get('type'), 'qemu'),",
            "                              (lambda t: t.find('./os/type').text,",
            "                               vm_mode.HVM),",
            "                              (lambda t: t.find('./devices/emulator'), None)]),",
            "                        'kvm': ('qemu:///system',",
            "                             [(lambda t: t.find('.').get('type'), 'kvm'),",
            "                              (lambda t: t.find('./os/type').text,",
            "                               vm_mode.HVM),",
            "                              (lambda t: t.find('./devices/emulator'), None)]),",
            "                        'uml': ('uml:///system',",
            "                             [(lambda t: t.find('.').get('type'), 'uml'),",
            "                              (lambda t: t.find('./os/type').text,",
            "                               vm_mode.UML)]),",
            "                        'xen': ('xen:///',",
            "                             [(lambda t: t.find('.').get('type'), 'xen'),",
            "                              (lambda t: t.find('./os/type').text,",
            "                               xen_vm_mode)])}",
            "",
            "        if expect_xen_hvm or xen_only:",
            "            hypervisors_to_check = ['xen']",
            "        else:",
            "            hypervisors_to_check = ['qemu', 'kvm', 'xen']",
            "",
            "        for hypervisor_type in hypervisors_to_check:",
            "            check_list = type_uri_map[hypervisor_type][1]",
            "",
            "            if rescue:",
            "                suffix = '.rescue'",
            "            else:",
            "                suffix = ''",
            "            if expect_kernel:",
            "                check = (lambda t: self.relpath(t.find('./os/kernel').text).",
            "                         split('/')[1], 'kernel' + suffix)",
            "            else:",
            "                check = (lambda t: t.find('./os/kernel'), None)",
            "            check_list.append(check)",
            "",
            "            if expect_kernel:",
            "                check = (lambda t: \"no_timer_check\" in t.find('./os/cmdline').",
            "                         text, hypervisor_type == \"qemu\")",
            "                check_list.append(check)",
            "            # Hypervisors that only support vm_mode.HVM and Xen",
            "            # should not produce configuration that results in kernel",
            "            # arguments",
            "            if not expect_kernel and (hypervisor_type in",
            "                                      ['qemu', 'kvm', 'xen']):",
            "                check = (lambda t: t.find('./os/root'), None)",
            "                check_list.append(check)",
            "                check = (lambda t: t.find('./os/cmdline'), None)",
            "                check_list.append(check)",
            "",
            "            if expect_ramdisk:",
            "                check = (lambda t: self.relpath(t.find('./os/initrd').text).",
            "                         split('/')[1], 'ramdisk' + suffix)",
            "            else:",
            "                check = (lambda t: t.find('./os/initrd'), None)",
            "            check_list.append(check)",
            "",
            "            if hypervisor_type in ['qemu', 'kvm']:",
            "                xpath = \"./sysinfo/system/entry\"",
            "                check = (lambda t: t.findall(xpath)[0].get(\"name\"),",
            "                         \"manufacturer\")",
            "                check_list.append(check)",
            "                check = (lambda t: t.findall(xpath)[0].text,",
            "                         version.vendor_string())",
            "                check_list.append(check)",
            "",
            "                check = (lambda t: t.findall(xpath)[1].get(\"name\"),",
            "                         \"product\")",
            "                check_list.append(check)",
            "                check = (lambda t: t.findall(xpath)[1].text,",
            "                         version.product_string())",
            "                check_list.append(check)",
            "",
            "                check = (lambda t: t.findall(xpath)[2].get(\"name\"),",
            "                         \"version\")",
            "                check_list.append(check)",
            "                # NOTE(sirp): empty strings don't roundtrip in lxml (they are",
            "                # converted to None), so we need an `or ''` to correct for that",
            "                check = (lambda t: t.findall(xpath)[2].text or '',",
            "                         version.version_string_with_package())",
            "                check_list.append(check)",
            "",
            "                check = (lambda t: t.findall(xpath)[3].get(\"name\"),",
            "                         \"serial\")",
            "                check_list.append(check)",
            "                check = (lambda t: t.findall(xpath)[3].text,",
            "                         \"cef19ce0-0ca2-11df-855d-b19fbce37686\")",
            "                check_list.append(check)",
            "",
            "                check = (lambda t: t.findall(xpath)[4].get(\"name\"),",
            "                         \"uuid\")",
            "                check_list.append(check)",
            "                check = (lambda t: t.findall(xpath)[4].text,",
            "                         instance['uuid'])",
            "                check_list.append(check)",
            "",
            "            if hypervisor_type in ['qemu', 'kvm']:",
            "                check = (lambda t: t.findall('./devices/serial')[0].get(",
            "                        'type'), 'file')",
            "                check_list.append(check)",
            "                check = (lambda t: t.findall('./devices/serial')[1].get(",
            "                        'type'), 'pty')",
            "                check_list.append(check)",
            "                check = (lambda t: self.relpath(t.findall(",
            "                         './devices/serial/source')[0].get('path')).",
            "                         split('/')[1], 'console.log')",
            "                check_list.append(check)",
            "            else:",
            "                check = (lambda t: t.find('./devices/console').get(",
            "                        'type'), 'pty')",
            "                check_list.append(check)",
            "",
            "        common_checks = [",
            "            (lambda t: t.find('.').tag, 'domain'),",
            "            (lambda t: t.find('./memory').text, '2097152')]",
            "        if rescue:",
            "            common_checks += [",
            "                (lambda t: self.relpath(t.findall('./devices/disk/source')[0].",
            "                    get('file')).split('/')[1], 'disk.rescue'),",
            "                (lambda t: self.relpath(t.findall('./devices/disk/source')[1].",
            "                    get('file')).split('/')[1], 'disk')]",
            "        else:",
            "            common_checks += [(lambda t: self.relpath(t.findall(",
            "                './devices/disk/source')[0].get('file')).split('/')[1],",
            "                               'disk')]",
            "            common_checks += [(lambda t: self.relpath(t.findall(",
            "                './devices/disk/source')[1].get('file')).split('/')[1],",
            "                               'disk.local')]",
            "",
            "        for virt_type in hypervisors_to_check:",
            "            expected_uri = type_uri_map[virt_type][0]",
            "            checks = type_uri_map[virt_type][1]",
            "            self.flags(virt_type=virt_type, group='libvirt')",
            "",
            "            with mock.patch('nova.virt.libvirt.driver.libvirt') as old_virt:",
            "                del old_virt.VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES",
            "",
            "                drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "                self.assertEqual(drvr._uri(), expected_uri)",
            "",
            "                network_info = _fake_network_info(self, 1)",
            "                disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                                    instance_ref,",
            "                                                    image_meta,",
            "                                                    rescue=rescue)",
            "",
            "                xml = drvr._get_guest_xml(self.context, instance_ref,",
            "                                          network_info, disk_info,",
            "                                          image_meta,",
            "                                          rescue=rescue)",
            "                tree = etree.fromstring(xml)",
            "                for i, (check, expected_result) in enumerate(checks):",
            "                    self.assertEqual(check(tree),",
            "                                     expected_result,",
            "                                     '%s != %s failed check %d' %",
            "                                     (check(tree), expected_result, i))",
            "",
            "                for i, (check, expected_result) in enumerate(common_checks):",
            "                    self.assertEqual(check(tree),",
            "                                     expected_result,",
            "                                     '%s != %s failed common check %d' %",
            "                                     (check(tree), expected_result, i))",
            "",
            "                filterref = './devices/interface/filterref'",
            "                vif = network_info[0]",
            "                nic_id = vif['address'].replace(':', '')",
            "                fw = firewall.NWFilterFirewall(drvr)",
            "                instance_filter_name = fw._instance_filter_name(instance_ref,",
            "                                                                nic_id)",
            "                self.assertEqual(tree.find(filterref).get('filter'),",
            "                                 instance_filter_name)",
            "",
            "        # This test is supposed to make sure we don't",
            "        # override a specifically set uri",
            "        #",
            "        # Deliberately not just assigning this string to CONF.connection_uri",
            "        # and checking against that later on. This way we make sure the",
            "        # implementation doesn't fiddle around with the CONF.",
            "        testuri = 'something completely different'",
            "        self.flags(connection_uri=testuri, group='libvirt')",
            "        for (virt_type, (expected_uri, checks)) in six.iteritems(type_uri_map):",
            "            self.flags(virt_type=virt_type, group='libvirt')",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "            self.assertEqual(drvr._uri(), testuri)",
            "",
            "    def test_ensure_filtering_rules_for_instance_timeout(self):",
            "        # ensure_filtering_fules_for_instance() finishes with timeout.",
            "        # Preparing mocks",
            "        def fake_none(self, *args):",
            "            return",
            "",
            "        class FakeTime(object):",
            "            def __init__(self):",
            "                self.counter = 0",
            "",
            "            def sleep(self, t):",
            "                self.counter += t",
            "",
            "        fake_timer = FakeTime()",
            "",
            "        def fake_sleep(t):",
            "            fake_timer.sleep(t)",
            "",
            "        # _fake_network_info must be called before create_fake_libvirt_mock(),",
            "        # as _fake_network_info calls importutils.import_class() and",
            "        # create_fake_libvirt_mock() mocks importutils.import_class().",
            "        network_info = _fake_network_info(self, 1)",
            "        self.create_fake_libvirt_mock()",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "",
            "        # Start test",
            "        self.mox.ReplayAll()",
            "        try:",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "            self.stubs.Set(drvr.firewall_driver,",
            "                           'setup_basic_filtering',",
            "                           fake_none)",
            "            self.stubs.Set(drvr.firewall_driver,",
            "                           'prepare_instance_filter',",
            "                           fake_none)",
            "            self.stubs.Set(drvr.firewall_driver,",
            "                           'instance_filter_exists',",
            "                           fake_none)",
            "            self.stubs.Set(greenthread,",
            "                           'sleep',",
            "                           fake_sleep)",
            "            drvr.ensure_filtering_rules_for_instance(instance_ref,",
            "                                                     network_info)",
            "        except exception.NovaException as e:",
            "            msg = ('The firewall filter for %s does not exist' %",
            "                   instance_ref['name'])",
            "            c1 = (0 <= six.text_type(e).find(msg))",
            "        self.assertTrue(c1)",
            "",
            "        self.assertEqual(29, fake_timer.counter, \"Didn't wait the expected \"",
            "                                                 \"amount of time\")",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver,",
            "        '_create_shared_storage_test_file')",
            "    @mock.patch.object(fakelibvirt.Connection, 'compareCPU')",
            "    def test_check_can_live_migrate_dest_all_pass_with_block_migration(",
            "            self, mock_cpu, mock_test_file):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.vcpu_model = test_vcpu_model.fake_vcpumodel",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        compute_info = {'disk_available_least': 400,",
            "                        'cpu_info': 'asdf',",
            "                        }",
            "        filename = \"file\"",
            "",
            "        # _check_cpu_match",
            "        mock_cpu.return_value = 1",
            "",
            "        # mounted_on_same_shared_storage",
            "        mock_test_file.return_value = filename",
            "",
            "        # No need for the src_compute_info",
            "        return_value = drvr.check_can_live_migrate_destination(self.context,",
            "                instance_ref, None, compute_info, True)",
            "        return_value.is_volume_backed = False",
            "        self.assertThat({\"filename\": \"file\",",
            "                         'image_type': 'default',",
            "                         'disk_available_mb': 409600,",
            "                         \"disk_over_commit\": False,",
            "                         \"block_migration\": True,",
            "                         \"is_volume_backed\": False},",
            "                        matchers.DictMatches(return_value.to_legacy_dict()))",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver,",
            "        '_create_shared_storage_test_file')",
            "    @mock.patch.object(fakelibvirt.Connection, 'compareCPU')",
            "    def test_check_can_live_migrate_dest_all_pass_no_block_migration(",
            "            self, mock_cpu, mock_test_file):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.vcpu_model = test_vcpu_model.fake_vcpumodel",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        compute_info = {'disk_available_least': 400,",
            "                        'cpu_info': 'asdf',",
            "                        }",
            "        filename = \"file\"",
            "",
            "        # _check_cpu_match",
            "        mock_cpu.return_value = 1",
            "        # mounted_on_same_shared_storage",
            "        mock_test_file.return_value = filename",
            "        # No need for the src_compute_info",
            "        return_value = drvr.check_can_live_migrate_destination(self.context,",
            "                instance_ref, None, compute_info, False)",
            "        return_value.is_volume_backed = False",
            "        self.assertThat({\"filename\": \"file\",",
            "                         \"image_type\": 'default',",
            "                         \"block_migration\": False,",
            "                         \"disk_over_commit\": False,",
            "                         \"disk_available_mb\": 409600,",
            "                         \"is_volume_backed\": False},",
            "                        matchers.DictMatches(return_value.to_legacy_dict()))",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver,",
            "                       '_create_shared_storage_test_file',",
            "                       return_value='fake')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_compare_cpu')",
            "    def test_check_can_live_migrate_guest_cpu_none_model(",
            "            self, mock_cpu, mock_test_file):",
            "        # Tests that when instance.vcpu_model.model is None, the host cpu",
            "        # model is used for live migration.",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.vcpu_model = test_vcpu_model.fake_vcpumodel",
            "        instance_ref.vcpu_model.model = None",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        compute_info = {'cpu_info': 'asdf', 'disk_available_least': 1}",
            "        result = drvr.check_can_live_migrate_destination(",
            "            self.context, instance_ref, compute_info, compute_info)",
            "        result.is_volume_backed = False",
            "        mock_cpu.assert_called_once_with(None, 'asdf')",
            "        expected_result = {\"filename\": 'fake',",
            "                           \"image_type\": CONF.libvirt.images_type,",
            "                           \"block_migration\": False,",
            "                           \"disk_over_commit\": False,",
            "                           \"disk_available_mb\": 1024,",
            "                           \"is_volume_backed\": False}",
            "        self.assertDictEqual(expected_result, result.to_legacy_dict())",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver,",
            "        '_create_shared_storage_test_file')",
            "    @mock.patch.object(fakelibvirt.Connection, 'compareCPU')",
            "    def test_check_can_live_migrate_dest_no_instance_cpu_info(",
            "            self, mock_cpu, mock_test_file):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        compute_info = {'cpu_info': jsonutils.dumps({",
            "            \"vendor\": \"AMD\",",
            "            \"arch\": arch.I686,",
            "            \"features\": [\"sse3\"],",
            "            \"model\": \"Opteron_G3\",",
            "            \"topology\": {\"cores\": 2, \"threads\": 1, \"sockets\": 4}",
            "        }), 'disk_available_least': 1}",
            "        filename = \"file\"",
            "",
            "        # _check_cpu_match",
            "        mock_cpu.return_value = 1",
            "        # mounted_on_same_shared_storage",
            "        mock_test_file.return_value = filename",
            "",
            "        return_value = drvr.check_can_live_migrate_destination(self.context,",
            "                instance_ref, compute_info, compute_info, False)",
            "        # NOTE(danms): Compute manager would have set this, so set it here",
            "        return_value.is_volume_backed = False",
            "        self.assertThat({\"filename\": \"file\",",
            "                         \"image_type\": 'default',",
            "                         \"block_migration\": False,",
            "                         \"disk_over_commit\": False,",
            "                         \"disk_available_mb\": 1024,",
            "                         \"is_volume_backed\": False},",
            "                        matchers.DictMatches(return_value.to_legacy_dict()))",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'compareCPU')",
            "    def test_check_can_live_migrate_dest_incompatible_cpu_raises(",
            "            self, mock_cpu):",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        instance_ref.vcpu_model = test_vcpu_model.fake_vcpumodel",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        compute_info = {'cpu_info': 'asdf', 'disk_available_least': 1}",
            "",
            "        mock_cpu.side_effect = exception.InvalidCPUInfo(reason='foo')",
            "        self.assertRaises(exception.InvalidCPUInfo,",
            "                          drvr.check_can_live_migrate_destination,",
            "                          self.context, instance_ref,",
            "                          compute_info, compute_info, False)",
            "",
            "    @mock.patch.object(host.Host, 'compare_cpu')",
            "    @mock.patch.object(nova.virt.libvirt, 'config')",
            "    def test_compare_cpu_compatible_host_cpu(self, mock_vconfig, mock_compare):",
            "        mock_compare.return_value = 5",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        ret = conn._compare_cpu(None, jsonutils.dumps(_fake_cpu_info))",
            "        self.assertIsNone(ret)",
            "",
            "    @mock.patch.object(host.Host, 'compare_cpu')",
            "    @mock.patch.object(nova.virt.libvirt, 'config')",
            "    def test_compare_cpu_handles_not_supported_error_gracefully(self,",
            "                                                                mock_vconfig,",
            "                                                                mock_compare):",
            "        not_supported_exc = fakelibvirt.make_libvirtError(",
            "                fakelibvirt.libvirtError,",
            "                'this function is not supported by the connection driver:'",
            "                ' virCompareCPU',",
            "                error_code=fakelibvirt.VIR_ERR_NO_SUPPORT)",
            "        mock_compare.side_effect = not_supported_exc",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        ret = conn._compare_cpu(None, jsonutils.dumps(_fake_cpu_info))",
            "        self.assertIsNone(ret)",
            "",
            "    @mock.patch.object(host.Host, 'compare_cpu')",
            "    @mock.patch.object(nova.virt.libvirt.LibvirtDriver,",
            "                       '_vcpu_model_to_cpu_config')",
            "    def test_compare_cpu_compatible_guest_cpu(self, mock_vcpu_to_cpu,",
            "                                              mock_compare):",
            "        mock_compare.return_value = 6",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        ret = conn._compare_cpu(jsonutils.dumps(_fake_cpu_info), None)",
            "        self.assertIsNone(ret)",
            "",
            "    def test_compare_cpu_virt_type_xen(self):",
            "        self.flags(virt_type='xen', group='libvirt')",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        ret = conn._compare_cpu(None, None)",
            "        self.assertIsNone(ret)",
            "",
            "    @mock.patch.object(host.Host, 'compare_cpu')",
            "    @mock.patch.object(nova.virt.libvirt, 'config')",
            "    def test_compare_cpu_invalid_cpuinfo_raises(self, mock_vconfig,",
            "                                                mock_compare):",
            "        mock_compare.return_value = 0",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertRaises(exception.InvalidCPUInfo,",
            "                          conn._compare_cpu, None,",
            "                          jsonutils.dumps(_fake_cpu_info))",
            "",
            "    @mock.patch.object(host.Host, 'compare_cpu')",
            "    @mock.patch.object(nova.virt.libvirt, 'config')",
            "    def test_compare_cpu_incompatible_cpu_raises(self, mock_vconfig,",
            "                                                 mock_compare):",
            "        mock_compare.side_effect = fakelibvirt.libvirtError('cpu')",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertRaises(exception.MigrationPreCheckError,",
            "                          conn._compare_cpu, None,",
            "                          jsonutils.dumps(_fake_cpu_info))",
            "",
            "    def test_check_can_live_migrate_dest_cleanup_works_correctly(self):",
            "        objects.Instance(**self.test_instance)",
            "        dest_check_data = objects.LibvirtLiveMigrateData(",
            "            filename=\"file\",",
            "            block_migration=True,",
            "            disk_over_commit=False,",
            "            disk_available_mb=1024)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        self.mox.StubOutWithMock(drvr, '_cleanup_shared_storage_test_file')",
            "        drvr._cleanup_shared_storage_test_file(\"file\")",
            "",
            "        self.mox.ReplayAll()",
            "        drvr.check_can_live_migrate_destination_cleanup(self.context,",
            "                                                        dest_check_data)",
            "",
            "    def _mock_can_live_migrate_source(self, block_migration=False,",
            "                                      is_shared_block_storage=False,",
            "                                      is_shared_instance_path=False,",
            "                                      is_booted_from_volume=False,",
            "                                      disk_available_mb=1024,",
            "                                      block_device_info=None,",
            "                                      block_device_text=None):",
            "        instance = objects.Instance(**self.test_instance)",
            "        dest_check_data = objects.LibvirtLiveMigrateData(",
            "            filename='file',",
            "            image_type='default',",
            "            block_migration=block_migration,",
            "            disk_over_commit=False,",
            "            disk_available_mb=disk_available_mb)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        self.mox.StubOutWithMock(drvr, '_is_shared_block_storage')",
            "        drvr._is_shared_block_storage(instance, dest_check_data,",
            "                block_device_info).AndReturn(is_shared_block_storage)",
            "        self.mox.StubOutWithMock(drvr, '_check_shared_storage_test_file')",
            "        drvr._check_shared_storage_test_file('file').AndReturn(",
            "                is_shared_instance_path)",
            "        self.mox.StubOutWithMock(drvr, \"get_instance_disk_info\")",
            "        drvr.get_instance_disk_info(instance,",
            "                                    block_device_info=block_device_info).\\",
            "                                    AndReturn(block_device_text)",
            "        self.mox.StubOutWithMock(drvr, '_is_booted_from_volume')",
            "        drvr._is_booted_from_volume(instance, block_device_text).AndReturn(",
            "            is_booted_from_volume)",
            "",
            "        return (instance, dest_check_data, drvr)",
            "",
            "    def test_check_can_live_migrate_source_block_migration(self):",
            "        instance, dest_check_data, drvr = self._mock_can_live_migrate_source(",
            "                block_migration=True)",
            "",
            "        self.mox.StubOutWithMock(drvr, \"_assert_dest_node_has_enough_disk\")",
            "        drvr._assert_dest_node_has_enough_disk(",
            "            self.context, instance, dest_check_data.disk_available_mb,",
            "            False, None)",
            "",
            "        self.mox.ReplayAll()",
            "        ret = drvr.check_can_live_migrate_source(self.context, instance,",
            "                                                 dest_check_data)",
            "        self.assertIsInstance(ret, objects.LibvirtLiveMigrateData)",
            "        self.assertIn('is_shared_block_storage', ret)",
            "        self.assertIn('is_shared_instance_path', ret)",
            "",
            "    def test_check_can_live_migrate_source_shared_block_storage(self):",
            "        instance, dest_check_data, drvr = self._mock_can_live_migrate_source(",
            "                is_shared_block_storage=True)",
            "        self.mox.ReplayAll()",
            "        drvr.check_can_live_migrate_source(self.context, instance,",
            "                                           dest_check_data)",
            "",
            "    def test_check_can_live_migrate_source_shared_instance_path(self):",
            "        instance, dest_check_data, drvr = self._mock_can_live_migrate_source(",
            "                is_shared_instance_path=True)",
            "        self.mox.ReplayAll()",
            "        drvr.check_can_live_migrate_source(self.context, instance,",
            "                                           dest_check_data)",
            "",
            "    def test_check_can_live_migrate_source_non_shared_fails(self):",
            "        instance, dest_check_data, drvr = self._mock_can_live_migrate_source()",
            "        self.mox.ReplayAll()",
            "        self.assertRaises(exception.InvalidSharedStorage,",
            "                          drvr.check_can_live_migrate_source, self.context,",
            "                          instance, dest_check_data)",
            "",
            "    def test_check_can_live_migrate_source_shared_block_migration_fails(self):",
            "        instance, dest_check_data, drvr = self._mock_can_live_migrate_source(",
            "                block_migration=True,",
            "                is_shared_block_storage=True)",
            "",
            "        self.mox.ReplayAll()",
            "        self.assertRaises(exception.InvalidLocalStorage,",
            "                          drvr.check_can_live_migrate_source,",
            "                          self.context, instance, dest_check_data)",
            "",
            "    def test_check_can_live_migrate_shared_path_block_migration_fails(self):",
            "        instance, dest_check_data, drvr = self._mock_can_live_migrate_source(",
            "                block_migration=True,",
            "                is_shared_instance_path=True)",
            "",
            "        self.mox.ReplayAll()",
            "        self.assertRaises(exception.InvalidLocalStorage,",
            "                          drvr.check_can_live_migrate_source,",
            "                          self.context, instance, dest_check_data, None)",
            "",
            "    def test_check_can_live_migrate_non_shared_non_block_migration_fails(self):",
            "        instance, dest_check_data, drvr = self._mock_can_live_migrate_source()",
            "        self.mox.ReplayAll()",
            "        self.assertRaises(exception.InvalidSharedStorage,",
            "                          drvr.check_can_live_migrate_source,",
            "                          self.context, instance, dest_check_data)",
            "",
            "    def test_check_can_live_migrate_source_with_dest_not_enough_disk(self):",
            "        instance, dest_check_data, drvr = self._mock_can_live_migrate_source(",
            "                block_migration=True,",
            "                disk_available_mb=0)",
            "",
            "        drvr.get_instance_disk_info(instance,",
            "                                    block_device_info=None).AndReturn(",
            "                                        '[{\"virt_disk_size\":2}]')",
            "",
            "        self.mox.ReplayAll()",
            "        self.assertRaises(exception.MigrationError,",
            "                          drvr.check_can_live_migrate_source,",
            "                          self.context, instance, dest_check_data)",
            "",
            "    def test_check_can_live_migrate_source_booted_from_volume(self):",
            "        instance, dest_check_data, drvr = self._mock_can_live_migrate_source(",
            "                is_booted_from_volume=True,",
            "                block_device_text='[]')",
            "        self.mox.ReplayAll()",
            "        drvr.check_can_live_migrate_source(self.context, instance,",
            "                                           dest_check_data)",
            "",
            "    def test_check_can_live_migrate_source_booted_from_volume_with_swap(self):",
            "        instance, dest_check_data, drvr = self._mock_can_live_migrate_source(",
            "                is_booted_from_volume=True,",
            "                block_device_text='[{\"path\":\"disk.swap\"}]')",
            "        self.mox.ReplayAll()",
            "        self.assertRaises(exception.InvalidSharedStorage,",
            "                          drvr.check_can_live_migrate_source,",
            "                          self.context, instance, dest_check_data)",
            "",
            "    @mock.patch.object(host.Host, 'has_min_version', return_value=False)",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_assert_dest_node_has_enough_disk')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_has_local_disk')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_is_booted_from_volume')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                'get_instance_disk_info')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_is_shared_block_storage', return_value=False)",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_check_shared_storage_test_file', return_value=False)",
            "    def test_check_can_live_migrate_source_block_migration_with_bdm_error(",
            "            self, mock_check, mock_shared_block, mock_get_bdi,",
            "            mock_booted_from_volume, mock_has_local, mock_enough,",
            "            mock_min_version):",
            "",
            "        bdi = {'block_device_mapping': ['bdm']}",
            "        instance = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        dest_check_data = objects.LibvirtLiveMigrateData(",
            "            filename='file',",
            "            image_type='default',",
            "            block_migration=True,",
            "            disk_over_commit=False,",
            "            disk_available_mb=100)",
            "        self.assertRaises(exception.MigrationPreCheckError,",
            "                          drvr.check_can_live_migrate_source,",
            "                          self.context, instance, dest_check_data,",
            "                          block_device_info=bdi)",
            "",
            "    @mock.patch.object(host.Host, 'has_min_version', return_value=True)",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_assert_dest_node_has_enough_disk')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_has_local_disk')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_is_booted_from_volume')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                'get_instance_disk_info')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_is_shared_block_storage')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_check_shared_storage_test_file')",
            "    def _test_check_can_live_migrate_source_block_migration_none(",
            "            self, block_migrate, is_shared_instance_path, is_share_block,",
            "            mock_check, mock_shared_block, mock_get_bdi,",
            "            mock_booted_from_volume, mock_has_local, mock_enough, mock_verson):",
            "",
            "        mock_check.return_value = is_shared_instance_path",
            "        mock_shared_block.return_value = is_share_block",
            "        instance = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        dest_check_data = objects.LibvirtLiveMigrateData(",
            "            filename='file',",
            "            image_type='default',",
            "            disk_over_commit=False,",
            "            disk_available_mb=100)",
            "        dest_check_data_ret = drvr.check_can_live_migrate_source(",
            "                          self.context, instance, dest_check_data)",
            "        self.assertEqual(block_migrate, dest_check_data_ret.block_migration)",
            "",
            "    def test_check_can_live_migrate_source_block_migration_none_shared1(self):",
            "        self._test_check_can_live_migrate_source_block_migration_none(",
            "            False,",
            "            True,",
            "            False)",
            "",
            "    def test_check_can_live_migrate_source_block_migration_none_shared2(self):",
            "        self._test_check_can_live_migrate_source_block_migration_none(",
            "            False,",
            "            False,",
            "            True)",
            "",
            "    def test_check_can_live_migrate_source_block_migration_none_no_share(self):",
            "        self._test_check_can_live_migrate_source_block_migration_none(",
            "            True,",
            "            False,",
            "            False)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_assert_dest_node_has_enough_disk')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_assert_dest_node_has_enough_disk')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_has_local_disk')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_is_booted_from_volume')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                'get_instance_disk_info')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_is_shared_block_storage')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.'",
            "                '_check_shared_storage_test_file')",
            "    def test_check_can_live_migration_source_disk_over_commit_none(self,",
            "            mock_check, mock_shared_block, mock_get_bdi,",
            "            mock_booted_from_volume, mock_has_local,",
            "            mock_enough, mock_disk_check):",
            "",
            "        mock_check.return_value = False",
            "        mock_shared_block.return_value = False",
            "        instance = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        dest_check_data = objects.LibvirtLiveMigrateData(",
            "            filename='file',",
            "            image_type='default',",
            "            disk_available_mb=100)",
            "",
            "        drvr.check_can_live_migrate_source(",
            "            self.context, instance, dest_check_data)",
            "",
            "        self.assertFalse(mock_disk_check.called)",
            "",
            "    def _is_shared_block_storage_test_create_mocks(self, disks):",
            "        # Test data",
            "        instance_xml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                        \"<devices>{}</devices></domain>\")",
            "        disks_xml = ''",
            "        for dsk in disks:",
            "            if dsk['type'] is not 'network':",
            "                disks_xml = ''.join([disks_xml,",
            "                                \"<disk type='{type}'>\"",
            "                                \"<driver name='qemu' type='{driver}'/>\"",
            "                                \"<source {source}='{source_path}'/>\"",
            "                                \"<target dev='{target_dev}' bus='virtio'/>\"",
            "                                \"</disk>\".format(**dsk)])",
            "            else:",
            "                disks_xml = ''.join([disks_xml,",
            "                                \"<disk type='{type}'>\"",
            "                                \"<driver name='qemu' type='{driver}'/>\"",
            "                                \"<source protocol='{source_proto}'\"",
            "                                \"name='{source_image}' >\"",
            "                                \"<host name='hostname' port='7000'/>\"",
            "                                \"<config file='/path/to/file'/>\"",
            "                                \"</source>\"",
            "                                \"<target dev='{target_dev}'\"",
            "                                \"bus='ide'/>\".format(**dsk)])",
            "",
            "        # Preparing mocks",
            "        mock_virDomain = mock.Mock(fakelibvirt.virDomain)",
            "        mock_virDomain.XMLDesc = mock.Mock()",
            "        mock_virDomain.XMLDesc.return_value = (instance_xml.format(disks_xml))",
            "",
            "        mock_lookup = mock.Mock()",
            "",
            "        def mock_lookup_side_effect(name):",
            "            return mock_virDomain",
            "        mock_lookup.side_effect = mock_lookup_side_effect",
            "",
            "        mock_getsize = mock.Mock()",
            "        mock_getsize.return_value = \"10737418240\"",
            "",
            "        return (mock_getsize, mock_lookup)",
            "",
            "    def test_is_shared_block_storage_rbd(self):",
            "        self.flags(images_type='rbd', group='libvirt')",
            "        bdi = {'block_device_mapping': []}",
            "        instance = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        mock_get_instance_disk_info = mock.Mock()",
            "        data = objects.LibvirtLiveMigrateData(image_type='rbd')",
            "        with mock.patch.object(drvr, 'get_instance_disk_info',",
            "                               mock_get_instance_disk_info):",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "            self.assertTrue(drvr._is_shared_block_storage(instance, data,",
            "                                  block_device_info=bdi))",
            "        self.assertEqual(0, mock_get_instance_disk_info.call_count)",
            "",
            "    def test_is_shared_block_storage_lvm(self):",
            "        self.flags(images_type='lvm', group='libvirt')",
            "        bdi = {'block_device_mapping': []}",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_get_instance_disk_info = mock.Mock()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        data = objects.LibvirtLiveMigrateData(image_type='lvm',",
            "                                              is_volume_backed=False,",
            "                                              is_shared_instance_path=False)",
            "        with mock.patch.object(drvr, 'get_instance_disk_info',",
            "                               mock_get_instance_disk_info):",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "            self.assertFalse(drvr._is_shared_block_storage(",
            "                                    instance, data,",
            "                                    block_device_info=bdi))",
            "        self.assertEqual(0, mock_get_instance_disk_info.call_count)",
            "",
            "    def test_is_shared_block_storage_qcow2(self):",
            "        self.flags(images_type='qcow2', group='libvirt')",
            "        bdi = {'block_device_mapping': []}",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_get_instance_disk_info = mock.Mock()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        data = objects.LibvirtLiveMigrateData(image_type='qcow2',",
            "                                              is_volume_backed=False,",
            "                                              is_shared_instance_path=False)",
            "        with mock.patch.object(drvr, 'get_instance_disk_info',",
            "                               mock_get_instance_disk_info):",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "            self.assertFalse(drvr._is_shared_block_storage(",
            "                                    instance, data,",
            "                                    block_device_info=bdi))",
            "        self.assertEqual(0, mock_get_instance_disk_info.call_count)",
            "",
            "    def test_is_shared_block_storage_rbd_only_source(self):",
            "        self.flags(images_type='rbd', group='libvirt')",
            "        bdi = {'block_device_mapping': []}",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_get_instance_disk_info = mock.Mock()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        data = objects.LibvirtLiveMigrateData(is_shared_instance_path=False,",
            "                                              is_volume_backed=False)",
            "        with mock.patch.object(drvr, 'get_instance_disk_info',",
            "                               mock_get_instance_disk_info):",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "            self.assertFalse(drvr._is_shared_block_storage(",
            "                                  instance, data,",
            "                                  block_device_info=bdi))",
            "        self.assertEqual(0, mock_get_instance_disk_info.call_count)",
            "",
            "    def test_is_shared_block_storage_rbd_only_dest(self):",
            "        bdi = {'block_device_mapping': []}",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_get_instance_disk_info = mock.Mock()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        data = objects.LibvirtLiveMigrateData(image_type='rbd',",
            "                                              is_volume_backed=False,",
            "                                              is_shared_instance_path=False)",
            "        with mock.patch.object(drvr, 'get_instance_disk_info',",
            "                               mock_get_instance_disk_info):",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "            self.assertFalse(drvr._is_shared_block_storage(",
            "                                    instance, data,",
            "                                    block_device_info=bdi))",
            "        self.assertEqual(0, mock_get_instance_disk_info.call_count)",
            "",
            "    def test_is_shared_block_storage_volume_backed(self):",
            "        disks = [{'type': 'block',",
            "                 'driver': 'raw',",
            "                 'source': 'dev',",
            "                 'source_path': '/dev/disk',",
            "                 'target_dev': 'vda'}]",
            "        bdi = {'block_device_mapping': [",
            "                  {'connection_info': 'info', 'mount_device': '/dev/vda'}]}",
            "        instance = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        (mock_getsize, mock_lookup) =\\",
            "            self._is_shared_block_storage_test_create_mocks(disks)",
            "        data = objects.LibvirtLiveMigrateData(is_volume_backed=True,",
            "                                              is_shared_instance_path=False)",
            "        with mock.patch.object(host.Host, 'get_domain', mock_lookup):",
            "            self.assertTrue(drvr._is_shared_block_storage(instance, data,",
            "                                  block_device_info = bdi))",
            "        mock_lookup.assert_called_once_with(instance)",
            "",
            "    def test_is_shared_block_storage_volume_backed_with_disk(self):",
            "        disks = [{'type': 'block',",
            "                 'driver': 'raw',",
            "                 'source': 'dev',",
            "                 'source_path': '/dev/disk',",
            "                 'target_dev': 'vda'},",
            "                {'type': 'file',",
            "                 'driver': 'raw',",
            "                 'source': 'file',",
            "                 'source_path': '/instance/disk.local',",
            "                 'target_dev': 'vdb'}]",
            "        bdi = {'block_device_mapping': [",
            "                  {'connection_info': 'info', 'mount_device': '/dev/vda'}]}",
            "        instance = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        (mock_getsize, mock_lookup) =\\",
            "            self._is_shared_block_storage_test_create_mocks(disks)",
            "        data = objects.LibvirtLiveMigrateData(is_volume_backed=True,",
            "                                              is_shared_instance_path=False)",
            "        with test.nested(",
            "                mock.patch.object(os.path, 'getsize', mock_getsize),",
            "                mock.patch.object(host.Host, 'get_domain', mock_lookup)):",
            "            self.assertFalse(drvr._is_shared_block_storage(",
            "                                    instance, data,",
            "                                    block_device_info = bdi))",
            "        mock_getsize.assert_called_once_with('/instance/disk.local')",
            "        mock_lookup.assert_called_once_with(instance)",
            "",
            "    def test_is_shared_block_storage_nfs(self):",
            "        bdi = {'block_device_mapping': []}",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        mock_image_backend = mock.MagicMock()",
            "        drvr.image_backend = mock_image_backend",
            "        mock_backend = mock.MagicMock()",
            "        mock_image_backend.backend.return_value = mock_backend",
            "        mock_backend.is_file_in_instance_path.return_value = True",
            "        mock_get_instance_disk_info = mock.Mock()",
            "        data = objects.LibvirtLiveMigrateData(",
            "            is_shared_instance_path=True,",
            "            image_type='foo')",
            "        with mock.patch.object(drvr, 'get_instance_disk_info',",
            "                               mock_get_instance_disk_info):",
            "            self.assertTrue(drvr._is_shared_block_storage(",
            "                'instance', data, block_device_info=bdi))",
            "        self.assertEqual(0, mock_get_instance_disk_info.call_count)",
            "",
            "    def test_live_migration_update_graphics_xml(self):",
            "        self.compute = importutils.import_object(CONF.compute_manager)",
            "        instance_dict = dict(self.test_instance)",
            "        instance_dict.update({'host': 'fake',",
            "                              'power_state': power_state.RUNNING,",
            "                              'vm_state': vm_states.ACTIVE})",
            "        instance_ref = objects.Instance(**instance_dict)",
            "",
            "        xml_tmpl = (\"<domain type='kvm'>\"",
            "                    \"<devices>\"",
            "                    \"<graphics type='vnc' listen='{vnc}'>\"",
            "                    \"<listen address='{vnc}'/>\"",
            "                    \"</graphics>\"",
            "                    \"<graphics type='spice' listen='{spice}'>\"",
            "                    \"<listen address='{spice}'/>\"",
            "                    \"</graphics>\"",
            "                    \"</devices>\"",
            "                    \"</domain>\")",
            "",
            "        initial_xml = xml_tmpl.format(vnc='1.2.3.4',",
            "                                      spice='5.6.7.8')",
            "",
            "        target_xml = xml_tmpl.format(vnc='10.0.0.1',",
            "                                     spice='10.0.0.2')",
            "        target_xml = etree.tostring(etree.fromstring(target_xml))",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        # Preparing mocks",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"migrateToURI2\")",
            "        _bandwidth = CONF.libvirt.live_migration_bandwidth",
            "        vdmock.XMLDesc(flags=fakelibvirt.VIR_DOMAIN_XML_MIGRATABLE).AndReturn(",
            "                initial_xml)",
            "        vdmock.migrateToURI2(drvr._live_migration_uri('dest'),",
            "                             None,",
            "                             target_xml,",
            "                             mox.IgnoreArg(),",
            "                             None,",
            "                             _bandwidth).AndRaise(",
            "                                fakelibvirt.libvirtError(\"ERR\"))",
            "",
            "        # start test",
            "        migrate_data = {'pre_live_migration_result':",
            "                {'graphics_listen_addrs':",
            "                    {'vnc': '10.0.0.1', 'spice': '10.0.0.2'}}}",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            graphics_listen_addr_vnc='10.0.0.1',",
            "            graphics_listen_addr_spice='10.0.0.2',",
            "            serial_listen_addr='127.0.0.1',",
            "            target_connect_addr=None,",
            "            bdms=[])",
            "        self.mox.ReplayAll()",
            "        self.assertRaises(fakelibvirt.libvirtError,",
            "                          drvr._live_migration_operation,",
            "                          self.context, instance_ref, 'dest',",
            "                          False, migrate_data, vdmock, [])",
            "",
            "    def test_live_migration_update_volume_xml(self):",
            "        self.compute = importutils.import_object(CONF.compute_manager)",
            "        instance_dict = dict(self.test_instance)",
            "        instance_dict.update({'host': 'fake',",
            "                              'power_state': power_state.RUNNING,",
            "                              'vm_state': vm_states.ACTIVE})",
            "        instance_ref = objects.Instance(**instance_dict)",
            "        target_xml = self.device_xml_tmpl.format(",
            "            device_path='/dev/disk/by-path/'",
            "            'ip-1.2.3.4:3260-iqn.'",
            "            'cde.67890.opst-lun-Z')",
            "        # start test",
            "        connection_info = {",
            "            u'driver_volume_type': u'iscsi',",
            "            u'serial': u'58a84f6d-3f0c-4e19-a0af-eb657b790657',",
            "            u'data': {",
            "                u'access_mode': u'rw', u'target_discovered': False,",
            "                u'target_iqn': u'ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z',",
            "                u'volume_id': u'58a84f6d-3f0c-4e19-a0af-eb657b790657',",
            "                'device_path':",
            "                u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z',",
            "            },",
            "        }",
            "        bdm = objects.LibvirtLiveMigrateBDMInfo(",
            "            serial='58a84f6d-3f0c-4e19-a0af-eb657b790657',",
            "            bus='virtio', type='disk', dev='vdb',",
            "            connection_info=connection_info)",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            serial_listen_addr='',",
            "            target_connect_addr=None,",
            "            bdms=[bdm])",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        test_mock = mock.MagicMock()",
            "",
            "        with mock.patch.object(libvirt_driver.LibvirtDriver, 'get_info') as \\",
            "                mget_info,\\",
            "                mock.patch.object(drvr._host, 'get_domain') as mget_domain,\\",
            "                mock.patch.object(fakelibvirt.virDomain, 'migrateToURI2'),\\",
            "                mock.patch.object(drvr, '_update_xml') as mupdate:",
            "",
            "            mget_info.side_effect = exception.InstanceNotFound(",
            "                                     instance_id='foo')",
            "            mget_domain.return_value = test_mock",
            "            test_mock.XMLDesc.return_value = target_xml",
            "            self.assertFalse(drvr._live_migration_operation(",
            "                             self.context, instance_ref, 'dest', False,",
            "                             migrate_data, test_mock, []))",
            "            mupdate.assert_called_once_with(target_xml, migrate_data.bdms,",
            "                                            {}, '')",
            "",
            "    def test_live_migration_with_valid_target_connect_addr(self):",
            "        self.compute = importutils.import_object(CONF.compute_manager)",
            "        instance_dict = dict(self.test_instance)",
            "        instance_dict.update({'host': 'fake',",
            "                              'power_state': power_state.RUNNING,",
            "                              'vm_state': vm_states.ACTIVE})",
            "        instance_ref = objects.Instance(**instance_dict)",
            "        target_xml = self.device_xml_tmpl.format(",
            "            device_path='/dev/disk/by-path/'",
            "            'ip-1.2.3.4:3260-iqn.'",
            "            'cde.67890.opst-lun-Z')",
            "        # start test",
            "        connection_info = {",
            "            u'driver_volume_type': u'iscsi',",
            "            u'serial': u'58a84f6d-3f0c-4e19-a0af-eb657b790657',",
            "            u'data': {",
            "                u'access_mode': u'rw', u'target_discovered': False,",
            "                u'target_iqn': u'ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z',",
            "                u'volume_id': u'58a84f6d-3f0c-4e19-a0af-eb657b790657',",
            "                'device_path':",
            "                u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z',",
            "            },",
            "        }",
            "        bdm = objects.LibvirtLiveMigrateBDMInfo(",
            "            serial='58a84f6d-3f0c-4e19-a0af-eb657b790657',",
            "            bus='virtio', type='disk', dev='vdb',",
            "            connection_info=connection_info)",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            serial_listen_addr='',",
            "            target_connect_addr='127.0.0.2',",
            "            bdms=[bdm])",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        test_mock = mock.MagicMock()",
            "",
            "        with mock.patch.object(drvr, '_update_xml') as mupdate:",
            "",
            "            test_mock.XMLDesc.return_value = target_xml",
            "            drvr._live_migration_operation(self.context, instance_ref,",
            "                                           'dest', False, migrate_data,",
            "                                           test_mock, [])",
            "            test_mock.migrateToURI2.assert_called_once_with(",
            "                'qemu+tcp://127.0.0.2/system',",
            "                None, mupdate(), None, None, 0)",
            "",
            "    def test_update_volume_xml(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        initial_xml = self.device_xml_tmpl.format(",
            "            device_path='/dev/disk/by-path/'",
            "            'ip-1.2.3.4:3260-iqn.'",
            "            'abc.12345.opst-lun-X')",
            "        target_xml = self.device_xml_tmpl.format(",
            "            device_path='/dev/disk/by-path/'",
            "            'ip-1.2.3.4:3260-iqn.'",
            "            'cde.67890.opst-lun-Z')",
            "        target_xml = etree.tostring(etree.fromstring(target_xml))",
            "        serial = \"58a84f6d-3f0c-4e19-a0af-eb657b790657\"",
            "",
            "        bdmi = objects.LibvirtLiveMigrateBDMInfo(serial=serial,",
            "                                                 bus='virtio',",
            "                                                 type='disk',",
            "                                                 dev='vdb')",
            "        bdmi.connection_info = {u'driver_volume_type': u'iscsi',",
            "           'serial': u'58a84f6d-3f0c-4e19-a0af-eb657b790657',",
            "            u'data': {u'access_mode': u'rw', u'target_discovered': False,",
            "            u'target_iqn': u'ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z',",
            "            u'volume_id': u'58a84f6d-3f0c-4e19-a0af-eb657b790657',",
            "           'device_path':",
            "              u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z'}}",
            "",
            "        conf = vconfig.LibvirtConfigGuestDisk()",
            "        conf.source_device = bdmi.type",
            "        conf.driver_name = \"qemu\"",
            "        conf.driver_format = \"raw\"",
            "        conf.driver_cache = \"none\"",
            "        conf.target_dev = bdmi.dev",
            "        conf.target_bus = bdmi.bus",
            "        conf.serial = bdmi.connection_info.get('serial')",
            "        conf.source_type = \"block\"",
            "        conf.source_path = bdmi.connection_info['data'].get('device_path')",
            "",
            "        with mock.patch.object(drvr, '_get_volume_config',",
            "                               return_value=conf):",
            "            parser = etree.XMLParser(remove_blank_text=True)",
            "            xml_doc = etree.fromstring(initial_xml, parser)",
            "            config = drvr._update_volume_xml(xml_doc, [bdmi])",
            "            xml_doc = etree.fromstring(target_xml, parser)",
            "            self.assertEqual(etree.tostring(xml_doc), etree.tostring(config))",
            "",
            "    def test_live_migration_uri(self):",
            "        hypervisor_uri_map = (",
            "            ('xen', 'xenmigr://%s/system'),",
            "            ('kvm', 'qemu+tcp://%s/system'),",
            "            ('qemu', 'qemu+tcp://%s/system'),",
            "            # anything else will return None",
            "            ('lxc', None),",
            "            ('parallels', None),",
            "            ('', None),",
            "        )",
            "        dest = 'destination'",
            "        for hyperv, uri in hypervisor_uri_map:",
            "            self.flags(virt_type=hyperv, group='libvirt')",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "            if uri is not None:",
            "                uri = uri % dest",
            "                self.assertEqual(uri, drvr._live_migration_uri(dest))",
            "            else:",
            "                self.assertRaises(exception.LiveMigrationURINotAvailable,",
            "                                  drvr._live_migration_uri,",
            "                                  dest)",
            "",
            "    def test_live_migration_uri_forced(self):",
            "        dest = 'destination'",
            "        for hyperv in ('kvm', 'xen'):",
            "            self.flags(virt_type=hyperv, group='libvirt')",
            "",
            "            forced_uri = 'foo://%s/bar'",
            "            self.flags(live_migration_uri=forced_uri, group='libvirt')",
            "",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "            self.assertEqual(forced_uri % dest, drvr._live_migration_uri(dest))",
            "",
            "    def test_update_volume_xml_no_serial(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        xml_tmpl = \"\"\"",
            "        <domain type='kvm'>",
            "          <devices>",
            "            <disk type='block' device='disk'>",
            "              <driver name='qemu' type='raw' cache='none'/>",
            "              <source dev='{device_path}'/>",
            "              <target bus='virtio' dev='vdb'/>",
            "              <serial></serial>",
            "              <address type='pci' domain='0x0' bus='0x0' slot='0x04' \\",
            "              function='0x0'/>",
            "            </disk>",
            "          </devices>",
            "        </domain>",
            "        \"\"\"",
            "",
            "        initial_xml = xml_tmpl.format(device_path='/dev/disk/by-path/'",
            "                                      'ip-1.2.3.4:3260-iqn.'",
            "                                      'abc.12345.opst-lun-X')",
            "        target_xml = xml_tmpl.format(device_path='/dev/disk/by-path/'",
            "                                     'ip-1.2.3.4:3260-iqn.'",
            "                                     'abc.12345.opst-lun-X')",
            "        target_xml = etree.tostring(etree.fromstring(target_xml))",
            "        serial = \"58a84f6d-3f0c-4e19-a0af-eb657b790657\"",
            "        connection_info = {",
            "            u'driver_volume_type': u'iscsi',",
            "            'serial': u'58a84f6d-3f0c-4e19-a0af-eb657b790657',",
            "            u'data': {",
            "                u'access_mode': u'rw', u'target_discovered': False,",
            "                u'target_iqn': u'ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z',",
            "                u'volume_id': u'58a84f6d-3f0c-4e19-a0af-eb657b790657',",
            "                u'device_path':",
            "                u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z',",
            "            },",
            "        }",
            "        bdmi = objects.LibvirtLiveMigrateBDMInfo(serial=serial,",
            "                                                 bus='virtio',",
            "                                                 dev='vdb',",
            "                                                 type='disk')",
            "        bdmi.connection_info = connection_info",
            "",
            "        conf = vconfig.LibvirtConfigGuestDisk()",
            "        conf.source_device = bdmi.type",
            "        conf.driver_name = \"qemu\"",
            "        conf.driver_format = \"raw\"",
            "        conf.driver_cache = \"none\"",
            "        conf.target_dev = bdmi.dev",
            "        conf.target_bus = bdmi.bus",
            "        conf.serial = bdmi.connection_info.get('serial')",
            "        conf.source_type = \"block\"",
            "        conf.source_path = bdmi.connection_info['data'].get('device_path')",
            "",
            "        with mock.patch.object(drvr, '_get_volume_config',",
            "                               return_value=conf):",
            "            xml_doc = etree.fromstring(initial_xml)",
            "            config = drvr._update_volume_xml(xml_doc, [bdmi])",
            "            self.assertEqual(target_xml, etree.tostring(config))",
            "",
            "    def test_update_volume_xml_no_connection_info(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        initial_xml = self.device_xml_tmpl.format(",
            "            device_path='/dev/disk/by-path/'",
            "            'ip-1.2.3.4:3260-iqn.'",
            "            'abc.12345.opst-lun-X')",
            "        target_xml = self.device_xml_tmpl.format(",
            "            device_path='/dev/disk/by-path/'",
            "            'ip-1.2.3.4:3260-iqn.'",
            "            'abc.12345.opst-lun-X')",
            "        target_xml = etree.tostring(etree.fromstring(target_xml))",
            "        serial = \"58a84f6d-3f0c-4e19-a0af-eb657b790657\"",
            "        bdmi = objects.LibvirtLiveMigrateBDMInfo(serial=serial,",
            "                                                 dev='vdb',",
            "                                                 type='disk',",
            "                                                 bus='scsi',",
            "                                                 format='qcow')",
            "        bdmi.connection_info = {}",
            "        conf = vconfig.LibvirtConfigGuestDisk()",
            "        with mock.patch.object(drvr, '_get_volume_config',",
            "                               return_value=conf):",
            "            xml_doc = etree.fromstring(initial_xml)",
            "            config = drvr._update_volume_xml(xml_doc, [bdmi])",
            "            self.assertEqual(target_xml, etree.tostring(config))",
            "",
            "    @mock.patch.object(fakelibvirt.virDomain, \"migrateToURI2\")",
            "    @mock.patch.object(fakelibvirt.virDomain, \"XMLDesc\")",
            "    def test_live_migration_update_serial_console_xml(self, mock_xml,",
            "                                                      mock_migrate):",
            "        self.compute = importutils.import_object(CONF.compute_manager)",
            "        instance_ref = self.test_instance",
            "",
            "        xml_tmpl = (\"<domain type='kvm'>\"",
            "                    \"<devices>\"",
            "                    \"<console type='tcp'>\"",
            "                    \"<source mode='bind' host='{addr}' service='10000'/>\"",
            "                    \"</console>\"",
            "                    \"</devices>\"",
            "                    \"</domain>\")",
            "",
            "        initial_xml = xml_tmpl.format(addr='9.0.0.1')",
            "",
            "        target_xml = xml_tmpl.format(addr='9.0.0.12')",
            "        target_xml = etree.tostring(etree.fromstring(target_xml))",
            "",
            "        # Preparing mocks",
            "        mock_xml.return_value = initial_xml",
            "        mock_migrate.side_effect = fakelibvirt.libvirtError(\"ERR\")",
            "",
            "        # start test",
            "        bandwidth = CONF.libvirt.live_migration_bandwidth",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            graphics_listen_addr_vnc='10.0.0.1',",
            "            graphics_listen_addr_spice='10.0.0.2',",
            "            serial_listen_addr='9.0.0.12',",
            "            target_connect_addr=None,",
            "            bdms=[])",
            "        dom = fakelibvirt.virDomain",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertRaises(fakelibvirt.libvirtError,",
            "                          drvr._live_migration_operation,",
            "                          self.context, instance_ref, 'dest',",
            "                          False, migrate_data, dom, [])",
            "        mock_xml.assert_called_once_with(",
            "                flags=fakelibvirt.VIR_DOMAIN_XML_MIGRATABLE)",
            "        mock_migrate.assert_called_once_with(",
            "                drvr._live_migration_uri('dest'),",
            "                None, target_xml, mock.ANY, None, bandwidth)",
            "",
            "    @mock.patch.object(fakelibvirt, 'VIR_DOMAIN_XML_MIGRATABLE', None,",
            "                       create=True)",
            "    def test_live_migration_fails_with_serial_console_without_migratable(self):",
            "        self.compute = importutils.import_object(CONF.compute_manager)",
            "        instance_ref = self.test_instance",
            "",
            "        CONF.set_override(\"enabled\", True, \"serial_console\")",
            "        dom = fakelibvirt.virDomain",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            serial_listen_addr='', target_connect_addr=None)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertRaises(exception.MigrationError,",
            "                          drvr._live_migration_operation,",
            "                          self.context, instance_ref, 'dest',",
            "                          False, migrate_data, dom, [])",
            "",
            "    @mock.patch.object(fakelibvirt, 'VIR_DOMAIN_XML_MIGRATABLE', None,",
            "                       create=True)",
            "    def test_live_migration_uses_migrateToURI_without_migratable_flag(self):",
            "        self.compute = importutils.import_object(CONF.compute_manager)",
            "        instance_dict = dict(self.test_instance)",
            "        instance_dict.update({'host': 'fake',",
            "                              'power_state': power_state.RUNNING,",
            "                              'vm_state': vm_states.ACTIVE})",
            "        instance_ref = objects.Instance(**instance_dict)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        # Preparing mocks",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"migrateToURI\")",
            "        _bandwidth = CONF.libvirt.live_migration_bandwidth",
            "        vdmock.migrateToURI(drvr._live_migration_uri('dest'),",
            "                            mox.IgnoreArg(),",
            "                            None,",
            "                            _bandwidth).AndRaise(",
            "                                fakelibvirt.libvirtError(\"ERR\"))",
            "",
            "        # start test",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            graphics_listen_addr_vnc='0.0.0.0',",
            "            graphics_listen_addr_spice='0.0.0.0',",
            "            serial_listen_addr='127.0.0.1',",
            "            target_connect_addr=None,",
            "            bdms=[])",
            "        self.mox.ReplayAll()",
            "        self.assertRaises(fakelibvirt.libvirtError,",
            "                          drvr._live_migration_operation,",
            "                          self.context, instance_ref, 'dest',",
            "                          False, migrate_data, vdmock, [])",
            "",
            "    def test_live_migration_uses_migrateToURI_without_dest_listen_addrs(self):",
            "        self.compute = importutils.import_object(CONF.compute_manager)",
            "        instance_dict = dict(self.test_instance)",
            "        instance_dict.update({'host': 'fake',",
            "                              'power_state': power_state.RUNNING,",
            "                              'vm_state': vm_states.ACTIVE})",
            "        instance_ref = objects.Instance(**instance_dict)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        # Preparing mocks",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"migrateToURI\")",
            "        _bandwidth = CONF.libvirt.live_migration_bandwidth",
            "        vdmock.migrateToURI(drvr._live_migration_uri('dest'),",
            "                            mox.IgnoreArg(),",
            "                            None,",
            "                            _bandwidth).AndRaise(",
            "                                fakelibvirt.libvirtError(\"ERR\"))",
            "",
            "        # start test",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            serial_listen_addr='',",
            "            target_connect_addr=None,",
            "            bdms=[])",
            "        self.mox.ReplayAll()",
            "        self.assertRaises(fakelibvirt.libvirtError,",
            "                          drvr._live_migration_operation,",
            "                          self.context, instance_ref, 'dest',",
            "                          False, migrate_data, vdmock, [])",
            "",
            "    @mock.patch.object(host.Host, 'has_min_version', return_value=True)",
            "    @mock.patch.object(fakelibvirt.virDomain, \"migrateToURI3\")",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._update_xml',",
            "                return_value='')",
            "    @mock.patch('nova.virt.libvirt.guest.Guest.get_xml_desc', return_value='')",
            "    def test_live_migration_uses_migrateToURI3(",
            "            self, mock_old_xml, mock_new_xml, mock_migrateToURI3,",
            "            mock_min_version):",
            "        # Preparing mocks",
            "        disk_paths = ['vda', 'vdb']",
            "        params = {",
            "            'migrate_disks': ['vda', 'vdb'],",
            "            'bandwidth': CONF.libvirt.live_migration_bandwidth,",
            "            'destination_xml': '',",
            "        }",
            "        mock_migrateToURI3.side_effect = fakelibvirt.libvirtError(\"ERR\")",
            "",
            "        # Start test",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            graphics_listen_addr_vnc='0.0.0.0',",
            "            graphics_listen_addr_spice='0.0.0.0',",
            "            serial_listen_addr='127.0.0.1',",
            "            target_connect_addr=None,",
            "            bdms=[])",
            "",
            "        dom = fakelibvirt.virDomain",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        self.assertRaises(fakelibvirt.libvirtError,",
            "                          drvr._live_migration_operation,",
            "                          self.context, instance, 'dest',",
            "                          False, migrate_data, dom, disk_paths)",
            "        mock_migrateToURI3.assert_called_once_with(",
            "                drvr._live_migration_uri('dest'), params, None)",
            "",
            "    @mock.patch.object(fakelibvirt, 'VIR_DOMAIN_XML_MIGRATABLE', None,",
            "                       create=True)",
            "    def test_live_migration_fails_without_migratable_flag_or_0_addr(self):",
            "        self.flags(enabled=True, vncserver_listen='1.2.3.4', group='vnc')",
            "        self.compute = importutils.import_object(CONF.compute_manager)",
            "        instance_dict = dict(self.test_instance)",
            "        instance_dict.update({'host': 'fake',",
            "                              'power_state': power_state.RUNNING,",
            "                              'vm_state': vm_states.ACTIVE})",
            "        instance_ref = objects.Instance(**instance_dict)",
            "",
            "        # Preparing mocks",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"migrateToURI\")",
            "",
            "        # start test",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            graphics_listen_addr_vnc='1.2.3.4',",
            "            graphics_listen_addr_spice='1.2.3.4',",
            "            serial_listen_addr='127.0.0.1',",
            "            target_connect_addr=None)",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertRaises(exception.MigrationError,",
            "                          drvr._live_migration_operation,",
            "                          self.context, instance_ref, 'dest',",
            "                          False, migrate_data, vdmock, [])",
            "",
            "    def test_live_migration_raises_exception(self):",
            "        # Confirms recover method is called when exceptions are raised.",
            "        # Preparing data",
            "        self.compute = importutils.import_object(CONF.compute_manager)",
            "        instance_dict = dict(self.test_instance)",
            "        instance_dict.update({'host': 'fake',",
            "                              'power_state': power_state.RUNNING,",
            "                              'vm_state': vm_states.ACTIVE})",
            "        instance_ref = objects.Instance(**instance_dict)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        # Preparing mocks",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"migrateToURI2\")",
            "        _bandwidth = CONF.libvirt.live_migration_bandwidth",
            "        if getattr(fakelibvirt, 'VIR_DOMAIN_XML_MIGRATABLE', None) is None:",
            "            vdmock.migrateToURI(drvr._live_migration_uri('dest'),",
            "                                mox.IgnoreArg(),",
            "                                None,",
            "                                _bandwidth).AndRaise(",
            "                                        fakelibvirt.libvirtError('ERR'))",
            "        else:",
            "            vdmock.XMLDesc(flags=fakelibvirt.VIR_DOMAIN_XML_MIGRATABLE",
            "            ).AndReturn(FakeVirtDomain().XMLDesc(flags=0))",
            "            vdmock.migrateToURI2(drvr._live_migration_uri('dest'),",
            "                                 None,",
            "                                 mox.IgnoreArg(),",
            "                                 mox.IgnoreArg(),",
            "                                 None,",
            "                                 _bandwidth).AndRaise(",
            "                                         fakelibvirt.libvirtError('ERR'))",
            "",
            "        # start test",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            graphics_listen_addr_vnc='127.0.0.1',",
            "            graphics_listen_addr_spice='127.0.0.1',",
            "            serial_listen_addr='127.0.0.1',",
            "            target_connect_addr=None,",
            "            bdms=[])",
            "        self.mox.ReplayAll()",
            "        self.assertRaises(fakelibvirt.libvirtError,",
            "                          drvr._live_migration_operation,",
            "                          self.context, instance_ref, 'dest',",
            "                          False, migrate_data, vdmock, [])",
            "",
            "        self.assertEqual(vm_states.ACTIVE, instance_ref.vm_state)",
            "        self.assertEqual(power_state.RUNNING, instance_ref.power_state)",
            "",
            "    def test_live_migration_raises_unsupported_config_exception(self):",
            "        # Tests that when migrateToURI2 fails with VIR_ERR_CONFIG_UNSUPPORTED,",
            "        # migrateToURI is used instead.",
            "",
            "        # Preparing data",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        # Preparing mocks",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, 'migrateToURI2')",
            "        self.mox.StubOutWithMock(vdmock, 'migrateToURI')",
            "        _bandwidth = CONF.libvirt.live_migration_bandwidth",
            "        vdmock.XMLDesc(flags=fakelibvirt.VIR_DOMAIN_XML_MIGRATABLE).AndReturn(",
            "                FakeVirtDomain().XMLDesc(flags=0))",
            "        unsupported_config_error = fakelibvirt.libvirtError('ERR')",
            "        unsupported_config_error.err = (",
            "            fakelibvirt.VIR_ERR_CONFIG_UNSUPPORTED,)",
            "        # This is the first error we hit but since the error code is",
            "        # VIR_ERR_CONFIG_UNSUPPORTED we'll try migrateToURI.",
            "        vdmock.migrateToURI2(drvr._live_migration_uri('dest'), None,",
            "                             mox.IgnoreArg(), mox.IgnoreArg(), None,",
            "                             _bandwidth).AndRaise(unsupported_config_error)",
            "        # This is the second and final error that will actually kill the run,",
            "        # we use TestingException to make sure it's not the same libvirtError",
            "        # above.",
            "        vdmock.migrateToURI(drvr._live_migration_uri('dest'),",
            "                            mox.IgnoreArg(), None,",
            "                            _bandwidth).AndRaise(test.TestingException('oops'))",
            "",
            "        graphics_listen_addrs = {'vnc': '0.0.0.0', 'spice': '127.0.0.1'}",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            graphics_listen_addr_vnc='0.0.0.0',",
            "            graphics_listen_addr_spice='127.0.0.1',",
            "            serial_listen_addr='127.0.0.1',",
            "            target_connect_addr=None,",
            "            bdms=[])",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        self.mox.StubOutWithMock(",
            "            drvr, '_check_graphics_addresses_can_live_migrate')",
            "        drvr._check_graphics_addresses_can_live_migrate(graphics_listen_addrs)",
            "        self.mox.ReplayAll()",
            "",
            "        # start test",
            "        self.assertRaises(test.TestingException,",
            "                          drvr._live_migration_operation,",
            "                          self.context, instance_ref, 'dest',",
            "                          False, migrate_data, vdmock, [])",
            "",
            "    @mock.patch('shutil.rmtree')",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path_at_destination')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.destroy')",
            "    def test_rollback_live_migration_at_dest_not_shared(self, mock_destroy,",
            "                                                        mock_get_instance_path,",
            "                                                        mock_exist,",
            "                                                        mock_shutil",
            "                                                        ):",
            "        # destroy method may raise InstanceTerminationFailure or",
            "        # InstancePowerOffFailure, here use their base class Invalid.",
            "        mock_destroy.side_effect = exception.Invalid(reason='just test')",
            "        fake_instance_path = os.path.join(cfg.CONF.instances_path,",
            "                                          '/fake_instance_uuid')",
            "        mock_get_instance_path.return_value = fake_instance_path",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            is_shared_instance_path=False,",
            "            instance_relative_path=False)",
            "        self.assertRaises(exception.Invalid,",
            "                          drvr.rollback_live_migration_at_destination,",
            "                          \"context\", \"instance\", [], None, True, migrate_data)",
            "        mock_exist.assert_called_once_with(fake_instance_path)",
            "        mock_shutil.assert_called_once_with(fake_instance_path)",
            "",
            "    @mock.patch('shutil.rmtree')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path_at_destination')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.destroy')",
            "    def test_rollback_live_migration_at_dest_shared(self, mock_destroy,",
            "                                                    mock_get_instance_path,",
            "                                                    mock_exist,",
            "                                                    mock_shutil",
            "                                                    ):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            is_shared_instance_path=True,",
            "            instance_relative_path=False)",
            "        drvr.rollback_live_migration_at_destination(\"context\", \"instance\", [],",
            "                                                    None, True, migrate_data)",
            "        mock_destroy.assert_called_once_with(\"context\", \"instance\", [],",
            "                                             None, True, migrate_data)",
            "        self.assertFalse(mock_get_instance_path.called)",
            "        self.assertFalse(mock_exist.called)",
            "        self.assertFalse(mock_shutil.called)",
            "",
            "    @mock.patch.object(host.Host, \"has_min_version\", return_value=False)",
            "    @mock.patch.object(fakelibvirt.Domain, \"XMLDesc\")",
            "    def test_live_migration_copy_disk_paths(self, mock_xml, mock_version):",
            "        xml = \"\"\"",
            "        <domain>",
            "          <name>dummy</name>",
            "          <uuid>d4e13113-918e-42fe-9fc9-861693ffd432</uuid>",
            "          <devices>",
            "            <disk type=\"file\">",
            "               <source file=\"/var/lib/nova/instance/123/disk.root\"/>",
            "               <target dev=\"vda\"/>",
            "            </disk>",
            "            <disk type=\"file\">",
            "               <source file=\"/var/lib/nova/instance/123/disk.shared\"/>",
            "               <target dev=\"vdb\"/>",
            "               <shareable/>",
            "            </disk>",
            "            <disk type=\"file\">",
            "               <source file=\"/var/lib/nova/instance/123/disk.config\"/>",
            "               <target dev=\"vdc\"/>",
            "               <readonly/>",
            "            </disk>",
            "            <disk type=\"block\">",
            "               <source dev=\"/dev/mapper/somevol\"/>",
            "               <target dev=\"vdd\"/>",
            "            </disk>",
            "            <disk type=\"network\">",
            "               <source protocol=\"https\" name=\"url_path\">",
            "                 <host name=\"hostname\" port=\"443\"/>",
            "               </source>",
            "            </disk>",
            "          </devices>",
            "        </domain>\"\"\"",
            "        mock_xml.return_value = xml",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        dom = fakelibvirt.Domain(drvr._get_connection(), xml, False)",
            "        guest = libvirt_guest.Guest(dom)",
            "",
            "        paths = drvr._live_migration_copy_disk_paths(None, None, guest)",
            "        self.assertEqual(([\"/var/lib/nova/instance/123/disk.root\",",
            "                          \"/dev/mapper/somevol\"], ['vda', 'vdd']), paths)",
            "",
            "    @mock.patch.object(host.Host, \"has_min_version\", return_value=True)",
            "    @mock.patch('nova.virt.driver.get_block_device_info')",
            "    @mock.patch('nova.objects.BlockDeviceMappingList.get_by_instance_uuid')",
            "    @mock.patch.object(fakelibvirt.Domain, \"XMLDesc\")",
            "    def test_live_migration_copy_disk_paths_selective_block_migration(",
            "            self, mock_xml, mock_get_instance,",
            "            mock_block_device_info, mock_version):",
            "        xml = \"\"\"",
            "        <domain>",
            "          <name>dummy</name>",
            "          <uuid>d4e13113-918e-42fe-9fc9-861693ffd432</uuid>",
            "          <devices>",
            "            <disk type=\"file\">",
            "               <source file=\"/var/lib/nova/instance/123/disk.root\"/>",
            "               <target dev=\"vda\"/>",
            "            </disk>",
            "            <disk type=\"file\">",
            "               <source file=\"/var/lib/nova/instance/123/disk.shared\"/>",
            "               <target dev=\"vdb\"/>",
            "            </disk>",
            "            <disk type=\"file\">",
            "               <source file=\"/var/lib/nova/instance/123/disk.config\"/>",
            "               <target dev=\"vdc\"/>",
            "            </disk>",
            "            <disk type=\"block\">",
            "               <source dev=\"/dev/mapper/somevol\"/>",
            "               <target dev=\"vdd\"/>",
            "            </disk>",
            "            <disk type=\"network\">",
            "               <source protocol=\"https\" name=\"url_path\">",
            "                 <host name=\"hostname\" port=\"443\"/>",
            "               </source>",
            "            </disk>",
            "          </devices>",
            "        </domain>\"\"\"",
            "        mock_xml.return_value = xml",
            "        instance = objects.Instance(**self.test_instance)",
            "        instance.root_device_name = '/dev/vda'",
            "        block_device_info = {",
            "            'swap': {",
            "                'disk_bus': u'virtio',",
            "                'swap_size': 10,",
            "                'device_name': u'/dev/vdc'",
            "            },",
            "            'root_device_name': u'/dev/vda',",
            "            'ephemerals': [{",
            "                'guest_format': u'ext3',",
            "                'device_name': u'/dev/vdb',",
            "                'disk_bus': u'virtio',",
            "                'device_type': u'disk',",
            "                'size': 1",
            "            }],",
            "            'block_device_mapping': [{",
            "                'guest_format': None,",
            "                'boot_index': None,",
            "                'mount_device': u'/dev/vdd',",
            "                'connection_info': {",
            "                    u'driver_volume_type': u'iscsi',",
            "                    'serial': u'147df29f-aec2-4851-b3fe-f68dad151834',",
            "                    u'data': {",
            "                        u'access_mode': u'rw',",
            "                        u'target_discovered': False,",
            "                        u'encrypted': False,",
            "                        u'qos_specs': None,",
            "                        u'target_iqn': u'iqn.2010-10.org.openstack:'",
            "                                       u'volume-147df29f-aec2-4851-b3fe-'",
            "                                       u'f68dad151834',",
            "                        u'target_portal': u'10.102.44.141:3260', u'volume_id':",
            "                            u'147df29f-aec2-4851-b3fe-f68dad151834',",
            "                        u'target_lun': 1,",
            "                        u'auth_password': u'cXELT66FngwzTwpf',",
            "                        u'auth_username': u'QbQQjj445uWgeQkFKcVw',",
            "                        u'auth_method': u'CHAP'",
            "                    }",
            "                },",
            "                'disk_bus': None,",
            "                'device_type': None,",
            "                'delete_on_termination': False",
            "            }]",
            "        }",
            "        mock_block_device_info.return_value = block_device_info",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        dom = fakelibvirt.Domain(drvr._get_connection(), xml, False)",
            "        guest = libvirt_guest.Guest(dom)",
            "        return_value = drvr._live_migration_copy_disk_paths(context, instance,",
            "                                                            guest)",
            "        expected = (['/var/lib/nova/instance/123/disk.root',",
            "                     '/var/lib/nova/instance/123/disk.shared',",
            "                     '/var/lib/nova/instance/123/disk.config'],",
            "                    ['vda', 'vdb', 'vdc'])",
            "        self.assertEqual(expected, return_value)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver,",
            "                       \"_live_migration_copy_disk_paths\")",
            "    def test_live_migration_data_gb_plain(self, mock_paths):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        data_gb = drvr._live_migration_data_gb(instance, [])",
            "        self.assertEqual(2, data_gb)",
            "        self.assertEqual(0, mock_paths.call_count)",
            "",
            "    def test_live_migration_data_gb_block(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        def fake_stat(path):",
            "            class StatResult(object):",
            "                def __init__(self, size):",
            "                    self._size = size",
            "",
            "                @property",
            "                def st_size(self):",
            "                    return self._size",
            "",
            "            if path == \"/var/lib/nova/instance/123/disk.root\":",
            "                return StatResult(10 * units.Gi)",
            "            elif path == \"/dev/mapper/somevol\":",
            "                return StatResult(1.5 * units.Gi)",
            "            else:",
            "                raise Exception(\"Should not be reached\")",
            "",
            "        disk_paths = [\"/var/lib/nova/instance/123/disk.root\",",
            "                      \"/dev/mapper/somevol\"]",
            "        with mock.patch.object(os, \"stat\") as mock_stat:",
            "            mock_stat.side_effect = fake_stat",
            "            data_gb = drvr._live_migration_data_gb(instance, disk_paths)",
            "            # Expecting 2 GB for RAM, plus 10 GB for disk.root",
            "            # and 1.5 GB rounded to 2 GB for somevol, so 14 GB",
            "            self.assertEqual(14, data_gb)",
            "",
            "    EXPECT_SUCCESS = 1",
            "    EXPECT_FAILURE = 2",
            "    EXPECT_ABORT = 3",
            "",
            "    @mock.patch.object(time, \"time\")",
            "    @mock.patch.object(time, \"sleep\",",
            "                       side_effect=lambda x: eventlet.sleep(0))",
            "    @mock.patch.object(host.DomainJobInfo, \"for_domain\")",
            "    @mock.patch.object(objects.Instance, \"save\")",
            "    @mock.patch.object(objects.Migration, \"save\")",
            "    @mock.patch.object(fakelibvirt.Connection, \"_mark_running\")",
            "    @mock.patch.object(fakelibvirt.virDomain, \"abortJob\")",
            "    def _test_live_migration_monitoring(self,",
            "                                        job_info_records,",
            "                                        time_records,",
            "                                        expect_result,",
            "                                        mock_abort,",
            "                                        mock_running,",
            "                                        mock_save,",
            "                                        mock_mig_save,",
            "                                        mock_job_info,",
            "                                        mock_sleep,",
            "                                        mock_time,",
            "                                        expected_mig_status=None):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        dom = fakelibvirt.Domain(drvr._get_connection(), \"<domain/>\", True)",
            "        guest = libvirt_guest.Guest(dom)",
            "        finish_event = eventlet.event.Event()",
            "",
            "        def fake_job_info(hostself):",
            "            while True:",
            "                self.assertTrue(len(job_info_records) > 0)",
            "                rec = job_info_records.pop(0)",
            "",
            "                if type(rec) == str:",
            "                    if rec == \"thread-finish\":",
            "                        finish_event.send()",
            "                    elif rec == \"domain-stop\":",
            "                        dom.destroy()",
            "                else:",
            "                    if len(time_records) > 0:",
            "                        time_records.pop(0)",
            "                    return rec",
            "            return rec",
            "",
            "        def fake_time():",
            "            if len(time_records) > 0:",
            "                return time_records[0]",
            "            else:",
            "                return int(",
            "                    datetime.datetime(2001, 1, 20, 20, 1, 0)",
            "                    .strftime('%s'))",
            "",
            "        mock_job_info.side_effect = fake_job_info",
            "        mock_time.side_effect = fake_time",
            "",
            "        dest = mock.sentinel.migrate_dest",
            "        migration = objects.Migration(context=self.context, id=1)",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "            migration=migration)",
            "",
            "        fake_post_method = mock.MagicMock()",
            "        fake_recover_method = mock.MagicMock()",
            "        drvr._live_migration_monitor(self.context, instance,",
            "                                     guest, dest,",
            "                                     fake_post_method,",
            "                                     fake_recover_method,",
            "                                     False,",
            "                                     migrate_data,",
            "                                     dom,",
            "                                     finish_event,",
            "                                     [])",
            "",
            "        mock_mig_save.assert_called_with()",
            "",
            "        if expect_result == self.EXPECT_SUCCESS:",
            "            self.assertFalse(fake_recover_method.called,",
            "                             'Recover method called when success expected')",
            "            self.assertFalse(mock_abort.called,",
            "                             'abortJob not called when success expected')",
            "            fake_post_method.assert_called_once_with(",
            "                self.context, instance, dest, False, migrate_data)",
            "        else:",
            "            if expect_result == self.EXPECT_ABORT:",
            "                self.assertTrue(mock_abort.called,",
            "                                'abortJob called when abort expected')",
            "            else:",
            "                self.assertFalse(mock_abort.called,",
            "                                 'abortJob not called when failure expected')",
            "            self.assertFalse(fake_post_method.called,",
            "                             'Post method called when success not expected')",
            "            if expected_mig_status:",
            "                fake_recover_method.assert_called_once_with(",
            "                    self.context, instance, dest, False, migrate_data,",
            "                    migration_status=expected_mig_status)",
            "            else:",
            "                fake_recover_method.assert_called_once_with(",
            "                    self.context, instance, dest, False, migrate_data)",
            "",
            "    def test_live_migration_monitor_success(self):",
            "        # A normal sequence where see all the normal job states",
            "        domain_info_records = [",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_NONE),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            \"thread-finish\",",
            "            \"domain-stop\",",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_COMPLETED),",
            "        ]",
            "",
            "        self._test_live_migration_monitoring(domain_info_records, [],",
            "                                             self.EXPECT_SUCCESS)",
            "",
            "    def test_live_migration_monitor_success_race(self):",
            "        # A normalish sequence but we're too slow to see the",
            "        # completed job state",
            "        domain_info_records = [",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_NONE),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            \"thread-finish\",",
            "            \"domain-stop\",",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_NONE),",
            "        ]",
            "",
            "        self._test_live_migration_monitoring(domain_info_records, [],",
            "                                             self.EXPECT_SUCCESS)",
            "",
            "    def test_live_migration_monitor_failed(self):",
            "        # A failed sequence where we see all the expected events",
            "        domain_info_records = [",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_NONE),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            \"thread-finish\",",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_FAILED),",
            "        ]",
            "",
            "        self._test_live_migration_monitoring(domain_info_records, [],",
            "                                             self.EXPECT_FAILURE)",
            "",
            "    def test_live_migration_monitor_failed_race(self):",
            "        # A failed sequence where we are too slow to see the",
            "        # failed event",
            "        domain_info_records = [",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_NONE),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            \"thread-finish\",",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_NONE),",
            "        ]",
            "",
            "        self._test_live_migration_monitoring(domain_info_records, [],",
            "                                             self.EXPECT_FAILURE)",
            "",
            "    def test_live_migration_monitor_cancelled(self):",
            "        # A cancelled sequence where we see all the events",
            "        domain_info_records = [",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_NONE),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            \"thread-finish\",",
            "            \"domain-stop\",",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_CANCELLED),",
            "        ]",
            "",
            "        self._test_live_migration_monitoring(domain_info_records, [],",
            "                                             self.EXPECT_FAILURE,",
            "                                             expected_mig_status='cancelled')",
            "",
            "    @mock.patch.object(fakelibvirt.virDomain, \"migrateSetMaxDowntime\")",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver,",
            "                       \"_migration_downtime_steps\")",
            "    def test_live_migration_monitor_downtime(self, mock_downtime_steps,",
            "                                             mock_set_downtime):",
            "        self.flags(live_migration_completion_timeout=1000000,",
            "                   live_migration_progress_timeout=1000000,",
            "                   group='libvirt')",
            "        # We've setup 4 fake downtime steps - first value is the",
            "        # time delay, second is the downtime value",
            "        downtime_steps = [",
            "            (90, 10),",
            "            (180, 50),",
            "            (270, 200),",
            "            (500, 300),",
            "        ]",
            "        mock_downtime_steps.return_value = downtime_steps",
            "",
            "        # Each one of these fake times is used for time.time()",
            "        # when a new domain_info_records entry is consumed.",
            "        # Times are chosen so that only the first 3 downtime",
            "        # steps are needed.",
            "        fake_times = [0, 1, 30, 95, 150, 200, 300]",
            "",
            "        # A normal sequence where see all the normal job states",
            "        domain_info_records = [",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_NONE),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            \"thread-finish\",",
            "            \"domain-stop\",",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_COMPLETED),",
            "        ]",
            "",
            "        self._test_live_migration_monitoring(domain_info_records,",
            "                                             fake_times, self.EXPECT_SUCCESS)",
            "",
            "        mock_set_downtime.assert_has_calls([mock.call(10),",
            "                                            mock.call(50),",
            "                                            mock.call(200)])",
            "",
            "    def test_live_migration_monitor_completion(self):",
            "        self.flags(live_migration_completion_timeout=100,",
            "                   live_migration_progress_timeout=1000000,",
            "                   group='libvirt')",
            "        # Each one of these fake times is used for time.time()",
            "        # when a new domain_info_records entry is consumed.",
            "        fake_times = [0, 40, 80, 120, 160, 200, 240, 280, 320]",
            "",
            "        # A normal sequence where see all the normal job states",
            "        domain_info_records = [",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_NONE),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            \"thread-finish\",",
            "            \"domain-stop\",",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_CANCELLED),",
            "        ]",
            "",
            "        self._test_live_migration_monitoring(domain_info_records,",
            "                                             fake_times, self.EXPECT_ABORT,",
            "                                             expected_mig_status='cancelled')",
            "",
            "    def test_live_migration_monitor_progress(self):",
            "        self.flags(live_migration_completion_timeout=1000000,",
            "                   live_migration_progress_timeout=150,",
            "                   group='libvirt')",
            "        # Each one of these fake times is used for time.time()",
            "        # when a new domain_info_records entry is consumed.",
            "        fake_times = [0, 40, 80, 120, 160, 200, 240, 280, 320]",
            "",
            "        # A normal sequence where see all the normal job states",
            "        domain_info_records = [",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_NONE),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_UNBOUNDED),",
            "            \"thread-finish\",",
            "            \"domain-stop\",",
            "            host.DomainJobInfo(",
            "                type=fakelibvirt.VIR_DOMAIN_JOB_CANCELLED),",
            "        ]",
            "",
            "        self._test_live_migration_monitoring(domain_info_records,",
            "                                             fake_times, self.EXPECT_ABORT,",
            "                                             expected_mig_status='cancelled')",
            "",
            "    def test_live_migration_downtime_steps(self):",
            "        self.flags(live_migration_downtime=400, group='libvirt')",
            "        self.flags(live_migration_downtime_steps=10, group='libvirt')",
            "        self.flags(live_migration_downtime_delay=30, group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        steps = drvr._migration_downtime_steps(3.0)",
            "",
            "        self.assertEqual([",
            "            (0, 37),",
            "            (90, 38),",
            "            (180, 39),",
            "            (270, 42),",
            "            (360, 46),",
            "            (450, 55),",
            "            (540, 70),",
            "            (630, 98),",
            "            (720, 148),",
            "            (810, 238),",
            "            (900, 400),",
            "        ], list(steps))",
            "",
            "    @mock.patch.object(utils, \"spawn\")",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, \"_live_migration_monitor\")",
            "    @mock.patch.object(host.Host, \"get_guest\")",
            "    @mock.patch.object(fakelibvirt.Connection, \"_mark_running\")",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver,",
            "                       \"_live_migration_copy_disk_paths\")",
            "    def test_live_migration_main(self, mock_copy_disk_path, mock_running,",
            "                                 mock_guest, mock_monitor, mock_thread):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        dom = fakelibvirt.Domain(drvr._get_connection(),",
            "                                 \"<domain><name>demo</name></domain>\", True)",
            "        guest = libvirt_guest.Guest(dom)",
            "        migrate_data = {}",
            "        disks_to_copy = (['/some/path/one', '/test/path/two'],",
            "                         ['vda', 'vdb'])",
            "        mock_copy_disk_path.return_value = disks_to_copy",
            "",
            "        mock_guest.return_value = guest",
            "",
            "        def fake_post():",
            "            pass",
            "",
            "        def fake_recover():",
            "            pass",
            "",
            "        drvr._live_migration(self.context, instance, \"fakehost\",",
            "                             fake_post, fake_recover, True,",
            "                             migrate_data)",
            "        mock_copy_disk_path.assert_called_once_with(self.context, instance,",
            "                                                    guest)",
            "",
            "        class AnyEventletEvent(object):",
            "            def __eq__(self, other):",
            "                return type(other) == eventlet.event.Event",
            "",
            "        mock_thread.assert_called_once_with(",
            "            drvr._live_migration_operation,",
            "            self.context, instance, \"fakehost\", True,",
            "            migrate_data, dom, disks_to_copy[1])",
            "        mock_monitor.assert_called_once_with(",
            "            self.context, instance, guest, \"fakehost\",",
            "            fake_post, fake_recover, True,",
            "            migrate_data, dom, AnyEventletEvent(), disks_to_copy[0])",
            "",
            "    def _do_test_create_images_and_backing(self, disk_type):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.mox.StubOutWithMock(drvr, '_fetch_instance_kernel_ramdisk')",
            "        self.mox.StubOutWithMock(libvirt_driver.libvirt_utils, 'create_image')",
            "",
            "        disk_info = {'path': 'foo', 'type': disk_type,",
            "                     'disk_size': 1 * 1024 ** 3,",
            "                     'virt_disk_size': 20 * 1024 ** 3,",
            "                     'backing_file': None}",
            "",
            "        libvirt_driver.libvirt_utils.create_image(",
            "            disk_info['type'], mox.IgnoreArg(), disk_info['virt_disk_size'])",
            "        drvr._fetch_instance_kernel_ramdisk(self.context, self.test_instance,",
            "                                            fallback_from_host=None)",
            "        self.mox.ReplayAll()",
            "",
            "        self.stub_out('os.path.exists', lambda *args: False)",
            "        drvr._create_images_and_backing(self.context, self.test_instance,",
            "                                        \"/fake/instance/dir\", [disk_info])",
            "",
            "    def test_create_images_and_backing_qcow2(self):",
            "        self._do_test_create_images_and_backing('qcow2')",
            "",
            "    def test_create_images_and_backing_raw(self):",
            "        self._do_test_create_images_and_backing('raw')",
            "",
            "    def test_create_images_and_backing_images_not_exist_no_fallback(self):",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        disk_info = [",
            "            {u'backing_file': u'fake_image_backing_file',",
            "             u'disk_size': 10747904,",
            "             u'path': u'disk_path',",
            "             u'type': u'qcow2',",
            "             u'virt_disk_size': 25165824}]",
            "",
            "        self.test_instance.update({'user_id': 'fake-user',",
            "                                   'os_type': None,",
            "                                   'project_id': 'fake-project'})",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        with mock.patch.object(libvirt_driver.libvirt_utils, 'fetch_image',",
            "                               side_effect=exception.ImageNotFound(",
            "                                   image_id=\"fake_id\")):",
            "            self.assertRaises(exception.ImageNotFound,",
            "                              conn._create_images_and_backing,",
            "                              self.context, instance,",
            "                              \"/fake/instance/dir\", disk_info)",
            "",
            "    def test_create_images_and_backing_images_not_exist_fallback(self):",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        disk_info = [",
            "            {u'backing_file': u'fake_image_backing_file',",
            "             u'disk_size': 10747904,",
            "             u'path': u'disk_path',",
            "             u'type': u'qcow2',",
            "             u'virt_disk_size': 25165824}]",
            "",
            "        base_dir = os.path.join(CONF.instances_path,",
            "                                CONF.image_cache_subdirectory_name)",
            "        self.test_instance.update({'user_id': 'fake-user',",
            "                                   'os_type': None,",
            "                                   'kernel_id': 'fake_kernel_id',",
            "                                   'ramdisk_id': 'fake_ramdisk_id',",
            "                                   'project_id': 'fake-project'})",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        with test.nested(",
            "            mock.patch.object(libvirt_driver.libvirt_utils, 'copy_image'),",
            "            mock.patch.object(libvirt_driver.libvirt_utils, 'fetch_image',",
            "                              side_effect=exception.ImageNotFound(",
            "                                  image_id=\"fake_id\")),",
            "        ) as (copy_image_mock, fetch_image_mock):",
            "            conn._create_images_and_backing(self.context, instance,",
            "                                            \"/fake/instance/dir\", disk_info,",
            "                                            fallback_from_host=\"fake_host\")",
            "            backfile_path = os.path.join(base_dir, 'fake_image_backing_file')",
            "            kernel_path = os.path.join(CONF.instances_path,",
            "                                       self.test_instance['uuid'],",
            "                                       'kernel')",
            "            ramdisk_path = os.path.join(CONF.instances_path,",
            "                                        self.test_instance['uuid'],",
            "                                        'ramdisk')",
            "            copy_image_mock.assert_has_calls([",
            "                mock.call(dest=backfile_path, src=backfile_path,",
            "                          host='fake_host', receive=True),",
            "                mock.call(dest=kernel_path, src=kernel_path,",
            "                          host='fake_host', receive=True),",
            "                mock.call(dest=ramdisk_path, src=ramdisk_path,",
            "                          host='fake_host', receive=True)",
            "            ])",
            "            fetch_image_mock.assert_has_calls([",
            "                mock.call(context=self.context,",
            "                          target=backfile_path,",
            "                          image_id=self.test_instance['image_ref'],",
            "                          user_id=self.test_instance['user_id'],",
            "                          project_id=self.test_instance['project_id'],",
            "                          max_size=25165824),",
            "                mock.call(self.context, kernel_path,",
            "                          self.test_instance['kernel_id'],",
            "                          self.test_instance['user_id'],",
            "                          self.test_instance['project_id']),",
            "                mock.call(self.context, ramdisk_path,",
            "                          self.test_instance['ramdisk_id'],",
            "                          self.test_instance['user_id'],",
            "                          self.test_instance['project_id']),",
            "            ])",
            "",
            "    @mock.patch.object(libvirt_driver.libvirt_utils, 'fetch_image')",
            "    @mock.patch.object(os.path, 'exists', return_value=True)",
            "    def test_create_images_and_backing_images_exist(self, mock_exists,",
            "                                                    mock_fetch_image):",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        disk_info = [",
            "            {u'backing_file': u'fake_image_backing_file',",
            "             u'disk_size': 10747904,",
            "             u'path': u'disk_path',",
            "             u'type': u'qcow2',",
            "             u'virt_disk_size': 25165824}]",
            "",
            "        self.test_instance.update({'user_id': 'fake-user',",
            "                                   'os_type': None,",
            "                                   'kernel_id': 'fake_kernel_id',",
            "                                   'ramdisk_id': 'fake_ramdisk_id',",
            "                                   'project_id': 'fake-project'})",
            "        instance = objects.Instance(**self.test_instance)",
            "        with mock.patch.object(imagebackend.Image, 'get_disk_size'):",
            "            conn._create_images_and_backing(self.context, instance,",
            "                                            '/fake/instance/dir', disk_info)",
            "        self.assertFalse(mock_fetch_image.called)",
            "",
            "    def test_create_images_and_backing_ephemeral_gets_created(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        disk_info = [",
            "            {u'backing_file': u'fake_image_backing_file',",
            "             u'disk_size': 10747904,",
            "             u'path': u'disk_path',",
            "             u'type': u'qcow2',",
            "             u'virt_disk_size': 25165824},",
            "            {u'backing_file': u'ephemeral_1_default',",
            "             u'disk_size': 393216,",
            "             u'over_committed_disk_size': 1073348608,",
            "             u'path': u'disk_eph_path',",
            "             u'type': u'qcow2',",
            "             u'virt_disk_size': 1073741824}]",
            "",
            "        base_dir = os.path.join(CONF.instances_path,",
            "                                CONF.image_cache_subdirectory_name)",
            "        instance = objects.Instance(**self.test_instance)",
            "        with test.nested(",
            "            mock.patch.object(drvr, '_fetch_instance_kernel_ramdisk'),",
            "            mock.patch.object(libvirt_driver.libvirt_utils, 'fetch_image'),",
            "            mock.patch.object(drvr, '_create_ephemeral'),",
            "            mock.patch.object(imagebackend.Image, 'verify_base_size'),",
            "            mock.patch.object(imagebackend.Image, 'get_disk_size')",
            "        ) as (fetch_kernel_ramdisk_mock, fetch_image_mock,",
            "                create_ephemeral_mock, verify_base_size_mock, disk_size_mock):",
            "            drvr._create_images_and_backing(self.context, instance,",
            "                                            \"/fake/instance/dir\",",
            "                                            disk_info)",
            "            self.assertEqual(len(create_ephemeral_mock.call_args_list), 1)",
            "            m_args, m_kwargs = create_ephemeral_mock.call_args_list[0]",
            "            self.assertEqual(",
            "                    os.path.join(base_dir, 'ephemeral_1_default'),",
            "                    m_kwargs['target'])",
            "            self.assertEqual(len(fetch_image_mock.call_args_list), 1)",
            "            m_args, m_kwargs = fetch_image_mock.call_args_list[0]",
            "            self.assertEqual(",
            "                    os.path.join(base_dir, 'fake_image_backing_file'),",
            "                    m_kwargs['target'])",
            "            verify_base_size_mock.assert_has_calls([",
            "                mock.call(os.path.join(base_dir, 'fake_image_backing_file'),",
            "                          25165824),",
            "                mock.call(os.path.join(base_dir, 'ephemeral_1_default'),",
            "                          1073741824)",
            "            ])",
            "",
            "    def test_create_images_and_backing_disk_info_none(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.mox.StubOutWithMock(drvr, '_fetch_instance_kernel_ramdisk')",
            "",
            "        drvr._fetch_instance_kernel_ramdisk(self.context, self.test_instance,",
            "                                            fallback_from_host=None)",
            "        self.mox.ReplayAll()",
            "",
            "        drvr._create_images_and_backing(self.context, self.test_instance,",
            "                                        \"/fake/instance/dir\", None)",
            "",
            "    def _generate_target_ret(self, target_connect_addr=None):",
            "        target_ret = {",
            "        'graphics_listen_addrs': {'spice': '127.0.0.1', 'vnc': '127.0.0.1'},",
            "        'target_connect_addr': target_connect_addr,",
            "        'serial_listen_addr': '127.0.0.1',",
            "        'volume': {",
            "         '12345': {'connection_info': {u'data': {'device_path':",
            "              u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.abc.12345.opst-lun-X'},",
            "                   'serial': '12345'},",
            "                   'disk_info': {'bus': 'scsi',",
            "                                 'dev': 'sda',",
            "                                 'type': 'disk'}},",
            "         '67890': {'connection_info': {u'data': {'device_path':",
            "              u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z'},",
            "                   'serial': '67890'},",
            "                   'disk_info': {'bus': 'scsi',",
            "                                 'dev': 'sdb',",
            "                                 'type': 'disk'}}}}",
            "        return target_ret",
            "",
            "    def test_pre_live_migration_works_correctly_mocked(self):",
            "        self._test_pre_live_migration_works_correctly_mocked()",
            "",
            "    def test_pre_live_migration_with_transport_ip(self):",
            "        self.flags(live_migration_inbound_addr='127.0.0.2',",
            "                   group='libvirt')",
            "        target_ret = self._generate_target_ret('127.0.0.2')",
            "        self._test_pre_live_migration_works_correctly_mocked(target_ret)",
            "",
            "    def _test_pre_live_migration_works_correctly_mocked(self,",
            "                                                        target_ret=None):",
            "        # Creating testdata",
            "        vol = {'block_device_mapping': [",
            "           {'connection_info': {'serial': '12345', u'data':",
            "            {'device_path':",
            "             u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.abc.12345.opst-lun-X'}},",
            "             'mount_device': '/dev/sda'},",
            "           {'connection_info': {'serial': '67890', u'data':",
            "            {'device_path':",
            "             u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z'}},",
            "             'mount_device': '/dev/sdb'}]}",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        class FakeNetworkInfo(object):",
            "            def fixed_ips(self):",
            "                return [\"test_ip_addr\"]",
            "",
            "        def fake_none(*args, **kwargs):",
            "            return",
            "",
            "        self.stubs.Set(drvr, '_create_images_and_backing', fake_none)",
            "",
            "        instance = objects.Instance(**self.test_instance)",
            "        c = context.get_admin_context()",
            "        nw_info = FakeNetworkInfo()",
            "",
            "        # Creating mocks",
            "        self.mox.StubOutWithMock(driver, \"block_device_info_get_mapping\")",
            "        driver.block_device_info_get_mapping(vol",
            "            ).AndReturn(vol['block_device_mapping'])",
            "        self.mox.StubOutWithMock(drvr, \"_connect_volume\")",
            "        for v in vol['block_device_mapping']:",
            "            disk_info = {",
            "                'bus': \"scsi\",",
            "                'dev': v['mount_device'].rpartition(\"/\")[2],",
            "                'type': \"disk\"",
            "                }",
            "            drvr._connect_volume(v['connection_info'],",
            "                                 disk_info)",
            "        self.mox.StubOutWithMock(drvr, 'plug_vifs')",
            "        drvr.plug_vifs(mox.IsA(instance), nw_info)",
            "",
            "        self.mox.ReplayAll()",
            "        migrate_data = {",
            "            \"block_migration\": False,",
            "            \"instance_relative_path\": \"foo\",",
            "            \"is_shared_block_storage\": False,",
            "            \"is_shared_instance_path\": False,",
            "        }",
            "        result = drvr.pre_live_migration(",
            "            c, instance, vol, nw_info, None,",
            "            migrate_data=migrate_data)",
            "        if not target_ret:",
            "            target_ret = self._generate_target_ret()",
            "        self.assertEqual(",
            "            result.to_legacy_dict(",
            "                pre_migration_result=True)['pre_live_migration_result'],",
            "            target_ret)",
            "",
            "    def test_pre_live_migration_block_with_config_drive_mocked(self):",
            "        # Creating testdata",
            "        vol = {'block_device_mapping': [",
            "                  {'connection_info': 'dummy', 'mount_device': '/dev/sda'},",
            "                  {'connection_info': 'dummy', 'mount_device': '/dev/sdb'}]}",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        def fake_true(*args, **kwargs):",
            "            return True",
            "",
            "        self.stubs.Set(configdrive, 'required_by', fake_true)",
            "",
            "        instance = objects.Instance(**self.test_instance)",
            "        c = context.get_admin_context()",
            "",
            "        self.assertRaises(exception.NoLiveMigrationForConfigDriveInLibVirt,",
            "                          drvr.pre_live_migration, c, instance, vol, None,",
            "                          None, {'is_shared_instance_path': False,",
            "                                 'is_shared_block_storage': False,",
            "                                 'block_migration': False,",
            "                                 'instance_relative_path': 'foo'})",
            "",
            "    @mock.patch('nova.virt.driver.block_device_info_get_mapping',",
            "                return_value=())",
            "    @mock.patch('nova.virt.configdrive.required_by',",
            "                return_value=True)",
            "    def test_pre_live_migration_block_with_config_drive_mocked_with_vfat(",
            "            self, mock_required_by, block_device_info_get_mapping):",
            "        self.flags(config_drive_format='vfat')",
            "        # Creating testdata",
            "        vol = {'block_device_mapping': [",
            "            {'connection_info': 'dummy', 'mount_device': '/dev/sda'},",
            "            {'connection_info': 'dummy', 'mount_device': '/dev/sdb'}]}",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        res_data = drvr.pre_live_migration(",
            "            self.context, instance, vol, [], None,",
            "            {'is_shared_instance_path': False,",
            "             'is_shared_block_storage': False,",
            "             'block_migration': False,",
            "             'instance_relative_path': 'foo'})",
            "        res_data = res_data.to_legacy_dict(pre_migration_result=True)",
            "        block_device_info_get_mapping.assert_called_once_with(",
            "            {'block_device_mapping': [",
            "                {'connection_info': 'dummy', 'mount_device': '/dev/sda'},",
            "                {'connection_info': 'dummy', 'mount_device': '/dev/sdb'}",
            "            ]}",
            "        )",
            "        self.assertEqual({'graphics_listen_addrs': {'spice': '127.0.0.1',",
            "                                                    'vnc': '127.0.0.1'},",
            "                          'target_connect_addr': None,",
            "                          'serial_listen_addr': '127.0.0.1',",
            "                          'volume': {}}, res_data['pre_live_migration_result'])",
            "",
            "    def test_pre_live_migration_vol_backed_works_correctly_mocked(self):",
            "        # Creating testdata, using temp dir.",
            "        with utils.tempdir() as tmpdir:",
            "            self.flags(instances_path=tmpdir)",
            "            vol = {'block_device_mapping': [",
            "             {'connection_info': {'serial': '12345', u'data':",
            "             {'device_path':",
            "              u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.abc.12345.opst-lun-X'}},",
            "             'mount_device': '/dev/sda'},",
            "             {'connection_info': {'serial': '67890', u'data':",
            "             {'device_path':",
            "             u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z'}},",
            "             'mount_device': '/dev/sdb'}]}",
            "",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "            def fake_none(*args, **kwargs):",
            "                return",
            "",
            "            self.stubs.Set(drvr, '_create_images_and_backing', fake_none)",
            "",
            "            class FakeNetworkInfo(object):",
            "                def fixed_ips(self):",
            "                    return [\"test_ip_addr\"]",
            "            inst_ref = objects.Instance(**self.test_instance)",
            "            c = context.get_admin_context()",
            "            nw_info = FakeNetworkInfo()",
            "            # Creating mocks",
            "            self.mox.StubOutWithMock(drvr, \"_connect_volume\")",
            "            for v in vol['block_device_mapping']:",
            "                disk_info = {",
            "                    'bus': \"scsi\",",
            "                    'dev': v['mount_device'].rpartition(\"/\")[2],",
            "                    'type': \"disk\"",
            "                    }",
            "                drvr._connect_volume(v['connection_info'],",
            "                                     disk_info)",
            "            self.mox.StubOutWithMock(drvr, 'plug_vifs')",
            "            drvr.plug_vifs(mox.IsA(inst_ref), nw_info)",
            "            self.mox.ReplayAll()",
            "            migrate_data = {'is_shared_instance_path': False,",
            "                            'is_shared_block_storage': False,",
            "                            'is_volume_backed': True,",
            "                            'block_migration': False,",
            "                            'instance_relative_path': inst_ref['name'],",
            "                            'disk_over_commit': False,",
            "                            'disk_available_mb': 123,",
            "                            'image_type': 'qcow2',",
            "                            'filename': 'foo',",
            "                        }",
            "            ret = drvr.pre_live_migration(c, inst_ref, vol, nw_info, None,",
            "                                          migrate_data)",
            "            target_ret = {",
            "            'graphics_listen_addrs': {'spice': '127.0.0.1',",
            "                                      'vnc': '127.0.0.1'},",
            "            'target_connect_addr': None,",
            "            'serial_listen_addr': '127.0.0.1',",
            "            'volume': {",
            "            '12345': {'connection_info': {u'data': {'device_path':",
            "              u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.abc.12345.opst-lun-X'},",
            "                      'serial': '12345'},",
            "                      'disk_info': {'bus': 'scsi',",
            "                                    'dev': 'sda',",
            "                                    'type': 'disk'}},",
            "            '67890': {'connection_info': {u'data': {'device_path':",
            "              u'/dev/disk/by-path/ip-1.2.3.4:3260-iqn.cde.67890.opst-lun-Z'},",
            "                      'serial': '67890'},",
            "                      'disk_info': {'bus': 'scsi',",
            "                                    'dev': 'sdb',",
            "                                    'type': 'disk'}}}}",
            "            self.assertEqual(",
            "                ret.to_legacy_dict(True)['pre_live_migration_result'],",
            "                target_ret)",
            "            self.assertTrue(os.path.exists('%s/%s/' % (tmpdir,",
            "                                                       inst_ref['name'])))",
            "",
            "    def test_pre_live_migration_plug_vifs_retry_fails(self):",
            "        self.flags(live_migration_retry_count=3)",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        def fake_plug_vifs(instance, network_info):",
            "            raise processutils.ProcessExecutionError()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr, 'plug_vifs', fake_plug_vifs)",
            "        self.stubs.Set(eventlet.greenthread, 'sleep',",
            "                       lambda x: eventlet.sleep(0))",
            "        disk_info_json = jsonutils.dumps({})",
            "        self.assertRaises(processutils.ProcessExecutionError,",
            "                          drvr.pre_live_migration,",
            "                          self.context, instance, block_device_info=None,",
            "                          network_info=[], disk_info=disk_info_json)",
            "",
            "    def test_pre_live_migration_plug_vifs_retry_works(self):",
            "        self.flags(live_migration_retry_count=3)",
            "        called = {'count': 0}",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        def fake_plug_vifs(instance, network_info):",
            "            called['count'] += 1",
            "            if called['count'] < CONF.live_migration_retry_count:",
            "                raise processutils.ProcessExecutionError()",
            "            else:",
            "                return",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr, 'plug_vifs', fake_plug_vifs)",
            "        self.stubs.Set(eventlet.greenthread, 'sleep',",
            "                       lambda x: eventlet.sleep(0))",
            "        disk_info_json = jsonutils.dumps({})",
            "        drvr.pre_live_migration(self.context, instance, block_device_info=None,",
            "                                network_info=[], disk_info=disk_info_json)",
            "",
            "    def test_pre_live_migration_image_not_created_with_shared_storage(self):",
            "        migrate_data_set = [{'is_shared_block_storage': False,",
            "                             'is_shared_instance_path': True,",
            "                             'is_volume_backed': False,",
            "                             'filename': 'foo',",
            "                             'instance_relative_path': 'bar',",
            "                             'disk_over_commit': False,",
            "                             'disk_available_mb': 123,",
            "                             'image_type': 'qcow2',",
            "                             'block_migration': False},",
            "                            {'is_shared_block_storage': True,",
            "                             'is_shared_instance_path': True,",
            "                             'is_volume_backed': False,",
            "                             'filename': 'foo',",
            "                             'instance_relative_path': 'bar',",
            "                             'disk_over_commit': False,",
            "                             'disk_available_mb': 123,",
            "                             'image_type': 'qcow2',",
            "                             'block_migration': False},",
            "                            {'is_shared_block_storage': False,",
            "                             'is_shared_instance_path': True,",
            "                             'is_volume_backed': False,",
            "                             'filename': 'foo',",
            "                             'instance_relative_path': 'bar',",
            "                             'disk_over_commit': False,",
            "                             'disk_available_mb': 123,",
            "                             'image_type': 'qcow2',",
            "                             'block_migration': True}]",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        # creating mocks",
            "        with test.nested(",
            "            mock.patch.object(drvr,",
            "                              '_create_images_and_backing'),",
            "            mock.patch.object(drvr,",
            "                              'ensure_filtering_rules_for_instance'),",
            "            mock.patch.object(drvr, 'plug_vifs'),",
            "        ) as (",
            "            create_image_mock,",
            "            rules_mock,",
            "            plug_mock,",
            "        ):",
            "            disk_info_json = jsonutils.dumps({})",
            "            for migrate_data in migrate_data_set:",
            "                res = drvr.pre_live_migration(self.context, instance,",
            "                                              block_device_info=None,",
            "                                              network_info=[],",
            "                                              disk_info=disk_info_json,",
            "                                              migrate_data=migrate_data)",
            "                self.assertFalse(create_image_mock.called)",
            "                self.assertIsInstance(res,",
            "                                      objects.LibvirtLiveMigrateData)",
            "",
            "    def test_pre_live_migration_with_not_shared_instance_path(self):",
            "        migrate_data = {'is_shared_block_storage': False,",
            "                        'is_shared_instance_path': False,",
            "                        'block_migration': False,",
            "                        'instance_relative_path': 'foo'}",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        def check_instance_dir(context, instance,",
            "                               instance_dir, disk_info,",
            "                               fallback_from_host=False):",
            "            self.assertTrue(instance_dir)",
            "        # creating mocks",
            "        with test.nested(",
            "            mock.patch.object(drvr,",
            "                              '_create_images_and_backing',",
            "                              side_effect=check_instance_dir),",
            "            mock.patch.object(drvr,",
            "                              'ensure_filtering_rules_for_instance'),",
            "            mock.patch.object(drvr, 'plug_vifs'),",
            "        ) as (",
            "            create_image_mock,",
            "            rules_mock,",
            "            plug_mock,",
            "        ):",
            "            disk_info_json = jsonutils.dumps({})",
            "            res = drvr.pre_live_migration(self.context, instance,",
            "                                          block_device_info=None,",
            "                                          network_info=[],",
            "                                          disk_info=disk_info_json,",
            "                                          migrate_data=migrate_data)",
            "            create_image_mock.assert_has_calls(",
            "                [mock.call(self.context, instance, mock.ANY, {},",
            "                           fallback_from_host=instance.host)])",
            "            self.assertIsInstance(res, objects.LibvirtLiveMigrateData)",
            "",
            "    def test_pre_live_migration_recreate_disk_info(self):",
            "",
            "        migrate_data = {'is_shared_block_storage': False,",
            "                        'is_shared_instance_path': False,",
            "                        'block_migration': True,",
            "                        'instance_relative_path': '/some/path/'}",
            "        disk_info = [{'disk_size': 5368709120, 'type': 'raw',",
            "                      'virt_disk_size': 5368709120,",
            "                      'path': '/some/path/disk',",
            "                      'backing_file': '', 'over_committed_disk_size': 0},",
            "                     {'disk_size': 1073741824, 'type': 'raw',",
            "                      'virt_disk_size': 1073741824,",
            "                      'path': '/some/path/disk.eph0',",
            "                      'backing_file': '', 'over_committed_disk_size': 0}]",
            "        image_disk_info = {'/some/path/disk': 'raw',",
            "                           '/some/path/disk.eph0': 'raw'}",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        instance_path = os.path.dirname(disk_info[0]['path'])",
            "        disk_info_path = os.path.join(instance_path, 'disk.info')",
            "",
            "        with test.nested(",
            "            mock.patch.object(os, 'mkdir'),",
            "            mock.patch.object(fake_libvirt_utils, 'write_to_file'),",
            "            mock.patch.object(drvr, '_create_images_and_backing')",
            "        ) as (",
            "            mkdir, write_to_file, create_images_and_backing",
            "        ):",
            "            drvr.pre_live_migration(self.context, instance,",
            "                                    block_device_info=None,",
            "                                    network_info=[],",
            "                                    disk_info=jsonutils.dumps(disk_info),",
            "                                    migrate_data=migrate_data)",
            "            write_to_file.assert_called_with(disk_info_path,",
            "                                             jsonutils.dumps(image_disk_info))",
            "",
            "    def test_get_instance_disk_info_works_correctly(self):",
            "        # Test data",
            "        instance = objects.Instance(**self.test_instance)",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices>\"",
            "                    \"<disk type='file'><driver name='qemu' type='raw'/>\"",
            "                    \"<source file='/test/disk'/>\"",
            "                    \"<target dev='vda' bus='virtio'/></disk>\"",
            "                    \"<disk type='file'><driver name='qemu' type='qcow2'/>\"",
            "                    \"<source file='/test/disk.local'/>\"",
            "                    \"<target dev='vdb' bus='virtio'/></disk>\"",
            "                    \"</devices></domain>\")",
            "",
            "        # Preparing mocks",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"XMLDesc\")",
            "        vdmock.XMLDesc(flags=0).AndReturn(dummyxml)",
            "",
            "        def fake_lookup(instance_name):",
            "            if instance_name == instance.name:",
            "                return vdmock",
            "        self.create_fake_libvirt_mock(lookupByName=fake_lookup)",
            "",
            "        fake_libvirt_utils.disk_sizes['/test/disk'] = 10 * units.Gi",
            "        fake_libvirt_utils.disk_sizes['/test/disk.local'] = 20 * units.Gi",
            "        fake_libvirt_utils.disk_backing_files['/test/disk.local'] = 'file'",
            "",
            "        self.mox.StubOutWithMock(os.path, \"getsize\")",
            "        os.path.getsize('/test/disk').AndReturn((10737418240))",
            "        os.path.getsize('/test/disk.local').AndReturn((3328599655))",
            "",
            "        ret = (\"image: /test/disk\\n\"",
            "               \"file format: raw\\n\"",
            "               \"virtual size: 20G (21474836480 bytes)\\n\"",
            "               \"disk size: 3.1G\\n\"",
            "               \"cluster_size: 2097152\\n\"",
            "               \"backing file: /test/dummy (actual path: /backing/file)\\n\")",
            "",
            "        self.mox.StubOutWithMock(os.path, \"exists\")",
            "        os.path.exists('/test/disk.local').AndReturn(True)",
            "",
            "        self.mox.StubOutWithMock(utils, \"execute\")",
            "        utils.execute('env', 'LC_ALL=C', 'LANG=C', 'qemu-img', 'info',",
            "                      '/test/disk.local').AndReturn((ret, ''))",
            "",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        info = drvr.get_instance_disk_info(instance)",
            "        info = jsonutils.loads(info)",
            "        self.assertEqual(info[0]['type'], 'raw')",
            "        self.assertEqual(info[0]['path'], '/test/disk')",
            "        self.assertEqual(info[0]['disk_size'], 10737418240)",
            "        self.assertEqual(info[0]['backing_file'], \"\")",
            "        self.assertEqual(info[0]['over_committed_disk_size'], 0)",
            "        self.assertEqual(info[1]['type'], 'qcow2')",
            "        self.assertEqual(info[1]['path'], '/test/disk.local')",
            "        self.assertEqual(info[1]['virt_disk_size'], 21474836480)",
            "        self.assertEqual(info[1]['backing_file'], \"file\")",
            "        self.assertEqual(info[1]['over_committed_disk_size'], 18146236825)",
            "",
            "    def test_post_live_migration(self):",
            "        vol = {'block_device_mapping': [",
            "                  {'connection_info': {",
            "                       'data': {'multipath_id': 'dummy1'},",
            "                       'serial': 'fake_serial1'},",
            "                    'mount_device': '/dev/sda',",
            "                   },",
            "                  {'connection_info': {",
            "                       'data': {},",
            "                       'serial': 'fake_serial2'},",
            "                    'mount_device': '/dev/sdb', }]}",
            "",
            "        def fake_initialize_connection(context, volume_id, connector):",
            "            return {'data': {}}",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        fake_connector = {'host': 'fake'}",
            "        inst_ref = {'id': 'foo'}",
            "        cntx = context.get_admin_context()",
            "",
            "        # Set up the mock expectations",
            "        with test.nested(",
            "            mock.patch.object(driver, 'block_device_info_get_mapping',",
            "                              return_value=vol['block_device_mapping']),",
            "            mock.patch.object(drvr, \"get_volume_connector\",",
            "                              return_value=fake_connector),",
            "            mock.patch.object(drvr._volume_api, \"initialize_connection\",",
            "                              side_effect=fake_initialize_connection),",
            "            mock.patch.object(drvr, '_disconnect_volume')",
            "        ) as (block_device_info_get_mapping, get_volume_connector,",
            "              initialize_connection, _disconnect_volume):",
            "            drvr.post_live_migration(cntx, inst_ref, vol)",
            "",
            "            block_device_info_get_mapping.assert_has_calls([",
            "                mock.call(vol)])",
            "            get_volume_connector.assert_has_calls([",
            "                mock.call(inst_ref)])",
            "            _disconnect_volume.assert_has_calls([",
            "                mock.call({'data': {'multipath_id': 'dummy1'}}, 'sda'),",
            "                mock.call({'data': {}}, 'sdb')])",
            "",
            "    def test_get_instance_disk_info_excludes_volumes(self):",
            "        # Test data",
            "        instance = objects.Instance(**self.test_instance)",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices>\"",
            "                    \"<disk type='file'><driver name='qemu' type='raw'/>\"",
            "                    \"<source file='/test/disk'/>\"",
            "                    \"<target dev='vda' bus='virtio'/></disk>\"",
            "                    \"<disk type='file'><driver name='qemu' type='qcow2'/>\"",
            "                    \"<source file='/test/disk.local'/>\"",
            "                    \"<target dev='vdb' bus='virtio'/></disk>\"",
            "                    \"<disk type='file'><driver name='qemu' type='qcow2'/>\"",
            "                    \"<source file='/fake/path/to/volume1'/>\"",
            "                    \"<target dev='vdc' bus='virtio'/></disk>\"",
            "                    \"<disk type='file'><driver name='qemu' type='qcow2'/>\"",
            "                    \"<source file='/fake/path/to/volume2'/>\"",
            "                    \"<target dev='vdd' bus='virtio'/></disk>\"",
            "                    \"</devices></domain>\")",
            "",
            "        # Preparing mocks",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"XMLDesc\")",
            "        vdmock.XMLDesc(flags=0).AndReturn(dummyxml)",
            "",
            "        def fake_lookup(instance_name):",
            "            if instance_name == instance.name:",
            "                return vdmock",
            "        self.create_fake_libvirt_mock(lookupByName=fake_lookup)",
            "",
            "        fake_libvirt_utils.disk_sizes['/test/disk'] = 10 * units.Gi",
            "        fake_libvirt_utils.disk_sizes['/test/disk.local'] = 20 * units.Gi",
            "        fake_libvirt_utils.disk_backing_files['/test/disk.local'] = 'file'",
            "",
            "        self.mox.StubOutWithMock(os.path, \"getsize\")",
            "        os.path.getsize('/test/disk').AndReturn((10737418240))",
            "        os.path.getsize('/test/disk.local').AndReturn((3328599655))",
            "",
            "        ret = (\"image: /test/disk\\n\"",
            "               \"file format: raw\\n\"",
            "               \"virtual size: 20G (21474836480 bytes)\\n\"",
            "               \"disk size: 3.1G\\n\"",
            "               \"cluster_size: 2097152\\n\"",
            "               \"backing file: /test/dummy (actual path: /backing/file)\\n\")",
            "",
            "        self.mox.StubOutWithMock(os.path, \"exists\")",
            "        os.path.exists('/test/disk.local').AndReturn(True)",
            "",
            "        self.mox.StubOutWithMock(utils, \"execute\")",
            "        utils.execute('env', 'LC_ALL=C', 'LANG=C', 'qemu-img', 'info',",
            "                      '/test/disk.local').AndReturn((ret, ''))",
            "",
            "        self.mox.ReplayAll()",
            "        conn_info = {'driver_volume_type': 'fake'}",
            "        info = {'block_device_mapping': [",
            "                  {'connection_info': conn_info, 'mount_device': '/dev/vdc'},",
            "                  {'connection_info': conn_info, 'mount_device': '/dev/vdd'}]}",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        info = drvr.get_instance_disk_info(instance,",
            "                                           block_device_info=info)",
            "        info = jsonutils.loads(info)",
            "        self.assertEqual(info[0]['type'], 'raw')",
            "        self.assertEqual(info[0]['path'], '/test/disk')",
            "        self.assertEqual(info[0]['disk_size'], 10737418240)",
            "        self.assertEqual(info[0]['backing_file'], \"\")",
            "        self.assertEqual(info[0]['over_committed_disk_size'], 0)",
            "        self.assertEqual(info[1]['type'], 'qcow2')",
            "        self.assertEqual(info[1]['path'], '/test/disk.local')",
            "        self.assertEqual(info[1]['virt_disk_size'], 21474836480)",
            "        self.assertEqual(info[1]['backing_file'], \"file\")",
            "        self.assertEqual(info[1]['over_committed_disk_size'], 18146236825)",
            "",
            "    def test_get_instance_disk_info_no_bdinfo_passed(self):",
            "        # NOTE(ndipanov): _get_disk_overcomitted_size_total calls this method",
            "        # without access to Nova's block device information. We want to make",
            "        # sure that we guess volumes mostly correctly in that case as well",
            "        instance = objects.Instance(**self.test_instance)",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices>\"",
            "                    \"<disk type='file'><driver name='qemu' type='raw'/>\"",
            "                    \"<source file='/test/disk'/>\"",
            "                    \"<target dev='vda' bus='virtio'/></disk>\"",
            "                    \"<disk type='block'><driver name='qemu' type='raw'/>\"",
            "                    \"<source file='/fake/path/to/volume1'/>\"",
            "                    \"<target dev='vdb' bus='virtio'/></disk>\"",
            "                    \"</devices></domain>\")",
            "",
            "        # Preparing mocks",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"XMLDesc\")",
            "        vdmock.XMLDesc(flags=0).AndReturn(dummyxml)",
            "",
            "        def fake_lookup(instance_name):",
            "            if instance_name == instance.name:",
            "                return vdmock",
            "        self.create_fake_libvirt_mock(lookupByName=fake_lookup)",
            "",
            "        fake_libvirt_utils.disk_sizes['/test/disk'] = 10 * units.Gi",
            "",
            "        self.mox.StubOutWithMock(os.path, \"getsize\")",
            "        os.path.getsize('/test/disk').AndReturn((10737418240))",
            "",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        info = drvr.get_instance_disk_info(instance)",
            "",
            "        info = jsonutils.loads(info)",
            "        self.assertEqual(1, len(info))",
            "        self.assertEqual(info[0]['type'], 'raw')",
            "        self.assertEqual(info[0]['path'], '/test/disk')",
            "        self.assertEqual(info[0]['disk_size'], 10737418240)",
            "        self.assertEqual(info[0]['backing_file'], \"\")",
            "        self.assertEqual(info[0]['over_committed_disk_size'], 0)",
            "",
            "    def test_spawn_with_network_info(self):",
            "        # Preparing mocks",
            "        def fake_none(*args, **kwargs):",
            "            return",
            "",
            "        def fake_getLibVersion():",
            "            return fakelibvirt.FAKE_LIBVIRT_VERSION",
            "",
            "        def fake_getCapabilities():",
            "            return \"\"\"",
            "            <capabilities>",
            "                <host>",
            "                    <uuid>cef19ce0-0ca2-11df-855d-b19fbce37686</uuid>",
            "                    <cpu>",
            "                      <arch>x86_64</arch>",
            "                      <model>Penryn</model>",
            "                      <vendor>Intel</vendor>",
            "                      <topology sockets='1' cores='2' threads='1'/>",
            "                      <feature name='xtpr'/>",
            "                    </cpu>",
            "                </host>",
            "            </capabilities>",
            "            \"\"\"",
            "",
            "        def fake_baselineCPU(cpu, flag):",
            "            return \"\"\"<cpu mode='custom' match='exact'>",
            "                        <model fallback='allow'>Penryn</model>",
            "                        <vendor>Intel</vendor>",
            "                        <feature policy='require' name='xtpr'/>",
            "                      </cpu>",
            "                   \"\"\"",
            "",
            "        # _fake_network_info must be called before create_fake_libvirt_mock(),",
            "        # as _fake_network_info calls importutils.import_class() and",
            "        # create_fake_libvirt_mock() mocks importutils.import_class().",
            "        network_info = _fake_network_info(self, 1)",
            "        self.create_fake_libvirt_mock(getLibVersion=fake_getLibVersion,",
            "                                      getCapabilities=fake_getCapabilities,",
            "                                      getVersion=lambda: 1005001,",
            "                                      baselineCPU=fake_baselineCPU)",
            "",
            "        instance_ref = self.test_instance",
            "        instance_ref['image_ref'] = 123456  # we send an int to test sha1 call",
            "        instance = objects.Instance(**instance_ref)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        # Mock out the get_info method of the LibvirtDriver so that the polling",
            "        # in the spawn method of the LibvirtDriver returns immediately",
            "        self.mox.StubOutWithMock(libvirt_driver.LibvirtDriver, 'get_info')",
            "        libvirt_driver.LibvirtDriver.get_info(instance",
            "            ).AndReturn(hardware.InstanceInfo(state=power_state.RUNNING))",
            "",
            "        # Start test",
            "        self.mox.ReplayAll()",
            "",
            "        with mock.patch('nova.virt.libvirt.driver.libvirt') as old_virt:",
            "            del old_virt.VIR_CONNECT_BASELINE_CPU_EXPAND_FEATURES",
            "",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "            self.stubs.Set(drvr.firewall_driver,",
            "                        'setup_basic_filtering',",
            "                        fake_none)",
            "            self.stubs.Set(drvr.firewall_driver,",
            "                        'prepare_instance_filter',",
            "                        fake_none)",
            "            self.stubs.Set(imagebackend.Image,",
            "                        'cache',",
            "                        fake_none)",
            "",
            "            drvr.spawn(self.context, instance, image_meta, [], 'herp',",
            "                        network_info=network_info)",
            "",
            "        path = os.path.join(CONF.instances_path, instance['name'])",
            "        if os.path.isdir(path):",
            "            shutil.rmtree(path)",
            "",
            "        path = os.path.join(CONF.instances_path,",
            "                            CONF.image_cache_subdirectory_name)",
            "        if os.path.isdir(path):",
            "            shutil.rmtree(os.path.join(CONF.instances_path,",
            "                                       CONF.image_cache_subdirectory_name))",
            "",
            "    def test_spawn_without_image_meta(self):",
            "        self.create_image_called = False",
            "",
            "        def fake_none(*args, **kwargs):",
            "            return",
            "",
            "        def fake_create_image(*args, **kwargs):",
            "            self.create_image_called = True",
            "",
            "        def fake_get_info(instance):",
            "            return hardware.InstanceInfo(state=power_state.RUNNING)",
            "",
            "        instance_ref = self.test_instance",
            "        instance_ref['image_ref'] = 1",
            "        instance = objects.Instance(**instance_ref)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr, '_get_guest_xml', fake_none)",
            "        self.stubs.Set(drvr, '_create_image', fake_create_image)",
            "        self.stubs.Set(drvr, '_create_domain_and_network', fake_none)",
            "        self.stubs.Set(drvr, 'get_info', fake_get_info)",
            "",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        drvr.spawn(self.context, instance,",
            "                   image_meta, [], None)",
            "        self.assertTrue(self.create_image_called)",
            "",
            "        drvr.spawn(self.context, instance,",
            "                   image_meta, [], None)",
            "        self.assertTrue(self.create_image_called)",
            "",
            "    def test_spawn_from_volume_calls_cache(self):",
            "        self.cache_called_for_disk = False",
            "",
            "        def fake_none(*args, **kwargs):",
            "            return",
            "",
            "        def fake_cache(*args, **kwargs):",
            "            if kwargs.get('image_id') == 'my_fake_image':",
            "                self.cache_called_for_disk = True",
            "",
            "        def fake_get_info(instance):",
            "            return hardware.InstanceInfo(state=power_state.RUNNING)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr, '_get_guest_xml', fake_none)",
            "",
            "        self.stubs.Set(imagebackend.Image, 'cache', fake_cache)",
            "        self.stubs.Set(drvr, '_create_domain_and_network', fake_none)",
            "        self.stubs.Set(drvr, 'get_info', fake_get_info)",
            "",
            "        block_device_info = {'root_device_name': '/dev/vda',",
            "                             'block_device_mapping': [",
            "                                {'mount_device': 'vda',",
            "                                 'boot_index': 0}",
            "                                ]",
            "                            }",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        # Volume-backed instance created without image",
            "        instance_ref = self.test_instance",
            "        instance_ref['image_ref'] = ''",
            "        instance_ref['root_device_name'] = '/dev/vda'",
            "        instance_ref['uuid'] = uuidutils.generate_uuid()",
            "        instance = objects.Instance(**instance_ref)",
            "",
            "        drvr.spawn(self.context, instance,",
            "                   image_meta, [], None,",
            "                   block_device_info=block_device_info)",
            "        self.assertFalse(self.cache_called_for_disk)",
            "",
            "        # Booted from volume but with placeholder image",
            "        instance_ref = self.test_instance",
            "        instance_ref['image_ref'] = 'my_fake_image'",
            "        instance_ref['root_device_name'] = '/dev/vda'",
            "        instance_ref['uuid'] = uuidutils.generate_uuid()",
            "        instance = objects.Instance(**instance_ref)",
            "",
            "        drvr.spawn(self.context, instance,",
            "                   image_meta, [], None,",
            "                   block_device_info=block_device_info)",
            "        self.assertFalse(self.cache_called_for_disk)",
            "",
            "        # Booted from an image",
            "        instance_ref['image_ref'] = 'my_fake_image'",
            "        instance_ref['uuid'] = uuidutils.generate_uuid()",
            "        instance = objects.Instance(**instance_ref)",
            "        drvr.spawn(self.context, instance,",
            "                   image_meta, [], None)",
            "        self.assertTrue(self.cache_called_for_disk)",
            "",
            "    def test_start_lxc_from_volume(self):",
            "        self.flags(virt_type=\"lxc\",",
            "                   group='libvirt')",
            "",
            "        def check_setup_container(image, container_dir=None):",
            "            self.assertIsInstance(image, imgmodel.LocalBlockImage)",
            "            self.assertEqual(image.path, '/dev/path/to/dev')",
            "            return '/dev/nbd1'",
            "",
            "        bdm = {",
            "                  'guest_format': None,",
            "                  'boot_index': 0,",
            "                  'mount_device': '/dev/sda',",
            "                  'connection_info': {",
            "                      'driver_volume_type': 'iscsi',",
            "                      'serial': 'afc1',",
            "                      'data': {",
            "                          'access_mode': 'rw',",
            "                          'target_discovered': False,",
            "                          'encrypted': False,",
            "                          'qos_specs': None,",
            "                          'target_iqn': 'iqn: volume-afc1',",
            "                          'target_portal': 'ip: 3260',",
            "                          'volume_id': 'afc1',",
            "                          'target_lun': 1,",
            "                          'auth_password': 'uj',",
            "                          'auth_username': '47',",
            "                          'auth_method': 'CHAP'",
            "                      }",
            "                  },",
            "                  'disk_bus': 'scsi',",
            "                  'device_type': 'disk',",
            "                  'delete_on_termination': False",
            "              }",
            "",
            "        def _connect_volume_side_effect(connection_info, disk_info):",
            "            bdm['connection_info']['data']['device_path'] = '/dev/path/to/dev'",
            "",
            "        def _get(key, opt=None):",
            "            return bdm.get(key, opt)",
            "",
            "        def getitem(key):",
            "            return bdm[key]",
            "",
            "        def setitem(key, val):",
            "            bdm[key] = val",
            "",
            "        bdm_mock = mock.MagicMock()",
            "        bdm_mock.__getitem__.side_effect = getitem",
            "        bdm_mock.__setitem__.side_effect = setitem",
            "        bdm_mock.get = _get",
            "",
            "        disk_mock = mock.MagicMock()",
            "        disk_mock.source_path = '/dev/path/to/dev'",
            "",
            "        block_device_info = {'block_device_mapping': [bdm_mock],",
            "                             'root_device_name': '/dev/sda'}",
            "",
            "        # Volume-backed instance created without image",
            "        instance_ref = self.test_instance",
            "        instance_ref['image_ref'] = ''",
            "        instance_ref['root_device_name'] = '/dev/sda'",
            "        instance_ref['ephemeral_gb'] = 0",
            "        instance_ref['uuid'] = uuidutils.generate_uuid()",
            "        inst_obj = objects.Instance(**instance_ref)",
            "        image_meta = objects.ImageMeta.from_dict({})",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        with test.nested(",
            "            mock.patch.object(drvr, '_create_images_and_backing'),",
            "            mock.patch.object(drvr, 'plug_vifs'),",
            "            mock.patch.object(drvr.firewall_driver, 'setup_basic_filtering'),",
            "            mock.patch.object(drvr.firewall_driver, 'prepare_instance_filter'),",
            "            mock.patch.object(drvr.firewall_driver, 'apply_instance_filter'),",
            "            mock.patch.object(drvr, '_create_domain'),",
            "            mock.patch.object(drvr, '_connect_volume',",
            "                              side_effect=_connect_volume_side_effect),",
            "            mock.patch.object(drvr, '_get_volume_config',",
            "                                     return_value=disk_mock),",
            "            mock.patch.object(drvr, 'get_info',",
            "                              return_value=hardware.InstanceInfo(",
            "                              state=power_state.RUNNING)),",
            "            mock.patch('nova.virt.disk.api.setup_container',",
            "                       side_effect=check_setup_container),",
            "            mock.patch('nova.virt.disk.api.teardown_container'),",
            "            mock.patch.object(objects.Instance, 'save')):",
            "",
            "            drvr.spawn(self.context, inst_obj, image_meta, [], None,",
            "                       network_info=[],",
            "                       block_device_info=block_device_info)",
            "            self.assertEqual('/dev/nbd1',",
            "                             inst_obj.system_metadata.get(",
            "                             'rootfs_device_name'))",
            "",
            "    def test_spawn_with_pci_devices(self):",
            "        def fake_none(*args, **kwargs):",
            "            return None",
            "",
            "        def fake_get_info(instance):",
            "            return hardware.InstanceInfo(state=power_state.RUNNING)",
            "",
            "        class FakeLibvirtPciDevice(object):",
            "            def dettach(self):",
            "                return None",
            "",
            "            def reset(self):",
            "                return None",
            "",
            "        def fake_node_device_lookup_by_name(address):",
            "            pattern = (\"pci_%(hex)s{4}_%(hex)s{2}_%(hex)s{2}_%(oct)s{1}\"",
            "                       % dict(hex='[\\da-f]', oct='[0-8]'))",
            "            pattern = re.compile(pattern)",
            "            if pattern.match(address) is None:",
            "                raise fakelibvirt.libvirtError()",
            "            return FakeLibvirtPciDevice()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr, '_get_guest_xml', fake_none)",
            "        self.stubs.Set(drvr, '_create_image', fake_none)",
            "        self.stubs.Set(drvr, '_create_domain_and_network', fake_none)",
            "        self.stubs.Set(drvr, 'get_info', fake_get_info)",
            "",
            "        drvr._conn.nodeDeviceLookupByName = \\",
            "                    fake_node_device_lookup_by_name",
            "",
            "        instance_ref = self.test_instance",
            "        instance_ref['image_ref'] = 'my_fake_image'",
            "        instance = objects.Instance(**instance_ref)",
            "        instance['pci_devices'] = objects.PciDeviceList(",
            "            objects=[objects.PciDevice(address='0000:00:00.0')])",
            "",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        drvr.spawn(self.context, instance,",
            "                   image_meta, [], None)",
            "",
            "    def test_chown_disk_config_for_instance(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        self.mox.StubOutWithMock(fake_libvirt_utils, 'get_instance_path')",
            "        self.mox.StubOutWithMock(os.path, 'exists')",
            "        self.mox.StubOutWithMock(fake_libvirt_utils, 'chown')",
            "        fake_libvirt_utils.get_instance_path(instance).AndReturn('/tmp/uuid')",
            "        os.path.exists('/tmp/uuid/disk.config').AndReturn(True)",
            "        fake_libvirt_utils.chown('/tmp/uuid/disk.config', os.getuid())",
            "",
            "        self.mox.ReplayAll()",
            "        drvr._chown_disk_config_for_instance(instance)",
            "",
            "    def _test_create_image_plain(self, os_type='', filename='', mkfs=False):",
            "        gotFiles = []",
            "",
            "        def fake_image(self, instance, name, image_type=''):",
            "            class FakeImage(imagebackend.Image):",
            "                def __init__(self, instance, name, is_block_dev=False):",
            "                    self.path = os.path.join(instance['name'], name)",
            "                    self.is_block_dev = is_block_dev",
            "",
            "                def create_image(self, prepare_template, base,",
            "                                 size, *args, **kwargs):",
            "                    pass",
            "",
            "                def resize_image(self, size):",
            "                    pass",
            "",
            "                def cache(self, fetch_func, filename, size=None,",
            "                          *args, **kwargs):",
            "                    gotFiles.append({'filename': filename,",
            "                                     'size': size})",
            "",
            "                def snapshot(self, name):",
            "                    pass",
            "",
            "            return FakeImage(instance, name)",
            "",
            "        def fake_none(*args, **kwargs):",
            "            return",
            "",
            "        def fake_get_info(instance):",
            "            return hardware.InstanceInfo(state=power_state.RUNNING)",
            "",
            "        # Stop 'libvirt_driver._create_image' touching filesystem",
            "        self.stubs.Set(nova.virt.libvirt.imagebackend.Backend, \"image\",",
            "                       fake_image)",
            "",
            "        instance_ref = self.test_instance",
            "        instance_ref['image_ref'] = 1",
            "        instance = objects.Instance(**instance_ref)",
            "        instance['os_type'] = os_type",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr, '_get_guest_xml', fake_none)",
            "        self.stubs.Set(drvr, '_create_domain_and_network', fake_none)",
            "        self.stubs.Set(drvr, 'get_info', fake_get_info)",
            "        if mkfs:",
            "            self.stubs.Set(nova.virt.disk.api, '_MKFS_COMMAND',",
            "                       {os_type: 'mkfs.ext4 --label %(fs_label)s %(target)s'})",
            "",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta)",
            "        drvr._create_image(context, instance, disk_info['mapping'])",
            "        drvr._get_guest_xml(self.context, instance, None,",
            "                            disk_info, image_meta)",
            "",
            "        wantFiles = [",
            "            {'filename': '356a192b7913b04c54574d18c28d46e6395428ab',",
            "             'size': 10 * units.Gi},",
            "            {'filename': filename,",
            "             'size': 20 * units.Gi},",
            "            ]",
            "        self.assertEqual(gotFiles, wantFiles)",
            "",
            "    def test_create_image_plain_os_type_blank(self):",
            "        self._test_create_image_plain(os_type='',",
            "                                      filename=self._EPHEMERAL_20_DEFAULT,",
            "                                      mkfs=False)",
            "",
            "    def test_create_image_plain_os_type_none(self):",
            "        self._test_create_image_plain(os_type=None,",
            "                                      filename=self._EPHEMERAL_20_DEFAULT,",
            "                                      mkfs=False)",
            "",
            "    def test_create_image_plain_os_type_set_no_fs(self):",
            "        self._test_create_image_plain(os_type='test',",
            "                                      filename=self._EPHEMERAL_20_DEFAULT,",
            "                                      mkfs=False)",
            "",
            "    def test_create_image_plain_os_type_set_with_fs(self):",
            "        ephemeral_file_name = ('ephemeral_20_%s' % utils.get_hash_str(",
            "            'mkfs.ext4 --label %(fs_label)s %(target)s')[:7])",
            "",
            "        self._test_create_image_plain(os_type='test',",
            "                                      filename=ephemeral_file_name,",
            "                                      mkfs=True)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.imagecache')",
            "    def test_create_image_initrd(self, mock_imagecache):",
            "        INITRD = self._EPHEMERAL_20_DEFAULT + '.initrd'",
            "        KERNEL = 'vmlinuz.' + self._EPHEMERAL_20_DEFAULT",
            "",
            "        mock_imagecache.get_cache_fname.side_effect = \\",
            "                [KERNEL,",
            "                 INITRD,",
            "                 self._EPHEMERAL_20_DEFAULT + '.img']",
            "        filename = self._EPHEMERAL_20_DEFAULT",
            "",
            "        gotFiles = []",
            "",
            "        outer = self",
            "",
            "        def fake_image(self, instance, name, image_type=''):",
            "            class FakeImage(imagebackend.Image):",
            "                def __init__(self, instance, name, is_block_dev=False):",
            "                    self.path = os.path.join(instance['name'], name)",
            "                    self.is_block_dev = is_block_dev",
            "",
            "                def create_image(self, prepare_template, base,",
            "                                 size, *args, **kwargs):",
            "                    pass",
            "",
            "                def cache(self, fetch_func, filename, size=None,",
            "                          *args, **kwargs):",
            "                    gotFiles.append({'filename': filename,",
            "                                     'size': size})",
            "                    if filename == INITRD:",
            "                        outer.assertEqual(fetch_func,",
            "                                fake_libvirt_utils.fetch_raw_image)",
            "                    if filename == KERNEL:",
            "                        outer.assertEqual(fetch_func,",
            "                                fake_libvirt_utils.fetch_raw_image)",
            "",
            "                def resize_image(self, size):",
            "                    pass",
            "",
            "                def snapshot(self, name):",
            "                    pass",
            "",
            "            return FakeImage(instance, name)",
            "",
            "        instance_ref = self.test_instance",
            "        instance_ref['image_ref'] = 1",
            "        instance_ref['kernel_id'] = 2",
            "        instance_ref['ramdisk_id'] = 3",
            "        instance_ref['os_type'] = 'test'",
            "        instance = objects.Instance(**instance_ref)",
            "",
            "        driver = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        with test.nested(",
            "            mock.patch.object(nova.virt.libvirt.imagebackend.Backend,",
            "              \"image\", fake_image),",
            "            mock.patch.object(driver, '_get_guest_xml'),",
            "            mock.patch.object(driver, '_create_domain_and_network'),",
            "            mock.patch.object(driver, 'get_info',",
            "              return_value=[hardware.InstanceInfo(state=power_state.RUNNING)])",
            "            ):",
            "            image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "            disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                                instance,",
            "                                                image_meta)",
            "            driver._create_image(context, instance, disk_info['mapping'])",
            "",
            "        wantFiles = [",
            "            {'filename': KERNEL,",
            "             'size': None},",
            "            {'filename': INITRD,",
            "             'size': None},",
            "            {'filename': self._EPHEMERAL_20_DEFAULT + '.img',",
            "             'size': 10 * units.Gi},",
            "            {'filename': filename,",
            "             'size': 20 * units.Gi},",
            "            ]",
            "        self.assertEqual(wantFiles, gotFiles)",
            "",
            "    def _create_image_helper(self, callback, suffix=''):",
            "        gotFiles = []",
            "        imported_files = []",
            "",
            "        def fake_image(self, instance, name, image_type=''):",
            "            class FakeImage(imagebackend.Image):",
            "                def __init__(self, instance, name, is_block_dev=False):",
            "                    self.path = os.path.join(instance['name'], name)",
            "                    self.is_block_dev = is_block_dev",
            "",
            "                def create_image(self, prepare_template, base,",
            "                                 size, *args, **kwargs):",
            "                    pass",
            "",
            "                def resize_image(self, size):",
            "                    pass",
            "",
            "                def cache(self, fetch_func, filename, size=None,",
            "                          *args, **kwargs):",
            "                    gotFiles.append({'filename': filename,",
            "                                     'size': size})",
            "",
            "                def import_file(self, instance, local_filename,",
            "                                remote_filename):",
            "                    imported_files.append((local_filename, remote_filename))",
            "",
            "                def snapshot(self, name):",
            "                    pass",
            "",
            "            return FakeImage(instance, name)",
            "",
            "        def fake_none(*args, **kwargs):",
            "            return",
            "",
            "        def fake_get_info(instance):",
            "            return hardware.InstanceInfo(state=power_state.RUNNING)",
            "",
            "        # Stop 'libvirt_driver._create_image' touching filesystem",
            "        self.stubs.Set(nova.virt.libvirt.imagebackend.Backend, \"image\",",
            "                       fake_image)",
            "",
            "        instance_ref = self.test_instance",
            "        instance_ref['image_ref'] = 1",
            "        # NOTE(mikal): use this callback to tweak the instance to match",
            "        # what you're trying to test",
            "        callback(instance_ref)",
            "        instance = objects.Instance(**instance_ref)",
            "        # Turn on some swap to exercise that codepath in _create_image",
            "        instance.flavor.swap = 500",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr, '_get_guest_xml', fake_none)",
            "        self.stubs.Set(drvr, '_create_domain_and_network', fake_none)",
            "        self.stubs.Set(drvr, 'get_info', fake_get_info)",
            "        self.stubs.Set(instance_metadata, 'InstanceMetadata', fake_none)",
            "        self.stubs.Set(nova.virt.configdrive.ConfigDriveBuilder,",
            "                       'make_drive', fake_none)",
            "",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta)",
            "        drvr._create_image(context, instance, disk_info['mapping'],",
            "                           suffix=suffix)",
            "        drvr._get_guest_xml(self.context, instance, None,",
            "                            disk_info, image_meta)",
            "",
            "        return gotFiles, imported_files",
            "",
            "    def test_create_image_with_swap(self):",
            "        def enable_swap(instance_ref):",
            "            # Turn on some swap to exercise that codepath in _create_image",
            "            instance_ref['system_metadata']['instance_type_swap'] = 500",
            "",
            "        gotFiles, _ = self._create_image_helper(enable_swap)",
            "        wantFiles = [",
            "            {'filename': '356a192b7913b04c54574d18c28d46e6395428ab',",
            "             'size': 10 * units.Gi},",
            "            {'filename': self._EPHEMERAL_20_DEFAULT,",
            "             'size': 20 * units.Gi},",
            "            {'filename': 'swap_500',",
            "             'size': 500 * units.Mi},",
            "            ]",
            "        self.assertEqual(gotFiles, wantFiles)",
            "",
            "    def test_create_image_with_configdrive(self):",
            "        def enable_configdrive(instance_ref):",
            "            instance_ref['config_drive'] = 'true'",
            "",
            "        # Ensure that we create a config drive and then import it into the",
            "        # image backend store",
            "        _, imported_files = self._create_image_helper(enable_configdrive)",
            "        self.assertTrue(imported_files[0][0].endswith('/disk.config'))",
            "        self.assertEqual('disk.config', imported_files[0][1])",
            "",
            "    def test_create_image_with_configdrive_rescue(self):",
            "        def enable_configdrive(instance_ref):",
            "            instance_ref['config_drive'] = 'true'",
            "",
            "        # Ensure that we create a config drive and then import it into the",
            "        # image backend store",
            "        _, imported_files = self._create_image_helper(enable_configdrive,",
            "                                                      suffix='.rescue')",
            "        self.assertTrue(imported_files[0][0].endswith('/disk.config.rescue'))",
            "        self.assertEqual('disk.config.rescue', imported_files[0][1])",
            "",
            "    @mock.patch.object(nova.virt.libvirt.imagebackend.Image, 'cache',",
            "                       side_effect=exception.ImageNotFound(image_id='fake-id'))",
            "    def test_create_image_not_exist_no_fallback(self, mock_cache):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta)",
            "        self.assertRaises(exception.ImageNotFound,",
            "                          drvr._create_image,",
            "                          self.context, instance, disk_info['mapping'])",
            "",
            "    @mock.patch.object(nova.virt.libvirt.imagebackend.Image, 'cache')",
            "    def test_create_image_not_exist_fallback(self, mock_cache):",
            "",
            "        def side_effect(fetch_func, filename, size=None, *args, **kwargs):",
            "            def second_call(fetch_func, filename, size=None, *args, **kwargs):",
            "                # call copy_from_host ourselves because we mocked image.cache()",
            "                fetch_func('fake-target', 'fake-max-size')",
            "                # further calls have no side effect",
            "                mock_cache.side_effect = None",
            "            mock_cache.side_effect = second_call",
            "            # raise an error only the first call",
            "            raise exception.ImageNotFound(image_id='fake-id')",
            "",
            "        mock_cache.side_effect = side_effect",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta)",
            "",
            "        with mock.patch.object(libvirt_driver.libvirt_utils,",
            "                               'copy_image') as mock_copy:",
            "            drvr._create_image(self.context, instance, disk_info['mapping'],",
            "                               fallback_from_host='fake-source-host')",
            "            mock_copy.assert_called_once_with(src='fake-target',",
            "                                              dest='fake-target',",
            "                                              host='fake-source-host',",
            "                                              receive=True)",
            "",
            "    @mock.patch.object(nova.virt.libvirt.imagebackend.Image, 'cache')",
            "    def test_create_image_resize_snap_backend(self, mock_cache):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr.image_backend = mock.Mock()",
            "        drvr.image_backend.image.return_value = drvr.image_backend",
            "        instance = objects.Instance(**self.test_instance)",
            "        instance.task_state = task_states.RESIZE_FINISH",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta)",
            "        with mock.patch.object(drvr.image_backend, 'create_snap') as mock_crt:",
            "            drvr._create_image(self.context, instance, disk_info['mapping'])",
            "            mock_crt.assert_called_once_with(",
            "                    libvirt_utils.RESIZE_SNAPSHOT_NAME)",
            "",
            "    @mock.patch.object(utils, 'execute')",
            "    def test_create_ephemeral_specified_fs(self, mock_exec):",
            "        self.flags(default_ephemeral_format='ext3')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr._create_ephemeral('/dev/something', 20, 'myVol', 'linux',",
            "                               is_block_dev=True, max_size=20,",
            "                               specified_fs='ext4')",
            "        mock_exec.assert_called_once_with('mkfs', '-t', 'ext4', '-F', '-L',",
            "                                          'myVol', '/dev/something',",
            "                                          run_as_root=True)",
            "",
            "    def test_create_ephemeral_specified_fs_not_valid(self):",
            "        CONF.set_override('default_ephemeral_format', 'ext4')",
            "        ephemerals = [{'device_type': 'disk',",
            "                       'disk_bus': 'virtio',",
            "                       'device_name': '/dev/vdb',",
            "                       'guest_format': 'dummy',",
            "                       'size': 1}]",
            "        block_device_info = {",
            "                'ephemerals': ephemerals}",
            "        instance_ref = self.test_instance",
            "        instance_ref['image_ref'] = 1",
            "        instance = objects.Instance(**instance_ref)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        image_meta = objects.ImageMeta.from_dict({'disk_format': 'raw'})",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta)",
            "        disk_info['mapping'].pop('disk.local')",
            "",
            "        with test.nested(",
            "            mock.patch.object(utils, 'execute'),",
            "            mock.patch.object(drvr, 'get_info'),",
            "            mock.patch.object(drvr, '_create_domain_and_network'),",
            "            mock.patch.object(imagebackend.Image, 'verify_base_size'),",
            "            mock.patch.object(imagebackend.Image, 'get_disk_size')):",
            "            self.assertRaises(exception.InvalidBDMFormat, drvr._create_image,",
            "                              context, instance, disk_info['mapping'],",
            "                              block_device_info=block_device_info)",
            "",
            "    def test_create_ephemeral_default(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.mox.StubOutWithMock(utils, 'execute')",
            "        utils.execute('mkfs', '-t', 'ext4', '-F', '-L', 'myVol',",
            "                      '/dev/something', run_as_root=True)",
            "        self.mox.ReplayAll()",
            "        drvr._create_ephemeral('/dev/something', 20, 'myVol', 'linux',",
            "                               is_block_dev=True, max_size=20)",
            "",
            "    def test_create_ephemeral_with_conf(self):",
            "        CONF.set_override('default_ephemeral_format', 'ext4')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.mox.StubOutWithMock(utils, 'execute')",
            "        utils.execute('mkfs', '-t', 'ext4', '-F', '-L', 'myVol',",
            "                      '/dev/something', run_as_root=True)",
            "        self.mox.ReplayAll()",
            "        drvr._create_ephemeral('/dev/something', 20, 'myVol', 'linux',",
            "                               is_block_dev=True)",
            "",
            "    def test_create_ephemeral_with_arbitrary(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(nova.virt.disk.api, '_MKFS_COMMAND',",
            "                       {'linux': 'mkfs.ext4 --label %(fs_label)s %(target)s'})",
            "        self.mox.StubOutWithMock(utils, 'execute')",
            "        utils.execute('mkfs.ext4', '--label', 'myVol', '/dev/something',",
            "                      run_as_root=True)",
            "        self.mox.ReplayAll()",
            "        drvr._create_ephemeral('/dev/something', 20, 'myVol', 'linux',",
            "                               is_block_dev=True)",
            "",
            "    def test_create_ephemeral_with_ext3(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(nova.virt.disk.api, '_MKFS_COMMAND',",
            "                       {'linux': 'mkfs.ext3 --label %(fs_label)s %(target)s'})",
            "        self.mox.StubOutWithMock(utils, 'execute')",
            "        utils.execute('mkfs.ext3', '--label', 'myVol', '/dev/something',",
            "                      run_as_root=True)",
            "        self.mox.ReplayAll()",
            "        drvr._create_ephemeral('/dev/something', 20, 'myVol', 'linux',",
            "                               is_block_dev=True)",
            "",
            "    def test_create_swap_default(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.mox.StubOutWithMock(utils, 'execute')",
            "        utils.execute('mkswap', '/dev/something', run_as_root=False)",
            "        self.mox.ReplayAll()",
            "",
            "        drvr._create_swap('/dev/something', 1, max_size=20)",
            "",
            "    def test_get_console_output_file(self):",
            "        fake_libvirt_utils.files['console.log'] = '01234567890'",
            "",
            "        with utils.tempdir() as tmpdir:",
            "            self.flags(instances_path=tmpdir)",
            "",
            "            instance_ref = self.test_instance",
            "            instance_ref['image_ref'] = 123456",
            "            instance = objects.Instance(**instance_ref)",
            "",
            "            console_dir = (os.path.join(tmpdir, instance['name']))",
            "            console_log = '%s/console.log' % (console_dir)",
            "            fake_dom_xml = \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                        </disk>",
            "                        <console type='file'>",
            "                            <source path='%s'/>",
            "                            <target port='0'/>",
            "                        </console>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\" % console_log",
            "",
            "            def fake_lookup(id):",
            "                return FakeVirtDomain(fake_dom_xml)",
            "",
            "            self.create_fake_libvirt_mock()",
            "            libvirt_driver.LibvirtDriver._conn.lookupByName = fake_lookup",
            "",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "            try:",
            "                prev_max = libvirt_driver.MAX_CONSOLE_BYTES",
            "                libvirt_driver.MAX_CONSOLE_BYTES = 5",
            "                with mock.patch('os.path.exists', return_value=True):",
            "                    output = drvr.get_console_output(self.context, instance)",
            "            finally:",
            "                libvirt_driver.MAX_CONSOLE_BYTES = prev_max",
            "",
            "            self.assertEqual('67890', output)",
            "",
            "    def test_get_console_output_file_missing(self):",
            "        with utils.tempdir() as tmpdir:",
            "            self.flags(instances_path=tmpdir)",
            "",
            "            instance_ref = self.test_instance",
            "            instance_ref['image_ref'] = 123456",
            "            instance = objects.Instance(**instance_ref)",
            "",
            "            console_log = os.path.join(tmpdir, instance['name'],",
            "                                       'non-existent.log')",
            "            fake_dom_xml = \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                        </disk>",
            "                        <console type='file'>",
            "                            <source path='%s'/>",
            "                            <target port='0'/>",
            "                        </console>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\" % console_log",
            "",
            "            def fake_lookup(id):",
            "                return FakeVirtDomain(fake_dom_xml)",
            "",
            "            self.create_fake_libvirt_mock()",
            "            libvirt_driver.LibvirtDriver._conn.lookupByName = fake_lookup",
            "",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "            with mock.patch('os.path.exists', return_value=False):",
            "                output = drvr.get_console_output(self.context, instance)",
            "",
            "            self.assertEqual('', output)",
            "",
            "    def test_get_console_output_pty(self):",
            "        fake_libvirt_utils.files['pty'] = '01234567890'",
            "",
            "        with utils.tempdir() as tmpdir:",
            "            self.flags(instances_path=tmpdir)",
            "",
            "            instance_ref = self.test_instance",
            "            instance_ref['image_ref'] = 123456",
            "            instance = objects.Instance(**instance_ref)",
            "",
            "            console_dir = (os.path.join(tmpdir, instance['name']))",
            "            pty_file = '%s/fake_pty' % (console_dir)",
            "            fake_dom_xml = \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                        </disk>",
            "                        <console type='pty'>",
            "                            <source path='%s'/>",
            "                            <target port='0'/>",
            "                        </console>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\" % pty_file",
            "",
            "            def fake_lookup(id):",
            "                return FakeVirtDomain(fake_dom_xml)",
            "",
            "            def _fake_flush(self, fake_pty):",
            "                return 'foo'",
            "",
            "            def _fake_append_to_file(self, data, fpath):",
            "                return 'pty'",
            "",
            "            self.create_fake_libvirt_mock()",
            "            libvirt_driver.LibvirtDriver._conn.lookupByName = fake_lookup",
            "            libvirt_driver.LibvirtDriver._flush_libvirt_console = _fake_flush",
            "            libvirt_driver.LibvirtDriver._append_to_file = _fake_append_to_file",
            "",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "            try:",
            "                prev_max = libvirt_driver.MAX_CONSOLE_BYTES",
            "                libvirt_driver.MAX_CONSOLE_BYTES = 5",
            "                output = drvr.get_console_output(self.context, instance)",
            "            finally:",
            "                libvirt_driver.MAX_CONSOLE_BYTES = prev_max",
            "",
            "            self.assertEqual('67890', output)",
            "",
            "    def test_get_host_ip_addr(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        ip = drvr.get_host_ip_addr()",
            "        self.assertEqual(ip, CONF.my_ip)",
            "",
            "    @mock.patch.object(libvirt_driver.LOG, 'warn')",
            "    @mock.patch('nova.compute.utils.get_machine_ips')",
            "    def test_get_host_ip_addr_failure(self, mock_ips, mock_log):",
            "        mock_ips.return_value = ['8.8.8.8', '75.75.75.75']",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr.get_host_ip_addr()",
            "        mock_log.assert_called_once_with(u'my_ip address (%(my_ip)s) was '",
            "                                         u'not found on any of the '",
            "                                         u'interfaces: %(ifaces)s',",
            "                                         {'ifaces': '8.8.8.8, 75.75.75.75',",
            "                                          'my_ip': mock.ANY})",
            "",
            "    def test_conn_event_handler(self):",
            "        self.mox.UnsetStubs()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        service_mock = mock.MagicMock()",
            "        service_mock.disabled.return_value = False",
            "        with test.nested(",
            "            mock.patch.object(drvr._host, \"_connect\",",
            "                              side_effect=fakelibvirt.make_libvirtError(",
            "                                  fakelibvirt.libvirtError,",
            "                                  \"Failed to connect to host\",",
            "                                  error_code=",
            "                                  fakelibvirt.VIR_ERR_INTERNAL_ERROR)),",
            "            mock.patch.object(drvr._host, \"_init_events\",",
            "                              return_value=None),",
            "            mock.patch.object(objects.Service, \"get_by_compute_host\",",
            "                              return_value=service_mock)):",
            "",
            "            # verify that the driver registers for the close callback",
            "            # and re-connects after receiving the callback",
            "            self.assertRaises(exception.HypervisorUnavailable,",
            "                              drvr.init_host,",
            "                              \"wibble\")",
            "            self.assertTrue(service_mock.disabled)",
            "",
            "    def test_command_with_broken_connection(self):",
            "        self.mox.UnsetStubs()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        service_mock = mock.MagicMock()",
            "        service_mock.disabled.return_value = False",
            "        with test.nested(",
            "            mock.patch.object(drvr._host, \"_connect\",",
            "                              side_effect=fakelibvirt.make_libvirtError(",
            "                                  fakelibvirt.libvirtError,",
            "                                  \"Failed to connect to host\",",
            "                                  error_code=",
            "                                  fakelibvirt.VIR_ERR_INTERNAL_ERROR)),",
            "            mock.patch.object(drvr._host, \"_init_events\",",
            "                              return_value=None),",
            "            mock.patch.object(host.Host, \"has_min_version\",",
            "                              return_value=True),",
            "            mock.patch.object(drvr, \"_do_quality_warnings\",",
            "                              return_value=None),",
            "            mock.patch.object(objects.Service, \"get_by_compute_host\",",
            "                              return_value=service_mock)):",
            "",
            "            drvr.init_host(\"wibble\")",
            "            self.assertRaises(exception.HypervisorUnavailable,",
            "                              drvr.get_num_instances)",
            "            self.assertTrue(service_mock.disabled)",
            "",
            "    def test_service_resume_after_broken_connection(self):",
            "        self.mox.UnsetStubs()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        service_mock = mock.MagicMock()",
            "        service_mock.disabled.return_value = True",
            "        with test.nested(",
            "            mock.patch.object(drvr._host, \"_connect\",",
            "                              return_value=mock.MagicMock()),",
            "            mock.patch.object(drvr._host, \"_init_events\",",
            "                              return_value=None),",
            "            mock.patch.object(host.Host, \"has_min_version\",",
            "                              return_value=True),",
            "            mock.patch.object(drvr, \"_do_quality_warnings\",",
            "                              return_value=None),",
            "            mock.patch.object(objects.Service, \"get_by_compute_host\",",
            "                              return_value=service_mock)):",
            "",
            "            drvr.init_host(\"wibble\")",
            "            drvr.get_num_instances()",
            "            self.assertTrue(not service_mock.disabled and",
            "                            service_mock.disabled_reason is None)",
            "",
            "    @mock.patch.object(objects.Instance, 'save')",
            "    def test_immediate_delete(self, mock_save):",
            "        def fake_get_domain(instance):",
            "            raise exception.InstanceNotFound(instance_id=instance.uuid)",
            "",
            "        def fake_delete_instance_files(instance):",
            "            pass",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr._host, 'get_domain', fake_get_domain)",
            "        self.stubs.Set(drvr, 'delete_instance_files',",
            "                       fake_delete_instance_files)",
            "",
            "        instance = objects.Instance(self.context, **self.test_instance)",
            "        drvr.destroy(self.context, instance, {})",
            "        mock_save.assert_called_once_with()",
            "",
            "    @mock.patch.object(objects.Instance, 'get_by_uuid')",
            "    @mock.patch.object(objects.Instance, 'obj_load_attr', autospec=True)",
            "    @mock.patch.object(objects.Instance, 'save', autospec=True)",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_destroy')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, 'delete_instance_files')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_disconnect_volume')",
            "    @mock.patch.object(driver, 'block_device_info_get_mapping')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_undefine_domain')",
            "    def _test_destroy_removes_disk(self, mock_undefine_domain, mock_mapping,",
            "                                   mock_disconnect_volume,",
            "                                   mock_delete_instance_files, mock_destroy,",
            "                                   mock_inst_save, mock_inst_obj_load_attr,",
            "                                   mock_get_by_uuid, volume_fail=False):",
            "        instance = objects.Instance(self.context, **self.test_instance)",
            "        vol = {'block_device_mapping': [",
            "              {'connection_info': 'dummy', 'mount_device': '/dev/sdb'}]}",
            "",
            "        mock_mapping.return_value = vol['block_device_mapping']",
            "        mock_delete_instance_files.return_value = True",
            "        mock_get_by_uuid.return_value = instance",
            "        if volume_fail:",
            "            mock_disconnect_volume.return_value = (",
            "                exception.VolumeNotFound('vol'))",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr.destroy(self.context, instance, [], vol)",
            "",
            "    def test_destroy_removes_disk(self):",
            "        self._test_destroy_removes_disk(volume_fail=False)",
            "",
            "    def test_destroy_removes_disk_volume_fails(self):",
            "        self._test_destroy_removes_disk(volume_fail=True)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, 'unplug_vifs')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_destroy')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_undefine_domain')",
            "    def test_destroy_not_removes_disk(self, mock_undefine_domain, mock_destroy,",
            "                                      mock_unplug_vifs):",
            "        instance = fake_instance.fake_instance_obj(",
            "            None, name='instancename', id=1,",
            "            uuid='875a8070-d0b9-4949-8b31-104d125c9a64')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr.destroy(self.context, instance, [], None, False)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, 'cleanup')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_teardown_container')",
            "    @mock.patch.object(host.Host, 'get_domain')",
            "    def test_destroy_lxc_calls_teardown_container(self, mock_get_domain,",
            "                                                  mock_teardown_container,",
            "                                                  mock_cleanup):",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "        fake_domain = FakeVirtDomain()",
            "",
            "        def destroy_side_effect(*args, **kwargs):",
            "            fake_domain._info[0] = power_state.SHUTDOWN",
            "",
            "        with mock.patch.object(fake_domain, 'destroy',",
            "               side_effect=destroy_side_effect) as mock_domain_destroy:",
            "            mock_get_domain.return_value = fake_domain",
            "            instance = objects.Instance(**self.test_instance)",
            "",
            "            drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "            network_info = []",
            "            drvr.destroy(self.context, instance, network_info, None, False)",
            "",
            "            mock_get_domain.assert_has_calls([mock.call(instance),",
            "                                              mock.call(instance)])",
            "            mock_domain_destroy.assert_called_once_with()",
            "            mock_teardown_container.assert_called_once_with(instance)",
            "            mock_cleanup.assert_called_once_with(self.context, instance,",
            "                                                 network_info, None, False,",
            "                                                 None)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, 'cleanup')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_teardown_container')",
            "    @mock.patch.object(host.Host, 'get_domain')",
            "    def test_destroy_lxc_calls_teardown_container_when_no_domain(self,",
            "            mock_get_domain, mock_teardown_container, mock_cleanup):",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "        instance = objects.Instance(**self.test_instance)",
            "        inf_exception = exception.InstanceNotFound(instance_id=instance.uuid)",
            "        mock_get_domain.side_effect = inf_exception",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        network_info = []",
            "        drvr.destroy(self.context, instance, network_info, None, False)",
            "",
            "        mock_get_domain.assert_has_calls([mock.call(instance),",
            "                                          mock.call(instance)])",
            "        mock_teardown_container.assert_called_once_with(instance)",
            "        mock_cleanup.assert_called_once_with(self.context, instance,",
            "                                             network_info, None, False,",
            "                                             None)",
            "",
            "    def test_reboot_different_ids(self):",
            "        class FakeLoopingCall(object):",
            "            def start(self, *a, **k):",
            "                return self",
            "",
            "            def wait(self):",
            "                return None",
            "",
            "        self.flags(wait_soft_reboot_seconds=1, group='libvirt')",
            "        info_tuple = ('fake', 'fake', 'fake', 'also_fake')",
            "        self.reboot_create_called = False",
            "",
            "        # Mock domain",
            "        mock_domain = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        mock_domain.info().AndReturn(",
            "            (libvirt_guest.VIR_DOMAIN_RUNNING,) + info_tuple)",
            "        mock_domain.ID().AndReturn('some_fake_id')",
            "        mock_domain.ID().AndReturn('some_fake_id')",
            "        mock_domain.shutdown()",
            "        mock_domain.info().AndReturn(",
            "            (libvirt_guest.VIR_DOMAIN_CRASHED,) + info_tuple)",
            "        mock_domain.ID().AndReturn('some_other_fake_id')",
            "        mock_domain.ID().AndReturn('some_other_fake_id')",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        def fake_get_domain(instance):",
            "            return mock_domain",
            "",
            "        def fake_create_domain(**kwargs):",
            "            self.reboot_create_called = True",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        self.stubs.Set(drvr._host, 'get_domain', fake_get_domain)",
            "        self.stubs.Set(drvr, '_create_domain', fake_create_domain)",
            "        self.stubs.Set(loopingcall, 'FixedIntervalLoopingCall',",
            "                       lambda *a, **k: FakeLoopingCall())",
            "        self.stubs.Set(pci_manager, 'get_instance_pci_devs', lambda *a: [])",
            "        drvr.reboot(None, instance, [], 'SOFT')",
            "        self.assertTrue(self.reboot_create_called)",
            "",
            "    @mock.patch.object(pci_manager, 'get_instance_pci_devs')",
            "    @mock.patch.object(loopingcall, 'FixedIntervalLoopingCall')",
            "    @mock.patch.object(greenthread, 'sleep')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_hard_reboot')",
            "    @mock.patch.object(host.Host, 'get_domain')",
            "    def test_reboot_same_ids(self, mock_get_domain, mock_hard_reboot,",
            "                             mock_sleep, mock_loopingcall,",
            "                             mock_get_instance_pci_devs):",
            "        class FakeLoopingCall(object):",
            "            def start(self, *a, **k):",
            "                return self",
            "",
            "            def wait(self):",
            "                return None",
            "",
            "        self.flags(wait_soft_reboot_seconds=1, group='libvirt')",
            "        info_tuple = ('fake', 'fake', 'fake', 'also_fake')",
            "        self.reboot_hard_reboot_called = False",
            "",
            "        # Mock domain",
            "        mock_domain = mock.Mock(fakelibvirt.virDomain)",
            "        return_values = [(libvirt_guest.VIR_DOMAIN_RUNNING,) + info_tuple,",
            "                         (libvirt_guest.VIR_DOMAIN_CRASHED,) + info_tuple]",
            "        mock_domain.info.side_effect = return_values",
            "        mock_domain.ID.return_value = 'some_fake_id'",
            "        mock_domain.shutdown.side_effect = mock.Mock()",
            "",
            "        def fake_hard_reboot(*args, **kwargs):",
            "            self.reboot_hard_reboot_called = True",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_get_domain.return_value = mock_domain",
            "        mock_hard_reboot.side_effect = fake_hard_reboot",
            "        mock_loopingcall.return_value = FakeLoopingCall()",
            "        mock_get_instance_pci_devs.return_value = []",
            "        drvr.reboot(None, instance, [], 'SOFT')",
            "        self.assertTrue(self.reboot_hard_reboot_called)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_hard_reboot')",
            "    @mock.patch.object(host.Host, 'get_domain')",
            "    def test_soft_reboot_libvirt_exception(self, mock_get_domain,",
            "                                           mock_hard_reboot):",
            "        # Tests that a hard reboot is performed when a soft reboot results",
            "        # in raising a libvirtError.",
            "        info_tuple = ('fake', 'fake', 'fake', 'also_fake')",
            "        # setup mocks",
            "        mock_virDomain = mock.Mock(fakelibvirt.virDomain)",
            "        mock_virDomain.info.return_value = (",
            "            (libvirt_guest.VIR_DOMAIN_RUNNING,) + info_tuple)",
            "        mock_virDomain.ID.return_value = 'some_fake_id'",
            "        mock_virDomain.shutdown.side_effect = fakelibvirt.libvirtError('Err')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        context = None",
            "        instance = objects.Instance(**self.test_instance)",
            "        network_info = []",
            "        mock_get_domain.return_value = mock_virDomain",
            "",
            "        drvr.reboot(context, instance, network_info, 'SOFT')",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_hard_reboot')",
            "    @mock.patch.object(host.Host, 'get_domain')",
            "    def _test_resume_state_on_host_boot_with_state(self, state,",
            "                                                   mock_get_domain,",
            "                                                   mock_hard_reboot):",
            "        mock_virDomain = mock.Mock(fakelibvirt.virDomain)",
            "        mock_virDomain.info.return_value = ([state, None, None, None, None])",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        mock_get_domain.return_value = mock_virDomain",
            "        instance = objects.Instance(**self.test_instance)",
            "        network_info = _fake_network_info(self, 1)",
            "",
            "        drvr.resume_state_on_host_boot(self.context, instance, network_info,",
            "                                       block_device_info=None)",
            "",
            "        ignored_states = (power_state.RUNNING,",
            "                          power_state.SUSPENDED,",
            "                          power_state.NOSTATE,",
            "                          power_state.PAUSED)",
            "        self.assertEqual(mock_hard_reboot.called, state not in ignored_states)",
            "",
            "    def test_resume_state_on_host_boot_with_running_state(self):",
            "        self._test_resume_state_on_host_boot_with_state(power_state.RUNNING)",
            "",
            "    def test_resume_state_on_host_boot_with_suspended_state(self):",
            "        self._test_resume_state_on_host_boot_with_state(power_state.SUSPENDED)",
            "",
            "    def test_resume_state_on_host_boot_with_paused_state(self):",
            "        self._test_resume_state_on_host_boot_with_state(power_state.PAUSED)",
            "",
            "    def test_resume_state_on_host_boot_with_nostate(self):",
            "        self._test_resume_state_on_host_boot_with_state(power_state.NOSTATE)",
            "",
            "    def test_resume_state_on_host_boot_with_shutdown_state(self):",
            "        self._test_resume_state_on_host_boot_with_state(power_state.RUNNING)",
            "",
            "    def test_resume_state_on_host_boot_with_crashed_state(self):",
            "        self._test_resume_state_on_host_boot_with_state(power_state.CRASHED)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_hard_reboot')",
            "    @mock.patch.object(host.Host, 'get_domain')",
            "    def test_resume_state_on_host_boot_with_instance_not_found_on_driver(",
            "            self, mock_get_domain, mock_hard_reboot):",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        mock_get_domain.side_effect = exception.InstanceNotFound(",
            "            instance_id='fake')",
            "        drvr.resume_state_on_host_boot(self.context, instance, network_info=[],",
            "                                       block_device_info=None)",
            "",
            "        mock_hard_reboot.assert_called_once_with(self.context,",
            "                                                 instance, [], None)",
            "",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver.get_info')",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver._create_domain_and_network')",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver._create_images_and_backing')",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver._get_guest_xml')",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver._get_instance_disk_info')",
            "    @mock.patch('nova.virt.libvirt.blockinfo.get_disk_info')",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver._destroy')",
            "    def test_hard_reboot(self, mock_destroy, mock_get_disk_info,",
            "                         mock_get_instance_disk_info, mock_get_guest_xml,",
            "                         mock_create_images_and_backing,",
            "                         mock_create_domain_and_network, mock_get_info):",
            "        self.context.auth_token = True  # any non-None value will suffice",
            "        instance = objects.Instance(**self.test_instance)",
            "        instance_path = libvirt_utils.get_instance_path(instance)",
            "        network_info = _fake_network_info(self, 1)",
            "        block_device_info = None",
            "",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices>\"",
            "                    \"<disk type='file'><driver name='qemu' type='raw'/>\"",
            "                    \"<source file='/test/disk'/>\"",
            "                    \"<target dev='vda' bus='virtio'/></disk>\"",
            "                    \"<disk type='file'><driver name='qemu' type='qcow2'/>\"",
            "                    \"<source file='/test/disk.local'/>\"",
            "                    \"<target dev='vdb' bus='virtio'/></disk>\"",
            "                    \"</devices></domain>\")",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        return_values = [hardware.InstanceInfo(state=power_state.SHUTDOWN),",
            "                         hardware.InstanceInfo(state=power_state.RUNNING)]",
            "        mock_get_info.side_effect = return_values",
            "",
            "        backing_disk_info = [{\"virt_disk_size\": 2}]",
            "",
            "        mock_get_disk_info.return_value = mock.sentinel.disk_info",
            "        mock_get_guest_xml.return_value = dummyxml",
            "        mock_get_instance_disk_info.return_value = backing_disk_info",
            "",
            "        drvr._hard_reboot(self.context, instance, network_info,",
            "                          block_device_info)",
            "",
            "        # make sure that _create_images_and_backing is passed the disk_info",
            "        # returned from _get_instance_disk_info and not the one that is in",
            "        # scope from blockinfo.get_disk_info",
            "        mock_create_images_and_backing.assert_called_once_with(self.context,",
            "            instance, instance_path, backing_disk_info)",
            "",
            "        # make sure that _create_domain_and_network is passed the disk_info",
            "        # returned from blockinfo.get_disk_info and not the one that's",
            "        # returned from _get_instance_disk_info",
            "        mock_create_domain_and_network.assert_called_once_with(self.context,",
            "            dummyxml, instance, network_info, mock.sentinel.disk_info,",
            "            block_device_info=block_device_info,",
            "            reboot=True, vifs_already_plugged=True)",
            "",
            "    @mock.patch('oslo_utils.fileutils.ensure_tree')",
            "    @mock.patch('oslo_service.loopingcall.FixedIntervalLoopingCall')",
            "    @mock.patch('nova.pci.manager.get_instance_pci_devs')",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver._prepare_pci_devices_for_use')",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver._create_domain_and_network')",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver._create_images_and_backing')",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver._get_instance_disk_info')",
            "    @mock.patch('nova.virt.libvirt.utils.write_to_file')",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path')",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver._get_guest_config')",
            "    @mock.patch('nova.virt.libvirt.blockinfo.get_disk_info')",
            "    @mock.patch('nova.virt.libvirt.LibvirtDriver._destroy')",
            "    def test_hard_reboot_does_not_call_glance_show(self,",
            "            mock_destroy, mock_get_disk_info, mock_get_guest_config,",
            "            mock_get_instance_path, mock_write_to_file,",
            "            mock_get_instance_disk_info, mock_create_images_and_backing,",
            "            mock_create_domand_and_network, mock_prepare_pci_devices_for_use,",
            "            mock_get_instance_pci_devs, mock_looping_call, mock_ensure_tree):",
            "        \"\"\"For a hard reboot, we shouldn't need an additional call to glance",
            "        to get the image metadata.",
            "",
            "        This is important for automatically spinning up instances on a",
            "        host-reboot, since we won't have a user request context that'll allow",
            "        the Glance request to go through. We have to rely on the cached image",
            "        metadata, instead.",
            "",
            "        https://bugs.launchpad.net/nova/+bug/1339386",
            "        \"\"\"",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        network_info = mock.MagicMock()",
            "        block_device_info = mock.MagicMock()",
            "        mock_get_disk_info.return_value = {}",
            "        mock_get_guest_config.return_value = mock.MagicMock()",
            "        mock_get_instance_path.return_value = '/foo'",
            "        mock_looping_call.return_value = mock.MagicMock()",
            "        drvr._image_api = mock.MagicMock()",
            "",
            "        drvr._hard_reboot(self.context, instance, network_info,",
            "                          block_device_info)",
            "",
            "        self.assertFalse(drvr._image_api.get.called)",
            "        mock_ensure_tree.assert_called_once_with('/foo')",
            "",
            "    def test_suspend(self):",
            "        guest = libvirt_guest.Guest(FakeVirtDomain(id=1))",
            "        dom = guest._domain",
            "",
            "        instance = objects.Instance(**self.test_instance)",
            "        instance.ephemeral_key_uuid = None",
            "",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        @mock.patch.object(dmcrypt, 'delete_volume')",
            "        @mock.patch.object(conn, '_get_instance_disk_info', return_value=[])",
            "        @mock.patch.object(conn, '_detach_sriov_ports')",
            "        @mock.patch.object(conn, '_detach_pci_devices')",
            "        @mock.patch.object(pci_manager, 'get_instance_pci_devs',",
            "                           return_value='pci devs')",
            "        @mock.patch.object(conn._host, 'get_guest', return_value=guest)",
            "        def suspend(mock_get_guest, mock_get_instance_pci_devs,",
            "                    mock_detach_pci_devices, mock_detach_sriov_ports,",
            "                    mock_get_instance_disk_info, mock_delete_volume):",
            "            mock_managedSave = mock.Mock()",
            "            dom.managedSave = mock_managedSave",
            "",
            "            conn.suspend(self.context, instance)",
            "",
            "            mock_managedSave.assert_called_once_with(0)",
            "            self.assertFalse(mock_get_instance_disk_info.called)",
            "            mock_delete_volume.assert_has_calls([mock.call(disk['path'])",
            "                for disk in mock_get_instance_disk_info.return_value], False)",
            "",
            "        suspend()",
            "",
            "    @mock.patch.object(time, 'sleep')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_create_domain')",
            "    @mock.patch.object(host.Host, 'get_domain')",
            "    def _test_clean_shutdown(self, mock_get_domain, mock_create_domain,",
            "                             mock_sleep, seconds_to_shutdown,",
            "                             timeout, retry_interval,",
            "                             shutdown_attempts, succeeds):",
            "        info_tuple = ('fake', 'fake', 'fake', 'also_fake')",
            "        shutdown_count = []",
            "",
            "        # Mock domain",
            "        mock_domain = mock.Mock(fakelibvirt.virDomain)",
            "        return_infos = [(libvirt_guest.VIR_DOMAIN_RUNNING,) + info_tuple]",
            "        return_shutdowns = [shutdown_count.append(\"shutdown\")]",
            "        retry_countdown = retry_interval",
            "        for x in range(min(seconds_to_shutdown, timeout)):",
            "            return_infos.append(",
            "                (libvirt_guest.VIR_DOMAIN_RUNNING,) + info_tuple)",
            "            if retry_countdown == 0:",
            "                return_shutdowns.append(shutdown_count.append(\"shutdown\"))",
            "                retry_countdown = retry_interval",
            "            else:",
            "                retry_countdown -= 1",
            "",
            "        if seconds_to_shutdown < timeout:",
            "            return_infos.append(",
            "                (libvirt_guest.VIR_DOMAIN_SHUTDOWN,) + info_tuple)",
            "",
            "        mock_domain.info.side_effect = return_infos",
            "        mock_domain.shutdown.side_effect = return_shutdowns",
            "",
            "        def fake_create_domain(**kwargs):",
            "            self.reboot_create_called = True",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_get_domain.return_value = mock_domain",
            "        mock_create_domain.side_effect = fake_create_domain",
            "        result = drvr._clean_shutdown(instance, timeout, retry_interval)",
            "",
            "        self.assertEqual(succeeds, result)",
            "        self.assertEqual(shutdown_attempts, len(shutdown_count))",
            "",
            "    def test_clean_shutdown_first_time(self):",
            "        self._test_clean_shutdown(seconds_to_shutdown=2,",
            "                                  timeout=5,",
            "                                  retry_interval=3,",
            "                                  shutdown_attempts=1,",
            "                                  succeeds=True)",
            "",
            "    def test_clean_shutdown_with_retry(self):",
            "        self._test_clean_shutdown(seconds_to_shutdown=4,",
            "                                  timeout=5,",
            "                                  retry_interval=3,",
            "                                  shutdown_attempts=2,",
            "                                  succeeds=True)",
            "",
            "    def test_clean_shutdown_failure(self):",
            "        self._test_clean_shutdown(seconds_to_shutdown=6,",
            "                                  timeout=5,",
            "                                  retry_interval=3,",
            "                                  shutdown_attempts=2,",
            "                                  succeeds=False)",
            "",
            "    def test_clean_shutdown_no_wait(self):",
            "        self._test_clean_shutdown(seconds_to_shutdown=6,",
            "                                  timeout=0,",
            "                                  retry_interval=3,",
            "                                  shutdown_attempts=1,",
            "                                  succeeds=False)",
            "",
            "    @mock.patch.object(FakeVirtDomain, 'attachDeviceFlags')",
            "    @mock.patch.object(FakeVirtDomain, 'ID', return_value=1)",
            "    @mock.patch.object(utils, 'get_image_from_system_metadata',",
            "                       return_value=None)",
            "    def test_attach_sriov_ports(self,",
            "                                mock_get_image_metadata,",
            "                                mock_ID,",
            "                                mock_attachDevice):",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        network_info = _fake_network_info(self, 1)",
            "        network_info[0]['vnic_type'] = network_model.VNIC_TYPE_DIRECT",
            "        guest = libvirt_guest.Guest(FakeVirtDomain())",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        drvr._attach_sriov_ports(self.context, instance, guest, network_info)",
            "        mock_get_image_metadata.assert_called_once_with(",
            "            instance.system_metadata)",
            "        self.assertTrue(mock_attachDevice.called)",
            "",
            "    @mock.patch.object(FakeVirtDomain, 'attachDeviceFlags')",
            "    @mock.patch.object(FakeVirtDomain, 'ID', return_value=1)",
            "    @mock.patch.object(utils, 'get_image_from_system_metadata',",
            "                       return_value=None)",
            "    def test_attach_sriov_ports_with_info_cache(self,",
            "                                                mock_get_image_metadata,",
            "                                                mock_ID,",
            "                                                mock_attachDevice):",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        network_info = _fake_network_info(self, 1)",
            "        network_info[0]['vnic_type'] = network_model.VNIC_TYPE_DIRECT",
            "        instance.info_cache = objects.InstanceInfoCache(",
            "            network_info=network_info)",
            "        guest = libvirt_guest.Guest(FakeVirtDomain())",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        drvr._attach_sriov_ports(self.context, instance, guest, None)",
            "        mock_get_image_metadata.assert_called_once_with(",
            "            instance.system_metadata)",
            "        self.assertTrue(mock_attachDevice.called)",
            "",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    @mock.patch.object(FakeVirtDomain, 'detachDeviceFlags')",
            "    @mock.patch.object(utils, 'get_image_from_system_metadata',",
            "                       return_value=None)",
            "    def test_detach_sriov_ports(self,",
            "                                mock_get_image_metadata,",
            "                                mock_detachDeviceFlags,",
            "                                mock_has_min_version):",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        network_info = _fake_network_info(self, 1)",
            "        network_info[0]['vnic_type'] = network_model.VNIC_TYPE_DIRECT",
            "        # some more adjustments for the fake network_info so that",
            "        # the correct get_config function will be executed (vif's",
            "        # get_config_hw_veb - which is according to the real SRIOV vif)",
            "        # and most importantly the pci_slot which is translated to",
            "        # cfg.source_dev, then to PciDevice.address and sent to",
            "        # _detach_pci_devices",
            "        network_info[0]['profile'] = dict(pci_slot=\"0000:00:00.0\")",
            "        network_info[0]['type'] = \"hw_veb\"",
            "        network_info[0]['details'] = dict(vlan=\"2145\")",
            "        instance.info_cache = objects.InstanceInfoCache(",
            "            network_info=network_info)",
            "        # fill the pci_devices of the instance so that",
            "        # pci_manager.get_instance_pci_devs will not return an empty list",
            "        # which will eventually fail the assertion for detachDeviceFlags",
            "        instance.pci_devices = objects.PciDeviceList()",
            "        instance.pci_devices.objects = [",
            "            objects.PciDevice(address='0000:00:00.0', request_id=None)",
            "        ]",
            "",
            "        domain = FakeVirtDomain()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        guest = libvirt_guest.Guest(domain)",
            "",
            "        drvr._detach_sriov_ports(self.context, instance, guest)",
            "        mock_get_image_metadata.assert_called_once_with(",
            "            instance.system_metadata)",
            "        self.assertTrue(mock_detachDeviceFlags.called)",
            "",
            "    @mock.patch.object(host.Host, 'has_min_version', return_value=True)",
            "    @mock.patch.object(FakeVirtDomain, 'detachDeviceFlags')",
            "    def test_detach_duplicate_mac_sriov_ports(self,",
            "                                              mock_detachDeviceFlags,",
            "                                              mock_has_min_version):",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        network_info = _fake_network_info(self, 2)",
            "",
            "        for network_info_inst in network_info:",
            "            network_info_inst['vnic_type'] = network_model.VNIC_TYPE_DIRECT",
            "            network_info_inst['type'] = \"hw_veb\"",
            "            network_info_inst['details'] = dict(vlan=\"2145\")",
            "            network_info_inst['address'] = \"fa:16:3e:96:2a:48\"",
            "",
            "        network_info[0]['profile'] = dict(pci_slot=\"0000:00:00.0\")",
            "        network_info[1]['profile'] = dict(pci_slot=\"0000:00:00.1\")",
            "",
            "        instance.info_cache = objects.InstanceInfoCache(",
            "            network_info=network_info)",
            "        # fill the pci_devices of the instance so that",
            "        # pci_manager.get_instance_pci_devs will not return an empty list",
            "        # which will eventually fail the assertion for detachDeviceFlags",
            "        instance.pci_devices = objects.PciDeviceList()",
            "        instance.pci_devices.objects = [",
            "            objects.PciDevice(address='0000:00:00.0', request_id=None),",
            "            objects.PciDevice(address='0000:00:00.1', request_id=None)",
            "        ]",
            "",
            "        domain = FakeVirtDomain()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        guest = libvirt_guest.Guest(domain)",
            "",
            "        drvr._detach_sriov_ports(self.context, instance, guest)",
            "",
            "        expected_xml = [",
            "            ('<hostdev mode=\"subsystem\" type=\"pci\" managed=\"yes\">\\n'",
            "             '  <source>\\n'",
            "             '    <address bus=\"0x00\" domain=\"0x0000\" \\",
            "                   function=\"0x0\" slot=\"0x00\"/>\\n'",
            "             '  </source>\\n'",
            "             '</hostdev>\\n'),",
            "            ('<hostdev mode=\"subsystem\" type=\"pci\" managed=\"yes\">\\n'",
            "             '  <source>\\n'",
            "             '    <address bus=\"0x00\" domain=\"0x0000\" \\",
            "                   function=\"0x1\" slot=\"0x00\"/>\\n'",
            "             '  </source>\\n'",
            "             '</hostdev>\\n')",
            "        ]",
            "",
            "        mock_detachDeviceFlags.has_calls([",
            "            mock.call(expected_xml[0], flags=1),",
            "            mock.call(expected_xml[1], flags=1)",
            "        ])",
            "",
            "    def test_resume(self):",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices>\"",
            "                    \"<disk type='file'><driver name='qemu' type='raw'/>\"",
            "                    \"<source file='/test/disk'/>\"",
            "                    \"<target dev='vda' bus='virtio'/></disk>\"",
            "                    \"<disk type='file'><driver name='qemu' type='qcow2'/>\"",
            "                    \"<source file='/test/disk.local'/>\"",
            "                    \"<target dev='vdb' bus='virtio'/></disk>\"",
            "                    \"</devices></domain>\")",
            "        instance = objects.Instance(**self.test_instance)",
            "        network_info = _fake_network_info(self, 1)",
            "        block_device_info = None",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        guest = libvirt_guest.Guest('fake_dom')",
            "        with test.nested(",
            "            mock.patch.object(drvr, '_get_existing_domain_xml',",
            "                              return_value=dummyxml),",
            "            mock.patch.object(drvr, '_create_domain_and_network',",
            "                              return_value=guest),",
            "            mock.patch.object(drvr, '_attach_pci_devices'),",
            "            mock.patch.object(pci_manager, 'get_instance_pci_devs',",
            "                              return_value='fake_pci_devs'),",
            "            mock.patch.object(utils, 'get_image_from_system_metadata'),",
            "            mock.patch.object(blockinfo, 'get_disk_info'),",
            "        ) as (_get_existing_domain_xml, _create_domain_and_network,",
            "              _attach_pci_devices, get_instance_pci_devs, get_image_metadata,",
            "              get_disk_info):",
            "            get_image_metadata.return_value = {'bar': 234}",
            "",
            "            disk_info = {'foo': 123}",
            "            get_disk_info.return_value = disk_info",
            "",
            "            drvr.resume(self.context, instance, network_info,",
            "                        block_device_info)",
            "            _get_existing_domain_xml.assert_has_calls([mock.call(instance,",
            "                                            network_info, block_device_info)])",
            "            _create_domain_and_network.assert_has_calls([mock.call(",
            "                                        self.context, dummyxml,",
            "                                        instance, network_info, disk_info,",
            "                                        block_device_info=block_device_info,",
            "                                        vifs_already_plugged=True)])",
            "            _attach_pci_devices.assert_has_calls([mock.call(guest,",
            "                                                 'fake_pci_devs')])",
            "",
            "    @mock.patch.object(host.Host, 'get_domain')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, 'get_info')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, 'delete_instance_files')",
            "    @mock.patch.object(objects.Instance, 'save')",
            "    def test_destroy_undefines(self, mock_save, mock_delete_instance_files,",
            "                               mock_get_info, mock_get_domain):",
            "        dom_mock = mock.MagicMock()",
            "        dom_mock.undefineFlags.return_value = 1",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        mock_get_domain.return_value = dom_mock",
            "        mock_get_info.return_value = hardware.InstanceInfo(",
            "            state=power_state.SHUTDOWN, id=-1)",
            "        mock_delete_instance_files.return_value = None",
            "",
            "        instance = objects.Instance(self.context, **self.test_instance)",
            "        drvr.destroy(self.context, instance, [])",
            "        mock_save.assert_called_once_with()",
            "",
            "    @mock.patch.object(rbd_utils, 'RBDDriver')",
            "    def test_cleanup_rbd(self, mock_driver):",
            "        driver = mock_driver.return_value",
            "        driver.cleanup_volumes = mock.Mock()",
            "        fake_instance = {'uuid': '875a8070-d0b9-4949-8b31-104d125c9a64'}",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        drvr._cleanup_rbd(fake_instance)",
            "",
            "        driver.cleanup_volumes.assert_called_once_with(fake_instance)",
            "",
            "    @mock.patch.object(objects.Instance, 'save')",
            "    def test_destroy_undefines_no_undefine_flags(self, mock_save):",
            "        mock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        mock.ID()",
            "        mock.destroy()",
            "        mock.undefineFlags(1).AndRaise(fakelibvirt.libvirtError('Err'))",
            "        mock.ID().AndReturn(123)",
            "        mock.undefine()",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        def fake_get_domain(instance):",
            "            return mock",
            "",
            "        def fake_get_info(instance_name):",
            "            return hardware.InstanceInfo(state=power_state.SHUTDOWN, id=-1)",
            "",
            "        def fake_delete_instance_files(instance):",
            "            return None",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr._host, 'get_domain', fake_get_domain)",
            "        self.stubs.Set(drvr, 'get_info', fake_get_info)",
            "        self.stubs.Set(drvr, 'delete_instance_files',",
            "                       fake_delete_instance_files)",
            "        instance = objects.Instance(self.context, **self.test_instance)",
            "        drvr.destroy(self.context, instance, [])",
            "        mock_save.assert_called_once_with()",
            "",
            "    @mock.patch.object(objects.Instance, 'save')",
            "    def test_destroy_undefines_no_attribute_with_managed_save(self, mock_save):",
            "        mock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        mock.ID()",
            "        mock.destroy()",
            "        mock.undefineFlags(1).AndRaise(AttributeError())",
            "        mock.hasManagedSaveImage(0).AndReturn(True)",
            "        mock.managedSaveRemove(0)",
            "        mock.undefine()",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        def fake_get_domain(instance):",
            "            return mock",
            "",
            "        def fake_get_info(instance_name):",
            "            return hardware.InstanceInfo(state=power_state.SHUTDOWN, id=-1)",
            "",
            "        def fake_delete_instance_files(instance):",
            "            return None",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr._host, 'get_domain', fake_get_domain)",
            "        self.stubs.Set(drvr, 'get_info', fake_get_info)",
            "        self.stubs.Set(drvr, 'delete_instance_files',",
            "                       fake_delete_instance_files)",
            "        instance = objects.Instance(self.context, **self.test_instance)",
            "        drvr.destroy(self.context, instance, [])",
            "        mock_save.assert_called_once_with()",
            "",
            "    @mock.patch.object(objects.Instance, 'save')",
            "    def test_destroy_undefines_no_attribute_no_managed_save(self, mock_save):",
            "        mock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        mock.ID()",
            "        mock.destroy()",
            "        mock.undefineFlags(1).AndRaise(AttributeError())",
            "        mock.hasManagedSaveImage(0).AndRaise(AttributeError())",
            "        mock.undefine()",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        def fake_get_domain(self, instance):",
            "            return mock",
            "",
            "        def fake_get_info(instance_name):",
            "            return hardware.InstanceInfo(state=power_state.SHUTDOWN)",
            "",
            "        def fake_delete_instance_files(instance):",
            "            return None",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(host.Host, 'get_domain', fake_get_domain)",
            "        self.stubs.Set(drvr, 'get_info', fake_get_info)",
            "        self.stubs.Set(drvr, 'delete_instance_files',",
            "                       fake_delete_instance_files)",
            "        instance = objects.Instance(self.context, **self.test_instance)",
            "        drvr.destroy(self.context, instance, [])",
            "        mock_save.assert_called_once_with()",
            "",
            "    def test_destroy_timed_out(self):",
            "        mock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        mock.ID()",
            "        mock.destroy().AndRaise(fakelibvirt.libvirtError(\"timed out\"))",
            "        self.mox.ReplayAll()",
            "",
            "        def fake_get_domain(self, instance):",
            "            return mock",
            "",
            "        def fake_get_error_code(self):",
            "            return fakelibvirt.VIR_ERR_OPERATION_TIMEOUT",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(host.Host, 'get_domain', fake_get_domain)",
            "        self.stubs.Set(fakelibvirt.libvirtError, 'get_error_code',",
            "                fake_get_error_code)",
            "        instance = objects.Instance(**self.test_instance)",
            "        self.assertRaises(exception.InstancePowerOffFailure,",
            "                drvr.destroy, self.context, instance, [])",
            "",
            "    def test_private_destroy_not_found(self):",
            "        ex = fakelibvirt.make_libvirtError(",
            "                fakelibvirt.libvirtError,",
            "                \"No such domain\",",
            "                error_code=fakelibvirt.VIR_ERR_NO_DOMAIN)",
            "        mock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        mock.ID()",
            "        mock.destroy().AndRaise(ex)",
            "        mock.info().AndRaise(ex)",
            "        mock.UUIDString()",
            "        self.mox.ReplayAll()",
            "",
            "        def fake_get_domain(instance):",
            "            return mock",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr._host, 'get_domain', fake_get_domain)",
            "        instance = objects.Instance(**self.test_instance)",
            "        # NOTE(vish): verifies destroy doesn't raise if the instance disappears",
            "        drvr._destroy(instance)",
            "",
            "    def test_private_destroy_lxc_processes_refused_to_die(self):",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "        ex = fakelibvirt.make_libvirtError(",
            "                fakelibvirt.libvirtError, \"\",",
            "                error_message=\"internal error: Some processes refused to die\",",
            "                error_code=fakelibvirt.VIR_ERR_INTERNAL_ERROR)",
            "",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        with mock.patch.object(conn._host, 'get_domain') as mock_get_domain, \\",
            "             mock.patch.object(conn, 'get_info') as mock_get_info:",
            "            mock_domain = mock.MagicMock()",
            "            mock_domain.ID.return_value = 1",
            "            mock_get_domain.return_value = mock_domain",
            "            mock_domain.destroy.side_effect = ex",
            "",
            "            mock_info = mock.MagicMock()",
            "            mock_info.id = 1",
            "            mock_info.state = power_state.SHUTDOWN",
            "            mock_get_info.return_value = mock_info",
            "",
            "            instance = objects.Instance(**self.test_instance)",
            "            conn._destroy(instance)",
            "",
            "    def test_private_destroy_processes_refused_to_die_still_raises(self):",
            "        ex = fakelibvirt.make_libvirtError(",
            "                fakelibvirt.libvirtError, \"\",",
            "                error_message=\"internal error: Some processes refused to die\",",
            "                error_code=fakelibvirt.VIR_ERR_INTERNAL_ERROR)",
            "",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        with mock.patch.object(conn._host, 'get_domain') as mock_get_domain:",
            "            mock_domain = mock.MagicMock()",
            "            mock_domain.ID.return_value = 1",
            "            mock_get_domain.return_value = mock_domain",
            "            mock_domain.destroy.side_effect = ex",
            "",
            "            instance = objects.Instance(**self.test_instance)",
            "            self.assertRaises(fakelibvirt.libvirtError, conn._destroy,",
            "                              instance)",
            "",
            "    def test_private_destroy_ebusy_timeout(self):",
            "        # Tests that _destroy will retry 3 times to destroy the guest when an",
            "        # EBUSY is raised, but eventually times out and raises the libvirtError",
            "        ex = fakelibvirt.make_libvirtError(",
            "                fakelibvirt.libvirtError,",
            "                (\"Failed to terminate process 26425 with SIGKILL: \"",
            "                 \"Device or resource busy\"),",
            "                error_code=fakelibvirt.VIR_ERR_SYSTEM_ERROR,",
            "                int1=errno.EBUSY)",
            "",
            "        mock_guest = mock.Mock(libvirt_guest.Guest, id=1)",
            "        mock_guest.poweroff = mock.Mock(side_effect=ex)",
            "",
            "        instance = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        with mock.patch.object(drvr._host, 'get_guest',",
            "                               return_value=mock_guest):",
            "            self.assertRaises(fakelibvirt.libvirtError, drvr._destroy,",
            "                              instance)",
            "",
            "        self.assertEqual(3, mock_guest.poweroff.call_count)",
            "",
            "    def test_private_destroy_ebusy_multiple_attempt_ok(self):",
            "        # Tests that the _destroy attempt loop is broken when EBUSY is no",
            "        # longer raised.",
            "        ex = fakelibvirt.make_libvirtError(",
            "                fakelibvirt.libvirtError,",
            "                (\"Failed to terminate process 26425 with SIGKILL: \"",
            "                 \"Device or resource busy\"),",
            "                error_code=fakelibvirt.VIR_ERR_SYSTEM_ERROR,",
            "                int1=errno.EBUSY)",
            "",
            "        mock_guest = mock.Mock(libvirt_guest.Guest, id=1)",
            "        mock_guest.poweroff = mock.Mock(side_effect=[ex, None])",
            "",
            "        inst_info = hardware.InstanceInfo(power_state.SHUTDOWN, id=1)",
            "        instance = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        with mock.patch.object(drvr._host, 'get_guest',",
            "                               return_value=mock_guest):",
            "            with mock.patch.object(drvr, 'get_info', return_value=inst_info):",
            "                drvr._destroy(instance)",
            "",
            "        self.assertEqual(2, mock_guest.poweroff.call_count)",
            "",
            "    def test_undefine_domain_with_not_found_instance(self):",
            "        def fake_get_domain(self, instance):",
            "            raise exception.InstanceNotFound(instance_id=instance.uuid)",
            "",
            "        self.stubs.Set(host.Host, 'get_domain', fake_get_domain)",
            "        self.mox.StubOutWithMock(fakelibvirt.libvirtError, \"get_error_code\")",
            "",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        # NOTE(wenjianhn): verifies undefine doesn't raise if the",
            "        # instance disappears",
            "        drvr._undefine_domain(instance)",
            "",
            "    @mock.patch.object(host.Host, \"list_instance_domains\")",
            "    @mock.patch.object(objects.BlockDeviceMappingList, \"bdms_by_instance_uuid\")",
            "    @mock.patch.object(objects.InstanceList, \"get_by_filters\")",
            "    def test_disk_over_committed_size_total(self, mock_get, mock_bdms,",
            "                                            mock_list):",
            "        # Ensure destroy calls managedSaveRemove for saved instance.",
            "        class DiagFakeDomain(object):",
            "            def __init__(self, name):",
            "                self._name = name",
            "                self._uuid = str(uuid.uuid4())",
            "",
            "            def ID(self):",
            "                return 1",
            "",
            "            def name(self):",
            "                return self._name",
            "",
            "            def UUIDString(self):",
            "                return self._uuid",
            "",
            "            def XMLDesc(self, flags):",
            "                return \"<domain/>\"",
            "",
            "        instance_domains = [",
            "            DiagFakeDomain(\"instance0000001\"),",
            "            DiagFakeDomain(\"instance0000002\")]",
            "        mock_list.return_value = instance_domains",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        fake_disks = {'instance0000001':",
            "                      [{'type': 'qcow2', 'path': '/somepath/disk1',",
            "                        'virt_disk_size': '10737418240',",
            "                        'backing_file': '/somepath/disk1',",
            "                        'disk_size': '83886080',",
            "                        'over_committed_disk_size': '10653532160'}],",
            "                      'instance0000002':",
            "                      [{'type': 'raw', 'path': '/somepath/disk2',",
            "                        'virt_disk_size': '0',",
            "                        'backing_file': '/somepath/disk2',",
            "                        'disk_size': '10737418240',",
            "                        'over_committed_disk_size': '0'}]}",
            "",
            "        def get_info(instance_name, xml, **kwargs):",
            "            return fake_disks.get(instance_name)",
            "",
            "        instance_uuids = [dom.UUIDString() for dom in instance_domains]",
            "        instances = [objects.Instance(",
            "            uuid=instance_uuids[0],",
            "            root_device_name='/dev/vda'),",
            "            objects.Instance(",
            "            uuid=instance_uuids[1],",
            "            root_device_name='/dev/vdb')",
            "        ]",
            "        mock_get.return_value = instances",
            "",
            "        with mock.patch.object(drvr,",
            "                               \"_get_instance_disk_info\") as mock_info:",
            "            mock_info.side_effect = get_info",
            "",
            "            result = drvr._get_disk_over_committed_size_total()",
            "            self.assertEqual(result, 10653532160)",
            "            mock_list.assert_called_once_with()",
            "            self.assertEqual(2, mock_info.call_count)",
            "",
            "        filters = {'uuid': instance_uuids}",
            "        mock_get.assert_called_once_with(mock.ANY, filters, use_slave=True)",
            "        mock_bdms.assert_called_with(mock.ANY, instance_uuids)",
            "",
            "    @mock.patch.object(host.Host, \"list_instance_domains\")",
            "    @mock.patch.object(objects.BlockDeviceMappingList, \"bdms_by_instance_uuid\")",
            "    @mock.patch.object(objects.InstanceList, \"get_by_filters\")",
            "    def test_disk_over_committed_size_total_eperm(self, mock_get, mock_bdms,",
            "                                                  mock_list):",
            "        # Ensure destroy calls managedSaveRemove for saved instance.",
            "        class DiagFakeDomain(object):",
            "            def __init__(self, name):",
            "                self._name = name",
            "                self._uuid = str(uuid.uuid4())",
            "",
            "            def ID(self):",
            "                return 1",
            "",
            "            def name(self):",
            "                return self._name",
            "",
            "            def UUIDString(self):",
            "                return self._uuid",
            "",
            "            def XMLDesc(self, flags):",
            "                return \"<domain/>\"",
            "",
            "        instance_domains = [",
            "            DiagFakeDomain(\"instance0000001\"),",
            "            DiagFakeDomain(\"instance0000002\")]",
            "        mock_list.return_value = instance_domains",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        fake_disks = {'instance0000001':",
            "                      [{'type': 'qcow2', 'path': '/somepath/disk1',",
            "                        'virt_disk_size': '10737418240',",
            "                        'backing_file': '/somepath/disk1',",
            "                        'disk_size': '83886080',",
            "                        'over_committed_disk_size': '10653532160'}],",
            "                      'instance0000002':",
            "                      [{'type': 'raw', 'path': '/somepath/disk2',",
            "                        'virt_disk_size': '0',",
            "                        'backing_file': '/somepath/disk2',",
            "                        'disk_size': '10737418240',",
            "                        'over_committed_disk_size': '21474836480'}]}",
            "",
            "        def side_effect(name, dom, block_device_info):",
            "            if name == 'instance0000001':",
            "                self.assertEqual('/dev/vda',",
            "                                 block_device_info['root_device_name'])",
            "                raise OSError(errno.EACCES, 'Permission denied')",
            "            if name == 'instance0000002':",
            "                self.assertEqual('/dev/vdb',",
            "                                 block_device_info['root_device_name'])",
            "                return fake_disks.get(name)",
            "        get_disk_info = mock.Mock()",
            "        get_disk_info.side_effect = side_effect",
            "        drvr._get_instance_disk_info = get_disk_info",
            "",
            "        instance_uuids = [dom.UUIDString() for dom in instance_domains]",
            "        instances = [objects.Instance(",
            "            uuid=instance_uuids[0],",
            "            root_device_name='/dev/vda'),",
            "            objects.Instance(",
            "            uuid=instance_uuids[1],",
            "            root_device_name='/dev/vdb')",
            "        ]",
            "        mock_get.return_value = instances",
            "",
            "        result = drvr._get_disk_over_committed_size_total()",
            "        self.assertEqual(21474836480, result)",
            "        mock_list.assert_called_once_with()",
            "        self.assertEqual(2, get_disk_info.call_count)",
            "        filters = {'uuid': instance_uuids}",
            "        mock_get.assert_called_once_with(mock.ANY, filters, use_slave=True)",
            "        mock_bdms.assert_called_with(mock.ANY, instance_uuids)",
            "",
            "    @mock.patch.object(host.Host, \"list_instance_domains\",",
            "                       return_value=[mock.MagicMock(name='foo')])",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, \"_get_instance_disk_info\",",
            "                       side_effect=exception.VolumeBDMPathNotFound(path='bar'))",
            "    @mock.patch.object(objects.BlockDeviceMappingList, \"bdms_by_instance_uuid\")",
            "    @mock.patch.object(objects.InstanceList, \"get_by_filters\")",
            "    def test_disk_over_committed_size_total_bdm_not_found(self,",
            "                                                          mock_get,",
            "                                                          mock_bdms,",
            "                                                          mock_get_disk_info,",
            "                                                          mock_list_domains):",
            "        # Tests that we handle VolumeBDMPathNotFound gracefully.",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertEqual(0, drvr._get_disk_over_committed_size_total())",
            "",
            "    def test_cpu_info(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        def get_host_capabilities_stub(self):",
            "            cpu = vconfig.LibvirtConfigCPU()",
            "            cpu.model = \"Opteron_G4\"",
            "            cpu.vendor = \"AMD\"",
            "            cpu.arch = arch.X86_64",
            "",
            "            cpu.cells = 1",
            "            cpu.cores = 2",
            "            cpu.threads = 1",
            "            cpu.sockets = 4",
            "",
            "            cpu.add_feature(vconfig.LibvirtConfigCPUFeature(\"extapic\"))",
            "            cpu.add_feature(vconfig.LibvirtConfigCPUFeature(\"3dnow\"))",
            "",
            "            caps = vconfig.LibvirtConfigCaps()",
            "            caps.host = vconfig.LibvirtConfigCapsHost()",
            "            caps.host.cpu = cpu",
            "",
            "            guest = vconfig.LibvirtConfigGuest()",
            "            guest.ostype = vm_mode.HVM",
            "            guest.arch = arch.X86_64",
            "            guest.domtype = [\"kvm\"]",
            "            caps.guests.append(guest)",
            "",
            "            guest = vconfig.LibvirtConfigGuest()",
            "            guest.ostype = vm_mode.HVM",
            "            guest.arch = arch.I686",
            "            guest.domtype = [\"kvm\"]",
            "            caps.guests.append(guest)",
            "",
            "            return caps",
            "",
            "        self.stubs.Set(host.Host, \"get_capabilities\",",
            "                       get_host_capabilities_stub)",
            "",
            "        want = {\"vendor\": \"AMD\",",
            "                \"features\": set([\"extapic\", \"3dnow\"]),",
            "                \"model\": \"Opteron_G4\",",
            "                \"arch\": arch.X86_64,",
            "                \"topology\": {\"cells\": 1, \"cores\": 2, \"threads\": 1,",
            "                             \"sockets\": 4}}",
            "        got = drvr._get_cpu_info()",
            "        self.assertEqual(want, got)",
            "",
            "    def test_get_pcidev_info(self):",
            "",
            "        def fake_nodeDeviceLookupByName(self, name):",
            "            return FakeNodeDevice(_fake_NodeDevXml[name])",
            "",
            "        self.mox.StubOutWithMock(host.Host, 'device_lookup_by_name')",
            "        host.Host.device_lookup_by_name = fake_nodeDeviceLookupByName",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        with mock.patch.object(",
            "            fakelibvirt.Connection, 'getLibVersion') as mock_lib_version:",
            "            mock_lib_version.return_value = (",
            "                versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_PF_WITH_NO_VFS_CAP_VERSION) - 1)",
            "",
            "            actualvf = drvr._get_pcidev_info(\"pci_0000_04_00_3\")",
            "            expect_vf = {",
            "                \"dev_id\": \"pci_0000_04_00_3\",",
            "                \"address\": \"0000:04:00.3\",",
            "                \"product_id\": '1521',",
            "                \"numa_node\": None,",
            "                \"vendor_id\": '8086',",
            "                \"label\": 'label_8086_1521',",
            "                \"dev_type\": fields.PciDeviceType.SRIOV_PF,",
            "                }",
            "",
            "            self.assertEqual(expect_vf, actualvf)",
            "            actualvf = drvr._get_pcidev_info(\"pci_0000_04_10_7\")",
            "            expect_vf = {",
            "                \"dev_id\": \"pci_0000_04_10_7\",",
            "                \"address\": \"0000:04:10.7\",",
            "                \"product_id\": '1520',",
            "                \"numa_node\": None,",
            "                \"vendor_id\": '8086',",
            "                \"label\": 'label_8086_1520',",
            "                \"dev_type\": fields.PciDeviceType.SRIOV_VF,",
            "                \"parent_addr\": '0000:04:00.3',",
            "                }",
            "            self.assertEqual(expect_vf, actualvf)",
            "",
            "            actualvf = drvr._get_pcidev_info(\"pci_0000_04_11_7\")",
            "            expect_vf = {",
            "                \"dev_id\": \"pci_0000_04_11_7\",",
            "                \"address\": \"0000:04:11.7\",",
            "                \"product_id\": '1520',",
            "                \"vendor_id\": '8086',",
            "                \"numa_node\": 0,",
            "                \"label\": 'label_8086_1520',",
            "                \"dev_type\": fields.PciDeviceType.SRIOV_VF,",
            "                \"parent_addr\": '0000:04:00.3',",
            "                }",
            "",
            "            self.assertEqual(expect_vf, actualvf)",
            "",
            "            with mock.patch.object(",
            "                pci_utils, 'is_physical_function', return_value=True):",
            "                actualvf = drvr._get_pcidev_info(\"pci_0000_04_00_1\")",
            "                expect_vf = {",
            "                    \"dev_id\": \"pci_0000_04_00_1\",",
            "                    \"address\": \"0000:04:00.1\",",
            "                    \"product_id\": '1013',",
            "                    \"numa_node\": 0,",
            "                    \"vendor_id\": '15b3',",
            "                    \"label\": 'label_15b3_1013',",
            "                    \"dev_type\": fields.PciDeviceType.SRIOV_PF,",
            "                    }",
            "                self.assertEqual(expect_vf, actualvf)",
            "",
            "            with mock.patch.object(",
            "                pci_utils, 'is_physical_function', return_value=False):",
            "                actualvf = drvr._get_pcidev_info(\"pci_0000_04_00_1\")",
            "                expect_vf = {",
            "                    \"dev_id\": \"pci_0000_04_00_1\",",
            "                    \"address\": \"0000:04:00.1\",",
            "                    \"product_id\": '1013',",
            "                    \"numa_node\": 0,",
            "                    \"vendor_id\": '15b3',",
            "                    \"label\": 'label_15b3_1013',",
            "                    \"dev_type\": fields.PciDeviceType.STANDARD,",
            "                    }",
            "                self.assertEqual(expect_vf, actualvf)",
            "",
            "        with mock.patch.object(",
            "            fakelibvirt.Connection, 'getLibVersion') as mock_lib_version:",
            "            mock_lib_version.return_value = (",
            "                versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_PF_WITH_NO_VFS_CAP_VERSION))",
            "            actualvf = drvr._get_pcidev_info(\"pci_0000_03_00_0\")",
            "            expect_vf = {",
            "                \"dev_id\": \"pci_0000_03_00_0\",",
            "                \"address\": \"0000:03:00.0\",",
            "                \"product_id\": '1013',",
            "                \"numa_node\": 0,",
            "                \"vendor_id\": '15b3',",
            "                \"label\": 'label_15b3_1013',",
            "                \"dev_type\": fields.PciDeviceType.SRIOV_PF,",
            "                }",
            "            self.assertEqual(expect_vf, actualvf)",
            "",
            "            actualvf = drvr._get_pcidev_info(\"pci_0000_03_00_1\")",
            "            expect_vf = {",
            "                \"dev_id\": \"pci_0000_03_00_1\",",
            "                \"address\": \"0000:03:00.1\",",
            "                \"product_id\": '1013',",
            "                \"numa_node\": 0,",
            "                \"vendor_id\": '15b3',",
            "                \"label\": 'label_15b3_1013',",
            "                \"dev_type\": fields.PciDeviceType.SRIOV_PF,",
            "                }",
            "",
            "            self.assertEqual(expect_vf, actualvf)",
            "",
            "    def test_list_devices_not_supported(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        # Handle just the NO_SUPPORT error",
            "        not_supported_exc = fakelibvirt.make_libvirtError(",
            "                fakelibvirt.libvirtError,",
            "                'this function is not supported by the connection driver:'",
            "                ' virNodeNumOfDevices',",
            "                error_code=fakelibvirt.VIR_ERR_NO_SUPPORT)",
            "",
            "        with mock.patch.object(drvr._conn, 'listDevices',",
            "                               side_effect=not_supported_exc):",
            "            self.assertEqual('[]', drvr._get_pci_passthrough_devices())",
            "",
            "        # We cache not supported status to avoid emitting too many logging",
            "        # messages. Clear this value to test the other exception case.",
            "        del drvr._list_devices_supported",
            "",
            "        # Other errors should not be caught",
            "        other_exc = fakelibvirt.make_libvirtError(",
            "            fakelibvirt.libvirtError,",
            "            'other exc',",
            "            error_code=fakelibvirt.VIR_ERR_NO_DOMAIN)",
            "",
            "        with mock.patch.object(drvr._conn, 'listDevices',",
            "                               side_effect=other_exc):",
            "            self.assertRaises(fakelibvirt.libvirtError,",
            "                              drvr._get_pci_passthrough_devices)",
            "",
            "    def test_get_pci_passthrough_devices(self):",
            "",
            "        def fakelistDevices(caps, fakeargs=0):",
            "            return ['pci_0000_04_00_3', 'pci_0000_04_10_7',",
            "                    'pci_0000_04_11_7']",
            "",
            "        self.mox.StubOutWithMock(libvirt_driver.LibvirtDriver, '_conn')",
            "",
            "        libvirt_driver.LibvirtDriver._conn.listDevices = fakelistDevices",
            "",
            "        def fake_nodeDeviceLookupByName(self, name):",
            "            return FakeNodeDevice(_fake_NodeDevXml[name])",
            "",
            "        self.mox.StubOutWithMock(host.Host, 'device_lookup_by_name')",
            "        host.Host.device_lookup_by_name = fake_nodeDeviceLookupByName",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        actjson = drvr._get_pci_passthrough_devices()",
            "",
            "        expectvfs = [",
            "            {",
            "                \"dev_id\": \"pci_0000_04_00_3\",",
            "                \"address\": \"0000:04:00.3\",",
            "                \"product_id\": '1521',",
            "                \"vendor_id\": '8086',",
            "                \"dev_type\": fields.PciDeviceType.SRIOV_PF,",
            "                \"phys_function\": None,",
            "                \"numa_node\": None},",
            "            {",
            "                \"dev_id\": \"pci_0000_04_10_7\",",
            "                \"domain\": 0,",
            "                \"address\": \"0000:04:10.7\",",
            "                \"product_id\": '1520',",
            "                \"vendor_id\": '8086',",
            "                \"numa_node\": None,",
            "                \"dev_type\": fields.PciDeviceType.SRIOV_VF,",
            "                \"phys_function\": [('0x0000', '0x04', '0x00', '0x3')]},",
            "            {",
            "                \"dev_id\": \"pci_0000_04_11_7\",",
            "                \"domain\": 0,",
            "                \"address\": \"0000:04:11.7\",",
            "                \"product_id\": '1520',",
            "                \"vendor_id\": '8086',",
            "                \"numa_node\": 0,",
            "                \"dev_type\": fields.PciDeviceType.SRIOV_VF,",
            "                \"phys_function\": [('0x0000', '0x04', '0x00', '0x3')],",
            "            }",
            "        ]",
            "",
            "        actualvfs = jsonutils.loads(actjson)",
            "        for dev in range(len(actualvfs)):",
            "            for key in actualvfs[dev].keys():",
            "                if key not in ['phys_function', 'virt_functions', 'label']:",
            "                    self.assertEqual(expectvfs[dev][key], actualvfs[dev][key])",
            "",
            "    def _fake_caps_numa_topology(self,",
            "                                 cells_per_host=4,",
            "                                 sockets_per_cell=1,",
            "                                 cores_per_socket=1,",
            "                                 threads_per_core=2,",
            "                                 kb_mem=1048576):",
            "",
            "        # Generate mempages list per cell",
            "        cell_mempages = list()",
            "        for cellid in range(cells_per_host):",
            "            mempages_0 = vconfig.LibvirtConfigCapsNUMAPages()",
            "            mempages_0.size = 4",
            "            mempages_0.total = 1024 * cellid",
            "",
            "            mempages_1 = vconfig.LibvirtConfigCapsNUMAPages()",
            "            mempages_1.size = 2048",
            "            mempages_1.total = 0 + cellid",
            "",
            "            cell_mempages.append([mempages_0, mempages_1])",
            "",
            "        topology = fakelibvirt.HostInfo._gen_numa_topology(cells_per_host,",
            "                                         sockets_per_cell,",
            "                                         cores_per_socket,",
            "                                         threads_per_core,",
            "                                         kb_mem=kb_mem,",
            "                                         numa_mempages_list=cell_mempages)",
            "",
            "        return topology",
            "",
            "    def _test_get_host_numa_topology(self, mempages):",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = arch.X86_64",
            "        caps.host.topology = self._fake_caps_numa_topology()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        expected_topo_dict = {'cells': [",
            "                                {'cpus': '0,1', 'cpu_usage': 0,",
            "                                  'mem': {'total': 256, 'used': 0},",
            "                                  'id': 0},",
            "                                {'cpus': '3', 'cpu_usage': 0,",
            "                                  'mem': {'total': 256, 'used': 0},",
            "                                  'id': 1},",
            "                                {'cpus': '', 'cpu_usage': 0,",
            "                                  'mem': {'total': 256, 'used': 0},",
            "                                  'id': 2},",
            "                                {'cpus': '', 'cpu_usage': 0,",
            "                                  'mem': {'total': 256, 'used': 0},",
            "                                  'id': 3}]}",
            "        with test.nested(",
            "                mock.patch.object(host.Host, \"get_capabilities\",",
            "                                  return_value=caps),",
            "                mock.patch.object(",
            "                    hardware, 'get_vcpu_pin_set',",
            "                    return_value=set([0, 1, 3, 4, 5])),",
            "                mock.patch.object(host.Host, 'get_online_cpus',",
            "                                  return_value=set([0, 1, 2, 3, 6])),",
            "                ):",
            "            got_topo = drvr._get_host_numa_topology()",
            "            got_topo_dict = got_topo._to_dict()",
            "            self.assertThat(",
            "                    expected_topo_dict, matchers.DictMatches(got_topo_dict))",
            "",
            "            if mempages:",
            "                # cells 0",
            "                self.assertEqual(4, got_topo.cells[0].mempages[0].size_kb)",
            "                self.assertEqual(0, got_topo.cells[0].mempages[0].total)",
            "                self.assertEqual(2048, got_topo.cells[0].mempages[1].size_kb)",
            "                self.assertEqual(0, got_topo.cells[0].mempages[1].total)",
            "                # cells 1",
            "                self.assertEqual(4, got_topo.cells[1].mempages[0].size_kb)",
            "                self.assertEqual(1024, got_topo.cells[1].mempages[0].total)",
            "                self.assertEqual(2048, got_topo.cells[1].mempages[1].size_kb)",
            "                self.assertEqual(1, got_topo.cells[1].mempages[1].total)",
            "            else:",
            "                self.assertEqual([], got_topo.cells[0].mempages)",
            "                self.assertEqual([], got_topo.cells[1].mempages)",
            "",
            "            self.assertEqual(expected_topo_dict, got_topo_dict)",
            "            self.assertEqual(set([]), got_topo.cells[0].pinned_cpus)",
            "            self.assertEqual(set([]), got_topo.cells[1].pinned_cpus)",
            "            self.assertEqual(set([]), got_topo.cells[2].pinned_cpus)",
            "            self.assertEqual(set([]), got_topo.cells[3].pinned_cpus)",
            "            self.assertEqual([set([0, 1])], got_topo.cells[0].siblings)",
            "            self.assertEqual([], got_topo.cells[1].siblings)",
            "",
            "    @mock.patch.object(host.Host, 'has_min_version', return_value=True)",
            "    def test_get_host_numa_topology(self, mock_version):",
            "        self._test_get_host_numa_topology(mempages=True)",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getType')",
            "    @mock.patch.object(fakelibvirt.Connection, 'getVersion')",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion')",
            "    def test_get_host_numa_topology_no_mempages(self, mock_lib_version,",
            "                                                mock_version, mock_type):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        mock_lib_version.return_value = versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_HUGEPAGE_VERSION) - 1",
            "        mock_version.return_value = versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_QEMU_NUMA_HUGEPAGE_VERSION)",
            "        mock_type.return_value = host.HV_DRIVER_QEMU",
            "        self._test_get_host_numa_topology(mempages=False)",
            "",
            "    def test_get_host_numa_topology_empty(self):",
            "        caps = vconfig.LibvirtConfigCaps()",
            "        caps.host = vconfig.LibvirtConfigCapsHost()",
            "        caps.host.cpu = vconfig.LibvirtConfigCPU()",
            "        caps.host.cpu.arch = arch.X86_64",
            "        caps.host.topology = None",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        with test.nested(",
            "            mock.patch.object(host.Host, 'has_min_version', return_value=True),",
            "            mock.patch.object(host.Host, \"get_capabilities\",",
            "                              return_value=caps)",
            "        ) as (has_min_version, get_caps):",
            "            self.assertIsNone(drvr._get_host_numa_topology())",
            "        self.assertEqual(2, get_caps.call_count)",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getType')",
            "    @mock.patch.object(fakelibvirt.Connection, 'getVersion')",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion')",
            "    def test_get_host_numa_topology_old_version(self, mock_lib_version,",
            "                                                mock_version, mock_type):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        mock_lib_version.return_value = versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_NUMA_VERSION) - 1",
            "        mock_version.return_value = versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_QEMU_NUMA_HUGEPAGE_VERSION)",
            "        mock_type.return_value = host.HV_DRIVER_QEMU",
            "        self.assertIsNone(drvr._get_host_numa_topology())",
            "",
            "    @mock.patch.object(fakelibvirt.Connection, 'getType')",
            "    @mock.patch.object(fakelibvirt.Connection, 'getVersion')",
            "    @mock.patch.object(fakelibvirt.Connection, 'getLibVersion')",
            "    def test_get_host_numa_topology_xen(self, mock_lib_version,",
            "                                        mock_version, mock_type):",
            "        self.flags(virt_type='xen', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        mock_lib_version.return_value = versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_LIBVIRT_NUMA_VERSION)",
            "        mock_version.return_value = versionutils.convert_version_to_int(",
            "                libvirt_driver.MIN_QEMU_NUMA_HUGEPAGE_VERSION)",
            "        mock_type.return_value = host.HV_DRIVER_XEN",
            "        self.assertIsNone(drvr._get_host_numa_topology())",
            "",
            "    def test_diagnostic_vcpus_exception(self):",
            "        xml = \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                            <target dev='vda' bus='virtio'/>",
            "                        </disk>",
            "                        <disk type='block'>",
            "                            <source dev='/path/to/dev/1'/>",
            "                            <target dev='vdb' bus='virtio'/>",
            "                        </disk>",
            "                        <interface type='network'>",
            "                            <mac address='52:54:00:a4:38:38'/>",
            "                            <source network='default'/>",
            "                            <target dev='vnet0'/>",
            "                        </interface>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\"",
            "",
            "        class DiagFakeDomain(FakeVirtDomain):",
            "",
            "            def __init__(self):",
            "                super(DiagFakeDomain, self).__init__(fake_xml=xml)",
            "",
            "            def vcpus(self):",
            "                raise fakelibvirt.libvirtError('vcpus missing')",
            "",
            "            def blockStats(self, path):",
            "                return (169, 688640, 0, 0, -1)",
            "",
            "            def interfaceStats(self, path):",
            "                return (4408, 82, 0, 0, 0, 0, 0, 0)",
            "",
            "            def memoryStats(self):",
            "                return {'actual': 220160, 'rss': 200164}",
            "",
            "            def maxMemory(self):",
            "                return 280160",
            "",
            "        def fake_get_domain(self, instance):",
            "            return DiagFakeDomain()",
            "",
            "        self.stubs.Set(host.Host, \"get_domain\", fake_get_domain)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        actual = drvr.get_diagnostics(instance)",
            "        expect = {'vda_read': 688640,",
            "                  'vda_read_req': 169,",
            "                  'vda_write': 0,",
            "                  'vda_write_req': 0,",
            "                  'vda_errors': -1,",
            "                  'vdb_read': 688640,",
            "                  'vdb_read_req': 169,",
            "                  'vdb_write': 0,",
            "                  'vdb_write_req': 0,",
            "                  'vdb_errors': -1,",
            "                  'memory': 280160,",
            "                  'memory-actual': 220160,",
            "                  'memory-rss': 200164,",
            "                  'vnet0_rx': 4408,",
            "                  'vnet0_rx_drop': 0,",
            "                  'vnet0_rx_errors': 0,",
            "                  'vnet0_rx_packets': 82,",
            "                  'vnet0_tx': 0,",
            "                  'vnet0_tx_drop': 0,",
            "                  'vnet0_tx_errors': 0,",
            "                  'vnet0_tx_packets': 0,",
            "                  }",
            "        self.assertEqual(actual, expect)",
            "",
            "        lt = datetime.datetime(2012, 11, 22, 12, 00, 00)",
            "        diags_time = datetime.datetime(2012, 11, 22, 12, 00, 10)",
            "        self.useFixture(utils_fixture.TimeFixture(diags_time))",
            "",
            "        instance.launched_at = lt",
            "        actual = drvr.get_instance_diagnostics(instance)",
            "        expected = {'config_drive': False,",
            "                    'cpu_details': [],",
            "                    'disk_details': [{'errors_count': 0,",
            "                                      'id': '',",
            "                                      'read_bytes': 688640,",
            "                                      'read_requests': 169,",
            "                                      'write_bytes': 0,",
            "                                      'write_requests': 0},",
            "                                     {'errors_count': 0,",
            "                                      'id': '',",
            "                                      'read_bytes': 688640,",
            "                                      'read_requests': 169,",
            "                                      'write_bytes': 0,",
            "                                      'write_requests': 0}],",
            "                    'driver': 'libvirt',",
            "                    'hypervisor_os': 'linux',",
            "                    'memory_details': {'maximum': 2048, 'used': 1234},",
            "                    'nic_details': [{'mac_address': '52:54:00:a4:38:38',",
            "                                     'rx_drop': 0,",
            "                                     'rx_errors': 0,",
            "                                     'rx_octets': 4408,",
            "                                     'rx_packets': 82,",
            "                                     'tx_drop': 0,",
            "                                     'tx_errors': 0,",
            "                                     'tx_octets': 0,",
            "                                     'tx_packets': 0}],",
            "                    'state': 'running',",
            "                    'uptime': 10,",
            "                    'version': '1.0'}",
            "        self.assertEqual(expected, actual.serialize())",
            "",
            "    def test_diagnostic_blockstats_exception(self):",
            "        xml = \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                            <target dev='vda' bus='virtio'/>",
            "                        </disk>",
            "                        <disk type='block'>",
            "                            <source dev='/path/to/dev/1'/>",
            "                            <target dev='vdb' bus='virtio'/>",
            "                        </disk>",
            "                        <interface type='network'>",
            "                            <mac address='52:54:00:a4:38:38'/>",
            "                            <source network='default'/>",
            "                            <target dev='vnet0'/>",
            "                        </interface>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\"",
            "",
            "        class DiagFakeDomain(FakeVirtDomain):",
            "",
            "            def __init__(self):",
            "                super(DiagFakeDomain, self).__init__(fake_xml=xml)",
            "",
            "            def vcpus(self):",
            "                return ([(0, 1, 15340000000, 0),",
            "                         (1, 1, 1640000000, 0),",
            "                         (2, 1, 3040000000, 0),",
            "                         (3, 1, 1420000000, 0)],",
            "                        [(True, False),",
            "                         (True, False),",
            "                         (True, False),",
            "                         (True, False)])",
            "",
            "            def blockStats(self, path):",
            "                raise fakelibvirt.libvirtError('blockStats missing')",
            "",
            "            def interfaceStats(self, path):",
            "                return (4408, 82, 0, 0, 0, 0, 0, 0)",
            "",
            "            def memoryStats(self):",
            "                return {'actual': 220160, 'rss': 200164}",
            "",
            "            def maxMemory(self):",
            "                return 280160",
            "",
            "        def fake_get_domain(self, instance):",
            "            return DiagFakeDomain()",
            "",
            "        self.stubs.Set(host.Host, \"get_domain\", fake_get_domain)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        actual = drvr.get_diagnostics(instance)",
            "        expect = {'cpu0_time': 15340000000,",
            "                  'cpu1_time': 1640000000,",
            "                  'cpu2_time': 3040000000,",
            "                  'cpu3_time': 1420000000,",
            "                  'memory': 280160,",
            "                  'memory-actual': 220160,",
            "                  'memory-rss': 200164,",
            "                  'vnet0_rx': 4408,",
            "                  'vnet0_rx_drop': 0,",
            "                  'vnet0_rx_errors': 0,",
            "                  'vnet0_rx_packets': 82,",
            "                  'vnet0_tx': 0,",
            "                  'vnet0_tx_drop': 0,",
            "                  'vnet0_tx_errors': 0,",
            "                  'vnet0_tx_packets': 0,",
            "                  }",
            "        self.assertEqual(actual, expect)",
            "",
            "        lt = datetime.datetime(2012, 11, 22, 12, 00, 00)",
            "        diags_time = datetime.datetime(2012, 11, 22, 12, 00, 10)",
            "        self.useFixture(utils_fixture.TimeFixture(diags_time))",
            "",
            "        instance.launched_at = lt",
            "        actual = drvr.get_instance_diagnostics(instance)",
            "        expected = {'config_drive': False,",
            "                    'cpu_details': [{'time': 15340000000},",
            "                                    {'time': 1640000000},",
            "                                    {'time': 3040000000},",
            "                                    {'time': 1420000000}],",
            "                    'disk_details': [],",
            "                    'driver': 'libvirt',",
            "                    'hypervisor_os': 'linux',",
            "                    'memory_details': {'maximum': 2048, 'used': 1234},",
            "                    'nic_details': [{'mac_address': '52:54:00:a4:38:38',",
            "                                     'rx_drop': 0,",
            "                                     'rx_errors': 0,",
            "                                     'rx_octets': 4408,",
            "                                     'rx_packets': 82,",
            "                                     'tx_drop': 0,",
            "                                     'tx_errors': 0,",
            "                                     'tx_octets': 0,",
            "                                     'tx_packets': 0}],",
            "                    'state': 'running',",
            "                    'uptime': 10,",
            "                    'version': '1.0'}",
            "        self.assertEqual(expected, actual.serialize())",
            "",
            "    def test_diagnostic_interfacestats_exception(self):",
            "        xml = \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                            <target dev='vda' bus='virtio'/>",
            "                        </disk>",
            "                        <disk type='block'>",
            "                            <source dev='/path/to/dev/1'/>",
            "                            <target dev='vdb' bus='virtio'/>",
            "                        </disk>",
            "                        <interface type='network'>",
            "                            <mac address='52:54:00:a4:38:38'/>",
            "                            <source network='default'/>",
            "                            <target dev='vnet0'/>",
            "                        </interface>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\"",
            "",
            "        class DiagFakeDomain(FakeVirtDomain):",
            "",
            "            def __init__(self):",
            "                super(DiagFakeDomain, self).__init__(fake_xml=xml)",
            "",
            "            def vcpus(self):",
            "                return ([(0, 1, 15340000000, 0),",
            "                         (1, 1, 1640000000, 0),",
            "                         (2, 1, 3040000000, 0),",
            "                         (3, 1, 1420000000, 0)],",
            "                        [(True, False),",
            "                         (True, False),",
            "                         (True, False),",
            "                         (True, False)])",
            "",
            "            def blockStats(self, path):",
            "                return (169, 688640, 0, 0, -1)",
            "",
            "            def interfaceStats(self, path):",
            "                raise fakelibvirt.libvirtError('interfaceStat missing')",
            "",
            "            def memoryStats(self):",
            "                return {'actual': 220160, 'rss': 200164}",
            "",
            "            def maxMemory(self):",
            "                return 280160",
            "",
            "        def fake_get_domain(self, instance):",
            "            return DiagFakeDomain()",
            "",
            "        self.stubs.Set(host.Host, \"get_domain\", fake_get_domain)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        actual = drvr.get_diagnostics(instance)",
            "        expect = {'cpu0_time': 15340000000,",
            "                  'cpu1_time': 1640000000,",
            "                  'cpu2_time': 3040000000,",
            "                  'cpu3_time': 1420000000,",
            "                  'vda_read': 688640,",
            "                  'vda_read_req': 169,",
            "                  'vda_write': 0,",
            "                  'vda_write_req': 0,",
            "                  'vda_errors': -1,",
            "                  'vdb_read': 688640,",
            "                  'vdb_read_req': 169,",
            "                  'vdb_write': 0,",
            "                  'vdb_write_req': 0,",
            "                  'vdb_errors': -1,",
            "                  'memory': 280160,",
            "                  'memory-actual': 220160,",
            "                  'memory-rss': 200164,",
            "                  }",
            "        self.assertEqual(actual, expect)",
            "",
            "        lt = datetime.datetime(2012, 11, 22, 12, 00, 00)",
            "        diags_time = datetime.datetime(2012, 11, 22, 12, 00, 10)",
            "        self.useFixture(utils_fixture.TimeFixture(diags_time))",
            "",
            "        instance.launched_at = lt",
            "        actual = drvr.get_instance_diagnostics(instance)",
            "        expected = {'config_drive': False,",
            "                    'cpu_details': [{'time': 15340000000},",
            "                                    {'time': 1640000000},",
            "                                    {'time': 3040000000},",
            "                                    {'time': 1420000000}],",
            "                    'disk_details': [{'errors_count': 0,",
            "                                      'id': '',",
            "                                      'read_bytes': 688640,",
            "                                      'read_requests': 169,",
            "                                      'write_bytes': 0,",
            "                                      'write_requests': 0},",
            "                                     {'errors_count': 0,",
            "                                      'id': '',",
            "                                      'read_bytes': 688640,",
            "                                      'read_requests': 169,",
            "                                      'write_bytes': 0,",
            "                                      'write_requests': 0}],",
            "                    'driver': 'libvirt',",
            "                    'hypervisor_os': 'linux',",
            "                    'memory_details': {'maximum': 2048, 'used': 1234},",
            "                    'nic_details': [],",
            "                    'state': 'running',",
            "                    'uptime': 10,",
            "                    'version': '1.0'}",
            "        self.assertEqual(expected, actual.serialize())",
            "",
            "    def test_diagnostic_memorystats_exception(self):",
            "        xml = \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                            <target dev='vda' bus='virtio'/>",
            "                        </disk>",
            "                        <disk type='block'>",
            "                            <source dev='/path/to/dev/1'/>",
            "                            <target dev='vdb' bus='virtio'/>",
            "                        </disk>",
            "                        <interface type='network'>",
            "                            <mac address='52:54:00:a4:38:38'/>",
            "                            <source network='default'/>",
            "                            <target dev='vnet0'/>",
            "                        </interface>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\"",
            "",
            "        class DiagFakeDomain(FakeVirtDomain):",
            "",
            "            def __init__(self):",
            "                super(DiagFakeDomain, self).__init__(fake_xml=xml)",
            "",
            "            def vcpus(self):",
            "                return ([(0, 1, 15340000000, 0),",
            "                         (1, 1, 1640000000, 0),",
            "                         (2, 1, 3040000000, 0),",
            "                         (3, 1, 1420000000, 0)],",
            "                        [(True, False),",
            "                         (True, False),",
            "                         (True, False),",
            "                         (True, False)])",
            "",
            "            def blockStats(self, path):",
            "                return (169, 688640, 0, 0, -1)",
            "",
            "            def interfaceStats(self, path):",
            "                return (4408, 82, 0, 0, 0, 0, 0, 0)",
            "",
            "            def memoryStats(self):",
            "                raise fakelibvirt.libvirtError('memoryStats missing')",
            "",
            "            def maxMemory(self):",
            "                return 280160",
            "",
            "        def fake_get_domain(self, instance):",
            "            return DiagFakeDomain()",
            "",
            "        self.stubs.Set(host.Host, \"get_domain\", fake_get_domain)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        actual = drvr.get_diagnostics(instance)",
            "        expect = {'cpu0_time': 15340000000,",
            "                  'cpu1_time': 1640000000,",
            "                  'cpu2_time': 3040000000,",
            "                  'cpu3_time': 1420000000,",
            "                  'vda_read': 688640,",
            "                  'vda_read_req': 169,",
            "                  'vda_write': 0,",
            "                  'vda_write_req': 0,",
            "                  'vda_errors': -1,",
            "                  'vdb_read': 688640,",
            "                  'vdb_read_req': 169,",
            "                  'vdb_write': 0,",
            "                  'vdb_write_req': 0,",
            "                  'vdb_errors': -1,",
            "                  'memory': 280160,",
            "                  'vnet0_rx': 4408,",
            "                  'vnet0_rx_drop': 0,",
            "                  'vnet0_rx_errors': 0,",
            "                  'vnet0_rx_packets': 82,",
            "                  'vnet0_tx': 0,",
            "                  'vnet0_tx_drop': 0,",
            "                  'vnet0_tx_errors': 0,",
            "                  'vnet0_tx_packets': 0,",
            "                  }",
            "        self.assertEqual(actual, expect)",
            "",
            "        lt = datetime.datetime(2012, 11, 22, 12, 00, 00)",
            "        diags_time = datetime.datetime(2012, 11, 22, 12, 00, 10)",
            "        self.useFixture(utils_fixture.TimeFixture(diags_time))",
            "",
            "        instance.launched_at = lt",
            "        actual = drvr.get_instance_diagnostics(instance)",
            "        expected = {'config_drive': False,",
            "                    'cpu_details': [{'time': 15340000000},",
            "                                    {'time': 1640000000},",
            "                                    {'time': 3040000000},",
            "                                    {'time': 1420000000}],",
            "                    'disk_details': [{'errors_count': 0,",
            "                                      'id': '',",
            "                                      'read_bytes': 688640,",
            "                                      'read_requests': 169,",
            "                                      'write_bytes': 0,",
            "                                      'write_requests': 0},",
            "                                     {'errors_count': 0,",
            "                                      'id': '',",
            "                                      'read_bytes': 688640,",
            "                                      'read_requests': 169,",
            "                                      'write_bytes': 0,",
            "                                      'write_requests': 0}],",
            "                    'driver': 'libvirt',",
            "                    'hypervisor_os': 'linux',",
            "                    'memory_details': {'maximum': 2048, 'used': 1234},",
            "                    'nic_details': [{'mac_address': '52:54:00:a4:38:38',",
            "                                     'rx_drop': 0,",
            "                                     'rx_errors': 0,",
            "                                     'rx_octets': 4408,",
            "                                     'rx_packets': 82,",
            "                                     'tx_drop': 0,",
            "                                     'tx_errors': 0,",
            "                                     'tx_octets': 0,",
            "                                     'tx_packets': 0}],",
            "                    'state': 'running',",
            "                    'uptime': 10,",
            "                    'version': '1.0'}",
            "        self.assertEqual(expected, actual.serialize())",
            "",
            "    def test_diagnostic_full(self):",
            "        xml = \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                            <target dev='vda' bus='virtio'/>",
            "                        </disk>",
            "                        <disk type='block'>",
            "                            <source dev='/path/to/dev/1'/>",
            "                            <target dev='vdb' bus='virtio'/>",
            "                        </disk>",
            "                        <interface type='network'>",
            "                            <mac address='52:54:00:a4:38:38'/>",
            "                            <source network='default'/>",
            "                            <target dev='vnet0'/>",
            "                        </interface>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\"",
            "",
            "        class DiagFakeDomain(FakeVirtDomain):",
            "",
            "            def __init__(self):",
            "                super(DiagFakeDomain, self).__init__(fake_xml=xml)",
            "",
            "            def vcpus(self):",
            "                return ([(0, 1, 15340000000, 0),",
            "                         (1, 1, 1640000000, 0),",
            "                         (2, 1, 3040000000, 0),",
            "                         (3, 1, 1420000000, 0)],",
            "                        [(True, False),",
            "                         (True, False),",
            "                         (True, False),",
            "                         (True, False)])",
            "",
            "            def blockStats(self, path):",
            "                return (169, 688640, 0, 0, -1)",
            "",
            "            def interfaceStats(self, path):",
            "                return (4408, 82, 0, 0, 0, 0, 0, 0)",
            "",
            "            def memoryStats(self):",
            "                return {'actual': 220160, 'rss': 200164}",
            "",
            "            def maxMemory(self):",
            "                return 280160",
            "",
            "        def fake_get_domain(self, instance):",
            "            return DiagFakeDomain()",
            "",
            "        self.stubs.Set(host.Host, \"get_domain\", fake_get_domain)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        actual = drvr.get_diagnostics(instance)",
            "        expect = {'cpu0_time': 15340000000,",
            "                  'cpu1_time': 1640000000,",
            "                  'cpu2_time': 3040000000,",
            "                  'cpu3_time': 1420000000,",
            "                  'vda_read': 688640,",
            "                  'vda_read_req': 169,",
            "                  'vda_write': 0,",
            "                  'vda_write_req': 0,",
            "                  'vda_errors': -1,",
            "                  'vdb_read': 688640,",
            "                  'vdb_read_req': 169,",
            "                  'vdb_write': 0,",
            "                  'vdb_write_req': 0,",
            "                  'vdb_errors': -1,",
            "                  'memory': 280160,",
            "                  'memory-actual': 220160,",
            "                  'memory-rss': 200164,",
            "                  'vnet0_rx': 4408,",
            "                  'vnet0_rx_drop': 0,",
            "                  'vnet0_rx_errors': 0,",
            "                  'vnet0_rx_packets': 82,",
            "                  'vnet0_tx': 0,",
            "                  'vnet0_tx_drop': 0,",
            "                  'vnet0_tx_errors': 0,",
            "                  'vnet0_tx_packets': 0,",
            "                  }",
            "        self.assertEqual(actual, expect)",
            "",
            "        lt = datetime.datetime(2012, 11, 22, 12, 00, 00)",
            "        diags_time = datetime.datetime(2012, 11, 22, 12, 00, 10)",
            "        self.useFixture(utils_fixture.TimeFixture(diags_time))",
            "",
            "        instance.launched_at = lt",
            "        actual = drvr.get_instance_diagnostics(instance)",
            "        expected = {'config_drive': False,",
            "                    'cpu_details': [{'time': 15340000000},",
            "                                    {'time': 1640000000},",
            "                                    {'time': 3040000000},",
            "                                    {'time': 1420000000}],",
            "                    'disk_details': [{'errors_count': 0,",
            "                                      'id': '',",
            "                                      'read_bytes': 688640,",
            "                                      'read_requests': 169,",
            "                                      'write_bytes': 0,",
            "                                      'write_requests': 0},",
            "                                     {'errors_count': 0,",
            "                                      'id': '',",
            "                                      'read_bytes': 688640,",
            "                                      'read_requests': 169,",
            "                                      'write_bytes': 0,",
            "                                      'write_requests': 0}],",
            "                    'driver': 'libvirt',",
            "                    'hypervisor_os': 'linux',",
            "                    'memory_details': {'maximum': 2048, 'used': 1234},",
            "                    'nic_details': [{'mac_address': '52:54:00:a4:38:38',",
            "                                     'rx_drop': 0,",
            "                                     'rx_errors': 0,",
            "                                     'rx_octets': 4408,",
            "                                     'rx_packets': 82,",
            "                                     'tx_drop': 0,",
            "                                     'tx_errors': 0,",
            "                                     'tx_octets': 0,",
            "                                     'tx_packets': 0}],",
            "                    'state': 'running',",
            "                    'uptime': 10,",
            "                    'version': '1.0'}",
            "        self.assertEqual(expected, actual.serialize())",
            "",
            "    @mock.patch.object(host.Host, 'get_domain')",
            "    def test_diagnostic_full_with_multiple_interfaces(self, mock_get_domain):",
            "        xml = \"\"\"",
            "                <domain type='kvm'>",
            "                    <devices>",
            "                        <disk type='file'>",
            "                            <source file='filename'/>",
            "                            <target dev='vda' bus='virtio'/>",
            "                        </disk>",
            "                        <disk type='block'>",
            "                            <source dev='/path/to/dev/1'/>",
            "                            <target dev='vdb' bus='virtio'/>",
            "                        </disk>",
            "                        <interface type='network'>",
            "                            <mac address='52:54:00:a4:38:38'/>",
            "                            <source network='default'/>",
            "                            <target dev='vnet0'/>",
            "                        </interface>",
            "                        <interface type=\"bridge\">",
            "                            <mac address=\"53:55:00:a5:39:39\"/>",
            "                            <model type=\"virtio\"/>",
            "                            <target dev=\"br0\"/>",
            "                        </interface>",
            "                    </devices>",
            "                </domain>",
            "            \"\"\"",
            "",
            "        class DiagFakeDomain(FakeVirtDomain):",
            "",
            "            def __init__(self):",
            "                super(DiagFakeDomain, self).__init__(fake_xml=xml)",
            "",
            "            def vcpus(self):",
            "                return ([(0, 1, 15340000000, 0),",
            "                         (1, 1, 1640000000, 0),",
            "                         (2, 1, 3040000000, 0),",
            "                         (3, 1, 1420000000, 0)],",
            "                        [(True, False),",
            "                         (True, False),",
            "                         (True, False),",
            "                         (True, False)])",
            "",
            "            def blockStats(self, path):",
            "                return (169, 688640, 0, 0, -1)",
            "",
            "            def interfaceStats(self, path):",
            "                return (4408, 82, 0, 0, 0, 0, 0, 0)",
            "",
            "            def memoryStats(self):",
            "                return {'actual': 220160, 'rss': 200164}",
            "",
            "            def maxMemory(self):",
            "                return 280160",
            "",
            "        def fake_get_domain(self):",
            "            return DiagFakeDomain()",
            "",
            "        mock_get_domain.side_effect = fake_get_domain",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        actual = drvr.get_diagnostics(instance)",
            "        expect = {'cpu0_time': 15340000000,",
            "                  'cpu1_time': 1640000000,",
            "                  'cpu2_time': 3040000000,",
            "                  'cpu3_time': 1420000000,",
            "                  'vda_read': 688640,",
            "                  'vda_read_req': 169,",
            "                  'vda_write': 0,",
            "                  'vda_write_req': 0,",
            "                  'vda_errors': -1,",
            "                  'vdb_read': 688640,",
            "                  'vdb_read_req': 169,",
            "                  'vdb_write': 0,",
            "                  'vdb_write_req': 0,",
            "                  'vdb_errors': -1,",
            "                  'memory': 280160,",
            "                  'memory-actual': 220160,",
            "                  'memory-rss': 200164,",
            "                  'vnet0_rx': 4408,",
            "                  'vnet0_rx_drop': 0,",
            "                  'vnet0_rx_errors': 0,",
            "                  'vnet0_rx_packets': 82,",
            "                  'vnet0_tx': 0,",
            "                  'vnet0_tx_drop': 0,",
            "                  'vnet0_tx_errors': 0,",
            "                  'vnet0_tx_packets': 0,",
            "                  'br0_rx': 4408,",
            "                  'br0_rx_drop': 0,",
            "                  'br0_rx_errors': 0,",
            "                  'br0_rx_packets': 82,",
            "                  'br0_tx': 0,",
            "                  'br0_tx_drop': 0,",
            "                  'br0_tx_errors': 0,",
            "                  'br0_tx_packets': 0,",
            "                  }",
            "        self.assertEqual(actual, expect)",
            "",
            "        lt = datetime.datetime(2012, 11, 22, 12, 00, 00)",
            "        diags_time = datetime.datetime(2012, 11, 22, 12, 00, 10)",
            "        self.useFixture(utils_fixture.TimeFixture(diags_time))",
            "",
            "        instance.launched_at = lt",
            "        actual = drvr.get_instance_diagnostics(instance)",
            "        expected = {'config_drive': False,",
            "                    'cpu_details': [{'time': 15340000000},",
            "                                    {'time': 1640000000},",
            "                                    {'time': 3040000000},",
            "                                    {'time': 1420000000}],",
            "                    'disk_details': [{'errors_count': 0,",
            "                                      'id': '',",
            "                                      'read_bytes': 688640,",
            "                                      'read_requests': 169,",
            "                                      'write_bytes': 0,",
            "                                      'write_requests': 0},",
            "                                     {'errors_count': 0,",
            "                                      'id': '',",
            "                                      'read_bytes': 688640,",
            "                                      'read_requests': 169,",
            "                                      'write_bytes': 0,",
            "                                      'write_requests': 0}],",
            "                    'driver': 'libvirt',",
            "                    'hypervisor_os': 'linux',",
            "                    'memory_details': {'maximum': 2048, 'used': 1234},",
            "                    'nic_details': [{'mac_address': '52:54:00:a4:38:38',",
            "                                     'rx_drop': 0,",
            "                                     'rx_errors': 0,",
            "                                     'rx_octets': 4408,",
            "                                     'rx_packets': 82,",
            "                                     'tx_drop': 0,",
            "                                     'tx_errors': 0,",
            "                                     'tx_octets': 0,",
            "                                     'tx_packets': 0},",
            "                                    {'mac_address': '53:55:00:a5:39:39',",
            "                                     'rx_drop': 0,",
            "                                     'rx_errors': 0,",
            "                                     'rx_octets': 4408,",
            "                                     'rx_packets': 82,",
            "                                     'tx_drop': 0,",
            "                                     'tx_errors': 0,",
            "                                     'tx_octets': 0,",
            "                                     'tx_packets': 0}],",
            "                    'state': 'running',",
            "                    'uptime': 10.,",
            "                    'version': '1.0'}",
            "        self.assertEqual(expected, actual.serialize())",
            "",
            "    @mock.patch.object(host.Host, \"list_instance_domains\")",
            "    def test_failing_vcpu_count(self, mock_list):",
            "        \"\"\"Domain can fail to return the vcpu description in case it's",
            "        just starting up or shutting down. Make sure None is handled",
            "        gracefully.",
            "        \"\"\"",
            "",
            "        class DiagFakeDomain(object):",
            "            def __init__(self, vcpus):",
            "                self._vcpus = vcpus",
            "",
            "            def vcpus(self):",
            "                if self._vcpus is None:",
            "                    raise fakelibvirt.libvirtError(\"fake-error\")",
            "                else:",
            "                    return ([[1, 2, 3, 4]] * self._vcpus, [True] * self._vcpus)",
            "",
            "            def ID(self):",
            "                return 1",
            "",
            "            def name(self):",
            "                return \"instance000001\"",
            "",
            "            def UUIDString(self):",
            "                return \"19479fee-07a5-49bb-9138-d3738280d63c\"",
            "",
            "        mock_list.return_value = [",
            "            DiagFakeDomain(None), DiagFakeDomain(5)]",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        self.assertEqual(5, drvr._get_vcpu_used())",
            "        mock_list.assert_called_with(only_guests=True, only_running=True)",
            "",
            "    @mock.patch.object(host.Host, \"list_instance_domains\")",
            "    def test_failing_vcpu_count_none(self, mock_list):",
            "        \"\"\"Domain will return zero if the current number of vcpus used",
            "        is None. This is in case of VM state starting up or shutting",
            "        down. None type returned is counted as zero.",
            "        \"\"\"",
            "",
            "        class DiagFakeDomain(object):",
            "            def __init__(self):",
            "                pass",
            "",
            "            def vcpus(self):",
            "                return None",
            "",
            "            def ID(self):",
            "                return 1",
            "",
            "            def name(self):",
            "                return \"instance000001\"",
            "",
            "        mock_list.return_value = [DiagFakeDomain()]",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertEqual(0, drvr._get_vcpu_used())",
            "        mock_list.assert_called_with(only_guests=True, only_running=True)",
            "",
            "    def test_get_instance_capabilities(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        def get_host_capabilities_stub(self):",
            "            caps = vconfig.LibvirtConfigCaps()",
            "",
            "            guest = vconfig.LibvirtConfigGuest()",
            "            guest.ostype = 'hvm'",
            "            guest.arch = arch.X86_64",
            "            guest.domtype = ['kvm', 'qemu']",
            "            caps.guests.append(guest)",
            "",
            "            guest = vconfig.LibvirtConfigGuest()",
            "            guest.ostype = 'hvm'",
            "            guest.arch = arch.I686",
            "            guest.domtype = ['kvm']",
            "            caps.guests.append(guest)",
            "",
            "            return caps",
            "",
            "        self.stubs.Set(host.Host, \"get_capabilities\",",
            "                       get_host_capabilities_stub)",
            "",
            "        want = [(arch.X86_64, 'kvm', 'hvm'),",
            "                (arch.X86_64, 'qemu', 'hvm'),",
            "                (arch.I686, 'kvm', 'hvm')]",
            "        got = drvr._get_instance_capabilities()",
            "        self.assertEqual(want, got)",
            "",
            "    def test_set_cache_mode(self):",
            "        self.flags(disk_cachemodes=['file=directsync'], group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        fake_conf = FakeConfigGuestDisk()",
            "",
            "        fake_conf.source_type = 'file'",
            "        drvr._set_cache_mode(fake_conf)",
            "        self.assertEqual(fake_conf.driver_cache, 'directsync')",
            "",
            "    def test_set_cache_mode_invalid_mode(self):",
            "        self.flags(disk_cachemodes=['file=FAKE'], group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        fake_conf = FakeConfigGuestDisk()",
            "",
            "        fake_conf.source_type = 'file'",
            "        drvr._set_cache_mode(fake_conf)",
            "        self.assertIsNone(fake_conf.driver_cache)",
            "",
            "    def test_set_cache_mode_invalid_object(self):",
            "        self.flags(disk_cachemodes=['file=directsync'], group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        fake_conf = FakeConfigGuest()",
            "",
            "        fake_conf.driver_cache = 'fake'",
            "        drvr._set_cache_mode(fake_conf)",
            "        self.assertEqual(fake_conf.driver_cache, 'fake')",
            "",
            "    @mock.patch('os.unlink')",
            "    @mock.patch.object(os.path, 'exists')",
            "    def _test_shared_storage_detection(self, is_same,",
            "                                       mock_exists, mock_unlink):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        drvr.get_host_ip_addr = mock.MagicMock(return_value='bar')",
            "        mock_exists.return_value = is_same",
            "        with test.nested(",
            "            mock.patch.object(drvr._remotefs, 'create_file'),",
            "            mock.patch.object(drvr._remotefs, 'remove_file')",
            "        ) as (mock_rem_fs_create, mock_rem_fs_remove):",
            "            result = drvr._is_storage_shared_with('host', '/path')",
            "        mock_rem_fs_create.assert_any_call('host', mock.ANY)",
            "        create_args, create_kwargs = mock_rem_fs_create.call_args",
            "        self.assertTrue(create_args[1].startswith('/path'))",
            "        if is_same:",
            "            mock_unlink.assert_called_once_with(mock.ANY)",
            "        else:",
            "            mock_rem_fs_remove.assert_called_with('host', mock.ANY)",
            "            remove_args, remove_kwargs = mock_rem_fs_remove.call_args",
            "            self.assertTrue(remove_args[1].startswith('/path'))",
            "        return result",
            "",
            "    def test_shared_storage_detection_same_host(self):",
            "        self.assertTrue(self._test_shared_storage_detection(True))",
            "",
            "    def test_shared_storage_detection_different_host(self):",
            "        self.assertFalse(self._test_shared_storage_detection(False))",
            "",
            "    def test_shared_storage_detection_easy(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.mox.StubOutWithMock(drvr, 'get_host_ip_addr')",
            "        self.mox.StubOutWithMock(utils, 'execute')",
            "        self.mox.StubOutWithMock(os.path, 'exists')",
            "        self.mox.StubOutWithMock(os, 'unlink')",
            "        drvr.get_host_ip_addr().AndReturn('foo')",
            "        self.mox.ReplayAll()",
            "        self.assertTrue(drvr._is_storage_shared_with('foo', '/path'))",
            "",
            "    def test_store_pid_remove_pid(self):",
            "        instance = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        popen = mock.Mock(pid=3)",
            "        drvr.job_tracker.add_job(instance, popen.pid)",
            "        self.assertIn(3, drvr.job_tracker.jobs[instance.uuid])",
            "        drvr.job_tracker.remove_job(instance, popen.pid)",
            "        self.assertNotIn(instance.uuid, drvr.job_tracker.jobs)",
            "",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_domain')",
            "    def test_get_domain_info_with_more_return(self, mock_get_domain):",
            "        instance = objects.Instance(**self.test_instance)",
            "        dom_mock = mock.MagicMock()",
            "        dom_mock.info.return_value = [",
            "            1, 2048, 737, 8, 12345, 888888",
            "        ]",
            "        dom_mock.ID.return_value = mock.sentinel.instance_id",
            "        mock_get_domain.return_value = dom_mock",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        info = drvr.get_info(instance)",
            "        self.assertEqual(1, info.state)",
            "        self.assertEqual(2048, info.max_mem_kb)",
            "        self.assertEqual(737, info.mem_kb)",
            "        self.assertEqual(8, info.num_cpu)",
            "        self.assertEqual(12345, info.cpu_time_ns)",
            "        self.assertEqual(mock.sentinel.instance_id, info.id)",
            "        dom_mock.info.assert_called_once_with()",
            "        dom_mock.ID.assert_called_once_with()",
            "        mock_get_domain.assert_called_once_with(instance)",
            "",
            "    def test_create_domain(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        mock_domain = mock.MagicMock()",
            "",
            "        guest = drvr._create_domain(domain=mock_domain)",
            "",
            "        self.assertEqual(mock_domain, guest._domain)",
            "        mock_domain.createWithFlags.assert_has_calls([mock.call(0)])",
            "",
            "    @mock.patch('nova.virt.disk.api.clean_lxc_namespace')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.get_info')",
            "    @mock.patch('nova.virt.disk.api.setup_container')",
            "    @mock.patch('oslo_utils.fileutils.ensure_tree')",
            "    @mock.patch.object(fake_libvirt_utils, 'get_instance_path')",
            "    def test_create_domain_lxc(self, mock_get_inst_path, mock_ensure_tree,",
            "                           mock_setup_container, mock_get_info, mock_clean):",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        mock_instance = mock.MagicMock()",
            "        inst_sys_meta = dict()",
            "        mock_instance.system_metadata = inst_sys_meta",
            "        mock_get_inst_path.return_value = '/tmp/'",
            "        mock_image_backend = mock.MagicMock()",
            "        drvr.image_backend = mock_image_backend",
            "        mock_image = mock.MagicMock()",
            "        mock_image.path = '/tmp/test.img'",
            "        drvr.image_backend.image.return_value = mock_image",
            "        mock_setup_container.return_value = '/dev/nbd0'",
            "        mock_get_info.return_value = hardware.InstanceInfo(",
            "            state=power_state.RUNNING)",
            "",
            "        with test.nested(",
            "            mock.patch.object(drvr, '_create_images_and_backing'),",
            "            mock.patch.object(drvr, '_is_booted_from_volume',",
            "                              return_value=False),",
            "            mock.patch.object(drvr, '_create_domain'),",
            "            mock.patch.object(drvr, 'plug_vifs'),",
            "            mock.patch.object(drvr.firewall_driver, 'setup_basic_filtering'),",
            "            mock.patch.object(drvr.firewall_driver, 'prepare_instance_filter'),",
            "            mock.patch.object(drvr.firewall_driver, 'apply_instance_filter')):",
            "            drvr._create_domain_and_network(self.context, 'xml',",
            "                                            mock_instance, [], None)",
            "",
            "        self.assertEqual('/dev/nbd0', inst_sys_meta['rootfs_device_name'])",
            "        self.assertFalse(mock_instance.called)",
            "        mock_get_inst_path.assert_has_calls([mock.call(mock_instance)])",
            "        mock_ensure_tree.assert_has_calls([mock.call('/tmp/rootfs')])",
            "        drvr.image_backend.image.assert_has_calls([mock.call(mock_instance,",
            "                                                             'disk')])",
            "",
            "        setup_container_call = mock.call(",
            "            mock_image.get_model(),",
            "            container_dir='/tmp/rootfs')",
            "        mock_setup_container.assert_has_calls([setup_container_call])",
            "        mock_get_info.assert_has_calls([mock.call(mock_instance)])",
            "        mock_clean.assert_has_calls([mock.call(container_dir='/tmp/rootfs')])",
            "",
            "    @mock.patch('nova.virt.disk.api.clean_lxc_namespace')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.get_info')",
            "    @mock.patch.object(fake_libvirt_utils, 'chown_for_id_maps')",
            "    @mock.patch('nova.virt.disk.api.setup_container')",
            "    @mock.patch('oslo_utils.fileutils.ensure_tree')",
            "    @mock.patch.object(fake_libvirt_utils, 'get_instance_path')",
            "    def test_create_domain_lxc_id_maps(self, mock_get_inst_path,",
            "                                       mock_ensure_tree, mock_setup_container,",
            "                                       mock_chown, mock_get_info, mock_clean):",
            "        self.flags(virt_type='lxc', uid_maps=[\"0:1000:100\"],",
            "                   gid_maps=[\"0:1000:100\"], group='libvirt')",
            "",
            "        def chown_side_effect(path, id_maps):",
            "            self.assertEqual('/tmp/rootfs', path)",
            "            self.assertIsInstance(id_maps[0], vconfig.LibvirtConfigGuestUIDMap)",
            "            self.assertEqual(0, id_maps[0].start)",
            "            self.assertEqual(1000, id_maps[0].target)",
            "            self.assertEqual(100, id_maps[0].count)",
            "            self.assertIsInstance(id_maps[1], vconfig.LibvirtConfigGuestGIDMap)",
            "            self.assertEqual(0, id_maps[1].start)",
            "            self.assertEqual(1000, id_maps[1].target)",
            "            self.assertEqual(100, id_maps[1].count)",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        mock_instance = mock.MagicMock()",
            "        inst_sys_meta = dict()",
            "        mock_instance.system_metadata = inst_sys_meta",
            "        mock_get_inst_path.return_value = '/tmp/'",
            "        mock_image_backend = mock.MagicMock()",
            "        drvr.image_backend = mock_image_backend",
            "        mock_image = mock.MagicMock()",
            "        mock_image.path = '/tmp/test.img'",
            "        drvr.image_backend.image.return_value = mock_image",
            "        mock_setup_container.return_value = '/dev/nbd0'",
            "        mock_chown.side_effect = chown_side_effect",
            "        mock_get_info.return_value = hardware.InstanceInfo(",
            "            state=power_state.RUNNING)",
            "",
            "        with test.nested(",
            "            mock.patch.object(drvr, '_create_images_and_backing'),",
            "            mock.patch.object(drvr, '_is_booted_from_volume',",
            "                              return_value=False),",
            "            mock.patch.object(drvr, '_create_domain'),",
            "            mock.patch.object(drvr, 'plug_vifs'),",
            "            mock.patch.object(drvr.firewall_driver, 'setup_basic_filtering'),",
            "            mock.patch.object(drvr.firewall_driver, 'prepare_instance_filter'),",
            "            mock.patch.object(drvr.firewall_driver, 'apply_instance_filter')",
            "        ) as (",
            "            mock_create_images_and_backing, mock_is_booted_from_volume,",
            "            mock_create_domain, mock_plug_vifs, mock_setup_basic_filtering,",
            "            mock_prepare_instance_filter, mock_apply_instance_filter",
            "        ):",
            "            drvr._create_domain_and_network(self.context, 'xml',",
            "                                            mock_instance, [], None)",
            "",
            "        self.assertEqual('/dev/nbd0', inst_sys_meta['rootfs_device_name'])",
            "        self.assertFalse(mock_instance.called)",
            "        mock_get_inst_path.assert_has_calls([mock.call(mock_instance)])",
            "        mock_is_booted_from_volume.assert_called_once_with(mock_instance, {})",
            "        mock_ensure_tree.assert_has_calls([mock.call('/tmp/rootfs')])",
            "        drvr.image_backend.image.assert_has_calls([mock.call(mock_instance,",
            "                                                             'disk')])",
            "",
            "        setup_container_call = mock.call(",
            "            mock_image.get_model(),",
            "            container_dir='/tmp/rootfs')",
            "        mock_setup_container.assert_has_calls([setup_container_call])",
            "        mock_get_info.assert_has_calls([mock.call(mock_instance)])",
            "        mock_clean.assert_has_calls([mock.call(container_dir='/tmp/rootfs')])",
            "",
            "    @mock.patch('nova.virt.disk.api.teardown_container')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.get_info')",
            "    @mock.patch('nova.virt.disk.api.setup_container')",
            "    @mock.patch('oslo_utils.fileutils.ensure_tree')",
            "    @mock.patch.object(fake_libvirt_utils, 'get_instance_path')",
            "    def test_create_domain_lxc_not_running(self, mock_get_inst_path,",
            "                                           mock_ensure_tree,",
            "                                           mock_setup_container,",
            "                                           mock_get_info, mock_teardown):",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        mock_instance = mock.MagicMock()",
            "        inst_sys_meta = dict()",
            "        mock_instance.system_metadata = inst_sys_meta",
            "        mock_get_inst_path.return_value = '/tmp/'",
            "        mock_image_backend = mock.MagicMock()",
            "        drvr.image_backend = mock_image_backend",
            "        mock_image = mock.MagicMock()",
            "        mock_image.path = '/tmp/test.img'",
            "        drvr.image_backend.image.return_value = mock_image",
            "        mock_setup_container.return_value = '/dev/nbd0'",
            "        mock_get_info.return_value = hardware.InstanceInfo(",
            "            state=power_state.SHUTDOWN)",
            "",
            "        with test.nested(",
            "            mock.patch.object(drvr, '_create_images_and_backing'),",
            "            mock.patch.object(drvr, '_is_booted_from_volume',",
            "                              return_value=False),",
            "            mock.patch.object(drvr, '_create_domain'),",
            "            mock.patch.object(drvr, 'plug_vifs'),",
            "            mock.patch.object(drvr.firewall_driver, 'setup_basic_filtering'),",
            "            mock.patch.object(drvr.firewall_driver, 'prepare_instance_filter'),",
            "            mock.patch.object(drvr.firewall_driver, 'apply_instance_filter')):",
            "            drvr._create_domain_and_network(self.context, 'xml',",
            "                                            mock_instance, [], None)",
            "",
            "        self.assertEqual('/dev/nbd0', inst_sys_meta['rootfs_device_name'])",
            "        self.assertFalse(mock_instance.called)",
            "        mock_get_inst_path.assert_has_calls([mock.call(mock_instance)])",
            "        mock_ensure_tree.assert_has_calls([mock.call('/tmp/rootfs')])",
            "        drvr.image_backend.image.assert_has_calls([mock.call(mock_instance,",
            "                                                             'disk')])",
            "",
            "        setup_container_call = mock.call(",
            "            mock_image.get_model(),",
            "            container_dir='/tmp/rootfs')",
            "        mock_setup_container.assert_has_calls([setup_container_call])",
            "        mock_get_info.assert_has_calls([mock.call(mock_instance)])",
            "        teardown_call = mock.call(container_dir='/tmp/rootfs')",
            "        mock_teardown.assert_has_calls([teardown_call])",
            "",
            "    def test_create_domain_define_xml_fails(self):",
            "        \"\"\"Tests that the xml is logged when defining the domain fails.\"\"\"",
            "        fake_xml = \"<test>this is a test</test>\"",
            "",
            "        def fake_defineXML(xml):",
            "            self.assertEqual(fake_xml, xml)",
            "            raise fakelibvirt.libvirtError('virDomainDefineXML() failed')",
            "",
            "        def fake_safe_decode(text, *args, **kwargs):",
            "            return text + 'safe decoded'",
            "",
            "        self.log_error_called = False",
            "",
            "        def fake_error(msg, *args, **kwargs):",
            "            self.log_error_called = True",
            "            self.assertIn(fake_xml, msg % args)",
            "            self.assertIn('safe decoded', msg % args)",
            "",
            "        self.stubs.Set(encodeutils, 'safe_decode', fake_safe_decode)",
            "        self.stubs.Set(nova.virt.libvirt.guest.LOG, 'error', fake_error)",
            "",
            "        self.create_fake_libvirt_mock(defineXML=fake_defineXML)",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        self.assertRaises(fakelibvirt.libvirtError, drvr._create_domain,",
            "                          fake_xml)",
            "        self.assertTrue(self.log_error_called)",
            "",
            "    def test_create_domain_with_flags_fails(self):",
            "        \"\"\"Tests that the xml is logged when creating the domain with flags",
            "        fails",
            "        \"\"\"",
            "        fake_xml = \"<test>this is a test</test>\"",
            "        fake_domain = FakeVirtDomain(fake_xml)",
            "",
            "        def fake_createWithFlags(launch_flags):",
            "            raise fakelibvirt.libvirtError('virDomainCreateWithFlags() failed')",
            "",
            "        self.log_error_called = False",
            "",
            "        def fake_error(msg, *args, **kwargs):",
            "            self.log_error_called = True",
            "            self.assertIn(fake_xml, msg % args)",
            "",
            "        self.stubs.Set(fake_domain, 'createWithFlags', fake_createWithFlags)",
            "        self.stubs.Set(nova.virt.libvirt.guest.LOG, 'error', fake_error)",
            "",
            "        self.create_fake_libvirt_mock()",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        self.assertRaises(fakelibvirt.libvirtError, drvr._create_domain,",
            "                          domain=fake_domain)",
            "        self.assertTrue(self.log_error_called)",
            "",
            "    def test_create_domain_enable_hairpin_fails(self):",
            "        \"\"\"Tests that the xml is logged when enabling hairpin mode for the",
            "        domain fails.",
            "        \"\"\"",
            "        fake_xml = \"<test>this is a test</test>\"",
            "        fake_domain = FakeVirtDomain(fake_xml)",
            "",
            "        def fake_execute(*args, **kwargs):",
            "            raise processutils.ProcessExecutionError('error')",
            "",
            "        def fake_get_interfaces(*args):",
            "            return [\"dev\"]",
            "",
            "        self.log_error_called = False",
            "",
            "        def fake_error(msg, *args, **kwargs):",
            "            self.log_error_called = True",
            "            self.assertIn(fake_xml, msg % args)",
            "",
            "        self.stubs.Set(nova.virt.libvirt.guest.LOG, 'error', fake_error)",
            "",
            "        self.create_fake_libvirt_mock()",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        self.stubs.Set(nova.utils, 'execute', fake_execute)",
            "        self.stubs.Set(",
            "            nova.virt.libvirt.guest.Guest, 'get_interfaces',",
            "            fake_get_interfaces)",
            "",
            "        self.assertRaises(processutils.ProcessExecutionError,",
            "                          drvr._create_domain,",
            "                          domain=fake_domain,",
            "                          power_on=False)",
            "        self.assertTrue(self.log_error_called)",
            "",
            "    def test_get_vnc_console(self):",
            "        instance = objects.Instance(**self.test_instance)",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices>\"",
            "                    \"<graphics type='vnc' port='5900'/>\"",
            "                    \"</devices></domain>\")",
            "",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"XMLDesc\")",
            "        vdmock.XMLDesc(flags=0).AndReturn(dummyxml)",
            "",
            "        def fake_lookup(instance_name):",
            "            if instance_name == instance['name']:",
            "                return vdmock",
            "        self.create_fake_libvirt_mock(lookupByName=fake_lookup)",
            "",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        vnc_dict = drvr.get_vnc_console(self.context, instance)",
            "        self.assertEqual(vnc_dict.port, '5900')",
            "",
            "    def test_get_vnc_console_unavailable(self):",
            "        instance = objects.Instance(**self.test_instance)",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices></devices></domain>\")",
            "",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"XMLDesc\")",
            "        vdmock.XMLDesc(flags=0).AndReturn(dummyxml)",
            "",
            "        def fake_lookup(instance_name):",
            "            if instance_name == instance['name']:",
            "                return vdmock",
            "        self.create_fake_libvirt_mock(lookupByName=fake_lookup)",
            "",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertRaises(exception.ConsoleTypeUnavailable,",
            "                          drvr.get_vnc_console, self.context, instance)",
            "",
            "    def test_get_spice_console(self):",
            "        instance = objects.Instance(**self.test_instance)",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices>\"",
            "                    \"<graphics type='spice' port='5950'/>\"",
            "                    \"</devices></domain>\")",
            "",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"XMLDesc\")",
            "        vdmock.XMLDesc(flags=0).AndReturn(dummyxml)",
            "",
            "        def fake_lookup(instance_name):",
            "            if instance_name == instance['name']:",
            "                return vdmock",
            "        self.create_fake_libvirt_mock(lookupByName=fake_lookup)",
            "",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        spice_dict = drvr.get_spice_console(self.context, instance)",
            "        self.assertEqual(spice_dict.port, '5950')",
            "",
            "    def test_get_spice_console_unavailable(self):",
            "        instance = objects.Instance(**self.test_instance)",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices></devices></domain>\")",
            "",
            "        vdmock = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.mox.StubOutWithMock(vdmock, \"XMLDesc\")",
            "        vdmock.XMLDesc(flags=0).AndReturn(dummyxml)",
            "",
            "        def fake_lookup(instance_name):",
            "            if instance_name == instance['name']:",
            "                return vdmock",
            "        self.create_fake_libvirt_mock(lookupByName=fake_lookup)",
            "",
            "        self.mox.ReplayAll()",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertRaises(exception.ConsoleTypeUnavailable,",
            "                          drvr.get_spice_console, self.context, instance)",
            "",
            "    def test_detach_volume_with_instance_not_found(self):",
            "        # Test that detach_volume() method does not raise exception,",
            "        # if the instance does not exist.",
            "",
            "        instance = objects.Instance(**self.test_instance)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        with test.nested(",
            "            mock.patch.object(host.Host, 'get_domain',",
            "                              side_effect=exception.InstanceNotFound(",
            "                                  instance_id=instance.uuid)),",
            "            mock.patch.object(drvr, '_disconnect_volume')",
            "        ) as (_get_domain, _disconnect_volume):",
            "            connection_info = {'driver_volume_type': 'fake'}",
            "            drvr.detach_volume(connection_info, instance, '/dev/sda')",
            "            _get_domain.assert_called_once_with(instance)",
            "            _disconnect_volume.assert_called_once_with(connection_info,",
            "                                                       'sda')",
            "",
            "    def _test_attach_detach_interface_get_config(self, method_name):",
            "        \"\"\"Tests that the get_config() method is properly called in",
            "        attach_interface() and detach_interface().",
            "",
            "        method_name: either \\\"attach_interface\\\" or \\\"detach_interface\\\"",
            "                     depending on the method to test.",
            "        \"\"\"",
            "        self.stubs.Set(host.Host, \"get_domain\", lambda a, b: FakeVirtDomain())",
            "",
            "        instance = objects.Instance(**self.test_instance)",
            "        network_info = _fake_network_info(self, 1)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        fake_image_meta = objects.ImageMeta.from_dict(",
            "            {'id': instance['image_ref']})",
            "",
            "        if method_name == \"attach_interface\":",
            "            self.mox.StubOutWithMock(drvr.firewall_driver,",
            "                                     'setup_basic_filtering')",
            "            drvr.firewall_driver.setup_basic_filtering(instance, network_info)",
            "",
            "        expected = drvr.vif_driver.get_config(instance, network_info[0],",
            "                                              fake_image_meta,",
            "                                              instance.get_flavor(),",
            "                                              CONF.libvirt.virt_type,",
            "                                              drvr._host)",
            "        self.mox.StubOutWithMock(drvr.vif_driver, 'get_config')",
            "        drvr.vif_driver.get_config(instance, network_info[0],",
            "                                   mox.IsA(objects.ImageMeta),",
            "                                   mox.IsA(objects.Flavor),",
            "                                   CONF.libvirt.virt_type,",
            "                                   drvr._host).\\",
            "                                   AndReturn(expected)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        if method_name == \"attach_interface\":",
            "            drvr.attach_interface(instance, fake_image_meta,",
            "                                  network_info[0])",
            "        elif method_name == \"detach_interface\":",
            "            drvr.detach_interface(instance, network_info[0])",
            "        else:",
            "            raise ValueError(\"Unhandled method %s\" % method_name)",
            "",
            "    @mock.patch.object(lockutils, \"external_lock\")",
            "    def test_attach_interface_get_config(self, mock_lock):",
            "        \"\"\"Tests that the get_config() method is properly called in",
            "        attach_interface().",
            "        \"\"\"",
            "        mock_lock.return_value = threading.Semaphore()",
            "",
            "        self._test_attach_detach_interface_get_config(\"attach_interface\")",
            "",
            "    def test_detach_interface_get_config(self):",
            "        \"\"\"Tests that the get_config() method is properly called in",
            "        detach_interface().",
            "        \"\"\"",
            "        self._test_attach_detach_interface_get_config(\"detach_interface\")",
            "",
            "    def test_default_root_device_name(self):",
            "        instance = {'uuid': 'fake_instance'}",
            "        image_meta = objects.ImageMeta.from_dict({'id': 'fake'})",
            "        root_bdm = {'source_type': 'image',",
            "                    'detination_type': 'volume',",
            "                    'image_id': 'fake_id'}",
            "        self.flags(virt_type='fake_libvirt_type', group='libvirt')",
            "",
            "        self.mox.StubOutWithMock(blockinfo, 'get_disk_bus_for_device_type')",
            "        self.mox.StubOutWithMock(blockinfo, 'get_root_info')",
            "",
            "        blockinfo.get_disk_bus_for_device_type(instance,",
            "                                               'fake_libvirt_type',",
            "                                               image_meta,",
            "                                               'disk').InAnyOrder().\\",
            "                                                AndReturn('virtio')",
            "        blockinfo.get_disk_bus_for_device_type(instance,",
            "                                               'fake_libvirt_type',",
            "                                               image_meta,",
            "                                               'cdrom').InAnyOrder().\\",
            "                                                AndReturn('ide')",
            "        blockinfo.get_root_info(instance, 'fake_libvirt_type',",
            "                                image_meta, root_bdm,",
            "                                'virtio', 'ide').AndReturn({'dev': 'vda'})",
            "        self.mox.ReplayAll()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.assertEqual(drvr.default_root_device_name(instance, image_meta,",
            "                                                       root_bdm), '/dev/vda')",
            "",
            "    @mock.patch.object(objects.BlockDeviceMapping, \"save\")",
            "    def test_default_device_names_for_instance(self, save_mock):",
            "        instance = objects.Instance(**self.test_instance)",
            "        instance.root_device_name = '/dev/vda'",
            "        ephemerals = [objects.BlockDeviceMapping(",
            "                        **fake_block_device.AnonFakeDbBlockDeviceDict(",
            "                            {'device_name': 'vdb',",
            "                             'source_type': 'blank',",
            "                             'volume_size': 2,",
            "                             'destination_type': 'local'}))]",
            "        swap = [objects.BlockDeviceMapping(",
            "                        **fake_block_device.AnonFakeDbBlockDeviceDict(",
            "                            {'device_name': 'vdg',",
            "                             'source_type': 'blank',",
            "                             'volume_size': 512,",
            "                             'guest_format': 'swap',",
            "                             'destination_type': 'local'}))]",
            "        block_device_mapping = [",
            "            objects.BlockDeviceMapping(",
            "                **fake_block_device.AnonFakeDbBlockDeviceDict(",
            "                    {'source_type': 'volume',",
            "                     'destination_type': 'volume',",
            "                     'volume_id': 'fake-image-id',",
            "                     'device_name': '/dev/vdxx',",
            "                     'disk_bus': 'scsi'}))]",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr.default_device_names_for_instance(instance,",
            "                                               instance.root_device_name,",
            "                                               ephemerals, swap,",
            "                                               block_device_mapping)",
            "",
            "        # Ephemeral device name was correct so no changes",
            "        self.assertEqual('/dev/vdb', ephemerals[0].device_name)",
            "        # Swap device name was incorrect so it was changed",
            "        self.assertEqual('/dev/vdc', swap[0].device_name)",
            "        # Volume device name was changed too, taking the bus into account",
            "        self.assertEqual('/dev/sda', block_device_mapping[0].device_name)",
            "",
            "        self.assertEqual(3, save_mock.call_count)",
            "",
            "    def _test_get_device_name_for_instance(self, new_bdm, expected_dev):",
            "        instance = objects.Instance(**self.test_instance)",
            "        instance.root_device_name = '/dev/vda'",
            "        instance.ephemeral_gb = 0",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        got_dev = drvr.get_device_name_for_instance(",
            "            instance, [], new_bdm)",
            "        self.assertEqual(expected_dev, got_dev)",
            "",
            "    def test_get_device_name_for_instance_simple(self):",
            "        new_bdm = objects.BlockDeviceMapping(",
            "            context=context,",
            "            source_type='volume', destination_type='volume',",
            "            boot_index=-1, volume_id='fake-id',",
            "            device_name=None, guest_format=None,",
            "            disk_bus=None, device_type=None)",
            "        self._test_get_device_name_for_instance(new_bdm, '/dev/vdb')",
            "",
            "    def test_get_device_name_for_instance_suggested(self):",
            "        new_bdm = objects.BlockDeviceMapping(",
            "            context=context,",
            "            source_type='volume', destination_type='volume',",
            "            boot_index=-1, volume_id='fake-id',",
            "            device_name='/dev/vdg', guest_format=None,",
            "            disk_bus=None, device_type=None)",
            "        self._test_get_device_name_for_instance(new_bdm, '/dev/vdb')",
            "",
            "    def test_get_device_name_for_instance_bus(self):",
            "        new_bdm = objects.BlockDeviceMapping(",
            "            context=context,",
            "            source_type='volume', destination_type='volume',",
            "            boot_index=-1, volume_id='fake-id',",
            "            device_name=None, guest_format=None,",
            "            disk_bus='scsi', device_type=None)",
            "        self._test_get_device_name_for_instance(new_bdm, '/dev/sda')",
            "",
            "    def test_get_device_name_for_instance_device_type(self):",
            "        new_bdm = objects.BlockDeviceMapping(",
            "            context=context,",
            "            source_type='volume', destination_type='volume',",
            "            boot_index=-1, volume_id='fake-id',",
            "            device_name=None, guest_format=None,",
            "            disk_bus=None, device_type='floppy')",
            "        self._test_get_device_name_for_instance(new_bdm, '/dev/fda')",
            "",
            "    def test_is_supported_fs_format(self):",
            "        supported_fs = [disk.FS_FORMAT_EXT2, disk.FS_FORMAT_EXT3,",
            "                        disk.FS_FORMAT_EXT4, disk.FS_FORMAT_XFS]",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        for fs in supported_fs:",
            "            self.assertTrue(drvr.is_supported_fs_format(fs))",
            "",
            "        supported_fs = ['', 'dummy']",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        for fs in supported_fs:",
            "            self.assertFalse(drvr.is_supported_fs_format(fs))",
            "",
            "    def test_post_live_migration_at_destination_with_block_device_info(self):",
            "        # Preparing mocks",
            "        mock_domain = self.mox.CreateMock(fakelibvirt.virDomain)",
            "        self.resultXML = None",
            "",
            "        def fake_getLibVersion():",
            "            return fakelibvirt.FAKE_LIBVIRT_VERSION",
            "",
            "        def fake_getCapabilities():",
            "            return \"\"\"",
            "            <capabilities>",
            "                <host>",
            "                    <uuid>cef19ce0-0ca2-11df-855d-b19fbce37686</uuid>",
            "                    <cpu>",
            "                      <arch>x86_64</arch>",
            "                      <model>Penryn</model>",
            "                      <vendor>Intel</vendor>",
            "                      <topology sockets='1' cores='2' threads='1'/>",
            "                      <feature name='xtpr'/>",
            "                    </cpu>",
            "                </host>",
            "            </capabilities>",
            "            \"\"\"",
            "",
            "        def fake_to_xml(context, instance, network_info, disk_info,",
            "                        image_meta=None, rescue=None,",
            "                        block_device_info=None, write_to_disk=False):",
            "            if image_meta is None:",
            "                image_meta = objects.ImageMeta.from_dict({})",
            "            conf = drvr._get_guest_config(instance, network_info, image_meta,",
            "                                          disk_info, rescue, block_device_info)",
            "            self.resultXML = conf.to_xml()",
            "            return self.resultXML",
            "",
            "        def fake_get_domain(instance):",
            "            return mock_domain",
            "",
            "        def fake_baselineCPU(cpu, flag):",
            "            return \"\"\"<cpu mode='custom' match='exact'>",
            "                        <model fallback='allow'>Westmere</model>",
            "                        <vendor>Intel</vendor>",
            "                        <feature policy='require' name='aes'/>",
            "                      </cpu>",
            "                   \"\"\"",
            "",
            "        network_info = _fake_network_info(self, 1)",
            "        self.create_fake_libvirt_mock(getLibVersion=fake_getLibVersion,",
            "                                      getCapabilities=fake_getCapabilities,",
            "                                      getVersion=lambda: 1005001,",
            "                                      listDefinedDomains=lambda: [],",
            "                                      numOfDomains=lambda: 0,",
            "                                      baselineCPU=fake_baselineCPU)",
            "        instance_ref = self.test_instance",
            "        instance_ref['image_ref'] = 123456  # we send an int to test sha1 call",
            "        instance = objects.Instance(**instance_ref)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.stubs.Set(drvr,",
            "                       '_get_guest_xml',",
            "                       fake_to_xml)",
            "        self.stubs.Set(host.Host,",
            "                       'get_domain',",
            "                       fake_get_domain)",
            "        bdm = objects.BlockDeviceMapping(",
            "            self.context,",
            "            **fake_block_device.FakeDbBlockDeviceDict(",
            "                {'id': 1, 'guest_format': None,",
            "                 'boot_index': 0,",
            "                 'source_type': 'volume',",
            "                 'destination_type': 'volume',",
            "                 'device_name': '/dev/vda',",
            "                 'disk_bus': 'virtio',",
            "                 'device_type': 'disk',",
            "                 'delete_on_termination': False}))",
            "        block_device_info = {'block_device_mapping':",
            "                driver_block_device.convert_volumes([bdm])}",
            "        block_device_info['block_device_mapping'][0]['connection_info'] = (",
            "                {'driver_volume_type': 'iscsi'})",
            "        with test.nested(",
            "                mock.patch.object(",
            "                    driver_block_device.DriverVolumeBlockDevice, 'save'),",
            "                mock.patch.object(objects.Instance, 'save')",
            "        ) as (mock_volume_save, mock_instance_save):",
            "            drvr.post_live_migration_at_destination(",
            "                    self.context, instance, network_info, True,",
            "                    block_device_info=block_device_info)",
            "            self.assertIn('fake', self.resultXML)",
            "            mock_volume_save.assert_called_once_with()",
            "",
            "    def test_create_propagates_exceptions(self):",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(id=1, uuid='fake-uuid',",
            "                                    image_ref='my_fake_image')",
            "",
            "        with test.nested(",
            "              mock.patch.object(drvr, '_create_domain_setup_lxc'),",
            "              mock.patch.object(drvr, '_create_domain_cleanup_lxc'),",
            "              mock.patch.object(drvr, '_is_booted_from_volume',",
            "                                return_value=False),",
            "              mock.patch.object(drvr, 'plug_vifs'),",
            "              mock.patch.object(drvr, 'firewall_driver'),",
            "              mock.patch.object(drvr, '_create_domain',",
            "                                side_effect=exception.NovaException),",
            "              mock.patch.object(drvr, 'cleanup')):",
            "            self.assertRaises(exception.NovaException,",
            "                              drvr._create_domain_and_network,",
            "                              self.context,",
            "                              'xml',",
            "                              instance, None, None)",
            "",
            "    def test_create_without_pause(self):",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "",
            "        @contextlib.contextmanager",
            "        def fake_lxc_disk_handler(*args, **kwargs):",
            "            yield",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "",
            "        with test.nested(",
            "              mock.patch.object(drvr, '_lxc_disk_handler',",
            "                                side_effect=fake_lxc_disk_handler),",
            "              mock.patch.object(drvr, 'plug_vifs'),",
            "              mock.patch.object(drvr, 'firewall_driver'),",
            "              mock.patch.object(drvr, '_create_domain'),",
            "              mock.patch.object(drvr, 'cleanup')) as (",
            "              _handler, cleanup, firewall_driver, create, plug_vifs):",
            "            domain = drvr._create_domain_and_network(self.context, 'xml',",
            "                                                     instance, None, None)",
            "            self.assertEqual(0, create.call_args_list[0][1]['pause'])",
            "            self.assertEqual(0, domain.resume.call_count)",
            "",
            "    def _test_create_with_network_events(self, neutron_failure=None,",
            "                                         power_on=True):",
            "        generated_events = []",
            "",
            "        def wait_timeout():",
            "            event = mock.MagicMock()",
            "            if neutron_failure == 'timeout':",
            "                raise eventlet.timeout.Timeout()",
            "            elif neutron_failure == 'error':",
            "                event.status = 'failed'",
            "            else:",
            "                event.status = 'completed'",
            "            return event",
            "",
            "        def fake_prepare(instance, event_name):",
            "            m = mock.MagicMock()",
            "            m.instance = instance",
            "            m.event_name = event_name",
            "            m.wait.side_effect = wait_timeout",
            "            generated_events.append(m)",
            "            return m",
            "",
            "        virtapi = manager.ComputeVirtAPI(mock.MagicMock())",
            "        prepare = virtapi._compute.instance_events.prepare_for_instance_event",
            "        prepare.side_effect = fake_prepare",
            "        drvr = libvirt_driver.LibvirtDriver(virtapi, False)",
            "",
            "        instance = objects.Instance(**self.test_instance)",
            "        vifs = [{'id': 'vif1', 'active': False},",
            "                {'id': 'vif2', 'active': False}]",
            "",
            "        @mock.patch.object(drvr, 'plug_vifs')",
            "        @mock.patch.object(drvr, 'firewall_driver')",
            "        @mock.patch.object(drvr, '_create_domain')",
            "        @mock.patch.object(drvr, 'cleanup')",
            "        def test_create(cleanup, create, fw_driver, plug_vifs):",
            "            domain = drvr._create_domain_and_network(self.context, 'xml',",
            "                                                     instance, vifs, None,",
            "                                                     power_on=power_on)",
            "            plug_vifs.assert_called_with(instance, vifs)",
            "",
            "            pause = self._get_pause_flag(drvr, vifs, power_on=power_on)",
            "            self.assertEqual(pause,",
            "                             create.call_args_list[0][1]['pause'])",
            "            if pause:",
            "                domain.resume.assert_called_once_with()",
            "            if neutron_failure and CONF.vif_plugging_is_fatal:",
            "                cleanup.assert_called_once_with(self.context,",
            "                                                instance, network_info=vifs,",
            "                                                block_device_info=None)",
            "",
            "        test_create()",
            "",
            "        if utils.is_neutron() and CONF.vif_plugging_timeout and power_on:",
            "            prepare.assert_has_calls([",
            "                mock.call(instance, 'network-vif-plugged-vif1'),",
            "                mock.call(instance, 'network-vif-plugged-vif2')])",
            "            for event in generated_events:",
            "                if neutron_failure and generated_events.index(event) != 0:",
            "                    self.assertEqual(0, event.call_count)",
            "                elif (neutron_failure == 'error' and",
            "                          not CONF.vif_plugging_is_fatal):",
            "                    event.wait.assert_called_once_with()",
            "        else:",
            "            self.assertEqual(0, prepare.call_count)",
            "",
            "    @mock.patch('nova.utils.is_neutron', return_value=True)",
            "    def test_create_with_network_events_neutron(self, is_neutron):",
            "        self._test_create_with_network_events()",
            "",
            "    @mock.patch('nova.utils.is_neutron', return_value=True)",
            "    def test_create_with_network_events_neutron_power_off(self,",
            "                                                          is_neutron):",
            "        # Tests that we don't wait for events if we don't start the instance.",
            "        self._test_create_with_network_events(power_on=False)",
            "",
            "    @mock.patch('nova.utils.is_neutron', return_value=True)",
            "    def test_create_with_network_events_neutron_nowait(self, is_neutron):",
            "        self.flags(vif_plugging_timeout=0)",
            "        self._test_create_with_network_events()",
            "",
            "    @mock.patch('nova.utils.is_neutron', return_value=True)",
            "    def test_create_with_network_events_neutron_failed_nonfatal_timeout(",
            "            self, is_neutron):",
            "        self.flags(vif_plugging_is_fatal=False)",
            "        self._test_create_with_network_events(neutron_failure='timeout')",
            "",
            "    @mock.patch('nova.utils.is_neutron', return_value=True)",
            "    def test_create_with_network_events_neutron_failed_fatal_timeout(",
            "            self, is_neutron):",
            "        self.assertRaises(exception.VirtualInterfaceCreateException,",
            "                          self._test_create_with_network_events,",
            "                          neutron_failure='timeout')",
            "",
            "    @mock.patch('nova.utils.is_neutron', return_value=True)",
            "    def test_create_with_network_events_neutron_failed_nonfatal_error(",
            "            self, is_neutron):",
            "        self.flags(vif_plugging_is_fatal=False)",
            "        self._test_create_with_network_events(neutron_failure='error')",
            "",
            "    @mock.patch('nova.utils.is_neutron', return_value=True)",
            "    def test_create_with_network_events_neutron_failed_fatal_error(",
            "            self, is_neutron):",
            "        self.assertRaises(exception.VirtualInterfaceCreateException,",
            "                          self._test_create_with_network_events,",
            "                          neutron_failure='error')",
            "",
            "    @mock.patch('nova.utils.is_neutron', return_value=False)",
            "    def test_create_with_network_events_non_neutron(self, is_neutron):",
            "        self._test_create_with_network_events()",
            "",
            "    @mock.patch('nova.volume.encryptors.get_encryption_metadata')",
            "    @mock.patch('nova.virt.libvirt.blockinfo.get_info_from_bdm')",
            "    def test_create_with_bdm(self, get_info_from_bdm, get_encryption_metadata):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        mock_dom = mock.MagicMock()",
            "        mock_encryption_meta = mock.MagicMock()",
            "        get_encryption_metadata.return_value = mock_encryption_meta",
            "",
            "        fake_xml = \"\"\"",
            "            <domain>",
            "                <name>instance-00000001</name>",
            "                <memory>1048576</memory>",
            "                <vcpu>1</vcpu>",
            "                <devices>",
            "                    <disk type='file' device='disk'>",
            "                        <driver name='qemu' type='raw' cache='none'/>",
            "                        <source file='/path/fake-volume1'/>",
            "                        <target dev='vda' bus='virtio'/>",
            "                    </disk>",
            "                </devices>",
            "            </domain>",
            "        \"\"\"",
            "        fake_volume_id = \"fake-volume-id\"",
            "        connection_info = {\"driver_volume_type\": \"fake\",",
            "                           \"data\": {\"access_mode\": \"rw\",",
            "                                    \"volume_id\": fake_volume_id}}",
            "",
            "        def fake_getitem(*args, **kwargs):",
            "            fake_bdm = {'connection_info': connection_info,",
            "                        'mount_device': '/dev/vda'}",
            "            return fake_bdm.get(args[0])",
            "",
            "        mock_volume = mock.MagicMock()",
            "        mock_volume.__getitem__.side_effect = fake_getitem",
            "        block_device_info = {'block_device_mapping': [mock_volume]}",
            "        network_info = [network_model.VIF(id='1'),",
            "                        network_model.VIF(id='2', active=True)]",
            "",
            "        with test.nested(",
            "            mock.patch.object(drvr, '_get_volume_encryptor'),",
            "            mock.patch.object(drvr, 'plug_vifs'),",
            "            mock.patch.object(drvr.firewall_driver, 'setup_basic_filtering'),",
            "            mock.patch.object(drvr.firewall_driver,",
            "                              'prepare_instance_filter'),",
            "            mock.patch.object(drvr, '_create_domain'),",
            "            mock.patch.object(drvr.firewall_driver, 'apply_instance_filter'),",
            "        ) as (get_volume_encryptor, plug_vifs, setup_basic_filtering,",
            "              prepare_instance_filter, create_domain, apply_instance_filter):",
            "            create_domain.return_value = libvirt_guest.Guest(mock_dom)",
            "",
            "            guest = drvr._create_domain_and_network(",
            "                    self.context, fake_xml, instance, network_info, None,",
            "                    block_device_info=block_device_info)",
            "",
            "            get_encryption_metadata.assert_called_once_with(self.context,",
            "                drvr._volume_api, fake_volume_id, connection_info)",
            "            get_volume_encryptor.assert_called_once_with(connection_info,",
            "                                                         mock_encryption_meta)",
            "            plug_vifs.assert_called_once_with(instance, network_info)",
            "            setup_basic_filtering.assert_called_once_with(instance,",
            "                                                          network_info)",
            "            prepare_instance_filter.assert_called_once_with(instance,",
            "                                                          network_info)",
            "            pause = self._get_pause_flag(drvr, network_info)",
            "            create_domain.assert_called_once_with(",
            "                fake_xml, pause=pause, power_on=True)",
            "            self.assertEqual(mock_dom, guest._domain)",
            "",
            "    def test_get_guest_storage_config(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        test_instance = copy.deepcopy(self.test_instance)",
            "        test_instance[\"default_swap_device\"] = None",
            "        instance = objects.Instance(**test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        flavor = instance.get_flavor()",
            "        conn_info = {'driver_volume_type': 'fake', 'data': {}}",
            "        bdm = objects.BlockDeviceMapping(",
            "            self.context,",
            "            **fake_block_device.FakeDbBlockDeviceDict({",
            "                   'id': 1,",
            "                   'source_type': 'volume',",
            "                   'destination_type': 'volume',",
            "                   'device_name': '/dev/vdc'}))",
            "        bdi = {'block_device_mapping':",
            "               driver_block_device.convert_volumes([bdm])}",
            "        bdm = bdi['block_device_mapping'][0]",
            "        bdm['connection_info'] = conn_info",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta,",
            "                                            bdi)",
            "        mock_conf = mock.MagicMock(source_path='fake')",
            "",
            "        with test.nested(",
            "            mock.patch.object(driver_block_device.DriverVolumeBlockDevice,",
            "                              'save'),",
            "            mock.patch.object(drvr, '_connect_volume'),",
            "            mock.patch.object(drvr, '_get_volume_config',",
            "                              return_value=mock_conf),",
            "            mock.patch.object(drvr, '_set_cache_mode')",
            "        ) as (volume_save, connect_volume, get_volume_config, set_cache_mode):",
            "            devices = drvr._get_guest_storage_config(instance, image_meta,",
            "                disk_info, False, bdi, flavor, \"hvm\")",
            "",
            "            self.assertEqual(3, len(devices))",
            "            self.assertEqual('/dev/vdb', instance.default_ephemeral_device)",
            "            self.assertIsNone(instance.default_swap_device)",
            "            connect_volume.assert_called_with(bdm['connection_info'],",
            "                {'bus': 'virtio', 'type': 'disk', 'dev': 'vdc'})",
            "            get_volume_config.assert_called_with(bdm['connection_info'],",
            "                {'bus': 'virtio', 'type': 'disk', 'dev': 'vdc'})",
            "            volume_save.assert_called_once_with()",
            "            self.assertEqual(3, set_cache_mode.call_count)",
            "",
            "    def test_get_neutron_events(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        network_info = [network_model.VIF(id='1'),",
            "                        network_model.VIF(id='2', active=True)]",
            "        events = drvr._get_neutron_events(network_info)",
            "        self.assertEqual([('network-vif-plugged', '1')], events)",
            "",
            "    def test_unplug_vifs_ignores_errors(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "        with mock.patch.object(drvr, 'vif_driver') as vif_driver:",
            "            vif_driver.unplug.side_effect = exception.AgentError(",
            "                method='unplug')",
            "            drvr._unplug_vifs('inst', [1], ignore_errors=True)",
            "            vif_driver.unplug.assert_called_once_with('inst', 1)",
            "",
            "    def test_unplug_vifs_reports_errors(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "        with mock.patch.object(drvr, 'vif_driver') as vif_driver:",
            "            vif_driver.unplug.side_effect = exception.AgentError(",
            "                method='unplug')",
            "            self.assertRaises(exception.AgentError,",
            "                              drvr.unplug_vifs, 'inst', [1])",
            "            vif_driver.unplug.assert_called_once_with('inst', 1)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._unplug_vifs')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._undefine_domain')",
            "    def test_cleanup_pass_with_no_mount_device(self, undefine, unplug):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "        drvr.firewall_driver = mock.Mock()",
            "        drvr._disconnect_volume = mock.Mock()",
            "        fake_inst = {'name': 'foo'}",
            "        fake_bdms = [{'connection_info': 'foo',",
            "                     'mount_device': None}]",
            "        with mock.patch('nova.virt.driver'",
            "                        '.block_device_info_get_mapping',",
            "                        return_value=fake_bdms):",
            "            drvr.cleanup('ctxt', fake_inst, 'netinfo', destroy_disks=False)",
            "        self.assertTrue(drvr._disconnect_volume.called)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._unplug_vifs')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._undefine_domain')",
            "    def test_cleanup_wants_vif_errors_ignored(self, undefine, unplug):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "        fake_inst = {'name': 'foo'}",
            "        with mock.patch.object(drvr._conn, 'lookupByName') as lookup:",
            "            lookup.return_value = fake_inst",
            "            # NOTE(danms): Make unplug cause us to bail early, since",
            "            # we only care about how it was called",
            "            unplug.side_effect = test.TestingException",
            "            self.assertRaises(test.TestingException,",
            "                              drvr.cleanup, 'ctxt', fake_inst, 'netinfo')",
            "            unplug.assert_called_once_with(fake_inst, 'netinfo', True)",
            "",
            "    @mock.patch.object(driver, 'block_device_info_get_mapping')",
            "    @mock.patch.object(host.Host, \"get_guest\")",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver,",
            "                       '_get_serial_ports_from_guest')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_undefine_domain')",
            "    def test_cleanup_serial_console_enabled(",
            "            self, undefine, get_ports, get_guest,",
            "            block_device_info_get_mapping):",
            "        self.flags(enabled=\"True\", group='serial_console')",
            "        instance = 'i1'",
            "        network_info = {}",
            "        bdm_info = {}",
            "        firewall_driver = mock.MagicMock()",
            "",
            "        guest = mock.Mock(spec=libvirt_guest.Guest)",
            "        get_guest.return_value = guest",
            "        get_ports.return_value = iter([('127.0.0.1', 10000)])",
            "        block_device_info_get_mapping.return_value = ()",
            "",
            "        # We want to ensure undefine_domain is called after",
            "        # lookup_domain.",
            "        def undefine_domain(instance):",
            "            get_ports.side_effect = Exception(\"domain undefined\")",
            "        undefine.side_effect = undefine_domain",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "        drvr.firewall_driver = firewall_driver",
            "        drvr.cleanup(",
            "            'ctx', instance, network_info,",
            "            block_device_info=bdm_info,",
            "            destroy_disks=False, destroy_vifs=False)",
            "",
            "        get_ports.assert_called_once_with(guest)",
            "        undefine.assert_called_once_with(instance)",
            "        firewall_driver.unfilter_instance.assert_called_once_with(",
            "            instance, network_info=network_info)",
            "        block_device_info_get_mapping.assert_called_once_with(bdm_info)",
            "",
            "    @mock.patch.object(driver, 'block_device_info_get_mapping')",
            "    @mock.patch.object(host.Host, \"get_guest\")",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_undefine_domain')",
            "    def test_cleanup_serial_console_domain_gone(",
            "            self, undefine, get_guest, block_device_info_get_mapping):",
            "        self.flags(enabled=\"True\", group='serial_console')",
            "        instance = {'name': 'i1'}",
            "        network_info = {}",
            "        bdm_info = {}",
            "        firewall_driver = mock.MagicMock()",
            "",
            "        block_device_info_get_mapping.return_value = ()",
            "",
            "        # Ensure get_guest raises same exception that would have occurred",
            "        # if domain was gone.",
            "        get_guest.side_effect = exception.InstanceNotFound(\"domain undefined\")",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "        drvr.firewall_driver = firewall_driver",
            "        drvr.cleanup(",
            "            'ctx', instance, network_info,",
            "            block_device_info=bdm_info,",
            "            destroy_disks=False, destroy_vifs=False)",
            "",
            "        get_guest.assert_called_once_with(instance)",
            "        undefine.assert_called_once_with(instance)",
            "        firewall_driver.unfilter_instance.assert_called_once_with(",
            "            instance, network_info=network_info)",
            "        block_device_info_get_mapping.assert_called_once_with(bdm_info)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, 'unfilter_instance')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, 'delete_instance_files',",
            "                       return_value=True)",
            "    @mock.patch.object(objects.Instance, 'save')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, '_undefine_domain')",
            "    def test_cleanup_migrate_data_shared_block_storage(self,",
            "                                                       _undefine_domain,",
            "                                                       save,",
            "                                                       delete_instance_files,",
            "                                                       unfilter_instance):",
            "        # Tests the cleanup method when migrate_data has",
            "        # is_shared_block_storage=True and destroy_disks=False.",
            "        instance = objects.Instance(self.context, **self.test_instance)",
            "        migrate_data = objects.LibvirtLiveMigrateData(",
            "                is_shared_block_storage=True)",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "        drvr.cleanup(",
            "            self.context, instance, network_info={}, destroy_disks=False,",
            "            migrate_data=migrate_data, destroy_vifs=False)",
            "        delete_instance_files.assert_called_once_with(instance)",
            "        self.assertEqual(1, int(instance.system_metadata['clean_attempts']))",
            "        self.assertTrue(instance.cleaned)",
            "        save.assert_called_once_with()",
            "",
            "    def test_swap_volume(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "",
            "        mock_dom = mock.MagicMock()",
            "        guest = libvirt_guest.Guest(mock_dom)",
            "",
            "        with mock.patch.object(drvr._conn, 'defineXML',",
            "                               create=True) as mock_define:",
            "            xmldoc = \"<domain/>\"",
            "            srcfile = \"/first/path\"",
            "            dstfile = \"/second/path\"",
            "",
            "            mock_dom.XMLDesc.return_value = xmldoc",
            "            mock_dom.isPersistent.return_value = True",
            "            mock_dom.blockJobInfo.return_value = {}",
            "",
            "            drvr._swap_volume(guest, srcfile, dstfile, 1)",
            "",
            "            mock_dom.XMLDesc.assert_called_once_with(",
            "                flags=(fakelibvirt.VIR_DOMAIN_XML_INACTIVE |",
            "                       fakelibvirt.VIR_DOMAIN_XML_SECURE))",
            "            mock_dom.blockRebase.assert_called_once_with(",
            "                srcfile, dstfile, 0, flags=(",
            "                    fakelibvirt.VIR_DOMAIN_BLOCK_REBASE_COPY |",
            "                    fakelibvirt.VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT))",
            "            mock_dom.blockResize.assert_called_once_with(",
            "                srcfile, 1 * units.Gi / units.Ki)",
            "            mock_define.assert_called_once_with(xmldoc)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._disconnect_volume')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._swap_volume')",
            "    @mock.patch('nova.virt.block_device.DriverVolumeBlockDevice.save')",
            "    @mock.patch('nova.objects.block_device.BlockDeviceMapping.'",
            "                'get_by_volume_and_instance')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._get_volume_config')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._connect_volume')",
            "    @mock.patch('nova.virt.libvirt.host.Host.get_guest')",
            "    def test_swap_volume_driver_bdm_save(self, get_guest,",
            "                                         connect_volume, get_volume_config,",
            "                                         get_by_volume_and_instance,",
            "                                         volume_save, swap_volume,",
            "                                         disconnect_volume):",
            "        conn = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "        instance = objects.Instance(**self.test_instance)",
            "        old_connection_info = {'driver_volume_type': 'fake',",
            "                               'serial': 'old-volume-id',",
            "                               'data': {'device_path': '/fake-old-volume',",
            "                                        'access_mode': 'rw'}}",
            "        new_connection_info = {'driver_volume_type': 'fake',",
            "                               'serial': 'new-volume-id',",
            "                               'data': {'device_path': '/fake-new-volume',",
            "                                        'access_mode': 'rw'}}",
            "        mock_dom = mock.MagicMock()",
            "        guest = libvirt_guest.Guest(mock_dom)",
            "        mock_dom.XMLDesc.return_value = \"\"\"<domain>",
            "          <devices>",
            "            <disk type='file'>",
            "                <source file='/fake-old-volume'/>",
            "                <target dev='vdb' bus='virtio'/>",
            "            </disk>",
            "          </devices>",
            "        </domain>",
            "        \"\"\"",
            "        mock_dom.name.return_value = 'inst'",
            "        mock_dom.UUIDString.return_value = 'uuid'",
            "        get_guest.return_value = guest",
            "        disk_info = {'bus': 'virtio', 'type': 'disk', 'dev': 'vdb'}",
            "        get_volume_config.return_value = mock.MagicMock(",
            "            source_path='/fake-new-volume')",
            "",
            "        bdm = objects.BlockDeviceMapping(self.context,",
            "            **fake_block_device.FakeDbBlockDeviceDict(",
            "                {'id': 2, 'instance_uuid': 'fake-instance',",
            "                 'device_name': '/dev/vdb',",
            "                 'source_type': 'volume',",
            "                 'destination_type': 'volume',",
            "                 'volume_id': 'fake-volume-id-2',",
            "                 'boot_index': 0}))",
            "        get_by_volume_and_instance.return_value = bdm",
            "",
            "        conn.swap_volume(old_connection_info, new_connection_info, instance,",
            "                         '/dev/vdb', 1)",
            "",
            "        get_guest.assert_called_once_with(instance)",
            "        connect_volume.assert_called_once_with(new_connection_info, disk_info)",
            "",
            "        swap_volume.assert_called_once_with(guest, 'vdb',",
            "                                            '/fake-new-volume', 1)",
            "        disconnect_volume.assert_called_once_with(old_connection_info, 'vdb')",
            "        volume_save.assert_called_once_with()",
            "",
            "    def _test_live_snapshot(self, can_quiesce=False, require_quiesce=False):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI())",
            "        mock_dom = mock.MagicMock()",
            "        test_image_meta = self.test_image_meta.copy()",
            "        if require_quiesce:",
            "            test_image_meta = {'properties': {'os_require_quiesce': 'yes'}}",
            "",
            "        with test.nested(",
            "                mock.patch.object(drvr._conn, 'defineXML', create=True),",
            "                mock.patch.object(fake_libvirt_utils, 'get_disk_size'),",
            "                mock.patch.object(fake_libvirt_utils, 'get_disk_backing_file'),",
            "                mock.patch.object(fake_libvirt_utils, 'create_cow_image'),",
            "                mock.patch.object(fake_libvirt_utils, 'chown'),",
            "                mock.patch.object(fake_libvirt_utils, 'extract_snapshot'),",
            "                mock.patch.object(drvr, '_set_quiesced')",
            "        ) as (mock_define, mock_size, mock_backing, mock_create_cow,",
            "              mock_chown, mock_snapshot, mock_quiesce):",
            "",
            "            xmldoc = \"<domain/>\"",
            "            srcfile = \"/first/path\"",
            "            dstfile = \"/second/path\"",
            "            bckfile = \"/other/path\"",
            "            dltfile = dstfile + \".delta\"",
            "",
            "            mock_dom.XMLDesc.return_value = xmldoc",
            "            mock_dom.isPersistent.return_value = True",
            "            mock_size.return_value = 1004009",
            "            mock_backing.return_value = bckfile",
            "            guest = libvirt_guest.Guest(mock_dom)",
            "",
            "            if not can_quiesce:",
            "                mock_quiesce.side_effect = (",
            "                    exception.InstanceQuiesceNotSupported(",
            "                        instance_id=self.test_instance['id'], reason='test'))",
            "",
            "            image_meta = objects.ImageMeta.from_dict(test_image_meta)",
            "            drvr._live_snapshot(self.context, self.test_instance, guest,",
            "                                srcfile, dstfile, \"qcow2\", \"qcow2\", image_meta)",
            "",
            "            mock_dom.XMLDesc.assert_called_once_with(flags=(",
            "                fakelibvirt.VIR_DOMAIN_XML_INACTIVE |",
            "                fakelibvirt.VIR_DOMAIN_XML_SECURE))",
            "            mock_dom.blockRebase.assert_called_once_with(",
            "                srcfile, dltfile, 0, flags=(",
            "                    fakelibvirt.VIR_DOMAIN_BLOCK_REBASE_COPY |",
            "                    fakelibvirt.VIR_DOMAIN_BLOCK_REBASE_REUSE_EXT |",
            "                    fakelibvirt.VIR_DOMAIN_BLOCK_REBASE_SHALLOW))",
            "",
            "            mock_size.assert_called_once_with(srcfile, format=\"qcow2\")",
            "            mock_backing.assert_called_once_with(srcfile, basename=False,",
            "                                                 format=\"qcow2\")",
            "            mock_create_cow.assert_called_once_with(bckfile, dltfile, 1004009)",
            "            mock_chown.assert_called_once_with(dltfile, os.getuid())",
            "            mock_snapshot.assert_called_once_with(dltfile, \"qcow2\",",
            "                                                  dstfile, \"qcow2\")",
            "            mock_define.assert_called_once_with(xmldoc)",
            "            mock_quiesce.assert_any_call(mock.ANY, self.test_instance,",
            "                                         mock.ANY, True)",
            "            if can_quiesce:",
            "                mock_quiesce.assert_any_call(mock.ANY, self.test_instance,",
            "                                             mock.ANY, False)",
            "",
            "    def test_live_snapshot(self):",
            "        self._test_live_snapshot()",
            "",
            "    def test_live_snapshot_with_quiesce(self):",
            "        self._test_live_snapshot(can_quiesce=True)",
            "",
            "    def test_live_snapshot_with_require_quiesce(self):",
            "        self._test_live_snapshot(can_quiesce=True, require_quiesce=True)",
            "",
            "    def test_live_snapshot_with_require_quiesce_fails(self):",
            "        self.assertRaises(exception.InstanceQuiesceNotSupported,",
            "                          self._test_live_snapshot,",
            "                          can_quiesce=False, require_quiesce=True)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, \"_live_migration\")",
            "    def test_live_migration_hostname_valid(self, mock_lm):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr.live_migration(self.context, self.test_instance,",
            "                            \"host1.example.com\",",
            "                            lambda x: x,",
            "                            lambda x: x)",
            "        self.assertEqual(1, mock_lm.call_count)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, \"_live_migration\")",
            "    @mock.patch.object(fake_libvirt_utils, \"is_valid_hostname\")",
            "    def test_live_migration_hostname_invalid(self, mock_hostname, mock_lm):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        mock_hostname.return_value = False",
            "        self.assertRaises(exception.InvalidHostname,",
            "                          drvr.live_migration,",
            "                          self.context, self.test_instance,",
            "                          \"foo/?com=/bin/sh\",",
            "                          lambda x: x,",
            "                          lambda x: x)",
            "",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, \"pause\")",
            "    def test_live_migration_force_complete(self, pause):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr.live_migration_force_complete(self.test_instance)",
            "        pause.assert_called_once_with(self.test_instance)",
            "",
            "    @mock.patch.object(fakelibvirt.virDomain, \"abortJob\")",
            "    def test_live_migration_abort(self, mock_abort):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        dom = fakelibvirt.Domain(drvr._get_connection(), \"<domain/>\", False)",
            "        guest = libvirt_guest.Guest(dom)",
            "        with mock.patch.object(nova.virt.libvirt.host.Host, 'get_guest',",
            "                               return_value=guest):",
            "            drvr.live_migration_abort(self.test_instance)",
            "            self.assertTrue(mock_abort.called)",
            "",
            "    @mock.patch('os.path.exists', return_value=True)",
            "    @mock.patch('tempfile.mkstemp')",
            "    @mock.patch('os.close', return_value=None)",
            "    def test_check_instance_shared_storage_local_raw(self,",
            "                                                 mock_close,",
            "                                                 mock_mkstemp,",
            "                                                 mock_exists):",
            "        instance_uuid = str(uuid.uuid4())",
            "        self.flags(images_type='raw', group='libvirt')",
            "        self.flags(instances_path='/tmp')",
            "        mock_mkstemp.return_value = (-1,",
            "                                     '/tmp/{0}/file'.format(instance_uuid))",
            "        driver = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        temp_file = driver.check_instance_shared_storage_local(self.context,",
            "                                                               instance)",
            "        self.assertEqual('/tmp/{0}/file'.format(instance_uuid),",
            "                         temp_file['filename'])",
            "",
            "    def test_check_instance_shared_storage_local_rbd(self):",
            "        self.flags(images_type='rbd', group='libvirt')",
            "        driver = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(**self.test_instance)",
            "        self.assertIsNone(driver.",
            "                          check_instance_shared_storage_local(self.context,",
            "                                                              instance))",
            "",
            "    def test_version_to_string(self):",
            "        driver = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        string_ver = driver._version_to_string((4, 33, 173))",
            "        self.assertEqual(\"4.33.173\", string_ver)",
            "",
            "    def test_parallels_min_version_fail(self):",
            "        self.flags(virt_type='parallels', group='libvirt')",
            "        driver = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        with mock.patch.object(driver._conn, 'getLibVersion',",
            "                               return_value=1002011):",
            "            self.assertRaises(exception.NovaException,",
            "                              driver.init_host, 'wibble')",
            "",
            "    def test_parallels_min_version_ok(self):",
            "        self.flags(virt_type='parallels', group='libvirt')",
            "        driver = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        with mock.patch.object(driver._conn, 'getLibVersion',",
            "                               return_value=1002012):",
            "            driver.init_host('wibble')",
            "",
            "    def test_get_guest_config_parallels_vm(self):",
            "        self.flags(virt_type='parallels', group='libvirt')",
            "        self.flags(images_type='ploop', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance_ref = objects.Instance(**self.test_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                    _fake_network_info(self, 1),",
            "                                    image_meta, disk_info)",
            "        self.assertEqual(\"parallels\", cfg.virt_type)",
            "        self.assertEqual(instance_ref[\"uuid\"], cfg.uuid)",
            "        self.assertEqual(2 * units.Mi, cfg.memory)",
            "        self.assertEqual(1, cfg.vcpus)",
            "        self.assertEqual(vm_mode.HVM, cfg.os_type)",
            "        self.assertIsNone(cfg.os_root)",
            "        self.assertEqual(6, len(cfg.devices))",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertEqual(cfg.devices[0].driver_format, \"ploop\")",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestDisk)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestInterface)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestInput)",
            "        self.assertIsInstance(cfg.devices[4],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[5],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "",
            "    def test_get_guest_config_parallels_ct(self):",
            "        self.flags(virt_type='parallels', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        ct_instance = self.test_instance.copy()",
            "        ct_instance[\"vm_mode\"] = vm_mode.EXE",
            "        instance_ref = objects.Instance(**ct_instance)",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "",
            "        cfg = drvr._get_guest_config(instance_ref,",
            "                                    _fake_network_info(self, 1),",
            "                                    image_meta, {'mapping': {'disk': {}}})",
            "        self.assertEqual(\"parallels\", cfg.virt_type)",
            "        self.assertEqual(instance_ref[\"uuid\"], cfg.uuid)",
            "        self.assertEqual(2 * units.Mi, cfg.memory)",
            "        self.assertEqual(1, cfg.vcpus)",
            "        self.assertEqual(vm_mode.EXE, cfg.os_type)",
            "        self.assertEqual(\"/sbin/init\", cfg.os_init_path)",
            "        self.assertIsNone(cfg.os_root)",
            "        self.assertEqual(4, len(cfg.devices))",
            "        self.assertIsInstance(cfg.devices[0],",
            "                              vconfig.LibvirtConfigGuestFilesys)",
            "        fs = cfg.devices[0]",
            "        self.assertEqual(fs.source_type, \"file\")",
            "        self.assertEqual(fs.driver_type, \"ploop\")",
            "        self.assertEqual(fs.target_dir, \"/\")",
            "        self.assertIsInstance(cfg.devices[1],",
            "                              vconfig.LibvirtConfigGuestInterface)",
            "        self.assertIsInstance(cfg.devices[2],",
            "                              vconfig.LibvirtConfigGuestGraphics)",
            "        self.assertIsInstance(cfg.devices[3],",
            "                              vconfig.LibvirtConfigGuestVideo)",
            "",
            "    def _test_get_guest_config_parallels_volume(self, vmmode, devices):",
            "        self.flags(virt_type='parallels', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        ct_instance = self.test_instance.copy()",
            "        ct_instance[\"vm_mode\"] = vmmode",
            "        instance_ref = objects.Instance(**ct_instance)",
            "",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        conn_info = {'driver_volume_type': 'fake'}",
            "        bdm = objects.BlockDeviceMapping(",
            "            self.context,",
            "            **fake_block_device.FakeDbBlockDeviceDict(",
            "                {'id': 0,",
            "                 'source_type': 'volume', 'destination_type': 'volume',",
            "                 'device_name': '/dev/sda'}))",
            "        info = {'block_device_mapping': driver_block_device.convert_volumes(",
            "                [bdm])}",
            "        info['block_device_mapping'][0]['connection_info'] = conn_info",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance_ref,",
            "                                            image_meta,",
            "                                            info)",
            "",
            "        with mock.patch.object(",
            "                        driver_block_device.DriverVolumeBlockDevice, 'save'",
            "                                ) as mock_save:",
            "            cfg = drvr._get_guest_config(instance_ref,",
            "                                    _fake_network_info(self, 1),",
            "                                    image_meta, disk_info, None, info)",
            "            mock_save.assert_called_once_with()",
            "",
            "        self.assertEqual(\"parallels\", cfg.virt_type)",
            "        self.assertEqual(instance_ref[\"uuid\"], cfg.uuid)",
            "        self.assertEqual(2 * units.Mi, cfg.memory)",
            "        self.assertEqual(1, cfg.vcpus)",
            "        self.assertEqual(vmmode, cfg.os_type)",
            "        self.assertIsNone(cfg.os_root)",
            "        self.assertEqual(devices, len(cfg.devices))",
            "",
            "        disk_found = False",
            "",
            "        for dev in cfg.devices:",
            "            result = isinstance(dev, vconfig.LibvirtConfigGuestFilesys)",
            "            self.assertFalse(result)",
            "            if (isinstance(dev, vconfig.LibvirtConfigGuestDisk) and",
            "                (dev.source_path is None or",
            "               'disk.local' not in dev.source_path)):",
            "                self.assertEqual(\"disk\", dev.source_device)",
            "                self.assertEqual(\"sda\", dev.target_dev)",
            "                disk_found = True",
            "",
            "        self.assertTrue(disk_found)",
            "",
            "    def test_get_guest_config_parallels_volume(self):",
            "        self._test_get_guest_config_parallels_volume(vm_mode.EXE, 4)",
            "        self._test_get_guest_config_parallels_volume(vm_mode.HVM, 6)",
            "",
            "",
            "class HostStateTestCase(test.NoDBTestCase):",
            "",
            "    cpu_info = {\"vendor\": \"Intel\", \"model\": \"pentium\", \"arch\": \"i686\",",
            "                 \"features\": [\"ssse3\", \"monitor\", \"pni\", \"sse2\", \"sse\",",
            "                 \"fxsr\", \"clflush\", \"pse36\", \"pat\", \"cmov\", \"mca\", \"pge\",",
            "                 \"mtrr\", \"sep\", \"apic\"],",
            "                 \"topology\": {\"cores\": \"1\", \"threads\": \"1\", \"sockets\": \"1\"}}",
            "    instance_caps = [(arch.X86_64, \"kvm\", \"hvm\"),",
            "                     (arch.I686, \"kvm\", \"hvm\")]",
            "    pci_devices = [{",
            "        \"dev_id\": \"pci_0000_04_00_3\",",
            "        \"address\": \"0000:04:10.3\",",
            "        \"product_id\": '1521',",
            "        \"vendor_id\": '8086',",
            "        \"dev_type\": fields.PciDeviceType.SRIOV_PF,",
            "        \"phys_function\": None}]",
            "    numa_topology = objects.NUMATopology(",
            "                        cells=[objects.NUMACell(",
            "                            id=1, cpuset=set([1, 2]), memory=1024,",
            "                            cpu_usage=0, memory_usage=0,",
            "                            mempages=[], siblings=[],",
            "                            pinned_cpus=set([])),",
            "                               objects.NUMACell(",
            "                            id=2, cpuset=set([3, 4]), memory=1024,",
            "                            cpu_usage=0, memory_usage=0,",
            "                            mempages=[], siblings=[],",
            "                            pinned_cpus=set([]))])",
            "",
            "    class FakeConnection(libvirt_driver.LibvirtDriver):",
            "        \"\"\"Fake connection object.\"\"\"",
            "        def __init__(self):",
            "            super(HostStateTestCase.FakeConnection,",
            "                  self).__init__(fake.FakeVirtAPI(), True)",
            "",
            "            self._host = host.Host(\"qemu:///system\")",
            "",
            "            def _get_memory_mb_total():",
            "                return 497",
            "",
            "            def _get_memory_mb_used():",
            "                return 88",
            "",
            "            self._host.get_memory_mb_total = _get_memory_mb_total",
            "            self._host.get_memory_mb_used = _get_memory_mb_used",
            "",
            "        def _get_vcpu_total(self):",
            "            return 1",
            "",
            "        def _get_vcpu_used(self):",
            "            return 0",
            "",
            "        def _get_cpu_info(self):",
            "            return HostStateTestCase.cpu_info",
            "",
            "        def _get_disk_over_committed_size_total(self):",
            "            return 0",
            "",
            "        def _get_local_gb_info(self):",
            "            return {'total': 100, 'used': 20, 'free': 80}",
            "",
            "        def get_host_uptime(self):",
            "            return ('10:01:16 up  1:36,  6 users,  '",
            "                    'load average: 0.21, 0.16, 0.19')",
            "",
            "        def _get_disk_available_least(self):",
            "            return 13091",
            "",
            "        def _get_instance_capabilities(self):",
            "            return HostStateTestCase.instance_caps",
            "",
            "        def _get_pci_passthrough_devices(self):",
            "            return jsonutils.dumps(HostStateTestCase.pci_devices)",
            "",
            "        def _get_host_numa_topology(self):",
            "            return HostStateTestCase.numa_topology",
            "",
            "    @mock.patch.object(fakelibvirt, \"openAuth\")",
            "    def test_update_status(self, mock_open):",
            "        mock_open.return_value = fakelibvirt.Connection(\"qemu:///system\")",
            "",
            "        drvr = HostStateTestCase.FakeConnection()",
            "",
            "        stats = drvr.get_available_resource(\"compute1\")",
            "        self.assertEqual(stats[\"vcpus\"], 1)",
            "        self.assertEqual(stats[\"memory_mb\"], 497)",
            "        self.assertEqual(stats[\"local_gb\"], 100)",
            "        self.assertEqual(stats[\"vcpus_used\"], 0)",
            "        self.assertEqual(stats[\"memory_mb_used\"], 88)",
            "        self.assertEqual(stats[\"local_gb_used\"], 20)",
            "        self.assertEqual(stats[\"hypervisor_type\"], 'QEMU')",
            "        self.assertEqual(stats[\"hypervisor_version\"], 1001000)",
            "        self.assertEqual(stats[\"hypervisor_hostname\"], 'compute1')",
            "        cpu_info = jsonutils.loads(stats[\"cpu_info\"])",
            "        self.assertEqual(cpu_info,",
            "                {\"vendor\": \"Intel\", \"model\": \"pentium\",",
            "                 \"arch\": arch.I686,",
            "                 \"features\": [\"ssse3\", \"monitor\", \"pni\", \"sse2\", \"sse\",",
            "                              \"fxsr\", \"clflush\", \"pse36\", \"pat\", \"cmov\",",
            "                              \"mca\", \"pge\", \"mtrr\", \"sep\", \"apic\"],",
            "                 \"topology\": {\"cores\": \"1\", \"threads\": \"1\", \"sockets\": \"1\"}",
            "                })",
            "        self.assertEqual(stats[\"disk_available_least\"], 80)",
            "        self.assertEqual(jsonutils.loads(stats[\"pci_passthrough_devices\"]),",
            "                         HostStateTestCase.pci_devices)",
            "        self.assertThat(objects.NUMATopology.obj_from_db_obj(",
            "                            stats['numa_topology'])._to_dict(),",
            "                        matchers.DictMatches(",
            "                                HostStateTestCase.numa_topology._to_dict()))",
            "",
            "",
            "class LibvirtDriverTestCase(test.NoDBTestCase):",
            "    \"\"\"Test for nova.virt.libvirt.libvirt_driver.LibvirtDriver.\"\"\"",
            "    def setUp(self):",
            "        super(LibvirtDriverTestCase, self).setUp()",
            "        self.drvr = libvirt_driver.LibvirtDriver(",
            "            fake.FakeVirtAPI(), read_only=True)",
            "        self.context = context.get_admin_context()",
            "        self.test_image_meta = {",
            "            \"disk_format\": \"raw\",",
            "        }",
            "",
            "    def _create_instance(self, params=None):",
            "        \"\"\"Create a test instance.\"\"\"",
            "        if not params:",
            "            params = {}",
            "",
            "        flavor = objects.Flavor(memory_mb=512,",
            "                                swap=0,",
            "                                vcpu_weight=None,",
            "                                root_gb=10,",
            "                                id=2,",
            "                                name=u'm1.tiny',",
            "                                ephemeral_gb=20,",
            "                                rxtx_factor=1.0,",
            "                                flavorid=u'1',",
            "                                vcpus=1)",
            "",
            "        inst = {}",
            "        inst['id'] = 1",
            "        inst['uuid'] = '52d3b512-1152-431f-a8f7-28f0288a622b'",
            "        inst['os_type'] = 'linux'",
            "        inst['image_ref'] = '1'",
            "        inst['reservation_id'] = 'r-fakeres'",
            "        inst['user_id'] = 'fake'",
            "        inst['project_id'] = 'fake'",
            "        inst['instance_type_id'] = 2",
            "        inst['ami_launch_index'] = 0",
            "        inst['host'] = 'host1'",
            "        inst['root_gb'] = flavor.root_gb",
            "        inst['ephemeral_gb'] = flavor.ephemeral_gb",
            "        inst['config_drive'] = True",
            "        inst['kernel_id'] = 2",
            "        inst['ramdisk_id'] = 3",
            "        inst['key_data'] = 'ABCDEFG'",
            "        inst['system_metadata'] = {}",
            "        inst['metadata'] = {}",
            "        inst['task_state'] = None",
            "",
            "        inst.update(params)",
            "",
            "        return objects.Instance(flavor=flavor,",
            "                                old_flavor=None, new_flavor=None,",
            "                                **inst)",
            "",
            "    @staticmethod",
            "    def _disk_info():",
            "        # 10G root and 512M swap disk",
            "        disk_info = [{'disk_size': 1, 'type': 'qcow2',",
            "                      'virt_disk_size': 10737418240, 'path': '/test/disk',",
            "                      'backing_file': '/base/disk'},",
            "                     {'disk_size': 1, 'type': 'qcow2',",
            "                      'virt_disk_size': 536870912, 'path': '/test/disk.swap',",
            "                      'backing_file': '/base/swap_512'}]",
            "        return jsonutils.dumps(disk_info)",
            "",
            "    def test_migrate_disk_and_power_off_exception(self):",
            "        \"\"\"Test for nova.virt.libvirt.libvirt_driver.LivirtConnection",
            "        .migrate_disk_and_power_off.",
            "        \"\"\"",
            "",
            "        self.counter = 0",
            "        self.checked_shared_storage = False",
            "",
            "        def fake_get_instance_disk_info(instance,",
            "                                        block_device_info=None):",
            "            return '[]'",
            "",
            "        def fake_destroy(instance):",
            "            pass",
            "",
            "        def fake_get_host_ip_addr():",
            "            return '10.0.0.1'",
            "",
            "        def fake_execute(*args, **kwargs):",
            "            self.counter += 1",
            "            if self.counter == 1:",
            "                assert False, \"intentional failure\"",
            "",
            "        def fake_os_path_exists(path):",
            "            return True",
            "",
            "        def fake_is_storage_shared(dest, inst_base):",
            "            self.checked_shared_storage = True",
            "            return False",
            "",
            "        self.stubs.Set(self.drvr, 'get_instance_disk_info',",
            "                       fake_get_instance_disk_info)",
            "        self.stubs.Set(self.drvr, '_destroy', fake_destroy)",
            "        self.stubs.Set(self.drvr, 'get_host_ip_addr',",
            "                       fake_get_host_ip_addr)",
            "        self.stubs.Set(self.drvr, '_is_storage_shared_with',",
            "                       fake_is_storage_shared)",
            "        self.stubs.Set(utils, 'execute', fake_execute)",
            "        self.stub_out('os.path.exists', fake_os_path_exists)",
            "",
            "        ins_ref = self._create_instance()",
            "        flavor = {'root_gb': 10, 'ephemeral_gb': 20}",
            "        flavor_obj = objects.Flavor(**flavor)",
            "",
            "        self.assertRaises(AssertionError,",
            "                          self.drvr.migrate_disk_and_power_off,",
            "                          context.get_admin_context(), ins_ref, '10.0.0.2',",
            "                          flavor_obj, None)",
            "",
            "    def _test_migrate_disk_and_power_off(self, flavor_obj,",
            "                                         block_device_info=None,",
            "                                         params_for_instance=None):",
            "        \"\"\"Test for nova.virt.libvirt.libvirt_driver.LivirtConnection",
            "        .migrate_disk_and_power_off.",
            "        \"\"\"",
            "",
            "        disk_info = self._disk_info()",
            "",
            "        def fake_get_instance_disk_info(instance,",
            "                                        block_device_info=None):",
            "            return disk_info",
            "",
            "        def fake_destroy(instance):",
            "            pass",
            "",
            "        def fake_get_host_ip_addr():",
            "            return '10.0.0.1'",
            "",
            "        def fake_execute(*args, **kwargs):",
            "            pass",
            "",
            "        def fake_copy_image(src, dest, host=None, receive=False,",
            "                            on_execute=None, on_completion=None,",
            "                            compression=True):",
            "            self.assertIsNotNone(on_execute)",
            "            self.assertIsNotNone(on_completion)",
            "",
            "        self.stubs.Set(self.drvr, 'get_instance_disk_info',",
            "                       fake_get_instance_disk_info)",
            "        self.stubs.Set(self.drvr, '_destroy', fake_destroy)",
            "        self.stubs.Set(self.drvr, 'get_host_ip_addr',",
            "                       fake_get_host_ip_addr)",
            "        self.stubs.Set(utils, 'execute', fake_execute)",
            "        self.stubs.Set(libvirt_utils, 'copy_image', fake_copy_image)",
            "",
            "        ins_ref = self._create_instance(params=params_for_instance)",
            "",
            "        # dest is different host case",
            "        out = self.drvr.migrate_disk_and_power_off(",
            "               context.get_admin_context(), ins_ref, '10.0.0.2',",
            "               flavor_obj, None, block_device_info=block_device_info)",
            "        self.assertEqual(out, disk_info)",
            "",
            "        # dest is same host case",
            "        out = self.drvr.migrate_disk_and_power_off(",
            "               context.get_admin_context(), ins_ref, '10.0.0.1',",
            "               flavor_obj, None, block_device_info=block_device_info)",
            "        self.assertEqual(out, disk_info)",
            "",
            "    def test_migrate_disk_and_power_off(self):",
            "        flavor = {'root_gb': 10, 'ephemeral_gb': 20}",
            "        flavor_obj = objects.Flavor(**flavor)",
            "",
            "        self._test_migrate_disk_and_power_off(flavor_obj)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._disconnect_volume')",
            "    def test_migrate_disk_and_power_off_boot_from_volume(self,",
            "                                                         disconnect_volume):",
            "        info = {'block_device_mapping': [{'boot_index': None,",
            "                                          'mount_device': '/dev/vdd',",
            "                                          'connection_info': None},",
            "                                         {'boot_index': 0,",
            "                                          'mount_device': '/dev/vda',",
            "                                          'connection_info': None}]}",
            "        flavor = {'root_gb': 1, 'ephemeral_gb': 0}",
            "        flavor_obj = objects.Flavor(**flavor)",
            "        # Note(Mike_D): The size of instance's ephemeral_gb is 0 gb.",
            "        self._test_migrate_disk_and_power_off(",
            "            flavor_obj, block_device_info=info,",
            "            params_for_instance={'image_ref': None, 'ephemeral_gb': 0})",
            "        disconnect_volume.assert_called_with(",
            "            info['block_device_mapping'][1]['connection_info'], 'vda')",
            "",
            "    @mock.patch('nova.utils.execute')",
            "    @mock.patch('nova.virt.libvirt.utils.copy_image')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._destroy')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.get_host_ip_addr')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver'",
            "                '.get_instance_disk_info')",
            "    def test_migrate_disk_and_power_off_swap(self, mock_get_disk_info,",
            "                                             get_host_ip_addr,",
            "                                             mock_destroy,",
            "                                             mock_copy_image,",
            "                                             mock_execute):",
            "        \"\"\"Test for nova.virt.libvirt.libvirt_driver.LivirtConnection",
            "        .migrate_disk_and_power_off.",
            "        \"\"\"",
            "        self.copy_or_move_swap_called = False",
            "",
            "        disk_info = self._disk_info()",
            "        mock_get_disk_info.return_value = disk_info",
            "        get_host_ip_addr.return_value = '10.0.0.1'",
            "",
            "        def fake_copy_image(*args, **kwargs):",
            "            # disk.swap should not be touched since it is skipped over",
            "            if '/test/disk.swap' in list(args):",
            "                self.copy_or_move_swap_called = True",
            "",
            "        def fake_execute(*args, **kwargs):",
            "            # disk.swap should not be touched since it is skipped over",
            "            if set(['mv', '/test/disk.swap']).issubset(list(args)):",
            "                self.copy_or_move_swap_called = True",
            "",
            "        mock_copy_image.side_effect = fake_copy_image",
            "        mock_execute.side_effect = fake_execute",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        # Original instance config",
            "        instance = self._create_instance({'root_gb': 10,",
            "                                          'ephemeral_gb': 0})",
            "",
            "        # Re-size fake instance to 20G root and 1024M swap disk",
            "        flavor = {'root_gb': 20, 'ephemeral_gb': 0, 'swap': 1024}",
            "        flavor_obj = objects.Flavor(**flavor)",
            "",
            "        # Destination is same host",
            "        out = drvr.migrate_disk_and_power_off(context.get_admin_context(),",
            "                                              instance, '10.0.0.1',",
            "                                              flavor_obj, None)",
            "",
            "        mock_get_disk_info.assert_called_once_with(instance,",
            "                                                   block_device_info=None)",
            "        self.assertTrue(get_host_ip_addr.called)",
            "        mock_destroy.assert_called_once_with(instance)",
            "        self.assertFalse(self.copy_or_move_swap_called)",
            "        self.assertEqual(disk_info, out)",
            "",
            "    def _test_migrate_disk_and_power_off_resize_check(self, expected_exc):",
            "        \"\"\"Test for nova.virt.libvirt.libvirt_driver.LibvirtConnection",
            "        .migrate_disk_and_power_off.",
            "        \"\"\"",
            "",
            "        def fake_get_instance_disk_info(instance, xml=None,",
            "                                        block_device_info=None):",
            "            return self._disk_info()",
            "",
            "        def fake_destroy(instance):",
            "            pass",
            "",
            "        def fake_get_host_ip_addr():",
            "            return '10.0.0.1'",
            "",
            "        self.stubs.Set(self.drvr, 'get_instance_disk_info',",
            "                       fake_get_instance_disk_info)",
            "        self.stubs.Set(self.drvr, '_destroy', fake_destroy)",
            "        self.stubs.Set(self.drvr, 'get_host_ip_addr',",
            "                       fake_get_host_ip_addr)",
            "",
            "        ins_ref = self._create_instance()",
            "        flavor = {'root_gb': 10, 'ephemeral_gb': 20}",
            "        flavor_obj = objects.Flavor(**flavor)",
            "",
            "        # Migration is not implemented for LVM backed instances",
            "        self.assertRaises(expected_exc,",
            "              self.drvr.migrate_disk_and_power_off,",
            "              None, ins_ref, '10.0.0.1', flavor_obj, None)",
            "",
            "    @mock.patch('nova.utils.execute')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._destroy')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver'",
            "                '.get_instance_disk_info')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver'",
            "                '._is_storage_shared_with')",
            "    def _test_migrate_disk_and_power_off_backing_file(self,",
            "                                                      shared_storage,",
            "                                                      mock_is_shared_storage,",
            "                                                      mock_get_disk_info,",
            "                                                      mock_destroy,",
            "                                                      mock_execute):",
            "        self.convert_file_called = False",
            "        flavor = {'root_gb': 20, 'ephemeral_gb': 30, 'swap': 0}",
            "        flavor_obj = objects.Flavor(**flavor)",
            "        disk_info = [{'type': 'qcow2', 'path': '/test/disk',",
            "                      'virt_disk_size': '10737418240',",
            "                      'backing_file': '/base/disk',",
            "                      'disk_size': '83886080'}]",
            "        disk_info_text = jsonutils.dumps(disk_info)",
            "        mock_get_disk_info.return_value = disk_info_text",
            "        mock_is_shared_storage.return_value = shared_storage",
            "",
            "        def fake_execute(*args, **kwargs):",
            "            self.assertNotEqual(args[0:2], ['qemu-img', 'convert'])",
            "",
            "        mock_execute.side_effect = fake_execute",
            "",
            "        instance = self._create_instance()",
            "",
            "        out = self.drvr.migrate_disk_and_power_off(",
            "               context.get_admin_context(), instance, '10.0.0.2',",
            "               flavor_obj, None)",
            "",
            "        self.assertTrue(mock_is_shared_storage.called)",
            "        mock_destroy.assert_called_once_with(instance)",
            "        self.assertEqual(out, disk_info_text)",
            "",
            "    def test_migrate_disk_and_power_off_shared_storage(self):",
            "        self._test_migrate_disk_and_power_off_backing_file(True)",
            "",
            "    def test_migrate_disk_and_power_off_non_shared_storage(self):",
            "        self._test_migrate_disk_and_power_off_backing_file(False)",
            "",
            "    def test_migrate_disk_and_power_off_lvm(self):",
            "        self.flags(images_type='lvm', group='libvirt')",
            "",
            "        def fake_execute(*args, **kwargs):",
            "            pass",
            "",
            "        self.stubs.Set(utils, 'execute', fake_execute)",
            "",
            "        expected_exc = exception.InstanceFaultRollback",
            "        self._test_migrate_disk_and_power_off_resize_check(expected_exc)",
            "",
            "    def test_migrate_disk_and_power_off_resize_cannot_ssh(self):",
            "        def fake_execute(*args, **kwargs):",
            "            raise processutils.ProcessExecutionError()",
            "",
            "        def fake_is_storage_shared(dest, inst_base):",
            "            self.checked_shared_storage = True",
            "            return False",
            "",
            "        self.stubs.Set(self.drvr, '_is_storage_shared_with',",
            "                       fake_is_storage_shared)",
            "        self.stubs.Set(utils, 'execute', fake_execute)",
            "",
            "        expected_exc = exception.InstanceFaultRollback",
            "        self._test_migrate_disk_and_power_off_resize_check(expected_exc)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver'",
            "                '.get_instance_disk_info')",
            "    def test_migrate_disk_and_power_off_resize_error(self, mock_get_disk_info):",
            "        instance = self._create_instance()",
            "        flavor = {'root_gb': 5, 'ephemeral_gb': 10}",
            "        flavor_obj = objects.Flavor(**flavor)",
            "        mock_get_disk_info.return_value = self._disk_info()",
            "",
            "        self.assertRaises(",
            "            exception.InstanceFaultRollback,",
            "            self.drvr.migrate_disk_and_power_off,",
            "            'ctx', instance, '10.0.0.1', flavor_obj, None)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver'",
            "                '.get_instance_disk_info')",
            "    def test_migrate_disk_and_power_off_resize_error_default_ephemeral(",
            "            self, mock_get_disk_info):",
            "        # Note(Mike_D): The size of this instance's ephemeral_gb is 20 gb.",
            "        instance = self._create_instance()",
            "        flavor = {'root_gb': 10, 'ephemeral_gb': 0}",
            "        flavor_obj = objects.Flavor(**flavor)",
            "        mock_get_disk_info.return_value = self._disk_info()",
            "",
            "        self.assertRaises(exception.InstanceFaultRollback,",
            "                          self.drvr.migrate_disk_and_power_off,",
            "                          'ctx', instance, '10.0.0.1', flavor_obj, None)",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver'",
            "                '.get_instance_disk_info')",
            "    @mock.patch('nova.virt.driver.block_device_info_get_ephemerals')",
            "    def test_migrate_disk_and_power_off_resize_error_eph(self, mock_get,",
            "                                                         mock_get_disk_info):",
            "        mappings = [",
            "            {",
            "                 'device_name': '/dev/sdb4',",
            "                 'source_type': 'blank',",
            "                 'destination_type': 'local',",
            "                 'device_type': 'disk',",
            "                 'guest_format': 'swap',",
            "                 'boot_index': -1,",
            "                 'volume_size': 1",
            "             },",
            "             {",
            "                 'device_name': '/dev/sda1',",
            "                 'source_type': 'volume',",
            "                 'destination_type': 'volume',",
            "                 'device_type': 'disk',",
            "                 'volume_id': 1,",
            "                 'guest_format': None,",
            "                 'boot_index': 1,",
            "                 'volume_size': 6",
            "             },",
            "             {",
            "                 'device_name': '/dev/sda2',",
            "                 'source_type': 'snapshot',",
            "                 'destination_type': 'volume',",
            "                 'snapshot_id': 1,",
            "                 'device_type': 'disk',",
            "                 'guest_format': None,",
            "                 'boot_index': 0,",
            "                 'volume_size': 4",
            "             },",
            "             {",
            "                 'device_name': '/dev/sda3',",
            "                 'source_type': 'blank',",
            "                 'destination_type': 'local',",
            "                 'device_type': 'disk',",
            "                 'guest_format': None,",
            "                 'boot_index': -1,",
            "                 'volume_size': 3",
            "             }",
            "        ]",
            "        mock_get.return_value = mappings",
            "        instance = self._create_instance()",
            "",
            "        # Old flavor, eph is 20, real disk is 3, target is 2, fail",
            "        flavor = {'root_gb': 10, 'ephemeral_gb': 2}",
            "        flavor_obj = objects.Flavor(**flavor)",
            "        mock_get_disk_info.return_value = self._disk_info()",
            "",
            "        self.assertRaises(",
            "            exception.InstanceFaultRollback,",
            "            self.drvr.migrate_disk_and_power_off,",
            "            'ctx', instance, '10.0.0.1', flavor_obj, None)",
            "",
            "        # Old flavor, eph is 20, real disk is 3, target is 4",
            "        flavor = {'root_gb': 10, 'ephemeral_gb': 4}",
            "        flavor_obj = objects.Flavor(**flavor)",
            "        self._test_migrate_disk_and_power_off(flavor_obj)",
            "",
            "    @mock.patch('nova.utils.execute')",
            "    @mock.patch('nova.virt.libvirt.utils.copy_image')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._destroy')",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver'",
            "                '._is_storage_shared_with')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver'",
            "                '.get_instance_disk_info')",
            "    def test_migrate_disk_and_power_off_resize_copy_disk_info(self,",
            "                                                              mock_disk_info,",
            "                                                              mock_shared,",
            "                                                              mock_path,",
            "                                                              mock_destroy,",
            "                                                              mock_copy,",
            "                                                              mock_execuate):",
            "",
            "        instance = self._create_instance()",
            "        disk_info = self._disk_info()",
            "        disk_info_text = jsonutils.loads(disk_info)",
            "        instance_base = os.path.dirname(disk_info_text[0]['path'])",
            "        flavor = {'root_gb': 10, 'ephemeral_gb': 25}",
            "        flavor_obj = objects.Flavor(**flavor)",
            "",
            "        mock_disk_info.return_value = disk_info",
            "        mock_path.return_value = instance_base",
            "        mock_shared.return_value = False",
            "",
            "        self.drvr.migrate_disk_and_power_off(context.get_admin_context(),",
            "                                             instance, mock.sentinel,",
            "                                             flavor_obj, None)",
            "",
            "        src_disk_info_path = os.path.join(instance_base + '_resize',",
            "                                          'disk.info')",
            "        dst_disk_info_path = os.path.join(instance_base, 'disk.info')",
            "        mock_copy.assert_any_call(src_disk_info_path, dst_disk_info_path,",
            "                                  host=mock.sentinel, on_execute=mock.ANY,",
            "                                  on_completion=mock.ANY, compression=mock.ANY)",
            "",
            "    def test_wait_for_running(self):",
            "        def fake_get_info(instance):",
            "            if instance['name'] == \"not_found\":",
            "                raise exception.InstanceNotFound(instance_id=instance['uuid'])",
            "            elif instance['name'] == \"running\":",
            "                return hardware.InstanceInfo(state=power_state.RUNNING)",
            "            else:",
            "                return hardware.InstanceInfo(state=power_state.SHUTDOWN)",
            "",
            "        self.stubs.Set(self.drvr, 'get_info',",
            "                       fake_get_info)",
            "",
            "        # instance not found case",
            "        self.assertRaises(exception.InstanceNotFound,",
            "                self.drvr._wait_for_running,",
            "                    {'name': 'not_found',",
            "                     'uuid': 'not_found_uuid'})",
            "",
            "        # instance is running case",
            "        self.assertRaises(loopingcall.LoopingCallDone,",
            "                self.drvr._wait_for_running,",
            "                    {'name': 'running',",
            "                     'uuid': 'running_uuid'})",
            "",
            "        # else case",
            "        self.drvr._wait_for_running({'name': 'else',",
            "                                                  'uuid': 'other_uuid'})",
            "",
            "    def test_disk_size_from_instance_disk_info(self):",
            "        instance_data = {'root_gb': 10, 'ephemeral_gb': 20, 'swap_gb': 30}",
            "        inst = objects.Instance(**instance_data)",
            "        info = {'path': '/path/disk'}",
            "        self.assertEqual(10 * units.Gi,",
            "            self.drvr._disk_size_from_instance(inst, info))",
            "",
            "        info = {'path': '/path/disk.local'}",
            "        self.assertEqual(20 * units.Gi,",
            "            self.drvr._disk_size_from_instance(inst, info))",
            "",
            "        info = {'path': '/path/disk.swap'}",
            "        self.assertEqual(0,",
            "            self.drvr._disk_size_from_instance(inst, info))",
            "",
            "    @mock.patch('nova.utils.execute')",
            "    def test_disk_raw_to_qcow2(self, mock_execute):",
            "        path = '/test/disk'",
            "        _path_qcow = path + '_qcow'",
            "",
            "        self.drvr._disk_raw_to_qcow2(path)",
            "        mock_execute.assert_has_calls([",
            "            mock.call('qemu-img', 'convert', '-f', 'raw',",
            "                      '-O', 'qcow2', path, _path_qcow),",
            "            mock.call('mv', _path_qcow, path)])",
            "",
            "    @mock.patch('nova.utils.execute')",
            "    def test_disk_qcow2_to_raw(self, mock_execute):",
            "        path = '/test/disk'",
            "        _path_raw = path + '_raw'",
            "",
            "        self.drvr._disk_qcow2_to_raw(path)",
            "        mock_execute.assert_has_calls([",
            "            mock.call('qemu-img', 'convert', '-f', 'qcow2',",
            "                      '-O', 'raw', path, _path_raw),",
            "            mock.call('mv', _path_raw, path)])",
            "",
            "    @mock.patch('nova.virt.disk.api.extend')",
            "    def test_disk_resize_raw(self, mock_extend):",
            "        image = imgmodel.LocalFileImage(\"/test/disk\",",
            "                                        imgmodel.FORMAT_RAW)",
            "",
            "        self.drvr._disk_resize(image, 50)",
            "        mock_extend.assert_called_once_with(image, 50)",
            "",
            "    @mock.patch('nova.virt.disk.api.can_resize_image')",
            "    @mock.patch('nova.virt.disk.api.is_image_extendable')",
            "    @mock.patch('nova.virt.disk.api.extend')",
            "    def test_disk_resize_qcow2(",
            "            self, mock_extend, mock_can_resize, mock_is_image_extendable):",
            "",
            "        with test.nested(",
            "                mock.patch.object(",
            "                    self.drvr, '_disk_qcow2_to_raw'),",
            "                mock.patch.object(",
            "                    self.drvr, '_disk_raw_to_qcow2'))\\",
            "        as (mock_disk_qcow2_to_raw, mock_disk_raw_to_qcow2):",
            "",
            "            mock_can_resize.return_value = True",
            "            mock_is_image_extendable.return_value = True",
            "",
            "            imageqcow2 = imgmodel.LocalFileImage(\"/test/disk\",",
            "                                                 imgmodel.FORMAT_QCOW2)",
            "            imageraw = imgmodel.LocalFileImage(\"/test/disk\",",
            "                                               imgmodel.FORMAT_RAW)",
            "            self.drvr._disk_resize(imageqcow2, 50)",
            "",
            "            mock_disk_qcow2_to_raw.assert_called_once_with(imageqcow2.path)",
            "            mock_extend.assert_called_once_with(imageraw, 50)",
            "            mock_disk_raw_to_qcow2.assert_called_once_with(imageqcow2.path)",
            "",
            "    def _test_finish_migration(self, power_on, resize_instance=False):",
            "        \"\"\"Test for nova.virt.libvirt.libvirt_driver.LivirtConnection",
            "        .finish_migration.",
            "        \"\"\"",
            "",
            "        powered_on = power_on",
            "        self.fake_create_domain_called = False",
            "        self.fake_disk_resize_called = False",
            "",
            "        def fake_to_xml(context, instance, network_info, disk_info,",
            "                        image_meta=None, rescue=None,",
            "                        block_device_info=None, write_to_disk=False):",
            "            return \"\"",
            "",
            "        def fake_plug_vifs(instance, network_info):",
            "            pass",
            "",
            "        def fake_create_image(context, inst,",
            "                              disk_mapping, suffix='',",
            "                              disk_images=None, network_info=None,",
            "                              block_device_info=None, inject_files=True,",
            "                              fallback_from_host=None):",
            "            self.assertFalse(inject_files)",
            "",
            "        def fake_create_domain_and_network(",
            "            context, xml, instance, network_info, disk_info,",
            "            block_device_info=None, power_on=True, reboot=False,",
            "            vifs_already_plugged=False):",
            "            self.fake_create_domain_called = True",
            "            self.assertEqual(powered_on, power_on)",
            "            self.assertTrue(vifs_already_plugged)",
            "",
            "        def fake_enable_hairpin():",
            "            pass",
            "",
            "        def fake_execute(*args, **kwargs):",
            "            pass",
            "",
            "        def fake_get_info(instance):",
            "            if powered_on:",
            "                return hardware.InstanceInfo(state=power_state.RUNNING)",
            "            else:",
            "                return hardware.InstanceInfo(state=power_state.SHUTDOWN)",
            "",
            "        def fake_disk_resize(image, size):",
            "            self.fake_disk_resize_called = True",
            "",
            "        self.flags(use_cow_images=True)",
            "        self.stubs.Set(self.drvr, '_disk_resize',",
            "                       fake_disk_resize)",
            "        self.stubs.Set(self.drvr, '_get_guest_xml', fake_to_xml)",
            "        self.stubs.Set(self.drvr, 'plug_vifs', fake_plug_vifs)",
            "        self.stubs.Set(self.drvr, '_create_image',",
            "                       fake_create_image)",
            "        self.stubs.Set(self.drvr, '_create_domain_and_network',",
            "                       fake_create_domain_and_network)",
            "        self.stubs.Set(nova.virt.libvirt.guest.Guest, 'enable_hairpin',",
            "                       fake_enable_hairpin)",
            "        self.stubs.Set(utils, 'execute', fake_execute)",
            "        fw = base_firewall.NoopFirewallDriver()",
            "        self.stubs.Set(self.drvr, 'firewall_driver', fw)",
            "        self.stubs.Set(self.drvr, 'get_info',",
            "                       fake_get_info)",
            "",
            "        ins_ref = self._create_instance()",
            "",
            "        migration = objects.Migration()",
            "        migration.source_compute = 'fake-source-compute'",
            "        migration.dest_compute = 'fake-dest-compute'",
            "        migration.source_node = 'fake-source-node'",
            "        migration.dest_node = 'fake-dest-node'",
            "        image_meta = objects.ImageMeta.from_dict(self.test_image_meta)",
            "        self.drvr.finish_migration(",
            "                      context.get_admin_context(), migration, ins_ref,",
            "                      self._disk_info(), [], image_meta,",
            "                      resize_instance, None, power_on)",
            "        self.assertTrue(self.fake_create_domain_called)",
            "        self.assertEqual(",
            "            resize_instance, self.fake_disk_resize_called)",
            "",
            "    def test_finish_migration_resize(self):",
            "        self._test_finish_migration(True, resize_instance=True)",
            "",
            "    def test_finish_migration_power_on(self):",
            "        self._test_finish_migration(True)",
            "",
            "    def test_finish_migration_power_off(self):",
            "        self._test_finish_migration(False)",
            "",
            "    def _test_finish_revert_migration(self, power_on):",
            "        \"\"\"Test for nova.virt.libvirt.libvirt_driver.LivirtConnection",
            "        .finish_revert_migration.",
            "        \"\"\"",
            "        powered_on = power_on",
            "",
            "        self.fake_create_domain_called = False",
            "",
            "        def fake_execute(*args, **kwargs):",
            "            pass",
            "",
            "        def fake_plug_vifs(instance, network_info):",
            "            pass",
            "",
            "        def fake_create_domain(context, xml, instance, network_info,",
            "                               disk_info, block_device_info=None,",
            "                               power_on=None,",
            "                               vifs_already_plugged=None):",
            "            self.fake_create_domain_called = True",
            "            self.assertEqual(powered_on, power_on)",
            "            self.assertTrue(vifs_already_plugged)",
            "            return mock.MagicMock()",
            "",
            "        def fake_enable_hairpin():",
            "            pass",
            "",
            "        def fake_get_info(instance):",
            "            if powered_on:",
            "                return hardware.InstanceInfo(state=power_state.RUNNING)",
            "            else:",
            "                return hardware.InstanceInfo(state=power_state.SHUTDOWN)",
            "",
            "        def fake_to_xml(context, instance, network_info, disk_info,",
            "                        image_meta=None, rescue=None,",
            "                        block_device_info=None):",
            "            return \"\"",
            "",
            "        self.stubs.Set(self.drvr, '_get_guest_xml', fake_to_xml)",
            "        self.stubs.Set(self.drvr, 'plug_vifs', fake_plug_vifs)",
            "        self.stubs.Set(utils, 'execute', fake_execute)",
            "        fw = base_firewall.NoopFirewallDriver()",
            "        self.stubs.Set(self.drvr, 'firewall_driver', fw)",
            "        self.stubs.Set(self.drvr, '_create_domain_and_network',",
            "                       fake_create_domain)",
            "        self.stubs.Set(nova.virt.libvirt.guest.Guest, 'enable_hairpin',",
            "                       fake_enable_hairpin)",
            "        self.stubs.Set(self.drvr, 'get_info',",
            "                       fake_get_info)",
            "        self.stubs.Set(utils, 'get_image_from_system_metadata',",
            "                       lambda *a: self.test_image_meta)",
            "",
            "        with utils.tempdir() as tmpdir:",
            "            self.flags(instances_path=tmpdir)",
            "            ins_ref = self._create_instance()",
            "            os.mkdir(os.path.join(tmpdir, ins_ref['name']))",
            "            libvirt_xml_path = os.path.join(tmpdir,",
            "                                            ins_ref['name'],",
            "                                            'libvirt.xml')",
            "            f = open(libvirt_xml_path, 'w')",
            "            f.close()",
            "",
            "            self.drvr.finish_revert_migration(",
            "                                       context.get_admin_context(), ins_ref,",
            "                                       [], None, power_on)",
            "            self.assertTrue(self.fake_create_domain_called)",
            "",
            "    def test_finish_revert_migration_power_on(self):",
            "        self._test_finish_revert_migration(True)",
            "",
            "    def test_finish_revert_migration_power_off(self):",
            "        self._test_finish_revert_migration(False)",
            "",
            "    def _test_finish_revert_migration_after_crash(self, backup_made=True,",
            "                                                  del_inst_failed=False):",
            "        class FakeLoopingCall(object):",
            "            def start(self, *a, **k):",
            "                return self",
            "",
            "            def wait(self):",
            "                return None",
            "        context = 'fake_context'",
            "",
            "        instance = self._create_instance()",
            "        self.mox.StubOutWithMock(imagebackend.Backend, 'image')",
            "        self.mox.StubOutWithMock(libvirt_utils, 'get_instance_path')",
            "        self.mox.StubOutWithMock(os.path, 'exists')",
            "        self.mox.StubOutWithMock(shutil, 'rmtree')",
            "        self.mox.StubOutWithMock(utils, 'execute')",
            "",
            "        self.stubs.Set(blockinfo, 'get_disk_info', lambda *a: None)",
            "        self.stubs.Set(self.drvr, '_get_guest_xml',",
            "                       lambda *a, **k: None)",
            "        self.stubs.Set(self.drvr, '_create_domain_and_network',",
            "                       lambda *a, **kw: None)",
            "        self.stubs.Set(loopingcall, 'FixedIntervalLoopingCall',",
            "                       lambda *a, **k: FakeLoopingCall())",
            "",
            "        libvirt_utils.get_instance_path(instance).AndReturn('/fake/foo')",
            "        os.path.exists('/fake/foo_resize').AndReturn(backup_made)",
            "        if backup_made:",
            "            if del_inst_failed:",
            "                os_error = OSError(errno.ENOENT, 'No such file or directory')",
            "                shutil.rmtree('/fake/foo').AndRaise(os_error)",
            "            else:",
            "                shutil.rmtree('/fake/foo')",
            "            utils.execute('mv', '/fake/foo_resize', '/fake/foo')",
            "",
            "        imagebackend.Backend.image(mox.IgnoreArg(), 'disk').AndReturn(",
            "                fake_imagebackend.Raw())",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.drvr.finish_revert_migration(context, instance, [])",
            "",
            "    def test_finish_revert_migration_after_crash(self):",
            "        self._test_finish_revert_migration_after_crash(backup_made=True)",
            "",
            "    def test_finish_revert_migration_after_crash_before_new(self):",
            "        self._test_finish_revert_migration_after_crash(backup_made=True)",
            "",
            "    def test_finish_revert_migration_after_crash_before_backup(self):",
            "        self._test_finish_revert_migration_after_crash(backup_made=False)",
            "",
            "    def test_finish_revert_migration_after_crash_delete_failed(self):",
            "        self._test_finish_revert_migration_after_crash(backup_made=True,",
            "                                                       del_inst_failed=True)",
            "",
            "    def test_finish_revert_migration_preserves_disk_bus(self):",
            "",
            "        def fake_get_guest_xml(context, instance, network_info, disk_info,",
            "                               image_meta, block_device_info=None):",
            "            self.assertEqual('ide', disk_info['disk_bus'])",
            "",
            "        image_meta = {\"disk_format\": \"raw\",",
            "                      \"properties\": {\"hw_disk_bus\": \"ide\"}}",
            "        instance = self._create_instance()",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "",
            "        with test.nested(",
            "                mock.patch.object(drvr, '_create_domain_and_network'),",
            "                mock.patch.object(utils, 'get_image_from_system_metadata',",
            "                                  return_value=image_meta),",
            "                mock.patch.object(drvr, '_get_guest_xml',",
            "                                  side_effect=fake_get_guest_xml)):",
            "            drvr.finish_revert_migration('', instance, None, power_on=False)",
            "",
            "    def test_finish_revert_migration_snap_backend(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr.image_backend = mock.Mock()",
            "        drvr.image_backend.image.return_value = drvr.image_backend",
            "        ins_ref = self._create_instance()",
            "",
            "        with test.nested(",
            "                mock.patch.object(utils, 'get_image_from_system_metadata'),",
            "                mock.patch.object(drvr, '_create_domain_and_network'),",
            "                mock.patch.object(drvr, '_get_guest_xml')) as (",
            "                mock_image, mock_cdn, mock_ggx):",
            "            mock_image.return_value = {'disk_format': 'raw'}",
            "            drvr.finish_revert_migration('', ins_ref, None, power_on=False)",
            "",
            "            drvr.image_backend.rollback_to_snap.assert_called_once_with(",
            "                    libvirt_utils.RESIZE_SNAPSHOT_NAME)",
            "            drvr.image_backend.remove_snap.assert_called_once_with(",
            "                    libvirt_utils.RESIZE_SNAPSHOT_NAME, ignore_errors=True)",
            "",
            "    def test_finish_revert_migration_snap_backend_snapshot_not_found(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr.image_backend = mock.Mock()",
            "        drvr.image_backend.image.return_value = drvr.image_backend",
            "        ins_ref = self._create_instance()",
            "",
            "        with test.nested(",
            "                mock.patch.object(rbd_utils, 'RBDDriver'),",
            "                mock.patch.object(utils, 'get_image_from_system_metadata'),",
            "                mock.patch.object(drvr, '_create_domain_and_network'),",
            "                mock.patch.object(drvr, '_get_guest_xml')) as (",
            "                mock_rbd, mock_image, mock_cdn, mock_ggx):",
            "            mock_image.return_value = {'disk_format': 'raw'}",
            "            mock_rbd.rollback_to_snap.side_effect = exception.SnapshotNotFound(",
            "                    snapshot_id='testing')",
            "            drvr.finish_revert_migration('', ins_ref, None, power_on=False)",
            "",
            "            drvr.image_backend.remove_snap.assert_called_once_with(",
            "                    libvirt_utils.RESIZE_SNAPSHOT_NAME, ignore_errors=True)",
            "",
            "    def test_cleanup_failed_migration(self):",
            "        self.mox.StubOutWithMock(shutil, 'rmtree')",
            "        shutil.rmtree('/fake/inst')",
            "        self.mox.ReplayAll()",
            "        self.drvr._cleanup_failed_migration('/fake/inst')",
            "",
            "    def test_confirm_migration(self):",
            "        ins_ref = self._create_instance()",
            "",
            "        self.mox.StubOutWithMock(self.drvr, \"_cleanup_resize\")",
            "        self.drvr._cleanup_resize(ins_ref,",
            "                             _fake_network_info(self, 1))",
            "",
            "        self.mox.ReplayAll()",
            "        self.drvr.confirm_migration(\"migration_ref\", ins_ref,",
            "                                            _fake_network_info(self, 1))",
            "",
            "    def test_cleanup_resize_same_host(self):",
            "        CONF.set_override('policy_dirs', [], group='oslo_policy')",
            "        ins_ref = self._create_instance({'host': CONF.host})",
            "",
            "        def fake_os_path_exists(path):",
            "            return True",
            "",
            "        self.stub_out('os.path.exists', fake_os_path_exists)",
            "",
            "        self.mox.StubOutWithMock(imagebackend.Backend, 'image')",
            "        self.mox.StubOutWithMock(libvirt_utils, 'get_instance_path')",
            "        self.mox.StubOutWithMock(utils, 'execute')",
            "",
            "        libvirt_utils.get_instance_path(ins_ref,",
            "                forceold=True).AndReturn('/fake/inst')",
            "        utils.execute('rm', '-rf', '/fake/inst_resize', delay_on_retry=True,",
            "                      attempts=5)",
            "        imagebackend.Backend.image(ins_ref, 'disk').AndReturn(",
            "            fake_imagebackend.Raw())",
            "",
            "        self.mox.ReplayAll()",
            "        self.drvr._cleanup_resize(ins_ref,",
            "                                            _fake_network_info(self, 1))",
            "",
            "    def test_cleanup_resize_not_same_host(self):",
            "        CONF.set_override('policy_dirs', [], group='oslo_policy')",
            "        host = 'not' + CONF.host",
            "        ins_ref = self._create_instance({'host': host})",
            "",
            "        def fake_os_path_exists(path):",
            "            return True",
            "",
            "        def fake_undefine_domain(instance):",
            "            pass",
            "",
            "        def fake_unplug_vifs(instance, network_info, ignore_errors=False):",
            "            pass",
            "",
            "        def fake_unfilter_instance(instance, network_info):",
            "            pass",
            "",
            "        self.stub_out('os.path.exists', fake_os_path_exists)",
            "        self.stubs.Set(self.drvr, '_undefine_domain',",
            "                       fake_undefine_domain)",
            "        self.stubs.Set(self.drvr, 'unplug_vifs',",
            "                       fake_unplug_vifs)",
            "        self.stubs.Set(self.drvr.firewall_driver,",
            "                       'unfilter_instance', fake_unfilter_instance)",
            "",
            "        self.mox.StubOutWithMock(imagebackend.Backend, 'image')",
            "        self.mox.StubOutWithMock(libvirt_utils, 'get_instance_path')",
            "        self.mox.StubOutWithMock(utils, 'execute')",
            "",
            "        libvirt_utils.get_instance_path(ins_ref,",
            "                forceold=True).AndReturn('/fake/inst')",
            "        utils.execute('rm', '-rf', '/fake/inst_resize', delay_on_retry=True,",
            "                      attempts=5)",
            "        imagebackend.Backend.image(ins_ref, 'disk').AndReturn(",
            "                fake_imagebackend.Raw())",
            "",
            "        self.mox.ReplayAll()",
            "        self.drvr._cleanup_resize(ins_ref,",
            "                                            _fake_network_info(self, 1))",
            "",
            "    def test_cleanup_resize_snap_backend(self):",
            "        CONF.set_override('policy_dirs', [], group='oslo_policy')",
            "        ins_ref = self._create_instance({'host': CONF.host})",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        drvr.image_backend = mock.Mock()",
            "        drvr.image_backend.image.return_value = drvr.image_backend",
            "",
            "        with test.nested(",
            "                mock.patch.object(os.path, 'exists'),",
            "                mock.patch.object(libvirt_utils, 'get_instance_path'),",
            "                mock.patch.object(utils, 'execute'),",
            "                mock.patch.object(drvr.image_backend, 'remove_snap')) as (",
            "                mock_exists, mock_get_path, mock_exec, mock_remove):",
            "            mock_exists.return_value = True",
            "            mock_get_path.return_value = '/fake/inst'",
            "",
            "            drvr._cleanup_resize(ins_ref, _fake_network_info(self, 1))",
            "            mock_get_path.assert_called_once_with(ins_ref, forceold=True)",
            "            mock_exec.assert_called_once_with('rm', '-rf', '/fake/inst_resize',",
            "                                              delay_on_retry=True, attempts=5)",
            "            mock_remove.assert_called_once_with(",
            "                    libvirt_utils.RESIZE_SNAPSHOT_NAME, ignore_errors=True)",
            "",
            "    def test_get_instance_disk_info_exception(self):",
            "        instance = self._create_instance()",
            "",
            "        class FakeExceptionDomain(FakeVirtDomain):",
            "            def __init__(self):",
            "                super(FakeExceptionDomain, self).__init__()",
            "",
            "            def XMLDesc(self, flags):",
            "                raise fakelibvirt.libvirtError(\"Libvirt error\")",
            "",
            "        def fake_get_domain(self, instance):",
            "            return FakeExceptionDomain()",
            "",
            "        self.stubs.Set(host.Host, 'get_domain',",
            "                       fake_get_domain)",
            "        self.assertRaises(exception.InstanceNotFound,",
            "            self.drvr.get_instance_disk_info,",
            "            instance)",
            "",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch.object(lvm, 'list_volumes')",
            "    def test_lvm_disks(self, listlvs, exists):",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "        self.flags(images_volume_group='vols', group='libvirt')",
            "        exists.return_value = True",
            "        listlvs.return_value = ['fake-uuid_foo',",
            "                                'other-uuid_foo']",
            "        disks = self.drvr._lvm_disks(instance)",
            "        self.assertEqual(['/dev/vols/fake-uuid_foo'], disks)",
            "",
            "    def test_is_booted_from_volume(self):",
            "        func = libvirt_driver.LibvirtDriver._is_booted_from_volume",
            "        instance, disk_mapping = {}, {}",
            "",
            "        self.assertTrue(func(instance, disk_mapping))",
            "        disk_mapping['disk'] = 'map'",
            "        self.assertTrue(func(instance, disk_mapping))",
            "",
            "        instance['image_ref'] = 'uuid'",
            "        self.assertFalse(func(instance, disk_mapping))",
            "",
            "    @mock.patch('nova.virt.netutils.get_injected_network_template')",
            "    @mock.patch('nova.virt.disk.api.inject_data')",
            "    @mock.patch.object(libvirt_driver.LibvirtDriver, \"_conn\")",
            "    def _test_inject_data(self, driver_params, path, disk_params,",
            "                          mock_conn, disk_inject_data, inj_network,",
            "                          called=True):",
            "        class ImageBackend(object):",
            "            path = '/path'",
            "",
            "            def check_image_exists(self):",
            "                if self.path == '/fail/path':",
            "                    return False",
            "                return True",
            "",
            "            def get_model(self, connection):",
            "                return imgmodel.LocalFileImage(self.path,",
            "                                               imgmodel.FORMAT_RAW)",
            "",
            "        def fake_inj_network(*args, **kwds):",
            "            return args[0] or None",
            "        inj_network.side_effect = fake_inj_network",
            "",
            "        image_backend = ImageBackend()",
            "        image_backend.path = path",
            "",
            "        with mock.patch.object(",
            "                self.drvr.image_backend,",
            "                'image',",
            "                return_value=image_backend):",
            "            self.flags(inject_partition=0, group='libvirt')",
            "",
            "            self.drvr._inject_data(**driver_params)",
            "",
            "            if called:",
            "                disk_inject_data.assert_called_once_with(",
            "                    mock.ANY,",
            "                    *disk_params,",
            "                    partition=None, mandatory=('files',))",
            "",
            "            self.assertEqual(disk_inject_data.called, called)",
            "",
            "    def _test_inject_data_default_driver_params(self, **params):",
            "        return {",
            "            'instance': self._create_instance(params=params),",
            "            'network_info': None,",
            "            'admin_pass': None,",
            "            'files': None,",
            "            'suffix': ''",
            "        }",
            "",
            "    def test_inject_data_adminpass(self):",
            "        self.flags(inject_password=True, group='libvirt')",
            "        driver_params = self._test_inject_data_default_driver_params()",
            "        driver_params['admin_pass'] = 'foobar'",
            "        disk_params = [",
            "            None,  # key",
            "            None,  # net",
            "            {},  # metadata",
            "            'foobar',  # admin_pass",
            "            None,  # files",
            "        ]",
            "        self._test_inject_data(driver_params, \"/path\", disk_params)",
            "",
            "        # Test with the configuration setted to false.",
            "        self.flags(inject_password=False, group='libvirt')",
            "        self._test_inject_data(driver_params, \"/path\",",
            "                               disk_params, called=False)",
            "",
            "    def test_inject_data_key(self):",
            "        driver_params = self._test_inject_data_default_driver_params()",
            "        driver_params['instance']['key_data'] = 'key-content'",
            "",
            "        self.flags(inject_key=True, group='libvirt')",
            "        disk_params = [",
            "            'key-content',  # key",
            "            None,  # net",
            "            {},  # metadata",
            "            None,  # admin_pass",
            "            None,  # files",
            "        ]",
            "        self._test_inject_data(driver_params, \"/path\", disk_params)",
            "",
            "        # Test with the configuration setted to false.",
            "        self.flags(inject_key=False, group='libvirt')",
            "        self._test_inject_data(driver_params, \"/path\",",
            "                               disk_params, called=False)",
            "",
            "    def test_inject_data_metadata(self):",
            "        instance_metadata = {'metadata': {'data': 'foo'}}",
            "        driver_params = self._test_inject_data_default_driver_params(",
            "            **instance_metadata",
            "        )",
            "        disk_params = [",
            "            None,  # key",
            "            None,  # net",
            "            {'data': 'foo'},  # metadata",
            "            None,  # admin_pass",
            "            None,  # files",
            "        ]",
            "        self._test_inject_data(driver_params, \"/path\", disk_params)",
            "",
            "    def test_inject_data_files(self):",
            "        driver_params = self._test_inject_data_default_driver_params()",
            "        driver_params['files'] = ['file1', 'file2']",
            "        disk_params = [",
            "            None,  # key",
            "            None,  # net",
            "            {},  # metadata",
            "            None,  # admin_pass",
            "            ['file1', 'file2'],  # files",
            "        ]",
            "        self._test_inject_data(driver_params, \"/path\", disk_params)",
            "",
            "    def test_inject_data_net(self):",
            "        driver_params = self._test_inject_data_default_driver_params()",
            "        driver_params['network_info'] = {'net': 'eno1'}",
            "        disk_params = [",
            "            None,  # key",
            "            {'net': 'eno1'},  # net",
            "            {},  # metadata",
            "            None,  # admin_pass",
            "            None,  # files",
            "        ]",
            "        self._test_inject_data(driver_params, \"/path\", disk_params)",
            "",
            "    def test_inject_not_exist_image(self):",
            "        driver_params = self._test_inject_data_default_driver_params()",
            "        disk_params = [",
            "            'key-content',  # key",
            "            None,  # net",
            "            None,  # metadata",
            "            None,  # admin_pass",
            "            None,  # files",
            "        ]",
            "        self._test_inject_data(driver_params, \"/fail/path\",",
            "                               disk_params, called=False)",
            "",
            "    def _test_attach_detach_interface(self, method, power_state,",
            "                                      expected_flags):",
            "        instance = self._create_instance()",
            "        network_info = _fake_network_info(self, 1)",
            "        domain = FakeVirtDomain()",
            "        self.mox.StubOutWithMock(host.Host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr.firewall_driver,",
            "                                 'setup_basic_filtering')",
            "        self.mox.StubOutWithMock(domain, 'attachDeviceFlags')",
            "        self.mox.StubOutWithMock(domain, 'info')",
            "",
            "        host.Host.get_domain(instance).AndReturn(domain)",
            "        if method == 'attach_interface':",
            "            self.drvr.firewall_driver.setup_basic_filtering(",
            "                instance, [network_info[0]])",
            "",
            "        fake_image_meta = objects.ImageMeta.from_dict(",
            "            {'id': instance.image_ref})",
            "",
            "        expected = self.drvr.vif_driver.get_config(",
            "            instance, network_info[0], fake_image_meta, instance.flavor,",
            "            CONF.libvirt.virt_type, self.drvr._host)",
            "",
            "        self.mox.StubOutWithMock(self.drvr.vif_driver,",
            "                                 'get_config')",
            "        self.drvr.vif_driver.get_config(",
            "            instance, network_info[0],",
            "            mox.IsA(objects.ImageMeta),",
            "            mox.IsA(objects.Flavor),",
            "            CONF.libvirt.virt_type,",
            "            self.drvr._host).AndReturn(expected)",
            "        domain.info().AndReturn([power_state, 1, 2, 3, 4])",
            "        if method == 'attach_interface':",
            "            domain.attachDeviceFlags(expected.to_xml(), flags=expected_flags)",
            "        elif method == 'detach_interface':",
            "            domain.detachDeviceFlags(expected.to_xml(), expected_flags)",
            "",
            "        self.mox.ReplayAll()",
            "        if method == 'attach_interface':",
            "            self.drvr.attach_interface(",
            "                instance, fake_image_meta, network_info[0])",
            "        elif method == 'detach_interface':",
            "            self.drvr.detach_interface(",
            "                instance, network_info[0])",
            "        self.mox.VerifyAll()",
            "",
            "    def test_attach_interface_with_running_instance(self):",
            "        self._test_attach_detach_interface(",
            "            'attach_interface', power_state.RUNNING,",
            "            expected_flags=(fakelibvirt.VIR_DOMAIN_AFFECT_CONFIG |",
            "                            fakelibvirt.VIR_DOMAIN_AFFECT_LIVE))",
            "",
            "    def test_attach_interface_with_pause_instance(self):",
            "        self._test_attach_detach_interface(",
            "            'attach_interface', power_state.PAUSED,",
            "            expected_flags=(fakelibvirt.VIR_DOMAIN_AFFECT_CONFIG |",
            "                            fakelibvirt.VIR_DOMAIN_AFFECT_LIVE))",
            "",
            "    def test_attach_interface_with_shutdown_instance(self):",
            "        self._test_attach_detach_interface(",
            "            'attach_interface', power_state.SHUTDOWN,",
            "            expected_flags=(fakelibvirt.VIR_DOMAIN_AFFECT_CONFIG))",
            "",
            "    def test_detach_interface_with_running_instance(self):",
            "        self._test_attach_detach_interface(",
            "            'detach_interface', power_state.RUNNING,",
            "            expected_flags=(fakelibvirt.VIR_DOMAIN_AFFECT_CONFIG |",
            "                            fakelibvirt.VIR_DOMAIN_AFFECT_LIVE))",
            "",
            "    def test_detach_interface_with_pause_instance(self):",
            "        self._test_attach_detach_interface(",
            "            'detach_interface', power_state.PAUSED,",
            "            expected_flags=(fakelibvirt.VIR_DOMAIN_AFFECT_CONFIG |",
            "                            fakelibvirt.VIR_DOMAIN_AFFECT_LIVE))",
            "",
            "    def test_detach_interface_with_shutdown_instance(self):",
            "        self._test_attach_detach_interface(",
            "            'detach_interface', power_state.SHUTDOWN,",
            "            expected_flags=(fakelibvirt.VIR_DOMAIN_AFFECT_CONFIG))",
            "",
            "    @mock.patch('nova.virt.libvirt.driver.LOG')",
            "    def test_detach_interface_device_not_found(self, mock_log):",
            "        # Asserts that we don't log an error when the interface device is not",
            "        # found on the guest after a libvirt error during detach.",
            "        instance = self._create_instance()",
            "        vif = _fake_network_info(self, 1)[0]",
            "        guest = mock.Mock(spec='nova.virt.libvirt.guest.Guest')",
            "        guest.get_power_state = mock.Mock()",
            "        self.drvr._host.get_guest = mock.Mock(return_value=guest)",
            "        self.drvr.vif_driver = mock.Mock()",
            "        error = fakelibvirt.libvirtError(",
            "            'no matching network device was found')",
            "        error.err = (fakelibvirt.VIR_ERR_OPERATION_FAILED,)",
            "        guest.detach_device = mock.Mock(side_effect=error)",
            "        # mock out that get_interface_by_mac doesn't find the interface",
            "        guest.get_interface_by_mac = mock.Mock(return_value=None)",
            "        self.drvr.detach_interface(instance, vif)",
            "        guest.get_interface_by_mac.assert_called_once_with(vif['address'])",
            "        # an error shouldn't be logged, but a warning should be logged",
            "        self.assertFalse(mock_log.error.called)",
            "        self.assertEqual(1, mock_log.warning.call_count)",
            "        self.assertIn('the device is no longer found on the guest',",
            "                      six.text_type(mock_log.warning.call_args[0]))",
            "",
            "    def test_rescue(self):",
            "        instance = self._create_instance({'config_drive': None})",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices>\"",
            "                    \"<disk type='file'><driver name='qemu' type='raw'/>\"",
            "                    \"<source file='/test/disk'/>\"",
            "                    \"<target dev='vda' bus='virtio'/></disk>\"",
            "                    \"<disk type='file'><driver name='qemu' type='qcow2'/>\"",
            "                    \"<source file='/test/disk.local'/>\"",
            "                    \"<target dev='vdb' bus='virtio'/></disk>\"",
            "                    \"</devices></domain>\")",
            "        network_info = _fake_network_info(self, 1)",
            "",
            "        self.mox.StubOutWithMock(self.drvr,",
            "                                     '_get_existing_domain_xml')",
            "        self.mox.StubOutWithMock(libvirt_utils, 'write_to_file')",
            "        self.mox.StubOutWithMock(imagebackend.Backend, 'image')",
            "        self.mox.StubOutWithMock(imagebackend.Image, 'cache')",
            "        self.mox.StubOutWithMock(self.drvr, '_get_guest_xml')",
            "        self.mox.StubOutWithMock(self.drvr, '_destroy')",
            "        self.mox.StubOutWithMock(self.drvr, '_create_domain')",
            "",
            "        self.drvr._get_existing_domain_xml(mox.IgnoreArg(),",
            "                        mox.IgnoreArg()).MultipleTimes().AndReturn(dummyxml)",
            "        libvirt_utils.write_to_file(mox.IgnoreArg(), mox.IgnoreArg())",
            "        libvirt_utils.write_to_file(mox.IgnoreArg(), mox.IgnoreArg(),",
            "                               mox.IgnoreArg())",
            "        imagebackend.Backend.image(instance, 'kernel.rescue', 'raw'",
            "                                        ).AndReturn(fake_imagebackend.Raw())",
            "        imagebackend.Backend.image(instance, 'ramdisk.rescue', 'raw'",
            "                                        ).AndReturn(fake_imagebackend.Raw())",
            "        imagebackend.Backend.image(instance, 'disk.rescue', 'default'",
            "                                        ).AndReturn(fake_imagebackend.Raw())",
            "        imagebackend.Image.cache(context=mox.IgnoreArg(),",
            "                                fetch_func=mox.IgnoreArg(),",
            "                                filename=mox.IgnoreArg(),",
            "                                image_id=mox.IgnoreArg(),",
            "                                project_id=mox.IgnoreArg(),",
            "                                user_id=mox.IgnoreArg()).MultipleTimes()",
            "",
            "        imagebackend.Image.cache(context=mox.IgnoreArg(),",
            "                                fetch_func=mox.IgnoreArg(),",
            "                                filename=mox.IgnoreArg(),",
            "                                image_id=mox.IgnoreArg(),",
            "                                project_id=mox.IgnoreArg(),",
            "                                size=None, user_id=mox.IgnoreArg())",
            "",
            "        image_meta = objects.ImageMeta.from_dict(",
            "            {'id': 'fake', 'name': 'fake'})",
            "        self.drvr._get_guest_xml(mox.IgnoreArg(), instance,",
            "                                 network_info, mox.IgnoreArg(),",
            "                                 image_meta,",
            "                                 rescue=mox.IgnoreArg(),",
            "                                 write_to_disk=mox.IgnoreArg()",
            "                             ).AndReturn(dummyxml)",
            "",
            "        self.drvr._destroy(instance)",
            "        self.drvr._create_domain(mox.IgnoreArg())",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        rescue_password = 'fake_password'",
            "",
            "        self.drvr.rescue(self.context, instance,",
            "                    network_info, image_meta, rescue_password)",
            "        self.mox.VerifyAll()",
            "",
            "    @mock.patch.object(libvirt_utils, 'get_instance_path')",
            "    @mock.patch.object(libvirt_utils, 'load_file')",
            "    @mock.patch.object(host.Host, \"get_domain\")",
            "    def test_unrescue(self, mock_get_domain, mock_load_file,",
            "                                           mock_get_instance_path):",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices>\"",
            "                    \"<disk type='block' device='disk'>\"",
            "                    \"<source dev='/dev/some-vg/some-lv'/>\"",
            "                    \"<target dev='vda' bus='virtio'/></disk>\"",
            "                    \"</devices></domain>\")",
            "",
            "        mock_get_instance_path.return_value = '/path'",
            "        instance = objects.Instance(uuid='fake=uuid', id=1)",
            "        fake_dom = FakeVirtDomain(fake_xml=dummyxml)",
            "        mock_get_domain.return_value = fake_dom",
            "        mock_load_file.return_value = \"fake_unrescue_xml\"",
            "        unrescue_xml_path = os.path.join('/path', 'unrescue.xml')",
            "        rescue_file = os.path.join('/path', 'rescue.file')",
            "",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        with test.nested(",
            "                mock.patch.object(drvr, '_destroy'),",
            "                mock.patch.object(drvr, '_create_domain'),",
            "                mock.patch.object(libvirt_utils, 'file_delete'),",
            "                mock.patch.object(drvr, '_lvm_disks',",
            "                                  return_value=['lvm.rescue']),",
            "                mock.patch.object(lvm, 'remove_volumes'),",
            "                mock.patch.object(glob, 'iglob', return_value=[rescue_file])",
            "                ) as (mock_destroy, mock_create, mock_del, mock_lvm_disks,",
            "                      mock_remove_volumes, mock_glob):",
            "            drvr.unrescue(instance, None)",
            "            mock_destroy.assert_called_once_with(instance)",
            "            mock_create.assert_called_once_with(\"fake_unrescue_xml\",",
            "                                                 fake_dom)",
            "            self.assertEqual(2, mock_del.call_count)",
            "            self.assertEqual(unrescue_xml_path,",
            "                             mock_del.call_args_list[0][0][0])",
            "            self.assertEqual(rescue_file, mock_del.call_args_list[1][0][0])",
            "            mock_remove_volumes.assert_called_once_with(['lvm.rescue'])",
            "",
            "    @mock.patch(",
            "        'nova.virt.configdrive.ConfigDriveBuilder.add_instance_metadata')",
            "    @mock.patch('nova.virt.configdrive.ConfigDriveBuilder.make_drive')",
            "    def test_rescue_config_drive(self, mock_make, mock_add):",
            "        instance = self._create_instance()",
            "        uuid = instance.uuid",
            "        configdrive_path = uuid + '/disk.config.rescue'",
            "        dummyxml = (\"<domain type='kvm'><name>instance-0000000a</name>\"",
            "                    \"<devices>\"",
            "                    \"<disk type='file'><driver name='qemu' type='raw'/>\"",
            "                    \"<source file='/test/disk'/>\"",
            "                    \"<target dev='vda' bus='virtio'/></disk>\"",
            "                    \"<disk type='file'><driver name='qemu' type='qcow2'/>\"",
            "                    \"<source file='/test/disk.local'/>\"",
            "                    \"<target dev='vdb' bus='virtio'/></disk>\"",
            "                    \"</devices></domain>\")",
            "        network_info = _fake_network_info(self, 1)",
            "",
            "        self.mox.StubOutWithMock(self.drvr,",
            "                                    '_get_existing_domain_xml')",
            "        self.mox.StubOutWithMock(libvirt_utils, 'write_to_file')",
            "        self.mox.StubOutWithMock(imagebackend.Backend, 'image')",
            "        self.mox.StubOutWithMock(imagebackend.Image, 'cache')",
            "        self.mox.StubOutWithMock(instance_metadata.InstanceMetadata,",
            "                                                            '__init__')",
            "        self.mox.StubOutWithMock(self.drvr, '_get_guest_xml')",
            "        self.mox.StubOutWithMock(self.drvr, '_destroy')",
            "        self.mox.StubOutWithMock(self.drvr, '_create_domain')",
            "",
            "        self.drvr._get_existing_domain_xml(mox.IgnoreArg(),",
            "                    mox.IgnoreArg()).MultipleTimes().AndReturn(dummyxml)",
            "        libvirt_utils.write_to_file(mox.IgnoreArg(), mox.IgnoreArg())",
            "        libvirt_utils.write_to_file(mox.IgnoreArg(), mox.IgnoreArg(),",
            "                                    mox.IgnoreArg())",
            "",
            "        imagebackend.Backend.image(instance, 'kernel.rescue', 'raw'",
            "                                    ).AndReturn(fake_imagebackend.Raw())",
            "        imagebackend.Backend.image(instance, 'ramdisk.rescue', 'raw'",
            "                                    ).AndReturn(fake_imagebackend.Raw())",
            "        imagebackend.Backend.image(instance, 'disk.rescue', 'default'",
            "                                    ).AndReturn(fake_imagebackend.Raw())",
            "        imagebackend.Backend.image(instance, 'disk.config.rescue', 'raw'",
            "                                   ).AndReturn(fake_imagebackend.Raw())",
            "",
            "        imagebackend.Image.cache(context=mox.IgnoreArg(),",
            "                                fetch_func=mox.IgnoreArg(),",
            "                                filename=mox.IgnoreArg(),",
            "                                image_id=mox.IgnoreArg(),",
            "                                project_id=mox.IgnoreArg(),",
            "                                user_id=mox.IgnoreArg()).MultipleTimes()",
            "",
            "        imagebackend.Image.cache(context=mox.IgnoreArg(),",
            "                                fetch_func=mox.IgnoreArg(),",
            "                                filename=mox.IgnoreArg(),",
            "                                image_id=mox.IgnoreArg(),",
            "                                project_id=mox.IgnoreArg(),",
            "                                size=None, user_id=mox.IgnoreArg())",
            "",
            "        instance_metadata.InstanceMetadata.__init__(mox.IgnoreArg(),",
            "                                            content=mox.IgnoreArg(),",
            "                                            extra_md=mox.IgnoreArg(),",
            "                                            network_info=mox.IgnoreArg())",
            "        image_meta = objects.ImageMeta.from_dict(",
            "            {'id': 'fake', 'name': 'fake'})",
            "        self.drvr._get_guest_xml(mox.IgnoreArg(), instance,",
            "                                 network_info, mox.IgnoreArg(),",
            "                                 image_meta,",
            "                                 rescue=mox.IgnoreArg(),",
            "                                 write_to_disk=mox.IgnoreArg()",
            "                                ).AndReturn(dummyxml)",
            "        self.drvr._destroy(instance)",
            "        self.drvr._create_domain(mox.IgnoreArg())",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        rescue_password = 'fake_password'",
            "",
            "        self.drvr.rescue(self.context, instance, network_info,",
            "                                                image_meta, rescue_password)",
            "        self.mox.VerifyAll()",
            "",
            "        mock_add.assert_any_call(mock.ANY)",
            "        expected_call = [mock.call(os.path.join(CONF.instances_path,",
            "                                                configdrive_path))]",
            "        mock_make.assert_has_calls(expected_call)",
            "",
            "    @mock.patch('shutil.rmtree')",
            "    @mock.patch('nova.utils.execute')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path')",
            "    def test_delete_instance_files(self, get_instance_path, exists, exe,",
            "                                   shutil):",
            "        get_instance_path.return_value = '/path'",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "",
            "        exists.side_effect = [False, False, True, False]",
            "",
            "        result = self.drvr.delete_instance_files(instance)",
            "        get_instance_path.assert_called_with(instance)",
            "        exe.assert_called_with('mv', '/path', '/path_del')",
            "        shutil.assert_called_with('/path_del')",
            "        self.assertTrue(result)",
            "",
            "    @mock.patch('shutil.rmtree')",
            "    @mock.patch('nova.utils.execute')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('os.kill')",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path')",
            "    def test_delete_instance_files_kill_running(",
            "            self, get_instance_path, kill, exists, exe, shutil):",
            "        get_instance_path.return_value = '/path'",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "        self.drvr.job_tracker.jobs[instance.uuid] = [3, 4]",
            "",
            "        exists.side_effect = [False, False, True, False]",
            "",
            "        result = self.drvr.delete_instance_files(instance)",
            "        get_instance_path.assert_called_with(instance)",
            "        exe.assert_called_with('mv', '/path', '/path_del')",
            "        kill.assert_has_calls([mock.call(3, signal.SIGKILL), mock.call(3, 0),",
            "                               mock.call(4, signal.SIGKILL), mock.call(4, 0)])",
            "        shutil.assert_called_with('/path_del')",
            "        self.assertTrue(result)",
            "        self.assertNotIn(instance.uuid, self.drvr.job_tracker.jobs)",
            "",
            "    @mock.patch('shutil.rmtree')",
            "    @mock.patch('nova.utils.execute')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path')",
            "    def test_delete_instance_files_resize(self, get_instance_path, exists,",
            "                                          exe, shutil):",
            "        get_instance_path.return_value = '/path'",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "",
            "        nova.utils.execute.side_effect = [Exception(), None]",
            "        exists.side_effect = [False, False, True, False]",
            "",
            "        result = self.drvr.delete_instance_files(instance)",
            "        get_instance_path.assert_called_with(instance)",
            "        expected = [mock.call('mv', '/path', '/path_del'),",
            "                    mock.call('mv', '/path_resize', '/path_del')]",
            "        self.assertEqual(expected, exe.mock_calls)",
            "        shutil.assert_called_with('/path_del')",
            "        self.assertTrue(result)",
            "",
            "    @mock.patch('shutil.rmtree')",
            "    @mock.patch('nova.utils.execute')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path')",
            "    def test_delete_instance_files_failed(self, get_instance_path, exists, exe,",
            "                                          shutil):",
            "        get_instance_path.return_value = '/path'",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "",
            "        exists.side_effect = [False, False, True, True]",
            "",
            "        result = self.drvr.delete_instance_files(instance)",
            "        get_instance_path.assert_called_with(instance)",
            "        exe.assert_called_with('mv', '/path', '/path_del')",
            "        shutil.assert_called_with('/path_del')",
            "        self.assertFalse(result)",
            "",
            "    @mock.patch('shutil.rmtree')",
            "    @mock.patch('nova.utils.execute')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path')",
            "    def test_delete_instance_files_mv_failed(self, get_instance_path, exists,",
            "                                             exe, shutil):",
            "        get_instance_path.return_value = '/path'",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "",
            "        nova.utils.execute.side_effect = Exception()",
            "        exists.side_effect = [True, True]",
            "",
            "        result = self.drvr.delete_instance_files(instance)",
            "        get_instance_path.assert_called_with(instance)",
            "        expected = [mock.call('mv', '/path', '/path_del'),",
            "                    mock.call('mv', '/path_resize', '/path_del')] * 2",
            "        self.assertEqual(expected, exe.mock_calls)",
            "        self.assertFalse(result)",
            "",
            "    @mock.patch('shutil.rmtree')",
            "    @mock.patch('nova.utils.execute')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path')",
            "    def test_delete_instance_files_resume(self, get_instance_path, exists,",
            "                                             exe, shutil):",
            "        get_instance_path.return_value = '/path'",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "",
            "        nova.utils.execute.side_effect = Exception()",
            "        exists.side_effect = [False, False, True, False]",
            "",
            "        result = self.drvr.delete_instance_files(instance)",
            "        get_instance_path.assert_called_with(instance)",
            "        expected = [mock.call('mv', '/path', '/path_del'),",
            "                    mock.call('mv', '/path_resize', '/path_del')] * 2",
            "        self.assertEqual(expected, exe.mock_calls)",
            "        self.assertTrue(result)",
            "",
            "    @mock.patch('shutil.rmtree')",
            "    @mock.patch('nova.utils.execute')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path')",
            "    def test_delete_instance_files_none(self, get_instance_path, exists,",
            "                                        exe, shutil):",
            "        get_instance_path.return_value = '/path'",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "",
            "        nova.utils.execute.side_effect = Exception()",
            "        exists.side_effect = [False, False, False, False]",
            "",
            "        result = self.drvr.delete_instance_files(instance)",
            "        get_instance_path.assert_called_with(instance)",
            "        expected = [mock.call('mv', '/path', '/path_del'),",
            "                    mock.call('mv', '/path_resize', '/path_del')] * 2",
            "        self.assertEqual(expected, exe.mock_calls)",
            "        self.assertEqual(0, len(shutil.mock_calls))",
            "        self.assertTrue(result)",
            "",
            "    @mock.patch('shutil.rmtree')",
            "    @mock.patch('nova.utils.execute')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('nova.virt.libvirt.utils.get_instance_path')",
            "    def test_delete_instance_files_concurrent(self, get_instance_path, exists,",
            "                                              exe, shutil):",
            "        get_instance_path.return_value = '/path'",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "",
            "        nova.utils.execute.side_effect = [Exception(), Exception(), None]",
            "        exists.side_effect = [False, False, True, False]",
            "",
            "        result = self.drvr.delete_instance_files(instance)",
            "        get_instance_path.assert_called_with(instance)",
            "        expected = [mock.call('mv', '/path', '/path_del'),",
            "                    mock.call('mv', '/path_resize', '/path_del')]",
            "        expected.append(expected[0])",
            "        self.assertEqual(expected, exe.mock_calls)",
            "        shutil.assert_called_with('/path_del')",
            "        self.assertTrue(result)",
            "",
            "    def _assert_on_id_map(self, idmap, klass, start, target, count):",
            "        self.assertIsInstance(idmap, klass)",
            "        self.assertEqual(start, idmap.start)",
            "        self.assertEqual(target, idmap.target)",
            "        self.assertEqual(count, idmap.count)",
            "",
            "    def test_get_id_maps(self):",
            "        self.flags(virt_type=\"lxc\", group=\"libvirt\")",
            "        CONF.libvirt.virt_type = \"lxc\"",
            "        CONF.libvirt.uid_maps = [\"0:10000:1\", \"1:20000:10\"]",
            "        CONF.libvirt.gid_maps = [\"0:10000:1\", \"1:20000:10\"]",
            "",
            "        idmaps = self.drvr._get_guest_idmaps()",
            "",
            "        self.assertEqual(len(idmaps), 4)",
            "        self._assert_on_id_map(idmaps[0],",
            "                               vconfig.LibvirtConfigGuestUIDMap,",
            "                               0, 10000, 1)",
            "        self._assert_on_id_map(idmaps[1],",
            "                               vconfig.LibvirtConfigGuestUIDMap,",
            "                               1, 20000, 10)",
            "        self._assert_on_id_map(idmaps[2],",
            "                               vconfig.LibvirtConfigGuestGIDMap,",
            "                               0, 10000, 1)",
            "        self._assert_on_id_map(idmaps[3],",
            "                               vconfig.LibvirtConfigGuestGIDMap,",
            "                               1, 20000, 10)",
            "",
            "    def test_get_id_maps_not_lxc(self):",
            "        CONF.libvirt.uid_maps = [\"0:10000:1\", \"1:20000:10\"]",
            "        CONF.libvirt.gid_maps = [\"0:10000:1\", \"1:20000:10\"]",
            "",
            "        idmaps = self.drvr._get_guest_idmaps()",
            "",
            "        self.assertEqual(0, len(idmaps))",
            "",
            "    def test_get_id_maps_only_uid(self):",
            "        self.flags(virt_type=\"lxc\", group=\"libvirt\")",
            "        CONF.libvirt.uid_maps = [\"0:10000:1\", \"1:20000:10\"]",
            "        CONF.libvirt.gid_maps = []",
            "",
            "        idmaps = self.drvr._get_guest_idmaps()",
            "",
            "        self.assertEqual(2, len(idmaps))",
            "        self._assert_on_id_map(idmaps[0],",
            "                               vconfig.LibvirtConfigGuestUIDMap,",
            "                               0, 10000, 1)",
            "        self._assert_on_id_map(idmaps[1],",
            "                               vconfig.LibvirtConfigGuestUIDMap,",
            "                               1, 20000, 10)",
            "",
            "    def test_get_id_maps_only_gid(self):",
            "        self.flags(virt_type=\"lxc\", group=\"libvirt\")",
            "        CONF.libvirt.uid_maps = []",
            "        CONF.libvirt.gid_maps = [\"0:10000:1\", \"1:20000:10\"]",
            "",
            "        idmaps = self.drvr._get_guest_idmaps()",
            "",
            "        self.assertEqual(2, len(idmaps))",
            "        self._assert_on_id_map(idmaps[0],",
            "                               vconfig.LibvirtConfigGuestGIDMap,",
            "                               0, 10000, 1)",
            "        self._assert_on_id_map(idmaps[1],",
            "                               vconfig.LibvirtConfigGuestGIDMap,",
            "                               1, 20000, 10)",
            "",
            "    def test_instance_on_disk(self):",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "        self.assertFalse(drvr.instance_on_disk(instance))",
            "",
            "    def test_instance_on_disk_rbd(self):",
            "        self.flags(images_type='rbd', group='libvirt')",
            "        drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "        self.assertTrue(drvr.instance_on_disk(instance))",
            "",
            "    def test_get_interfaces(self):",
            "        dom_xml = \"\"\"",
            "              <domain type=\"qemu\">",
            "                  <devices>",
            "                      <interface type=\"ethernet\">",
            "                          <mac address=\"fe:eb:da:ed:ef:ac\"/>",
            "                          <model type=\"virtio\"/>",
            "                          <target dev=\"eth0\"/>",
            "                      </interface>",
            "                      <interface type=\"bridge\">",
            "                          <mac address=\"ca:fe:de:ad:be:ef\"/>",
            "                          <model type=\"virtio\"/>",
            "                          <target dev=\"br0\"/>",
            "                      </interface>",
            "                  </devices>",
            "              </domain>\"\"\"",
            "",
            "        list_interfaces = ['eth0', 'br0']",
            "",
            "        drv = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        self.assertEqual(list_interfaces, drv._get_interfaces(dom_xml))",
            "",
            "    def test_get_disk_xml(self):",
            "        dom_xml = \"\"\"",
            "              <domain type=\"kvm\">",
            "                <devices>",
            "                  <disk type=\"file\">",
            "                     <source file=\"disk1_file\"/>",
            "                     <target dev=\"vda\" bus=\"virtio\"/>",
            "                     <serial>0e38683e-f0af-418f-a3f1-6b67ea0f919d</serial>",
            "                  </disk>",
            "                  <disk type=\"block\">",
            "                    <source dev=\"/path/to/dev/1\"/>",
            "                    <target dev=\"vdb\" bus=\"virtio\" serial=\"1234\"/>",
            "                  </disk>",
            "                </devices>",
            "              </domain>",
            "              \"\"\"",
            "",
            "        diska_xml = \"\"\"<disk type=\"file\" device=\"disk\">",
            "  <source file=\"disk1_file\"/>",
            "  <target bus=\"virtio\" dev=\"vda\"/>",
            "  <serial>0e38683e-f0af-418f-a3f1-6b67ea0f919d</serial>",
            "</disk>\"\"\"",
            "",
            "        diskb_xml = \"\"\"<disk type=\"block\" device=\"disk\">",
            "  <source dev=\"/path/to/dev/1\"/>",
            "  <target bus=\"virtio\" dev=\"vdb\"/>",
            "</disk>\"\"\"",
            "",
            "        dom = mock.MagicMock()",
            "        dom.XMLDesc.return_value = dom_xml",
            "        guest = libvirt_guest.Guest(dom)",
            "",
            "        # NOTE(gcb): etree.tostring(node) returns an extra line with",
            "        # some white spaces, need to strip it.",
            "        actual_diska_xml = guest.get_disk('vda').to_xml()",
            "        self.assertEqual(diska_xml.strip(), actual_diska_xml.strip())",
            "",
            "        actual_diskb_xml = guest.get_disk('vdb').to_xml()",
            "        self.assertEqual(diskb_xml.strip(), actual_diskb_xml.strip())",
            "",
            "        self.assertIsNone(guest.get_disk('vdc'))",
            "",
            "    def test_vcpu_model_from_config(self):",
            "        drv = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        vcpu_model = drv._cpu_config_to_vcpu_model(None, None)",
            "        self.assertIsNone(vcpu_model)",
            "",
            "        cpu = vconfig.LibvirtConfigGuestCPU()",
            "        feature1 = vconfig.LibvirtConfigGuestCPUFeature()",
            "        feature2 = vconfig.LibvirtConfigGuestCPUFeature()",
            "        feature1.name = 'sse'",
            "        feature1.policy = cpumodel.POLICY_REQUIRE",
            "        feature2.name = 'aes'",
            "        feature2.policy = cpumodel.POLICY_REQUIRE",
            "",
            "        cpu.features = set([feature1, feature2])",
            "        cpu.mode = cpumodel.MODE_CUSTOM",
            "        cpu.sockets = 1",
            "        cpu.cores = 2",
            "        cpu.threads = 4",
            "        vcpu_model = drv._cpu_config_to_vcpu_model(cpu, None)",
            "        self.assertEqual(cpumodel.MATCH_EXACT, vcpu_model.match)",
            "        self.assertEqual(cpumodel.MODE_CUSTOM, vcpu_model.mode)",
            "        self.assertEqual(4, vcpu_model.topology.threads)",
            "        self.assertEqual(set(['sse', 'aes']),",
            "                         set([f.name for f in vcpu_model.features]))",
            "",
            "        cpu.mode = cpumodel.MODE_HOST_MODEL",
            "        vcpu_model_1 = drv._cpu_config_to_vcpu_model(cpu, vcpu_model)",
            "        self.assertEqual(cpumodel.MODE_HOST_MODEL, vcpu_model.mode)",
            "        self.assertEqual(vcpu_model, vcpu_model_1)",
            "",
            "    @mock.patch.object(lvm, 'get_volume_size', return_value=10)",
            "    @mock.patch.object(host.Host, \"get_guest\")",
            "    @mock.patch.object(dmcrypt, 'delete_volume')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver.unfilter_instance')",
            "    @mock.patch('nova.virt.libvirt.driver.LibvirtDriver._undefine_domain')",
            "    @mock.patch.object(objects.Instance, 'save')",
            "    def test_cleanup_lvm_encrypted(self, mock_save, mock_undefine_domain,",
            "                                   mock_unfilter, mock_delete_volume,",
            "                                   mock_get_guest, mock_get_size):",
            "        drv = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance = objects.Instance(uuid='fake-uuid', id=1,",
            "                                    ephemeral_key_uuid='000-000-000')",
            "        instance.system_metadata = {}",
            "        block_device_info = {'root_device_name': '/dev/vda',",
            "                             'ephemerals': [],",
            "                             'block_device_mapping': []}",
            "        self.flags(images_type=\"lvm\",",
            "                   group='libvirt')",
            "        dom_xml = \"\"\"",
            "              <domain type=\"kvm\">",
            "                <devices>",
            "                  <disk type=\"block\">",
            "                    <driver name='qemu' type='raw' cache='none'/>",
            "                    <source dev=\"/dev/mapper/fake-dmcrypt\"/>",
            "                    <target dev=\"vda\" bus=\"virtio\" serial=\"1234\"/>",
            "                  </disk>",
            "                </devices>",
            "              </domain>",
            "              \"\"\"",
            "        dom = mock.MagicMock()",
            "        dom.XMLDesc.return_value = dom_xml",
            "        guest = libvirt_guest.Guest(dom)",
            "        mock_get_guest.return_value = guest",
            "        drv.cleanup(self.context, instance, 'fake_network', destroy_vifs=False,",
            "                        block_device_info=block_device_info)",
            "        mock_delete_volume.assert_called_once_with('/dev/mapper/fake-dmcrypt')",
            "",
            "    @mock.patch.object(lvm, 'get_volume_size', return_value=10)",
            "    @mock.patch.object(host.Host, \"get_guest\")",
            "    @mock.patch.object(dmcrypt, 'delete_volume')",
            "    def _test_cleanup_lvm(self, mock_delete_volume, mock_get_guest, mock_size,",
            "                          encrypted=False):",
            "",
            "        drv = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        instance = objects.Instance(uuid='fake-uuid', id=1,",
            "                                    ephemeral_key_uuid='000-000-000')",
            "        block_device_info = {'root_device_name': '/dev/vda',",
            "                             'ephemerals': [],",
            "                             'block_device_mapping': []}",
            "        dev_name = 'fake-dmcrypt' if encrypted else 'fake'",
            "        dom_xml = \"\"\"",
            "              <domain type=\"kvm\">",
            "                <devices>",
            "                  <disk type=\"block\">",
            "                    <driver name='qemu' type='raw' cache='none'/>",
            "                    <source dev=\"/dev/mapper/%s\"/>",
            "                    <target dev=\"vda\" bus=\"virtio\" serial=\"1234\"/>",
            "                  </disk>",
            "                </devices>",
            "              </domain>",
            "              \"\"\" % dev_name",
            "        dom = mock.MagicMock()",
            "        dom.XMLDesc.return_value = dom_xml",
            "        guest = libvirt_guest.Guest(dom)",
            "        mock_get_guest.return_value = guest",
            "        drv._cleanup_lvm(instance, block_device_info)",
            "",
            "        if encrypted:",
            "            mock_delete_volume.assert_called_once_with(",
            "                '/dev/mapper/fake-dmcrypt')",
            "        else:",
            "            self.assertFalse(mock_delete_volume.called)",
            "",
            "    def test_cleanup_lvm(self):",
            "        self._test_cleanup_lvm()",
            "",
            "    def test_cleanup_encrypted_lvm(self):",
            "        self._test_cleanup_lvm(encrypted=True)",
            "",
            "    def test_vcpu_model_to_config(self):",
            "        drv = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "",
            "        feature = objects.VirtCPUFeature(policy=cpumodel.POLICY_REQUIRE,",
            "                                         name='sse')",
            "        feature_1 = objects.VirtCPUFeature(policy=cpumodel.POLICY_FORBID,",
            "                                           name='aes')",
            "        topo = objects.VirtCPUTopology(sockets=1, cores=2, threads=4)",
            "        vcpu_model = objects.VirtCPUModel(mode=cpumodel.MODE_HOST_MODEL,",
            "                                          features=[feature, feature_1],",
            "                                          topology=topo)",
            "",
            "        cpu = drv._vcpu_model_to_cpu_config(vcpu_model)",
            "        self.assertEqual(cpumodel.MODE_HOST_MODEL, cpu.mode)",
            "        self.assertEqual(1, cpu.sockets)",
            "        self.assertEqual(4, cpu.threads)",
            "        self.assertEqual(2, len(cpu.features))",
            "        self.assertEqual(set(['sse', 'aes']),",
            "                         set([f.name for f in cpu.features]))",
            "        self.assertEqual(set([cpumodel.POLICY_REQUIRE,",
            "                              cpumodel.POLICY_FORBID]),",
            "                         set([f.policy for f in cpu.features]))",
            "",
            "    def test_trigger_crash_dump(self):",
            "        mock_guest = mock.Mock(libvirt_guest.Guest, id=1)",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "",
            "        with mock.patch.object(self.drvr._host, 'get_guest',",
            "                               return_value=mock_guest):",
            "            self.drvr.trigger_crash_dump(instance)",
            "",
            "    def test_trigger_crash_dump_not_running(self):",
            "        ex = fakelibvirt.make_libvirtError(",
            "                fakelibvirt.libvirtError,",
            "                'Requested operation is not valid: domain is not running',",
            "                error_code=fakelibvirt.VIR_ERR_OPERATION_INVALID)",
            "",
            "        mock_guest = mock.Mock(libvirt_guest.Guest, id=1)",
            "        mock_guest.inject_nmi = mock.Mock(side_effect=ex)",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "",
            "        with mock.patch.object(self.drvr._host, 'get_guest',",
            "                               return_value=mock_guest):",
            "            self.assertRaises(exception.InstanceNotRunning,",
            "                              self.drvr.trigger_crash_dump, instance)",
            "",
            "    def test_trigger_crash_dump_not_supported(self):",
            "        ex = fakelibvirt.make_libvirtError(",
            "                fakelibvirt.libvirtError,",
            "                '',",
            "                error_code=fakelibvirt.VIR_ERR_NO_SUPPORT)",
            "",
            "        mock_guest = mock.Mock(libvirt_guest.Guest, id=1)",
            "        mock_guest.inject_nmi = mock.Mock(side_effect=ex)",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "",
            "        with mock.patch.object(self.drvr._host, 'get_guest',",
            "                               return_value=mock_guest):",
            "            self.assertRaises(exception.TriggerCrashDumpNotSupported,",
            "                              self.drvr.trigger_crash_dump, instance)",
            "",
            "    def test_trigger_crash_dump_unexpected_error(self):",
            "        ex = fakelibvirt.make_libvirtError(",
            "                fakelibvirt.libvirtError,",
            "                'UnexpectedError',",
            "                error_code=fakelibvirt.VIR_ERR_SYSTEM_ERROR)",
            "",
            "        mock_guest = mock.Mock(libvirt_guest.Guest, id=1)",
            "        mock_guest.inject_nmi = mock.Mock(side_effect=ex)",
            "        instance = objects.Instance(uuid='fake-uuid', id=1)",
            "",
            "        with mock.patch.object(self.drvr._host, 'get_guest',",
            "                               return_value=mock_guest):",
            "            self.assertRaises(fakelibvirt.libvirtError,",
            "                              self.drvr.trigger_crash_dump, instance)",
            "",
            "",
            "class LibvirtVolumeUsageTestCase(test.NoDBTestCase):",
            "    \"\"\"Test for LibvirtDriver.get_all_volume_usage.\"\"\"",
            "",
            "    def setUp(self):",
            "        super(LibvirtVolumeUsageTestCase, self).setUp()",
            "        self.drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.c = context.get_admin_context()",
            "",
            "        self.ins_ref = objects.Instance(",
            "            id=1729,",
            "            uuid='875a8070-d0b9-4949-8b31-104d125c9a64'",
            "        )",
            "",
            "        # verify bootable volume device path also",
            "        self.bdms = [{'volume_id': 1,",
            "                      'device_name': '/dev/vde'},",
            "                     {'volume_id': 2,",
            "                      'device_name': 'vda'}]",
            "",
            "    def test_get_all_volume_usage(self):",
            "        def fake_block_stats(instance_name, disk):",
            "            return (169, 688640, 0, 0, -1)",
            "",
            "        self.stubs.Set(self.drvr, 'block_stats', fake_block_stats)",
            "        vol_usage = self.drvr.get_all_volume_usage(self.c,",
            "              [dict(instance=self.ins_ref, instance_bdms=self.bdms)])",
            "",
            "        expected_usage = [{'volume': 1,",
            "                           'instance': self.ins_ref,",
            "                           'rd_bytes': 688640, 'wr_req': 0,",
            "                           'rd_req': 169, 'wr_bytes': 0},",
            "                           {'volume': 2,",
            "                            'instance': self.ins_ref,",
            "                            'rd_bytes': 688640, 'wr_req': 0,",
            "                            'rd_req': 169, 'wr_bytes': 0}]",
            "        self.assertEqual(vol_usage, expected_usage)",
            "",
            "    def test_get_all_volume_usage_device_not_found(self):",
            "        def fake_get_domain(self, instance):",
            "            raise exception.InstanceNotFound(instance_id=\"fakedom\")",
            "",
            "        self.stubs.Set(host.Host, 'get_domain', fake_get_domain)",
            "        vol_usage = self.drvr.get_all_volume_usage(self.c,",
            "              [dict(instance=self.ins_ref, instance_bdms=self.bdms)])",
            "        self.assertEqual(vol_usage, [])",
            "",
            "",
            "class LibvirtNonblockingTestCase(test.NoDBTestCase):",
            "    \"\"\"Test libvirtd calls are nonblocking.\"\"\"",
            "",
            "    def setUp(self):",
            "        super(LibvirtNonblockingTestCase, self).setUp()",
            "        self.flags(connection_uri=\"test:///default\",",
            "                   group='libvirt')",
            "",
            "    def test_connection_to_primitive(self):",
            "        # Test bug 962840.",
            "        import nova.virt.libvirt.driver as libvirt_driver",
            "        drvr = libvirt_driver.LibvirtDriver('')",
            "        drvr.set_host_enabled = mock.Mock()",
            "        jsonutils.to_primitive(drvr._conn, convert_instances=True)",
            "",
            "    def test_tpool_execute_calls_libvirt(self):",
            "        conn = fakelibvirt.virConnect()",
            "        conn.is_expected = True",
            "",
            "        self.mox.StubOutWithMock(eventlet.tpool, 'execute')",
            "        eventlet.tpool.execute(",
            "            fakelibvirt.openAuth,",
            "            'test:///default',",
            "            mox.IgnoreArg(),",
            "            mox.IgnoreArg()).AndReturn(conn)",
            "        eventlet.tpool.execute(",
            "            conn.domainEventRegisterAny,",
            "            None,",
            "            fakelibvirt.VIR_DOMAIN_EVENT_ID_LIFECYCLE,",
            "            mox.IgnoreArg(),",
            "            mox.IgnoreArg())",
            "        if hasattr(fakelibvirt.virConnect, 'registerCloseCallback'):",
            "            eventlet.tpool.execute(",
            "                conn.registerCloseCallback,",
            "                mox.IgnoreArg(),",
            "                mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "",
            "        driver = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), True)",
            "        c = driver._get_connection()",
            "        self.assertTrue(c.is_expected)",
            "",
            "",
            "class LibvirtVolumeSnapshotTestCase(test.NoDBTestCase):",
            "    \"\"\"Tests for libvirtDriver.volume_snapshot_create/delete.\"\"\"",
            "",
            "    def setUp(self):",
            "        super(LibvirtVolumeSnapshotTestCase, self).setUp()",
            "",
            "        self.drvr = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        self.c = context.get_admin_context()",
            "",
            "        self.flags(instance_name_template='instance-%s')",
            "        self.flags(qemu_allowed_storage_drivers=[], group='libvirt')",
            "",
            "        # creating instance",
            "        self.inst = {}",
            "        self.inst['uuid'] = uuidutils.generate_uuid()",
            "        self.inst['id'] = '1'",
            "",
            "        # create domain info",
            "        self.dom_xml = \"\"\"",
            "              <domain type='kvm'>",
            "                <devices>",
            "                  <disk type='file'>",
            "                     <source file='disk1_file'/>",
            "                     <target dev='vda' bus='virtio'/>",
            "                     <serial>0e38683e-f0af-418f-a3f1-6b67ea0f919d</serial>",
            "                  </disk>",
            "                  <disk type='block'>",
            "                    <source dev='/path/to/dev/1'/>",
            "                    <target dev='vdb' bus='virtio' serial='1234'/>",
            "                  </disk>",
            "                </devices>",
            "              </domain>\"\"\"",
            "",
            "        # alternate domain info with network-backed snapshot chain",
            "        self.dom_netdisk_xml = \"\"\"",
            "              <domain type='kvm'>",
            "                <devices>",
            "                  <disk type='file'>",
            "                    <source file='disk1_file'/>",
            "                    <target dev='vda' bus='virtio'/>",
            "                    <serial>0e38683e-f0af-418f-a3f1-6b67eaffffff</serial>",
            "                  </disk>",
            "                  <disk type='network' device='disk'>",
            "                    <driver name='qemu' type='qcow2'/>",
            "                    <source protocol='gluster' name='vol1/root.img'>",
            "                      <host name='server1' port='24007'/>",
            "                    </source>",
            "                    <backingStore type='network' index='1'>",
            "                      <driver name='qemu' type='qcow2'/>",
            "                      <source protocol='gluster' name='vol1/snap.img'>",
            "                        <host name='server1' port='24007'/>",
            "                      </source>",
            "                      <backingStore type='network' index='2'>",
            "                        <driver name='qemu' type='qcow2'/>",
            "                        <source protocol='gluster' name='vol1/snap-b.img'>",
            "                          <host name='server1' port='24007'/>",
            "                        </source>",
            "                        <backingStore/>",
            "                      </backingStore>",
            "                    </backingStore>",
            "                    <target dev='vdb' bus='virtio'/>",
            "                    <serial>0e38683e-f0af-418f-a3f1-6b67ea0f919d</serial>",
            "                  </disk>",
            "                </devices>",
            "              </domain>",
            "        \"\"\"",
            "",
            "        # XML with netdisk attached, and 1 snapshot taken",
            "        self.dom_netdisk_xml_2 = \"\"\"",
            "              <domain type='kvm'>",
            "                <devices>",
            "                  <disk type='file'>",
            "                    <source file='disk1_file'/>",
            "                    <target dev='vda' bus='virtio'/>",
            "                    <serial>0e38683e-f0af-418f-a3f1-6b67eaffffff</serial>",
            "                  </disk>",
            "                  <disk type='network' device='disk'>",
            "                    <driver name='qemu' type='qcow2'/>",
            "                    <source protocol='gluster' name='vol1/snap.img'>",
            "                      <host name='server1' port='24007'/>",
            "                    </source>",
            "                    <backingStore type='network' index='1'>",
            "                      <driver name='qemu' type='qcow2'/>",
            "                      <source protocol='gluster' name='vol1/root.img'>",
            "                        <host name='server1' port='24007'/>",
            "                      </source>",
            "                      <backingStore/>",
            "                    </backingStore>",
            "                    <target dev='vdb' bus='virtio'/>",
            "                    <serial>0e38683e-f0af-418f-a3f1-6b67ea0f919d</serial>",
            "                  </disk>",
            "                </devices>",
            "              </domain>",
            "        \"\"\"",
            "",
            "        self.create_info = {'type': 'qcow2',",
            "                            'snapshot_id': '1234-5678',",
            "                            'new_file': 'new-file'}",
            "",
            "        self.volume_uuid = '0e38683e-f0af-418f-a3f1-6b67ea0f919d'",
            "        self.snapshot_id = '9c3ca9f4-9f4e-4dba-bedd-5c5e4b52b162'",
            "",
            "        self.delete_info_1 = {'type': 'qcow2',",
            "                              'file_to_merge': 'snap.img',",
            "                              'merge_target_file': None}",
            "",
            "        self.delete_info_2 = {'type': 'qcow2',",
            "                              'file_to_merge': 'snap.img',",
            "                              'merge_target_file': 'other-snap.img'}",
            "",
            "        self.delete_info_3 = {'type': 'qcow2',",
            "                              'file_to_merge': None,",
            "                              'merge_target_file': None}",
            "",
            "        self.delete_info_netdisk = {'type': 'qcow2',",
            "                                    'file_to_merge': 'snap.img',",
            "                                    'merge_target_file': 'root.img'}",
            "",
            "        self.delete_info_invalid_type = {'type': 'made_up_type',",
            "                                         'file_to_merge': 'some_file',",
            "                                         'merge_target_file':",
            "                                             'some_other_file'}",
            "",
            "    def tearDown(self):",
            "        super(LibvirtVolumeSnapshotTestCase, self).tearDown()",
            "",
            "    @mock.patch('nova.virt.block_device.DriverVolumeBlockDevice.'",
            "                'refresh_connection_info')",
            "    @mock.patch('nova.objects.block_device.BlockDeviceMapping.'",
            "                'get_by_volume_and_instance')",
            "    def test_volume_refresh_connection_info(self,",
            "                                            mock_get_by_volume_and_instance,",
            "                                            mock_refresh_connection_info):",
            "        instance = objects.Instance(**self.inst)",
            "        fake_bdm = fake_block_device.FakeDbBlockDeviceDict({",
            "            'id': 123,",
            "            'instance_uuid': 'fake-instance',",
            "            'device_name': '/dev/sdb',",
            "            'source_type': 'volume',",
            "            'destination_type': 'volume',",
            "            'volume_id': 'fake-volume-id-1',",
            "            'connection_info': '{\"fake\": \"connection_info\"}'})",
            "        fake_bdm = objects.BlockDeviceMapping(self.c, **fake_bdm)",
            "        mock_get_by_volume_and_instance.return_value = fake_bdm",
            "",
            "        self.drvr._volume_refresh_connection_info(self.c, instance,",
            "                                                  self.volume_uuid)",
            "",
            "        mock_get_by_volume_and_instance.assert_called_once_with(",
            "            self.c, self.volume_uuid, instance.uuid)",
            "        mock_refresh_connection_info.assert_called_once_with(self.c, instance,",
            "            self.drvr._volume_api, self.drvr)",
            "",
            "    def test_volume_snapshot_create(self, quiesce=True):",
            "        \"\"\"Test snapshot creation with file-based disk.\"\"\"",
            "        self.flags(instance_name_template='instance-%s')",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_api')",
            "",
            "        instance = objects.Instance(**self.inst)",
            "",
            "        new_file = 'new-file'",
            "",
            "        domain = FakeVirtDomain(fake_xml=self.dom_xml)",
            "        self.mox.StubOutWithMock(domain, 'XMLDesc')",
            "        self.mox.StubOutWithMock(domain, 'snapshotCreateXML')",
            "        domain.XMLDesc(flags=0).AndReturn(self.dom_xml)",
            "",
            "        snap_xml_src = (",
            "           '<domainsnapshot>\\n'",
            "           '  <disks>\\n'",
            "           '    <disk name=\"disk1_file\" snapshot=\"external\" type=\"file\">\\n'",
            "           '      <source file=\"new-file\"/>\\n'",
            "           '    </disk>\\n'",
            "           '    <disk name=\"vdb\" snapshot=\"no\"/>\\n'",
            "           '  </disks>\\n'",
            "           '</domainsnapshot>\\n')",
            "",
            "        # Older versions of libvirt may be missing these.",
            "        fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT = 32",
            "        fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE = 64",
            "",
            "        snap_flags = (fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY |",
            "                      fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA |",
            "                      fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT)",
            "",
            "        snap_flags_q = (snap_flags |",
            "                        fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE)",
            "",
            "        if quiesce:",
            "            domain.snapshotCreateXML(snap_xml_src, flags=snap_flags_q)",
            "        else:",
            "            domain.snapshotCreateXML(snap_xml_src, flags=snap_flags_q).\\",
            "                AndRaise(fakelibvirt.libvirtError(",
            "                            'quiescing failed, no qemu-ga'))",
            "            domain.snapshotCreateXML(snap_xml_src, flags=snap_flags)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        guest = libvirt_guest.Guest(domain)",
            "        self.drvr._volume_snapshot_create(self.c, instance, guest,",
            "                                          self.volume_uuid, new_file)",
            "",
            "        self.mox.VerifyAll()",
            "",
            "    def test_volume_snapshot_create_libgfapi(self, quiesce=True):",
            "        \"\"\"Test snapshot creation with libgfapi network disk.\"\"\"",
            "        self.flags(instance_name_template = 'instance-%s')",
            "        self.flags(qemu_allowed_storage_drivers = ['gluster'], group='libvirt')",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_api')",
            "",
            "        self.dom_xml = \"\"\"",
            "              <domain type='kvm'>",
            "                <devices>",
            "                  <disk type='file'>",
            "                    <source file='disk1_file'/>",
            "                    <target dev='vda' bus='virtio'/>",
            "                    <serial>0e38683e-f0af-418f-a3f1-6b67ea0f919d</serial>",
            "                  </disk>",
            "                  <disk type='block'>",
            "                    <source protocol='gluster' name='gluster1/volume-1234'>",
            "                      <host name='127.3.4.5' port='24007'/>",
            "                    </source>",
            "                    <target dev='vdb' bus='virtio' serial='1234'/>",
            "                  </disk>",
            "                </devices>",
            "              </domain>\"\"\"",
            "",
            "        instance = objects.Instance(**self.inst)",
            "",
            "        new_file = 'new-file'",
            "",
            "        domain = FakeVirtDomain(fake_xml=self.dom_xml)",
            "        self.mox.StubOutWithMock(domain, 'XMLDesc')",
            "        self.mox.StubOutWithMock(domain, 'snapshotCreateXML')",
            "        domain.XMLDesc(flags=0).AndReturn(self.dom_xml)",
            "",
            "        snap_xml_src = (",
            "           '<domainsnapshot>\\n'",
            "           '  <disks>\\n'",
            "           '    <disk name=\"disk1_file\" snapshot=\"external\" type=\"file\">\\n'",
            "           '      <source file=\"new-file\"/>\\n'",
            "           '    </disk>\\n'",
            "           '    <disk name=\"vdb\" snapshot=\"no\"/>\\n'",
            "           '  </disks>\\n'",
            "           '</domainsnapshot>\\n')",
            "",
            "        # Older versions of libvirt may be missing these.",
            "        fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT = 32",
            "        fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE = 64",
            "",
            "        snap_flags = (fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY |",
            "                      fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA |",
            "                      fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_REUSE_EXT)",
            "",
            "        snap_flags_q = (snap_flags |",
            "                        fakelibvirt.VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE)",
            "",
            "        if quiesce:",
            "            domain.snapshotCreateXML(snap_xml_src, flags=snap_flags_q)",
            "        else:",
            "            domain.snapshotCreateXML(snap_xml_src, flags=snap_flags_q).\\",
            "                AndRaise(fakelibvirt.libvirtError(",
            "                    'quiescing failed, no qemu-ga'))",
            "            domain.snapshotCreateXML(snap_xml_src, flags=snap_flags)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        guest = libvirt_guest.Guest(domain)",
            "        self.drvr._volume_snapshot_create(self.c, instance, guest,",
            "                                          self.volume_uuid, new_file)",
            "",
            "        self.mox.VerifyAll()",
            "",
            "    def test_volume_snapshot_create_noquiesce(self):",
            "        self.test_volume_snapshot_create(quiesce=False)",
            "",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    def test_can_quiesce(self, ver):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        instance = objects.Instance(**self.inst)",
            "        image_meta = objects.ImageMeta.from_dict(",
            "            {\"properties\": {",
            "                \"hw_qemu_guest_agent\": \"yes\"}})",
            "        self.assertIsNone(self.drvr._can_quiesce(instance, image_meta))",
            "",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    def test_can_quiesce_bad_hyp(self, ver):",
            "        self.flags(virt_type='xxx', group='libvirt')",
            "        instance = objects.Instance(**self.inst)",
            "        image_meta = objects.ImageMeta.from_dict(",
            "            {\"properties\": {",
            "                \"hw_qemu_guest_agent\": \"yes\"}})",
            "        self.assertRaises(exception.InstanceQuiesceNotSupported,",
            "                          self.drvr._can_quiesce, instance, image_meta)",
            "",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=False)",
            "    def test_can_quiesce_bad_ver(self, ver):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        instance = objects.Instance(**self.inst)",
            "        image_meta = {\"properties\": {",
            "            \"hw_qemu_guest_agent\": \"yes\"}}",
            "        self.assertRaises(exception.InstanceQuiesceNotSupported,",
            "                          self.drvr._can_quiesce, instance, image_meta)",
            "",
            "    @mock.patch.object(host.Host,",
            "                       'has_min_version', return_value=True)",
            "    def test_can_quiesce_agent_not_enable(self, ver):",
            "        self.flags(virt_type='kvm', group='libvirt')",
            "        instance = objects.Instance(**self.inst)",
            "        image_meta = objects.ImageMeta.from_dict({})",
            "        self.assertRaises(exception.QemuGuestAgentNotEnabled,",
            "                          self.drvr._can_quiesce, instance, image_meta)",
            "",
            "    def test_volume_snapshot_create_outer_success(self):",
            "        instance = objects.Instance(**self.inst)",
            "",
            "        domain = FakeVirtDomain(fake_xml=self.dom_xml, id=1)",
            "        guest = libvirt_guest.Guest(domain)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_guest')",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_api')",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_snapshot_create')",
            "",
            "        self.drvr._host.get_guest(instance).AndReturn(guest)",
            "",
            "        self.drvr._volume_snapshot_create(self.c,",
            "                                          instance,",
            "                                          guest,",
            "                                          self.volume_uuid,",
            "                                          self.create_info['new_file'])",
            "",
            "        self.drvr._volume_api.update_snapshot_status(",
            "            self.c, self.create_info['snapshot_id'], 'creating')",
            "",
            "        self.mox.StubOutWithMock(self.drvr._volume_api, 'get_snapshot')",
            "        self.drvr._volume_api.get_snapshot(self.c,",
            "            self.create_info['snapshot_id']).AndReturn({'status': 'available'})",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_refresh_connection_info')",
            "        self.drvr._volume_refresh_connection_info(self.c, instance,",
            "                                                  self.volume_uuid)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.drvr.volume_snapshot_create(self.c, instance, self.volume_uuid,",
            "                                         self.create_info)",
            "",
            "    def test_volume_snapshot_create_outer_failure(self):",
            "        instance = objects.Instance(**self.inst)",
            "",
            "        domain = FakeVirtDomain(fake_xml=self.dom_xml, id=1)",
            "        guest = libvirt_guest.Guest(domain)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_guest')",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_api')",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_snapshot_create')",
            "",
            "        self.drvr._host.get_guest(instance).AndReturn(guest)",
            "",
            "        self.drvr._volume_snapshot_create(self.c,",
            "                                          instance,",
            "                                          guest,",
            "                                          self.volume_uuid,",
            "                                          self.create_info['new_file']).\\",
            "            AndRaise(exception.NovaException('oops'))",
            "",
            "        self.drvr._volume_api.update_snapshot_status(",
            "            self.c, self.create_info['snapshot_id'], 'error')",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(exception.NovaException,",
            "                          self.drvr.volume_snapshot_create,",
            "                          self.c,",
            "                          instance,",
            "                          self.volume_uuid,",
            "                          self.create_info)",
            "",
            "    def test_volume_snapshot_delete_1(self):",
            "        \"\"\"Deleting newest snapshot -- blockRebase.\"\"\"",
            "",
            "        # libvirt lib doesn't have VIR_DOMAIN_BLOCK_REBASE_RELATIVE flag",
            "        fakelibvirt.__dict__.pop('VIR_DOMAIN_BLOCK_REBASE_RELATIVE')",
            "        self.stubs.Set(libvirt_driver, 'libvirt', fakelibvirt)",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "",
            "        domain = FakeVirtDomain(fake_xml=self.dom_xml)",
            "        self.mox.StubOutWithMock(domain, 'XMLDesc')",
            "        domain.XMLDesc(flags=0).AndReturn(self.dom_xml)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr._host, 'has_min_version')",
            "        self.mox.StubOutWithMock(domain, 'blockRebase')",
            "        self.mox.StubOutWithMock(domain, 'blockCommit')",
            "        self.mox.StubOutWithMock(domain, 'blockJobInfo')",
            "",
            "        self.drvr._host.get_domain(instance).AndReturn(domain)",
            "        self.drvr._host.has_min_version(mox.IgnoreArg()).AndReturn(True)",
            "",
            "        domain.blockRebase('vda', 'snap.img', 0, flags=0)",
            "",
            "        domain.blockJobInfo('vda', flags=0).AndReturn({'cur': 1, 'end': 1000})",
            "        domain.blockJobInfo('vda', flags=0).AndReturn(",
            "            {'cur': 1000, 'end': 1000})",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.drvr._volume_snapshot_delete(self.c, instance, self.volume_uuid,",
            "                                          snapshot_id, self.delete_info_1)",
            "",
            "        self.mox.VerifyAll()",
            "        fakelibvirt.__dict__.update({'VIR_DOMAIN_BLOCK_REBASE_RELATIVE': 8})",
            "",
            "    def test_volume_snapshot_delete_relative_1(self):",
            "        \"\"\"Deleting newest snapshot -- blockRebase using relative flag\"\"\"",
            "",
            "        self.stubs.Set(libvirt_driver, 'libvirt', fakelibvirt)",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "",
            "        domain = FakeVirtDomain(fake_xml=self.dom_xml)",
            "        guest = libvirt_guest.Guest(domain)",
            "        self.mox.StubOutWithMock(domain, 'XMLDesc')",
            "        domain.XMLDesc(flags=0).AndReturn(self.dom_xml)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_guest')",
            "        self.mox.StubOutWithMock(self.drvr._host, 'has_min_version')",
            "        self.mox.StubOutWithMock(domain, 'blockRebase')",
            "        self.mox.StubOutWithMock(domain, 'blockCommit')",
            "        self.mox.StubOutWithMock(domain, 'blockJobInfo')",
            "",
            "        self.drvr._host.get_guest(instance).AndReturn(guest)",
            "        self.drvr._host.has_min_version(mox.IgnoreArg()).AndReturn(True)",
            "",
            "        domain.blockRebase('vda', 'snap.img', 0,",
            "                           flags=fakelibvirt.VIR_DOMAIN_BLOCK_REBASE_RELATIVE)",
            "",
            "        domain.blockJobInfo('vda', flags=0).AndReturn({'cur': 1, 'end': 1000})",
            "        domain.blockJobInfo('vda', flags=0).AndReturn(",
            "            {'cur': 1000, 'end': 1000})",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.drvr._volume_snapshot_delete(self.c, instance, self.volume_uuid,",
            "                                          snapshot_id, self.delete_info_1)",
            "",
            "        self.mox.VerifyAll()",
            "",
            "    def _setup_block_rebase_domain_and_guest_mocks(self, dom_xml):",
            "        mock_domain = mock.Mock(spec=fakelibvirt.virDomain)",
            "        mock_domain.XMLDesc.return_value = dom_xml",
            "        guest = libvirt_guest.Guest(mock_domain)",
            "",
            "        exc = fakelibvirt.make_libvirtError(",
            "            fakelibvirt.libvirtError, 'virDomainBlockRebase() failed',",
            "            error_code=fakelibvirt.VIR_ERR_OPERATION_INVALID)",
            "        mock_domain.blockRebase.side_effect = exc",
            "",
            "        return mock_domain, guest",
            "",
            "    @mock.patch.object(host.Host, \"has_min_version\",",
            "                       mock.Mock(return_value=True))",
            "    @mock.patch(\"nova.virt.libvirt.guest.Guest.is_active\",",
            "                 mock.Mock(return_value=False))",
            "    @mock.patch('nova.virt.images.qemu_img_info',",
            "                return_value=mock.Mock(file_format=\"fake_fmt\"))",
            "    @mock.patch('nova.utils.execute')",
            "    def test_volume_snapshot_delete_when_dom_not_running(self, mock_execute,",
            "                                                         mock_qemu_img_info):",
            "        \"\"\"Deleting newest snapshot of a file-based image when the domain is",
            "        not running should trigger a blockRebase using qemu-img not libvirt.",
            "        In this test, we rebase the image with another image as backing file.",
            "        \"\"\"",
            "        mock_domain, guest = self._setup_block_rebase_domain_and_guest_mocks(",
            "                                self.dom_xml)",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "        with mock.patch.object(self.drvr._host, 'get_guest',",
            "                               return_value=guest):",
            "            self.drvr._volume_snapshot_delete(self.c, instance,",
            "                                              self.volume_uuid, snapshot_id,",
            "                                              self.delete_info_1)",
            "",
            "        mock_qemu_img_info.assert_called_once_with(\"snap.img\")",
            "        mock_execute.assert_called_once_with('qemu-img', 'rebase',",
            "                                             '-b', 'snap.img', '-F',",
            "                                             'fake_fmt', 'disk1_file')",
            "",
            "    @mock.patch.object(host.Host, \"has_min_version\",",
            "                       mock.Mock(return_value=True))",
            "    @mock.patch(\"nova.virt.libvirt.guest.Guest.is_active\",",
            "                 mock.Mock(return_value=False))",
            "    @mock.patch('nova.virt.images.qemu_img_info',",
            "                return_value=mock.Mock(file_format=\"fake_fmt\"))",
            "    @mock.patch('nova.utils.execute')",
            "    def test_volume_snapshot_delete_when_dom_not_running_and_no_rebase_base(",
            "        self, mock_execute, mock_qemu_img_info):",
            "        \"\"\"Deleting newest snapshot of a file-based image when the domain is",
            "        not running should trigger a blockRebase using qemu-img not libvirt.",
            "        In this test, the image is rebased onto no backing file (i.e.",
            "        it will exist independently of any backing file)",
            "        \"\"\"",
            "        mock_domain, mock_guest = (",
            "            self._setup_block_rebase_domain_and_guest_mocks(self.dom_xml))",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "        with mock.patch.object(self.drvr._host, 'get_guest',",
            "                               return_value=mock_guest):",
            "            self.drvr._volume_snapshot_delete(self.c, instance,",
            "                                              self.volume_uuid, snapshot_id,",
            "                                              self.delete_info_3)",
            "",
            "        self.assertEqual(0, mock_qemu_img_info.call_count)",
            "        mock_execute.assert_called_once_with('qemu-img', 'rebase',",
            "                                             '-b', '', 'disk1_file')",
            "",
            "    @mock.patch.object(host.Host, \"has_min_version\",",
            "                       mock.Mock(return_value=True))",
            "    @mock.patch(\"nova.virt.libvirt.guest.Guest.is_active\",",
            "                 mock.Mock(return_value=False))",
            "    def test_volume_snapshot_delete_when_dom_with_nw_disk_not_running(self):",
            "        \"\"\"Deleting newest snapshot of a network disk when the domain is not",
            "        running should raise a NovaException.",
            "        \"\"\"",
            "        mock_domain, mock_guest = (",
            "            self._setup_block_rebase_domain_and_guest_mocks(",
            "                self.dom_netdisk_xml))",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "        with mock.patch.object(self.drvr._host, 'get_guest',",
            "                               return_value=mock_guest):",
            "            ex = self.assertRaises(exception.NovaException,",
            "                                   self.drvr._volume_snapshot_delete,",
            "                                   self.c, instance, self.volume_uuid,",
            "                                   snapshot_id, self.delete_info_1)",
            "            self.assertIn('has not been fully tested', six.text_type(ex))",
            "",
            "    def test_volume_snapshot_delete_2(self):",
            "        \"\"\"Deleting older snapshot -- blockCommit.\"\"\"",
            "",
            "        # libvirt lib doesn't have VIR_DOMAIN_BLOCK_COMMIT_RELATIVE",
            "        fakelibvirt.__dict__.pop('VIR_DOMAIN_BLOCK_COMMIT_RELATIVE')",
            "        self.stubs.Set(libvirt_driver, 'libvirt', fakelibvirt)",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "",
            "        domain = FakeVirtDomain(fake_xml=self.dom_xml)",
            "        self.mox.StubOutWithMock(domain, 'XMLDesc')",
            "        domain.XMLDesc(flags=0).AndReturn(self.dom_xml)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr._host, 'has_min_version')",
            "        self.mox.StubOutWithMock(domain, 'blockRebase')",
            "        self.mox.StubOutWithMock(domain, 'blockCommit')",
            "        self.mox.StubOutWithMock(domain, 'blockJobInfo')",
            "",
            "        self.drvr._host.get_domain(instance).AndReturn(domain)",
            "        self.drvr._host.has_min_version(mox.IgnoreArg()).AndReturn(True)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(exception.Invalid,",
            "                          self.drvr._volume_snapshot_delete,",
            "                          self.c,",
            "                          instance,",
            "                          self.volume_uuid,",
            "                          snapshot_id,",
            "                          self.delete_info_2)",
            "",
            "        fakelibvirt.__dict__.update({'VIR_DOMAIN_BLOCK_COMMIT_RELATIVE': 4})",
            "",
            "    def test_volume_snapshot_delete_relative_2(self):",
            "        \"\"\"Deleting older snapshot -- blockCommit using relative flag\"\"\"",
            "",
            "        self.stubs.Set(libvirt_driver, 'libvirt', fakelibvirt)",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "",
            "        domain = FakeVirtDomain(fake_xml=self.dom_xml)",
            "        self.mox.StubOutWithMock(domain, 'XMLDesc')",
            "        domain.XMLDesc(flags=0).AndReturn(self.dom_xml)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr._host, 'has_min_version')",
            "        self.mox.StubOutWithMock(domain, 'blockRebase')",
            "        self.mox.StubOutWithMock(domain, 'blockCommit')",
            "        self.mox.StubOutWithMock(domain, 'blockJobInfo')",
            "",
            "        self.drvr._host.get_domain(instance).AndReturn(domain)",
            "        self.drvr._host.has_min_version(mox.IgnoreArg()).AndReturn(True)",
            "",
            "        domain.blockCommit('vda', 'other-snap.img', 'snap.img', 0,",
            "                           flags=fakelibvirt.VIR_DOMAIN_BLOCK_COMMIT_RELATIVE)",
            "",
            "        domain.blockJobInfo('vda', flags=0).AndReturn({'cur': 1, 'end': 1000})",
            "        domain.blockJobInfo('vda', flags=0).AndReturn({})",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.drvr._volume_snapshot_delete(self.c, instance, self.volume_uuid,",
            "                                          snapshot_id, self.delete_info_2)",
            "",
            "        self.mox.VerifyAll()",
            "",
            "    def test_volume_snapshot_delete_nonrelative_null_base(self):",
            "        # Deleting newest and last snapshot of a volume",
            "        # with blockRebase. So base of the new image will be null.",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "",
            "        domain = FakeVirtDomain(fake_xml=self.dom_xml)",
            "        guest = libvirt_guest.Guest(domain)",
            "",
            "        with test.nested(",
            "            mock.patch.object(domain, 'XMLDesc', return_value=self.dom_xml),",
            "            mock.patch.object(self.drvr._host, 'get_guest',",
            "                              return_value=guest),",
            "            mock.patch.object(self.drvr._host, 'has_min_version',",
            "                              return_value=True),",
            "            mock.patch.object(domain, 'blockRebase'),",
            "            mock.patch.object(domain, 'blockJobInfo',",
            "                              return_value={'cur': 1000, 'end': 1000})",
            "        ) as (mock_xmldesc, mock_get_guest, mock_has_min_version,",
            "              mock_rebase, mock_job_info):",
            "",
            "            self.drvr._volume_snapshot_delete(self.c, instance,",
            "                                              self.volume_uuid, snapshot_id,",
            "                                              self.delete_info_3)",
            "",
            "            mock_xmldesc.assert_called_once_with(flags=0)",
            "            mock_get_guest.assert_called_once_with(instance)",
            "            mock_has_min_version.assert_called_once_with((1, 1, 1,))",
            "            mock_rebase.assert_called_once_with('vda', None, 0, flags=0)",
            "            mock_job_info.assert_called_once_with('vda', flags=0)",
            "",
            "    def test_volume_snapshot_delete_netdisk_nonrelative_null_base(self):",
            "        # Deleting newest and last snapshot of a network attached volume",
            "        # with blockRebase. So base of the new image will be null.",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "",
            "        domain = FakeVirtDomain(fake_xml=self.dom_netdisk_xml_2)",
            "        guest = libvirt_guest.Guest(domain)",
            "",
            "        with test.nested(",
            "            mock.patch.object(domain, 'XMLDesc',",
            "                              return_value=self.dom_netdisk_xml_2),",
            "            mock.patch.object(self.drvr._host, 'get_guest',",
            "                              return_value=guest),",
            "            mock.patch.object(self.drvr._host, 'has_min_version',",
            "                              return_value=True),",
            "            mock.patch.object(domain, 'blockRebase'),",
            "            mock.patch.object(domain, 'blockJobInfo',",
            "                              return_value={'cur': 1000, 'end': 1000})",
            "        ) as (mock_xmldesc, mock_get_guest, mock_has_min_version,",
            "              mock_rebase, mock_job_info):",
            "",
            "            self.drvr._volume_snapshot_delete(self.c, instance,",
            "                                              self.volume_uuid, snapshot_id,",
            "                                              self.delete_info_3)",
            "",
            "            mock_xmldesc.assert_called_once_with(flags=0)",
            "            mock_get_guest.assert_called_once_with(instance)",
            "            mock_has_min_version.assert_called_once_with((1, 1, 1,))",
            "            mock_rebase.assert_called_once_with('vdb', None, 0, flags=0)",
            "            mock_job_info.assert_called_once_with('vdb', flags=0)",
            "",
            "    def test_volume_snapshot_delete_outer_success(self):",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "",
            "        FakeVirtDomain(fake_xml=self.dom_xml)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_api')",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_snapshot_delete')",
            "",
            "        self.drvr._volume_snapshot_delete(self.c,",
            "                                          instance,",
            "                                          self.volume_uuid,",
            "                                          snapshot_id,",
            "                                          delete_info=self.delete_info_1)",
            "",
            "        self.drvr._volume_api.update_snapshot_status(",
            "            self.c, snapshot_id, 'deleting')",
            "",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_refresh_connection_info')",
            "        self.drvr._volume_refresh_connection_info(self.c, instance,",
            "                                                  self.volume_uuid)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.drvr.volume_snapshot_delete(self.c, instance, self.volume_uuid,",
            "                                         snapshot_id,",
            "                                         self.delete_info_1)",
            "",
            "        self.mox.VerifyAll()",
            "",
            "    def test_volume_snapshot_delete_outer_failure(self):",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = '1234-9876'",
            "",
            "        FakeVirtDomain(fake_xml=self.dom_xml)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_api')",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_snapshot_delete')",
            "",
            "        self.drvr._volume_snapshot_delete(self.c,",
            "                                          instance,",
            "                                          self.volume_uuid,",
            "                                          snapshot_id,",
            "                                          delete_info=self.delete_info_1).\\",
            "            AndRaise(exception.NovaException('oops'))",
            "",
            "        self.drvr._volume_api.update_snapshot_status(",
            "            self.c, snapshot_id, 'error_deleting')",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(exception.NovaException,",
            "                          self.drvr.volume_snapshot_delete,",
            "                          self.c,",
            "                          instance,",
            "                          self.volume_uuid,",
            "                          snapshot_id,",
            "                          self.delete_info_1)",
            "",
            "        self.mox.VerifyAll()",
            "",
            "    def test_volume_snapshot_delete_invalid_type(self):",
            "        instance = objects.Instance(**self.inst)",
            "",
            "        FakeVirtDomain(fake_xml=self.dom_xml)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr, '_volume_api')",
            "        self.mox.StubOutWithMock(self.drvr._host, 'has_min_version')",
            "",
            "        self.drvr._host.has_min_version(mox.IgnoreArg()).AndReturn(True)",
            "",
            "        self.drvr._volume_api.update_snapshot_status(",
            "            self.c, self.snapshot_id, 'error_deleting')",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(exception.NovaException,",
            "                          self.drvr.volume_snapshot_delete,",
            "                          self.c,",
            "                          instance,",
            "                          self.volume_uuid,",
            "                          self.snapshot_id,",
            "                          self.delete_info_invalid_type)",
            "",
            "    def test_volume_snapshot_delete_netdisk_1(self):",
            "        \"\"\"Delete newest snapshot -- blockRebase for libgfapi/network disk.\"\"\"",
            "",
            "        class FakeNetdiskDomain(FakeVirtDomain):",
            "            def __init__(self, *args, **kwargs):",
            "                super(FakeNetdiskDomain, self).__init__(*args, **kwargs)",
            "",
            "            def XMLDesc(self, flags):",
            "                return self.dom_netdisk_xml",
            "",
            "        # libvirt lib doesn't have VIR_DOMAIN_BLOCK_REBASE_RELATIVE",
            "        fakelibvirt.__dict__.pop('VIR_DOMAIN_BLOCK_REBASE_RELATIVE')",
            "        self.stubs.Set(libvirt_driver, 'libvirt', fakelibvirt)",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "",
            "        domain = FakeNetdiskDomain(fake_xml=self.dom_netdisk_xml)",
            "        self.mox.StubOutWithMock(domain, 'XMLDesc')",
            "        domain.XMLDesc(flags=0).AndReturn(self.dom_netdisk_xml)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr._host, 'has_min_version')",
            "        self.mox.StubOutWithMock(domain, 'blockRebase')",
            "        self.mox.StubOutWithMock(domain, 'blockCommit')",
            "        self.mox.StubOutWithMock(domain, 'blockJobInfo')",
            "",
            "        self.drvr._host.get_domain(instance).AndReturn(domain)",
            "        self.drvr._host.has_min_version(mox.IgnoreArg()).AndReturn(True)",
            "",
            "        domain.blockRebase('vdb', 'vdb[1]', 0, flags=0)",
            "",
            "        domain.blockJobInfo('vdb', flags=0).AndReturn({'cur': 1, 'end': 1000})",
            "        domain.blockJobInfo('vdb', flags=0).AndReturn(",
            "            {'cur': 1000, 'end': 1000})",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.drvr._volume_snapshot_delete(self.c, instance, self.volume_uuid,",
            "                                          snapshot_id, self.delete_info_1)",
            "        self.mox.VerifyAll()",
            "        fakelibvirt.__dict__.update({'VIR_DOMAIN_BLOCK_REBASE_RELATIVE': 8})",
            "",
            "    def test_volume_snapshot_delete_netdisk_relative_1(self):",
            "        \"\"\"Delete newest snapshot -- blockRebase for libgfapi/network disk.\"\"\"",
            "",
            "        class FakeNetdiskDomain(FakeVirtDomain):",
            "            def __init__(self, *args, **kwargs):",
            "                super(FakeNetdiskDomain, self).__init__(*args, **kwargs)",
            "",
            "            def XMLDesc(self, flags):",
            "                return self.dom_netdisk_xml",
            "",
            "        self.stubs.Set(libvirt_driver, 'libvirt', fakelibvirt)",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "",
            "        domain = FakeNetdiskDomain(fake_xml=self.dom_netdisk_xml)",
            "        self.mox.StubOutWithMock(domain, 'XMLDesc')",
            "        domain.XMLDesc(flags=0).AndReturn(self.dom_netdisk_xml)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr._host, 'has_min_version')",
            "        self.mox.StubOutWithMock(domain, 'blockRebase')",
            "        self.mox.StubOutWithMock(domain, 'blockCommit')",
            "        self.mox.StubOutWithMock(domain, 'blockJobInfo')",
            "",
            "        self.drvr._host.get_domain(instance).AndReturn(domain)",
            "        self.drvr._host.has_min_version(mox.IgnoreArg()).AndReturn(True)",
            "",
            "        domain.blockRebase('vdb', 'vdb[1]', 0,",
            "                           flags=fakelibvirt.VIR_DOMAIN_BLOCK_REBASE_RELATIVE)",
            "",
            "        domain.blockJobInfo('vdb', flags=0).AndReturn({'cur': 1, 'end': 1000})",
            "        domain.blockJobInfo('vdb', flags=0).AndReturn(",
            "            {'cur': 1000, 'end': 1000})",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.drvr._volume_snapshot_delete(self.c, instance, self.volume_uuid,",
            "                                          snapshot_id, self.delete_info_1)",
            "",
            "        self.mox.VerifyAll()",
            "",
            "    def test_volume_snapshot_delete_netdisk_2(self):",
            "        \"\"\"Delete older snapshot -- blockCommit for libgfapi/network disk.\"\"\"",
            "",
            "        class FakeNetdiskDomain(FakeVirtDomain):",
            "            def __init__(self, *args, **kwargs):",
            "                super(FakeNetdiskDomain, self).__init__(*args, **kwargs)",
            "",
            "            def XMLDesc(self, flags):",
            "                return self.dom_netdisk_xml",
            "",
            "        # libvirt lib doesn't have VIR_DOMAIN_BLOCK_COMMIT_RELATIVE",
            "        fakelibvirt.__dict__.pop('VIR_DOMAIN_BLOCK_COMMIT_RELATIVE')",
            "        self.stubs.Set(libvirt_driver, 'libvirt', fakelibvirt)",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "",
            "        domain = FakeNetdiskDomain(fake_xml=self.dom_netdisk_xml)",
            "        self.mox.StubOutWithMock(domain, 'XMLDesc')",
            "        domain.XMLDesc(flags=0).AndReturn(self.dom_netdisk_xml)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr._host, 'has_min_version')",
            "        self.mox.StubOutWithMock(domain, 'blockRebase')",
            "        self.mox.StubOutWithMock(domain, 'blockCommit')",
            "        self.mox.StubOutWithMock(domain, 'blockJobInfo')",
            "",
            "        self.drvr._host.get_domain(instance).AndReturn(domain)",
            "        self.drvr._host.has_min_version(mox.IgnoreArg()).AndReturn(True)",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.assertRaises(exception.Invalid,",
            "                          self.drvr._volume_snapshot_delete,",
            "                          self.c,",
            "                          instance,",
            "                          self.volume_uuid,",
            "                          snapshot_id,",
            "                          self.delete_info_netdisk)",
            "        fakelibvirt.__dict__.update({'VIR_DOMAIN_BLOCK_COMMIT_RELATIVE': 4})",
            "",
            "    def test_volume_snapshot_delete_netdisk_relative_2(self):",
            "        \"\"\"Delete older snapshot -- blockCommit for libgfapi/network disk.\"\"\"",
            "",
            "        class FakeNetdiskDomain(FakeVirtDomain):",
            "            def __init__(self, *args, **kwargs):",
            "                super(FakeNetdiskDomain, self).__init__(*args, **kwargs)",
            "",
            "            def XMLDesc(self, flags):",
            "                return self.dom_netdisk_xml",
            "",
            "        self.stubs.Set(libvirt_driver, 'libvirt', fakelibvirt)",
            "",
            "        instance = objects.Instance(**self.inst)",
            "        snapshot_id = 'snapshot-1234'",
            "",
            "        domain = FakeNetdiskDomain(fake_xml=self.dom_netdisk_xml)",
            "        self.mox.StubOutWithMock(domain, 'XMLDesc')",
            "        domain.XMLDesc(flags=0).AndReturn(self.dom_netdisk_xml)",
            "",
            "        self.mox.StubOutWithMock(self.drvr._host, 'get_domain')",
            "        self.mox.StubOutWithMock(self.drvr._host, 'has_min_version')",
            "        self.mox.StubOutWithMock(domain, 'blockRebase')",
            "        self.mox.StubOutWithMock(domain, 'blockCommit')",
            "        self.mox.StubOutWithMock(domain, 'blockJobInfo')",
            "",
            "        self.drvr._host.get_domain(instance).AndReturn(domain)",
            "        self.drvr._host.has_min_version(mox.IgnoreArg()).AndReturn(True)",
            "",
            "        domain.blockCommit('vdb', 'vdb[0]', 'vdb[1]', 0,",
            "                           flags=fakelibvirt.VIR_DOMAIN_BLOCK_COMMIT_RELATIVE)",
            "",
            "        domain.blockJobInfo('vdb', flags=0).AndReturn({'cur': 1, 'end': 1000})",
            "        domain.blockJobInfo('vdb', flags=0).AndReturn(",
            "            {'cur': 1000, 'end': 1000})",
            "",
            "        self.mox.ReplayAll()",
            "",
            "        self.drvr._volume_snapshot_delete(self.c, instance, self.volume_uuid,",
            "                                          snapshot_id,",
            "                                          self.delete_info_netdisk)",
            "",
            "        self.mox.VerifyAll()",
            "",
            "",
            "def _fake_convert_image(source, dest, in_format, out_format,",
            "                               run_as_root=True):",
            "    libvirt_driver.libvirt_utils.files[dest] = ''",
            "",
            "",
            "class _BaseSnapshotTests(test.NoDBTestCase):",
            "    def setUp(self):",
            "        super(_BaseSnapshotTests, self).setUp()",
            "        self.flags(snapshots_directory='./', group='libvirt')",
            "        self.context = context.get_admin_context()",
            "",
            "        self.useFixture(fixtures.MonkeyPatch(",
            "            'nova.virt.libvirt.driver.libvirt_utils',",
            "            fake_libvirt_utils))",
            "        self.useFixture(fixtures.MonkeyPatch(",
            "            'nova.virt.libvirt.imagebackend.libvirt_utils',",
            "            fake_libvirt_utils))",
            "",
            "        self.image_service = nova.tests.unit.image.fake.stub_out_image_service(",
            "                self)",
            "",
            "        self.mock_update_task_state = mock.Mock()",
            "",
            "        test_instance = _create_test_instance()",
            "        self.instance_ref = objects.Instance(**test_instance)",
            "        self.instance_ref.info_cache = objects.InstanceInfoCache(",
            "            network_info=None)",
            "",
            "    def _assert_snapshot(self, snapshot, disk_format,",
            "                         expected_properties=None):",
            "        self.mock_update_task_state.assert_has_calls([",
            "            mock.call(task_state=task_states.IMAGE_PENDING_UPLOAD),",
            "            mock.call(task_state=task_states.IMAGE_UPLOADING,",
            "                      expected_state=task_states.IMAGE_PENDING_UPLOAD)])",
            "",
            "        props = snapshot['properties']",
            "        self.assertEqual(props['image_state'], 'available')",
            "        self.assertEqual(snapshot['status'], 'active')",
            "        self.assertEqual(snapshot['disk_format'], disk_format)",
            "        self.assertEqual(snapshot['name'], 'test-snap')",
            "",
            "        if expected_properties:",
            "            for expected_key, expected_value in \\",
            "                    six.iteritems(expected_properties):",
            "                self.assertEqual(expected_value, props[expected_key])",
            "",
            "    def _create_image(self, extra_properties=None):",
            "        properties = {'instance_id': self.instance_ref['id'],",
            "                      'user_id': str(self.context.user_id)}",
            "        if extra_properties:",
            "            properties.update(extra_properties)",
            "",
            "        sent_meta = {'name': 'test-snap',",
            "                     'is_public': False,",
            "                     'status': 'creating',",
            "                     'properties': properties}",
            "",
            "        # Create new image. It will be updated in snapshot method",
            "        # To work with it from snapshot, the single image_service is needed",
            "        recv_meta = self.image_service.create(self.context, sent_meta)",
            "        return recv_meta",
            "",
            "    @mock.patch.object(imagebackend.Image, 'resolve_driver_format')",
            "    @mock.patch.object(host.Host, 'get_domain')",
            "    def _snapshot(self, image_id, mock_get_domain, mock_resolve):",
            "        mock_get_domain.return_value = FakeVirtDomain()",
            "        driver = libvirt_driver.LibvirtDriver(fake.FakeVirtAPI(), False)",
            "        driver.snapshot(self.context, self.instance_ref, image_id,",
            "                        self.mock_update_task_state)",
            "        snapshot = self.image_service.show(self.context, image_id)",
            "        return snapshot",
            "",
            "    def _test_snapshot(self, disk_format, extra_properties=None):",
            "        recv_meta = self._create_image(extra_properties=extra_properties)",
            "        snapshot = self._snapshot(recv_meta['id'])",
            "        self._assert_snapshot(snapshot, disk_format=disk_format,",
            "                              expected_properties=extra_properties)",
            "",
            "",
            "class LibvirtSnapshotTests(_BaseSnapshotTests):",
            "    def test_ami(self):",
            "        # Assign different image_ref from nova/images/fakes for testing ami",
            "        self.instance_ref.image_ref = 'c905cedb-7281-47e4-8a62-f26bc5fc4c77'",
            "        self.instance_ref.system_metadata = \\",
            "          utils.get_system_metadata_from_image(",
            "            {'disk_format': 'ami'})",
            "",
            "        self._test_snapshot(disk_format='ami')",
            "",
            "    @mock.patch.object(fake_libvirt_utils, 'disk_type', new='raw')",
            "    @mock.patch.object(libvirt_driver.imagebackend.images,",
            "                       'convert_image',",
            "                       side_effect=_fake_convert_image)",
            "    def test_raw(self, mock_convert_image):",
            "        self._test_snapshot(disk_format='raw')",
            "",
            "    def test_qcow2(self):",
            "        self._test_snapshot(disk_format='qcow2')",
            "",
            "    @mock.patch.object(fake_libvirt_utils, 'disk_type', new='ploop')",
            "    @mock.patch.object(libvirt_driver.imagebackend.images,",
            "                       'convert_image',",
            "                       side_effect=_fake_convert_image)",
            "    def test_ploop(self, mock_convert_image):",
            "        self._test_snapshot(disk_format='ploop')",
            "",
            "    def test_no_image_architecture(self):",
            "        self.instance_ref.image_ref = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "        self._test_snapshot(disk_format='qcow2')",
            "",
            "    def test_no_original_image(self):",
            "        self.instance_ref.image_ref = '661122aa-1234-dede-fefe-babababababa'",
            "        self._test_snapshot(disk_format='qcow2')",
            "",
            "    def test_snapshot_metadata_image(self):",
            "        # Assign an image with an architecture defined (x86_64)",
            "        self.instance_ref.image_ref = 'a440c04b-79fa-479c-bed1-0b816eaec379'",
            "",
            "        extra_properties = {'architecture': 'fake_arch',",
            "                            'key_a': 'value_a',",
            "                            'key_b': 'value_b',",
            "                            'os_type': 'linux'}",
            "",
            "        self._test_snapshot(disk_format='qcow2',",
            "                            extra_properties=extra_properties)",
            "",
            "    @mock.patch.object(rbd_utils, 'RBDDriver')",
            "    @mock.patch.object(rbd_utils, 'rbd')",
            "    def test_raw_with_rbd_clone(self, mock_rbd, mock_driver):",
            "        self.flags(images_type='rbd', group='libvirt')",
            "        rbd = mock_driver.return_value",
            "        rbd.parent_info = mock.Mock(return_value=['test-pool', '', ''])",
            "        rbd.parse_url = mock.Mock(return_value=['a', 'b', 'c', 'd'])",
            "        with mock.patch.object(fake_libvirt_utils, 'find_disk',",
            "                               return_value=('rbd://some/fake/rbd/image',",
            "                                             'raw')):",
            "            with mock.patch.object(fake_libvirt_utils, 'disk_type', new='rbd'):",
            "                self._test_snapshot(disk_format='raw')",
            "        rbd.clone.assert_called_with(mock.ANY, mock.ANY, dest_pool='test-pool')",
            "        rbd.flatten.assert_called_with(mock.ANY, pool='test-pool')",
            "",
            "    @mock.patch.object(rbd_utils, 'RBDDriver')",
            "    @mock.patch.object(rbd_utils, 'rbd')",
            "    def test_raw_with_rbd_clone_graceful_fallback(self, mock_rbd, mock_driver):",
            "        self.flags(images_type='rbd', group='libvirt')",
            "        rbd = mock_driver.return_value",
            "        rbd.parent_info = mock.Mock(side_effect=exception.ImageUnacceptable(",
            "            image_id='fake_id', reason='rbd testing'))",
            "        with test.nested(",
            "                mock.patch.object(libvirt_driver.imagebackend.images,",
            "                                  'convert_image',",
            "                                  side_effect=_fake_convert_image),",
            "                mock.patch.object(fake_libvirt_utils, 'find_disk',",
            "                                  return_value=('rbd://some/fake/rbd/image',",
            "                                                'raw')),",
            "                mock.patch.object(fake_libvirt_utils, 'disk_type', new='rbd')):",
            "            self._test_snapshot(disk_format='raw')",
            "            self.assertFalse(rbd.clone.called)",
            "",
            "    @mock.patch.object(rbd_utils, 'RBDDriver')",
            "    @mock.patch.object(rbd_utils, 'rbd')",
            "    def test_raw_with_rbd_clone_eperm(self, mock_rbd, mock_driver):",
            "        self.flags(images_type='rbd', group='libvirt')",
            "        rbd = mock_driver.return_value",
            "        rbd.parent_info = mock.Mock(return_value=['test-pool', '', ''])",
            "        rbd.parse_url = mock.Mock(return_value=['a', 'b', 'c', 'd'])",
            "        rbd.clone = mock.Mock(side_effect=exception.Forbidden(",
            "                image_id='fake_id', reason='rbd testing'))",
            "        with test.nested(",
            "                mock.patch.object(libvirt_driver.imagebackend.images,",
            "                                  'convert_image',",
            "                                  side_effect=_fake_convert_image),",
            "                mock.patch.object(fake_libvirt_utils, 'find_disk',",
            "                                  return_value=('rbd://some/fake/rbd/image',",
            "                                                'raw')),",
            "                mock.patch.object(fake_libvirt_utils, 'disk_type', new='rbd')):",
            "            self._test_snapshot(disk_format='raw')",
            "            # Ensure that the direct_snapshot attempt was cleaned up",
            "            rbd.remove_snap.assert_called_with('c', 'd', ignore_errors=False,",
            "                                               pool='b', force=True)",
            "",
            "    @mock.patch.object(rbd_utils, 'RBDDriver')",
            "    @mock.patch.object(rbd_utils, 'rbd')",
            "    def test_raw_with_rbd_clone_post_process_fails(self, mock_rbd,",
            "                                                   mock_driver):",
            "        self.flags(images_type='rbd', group='libvirt')",
            "        rbd = mock_driver.return_value",
            "        rbd.parent_info = mock.Mock(return_value=['test-pool', '', ''])",
            "        rbd.parse_url = mock.Mock(return_value=['a', 'b', 'c', 'd'])",
            "        with test.nested(",
            "                mock.patch.object(fake_libvirt_utils, 'find_disk',",
            "                                  return_value=('rbd://some/fake/rbd/image',",
            "                                                'raw')),",
            "                mock.patch.object(fake_libvirt_utils, 'disk_type', new='rbd'),",
            "                mock.patch.object(self.image_service, 'update',",
            "                                  side_effect=test.TestingException)):",
            "            self.assertRaises(test.TestingException, self._test_snapshot,",
            "                              disk_format='raw')",
            "        rbd.clone.assert_called_with(mock.ANY, mock.ANY, dest_pool='test-pool')",
            "        rbd.flatten.assert_called_with(mock.ANY, pool='test-pool')",
            "        # Ensure that the direct_snapshot attempt was cleaned up",
            "        rbd.remove_snap.assert_called_with('c', 'd', ignore_errors=True,",
            "                                           pool='b', force=True)",
            "",
            "",
            "class LXCSnapshotTests(LibvirtSnapshotTests):",
            "    \"\"\"Repeat all of the Libvirt snapshot tests, but with LXC enabled\"\"\"",
            "    def setUp(self):",
            "        super(LXCSnapshotTests, self).setUp()",
            "        self.flags(virt_type='lxc', group='libvirt')",
            "",
            "",
            "class LVMSnapshotTests(_BaseSnapshotTests):",
            "    @mock.patch.object(fake_libvirt_utils, 'disk_type', new='lvm')",
            "    @mock.patch.object(libvirt_driver.imagebackend.images,",
            "                       'convert_image',",
            "                       side_effect=_fake_convert_image)",
            "    @mock.patch.object(libvirt_driver.imagebackend.lvm, 'volume_info')",
            "    def _test_lvm_snapshot(self, disk_format, mock_volume_info,",
            "                           mock_convert_image):",
            "        self.flags(images_type='lvm',",
            "                   images_volume_group='nova-vg', group='libvirt')",
            "",
            "        self._test_snapshot(disk_format=disk_format)",
            "",
            "        mock_volume_info.assert_has_calls([mock.call('/dev/nova-vg/lv')])",
            "        mock_convert_image.assert_called_once_with(",
            "            '/dev/nova-vg/lv', mock.ANY, 'raw', disk_format,",
            "            run_as_root=True)",
            "",
            "    def test_raw(self):",
            "        self._test_lvm_snapshot('raw')",
            "",
            "    def test_qcow2(self):",
            "        self.flags(snapshot_image_format='qcow2', group='libvirt')",
            "        self._test_lvm_snapshot('qcow2')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "nova.tests.unit.virt.libvirt.test_driver.LibvirtDriverTestCase.self",
            "nova.tests.unit.virt.libvirt.test_driver.LibvirtConnTestCase.self",
            "nova.tests.unit.virt.libvirt.test_driver.LibvirtConnTestCase.test_create_image_initrd.outer"
        ]
    },
    "nova/virt/libvirt/driver.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 6655,
                "afterPatchRowNumber": 6655,
                "PatchRowcode": "                       instance=instance)"
            },
            "1": {
                "beforePatchRowNumber": 6656,
                "afterPatchRowNumber": 6656,
                "PatchRowcode": "             os.mkdir(instance_dir)"
            },
            "2": {
                "beforePatchRowNumber": 6657,
                "afterPatchRowNumber": 6657,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6658,
                "PatchRowcode": "+            # Recreate the disk.info file and in doing so stop the"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6659,
                "PatchRowcode": "+            # imagebackend from recreating it incorrectly by inspecting the"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6660,
                "PatchRowcode": "+            # contents of each file when using the Raw backend."
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6661,
                "PatchRowcode": "+            if disk_info:"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6662,
                "PatchRowcode": "+                image_disk_info = {}"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6663,
                "PatchRowcode": "+                for info in disk_info:"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6664,
                "PatchRowcode": "+                    image_file = os.path.basename(info['path'])"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6665,
                "PatchRowcode": "+                    image_path = os.path.join(instance_dir, image_file)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6666,
                "PatchRowcode": "+                    image_disk_info[image_path] = info['type']"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6667,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6668,
                "PatchRowcode": "+                LOG.debug('Creating disk.info with the contents: %s',"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6669,
                "PatchRowcode": "+                          image_disk_info, instance=instance)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6670,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6671,
                "PatchRowcode": "+                image_disk_info_path = os.path.join(instance_dir,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6672,
                "PatchRowcode": "+                                                    'disk.info')"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6673,
                "PatchRowcode": "+                libvirt_utils.write_to_file(image_disk_info_path,"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6674,
                "PatchRowcode": "+                                            jsonutils.dumps(image_disk_info))"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6675,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": 6658,
                "afterPatchRowNumber": 6676,
                "PatchRowcode": "             if not is_shared_block_storage:"
            },
            "22": {
                "beforePatchRowNumber": 6659,
                "afterPatchRowNumber": 6677,
                "PatchRowcode": "                 # Ensure images and backing files are present."
            },
            "23": {
                "beforePatchRowNumber": 6660,
                "afterPatchRowNumber": 6678,
                "PatchRowcode": "                 LOG.debug('Checking to make sure images and backing files are '"
            },
            "24": {
                "beforePatchRowNumber": 7242,
                "afterPatchRowNumber": 7260,
                "PatchRowcode": "                                              on_execute=on_execute,"
            },
            "25": {
                "beforePatchRowNumber": 7243,
                "afterPatchRowNumber": 7261,
                "PatchRowcode": "                                              on_completion=on_completion,"
            },
            "26": {
                "beforePatchRowNumber": 7244,
                "afterPatchRowNumber": 7262,
                "PatchRowcode": "                                              compression=compression)"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7263,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7264,
                "PatchRowcode": "+            # Ensure disk.info is written to the new path to avoid disks being"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7265,
                "PatchRowcode": "+            # reinspected and potentially changing format."
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7266,
                "PatchRowcode": "+            src_disk_info_path = os.path.join(inst_base_resize, 'disk.info')"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7267,
                "PatchRowcode": "+            dst_disk_info_path = os.path.join(inst_base, 'disk.info')"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7268,
                "PatchRowcode": "+            libvirt_utils.copy_image(src_disk_info_path, dst_disk_info_path,"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7269,
                "PatchRowcode": "+                                     host=dest, on_execute=on_execute,"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7270,
                "PatchRowcode": "+                                     on_completion=on_completion,"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7271,
                "PatchRowcode": "+                                     compression=compression)"
            },
            "36": {
                "beforePatchRowNumber": 7245,
                "afterPatchRowNumber": 7272,
                "PatchRowcode": "         except Exception:"
            },
            "37": {
                "beforePatchRowNumber": 7246,
                "afterPatchRowNumber": 7273,
                "PatchRowcode": "             with excutils.save_and_reraise_exception():"
            },
            "38": {
                "beforePatchRowNumber": 7247,
                "afterPatchRowNumber": 7274,
                "PatchRowcode": "                 self._cleanup_remote_migration(dest, inst_base,"
            }
        },
        "frontPatchFile": [
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# All Rights Reserved.",
            "# Copyright (c) 2010 Citrix Systems, Inc.",
            "# Copyright (c) 2011 Piston Cloud Computing, Inc",
            "# Copyright (c) 2012 University Of Minho",
            "# (c) Copyright 2013 Hewlett-Packard Development Company, L.P.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "A connection to a hypervisor through libvirt.",
            "",
            "Supports KVM, LXC, QEMU, UML, XEN and Parallels.",
            "",
            "\"\"\"",
            "",
            "import collections",
            "import contextlib",
            "import errno",
            "import functools",
            "import glob",
            "import itertools",
            "import mmap",
            "import operator",
            "import os",
            "import shutil",
            "import tempfile",
            "import time",
            "import uuid",
            "",
            "import eventlet",
            "from eventlet import greenthread",
            "from eventlet import tpool",
            "from lxml import etree",
            "from os_brick.initiator import connector",
            "from oslo_concurrency import processutils",
            "from oslo_config import cfg",
            "from oslo_log import log as logging",
            "from oslo_serialization import jsonutils",
            "from oslo_service import loopingcall",
            "from oslo_utils import excutils",
            "from oslo_utils import fileutils",
            "from oslo_utils import importutils",
            "from oslo_utils import strutils",
            "from oslo_utils import timeutils",
            "from oslo_utils import units",
            "import six",
            "from six.moves import range",
            "",
            "from nova.api.metadata import base as instance_metadata",
            "from nova import block_device",
            "from nova.compute import arch",
            "from nova.compute import hv_type",
            "from nova.compute import power_state",
            "from nova.compute import task_states",
            "from nova.compute import utils as compute_utils",
            "from nova.compute import vm_mode",
            "import nova.conf",
            "from nova.console import serial as serial_console",
            "from nova.console import type as ctype",
            "from nova import context as nova_context",
            "from nova import exception",
            "from nova.i18n import _",
            "from nova.i18n import _LE",
            "from nova.i18n import _LI",
            "from nova.i18n import _LW",
            "from nova import image",
            "from nova.network import model as network_model",
            "from nova import objects",
            "from nova.objects import fields",
            "from nova.objects import migrate_data as migrate_data_obj",
            "from nova.pci import manager as pci_manager",
            "from nova.pci import utils as pci_utils",
            "from nova import utils",
            "from nova import version",
            "from nova.virt import block_device as driver_block_device",
            "from nova.virt import configdrive",
            "from nova.virt import diagnostics",
            "from nova.virt.disk import api as disk",
            "from nova.virt.disk.vfs import guestfs",
            "from nova.virt import driver",
            "from nova.virt import firewall",
            "from nova.virt import hardware",
            "from nova.virt.image import model as imgmodel",
            "from nova.virt import images",
            "from nova.virt.libvirt import blockinfo",
            "from nova.virt.libvirt import config as vconfig",
            "from nova.virt.libvirt import firewall as libvirt_firewall",
            "from nova.virt.libvirt import guest as libvirt_guest",
            "from nova.virt.libvirt import host",
            "from nova.virt.libvirt import imagebackend",
            "from nova.virt.libvirt import imagecache",
            "from nova.virt.libvirt import instancejobtracker",
            "from nova.virt.libvirt.storage import dmcrypt",
            "from nova.virt.libvirt.storage import lvm",
            "from nova.virt.libvirt.storage import rbd_utils",
            "from nova.virt.libvirt import utils as libvirt_utils",
            "from nova.virt.libvirt import vif as libvirt_vif",
            "from nova.virt.libvirt.volume import remotefs",
            "from nova.virt import netutils",
            "from nova.virt import watchdog_actions",
            "from nova import volume",
            "from nova.volume import encryptors",
            "",
            "libvirt = None",
            "",
            "uefi_logged = False",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "# Downtime period in milliseconds",
            "LIVE_MIGRATION_DOWNTIME_MIN = 100",
            "# Step count",
            "LIVE_MIGRATION_DOWNTIME_STEPS_MIN = 3",
            "# Delay in seconds",
            "LIVE_MIGRATION_DOWNTIME_DELAY_MIN = 10",
            "",
            "libvirt_opts = [",
            "    cfg.StrOpt('rescue_image_id',",
            "               help='Rescue ami image. This will not be used if an image id '",
            "                    'is provided by the user.'),",
            "    cfg.StrOpt('rescue_kernel_id',",
            "               help='Rescue aki image'),",
            "    cfg.StrOpt('rescue_ramdisk_id',",
            "               help='Rescue ari image'),",
            "    cfg.StrOpt('virt_type',",
            "               default='kvm',",
            "               choices=('kvm', 'lxc', 'qemu', 'uml', 'xen', 'parallels'),",
            "               help='Libvirt domain type'),",
            "    cfg.StrOpt('connection_uri',",
            "               default='',",
            "               help='Override the default libvirt URI '",
            "                    '(which is dependent on virt_type)'),",
            "    cfg.BoolOpt('inject_password',",
            "                default=False,",
            "                help='Inject the admin password at boot time, '",
            "                     'without an agent.'),",
            "    cfg.BoolOpt('inject_key',",
            "                default=False,",
            "                help='Inject the ssh public key at boot time'),",
            "    cfg.IntOpt('inject_partition',",
            "                default=-2,",
            "                help='The partition to inject to : '",
            "                     '-2 => disable, -1 => inspect (libguestfs only), '",
            "                     '0 => not partitioned, >0 => partition number'),",
            "    cfg.BoolOpt('use_usb_tablet',",
            "                default=True,",
            "                help='Sync virtual and real mouse cursors in Windows VMs'),",
            "    cfg.StrOpt('live_migration_inbound_addr',",
            "               default=None,",
            "               help='Live migration target ip or hostname '",
            "                    '(if this option is set to be None,'",
            "                    'the hostname of the migration target'",
            "                    'compute node will be used)'),",
            "    cfg.StrOpt('live_migration_uri',",
            "               help='Override the default libvirt live migration target URI '",
            "                    '(which is dependent on virt_type) '",
            "                    '(any included \"%s\" is replaced with '",
            "                    'the migration target hostname)'),",
            "    cfg.StrOpt('live_migration_flag',",
            "               default='VIR_MIGRATE_UNDEFINE_SOURCE, VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, VIR_MIGRATE_TUNNELLED',",
            "               help='Migration flags to be set for live migration',",
            "               deprecated_for_removal=True,",
            "               deprecated_reason='The correct live migration flags can be '",
            "                                 'inferred from the new '",
            "                                 'live_migration_tunnelled config option. '",
            "                                 'live_migration_flag will be removed to '",
            "                                 'avoid potential misconfiguration.'),",
            "    cfg.StrOpt('block_migration_flag',",
            "               default='VIR_MIGRATE_UNDEFINE_SOURCE, VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, VIR_MIGRATE_TUNNELLED, '",
            "                       'VIR_MIGRATE_NON_SHARED_INC',",
            "               help='Migration flags to be set for block migration',",
            "               deprecated_for_removal=True,",
            "               deprecated_reason='The correct block migration flags can be '",
            "                                 'inferred from the new '",
            "                                 'live_migration_tunnelled config option. '",
            "                                 'block_migration_flag will be removed to '",
            "                                 'avoid potential misconfiguration.'),",
            "    cfg.BoolOpt('live_migration_tunnelled',",
            "                help='Whether to use tunnelled migration, where migration '",
            "                     'data is transported over the libvirtd connection. If '",
            "                     'True, we use the VIR_MIGRATE_TUNNELLED migration flag, '",
            "                     'avoiding the need to configure the network to allow '",
            "                     'direct hypervisor to hypervisor communication. If '",
            "                     'False, use the native transport. If not set, Nova '",
            "                     'will choose a sensible default based on, for example '",
            "                     'the availability of native encryption support in the '",
            "                     'hypervisor.'),",
            "    cfg.IntOpt('live_migration_bandwidth',",
            "               default=0,",
            "               help='Maximum bandwidth(in MiB/s) to be used during migration. '",
            "                    'If set to 0, will choose a suitable default. Some '",
            "                    'hypervisors do not support this feature and will return '",
            "                    'an error if bandwidth is not 0. Please refer to the '",
            "                    'libvirt documentation for further details'),",
            "    cfg.IntOpt('live_migration_downtime',",
            "               default=500,",
            "               help='Maximum permitted downtime, in milliseconds, for live '",
            "                    'migration switchover. Will be rounded up to a minimum '",
            "                    'of %dms. Use a large value if guest liveness is '",
            "                    'unimportant.' % LIVE_MIGRATION_DOWNTIME_MIN),",
            "    cfg.IntOpt('live_migration_downtime_steps',",
            "               default=10,",
            "               help='Number of incremental steps to reach max downtime value. '",
            "                    'Will be rounded up to a minimum of %d steps' %",
            "                    LIVE_MIGRATION_DOWNTIME_STEPS_MIN),",
            "    cfg.IntOpt('live_migration_downtime_delay',",
            "               default=75,",
            "               help='Time to wait, in seconds, between each step increase '",
            "                    'of the migration downtime. Minimum delay is %d seconds. '",
            "                    'Value is per GiB of guest RAM + disk to be transferred, '",
            "                    'with lower bound of a minimum of 2 GiB per device' %",
            "                    LIVE_MIGRATION_DOWNTIME_DELAY_MIN),",
            "    cfg.IntOpt('live_migration_completion_timeout',",
            "               default=800,",
            "               help='Time to wait, in seconds, for migration to successfully '",
            "                    'complete transferring data before aborting the '",
            "                    'operation. Value is per GiB of guest RAM + disk to be '",
            "                    'transferred, with lower bound of a minimum of 2 GiB. '",
            "                    'Should usually be larger than downtime delay * downtime '",
            "                    'steps. Set to 0 to disable timeouts.'),",
            "    cfg.IntOpt('live_migration_progress_timeout',",
            "               default=150,",
            "               help='Time to wait, in seconds, for migration to make forward '",
            "                    'progress in transferring data before aborting the '",
            "                    'operation. Set to 0 to disable timeouts.'),",
            "    cfg.StrOpt('snapshot_image_format',",
            "               choices=('raw', 'qcow2', 'vmdk', 'vdi'),",
            "               help='Snapshot image format. Defaults to same as source image'),",
            "    cfg.StrOpt('disk_prefix',",
            "               help='Override the default disk prefix for the devices attached'",
            "                    ' to a server, which is dependent on virt_type. '",
            "                    '(valid options are: sd, xvd, uvd, vd)'),",
            "    cfg.IntOpt('wait_soft_reboot_seconds',",
            "               default=120,",
            "               help='Number of seconds to wait for instance to shut down after'",
            "                    ' soft reboot request is made. We fall back to hard reboot'",
            "                    ' if instance does not shutdown within this window.'),",
            "    cfg.StrOpt('cpu_mode',",
            "               choices=('host-model', 'host-passthrough', 'custom', 'none'),",
            "               help='Set to \"host-model\" to clone the host CPU feature flags; '",
            "                    'to \"host-passthrough\" to use the host CPU model exactly; '",
            "                    'to \"custom\" to use a named CPU model; '",
            "                    'to \"none\" to not set any CPU model. '",
            "                    'If virt_type=\"kvm|qemu\", it will default to '",
            "                    '\"host-model\", otherwise it will default to \"none\"'),",
            "    cfg.StrOpt('cpu_model',",
            "               help='Set to a named libvirt CPU model (see names listed '",
            "                    'in /usr/share/libvirt/cpu_map.xml). Only has effect if '",
            "                    'cpu_mode=\"custom\" and virt_type=\"kvm|qemu\"'),",
            "    cfg.StrOpt('snapshots_directory',",
            "               default='$instances_path/snapshots',",
            "               help='Location where libvirt driver will store snapshots '",
            "                    'before uploading them to image service'),",
            "    cfg.StrOpt('xen_hvmloader_path',",
            "                default='/usr/lib/xen/boot/hvmloader',",
            "                help='Location where the Xen hvmloader is kept'),",
            "    cfg.ListOpt('disk_cachemodes',",
            "                 default=[],",
            "                 help='Specific cachemodes to use for different disk types '",
            "                      'e.g: file=directsync,block=none'),",
            "    cfg.StrOpt('rng_dev_path',",
            "                help='A path to a device that will be used as source of '",
            "                     'entropy on the host. Permitted options are: '",
            "                     '/dev/random or /dev/hwrng'),",
            "    cfg.ListOpt('hw_machine_type',",
            "               help='For qemu or KVM guests, set this option to specify '",
            "                    'a default machine type per host architecture. '",
            "                    'You can find a list of supported machine types '",
            "                    'in your environment by checking the output of '",
            "                    'the \"virsh capabilities\"command. The format of the '",
            "                    'value for this config option is host-arch=machine-type. '",
            "                    'For example: x86_64=machinetype1,armv7l=machinetype2'),",
            "    cfg.StrOpt('sysinfo_serial',",
            "               default='auto',",
            "               choices=('none', 'os', 'hardware', 'auto'),",
            "               help='The data source used to the populate the host \"serial\" '",
            "                    'UUID exposed to guest in the virtual BIOS.'),",
            "    cfg.IntOpt('mem_stats_period_seconds',",
            "                default=10,",
            "                help='A number of seconds to memory usage statistics period. '",
            "                     'Zero or negative value mean to disable memory usage '",
            "                     'statistics.'),",
            "    cfg.ListOpt('uid_maps',",
            "                default=[],",
            "                help='List of uid targets and ranges.'",
            "                     'Syntax is guest-uid:host-uid:count'",
            "                     'Maximum of 5 allowed.'),",
            "    cfg.ListOpt('gid_maps',",
            "                default=[],",
            "                help='List of guid targets and ranges.'",
            "                     'Syntax is guest-gid:host-gid:count'",
            "                     'Maximum of 5 allowed.'),",
            "    cfg.IntOpt('realtime_scheduler_priority',",
            "               default=1,",
            "               help='In a realtime host context vCPUs for guest will run in '",
            "               'that scheduling priority. Priority depends on the host '",
            "               'kernel (usually 1-99)')",
            "    ]",
            "",
            "CONF = nova.conf.CONF",
            "CONF.register_opts(libvirt_opts, 'libvirt')",
            "CONF.import_opt('host', 'nova.netconf')",
            "CONF.import_opt('my_ip', 'nova.netconf')",
            "CONF.import_opt('enabled', 'nova.compute.api',",
            "                group='ephemeral_storage_encryption')",
            "CONF.import_opt('cipher', 'nova.compute.api',",
            "                group='ephemeral_storage_encryption')",
            "CONF.import_opt('key_size', 'nova.compute.api',",
            "                group='ephemeral_storage_encryption')",
            "CONF.import_opt('live_migration_retry_count', 'nova.compute.manager')",
            "CONF.import_opt('server_proxyclient_address', 'nova.spice', group='spice')",
            "CONF.import_opt('vcpu_pin_set', 'nova.conf.virt')",
            "CONF.import_opt('hw_disk_discard', 'nova.virt.libvirt.imagebackend',",
            "                group='libvirt')",
            "CONF.import_group('workarounds', 'nova.utils')",
            "CONF.import_opt('iscsi_use_multipath', 'nova.virt.libvirt.volume.iscsi',",
            "                group='libvirt')",
            "",
            "DEFAULT_FIREWALL_DRIVER = \"%s.%s\" % (",
            "    libvirt_firewall.__name__,",
            "    libvirt_firewall.IptablesFirewallDriver.__name__)",
            "",
            "DEFAULT_UEFI_LOADER_PATH = {",
            "    \"x86_64\": \"/usr/share/OVMF/OVMF_CODE.fd\",",
            "    \"aarch64\": \"/usr/share/AAVMF/AAVMF_CODE.fd\"",
            "}",
            "",
            "MAX_CONSOLE_BYTES = 100 * units.Ki",
            "",
            "# The libvirt driver will prefix any disable reason codes with this string.",
            "DISABLE_PREFIX = 'AUTO: '",
            "# Disable reason for the service which was enabled or disabled without reason",
            "DISABLE_REASON_UNDEFINED = None",
            "",
            "# Guest config console string",
            "CONSOLE = \"console=tty0 console=ttyS0\"",
            "",
            "GuestNumaConfig = collections.namedtuple(",
            "    'GuestNumaConfig', ['cpuset', 'cputune', 'numaconfig', 'numatune'])",
            "",
            "libvirt_volume_drivers = [",
            "    'iscsi=nova.virt.libvirt.volume.iscsi.LibvirtISCSIVolumeDriver',",
            "    'iser=nova.virt.libvirt.volume.iser.LibvirtISERVolumeDriver',",
            "    'local=nova.virt.libvirt.volume.volume.LibvirtVolumeDriver',",
            "    'fake=nova.virt.libvirt.volume.volume.LibvirtFakeVolumeDriver',",
            "    'rbd=nova.virt.libvirt.volume.net.LibvirtNetVolumeDriver',",
            "    'sheepdog=nova.virt.libvirt.volume.net.LibvirtNetVolumeDriver',",
            "    'nfs=nova.virt.libvirt.volume.nfs.LibvirtNFSVolumeDriver',",
            "    'smbfs=nova.virt.libvirt.volume.smbfs.LibvirtSMBFSVolumeDriver',",
            "    'aoe=nova.virt.libvirt.volume.aoe.LibvirtAOEVolumeDriver',",
            "    'glusterfs='",
            "        'nova.virt.libvirt.volume.glusterfs.LibvirtGlusterfsVolumeDriver',",
            "    'fibre_channel='",
            "        'nova.virt.libvirt.volume.fibrechannel.'",
            "        'LibvirtFibreChannelVolumeDriver',",
            "    'scality=nova.virt.libvirt.volume.scality.LibvirtScalityVolumeDriver',",
            "    'gpfs=nova.virt.libvirt.volume.gpfs.LibvirtGPFSVolumeDriver',",
            "    'quobyte=nova.virt.libvirt.volume.quobyte.LibvirtQuobyteVolumeDriver',",
            "    'hgst=nova.virt.libvirt.volume.hgst.LibvirtHGSTVolumeDriver',",
            "    'scaleio=nova.virt.libvirt.volume.scaleio.LibvirtScaleIOVolumeDriver',",
            "    'disco=nova.virt.libvirt.volume.disco.LibvirtDISCOVolumeDriver',",
            "]",
            "",
            "",
            "def patch_tpool_proxy():",
            "    \"\"\"eventlet.tpool.Proxy doesn't work with old-style class in __str__()",
            "    or __repr__() calls. See bug #962840 for details.",
            "    We perform a monkey patch to replace those two instance methods.",
            "    \"\"\"",
            "    def str_method(self):",
            "        return str(self._obj)",
            "",
            "    def repr_method(self):",
            "        return repr(self._obj)",
            "",
            "    tpool.Proxy.__str__ = str_method",
            "    tpool.Proxy.__repr__ = repr_method",
            "",
            "",
            "patch_tpool_proxy()",
            "",
            "# For information about when MIN_LIBVIRT_VERSION and",
            "# NEXT_MIN_LIBVIRT_VERSION can be changed, consult",
            "#",
            "#   https://wiki.openstack.org/wiki/LibvirtDistroSupportMatrix",
            "#",
            "# Currently this is effectively the min version for i686/x86_64",
            "# + KVM/QEMU, as other architectures/hypervisors require newer",
            "# versions. Over time, this will become a common min version",
            "# for all architectures/hypervisors, as this value rises to",
            "# meet them.",
            "MIN_LIBVIRT_VERSION = (0, 10, 2)",
            "# TODO(berrange): Re-evaluate this at start of each release cycle",
            "# to decide if we want to plan a future min version bump.",
            "# MIN_LIBVIRT_VERSION can be updated to match this after",
            "# NEXT_MIN_LIBVIRT_VERSION  has been at a higher value for",
            "# one cycle",
            "NEXT_MIN_LIBVIRT_VERSION = (1, 2, 1)",
            "",
            "# When the above version matches/exceeds this version",
            "# delete it & corresponding code using it",
            "MIN_LIBVIRT_DEVICE_CALLBACK_VERSION = (1, 1, 1)",
            "# Live snapshot requirements",
            "MIN_LIBVIRT_LIVESNAPSHOT_VERSION = (1, 0, 0)",
            "MIN_QEMU_LIVESNAPSHOT_VERSION = (1, 3, 0)",
            "# BlockJobInfo management requirement",
            "MIN_LIBVIRT_BLOCKJOBINFO_VERSION = (1, 1, 1)",
            "# Relative block commit & rebase (feature is detected,",
            "# this version is only used for messaging)",
            "MIN_LIBVIRT_BLOCKJOB_RELATIVE_VERSION = (1, 2, 7)",
            "# Libvirt version 1.2.17 is required for successfull block live migration",
            "# of vm booted from image with attached devices",
            "MIN_LIBVIRT_BLOCK_LM_WITH_VOLUMES_VERSION = (1, 2, 17)",
            "# libvirt discard feature",
            "MIN_LIBVIRT_DISCARD_VERSION = (1, 0, 6)",
            "MIN_QEMU_DISCARD_VERSION = (1, 6, 0)",
            "# While earlier versions could support NUMA reporting and",
            "# NUMA placement, not until 1.2.7 was there the ability",
            "# to pin guest nodes to host nodes, so mandate that. Without",
            "# this the scheduler cannot make guaranteed decisions, as the",
            "# guest placement may not match what was requested",
            "MIN_LIBVIRT_NUMA_VERSION = (1, 2, 7)",
            "# PowerPC based hosts that support NUMA using libvirt",
            "MIN_LIBVIRT_NUMA_VERSION_PPC = (1, 2, 19)",
            "# Versions of libvirt with known NUMA topology issues",
            "# See bug #1449028",
            "BAD_LIBVIRT_NUMA_VERSIONS = [(1, 2, 9, 2)]",
            "# While earlier versions could support hugepage backed",
            "# guests, not until 1.2.8 was there the ability to request",
            "# a particular huge page size. Without this the scheduler",
            "# cannot make guaranteed decisions, as the huge page size",
            "# used by the guest may not match what was requested",
            "MIN_LIBVIRT_HUGEPAGE_VERSION = (1, 2, 8)",
            "# Versions of libvirt with broken cpu pinning support. This excludes",
            "# versions of libvirt with broken NUMA support since pinning needs",
            "# NUMA",
            "# See bug #1438226",
            "BAD_LIBVIRT_CPU_POLICY_VERSIONS = [(1, 2, 10)]",
            "# qemu 2.1 introduces support for pinning memory on host",
            "# NUMA nodes, along with the ability to specify hugepage",
            "# sizes per guest NUMA node",
            "MIN_QEMU_NUMA_HUGEPAGE_VERSION = (2, 1, 0)",
            "# fsFreeze/fsThaw requirement",
            "MIN_LIBVIRT_FSFREEZE_VERSION = (1, 2, 5)",
            "",
            "# UEFI booting support",
            "MIN_LIBVIRT_UEFI_VERSION = (1, 2, 9)",
            "",
            "# Hyper-V paravirtualized time source",
            "MIN_LIBVIRT_HYPERV_TIMER_VERSION = (1, 2, 2)",
            "MIN_QEMU_HYPERV_TIMER_VERSION = (2, 0, 0)",
            "",
            "MIN_LIBVIRT_HYPERV_FEATURE_VERSION = (1, 0, 0)",
            "MIN_LIBVIRT_HYPERV_FEATURE_EXTRA_VERSION = (1, 1, 0)",
            "MIN_QEMU_HYPERV_FEATURE_VERSION = (1, 1, 0)",
            "",
            "# parallels driver support",
            "MIN_LIBVIRT_PARALLELS_VERSION = (1, 2, 12)",
            "",
            "# Ability to set the user guest password with Qemu",
            "MIN_LIBVIRT_SET_ADMIN_PASSWD = (1, 2, 16)",
            "",
            "# s/390 & s/390x architectures with KVM",
            "MIN_LIBVIRT_KVM_S390_VERSION = (1, 2, 13)",
            "MIN_QEMU_S390_VERSION = (2, 3, 0)",
            "",
            "# libvirt < 1.3 reported virt_functions capability",
            "# only when VFs are enabled.",
            "# libvirt 1.3 fix f391889f4e942e22b9ef8ecca492de05106ce41e",
            "MIN_LIBVIRT_PF_WITH_NO_VFS_CAP_VERSION = (1, 3, 0)",
            "",
            "# ppc64/ppc64le architectures with KVM",
            "# NOTE(rfolco): Same levels for Libvirt/Qemu on Big Endian and Little",
            "# Endian giving the nuance around guest vs host architectures",
            "MIN_LIBVIRT_KVM_PPC64_VERSION = (1, 2, 12)",
            "MIN_QEMU_PPC64_VERSION = (2, 1, 0)",
            "",
            "# Names of the types that do not get compressed during migration",
            "NO_COMPRESSION_TYPES = ('qcow2',)",
            "",
            "# realtime suppport",
            "MIN_LIBVIRT_REALTIME_VERSION = (1, 2, 13)",
            "",
            "MIN_LIBVIRT_OTHER_ARCH = {arch.S390: MIN_LIBVIRT_KVM_S390_VERSION,",
            "                          arch.S390X: MIN_LIBVIRT_KVM_S390_VERSION,",
            "                          arch.PPC: MIN_LIBVIRT_KVM_PPC64_VERSION,",
            "                          arch.PPC64: MIN_LIBVIRT_KVM_PPC64_VERSION,",
            "                          arch.PPC64LE: MIN_LIBVIRT_KVM_PPC64_VERSION,",
            "                         }",
            "MIN_QEMU_OTHER_ARCH = {arch.S390: MIN_QEMU_S390_VERSION,",
            "                       arch.S390X: MIN_QEMU_S390_VERSION,",
            "                       arch.PPC: MIN_QEMU_PPC64_VERSION,",
            "                       arch.PPC64: MIN_QEMU_PPC64_VERSION,",
            "                       arch.PPC64LE: MIN_QEMU_PPC64_VERSION,",
            "                      }",
            "",
            "",
            "class LibvirtDriver(driver.ComputeDriver):",
            "    capabilities = {",
            "        \"has_imagecache\": True,",
            "        \"supports_recreate\": True,",
            "        \"supports_migrate_to_same_host\": False",
            "    }",
            "",
            "    def __init__(self, virtapi, read_only=False):",
            "        super(LibvirtDriver, self).__init__(virtapi)",
            "",
            "        global libvirt",
            "        if libvirt is None:",
            "            libvirt = importutils.import_module('libvirt')",
            "",
            "        self._host = host.Host(self._uri(), read_only,",
            "                               lifecycle_event_handler=self.emit_event,",
            "                               conn_event_handler=self._handle_conn_event)",
            "        self._initiator = None",
            "        self._fc_wwnns = None",
            "        self._fc_wwpns = None",
            "        self._caps = None",
            "        self.firewall_driver = firewall.load_driver(",
            "            DEFAULT_FIREWALL_DRIVER,",
            "            host=self._host)",
            "",
            "        self.vif_driver = libvirt_vif.LibvirtGenericVIFDriver()",
            "",
            "        self.volume_drivers = driver.driver_dict_from_config(",
            "            self._get_volume_drivers(), self)",
            "",
            "        self._disk_cachemode = None",
            "        self.image_cache_manager = imagecache.ImageCacheManager()",
            "        self.image_backend = imagebackend.Backend(CONF.use_cow_images)",
            "",
            "        self.disk_cachemodes = {}",
            "",
            "        self.valid_cachemodes = [\"default\",",
            "                                 \"none\",",
            "                                 \"writethrough\",",
            "                                 \"writeback\",",
            "                                 \"directsync\",",
            "                                 \"unsafe\",",
            "                                ]",
            "        self._conn_supports_start_paused = CONF.libvirt.virt_type in ('kvm',",
            "                                                                      'qemu')",
            "",
            "        for mode_str in CONF.libvirt.disk_cachemodes:",
            "            disk_type, sep, cache_mode = mode_str.partition('=')",
            "            if cache_mode not in self.valid_cachemodes:",
            "                LOG.warn(_LW('Invalid cachemode %(cache_mode)s specified '",
            "                             'for disk type %(disk_type)s.'),",
            "                         {'cache_mode': cache_mode, 'disk_type': disk_type})",
            "                continue",
            "            self.disk_cachemodes[disk_type] = cache_mode",
            "",
            "        self._volume_api = volume.API()",
            "        self._image_api = image.API()",
            "",
            "        sysinfo_serial_funcs = {",
            "            'none': lambda: None,",
            "            'hardware': self._get_host_sysinfo_serial_hardware,",
            "            'os': self._get_host_sysinfo_serial_os,",
            "            'auto': self._get_host_sysinfo_serial_auto,",
            "        }",
            "",
            "        self._sysinfo_serial_func = sysinfo_serial_funcs.get(",
            "            CONF.libvirt.sysinfo_serial)",
            "",
            "        self.job_tracker = instancejobtracker.InstanceJobTracker()",
            "        self._remotefs = remotefs.RemoteFilesystem()",
            "",
            "        self._live_migration_flags = self._block_migration_flags = None",
            "",
            "    def _get_volume_drivers(self):",
            "        return libvirt_volume_drivers",
            "",
            "    @property",
            "    def disk_cachemode(self):",
            "        if self._disk_cachemode is None:",
            "            # We prefer 'none' for consistent performance, host crash",
            "            # safety & migration correctness by avoiding host page cache.",
            "            # Some filesystems (eg GlusterFS via FUSE) don't support",
            "            # O_DIRECT though. For those we fallback to 'writethrough'",
            "            # which gives host crash safety, and is safe for migration",
            "            # provided the filesystem is cache coherent (cluster filesystems",
            "            # typically are, but things like NFS are not).",
            "            self._disk_cachemode = \"none\"",
            "            if not self._supports_direct_io(CONF.instances_path):",
            "                self._disk_cachemode = \"writethrough\"",
            "        return self._disk_cachemode",
            "",
            "    def _set_cache_mode(self, conf):",
            "        \"\"\"Set cache mode on LibvirtConfigGuestDisk object.\"\"\"",
            "        try:",
            "            source_type = conf.source_type",
            "            driver_cache = conf.driver_cache",
            "        except AttributeError:",
            "            return",
            "",
            "        cache_mode = self.disk_cachemodes.get(source_type,",
            "                                              driver_cache)",
            "        conf.driver_cache = cache_mode",
            "",
            "    def _do_quality_warnings(self):",
            "        \"\"\"Warn about untested driver configurations.",
            "",
            "        This will log a warning message about untested driver or host arch",
            "        configurations to indicate to administrators that the quality is",
            "        unknown. Currently, only qemu or kvm on intel 32- or 64-bit systems",
            "        is tested upstream.",
            "        \"\"\"",
            "        caps = self._host.get_capabilities()",
            "        hostarch = caps.host.cpu.arch",
            "        if (CONF.libvirt.virt_type not in ('qemu', 'kvm') or",
            "            hostarch not in (arch.I686, arch.X86_64)):",
            "            LOG.warn(_LW('The libvirt driver is not tested on '",
            "                         '%(type)s/%(arch)s by the OpenStack project and '",
            "                         'thus its quality can not be ensured. For more '",
            "                         'information, see: https://wiki.openstack.org/wiki/'",
            "                         'HypervisorSupportMatrix'),",
            "                        {'type': CONF.libvirt.virt_type, 'arch': hostarch})",
            "",
            "    def _handle_conn_event(self, enabled, reason):",
            "        LOG.info(_LI(\"Connection event '%(enabled)d' reason '%(reason)s'\"),",
            "                 {'enabled': enabled, 'reason': reason})",
            "        self._set_host_enabled(enabled, reason)",
            "",
            "    def _version_to_string(self, version):",
            "        return '.'.join([str(x) for x in version])",
            "",
            "    def init_host(self, host):",
            "        self._host.initialize()",
            "",
            "        self._do_quality_warnings()",
            "",
            "        self._parse_migration_flags()",
            "",
            "        if (CONF.libvirt.virt_type == 'lxc' and",
            "                not (CONF.libvirt.uid_maps and CONF.libvirt.gid_maps)):",
            "            LOG.warn(_LW(\"Running libvirt-lxc without user namespaces is \"",
            "                         \"dangerous. Containers spawned by Nova will be run \"",
            "                         \"as the host's root user. It is highly suggested \"",
            "                         \"that user namespaces be used in a public or \"",
            "                         \"multi-tenant environment.\"))",
            "",
            "        # Stop libguestfs using KVM unless we're also configured",
            "        # to use this. This solves problem where people need to",
            "        # stop Nova use of KVM because nested-virt is broken",
            "        if CONF.libvirt.virt_type != \"kvm\":",
            "            guestfs.force_tcg()",
            "",
            "        if not self._host.has_min_version(MIN_LIBVIRT_VERSION):",
            "            raise exception.NovaException(",
            "                _('Nova requires libvirt version %s or greater.') %",
            "                self._version_to_string(MIN_LIBVIRT_VERSION))",
            "",
            "        if (CONF.libvirt.virt_type == 'parallels' and",
            "            not self._host.has_min_version(MIN_LIBVIRT_PARALLELS_VERSION)):",
            "            raise exception.NovaException(",
            "                _('Running Nova with parallels virt_type requires '",
            "                  'libvirt version %s') %",
            "                self._version_to_string(MIN_LIBVIRT_PARALLELS_VERSION))",
            "",
            "        # Give the cloud admin a heads up if we are intending to",
            "        # change the MIN_LIBVIRT_VERSION in the next release.",
            "        if not self._host.has_min_version(NEXT_MIN_LIBVIRT_VERSION):",
            "            LOG.warning(_LW('Running Nova with a libvirt version less than '",
            "                            '%(version)s is deprecated. The required minimum '",
            "                            'version of libvirt will be raised to %(version)s '",
            "                            'in the next release.'),",
            "                        {'version': self._version_to_string(",
            "                            NEXT_MIN_LIBVIRT_VERSION)})",
            "",
            "        kvm_arch = arch.from_host()",
            "        if (CONF.libvirt.virt_type in ('kvm', 'qemu') and",
            "            kvm_arch in MIN_LIBVIRT_OTHER_ARCH and",
            "                not self._host.has_min_version(",
            "                                        MIN_LIBVIRT_OTHER_ARCH.get(kvm_arch),",
            "                                        MIN_QEMU_OTHER_ARCH.get(kvm_arch))):",
            "                raise exception.NovaException(",
            "                    _('Running Nova with qemu/kvm virt_type on %(arch)s '",
            "                      'requires libvirt version %(libvirt_ver)s and '",
            "                      'qemu version %(qemu_ver)s, or greater') %",
            "                    {'arch': kvm_arch,",
            "                     'libvirt_ver': self._version_to_string(",
            "                        MIN_LIBVIRT_OTHER_ARCH.get(kvm_arch)),",
            "                     'qemu_ver': self._version_to_string(",
            "                        MIN_QEMU_OTHER_ARCH.get(kvm_arch))})",
            "",
            "    def _check_required_migration_flags(self, migration_flags, config_name):",
            "        if CONF.libvirt.virt_type == 'xen':",
            "            if (migration_flags & libvirt.VIR_MIGRATE_PEER2PEER) != 0:",
            "                LOG.warning(_LW('Removing the VIR_MIGRATE_PEER2PEER flag from '",
            "                                '%(config_name)s because peer-to-peer '",
            "                                'migrations are not supported by the \"xen\" '",
            "                                'virt type'),",
            "                            {'config_name': config_name})",
            "                migration_flags &= ~libvirt.VIR_MIGRATE_PEER2PEER",
            "        else:",
            "            if (migration_flags & libvirt.VIR_MIGRATE_PEER2PEER) == 0:",
            "                LOG.warning(_LW('Adding the VIR_MIGRATE_PEER2PEER flag to '",
            "                                '%(config_name)s because direct migrations '",
            "                                'are not supported by the %(virt_type)s '",
            "                                'virt type'),",
            "                            {'config_name': config_name,",
            "                             'virt_type': CONF.libvirt.virt_type})",
            "                migration_flags |= libvirt.VIR_MIGRATE_PEER2PEER",
            "",
            "        if (migration_flags & libvirt.VIR_MIGRATE_UNDEFINE_SOURCE) == 0:",
            "            LOG.warning(_LW('Adding the VIR_MIGRATE_UNDEFINE_SOURCE flag to '",
            "                            '%(config_name)s because, without it, migrated '",
            "                            'VMs will remain defined on the source host'),",
            "                        {'config_name': config_name})",
            "            migration_flags |= libvirt.VIR_MIGRATE_UNDEFINE_SOURCE",
            "",
            "        if (migration_flags & libvirt.VIR_MIGRATE_PERSIST_DEST) != 0:",
            "            LOG.warning(_LW('Removing the VIR_MIGRATE_PERSIST_DEST flag from '",
            "                            '%(config_name)s as Nova ensures the VM is '",
            "                            'persisted on the destination host'),",
            "                        {'config_name': config_name})",
            "            migration_flags &= ~libvirt.VIR_MIGRATE_PERSIST_DEST",
            "",
            "        return migration_flags",
            "",
            "    def _check_block_migration_flags(self, live_migration_flags,",
            "                                     block_migration_flags):",
            "        if (live_migration_flags & libvirt.VIR_MIGRATE_NON_SHARED_INC) != 0:",
            "            LOG.warning(_LW('Removing the VIR_MIGRATE_NON_SHARED_INC flag '",
            "                            'from the live_migration_flag config option '",
            "                            'because it will cause all live-migrations to be '",
            "                            'block-migrations instead.'))",
            "            live_migration_flags &= ~libvirt.VIR_MIGRATE_NON_SHARED_INC",
            "",
            "        if (block_migration_flags & libvirt.VIR_MIGRATE_NON_SHARED_INC) == 0:",
            "            LOG.warning(_LW('Adding the VIR_MIGRATE_NON_SHARED_INC flag to '",
            "                            'the block_migration_flag config option, '",
            "                            'otherwise all block-migrations will be '",
            "                            'live-migrations instead.'))",
            "            block_migration_flags |= libvirt.VIR_MIGRATE_NON_SHARED_INC",
            "",
            "        return (live_migration_flags, block_migration_flags)",
            "",
            "    def _handle_live_migration_tunnelled(self, migration_flags, config_name):",
            "        if CONF.libvirt.live_migration_tunnelled is None:",
            "            return migration_flags",
            "",
            "        if CONF.libvirt.live_migration_tunnelled:",
            "            if (migration_flags & libvirt.VIR_MIGRATE_TUNNELLED) == 0:",
            "                LOG.warning(_LW('The %(config_name)s config option does not '",
            "                                'contain the VIR_MIGRATE_TUNNELLED flag but '",
            "                                'the live_migration_tunnelled is set to True '",
            "                                'which causes VIR_MIGRATE_TUNNELLED to be '",
            "                                'set'),",
            "                            {'config_name': config_name})",
            "            migration_flags |= libvirt.VIR_MIGRATE_TUNNELLED",
            "        else:",
            "            if (migration_flags & libvirt.VIR_MIGRATE_TUNNELLED) != 0:",
            "                LOG.warning(_LW('The %(config_name)s config option contains '",
            "                                'the VIR_MIGRATE_TUNNELLED flag but the '",
            "                                'live_migration_tunnelled is set to False '",
            "                                'which causes VIR_MIGRATE_TUNNELLED to be '",
            "                                'unset'),",
            "                            {'config_name': config_name})",
            "            migration_flags &= ~libvirt.VIR_MIGRATE_TUNNELLED",
            "",
            "        return migration_flags",
            "",
            "    def _parse_migration_flags(self):",
            "        def str2sum(str_val):",
            "            logical_sum = 0",
            "            for s in [i.strip() for i in str_val.split(',') if i]:",
            "                try:",
            "                    logical_sum |= getattr(libvirt, s)",
            "                except AttributeError:",
            "                    LOG.warning(_LW(\"Ignoring unknown libvirt live migration \"",
            "                                    \"flag '%(flag)s'\"), {'flag': s})",
            "            return logical_sum",
            "",
            "        live_migration_flags = str2sum(CONF.libvirt.live_migration_flag)",
            "        block_migration_flags = str2sum(CONF.libvirt.block_migration_flag)",
            "",
            "        live_config_name = 'live_migration_flag'",
            "        block_config_name = 'block_migration_flag'",
            "",
            "        live_migration_flags = self._check_required_migration_flags(",
            "            live_migration_flags, live_config_name)",
            "        block_migration_flags = self._check_required_migration_flags(",
            "            block_migration_flags, block_config_name)",
            "",
            "        (live_migration_flags,",
            "         block_migration_flags) = self._check_block_migration_flags(",
            "             live_migration_flags, block_migration_flags)",
            "",
            "        live_migration_flags = self._handle_live_migration_tunnelled(",
            "            live_migration_flags, live_config_name)",
            "        block_migration_flags = self._handle_live_migration_tunnelled(",
            "            block_migration_flags, block_config_name)",
            "",
            "        self._live_migration_flags = live_migration_flags",
            "        self._block_migration_flags = block_migration_flags",
            "",
            "    # TODO(sahid): This method is targeted for removal when the tests",
            "    # have been updated to avoid its use",
            "    #",
            "    # All libvirt API calls on the libvirt.Connect object should be",
            "    # encapsulated by methods on the nova.virt.libvirt.host.Host",
            "    # object, rather than directly invoking the libvirt APIs. The goal",
            "    # is to avoid a direct dependency on the libvirt API from the",
            "    # driver.py file.",
            "    def _get_connection(self):",
            "        return self._host.get_connection()",
            "",
            "    _conn = property(_get_connection)",
            "",
            "    @staticmethod",
            "    def _uri():",
            "        if CONF.libvirt.virt_type == 'uml':",
            "            uri = CONF.libvirt.connection_uri or 'uml:///system'",
            "        elif CONF.libvirt.virt_type == 'xen':",
            "            uri = CONF.libvirt.connection_uri or 'xen:///'",
            "        elif CONF.libvirt.virt_type == 'lxc':",
            "            uri = CONF.libvirt.connection_uri or 'lxc:///'",
            "        elif CONF.libvirt.virt_type == 'parallels':",
            "            uri = CONF.libvirt.connection_uri or 'parallels:///system'",
            "        else:",
            "            uri = CONF.libvirt.connection_uri or 'qemu:///system'",
            "        return uri",
            "",
            "    @staticmethod",
            "    def _live_migration_uri(dest):",
            "        # Only Xen and QEMU support live migration, see",
            "        # https://libvirt.org/migration.html#scenarios for reference",
            "        uris = {",
            "            'kvm': 'qemu+tcp://%s/system',",
            "            'qemu': 'qemu+tcp://%s/system',",
            "            'xen': 'xenmigr://%s/system',",
            "        }",
            "        virt_type = CONF.libvirt.virt_type",
            "        uri = CONF.libvirt.live_migration_uri or uris.get(virt_type)",
            "        if uri is None:",
            "            raise exception.LiveMigrationURINotAvailable(virt_type=virt_type)",
            "        return uri % dest",
            "",
            "    def instance_exists(self, instance):",
            "        \"\"\"Efficient override of base instance_exists method.\"\"\"",
            "        try:",
            "            self._host.get_guest(instance)",
            "            return True",
            "        except exception.NovaException:",
            "            return False",
            "",
            "    def list_instances(self):",
            "        names = []",
            "        for guest in self._host.list_guests(only_running=False):",
            "            names.append(guest.name)",
            "",
            "        return names",
            "",
            "    def list_instance_uuids(self):",
            "        uuids = []",
            "        for guest in self._host.list_guests(only_running=False):",
            "            uuids.append(guest.uuid)",
            "",
            "        return uuids",
            "",
            "    def plug_vifs(self, instance, network_info):",
            "        \"\"\"Plug VIFs into networks.\"\"\"",
            "        for vif in network_info:",
            "            self.vif_driver.plug(instance, vif)",
            "",
            "    def _unplug_vifs(self, instance, network_info, ignore_errors):",
            "        \"\"\"Unplug VIFs from networks.\"\"\"",
            "        for vif in network_info:",
            "            try:",
            "                self.vif_driver.unplug(instance, vif)",
            "            except exception.NovaException:",
            "                if not ignore_errors:",
            "                    raise",
            "",
            "    def unplug_vifs(self, instance, network_info):",
            "        self._unplug_vifs(instance, network_info, False)",
            "",
            "    def _teardown_container(self, instance):",
            "        inst_path = libvirt_utils.get_instance_path(instance)",
            "        container_dir = os.path.join(inst_path, 'rootfs')",
            "        rootfs_dev = instance.system_metadata.get('rootfs_device_name')",
            "        LOG.debug('Attempting to teardown container at path %(dir)s with '",
            "                  'root device: %(rootfs_dev)s',",
            "                  {'dir': container_dir, 'rootfs_dev': rootfs_dev},",
            "                  instance=instance)",
            "        disk.teardown_container(container_dir, rootfs_dev)",
            "",
            "    def _destroy(self, instance, attempt=1):",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "        except exception.InstanceNotFound:",
            "            guest = None",
            "",
            "        # If the instance is already terminated, we're still happy",
            "        # Otherwise, destroy it",
            "        old_domid = -1",
            "        if guest is not None:",
            "            try:",
            "                old_domid = guest.id",
            "                guest.poweroff()",
            "",
            "            except libvirt.libvirtError as e:",
            "                is_okay = False",
            "                errcode = e.get_error_code()",
            "                if errcode == libvirt.VIR_ERR_NO_DOMAIN:",
            "                    # Domain already gone. This can safely be ignored.",
            "                    is_okay = True",
            "                elif errcode == libvirt.VIR_ERR_OPERATION_INVALID:",
            "                    # If the instance is already shut off, we get this:",
            "                    # Code=55 Error=Requested operation is not valid:",
            "                    # domain is not running",
            "",
            "                    state = guest.get_power_state(self._host)",
            "                    if state == power_state.SHUTDOWN:",
            "                        is_okay = True",
            "                elif errcode == libvirt.VIR_ERR_INTERNAL_ERROR:",
            "                    errmsg = e.get_error_message()",
            "                    if (CONF.libvirt.virt_type == 'lxc' and",
            "                        errmsg == 'internal error: '",
            "                                  'Some processes refused to die'):",
            "                        # Some processes in the container didn't die",
            "                        # fast enough for libvirt. The container will",
            "                        # eventually die. For now, move on and let",
            "                        # the wait_for_destroy logic take over.",
            "                        is_okay = True",
            "                elif errcode == libvirt.VIR_ERR_OPERATION_TIMEOUT:",
            "                    LOG.warn(_LW(\"Cannot destroy instance, operation time \"",
            "                                 \"out\"),",
            "                             instance=instance)",
            "                    reason = _(\"operation time out\")",
            "                    raise exception.InstancePowerOffFailure(reason=reason)",
            "                elif errcode == libvirt.VIR_ERR_SYSTEM_ERROR:",
            "                    if e.get_int1() == errno.EBUSY:",
            "                        # NOTE(danpb): When libvirt kills a process it sends it",
            "                        # SIGTERM first and waits 10 seconds. If it hasn't gone",
            "                        # it sends SIGKILL and waits another 5 seconds. If it",
            "                        # still hasn't gone then you get this EBUSY error.",
            "                        # Usually when a QEMU process fails to go away upon",
            "                        # SIGKILL it is because it is stuck in an",
            "                        # uninterruptable kernel sleep waiting on I/O from",
            "                        # some non-responsive server.",
            "                        # Given the CPU load of the gate tests though, it is",
            "                        # conceivable that the 15 second timeout is too short,",
            "                        # particularly if the VM running tempest has a high",
            "                        # steal time from the cloud host. ie 15 wallclock",
            "                        # seconds may have passed, but the VM might have only",
            "                        # have a few seconds of scheduled run time.",
            "                        LOG.warn(_LW('Error from libvirt during destroy. '",
            "                                     'Code=%(errcode)s Error=%(e)s; '",
            "                                     'attempt %(attempt)d of 3'),",
            "                                 {'errcode': errcode, 'e': e,",
            "                                  'attempt': attempt},",
            "                                 instance=instance)",
            "                        with excutils.save_and_reraise_exception() as ctxt:",
            "                            # Try up to 3 times before giving up.",
            "                            if attempt < 3:",
            "                                ctxt.reraise = False",
            "                                self._destroy(instance, attempt + 1)",
            "                                return",
            "",
            "                if not is_okay:",
            "                    with excutils.save_and_reraise_exception():",
            "                        LOG.error(_LE('Error from libvirt during destroy. '",
            "                                      'Code=%(errcode)s Error=%(e)s'),",
            "                                  {'errcode': errcode, 'e': e},",
            "                                  instance=instance)",
            "",
            "        def _wait_for_destroy(expected_domid):",
            "            \"\"\"Called at an interval until the VM is gone.\"\"\"",
            "            # NOTE(vish): If the instance disappears during the destroy",
            "            #             we ignore it so the cleanup can still be",
            "            #             attempted because we would prefer destroy to",
            "            #             never fail.",
            "            try:",
            "                dom_info = self.get_info(instance)",
            "                state = dom_info.state",
            "                new_domid = dom_info.id",
            "            except exception.InstanceNotFound:",
            "                LOG.info(_LI(\"During wait destroy, instance disappeared.\"),",
            "                         instance=instance)",
            "                raise loopingcall.LoopingCallDone()",
            "",
            "            if state == power_state.SHUTDOWN:",
            "                LOG.info(_LI(\"Instance destroyed successfully.\"),",
            "                         instance=instance)",
            "                raise loopingcall.LoopingCallDone()",
            "",
            "            # NOTE(wangpan): If the instance was booted again after destroy,",
            "            #                this may be an endless loop, so check the id of",
            "            #                domain here, if it changed and the instance is",
            "            #                still running, we should destroy it again.",
            "            # see https://bugs.launchpad.net/nova/+bug/1111213 for more details",
            "            if new_domid != expected_domid:",
            "                LOG.info(_LI(\"Instance may be started again.\"),",
            "                         instance=instance)",
            "                kwargs['is_running'] = True",
            "                raise loopingcall.LoopingCallDone()",
            "",
            "        kwargs = {'is_running': False}",
            "        timer = loopingcall.FixedIntervalLoopingCall(_wait_for_destroy,",
            "                                                     old_domid)",
            "        timer.start(interval=0.5).wait()",
            "        if kwargs['is_running']:",
            "            LOG.info(_LI(\"Going to destroy instance again.\"),",
            "                     instance=instance)",
            "            self._destroy(instance)",
            "        else:",
            "            # NOTE(GuanQiang): teardown container to avoid resource leak",
            "            if CONF.libvirt.virt_type == 'lxc':",
            "                self._teardown_container(instance)",
            "",
            "    def destroy(self, context, instance, network_info, block_device_info=None,",
            "                destroy_disks=True, migrate_data=None):",
            "        self._destroy(instance)",
            "        self.cleanup(context, instance, network_info, block_device_info,",
            "                     destroy_disks, migrate_data)",
            "",
            "    def _undefine_domain(self, instance):",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "            try:",
            "                guest.delete_configuration()",
            "            except libvirt.libvirtError as e:",
            "                with excutils.save_and_reraise_exception():",
            "                    errcode = e.get_error_code()",
            "                    LOG.error(_LE('Error from libvirt during undefine. '",
            "                                  'Code=%(errcode)s Error=%(e)s'),",
            "                              {'errcode': errcode, 'e': e}, instance=instance)",
            "        except exception.InstanceNotFound:",
            "            pass",
            "",
            "    def cleanup(self, context, instance, network_info, block_device_info=None,",
            "                destroy_disks=True, migrate_data=None, destroy_vifs=True):",
            "        if destroy_vifs:",
            "            self._unplug_vifs(instance, network_info, True)",
            "",
            "        retry = True",
            "        while retry:",
            "            try:",
            "                self.unfilter_instance(instance, network_info)",
            "            except libvirt.libvirtError as e:",
            "                try:",
            "                    state = self.get_info(instance).state",
            "                except exception.InstanceNotFound:",
            "                    state = power_state.SHUTDOWN",
            "",
            "                if state != power_state.SHUTDOWN:",
            "                    LOG.warn(_LW(\"Instance may be still running, destroy \"",
            "                                 \"it again.\"), instance=instance)",
            "                    self._destroy(instance)",
            "                else:",
            "                    retry = False",
            "                    errcode = e.get_error_code()",
            "                    LOG.exception(_LE('Error from libvirt during unfilter. '",
            "                                      'Code=%(errcode)s Error=%(e)s'),",
            "                                  {'errcode': errcode, 'e': e},",
            "                                  instance=instance)",
            "                    reason = \"Error unfiltering instance.\"",
            "                    raise exception.InstanceTerminationFailure(reason=reason)",
            "            except Exception:",
            "                retry = False",
            "                raise",
            "            else:",
            "                retry = False",
            "",
            "        # FIXME(wangpan): if the instance is booted again here, such as the",
            "        #                 the soft reboot operation boot it here, it will",
            "        #                 become \"running deleted\", should we check and destroy",
            "        #                 it at the end of this method?",
            "",
            "        # NOTE(vish): we disconnect from volumes regardless",
            "        block_device_mapping = driver.block_device_info_get_mapping(",
            "            block_device_info)",
            "        for vol in block_device_mapping:",
            "            connection_info = vol['connection_info']",
            "            disk_dev = vol['mount_device']",
            "            if disk_dev is not None:",
            "                disk_dev = disk_dev.rpartition(\"/\")[2]",
            "",
            "            if ('data' in connection_info and",
            "                    'volume_id' in connection_info['data']):",
            "                volume_id = connection_info['data']['volume_id']",
            "                encryption = encryptors.get_encryption_metadata(",
            "                    context, self._volume_api, volume_id, connection_info)",
            "",
            "                if encryption:",
            "                    # The volume must be detached from the VM before",
            "                    # disconnecting it from its encryptor. Otherwise, the",
            "                    # encryptor may report that the volume is still in use.",
            "                    encryptor = self._get_volume_encryptor(connection_info,",
            "                                                           encryption)",
            "                    encryptor.detach_volume(**encryption)",
            "",
            "            try:",
            "                self._disconnect_volume(connection_info, disk_dev)",
            "            except Exception as exc:",
            "                with excutils.save_and_reraise_exception() as ctxt:",
            "                    if destroy_disks:",
            "                        # Don't block on Volume errors if we're trying to",
            "                        # delete the instance as we may be partially created",
            "                        # or deleted",
            "                        ctxt.reraise = False",
            "                        LOG.warn(_LW(\"Ignoring Volume Error on vol %(vol_id)s \"",
            "                                     \"during delete %(exc)s\"),",
            "                                 {'vol_id': vol.get('volume_id'), 'exc': exc},",
            "                                 instance=instance)",
            "",
            "        if destroy_disks:",
            "            # NOTE(haomai): destroy volumes if needed",
            "            if CONF.libvirt.images_type == 'lvm':",
            "                self._cleanup_lvm(instance, block_device_info)",
            "            if CONF.libvirt.images_type == 'rbd':",
            "                self._cleanup_rbd(instance)",
            "",
            "        is_shared_block_storage = False",
            "        if migrate_data and 'is_shared_block_storage' in migrate_data:",
            "            is_shared_block_storage = migrate_data.is_shared_block_storage",
            "        if destroy_disks or is_shared_block_storage:",
            "            attempts = int(instance.system_metadata.get('clean_attempts',",
            "                                                        '0'))",
            "            success = self.delete_instance_files(instance)",
            "            # NOTE(mriedem): This is used in the _run_pending_deletes periodic",
            "            # task in the compute manager. The tight coupling is not great...",
            "            instance.system_metadata['clean_attempts'] = str(attempts + 1)",
            "            if success:",
            "                instance.cleaned = True",
            "            instance.save()",
            "",
            "        if CONF.serial_console.enabled:",
            "            try:",
            "                guest = self._host.get_guest(instance)",
            "                serials = self._get_serial_ports_from_guest(guest)",
            "                for hostname, port in serials:",
            "                    serial_console.release_port(host=hostname, port=port)",
            "            except exception.InstanceNotFound:",
            "                pass",
            "",
            "        self._undefine_domain(instance)",
            "",
            "    def _detach_encrypted_volumes(self, instance, block_device_info):",
            "        \"\"\"Detaches encrypted volumes attached to instance.\"\"\"",
            "        disks = jsonutils.loads(self.get_instance_disk_info(instance,",
            "                                                            block_device_info))",
            "        encrypted_volumes = filter(dmcrypt.is_encrypted,",
            "                                   [disk['path'] for disk in disks])",
            "        for path in encrypted_volumes:",
            "            dmcrypt.delete_volume(path)",
            "",
            "    def _get_serial_ports_from_guest(self, guest, mode=None):",
            "        \"\"\"Returns an iterator over serial port(s) configured on guest.",
            "",
            "        :param mode: Should be a value in (None, bind, connect)",
            "        \"\"\"",
            "        xml = guest.get_xml_desc()",
            "        tree = etree.fromstring(xml)",
            "",
            "        # The 'serial' device is the base for x86 platforms. Other platforms",
            "        # (e.g. kvm on system z = arch.S390X) can only use 'console' devices.",
            "        xpath_mode = \"[@mode='%s']\" % mode if mode else \"\"",
            "        serial_tcp = \"./devices/serial[@type='tcp']/source\" + xpath_mode",
            "        console_tcp = \"./devices/console[@type='tcp']/source\" + xpath_mode",
            "",
            "        tcp_devices = tree.findall(serial_tcp)",
            "        if len(tcp_devices) == 0:",
            "            tcp_devices = tree.findall(console_tcp)",
            "        for source in tcp_devices:",
            "            yield (source.get(\"host\"), int(source.get(\"service\")))",
            "",
            "    @staticmethod",
            "    def _get_rbd_driver():",
            "        return rbd_utils.RBDDriver(",
            "                pool=CONF.libvirt.images_rbd_pool,",
            "                ceph_conf=CONF.libvirt.images_rbd_ceph_conf,",
            "                rbd_user=CONF.libvirt.rbd_user)",
            "",
            "    def _cleanup_rbd(self, instance):",
            "        LibvirtDriver._get_rbd_driver().cleanup_volumes(instance)",
            "",
            "    def _cleanup_lvm(self, instance, block_device_info):",
            "        \"\"\"Delete all LVM disks for given instance object.\"\"\"",
            "        if instance.get('ephemeral_key_uuid') is not None:",
            "            self._detach_encrypted_volumes(instance, block_device_info)",
            "",
            "        disks = self._lvm_disks(instance)",
            "        if disks:",
            "            lvm.remove_volumes(disks)",
            "",
            "    def _lvm_disks(self, instance):",
            "        \"\"\"Returns all LVM disks for given instance object.\"\"\"",
            "        if CONF.libvirt.images_volume_group:",
            "            vg = os.path.join('/dev', CONF.libvirt.images_volume_group)",
            "            if not os.path.exists(vg):",
            "                return []",
            "            pattern = '%s_' % instance.uuid",
            "",
            "            def belongs_to_instance(disk):",
            "                return disk.startswith(pattern)",
            "",
            "            def fullpath(name):",
            "                return os.path.join(vg, name)",
            "",
            "            logical_volumes = lvm.list_volumes(vg)",
            "",
            "            disk_names = filter(belongs_to_instance, logical_volumes)",
            "            disks = map(fullpath, disk_names)",
            "            return disks",
            "        return []",
            "",
            "    def get_volume_connector(self, instance):",
            "        root_helper = utils.get_root_helper()",
            "        return connector.get_connector_properties(",
            "            root_helper, CONF.my_block_storage_ip,",
            "            CONF.libvirt.iscsi_use_multipath,",
            "            enforce_multipath=True,",
            "            host=CONF.host)",
            "",
            "    def _cleanup_resize(self, instance, network_info):",
            "        # NOTE(wangpan): we get the pre-grizzly instance path firstly,",
            "        #                so the backup dir of pre-grizzly instance can",
            "        #                be deleted correctly with grizzly or later nova.",
            "        pre_grizzly_name = libvirt_utils.get_instance_path(instance,",
            "                                                           forceold=True)",
            "        target = pre_grizzly_name + '_resize'",
            "        if not os.path.exists(target):",
            "            target = libvirt_utils.get_instance_path(instance) + '_resize'",
            "",
            "        if os.path.exists(target):",
            "            # Deletion can fail over NFS, so retry the deletion as required.",
            "            # Set maximum attempt as 5, most test can remove the directory",
            "            # for the second time.",
            "            utils.execute('rm', '-rf', target, delay_on_retry=True,",
            "                          attempts=5)",
            "",
            "        backend = self.image_backend.image(instance, 'disk')",
            "        # TODO(nic): Set ignore_errors=False in a future release.",
            "        # It is set to True here to avoid any upgrade issues surrounding",
            "        # instances being in pending resize state when the software is updated;",
            "        # in that case there will be no snapshot to remove.  Once it can be",
            "        # reasonably assumed that no such instances exist in the wild",
            "        # anymore, it should be set back to False (the default) so it will",
            "        # throw errors, like it should.",
            "        backend.remove_snap(libvirt_utils.RESIZE_SNAPSHOT_NAME,",
            "                            ignore_errors=True)",
            "",
            "        if instance.host != CONF.host:",
            "            self._undefine_domain(instance)",
            "            self.unplug_vifs(instance, network_info)",
            "            self.unfilter_instance(instance, network_info)",
            "",
            "    def _get_volume_driver(self, connection_info):",
            "        driver_type = connection_info.get('driver_volume_type')",
            "        if driver_type not in self.volume_drivers:",
            "            raise exception.VolumeDriverNotFound(driver_type=driver_type)",
            "        return self.volume_drivers[driver_type]",
            "",
            "    def _connect_volume(self, connection_info, disk_info):",
            "        vol_driver = self._get_volume_driver(connection_info)",
            "        vol_driver.connect_volume(connection_info, disk_info)",
            "",
            "    def _disconnect_volume(self, connection_info, disk_dev):",
            "        vol_driver = self._get_volume_driver(connection_info)",
            "        vol_driver.disconnect_volume(connection_info, disk_dev)",
            "",
            "    def _get_volume_config(self, connection_info, disk_info):",
            "        vol_driver = self._get_volume_driver(connection_info)",
            "        return vol_driver.get_config(connection_info, disk_info)",
            "",
            "    def _get_volume_encryptor(self, connection_info, encryption):",
            "        encryptor = encryptors.get_volume_encryptor(connection_info,",
            "                                                    **encryption)",
            "        return encryptor",
            "",
            "    def _check_discard_for_attach_volume(self, conf, instance):",
            "        \"\"\"Perform some checks for volumes configured for discard support.",
            "",
            "        If discard is configured for the volume, and the guest is using a",
            "        configuration known to not work, we will log a message explaining",
            "        the reason why.",
            "        \"\"\"",
            "        if conf.driver_discard == 'unmap' and conf.target_bus == 'virtio':",
            "            LOG.debug('Attempting to attach volume %(id)s with discard '",
            "                      'support enabled to an instance using an '",
            "                      'unsupported configuration. target_bus = '",
            "                      '%(bus)s. Trim commands will not be issued to '",
            "                      'the storage device.',",
            "                      {'bus': conf.target_bus,",
            "                       'id': conf.serial},",
            "                      instance=instance)",
            "",
            "    def attach_volume(self, context, connection_info, instance, mountpoint,",
            "                      disk_bus=None, device_type=None, encryption=None):",
            "        guest = self._host.get_guest(instance)",
            "",
            "        disk_dev = mountpoint.rpartition(\"/\")[2]",
            "        bdm = {",
            "            'device_name': disk_dev,",
            "            'disk_bus': disk_bus,",
            "            'device_type': device_type}",
            "",
            "        # Note(cfb): If the volume has a custom block size, check that",
            "        #            that we are using QEMU/KVM and libvirt >= 0.10.2. The",
            "        #            presence of a block size is considered mandatory by",
            "        #            cinder so we fail if we can't honor the request.",
            "        data = {}",
            "        if ('data' in connection_info):",
            "            data = connection_info['data']",
            "        if ('logical_block_size' in data or 'physical_block_size' in data):",
            "            if ((CONF.libvirt.virt_type != \"kvm\" and",
            "                 CONF.libvirt.virt_type != \"qemu\")):",
            "                msg = _(\"Volume sets block size, but the current \"",
            "                        \"libvirt hypervisor '%s' does not support custom \"",
            "                        \"block size\") % CONF.libvirt.virt_type",
            "                raise exception.InvalidHypervisorType(msg)",
            "",
            "        disk_info = blockinfo.get_info_from_bdm(",
            "            instance, CONF.libvirt.virt_type, instance.image_meta, bdm)",
            "        self._connect_volume(connection_info, disk_info)",
            "        conf = self._get_volume_config(connection_info, disk_info)",
            "        self._set_cache_mode(conf)",
            "",
            "        self._check_discard_for_attach_volume(conf, instance)",
            "",
            "        try:",
            "            state = guest.get_power_state(self._host)",
            "            live = state in (power_state.RUNNING, power_state.PAUSED)",
            "",
            "            if encryption:",
            "                encryptor = self._get_volume_encryptor(connection_info,",
            "                                                       encryption)",
            "                encryptor.attach_volume(context, **encryption)",
            "",
            "            guest.attach_device(conf, persistent=True, live=live)",
            "        except Exception as ex:",
            "            LOG.exception(_LE('Failed to attach volume at mountpoint: %s'),",
            "                          mountpoint, instance=instance)",
            "            if isinstance(ex, libvirt.libvirtError):",
            "                errcode = ex.get_error_code()",
            "                if errcode == libvirt.VIR_ERR_OPERATION_FAILED:",
            "                    self._disconnect_volume(connection_info, disk_dev)",
            "                    raise exception.DeviceIsBusy(device=disk_dev)",
            "",
            "            with excutils.save_and_reraise_exception():",
            "                self._disconnect_volume(connection_info, disk_dev)",
            "",
            "    def _swap_volume(self, guest, disk_path, new_path, resize_to):",
            "        \"\"\"Swap existing disk with a new block device.\"\"\"",
            "        dev = guest.get_block_device(disk_path)",
            "",
            "        # Save a copy of the domain's persistent XML file",
            "        xml = guest.get_xml_desc(dump_inactive=True, dump_sensitive=True)",
            "",
            "        # Abort is an idempotent operation, so make sure any block",
            "        # jobs which may have failed are ended.",
            "        try:",
            "            dev.abort_job()",
            "        except Exception:",
            "            pass",
            "",
            "        try:",
            "            # NOTE (rmk): blockRebase cannot be executed on persistent",
            "            #             domains, so we need to temporarily undefine it.",
            "            #             If any part of this block fails, the domain is",
            "            #             re-defined regardless.",
            "            if guest.has_persistent_configuration():",
            "                guest.delete_configuration()",
            "",
            "            # Start copy with VIR_DOMAIN_REBASE_REUSE_EXT flag to",
            "            # allow writing to existing external volume file",
            "            dev.rebase(new_path, copy=True, reuse_ext=True)",
            "",
            "            while dev.wait_for_job():",
            "                time.sleep(0.5)",
            "",
            "            dev.abort_job(pivot=True)",
            "            if resize_to:",
            "                # NOTE(alex_xu): domain.blockJobAbort isn't sync call. This",
            "                # is bug in libvirt. So we need waiting for the pivot is",
            "                # finished. libvirt bug #1119173",
            "                while dev.wait_for_job(wait_for_job_clean=True):",
            "                    time.sleep(0.5)",
            "                dev.resize(resize_to * units.Gi / units.Ki)",
            "        finally:",
            "            self._host.write_instance_config(xml)",
            "",
            "    def swap_volume(self, old_connection_info,",
            "                    new_connection_info, instance, mountpoint, resize_to):",
            "",
            "        guest = self._host.get_guest(instance)",
            "",
            "        disk_dev = mountpoint.rpartition(\"/\")[2]",
            "        if not guest.get_disk(disk_dev):",
            "            raise exception.DiskNotFound(location=disk_dev)",
            "        disk_info = {",
            "            'dev': disk_dev,",
            "            'bus': blockinfo.get_disk_bus_for_disk_dev(",
            "                CONF.libvirt.virt_type, disk_dev),",
            "            'type': 'disk',",
            "            }",
            "        self._connect_volume(new_connection_info, disk_info)",
            "        conf = self._get_volume_config(new_connection_info, disk_info)",
            "        if not conf.source_path:",
            "            self._disconnect_volume(new_connection_info, disk_dev)",
            "            raise NotImplementedError(_(\"Swap only supports host devices\"))",
            "",
            "        # Save updates made in connection_info when connect_volume was called",
            "        volume_id = new_connection_info.get('serial')",
            "        bdm = objects.BlockDeviceMapping.get_by_volume_and_instance(",
            "            nova_context.get_admin_context(), volume_id, instance.uuid)",
            "        driver_bdm = driver_block_device.DriverVolumeBlockDevice(bdm)",
            "        driver_bdm['connection_info'] = new_connection_info",
            "        driver_bdm.save()",
            "",
            "        self._swap_volume(guest, disk_dev, conf.source_path, resize_to)",
            "        self._disconnect_volume(old_connection_info, disk_dev)",
            "",
            "    def _get_existing_domain_xml(self, instance, network_info,",
            "                                 block_device_info=None):",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "            xml = guest.get_xml_desc()",
            "        except exception.InstanceNotFound:",
            "            disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                                instance,",
            "                                                instance.image_meta,",
            "                                                block_device_info)",
            "            xml = self._get_guest_xml(nova_context.get_admin_context(),",
            "                                      instance, network_info, disk_info,",
            "                                      instance.image_meta,",
            "                                      block_device_info=block_device_info)",
            "        return xml",
            "",
            "    def detach_volume(self, connection_info, instance, mountpoint,",
            "                      encryption=None):",
            "        disk_dev = mountpoint.rpartition(\"/\")[2]",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "",
            "            state = guest.get_power_state(self._host)",
            "            live = state in (power_state.RUNNING, power_state.PAUSED)",
            "",
            "            wait_for_detach = guest.detach_device_with_retry(guest.get_disk,",
            "                                                             disk_dev,",
            "                                                             persistent=True,",
            "                                                             live=live)",
            "",
            "            if encryption:",
            "                # The volume must be detached from the VM before",
            "                # disconnecting it from its encryptor. Otherwise, the",
            "                # encryptor may report that the volume is still in use.",
            "                encryptor = self._get_volume_encryptor(connection_info,",
            "                                                       encryption)",
            "                encryptor.detach_volume(**encryption)",
            "",
            "            wait_for_detach()",
            "        except exception.InstanceNotFound:",
            "            # NOTE(zhaoqin): If the instance does not exist, _lookup_by_name()",
            "            #                will throw InstanceNotFound exception. Need to",
            "            #                disconnect volume under this circumstance.",
            "            LOG.warn(_LW(\"During detach_volume, instance disappeared.\"),",
            "                     instance=instance)",
            "        except exception.DeviceNotFound:",
            "            raise exception.DiskNotFound(location=disk_dev)",
            "        except libvirt.libvirtError as ex:",
            "            # NOTE(vish): This is called to cleanup volumes after live",
            "            #             migration, so we should still disconnect even if",
            "            #             the instance doesn't exist here anymore.",
            "            error_code = ex.get_error_code()",
            "            if error_code == libvirt.VIR_ERR_NO_DOMAIN:",
            "                # NOTE(vish):",
            "                LOG.warn(_LW(\"During detach_volume, instance disappeared.\"),",
            "                         instance=instance)",
            "            else:",
            "                raise",
            "",
            "        self._disconnect_volume(connection_info, disk_dev)",
            "",
            "    def attach_interface(self, instance, image_meta, vif):",
            "        guest = self._host.get_guest(instance)",
            "",
            "        self.vif_driver.plug(instance, vif)",
            "        self.firewall_driver.setup_basic_filtering(instance, [vif])",
            "        cfg = self.vif_driver.get_config(instance, vif, image_meta,",
            "                                         instance.flavor,",
            "                                         CONF.libvirt.virt_type,",
            "                                         self._host)",
            "        try:",
            "            state = guest.get_power_state(self._host)",
            "            live = state in (power_state.RUNNING, power_state.PAUSED)",
            "            guest.attach_device(cfg, persistent=True, live=live)",
            "        except libvirt.libvirtError:",
            "            LOG.error(_LE('attaching network adapter failed.'),",
            "                     instance=instance, exc_info=True)",
            "            self.vif_driver.unplug(instance, vif)",
            "            raise exception.InterfaceAttachFailed(",
            "                    instance_uuid=instance.uuid)",
            "",
            "    def detach_interface(self, instance, vif):",
            "        guest = self._host.get_guest(instance)",
            "        cfg = self.vif_driver.get_config(instance, vif,",
            "                                         instance.image_meta,",
            "                                         instance.flavor,",
            "                                         CONF.libvirt.virt_type, self._host)",
            "        try:",
            "            self.vif_driver.unplug(instance, vif)",
            "            state = guest.get_power_state(self._host)",
            "            live = state in (power_state.RUNNING, power_state.PAUSED)",
            "            guest.detach_device(cfg, persistent=True, live=live)",
            "        except libvirt.libvirtError as ex:",
            "            error_code = ex.get_error_code()",
            "            if error_code == libvirt.VIR_ERR_NO_DOMAIN:",
            "                LOG.warn(_LW(\"During detach_interface, \"",
            "                             \"instance disappeared.\"),",
            "                         instance=instance)",
            "            else:",
            "                # NOTE(mriedem): When deleting an instance and using Neutron,",
            "                # we can be racing against Neutron deleting the port and",
            "                # sending the vif-deleted event which then triggers a call to",
            "                # detach the interface, so we might have failed because the",
            "                # network device no longer exists. Libvirt will fail with",
            "                # \"operation failed: no matching network device was found\"",
            "                # which unfortunately does not have a unique error code so we",
            "                # need to look up the interface by MAC and if it's not found",
            "                # then we can just log it as a warning rather than tracing an",
            "                # error.",
            "                mac = vif.get('address')",
            "                interface = guest.get_interface_by_mac(mac)",
            "                if interface:",
            "                    LOG.error(_LE('detaching network adapter failed.'),",
            "                             instance=instance, exc_info=True)",
            "                    raise exception.InterfaceDetachFailed(",
            "                            instance_uuid=instance.uuid)",
            "",
            "                # The interface is gone so just log it as a warning.",
            "                LOG.warning(_LW('Detaching interface %(mac)s failed  because '",
            "                                'the device is no longer found on the guest.'),",
            "                            {'mac': mac}, instance=instance)",
            "",
            "    def _create_snapshot_metadata(self, image_meta, instance,",
            "                                  img_fmt, snp_name):",
            "        metadata = {'is_public': False,",
            "                    'status': 'active',",
            "                    'name': snp_name,",
            "                    'properties': {",
            "                                   'kernel_id': instance.kernel_id,",
            "                                   'image_location': 'snapshot',",
            "                                   'image_state': 'available',",
            "                                   'owner_id': instance.project_id,",
            "                                   'ramdisk_id': instance.ramdisk_id,",
            "                                   }",
            "                    }",
            "        if instance.os_type:",
            "            metadata['properties']['os_type'] = instance.os_type",
            "",
            "        # NOTE(vish): glance forces ami disk format to be ami",
            "        if image_meta.disk_format == 'ami':",
            "            metadata['disk_format'] = 'ami'",
            "        else:",
            "            metadata['disk_format'] = img_fmt",
            "",
            "        if image_meta.obj_attr_is_set(\"container_format\"):",
            "            metadata['container_format'] = image_meta.container_format",
            "        else:",
            "            metadata['container_format'] = \"bare\"",
            "",
            "        return metadata",
            "",
            "    def snapshot(self, context, instance, image_id, update_task_state):",
            "        \"\"\"Create snapshot from a running VM instance.",
            "",
            "        This command only works with qemu 0.14+",
            "        \"\"\"",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "",
            "            # TODO(sahid): We are converting all calls from a",
            "            # virDomain object to use nova.virt.libvirt.Guest.",
            "            # We should be able to remove virt_dom at the end.",
            "            virt_dom = guest._domain",
            "        except exception.InstanceNotFound:",
            "            raise exception.InstanceNotRunning(instance_id=instance.uuid)",
            "",
            "        snapshot = self._image_api.get(context, image_id)",
            "",
            "        # source_format is an on-disk format",
            "        # source_type is a backend type",
            "        disk_path, source_format = libvirt_utils.find_disk(virt_dom)",
            "        source_type = libvirt_utils.get_disk_type_from_path(disk_path)",
            "",
            "        # We won't have source_type for raw or qcow2 disks, because we can't",
            "        # determine that from the path. We should have it from the libvirt",
            "        # xml, though.",
            "        if source_type is None:",
            "            source_type = source_format",
            "        # For lxc instances we won't have it either from libvirt xml",
            "        # (because we just gave libvirt the mounted filesystem), or the path,",
            "        # so source_type is still going to be None. In this case,",
            "        # snapshot_backend is going to default to CONF.libvirt.images_type",
            "        # below, which is still safe.",
            "",
            "        image_format = CONF.libvirt.snapshot_image_format or source_type",
            "",
            "        # NOTE(bfilippov): save lvm and rbd as raw",
            "        if image_format == 'lvm' or image_format == 'rbd':",
            "            image_format = 'raw'",
            "",
            "        metadata = self._create_snapshot_metadata(instance.image_meta,",
            "                                                  instance,",
            "                                                  image_format,",
            "                                                  snapshot['name'])",
            "",
            "        snapshot_name = uuid.uuid4().hex",
            "",
            "        state = guest.get_power_state(self._host)",
            "",
            "        # NOTE(rmk): Live snapshots require QEMU 1.3 and Libvirt 1.0.0.",
            "        #            These restrictions can be relaxed as other configurations",
            "        #            can be validated.",
            "        # NOTE(dgenin): Instances with LVM encrypted ephemeral storage require",
            "        #               cold snapshots. Currently, checking for encryption is",
            "        #               redundant because LVM supports only cold snapshots.",
            "        #               It is necessary in case this situation changes in the",
            "        #               future.",
            "        if (self._host.has_min_version(MIN_LIBVIRT_LIVESNAPSHOT_VERSION,",
            "                                       MIN_QEMU_LIVESNAPSHOT_VERSION,",
            "                                       host.HV_DRIVER_QEMU)",
            "             and source_type not in ('lvm', 'rbd')",
            "             and not CONF.ephemeral_storage_encryption.enabled",
            "             and not CONF.workarounds.disable_libvirt_livesnapshot):",
            "            live_snapshot = True",
            "            # Abort is an idempotent operation, so make sure any block",
            "            # jobs which may have failed are ended. This operation also",
            "            # confirms the running instance, as opposed to the system as a",
            "            # whole, has a new enough version of the hypervisor (bug 1193146).",
            "            try:",
            "                guest.get_block_device(disk_path).abort_job()",
            "            except libvirt.libvirtError as ex:",
            "                error_code = ex.get_error_code()",
            "                if error_code == libvirt.VIR_ERR_CONFIG_UNSUPPORTED:",
            "                    live_snapshot = False",
            "                else:",
            "                    pass",
            "        else:",
            "            live_snapshot = False",
            "",
            "        # NOTE(rmk): We cannot perform live snapshots when a managedSave",
            "        #            file is present, so we will use the cold/legacy method",
            "        #            for instances which are shutdown.",
            "        if state == power_state.SHUTDOWN:",
            "            live_snapshot = False",
            "",
            "        # NOTE(dkang): managedSave does not work for LXC",
            "        if CONF.libvirt.virt_type != 'lxc' and not live_snapshot:",
            "            if state == power_state.RUNNING or state == power_state.PAUSED:",
            "                self._detach_pci_devices(guest,",
            "                    pci_manager.get_instance_pci_devs(instance))",
            "                self._detach_sriov_ports(context, instance, guest)",
            "                guest.save_memory_state()",
            "",
            "        snapshot_backend = self.image_backend.snapshot(instance,",
            "                disk_path,",
            "                image_type=source_type)",
            "",
            "        if live_snapshot:",
            "            LOG.info(_LI(\"Beginning live snapshot process\"),",
            "                     instance=instance)",
            "        else:",
            "            LOG.info(_LI(\"Beginning cold snapshot process\"),",
            "                     instance=instance)",
            "",
            "        update_task_state(task_state=task_states.IMAGE_PENDING_UPLOAD)",
            "",
            "        try:",
            "            update_task_state(task_state=task_states.IMAGE_UPLOADING,",
            "                              expected_state=task_states.IMAGE_PENDING_UPLOAD)",
            "            metadata['location'] = snapshot_backend.direct_snapshot(",
            "                context, snapshot_name, image_format, image_id,",
            "                instance.image_ref)",
            "            self._snapshot_domain(context, live_snapshot, virt_dom, state,",
            "                                  instance)",
            "            self._image_api.update(context, image_id, metadata,",
            "                                   purge_props=False)",
            "        except (NotImplementedError, exception.ImageUnacceptable,",
            "                exception.Forbidden) as e:",
            "            if type(e) != NotImplementedError:",
            "                LOG.warning(_LW('Performing standard snapshot because direct '",
            "                                'snapshot failed: %(error)s'), {'error': e})",
            "            failed_snap = metadata.pop('location', None)",
            "            if failed_snap:",
            "                failed_snap = {'url': str(failed_snap)}",
            "            snapshot_backend.cleanup_direct_snapshot(failed_snap,",
            "                                                     also_destroy_volume=True,",
            "                                                     ignore_errors=True)",
            "            update_task_state(task_state=task_states.IMAGE_PENDING_UPLOAD,",
            "                              expected_state=task_states.IMAGE_UPLOADING)",
            "",
            "            snapshot_directory = CONF.libvirt.snapshots_directory",
            "            fileutils.ensure_tree(snapshot_directory)",
            "            with utils.tempdir(dir=snapshot_directory) as tmpdir:",
            "                try:",
            "                    out_path = os.path.join(tmpdir, snapshot_name)",
            "                    if live_snapshot:",
            "                        # NOTE(xqueralt): libvirt needs o+x in the tempdir",
            "                        os.chmod(tmpdir, 0o701)",
            "                        self._live_snapshot(context, instance, guest,",
            "                                            disk_path, out_path, source_format,",
            "                                            image_format, instance.image_meta)",
            "                    else:",
            "                        snapshot_backend.snapshot_extract(out_path,",
            "                                                          image_format)",
            "                finally:",
            "                    self._snapshot_domain(context, live_snapshot, virt_dom,",
            "                                          state, instance)",
            "                    LOG.info(_LI(\"Snapshot extracted, beginning image upload\"),",
            "                             instance=instance)",
            "",
            "                # Upload that image to the image service",
            "                update_task_state(task_state=task_states.IMAGE_UPLOADING,",
            "                        expected_state=task_states.IMAGE_PENDING_UPLOAD)",
            "                with libvirt_utils.file_open(out_path) as image_file:",
            "                    self._image_api.update(context,",
            "                                           image_id,",
            "                                           metadata,",
            "                                           image_file)",
            "        except Exception:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.exception(_LE(\"Failed to snapshot image\"))",
            "                failed_snap = metadata.pop('location', None)",
            "                if failed_snap:",
            "                    failed_snap = {'url': str(failed_snap)}",
            "                snapshot_backend.cleanup_direct_snapshot(",
            "                        failed_snap, also_destroy_volume=True,",
            "                        ignore_errors=True)",
            "",
            "        LOG.info(_LI(\"Snapshot image upload complete\"), instance=instance)",
            "",
            "    def _snapshot_domain(self, context, live_snapshot, virt_dom, state,",
            "                         instance):",
            "        guest = None",
            "        # NOTE(dkang): because previous managedSave is not called",
            "        #              for LXC, _create_domain must not be called.",
            "        if CONF.libvirt.virt_type != 'lxc' and not live_snapshot:",
            "            if state == power_state.RUNNING:",
            "                guest = self._create_domain(domain=virt_dom)",
            "            elif state == power_state.PAUSED:",
            "                guest = self._create_domain(domain=virt_dom, pause=True)",
            "",
            "            if guest is not None:",
            "                self._attach_pci_devices(",
            "                    guest, pci_manager.get_instance_pci_devs(instance))",
            "                self._attach_sriov_ports(context, instance, guest)",
            "",
            "    def _can_set_admin_password(self, image_meta):",
            "        if (CONF.libvirt.virt_type not in ('kvm', 'qemu') or",
            "            not self._host.has_min_version(MIN_LIBVIRT_SET_ADMIN_PASSWD)):",
            "            raise exception.SetAdminPasswdNotSupported()",
            "",
            "        hw_qga = image_meta.properties.get('hw_qemu_guest_agent', '')",
            "        if not strutils.bool_from_string(hw_qga):",
            "            raise exception.QemuGuestAgentNotEnabled()",
            "",
            "    def set_admin_password(self, instance, new_pass):",
            "        self._can_set_admin_password(instance.image_meta)",
            "",
            "        guest = self._host.get_guest(instance)",
            "        user = instance.image_meta.properties.get(\"os_admin_user\")",
            "        if not user:",
            "            if instance.os_type == \"windows\":",
            "                user = \"Administrator\"",
            "            else:",
            "                user = \"root\"",
            "        try:",
            "            guest.set_user_password(user, new_pass)",
            "        except libvirt.libvirtError as ex:",
            "            error_code = ex.get_error_code()",
            "            msg = (_('Error from libvirt while set password for username '",
            "                     '\"%(user)s\": [Error Code %(error_code)s] %(ex)s')",
            "                   % {'user': user, 'error_code': error_code, 'ex': ex})",
            "            raise exception.NovaException(msg)",
            "",
            "    def _can_quiesce(self, instance, image_meta):",
            "        if (CONF.libvirt.virt_type not in ('kvm', 'qemu') or",
            "            not self._host.has_min_version(MIN_LIBVIRT_FSFREEZE_VERSION)):",
            "            raise exception.InstanceQuiesceNotSupported(",
            "                instance_id=instance.uuid)",
            "",
            "        if not image_meta.properties.get('hw_qemu_guest_agent', False):",
            "            raise exception.QemuGuestAgentNotEnabled()",
            "",
            "    def _set_quiesced(self, context, instance, image_meta, quiesced):",
            "        self._can_quiesce(instance, image_meta)",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "            if quiesced:",
            "                guest.freeze_filesystems()",
            "            else:",
            "                guest.thaw_filesystems()",
            "        except libvirt.libvirtError as ex:",
            "            error_code = ex.get_error_code()",
            "            msg = (_('Error from libvirt while quiescing %(instance_name)s: '",
            "                     '[Error Code %(error_code)s] %(ex)s')",
            "                   % {'instance_name': instance.name,",
            "                      'error_code': error_code, 'ex': ex})",
            "            raise exception.NovaException(msg)",
            "",
            "    def quiesce(self, context, instance, image_meta):",
            "        \"\"\"Freeze the guest filesystems to prepare for snapshot.",
            "",
            "        The qemu-guest-agent must be setup to execute fsfreeze.",
            "        \"\"\"",
            "        self._set_quiesced(context, instance, image_meta, True)",
            "",
            "    def unquiesce(self, context, instance, image_meta):",
            "        \"\"\"Thaw the guest filesystems after snapshot.\"\"\"",
            "        self._set_quiesced(context, instance, image_meta, False)",
            "",
            "    def _live_snapshot(self, context, instance, guest, disk_path, out_path,",
            "                       source_format, image_format, image_meta):",
            "        \"\"\"Snapshot an instance without downtime.\"\"\"",
            "        dev = guest.get_block_device(disk_path)",
            "",
            "        # Save a copy of the domain's persistent XML file",
            "        xml = guest.get_xml_desc(dump_inactive=True, dump_sensitive=True)",
            "",
            "        # Abort is an idempotent operation, so make sure any block",
            "        # jobs which may have failed are ended.",
            "        try:",
            "            dev.abort_job()",
            "        except Exception:",
            "            pass",
            "",
            "        # NOTE (rmk): We are using shallow rebases as a workaround to a bug",
            "        #             in QEMU 1.3. In order to do this, we need to create",
            "        #             a destination image with the original backing file",
            "        #             and matching size of the instance root disk.",
            "        src_disk_size = libvirt_utils.get_disk_size(disk_path,",
            "                                                    format=source_format)",
            "        src_back_path = libvirt_utils.get_disk_backing_file(disk_path,",
            "                                                        format=source_format,",
            "                                                        basename=False)",
            "        disk_delta = out_path + '.delta'",
            "        libvirt_utils.create_cow_image(src_back_path, disk_delta,",
            "                                       src_disk_size)",
            "",
            "        quiesced = False",
            "        try:",
            "            self._set_quiesced(context, instance, image_meta, True)",
            "            quiesced = True",
            "        except exception.NovaException as err:",
            "            if image_meta.properties.get('os_require_quiesce', False):",
            "                raise",
            "            LOG.info(_LI('Skipping quiescing instance: %(reason)s.'),",
            "                     {'reason': err}, instance=instance)",
            "",
            "        try:",
            "            # NOTE (rmk): blockRebase cannot be executed on persistent",
            "            #             domains, so we need to temporarily undefine it.",
            "            #             If any part of this block fails, the domain is",
            "            #             re-defined regardless.",
            "            if guest.has_persistent_configuration():",
            "                guest.delete_configuration()",
            "",
            "            # NOTE (rmk): Establish a temporary mirror of our root disk and",
            "            #             issue an abort once we have a complete copy.",
            "            dev.rebase(disk_delta, copy=True, reuse_ext=True, shallow=True)",
            "",
            "            while dev.wait_for_job():",
            "                time.sleep(0.5)",
            "",
            "            dev.abort_job()",
            "            libvirt_utils.chown(disk_delta, os.getuid())",
            "        finally:",
            "            self._host.write_instance_config(xml)",
            "            if quiesced:",
            "                self._set_quiesced(context, instance, image_meta, False)",
            "",
            "        # Convert the delta (CoW) image with a backing file to a flat",
            "        # image with no backing file.",
            "        libvirt_utils.extract_snapshot(disk_delta, 'qcow2',",
            "                                       out_path, image_format)",
            "",
            "    def _volume_snapshot_update_status(self, context, snapshot_id, status):",
            "        \"\"\"Send a snapshot status update to Cinder.",
            "",
            "        This method captures and logs exceptions that occur",
            "        since callers cannot do anything useful with these exceptions.",
            "",
            "        Operations on the Cinder side waiting for this will time out if",
            "        a failure occurs sending the update.",
            "",
            "        :param context: security context",
            "        :param snapshot_id: id of snapshot being updated",
            "        :param status: new status value",
            "",
            "        \"\"\"",
            "",
            "        try:",
            "            self._volume_api.update_snapshot_status(context,",
            "                                                    snapshot_id,",
            "                                                    status)",
            "        except Exception:",
            "            LOG.exception(_LE('Failed to send updated snapshot status '",
            "                              'to volume service.'))",
            "",
            "    def _volume_snapshot_create(self, context, instance, guest,",
            "                                volume_id, new_file):",
            "        \"\"\"Perform volume snapshot.",
            "",
            "           :param guest: VM that volume is attached to",
            "           :param volume_id: volume UUID to snapshot",
            "           :param new_file: relative path to new qcow2 file present on share",
            "",
            "        \"\"\"",
            "        xml = guest.get_xml_desc()",
            "        xml_doc = etree.fromstring(xml)",
            "",
            "        device_info = vconfig.LibvirtConfigGuest()",
            "        device_info.parse_dom(xml_doc)",
            "",
            "        disks_to_snap = []          # to be snapshotted by libvirt",
            "        network_disks_to_snap = []  # network disks (netfs, gluster, etc.)",
            "        disks_to_skip = []          # local disks not snapshotted",
            "",
            "        for guest_disk in device_info.devices:",
            "            if (guest_disk.root_name != 'disk'):",
            "                continue",
            "",
            "            if (guest_disk.target_dev is None):",
            "                continue",
            "",
            "            if (guest_disk.serial is None or guest_disk.serial != volume_id):",
            "                disks_to_skip.append(guest_disk.target_dev)",
            "                continue",
            "",
            "            # disk is a Cinder volume with the correct volume_id",
            "",
            "            disk_info = {",
            "                'dev': guest_disk.target_dev,",
            "                'serial': guest_disk.serial,",
            "                'current_file': guest_disk.source_path,",
            "                'source_protocol': guest_disk.source_protocol,",
            "                'source_name': guest_disk.source_name,",
            "                'source_hosts': guest_disk.source_hosts,",
            "                'source_ports': guest_disk.source_ports",
            "            }",
            "",
            "            # Determine path for new_file based on current path",
            "            if disk_info['current_file'] is not None:",
            "                current_file = disk_info['current_file']",
            "                new_file_path = os.path.join(os.path.dirname(current_file),",
            "                                             new_file)",
            "                disks_to_snap.append((current_file, new_file_path))",
            "            elif disk_info['source_protocol'] in ('gluster', 'netfs'):",
            "                network_disks_to_snap.append((disk_info, new_file))",
            "",
            "        if not disks_to_snap and not network_disks_to_snap:",
            "            msg = _('Found no disk to snapshot.')",
            "            raise exception.NovaException(msg)",
            "",
            "        snapshot = vconfig.LibvirtConfigGuestSnapshot()",
            "",
            "        for current_name, new_filename in disks_to_snap:",
            "            snap_disk = vconfig.LibvirtConfigGuestSnapshotDisk()",
            "            snap_disk.name = current_name",
            "            snap_disk.source_path = new_filename",
            "            snap_disk.source_type = 'file'",
            "            snap_disk.snapshot = 'external'",
            "            snap_disk.driver_name = 'qcow2'",
            "",
            "            snapshot.add_disk(snap_disk)",
            "",
            "        for disk_info, new_filename in network_disks_to_snap:",
            "            snap_disk = vconfig.LibvirtConfigGuestSnapshotDisk()",
            "            snap_disk.name = disk_info['dev']",
            "            snap_disk.source_type = 'network'",
            "            snap_disk.source_protocol = disk_info['source_protocol']",
            "            snap_disk.snapshot = 'external'",
            "            snap_disk.source_path = new_filename",
            "            old_dir = disk_info['source_name'].split('/')[0]",
            "            snap_disk.source_name = '%s/%s' % (old_dir, new_filename)",
            "            snap_disk.source_hosts = disk_info['source_hosts']",
            "            snap_disk.source_ports = disk_info['source_ports']",
            "",
            "            snapshot.add_disk(snap_disk)",
            "",
            "        for dev in disks_to_skip:",
            "            snap_disk = vconfig.LibvirtConfigGuestSnapshotDisk()",
            "            snap_disk.name = dev",
            "            snap_disk.snapshot = 'no'",
            "",
            "            snapshot.add_disk(snap_disk)",
            "",
            "        snapshot_xml = snapshot.to_xml()",
            "        LOG.debug(\"snap xml: %s\", snapshot_xml, instance=instance)",
            "",
            "        try:",
            "            guest.snapshot(snapshot, no_metadata=True, disk_only=True,",
            "                           reuse_ext=True, quiesce=True)",
            "            return",
            "        except libvirt.libvirtError:",
            "            LOG.exception(_LE('Unable to create quiesced VM snapshot, '",
            "                              'attempting again with quiescing disabled.'),",
            "                          instance=instance)",
            "",
            "        try:",
            "            guest.snapshot(snapshot, no_metadata=True, disk_only=True,",
            "                           reuse_ext=True, quiesce=False)",
            "        except libvirt.libvirtError:",
            "            LOG.exception(_LE('Unable to create VM snapshot, '",
            "                              'failing volume_snapshot operation.'),",
            "                          instance=instance)",
            "",
            "            raise",
            "",
            "    def _volume_refresh_connection_info(self, context, instance, volume_id):",
            "        bdm = objects.BlockDeviceMapping.get_by_volume_and_instance(",
            "                  context, volume_id, instance.uuid)",
            "",
            "        driver_bdm = driver_block_device.convert_volume(bdm)",
            "        if driver_bdm:",
            "            driver_bdm.refresh_connection_info(context, instance,",
            "                                               self._volume_api, self)",
            "",
            "    def volume_snapshot_create(self, context, instance, volume_id,",
            "                               create_info):",
            "        \"\"\"Create snapshots of a Cinder volume via libvirt.",
            "",
            "        :param instance: VM instance object reference",
            "        :param volume_id: id of volume being snapshotted",
            "        :param create_info: dict of information used to create snapshots",
            "                     - snapshot_id : ID of snapshot",
            "                     - type : qcow2 / <other>",
            "                     - new_file : qcow2 file created by Cinder which",
            "                     becomes the VM's active image after",
            "                     the snapshot is complete",
            "        \"\"\"",
            "",
            "        LOG.debug(\"volume_snapshot_create: create_info: %(c_info)s\",",
            "                  {'c_info': create_info}, instance=instance)",
            "",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "        except exception.InstanceNotFound:",
            "            raise exception.InstanceNotRunning(instance_id=instance.uuid)",
            "",
            "        if create_info['type'] != 'qcow2':",
            "            raise exception.NovaException(_('Unknown type: %s') %",
            "                                          create_info['type'])",
            "",
            "        snapshot_id = create_info.get('snapshot_id', None)",
            "        if snapshot_id is None:",
            "            raise exception.NovaException(_('snapshot_id required '",
            "                                            'in create_info'))",
            "",
            "        try:",
            "            self._volume_snapshot_create(context, instance, guest,",
            "                                         volume_id, create_info['new_file'])",
            "        except Exception:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.exception(_LE('Error occurred during '",
            "                                  'volume_snapshot_create, '",
            "                                  'sending error status to Cinder.'),",
            "                              instance=instance)",
            "                self._volume_snapshot_update_status(",
            "                    context, snapshot_id, 'error')",
            "",
            "        self._volume_snapshot_update_status(",
            "            context, snapshot_id, 'creating')",
            "",
            "        def _wait_for_snapshot():",
            "            snapshot = self._volume_api.get_snapshot(context, snapshot_id)",
            "",
            "            if snapshot.get('status') != 'creating':",
            "                self._volume_refresh_connection_info(context, instance,",
            "                                                     volume_id)",
            "                raise loopingcall.LoopingCallDone()",
            "",
            "        timer = loopingcall.FixedIntervalLoopingCall(_wait_for_snapshot)",
            "        timer.start(interval=0.5).wait()",
            "",
            "    @staticmethod",
            "    def _rebase_with_qemu_img(guest, device, active_disk_object,",
            "                              rebase_base):",
            "        \"\"\"Rebase a device tied to a guest using qemu-img.",
            "",
            "        :param guest:the Guest which owns the device being rebased",
            "        :type guest: nova.virt.libvirt.guest.Guest",
            "        :param device: the guest block device to rebase",
            "        :type device: nova.virt.libvirt.guest.BlockDevice",
            "        :param active_disk_object: the guest block device to rebase",
            "        :type active_disk_object: nova.virt.libvirt.config.\\",
            "                                    LibvirtConfigGuestDisk",
            "        :param rebase_base: the new parent in the backing chain",
            "        :type rebase_base: None or string",
            "        \"\"\"",
            "",
            "        # It's unsure how well qemu-img handles network disks for",
            "        # every protocol. So let's be safe.",
            "        active_protocol = active_disk_object.source_protocol",
            "        if active_protocol is not None:",
            "            msg = _(\"Something went wrong when deleting a volume snapshot: \"",
            "                    \"rebasing a %(protocol)s network disk using qemu-img \"",
            "                    \"has not been fully tested\") % {'protocol':",
            "                    active_protocol}",
            "            LOG.error(msg)",
            "            raise exception.NovaException(msg)",
            "",
            "        if rebase_base is None:",
            "            # If backing_file is specified as \"\" (the empty string), then",
            "            # the image is rebased onto no backing file (i.e. it will exist",
            "            # independently of any backing file).",
            "            backing_file = \"\"",
            "            qemu_img_extra_arg = []",
            "        else:",
            "            # If the rebased image is going to have a backing file then",
            "            # explicitly set the backing file format to avoid any security",
            "            # concerns related to file format auto detection.",
            "            backing_file = rebase_base",
            "            b_file_fmt = images.qemu_img_info(backing_file).file_format",
            "            qemu_img_extra_arg = ['-F', b_file_fmt]",
            "",
            "        qemu_img_extra_arg.append(active_disk_object.source_path)",
            "        utils.execute(\"qemu-img\", \"rebase\", \"-b\", backing_file,",
            "                      *qemu_img_extra_arg)",
            "",
            "    def _volume_snapshot_delete(self, context, instance, volume_id,",
            "                                snapshot_id, delete_info=None):",
            "        \"\"\"Note:",
            "            if file being merged into == active image:",
            "                do a blockRebase (pull) operation",
            "            else:",
            "                do a blockCommit operation",
            "            Files must be adjacent in snap chain.",
            "",
            "        :param instance: instance object reference",
            "        :param volume_id: volume UUID",
            "        :param snapshot_id: snapshot UUID (unused currently)",
            "        :param delete_info: {",
            "            'type':              'qcow2',",
            "            'file_to_merge':     'a.img',",
            "            'merge_target_file': 'b.img' or None (if merging file_to_merge into",
            "                                                  active image)",
            "          }",
            "",
            "",
            "        Libvirt blockjob handling required for this method is broken",
            "        in versions of libvirt that do not contain:",
            "        http://libvirt.org/git/?p=libvirt.git;h=0f9e67bfad (1.1.1)",
            "        (Patch is pending in 1.0.5-maint branch as well, but we cannot detect",
            "        libvirt 1.0.5.5 vs. 1.0.5.6 here.)",
            "        \"\"\"",
            "",
            "        if not self._host.has_min_version(MIN_LIBVIRT_BLOCKJOBINFO_VERSION):",
            "            ver = '.'.join([str(x) for x in MIN_LIBVIRT_BLOCKJOBINFO_VERSION])",
            "            msg = _(\"Libvirt '%s' or later is required for online deletion \"",
            "                    \"of volume snapshots.\") % ver",
            "            raise exception.Invalid(msg)",
            "",
            "        LOG.debug('volume_snapshot_delete: delete_info: %s', delete_info,",
            "                  instance=instance)",
            "",
            "        if delete_info['type'] != 'qcow2':",
            "            msg = _('Unknown delete_info type %s') % delete_info['type']",
            "            raise exception.NovaException(msg)",
            "",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "        except exception.InstanceNotFound:",
            "            raise exception.InstanceNotRunning(instance_id=instance.uuid)",
            "",
            "        # Find dev name",
            "        my_dev = None",
            "        active_disk = None",
            "",
            "        xml = guest.get_xml_desc()",
            "        xml_doc = etree.fromstring(xml)",
            "",
            "        device_info = vconfig.LibvirtConfigGuest()",
            "        device_info.parse_dom(xml_doc)",
            "",
            "        active_disk_object = None",
            "",
            "        for guest_disk in device_info.devices:",
            "            if (guest_disk.root_name != 'disk'):",
            "                continue",
            "",
            "            if (guest_disk.target_dev is None or guest_disk.serial is None):",
            "                continue",
            "",
            "            if guest_disk.serial == volume_id:",
            "                my_dev = guest_disk.target_dev",
            "",
            "                active_disk = guest_disk.source_path",
            "                active_protocol = guest_disk.source_protocol",
            "                active_disk_object = guest_disk",
            "                break",
            "",
            "        if my_dev is None or (active_disk is None and active_protocol is None):",
            "            msg = _('Disk with id: %s '",
            "                    'not found attached to instance.') % volume_id",
            "            LOG.debug('Domain XML: %s', xml, instance=instance)",
            "            raise exception.NovaException(msg)",
            "",
            "        LOG.debug(\"found device at %s\", my_dev, instance=instance)",
            "",
            "        def _get_snap_dev(filename, backing_store):",
            "            if filename is None:",
            "                msg = _('filename cannot be None')",
            "                raise exception.NovaException(msg)",
            "",
            "            # libgfapi delete",
            "            LOG.debug(\"XML: %s\" % xml)",
            "",
            "            LOG.debug(\"active disk object: %s\", active_disk_object)",
            "",
            "            # determine reference within backing store for desired image",
            "            filename_to_merge = filename",
            "            matched_name = None",
            "            b = backing_store",
            "            index = None",
            "",
            "            current_filename = active_disk_object.source_name.split('/')[1]",
            "            if current_filename == filename_to_merge:",
            "                return my_dev + '[0]'",
            "",
            "            while b is not None:",
            "                source_filename = b.source_name.split('/')[1]",
            "                if source_filename == filename_to_merge:",
            "                    LOG.debug('found match: %s', b.source_name)",
            "                    matched_name = b.source_name",
            "                    index = b.index",
            "                    break",
            "",
            "                b = b.backing_store",
            "",
            "            if matched_name is None:",
            "                msg = _('no match found for %s') % (filename_to_merge)",
            "                raise exception.NovaException(msg)",
            "",
            "            LOG.debug('index of match (%s) is %s', b.source_name, index)",
            "",
            "            my_snap_dev = '%s[%s]' % (my_dev, index)",
            "            return my_snap_dev",
            "",
            "        if delete_info['merge_target_file'] is None:",
            "            # pull via blockRebase()",
            "",
            "            # Merge the most recent snapshot into the active image",
            "",
            "            rebase_disk = my_dev",
            "            rebase_base = delete_info['file_to_merge']  # often None",
            "            if (active_protocol is not None) and (rebase_base is not None):",
            "                rebase_base = _get_snap_dev(rebase_base,",
            "                                            active_disk_object.backing_store)",
            "",
            "            # NOTE(deepakcs): libvirt added support for _RELATIVE in v1.2.7,",
            "            # and when available this flag _must_ be used to ensure backing",
            "            # paths are maintained relative by qemu.",
            "            #",
            "            # If _RELATIVE flag not found, continue with old behaviour",
            "            # (relative backing path seems to work for this case)",
            "            try:",
            "                libvirt.VIR_DOMAIN_BLOCK_REBASE_RELATIVE",
            "                relative = rebase_base is not None",
            "            except AttributeError:",
            "                LOG.warn(_LW(\"Relative blockrebase support was not detected. \"",
            "                             \"Continuing with old behaviour.\"))",
            "                relative = False",
            "",
            "            LOG.debug(",
            "                'disk: %(disk)s, base: %(base)s, '",
            "                'bw: %(bw)s, relative: %(relative)s',",
            "                {'disk': rebase_disk,",
            "                 'base': rebase_base,",
            "                 'bw': libvirt_guest.BlockDevice.REBASE_DEFAULT_BANDWIDTH,",
            "                 'relative': str(relative)}, instance=instance)",
            "",
            "            dev = guest.get_block_device(rebase_disk)",
            "            if guest.is_active():",
            "                result = dev.rebase(rebase_base, relative=relative)",
            "                if result == 0:",
            "                    LOG.debug('blockRebase started successfully',",
            "                              instance=instance)",
            "",
            "                while dev.wait_for_job(abort_on_error=True):",
            "                    LOG.debug('waiting for blockRebase job completion',",
            "                              instance=instance)",
            "                    time.sleep(0.5)",
            "",
            "            # If the guest is not running libvirt won't do a blockRebase.",
            "            # In that case, let's ask qemu-img to rebase the disk.",
            "            else:",
            "                LOG.debug('Guest is not running so doing a block rebase '",
            "                          'using \"qemu-img rebase\"', instance=instance)",
            "                self._rebase_with_qemu_img(guest, dev, active_disk_object,",
            "                                           rebase_base)",
            "",
            "        else:",
            "            # commit with blockCommit()",
            "            my_snap_base = None",
            "            my_snap_top = None",
            "            commit_disk = my_dev",
            "",
            "            # NOTE(deepakcs): libvirt added support for _RELATIVE in v1.2.7,",
            "            # and when available this flag _must_ be used to ensure backing",
            "            # paths are maintained relative by qemu.",
            "            #",
            "            # If _RELATIVE flag not found, raise exception as relative backing",
            "            # path may not be maintained and Cinder flow is broken if allowed",
            "            # to continue.",
            "            try:",
            "                libvirt.VIR_DOMAIN_BLOCK_COMMIT_RELATIVE",
            "            except AttributeError:",
            "                ver = '.'.join(",
            "                    [str(x) for x in",
            "                     MIN_LIBVIRT_BLOCKJOB_RELATIVE_VERSION])",
            "                msg = _(\"Relative blockcommit support was not detected. \"",
            "                        \"Libvirt '%s' or later is required for online \"",
            "                        \"deletion of file/network storage-backed volume \"",
            "                        \"snapshots.\") % ver",
            "                raise exception.Invalid(msg)",
            "",
            "            if active_protocol is not None:",
            "                my_snap_base = _get_snap_dev(delete_info['merge_target_file'],",
            "                                             active_disk_object.backing_store)",
            "                my_snap_top = _get_snap_dev(delete_info['file_to_merge'],",
            "                                            active_disk_object.backing_store)",
            "",
            "            commit_base = my_snap_base or delete_info['merge_target_file']",
            "            commit_top = my_snap_top or delete_info['file_to_merge']",
            "",
            "            LOG.debug('will call blockCommit with commit_disk=%(commit_disk)s '",
            "                      'commit_base=%(commit_base)s '",
            "                      'commit_top=%(commit_top)s ',",
            "                      {'commit_disk': commit_disk,",
            "                       'commit_base': commit_base,",
            "                       'commit_top': commit_top}, instance=instance)",
            "",
            "            dev = guest.get_block_device(commit_disk)",
            "            result = dev.commit(commit_base, commit_top, relative=True)",
            "",
            "            if result == 0:",
            "                LOG.debug('blockCommit started successfully',",
            "                          instance=instance)",
            "",
            "            while dev.wait_for_job(abort_on_error=True):",
            "                LOG.debug('waiting for blockCommit job completion',",
            "                          instance=instance)",
            "                time.sleep(0.5)",
            "",
            "    def volume_snapshot_delete(self, context, instance, volume_id, snapshot_id,",
            "                               delete_info):",
            "        try:",
            "            self._volume_snapshot_delete(context, instance, volume_id,",
            "                                         snapshot_id, delete_info=delete_info)",
            "        except Exception:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.exception(_LE('Error occurred during '",
            "                                  'volume_snapshot_delete, '",
            "                                  'sending error status to Cinder.'),",
            "                              instance=instance)",
            "                self._volume_snapshot_update_status(",
            "                    context, snapshot_id, 'error_deleting')",
            "",
            "        self._volume_snapshot_update_status(context, snapshot_id, 'deleting')",
            "        self._volume_refresh_connection_info(context, instance, volume_id)",
            "",
            "    def reboot(self, context, instance, network_info, reboot_type,",
            "               block_device_info=None, bad_volumes_callback=None):",
            "        \"\"\"Reboot a virtual machine, given an instance reference.\"\"\"",
            "        if reboot_type == 'SOFT':",
            "            # NOTE(vish): This will attempt to do a graceful shutdown/restart.",
            "            try:",
            "                soft_reboot_success = self._soft_reboot(instance)",
            "            except libvirt.libvirtError as e:",
            "                LOG.debug(\"Instance soft reboot failed: %s\", e,",
            "                          instance=instance)",
            "                soft_reboot_success = False",
            "",
            "            if soft_reboot_success:",
            "                LOG.info(_LI(\"Instance soft rebooted successfully.\"),",
            "                         instance=instance)",
            "                return",
            "            else:",
            "                LOG.warn(_LW(\"Failed to soft reboot instance. \"",
            "                             \"Trying hard reboot.\"),",
            "                         instance=instance)",
            "        return self._hard_reboot(context, instance, network_info,",
            "                                 block_device_info)",
            "",
            "    def _soft_reboot(self, instance):",
            "        \"\"\"Attempt to shutdown and restart the instance gracefully.",
            "",
            "        We use shutdown and create here so we can return if the guest",
            "        responded and actually rebooted. Note that this method only",
            "        succeeds if the guest responds to acpi. Therefore we return",
            "        success or failure so we can fall back to a hard reboot if",
            "        necessary.",
            "",
            "        :returns: True if the reboot succeeded",
            "        \"\"\"",
            "        guest = self._host.get_guest(instance)",
            "",
            "        state = guest.get_power_state(self._host)",
            "        old_domid = guest.id",
            "        # NOTE(vish): This check allows us to reboot an instance that",
            "        #             is already shutdown.",
            "        if state == power_state.RUNNING:",
            "            guest.shutdown()",
            "        # NOTE(vish): This actually could take slightly longer than the",
            "        #             FLAG defines depending on how long the get_info",
            "        #             call takes to return.",
            "        self._prepare_pci_devices_for_use(",
            "            pci_manager.get_instance_pci_devs(instance, 'all'))",
            "        for x in range(CONF.libvirt.wait_soft_reboot_seconds):",
            "            guest = self._host.get_guest(instance)",
            "",
            "            state = guest.get_power_state(self._host)",
            "            new_domid = guest.id",
            "",
            "            # NOTE(ivoks): By checking domain IDs, we make sure we are",
            "            #              not recreating domain that's already running.",
            "            if old_domid != new_domid:",
            "                if state in [power_state.SHUTDOWN,",
            "                             power_state.CRASHED]:",
            "                    LOG.info(_LI(\"Instance shutdown successfully.\"),",
            "                             instance=instance)",
            "                    self._create_domain(domain=guest._domain)",
            "                    timer = loopingcall.FixedIntervalLoopingCall(",
            "                        self._wait_for_running, instance)",
            "                    timer.start(interval=0.5).wait()",
            "                    return True",
            "                else:",
            "                    LOG.info(_LI(\"Instance may have been rebooted during soft \"",
            "                                 \"reboot, so return now.\"), instance=instance)",
            "                    return True",
            "            greenthread.sleep(1)",
            "        return False",
            "",
            "    def _hard_reboot(self, context, instance, network_info,",
            "                     block_device_info=None):",
            "        \"\"\"Reboot a virtual machine, given an instance reference.",
            "",
            "        Performs a Libvirt reset (if supported) on the domain.",
            "",
            "        If Libvirt reset is unavailable this method actually destroys and",
            "        re-creates the domain to ensure the reboot happens, as the guest",
            "        OS cannot ignore this action.",
            "        \"\"\"",
            "",
            "        self._destroy(instance)",
            "",
            "        # Convert the system metadata to image metadata",
            "        instance_dir = libvirt_utils.get_instance_path(instance)",
            "        fileutils.ensure_tree(instance_dir)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            instance.image_meta,",
            "                                            block_device_info)",
            "        # NOTE(vish): This could generate the wrong device_format if we are",
            "        #             using the raw backend and the images don't exist yet.",
            "        #             The create_images_and_backing below doesn't properly",
            "        #             regenerate raw backend images, however, so when it",
            "        #             does we need to (re)generate the xml after the images",
            "        #             are in place.",
            "        xml = self._get_guest_xml(context, instance, network_info, disk_info,",
            "                                  instance.image_meta,",
            "                                  block_device_info=block_device_info,",
            "                                  write_to_disk=True)",
            "",
            "        if context.auth_token is not None:",
            "            # NOTE (rmk): Re-populate any missing backing files.",
            "            backing_disk_info = self._get_instance_disk_info(instance.name,",
            "                                                             xml,",
            "                                                             block_device_info)",
            "            self._create_images_and_backing(context, instance, instance_dir,",
            "                                            backing_disk_info)",
            "",
            "        # Initialize all the necessary networking, block devices and",
            "        # start the instance.",
            "        self._create_domain_and_network(context, xml, instance, network_info,",
            "                                        disk_info,",
            "                                        block_device_info=block_device_info,",
            "                                        reboot=True,",
            "                                        vifs_already_plugged=True)",
            "        self._prepare_pci_devices_for_use(",
            "            pci_manager.get_instance_pci_devs(instance, 'all'))",
            "",
            "        def _wait_for_reboot():",
            "            \"\"\"Called at an interval until the VM is running again.\"\"\"",
            "            state = self.get_info(instance).state",
            "",
            "            if state == power_state.RUNNING:",
            "                LOG.info(_LI(\"Instance rebooted successfully.\"),",
            "                         instance=instance)",
            "                raise loopingcall.LoopingCallDone()",
            "",
            "        timer = loopingcall.FixedIntervalLoopingCall(_wait_for_reboot)",
            "        timer.start(interval=0.5).wait()",
            "",
            "    def pause(self, instance):",
            "        \"\"\"Pause VM instance.\"\"\"",
            "        self._host.get_guest(instance).pause()",
            "",
            "    def unpause(self, instance):",
            "        \"\"\"Unpause paused VM instance.\"\"\"",
            "        self._host.get_guest(instance).resume()",
            "",
            "    def _clean_shutdown(self, instance, timeout, retry_interval):",
            "        \"\"\"Attempt to shutdown the instance gracefully.",
            "",
            "        :param instance: The instance to be shutdown",
            "        :param timeout: How long to wait in seconds for the instance to",
            "                        shutdown",
            "        :param retry_interval: How often in seconds to signal the instance",
            "                               to shutdown while waiting",
            "",
            "        :returns: True if the shutdown succeeded",
            "        \"\"\"",
            "",
            "        # List of states that represent a shutdown instance",
            "        SHUTDOWN_STATES = [power_state.SHUTDOWN,",
            "                           power_state.CRASHED]",
            "",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "        except exception.InstanceNotFound:",
            "            # If the instance has gone then we don't need to",
            "            # wait for it to shutdown",
            "            return True",
            "",
            "        state = guest.get_power_state(self._host)",
            "        if state in SHUTDOWN_STATES:",
            "            LOG.info(_LI(\"Instance already shutdown.\"),",
            "                     instance=instance)",
            "            return True",
            "",
            "        LOG.debug(\"Shutting down instance from state %s\", state,",
            "                  instance=instance)",
            "        guest.shutdown()",
            "        retry_countdown = retry_interval",
            "",
            "        for sec in six.moves.range(timeout):",
            "",
            "            guest = self._host.get_guest(instance)",
            "            state = guest.get_power_state(self._host)",
            "",
            "            if state in SHUTDOWN_STATES:",
            "                LOG.info(_LI(\"Instance shutdown successfully after %d \"",
            "                              \"seconds.\"), sec, instance=instance)",
            "                return True",
            "",
            "            # Note(PhilD): We can't assume that the Guest was able to process",
            "            #              any previous shutdown signal (for example it may",
            "            #              have still been startingup, so within the overall",
            "            #              timeout we re-trigger the shutdown every",
            "            #              retry_interval",
            "            if retry_countdown == 0:",
            "                retry_countdown = retry_interval",
            "                # Instance could shutdown at any time, in which case we",
            "                # will get an exception when we call shutdown",
            "                try:",
            "                    LOG.debug(\"Instance in state %s after %d seconds - \"",
            "                              \"resending shutdown\", state, sec,",
            "                              instance=instance)",
            "                    guest.shutdown()",
            "                except libvirt.libvirtError:",
            "                    # Assume this is because its now shutdown, so loop",
            "                    # one more time to clean up.",
            "                    LOG.debug(\"Ignoring libvirt exception from shutdown \"",
            "                              \"request.\", instance=instance)",
            "                    continue",
            "            else:",
            "                retry_countdown -= 1",
            "",
            "            time.sleep(1)",
            "",
            "        LOG.info(_LI(\"Instance failed to shutdown in %d seconds.\"),",
            "                 timeout, instance=instance)",
            "        return False",
            "",
            "    def power_off(self, instance, timeout=0, retry_interval=0):",
            "        \"\"\"Power off the specified instance.\"\"\"",
            "        if timeout:",
            "            self._clean_shutdown(instance, timeout, retry_interval)",
            "        self._destroy(instance)",
            "",
            "    def power_on(self, context, instance, network_info,",
            "                 block_device_info=None):",
            "        \"\"\"Power on the specified instance.\"\"\"",
            "        # We use _hard_reboot here to ensure that all backing files,",
            "        # network, and block device connections, etc. are established",
            "        # and available before we attempt to start the instance.",
            "        self._hard_reboot(context, instance, network_info, block_device_info)",
            "",
            "    def trigger_crash_dump(self, instance):",
            "",
            "        \"\"\"Trigger crash dump by injecting an NMI to the specified instance.\"\"\"",
            "        try:",
            "            self._host.get_guest(instance).inject_nmi()",
            "        except libvirt.libvirtError as ex:",
            "            error_code = ex.get_error_code()",
            "",
            "            if error_code == libvirt.VIR_ERR_NO_SUPPORT:",
            "                raise exception.TriggerCrashDumpNotSupported()",
            "            elif error_code == libvirt.VIR_ERR_OPERATION_INVALID:",
            "                raise exception.InstanceNotRunning(instance_id=instance.uuid)",
            "",
            "            LOG.exception(_LE('Error from libvirt while injecting an NMI to '",
            "                              '%(instance_uuid)s: '",
            "                              '[Error Code %(error_code)s] %(ex)s'),",
            "                          {'instance_uuid': instance.uuid,",
            "                           'error_code': error_code, 'ex': ex})",
            "            raise",
            "",
            "    def suspend(self, context, instance):",
            "        \"\"\"Suspend the specified instance.\"\"\"",
            "        guest = self._host.get_guest(instance)",
            "",
            "        self._detach_pci_devices(guest,",
            "            pci_manager.get_instance_pci_devs(instance))",
            "        self._detach_sriov_ports(context, instance, guest)",
            "        guest.save_memory_state()",
            "",
            "    def resume(self, context, instance, network_info, block_device_info=None):",
            "        \"\"\"resume the specified instance.\"\"\"",
            "        disk_info = blockinfo.get_disk_info(",
            "                CONF.libvirt.virt_type, instance, instance.image_meta,",
            "                block_device_info=block_device_info)",
            "",
            "        xml = self._get_existing_domain_xml(instance, network_info,",
            "                                            block_device_info)",
            "        guest = self._create_domain_and_network(context, xml, instance,",
            "                           network_info, disk_info,",
            "                           block_device_info=block_device_info,",
            "                           vifs_already_plugged=True)",
            "        self._attach_pci_devices(guest,",
            "            pci_manager.get_instance_pci_devs(instance))",
            "        self._attach_sriov_ports(context, instance, guest, network_info)",
            "",
            "    def resume_state_on_host_boot(self, context, instance, network_info,",
            "                                  block_device_info=None):",
            "        \"\"\"resume guest state when a host is booted.\"\"\"",
            "        # Check if the instance is running already and avoid doing",
            "        # anything if it is.",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "            state = guest.get_power_state(self._host)",
            "",
            "            ignored_states = (power_state.RUNNING,",
            "                              power_state.SUSPENDED,",
            "                              power_state.NOSTATE,",
            "                              power_state.PAUSED)",
            "",
            "            if state in ignored_states:",
            "                return",
            "        except exception.NovaException:",
            "            pass",
            "",
            "        # Instance is not up and could be in an unknown state.",
            "        # Be as absolute as possible about getting it back into",
            "        # a known and running state.",
            "        self._hard_reboot(context, instance, network_info, block_device_info)",
            "",
            "    def rescue(self, context, instance, network_info, image_meta,",
            "               rescue_password):",
            "        \"\"\"Loads a VM using rescue images.",
            "",
            "        A rescue is normally performed when something goes wrong with the",
            "        primary images and data needs to be corrected/recovered. Rescuing",
            "        should not edit or over-ride the original image, only allow for",
            "        data recovery.",
            "",
            "        \"\"\"",
            "        instance_dir = libvirt_utils.get_instance_path(instance)",
            "        unrescue_xml = self._get_existing_domain_xml(instance, network_info)",
            "        unrescue_xml_path = os.path.join(instance_dir, 'unrescue.xml')",
            "        libvirt_utils.write_to_file(unrescue_xml_path, unrescue_xml)",
            "",
            "        rescue_image_id = None",
            "        if image_meta.obj_attr_is_set(\"id\"):",
            "            rescue_image_id = image_meta.id",
            "",
            "        rescue_images = {",
            "            'image_id': (rescue_image_id or",
            "                        CONF.libvirt.rescue_image_id or instance.image_ref),",
            "            'kernel_id': (CONF.libvirt.rescue_kernel_id or",
            "                          instance.kernel_id),",
            "            'ramdisk_id': (CONF.libvirt.rescue_ramdisk_id or",
            "                           instance.ramdisk_id),",
            "        }",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta,",
            "                                            rescue=True)",
            "        self._create_image(context, instance, disk_info['mapping'],",
            "                           suffix='.rescue', disk_images=rescue_images,",
            "                           network_info=network_info,",
            "                           admin_pass=rescue_password)",
            "        xml = self._get_guest_xml(context, instance, network_info, disk_info,",
            "                                  image_meta, rescue=rescue_images,",
            "                                  write_to_disk=True)",
            "        self._destroy(instance)",
            "        self._create_domain(xml)",
            "",
            "    def unrescue(self, instance, network_info):",
            "        \"\"\"Reboot the VM which is being rescued back into primary images.",
            "        \"\"\"",
            "        instance_dir = libvirt_utils.get_instance_path(instance)",
            "        unrescue_xml_path = os.path.join(instance_dir, 'unrescue.xml')",
            "        xml = libvirt_utils.load_file(unrescue_xml_path)",
            "        guest = self._host.get_guest(instance)",
            "",
            "        # TODO(sahid): We are converting all calls from a",
            "        # virDomain object to use nova.virt.libvirt.Guest.",
            "        # We should be able to remove virt_dom at the end.",
            "        virt_dom = guest._domain",
            "        self._destroy(instance)",
            "        self._create_domain(xml, virt_dom)",
            "        libvirt_utils.file_delete(unrescue_xml_path)",
            "        rescue_files = os.path.join(instance_dir, \"*.rescue\")",
            "        for rescue_file in glob.iglob(rescue_files):",
            "            libvirt_utils.file_delete(rescue_file)",
            "        # cleanup rescue volume",
            "        lvm.remove_volumes([lvmdisk for lvmdisk in self._lvm_disks(instance)",
            "                                if lvmdisk.endswith('.rescue')])",
            "",
            "    def poll_rebooting_instances(self, timeout, instances):",
            "        pass",
            "",
            "    # NOTE(ilyaalekseyev): Implementation like in multinics",
            "    # for xenapi(tr3buchet)",
            "    def spawn(self, context, instance, image_meta, injected_files,",
            "              admin_password, network_info=None, block_device_info=None):",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta,",
            "                                            block_device_info)",
            "        self._create_image(context, instance,",
            "                           disk_info['mapping'],",
            "                           network_info=network_info,",
            "                           block_device_info=block_device_info,",
            "                           files=injected_files,",
            "                           admin_pass=admin_password)",
            "        xml = self._get_guest_xml(context, instance, network_info,",
            "                                  disk_info, image_meta,",
            "                                  block_device_info=block_device_info,",
            "                                  write_to_disk=True)",
            "        self._create_domain_and_network(context, xml, instance, network_info,",
            "                                        disk_info,",
            "                                        block_device_info=block_device_info)",
            "        LOG.debug(\"Instance is running\", instance=instance)",
            "",
            "        def _wait_for_boot():",
            "            \"\"\"Called at an interval until the VM is running.\"\"\"",
            "            state = self.get_info(instance).state",
            "",
            "            if state == power_state.RUNNING:",
            "                LOG.info(_LI(\"Instance spawned successfully.\"),",
            "                         instance=instance)",
            "                raise loopingcall.LoopingCallDone()",
            "",
            "        timer = loopingcall.FixedIntervalLoopingCall(_wait_for_boot)",
            "        timer.start(interval=0.5).wait()",
            "",
            "    def _flush_libvirt_console(self, pty):",
            "        out, err = utils.execute('dd',",
            "                                 'if=%s' % pty,",
            "                                 'iflag=nonblock',",
            "                                 run_as_root=True,",
            "                                 check_exit_code=False)",
            "        return out",
            "",
            "    def _append_to_file(self, data, fpath):",
            "        LOG.info(_LI('data: %(data)r, fpath: %(fpath)r'),",
            "                 {'data': data, 'fpath': fpath})",
            "        with open(fpath, 'a+') as fp:",
            "            fp.write(data)",
            "",
            "        return fpath",
            "",
            "    def get_console_output(self, context, instance):",
            "        guest = self._host.get_guest(instance)",
            "",
            "        xml = guest.get_xml_desc()",
            "        tree = etree.fromstring(xml)",
            "",
            "        console_types = {}",
            "",
            "        # NOTE(comstud): We want to try 'file' types first, then try 'pty'",
            "        # types.  We can't use Python 2.7 syntax of:",
            "        # tree.find(\"./devices/console[@type='file']/source\")",
            "        # because we need to support 2.6.",
            "        console_nodes = tree.findall('./devices/console')",
            "        for console_node in console_nodes:",
            "            console_type = console_node.get('type')",
            "            console_types.setdefault(console_type, [])",
            "            console_types[console_type].append(console_node)",
            "",
            "        # If the guest has a console logging to a file prefer to use that",
            "        if console_types.get('file'):",
            "            for file_console in console_types.get('file'):",
            "                source_node = file_console.find('./source')",
            "                if source_node is None:",
            "                    continue",
            "                path = source_node.get(\"path\")",
            "                if not path:",
            "                    continue",
            "",
            "                if not os.path.exists(path):",
            "                    LOG.info(_LI('Instance is configured with a file console, '",
            "                                 'but the backing file is not (yet?) present'),",
            "                             instance=instance)",
            "                    return \"\"",
            "",
            "                libvirt_utils.chown(path, os.getuid())",
            "",
            "                with libvirt_utils.file_open(path, 'rb') as fp:",
            "                    log_data, remaining = utils.last_bytes(fp,",
            "                                                           MAX_CONSOLE_BYTES)",
            "                    if remaining > 0:",
            "                        LOG.info(_LI('Truncated console log returned, '",
            "                                     '%d bytes ignored'), remaining,",
            "                                 instance=instance)",
            "                    return log_data",
            "",
            "        # Try 'pty' types",
            "        if console_types.get('pty'):",
            "            for pty_console in console_types.get('pty'):",
            "                source_node = pty_console.find('./source')",
            "                if source_node is None:",
            "                    continue",
            "                pty = source_node.get(\"path\")",
            "                if not pty:",
            "                    continue",
            "                break",
            "        else:",
            "            msg = _(\"Guest does not have a console available\")",
            "            raise exception.NovaException(msg)",
            "",
            "        self._chown_console_log_for_instance(instance)",
            "        data = self._flush_libvirt_console(pty)",
            "        console_log = self._get_console_log_path(instance)",
            "        fpath = self._append_to_file(data, console_log)",
            "",
            "        with libvirt_utils.file_open(fpath, 'rb') as fp:",
            "            log_data, remaining = utils.last_bytes(fp, MAX_CONSOLE_BYTES)",
            "            if remaining > 0:",
            "                LOG.info(_LI('Truncated console log returned, '",
            "                             '%d bytes ignored'),",
            "                         remaining, instance=instance)",
            "            return log_data",
            "",
            "    def get_host_ip_addr(self):",
            "        ips = compute_utils.get_machine_ips()",
            "        if CONF.my_ip not in ips:",
            "            LOG.warn(_LW('my_ip address (%(my_ip)s) was not found on '",
            "                         'any of the interfaces: %(ifaces)s'),",
            "                     {'my_ip': CONF.my_ip, 'ifaces': \", \".join(ips)})",
            "        return CONF.my_ip",
            "",
            "    def get_vnc_console(self, context, instance):",
            "        def get_vnc_port_for_instance(instance_name):",
            "            guest = self._host.get_guest(instance)",
            "",
            "            xml = guest.get_xml_desc()",
            "            xml_dom = etree.fromstring(xml)",
            "",
            "            graphic = xml_dom.find(\"./devices/graphics[@type='vnc']\")",
            "            if graphic is not None:",
            "                return graphic.get('port')",
            "            # NOTE(rmk): We had VNC consoles enabled but the instance in",
            "            # question is not actually listening for connections.",
            "            raise exception.ConsoleTypeUnavailable(console_type='vnc')",
            "",
            "        port = get_vnc_port_for_instance(instance.name)",
            "        host = CONF.vnc.vncserver_proxyclient_address",
            "",
            "        return ctype.ConsoleVNC(host=host, port=port)",
            "",
            "    def get_spice_console(self, context, instance):",
            "        def get_spice_ports_for_instance(instance_name):",
            "            guest = self._host.get_guest(instance)",
            "",
            "            xml = guest.get_xml_desc()",
            "            xml_dom = etree.fromstring(xml)",
            "",
            "            graphic = xml_dom.find(\"./devices/graphics[@type='spice']\")",
            "            if graphic is not None:",
            "                return (graphic.get('port'), graphic.get('tlsPort'))",
            "            # NOTE(rmk): We had Spice consoles enabled but the instance in",
            "            # question is not actually listening for connections.",
            "            raise exception.ConsoleTypeUnavailable(console_type='spice')",
            "",
            "        ports = get_spice_ports_for_instance(instance.name)",
            "        host = CONF.spice.server_proxyclient_address",
            "",
            "        return ctype.ConsoleSpice(host=host, port=ports[0], tlsPort=ports[1])",
            "",
            "    def get_serial_console(self, context, instance):",
            "        guest = self._host.get_guest(instance)",
            "        for hostname, port in self._get_serial_ports_from_guest(",
            "                guest, mode='bind'):",
            "            return ctype.ConsoleSerial(host=hostname, port=port)",
            "        raise exception.ConsoleTypeUnavailable(console_type='serial')",
            "",
            "    @staticmethod",
            "    def _supports_direct_io(dirpath):",
            "",
            "        if not hasattr(os, 'O_DIRECT'):",
            "            LOG.debug(\"This python runtime does not support direct I/O\")",
            "            return False",
            "",
            "        testfile = os.path.join(dirpath, \".directio.test\")",
            "",
            "        hasDirectIO = True",
            "        try:",
            "            f = os.open(testfile, os.O_CREAT | os.O_WRONLY | os.O_DIRECT)",
            "            # Check is the write allowed with 512 byte alignment",
            "            align_size = 512",
            "            m = mmap.mmap(-1, align_size)",
            "            m.write(r\"x\" * align_size)",
            "            os.write(f, m)",
            "            os.close(f)",
            "            LOG.debug(\"Path '%(path)s' supports direct I/O\",",
            "                      {'path': dirpath})",
            "        except OSError as e:",
            "            if e.errno == errno.EINVAL:",
            "                LOG.debug(\"Path '%(path)s' does not support direct I/O: \"",
            "                          \"'%(ex)s'\", {'path': dirpath, 'ex': e})",
            "                hasDirectIO = False",
            "            else:",
            "                with excutils.save_and_reraise_exception():",
            "                    LOG.error(_LE(\"Error on '%(path)s' while checking \"",
            "                                  \"direct I/O: '%(ex)s'\"),",
            "                              {'path': dirpath, 'ex': e})",
            "        except Exception as e:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.error(_LE(\"Error on '%(path)s' while checking direct I/O: \"",
            "                              \"'%(ex)s'\"), {'path': dirpath, 'ex': e})",
            "        finally:",
            "            try:",
            "                os.unlink(testfile)",
            "            except Exception:",
            "                pass",
            "",
            "        return hasDirectIO",
            "",
            "    @staticmethod",
            "    def _create_ephemeral(target, ephemeral_size,",
            "                          fs_label, os_type, is_block_dev=False,",
            "                          max_size=None, context=None, specified_fs=None):",
            "        if not is_block_dev:",
            "            libvirt_utils.create_image('raw', target, '%dG' % ephemeral_size)",
            "",
            "        # Run as root only for block devices.",
            "        disk.mkfs(os_type, fs_label, target, run_as_root=is_block_dev,",
            "                  specified_fs=specified_fs)",
            "",
            "    @staticmethod",
            "    def _create_swap(target, swap_mb, max_size=None, context=None):",
            "        \"\"\"Create a swap file of specified size.\"\"\"",
            "        libvirt_utils.create_image('raw', target, '%dM' % swap_mb)",
            "        utils.mkfs('swap', target)",
            "",
            "    @staticmethod",
            "    def _get_console_log_path(instance):",
            "        return os.path.join(libvirt_utils.get_instance_path(instance),",
            "                            'console.log')",
            "",
            "    @staticmethod",
            "    def _get_disk_config_path(instance, suffix=''):",
            "        return os.path.join(libvirt_utils.get_instance_path(instance),",
            "                            'disk.config' + suffix)",
            "",
            "    @staticmethod",
            "    def _get_disk_config_image_type():",
            "        # TODO(mikal): there is a bug here if images_type has",
            "        # changed since creation of the instance, but I am pretty",
            "        # sure that this bug already exists.",
            "        return 'rbd' if CONF.libvirt.images_type == 'rbd' else 'raw'",
            "",
            "    def _chown_console_log_for_instance(self, instance):",
            "        console_log = self._get_console_log_path(instance)",
            "        if os.path.exists(console_log):",
            "            libvirt_utils.chown(console_log, os.getuid())",
            "",
            "    def _chown_disk_config_for_instance(self, instance):",
            "        disk_config = self._get_disk_config_path(instance)",
            "        if os.path.exists(disk_config):",
            "            libvirt_utils.chown(disk_config, os.getuid())",
            "",
            "    @staticmethod",
            "    def _is_booted_from_volume(instance, disk_mapping):",
            "        \"\"\"Determines whether the VM is booting from volume",
            "",
            "        Determines whether the disk mapping indicates that the VM",
            "        is booting from a volume.",
            "        \"\"\"",
            "        return ((not bool(instance.get('image_ref')))",
            "                or 'disk' not in disk_mapping)",
            "",
            "    @staticmethod",
            "    def _has_local_disk(instance, disk_mapping):",
            "        \"\"\"Determines whether the VM has a local disk",
            "",
            "        Determines whether the disk mapping indicates that the VM",
            "        has a local disk (e.g. ephemeral, swap disk and config-drive).",
            "        \"\"\"",
            "        if disk_mapping:",
            "            if ('disk.local' in disk_mapping or",
            "                'disk.swap' in disk_mapping or",
            "                'disk.config' in disk_mapping):",
            "                return True",
            "        return False",
            "",
            "    def _inject_data(self, instance, network_info, admin_pass, files, suffix):",
            "        \"\"\"Injects data in a disk image",
            "",
            "        Helper used for injecting data in a disk image file system.",
            "",
            "        Keyword arguments:",
            "          instance -- a dict that refers instance specifications",
            "          network_info -- a dict that refers network speficications",
            "          admin_pass -- a string used to set an admin password",
            "          files -- a list of files needs to be injected",
            "          suffix -- a string used as an image name suffix",
            "        \"\"\"",
            "        # Handles the partition need to be used.",
            "        target_partition = None",
            "        if not instance.kernel_id:",
            "            target_partition = CONF.libvirt.inject_partition",
            "            if target_partition == 0:",
            "                target_partition = None",
            "        if CONF.libvirt.virt_type == 'lxc':",
            "            target_partition = None",
            "",
            "        # Handles the key injection.",
            "        if CONF.libvirt.inject_key and instance.get('key_data'):",
            "            key = str(instance.key_data)",
            "        else:",
            "            key = None",
            "",
            "        # Handles the admin password injection.",
            "        if not CONF.libvirt.inject_password:",
            "            admin_pass = None",
            "",
            "        # Handles the network injection.",
            "        net = netutils.get_injected_network_template(",
            "                network_info, libvirt_virt_type=CONF.libvirt.virt_type)",
            "",
            "        # Handles the metadata injection",
            "        metadata = instance.get('metadata')",
            "",
            "        image_type = CONF.libvirt.images_type",
            "        if any((key, net, metadata, admin_pass, files)):",
            "            injection_image = self.image_backend.image(",
            "                instance,",
            "                'disk' + suffix,",
            "                image_type)",
            "            img_id = instance.image_ref",
            "",
            "            if not injection_image.check_image_exists():",
            "                LOG.warn(_LW('Image %s not found on disk storage. '",
            "                         'Continue without injecting data'),",
            "                         injection_image.path, instance=instance)",
            "                return",
            "            try:",
            "                disk.inject_data(injection_image.get_model(self._conn),",
            "                                 key, net, metadata, admin_pass, files,",
            "                                 partition=target_partition,",
            "                                 mandatory=('files',))",
            "            except Exception as e:",
            "                with excutils.save_and_reraise_exception():",
            "                    LOG.error(_LE('Error injecting data into image '",
            "                                  '%(img_id)s (%(e)s)'),",
            "                              {'img_id': img_id, 'e': e},",
            "                              instance=instance)",
            "",
            "    # NOTE(sileht): many callers of this method assume that this",
            "    # method doesn't fail if an image already exists but instead",
            "    # think that it will be reused (ie: (live)-migration/resize)",
            "    def _create_image(self, context, instance,",
            "                      disk_mapping, suffix='',",
            "                      disk_images=None, network_info=None,",
            "                      block_device_info=None, files=None,",
            "                      admin_pass=None, inject_files=True,",
            "                      fallback_from_host=None):",
            "        booted_from_volume = self._is_booted_from_volume(",
            "            instance, disk_mapping)",
            "",
            "        def image(fname, image_type=CONF.libvirt.images_type):",
            "            return self.image_backend.image(instance,",
            "                                            fname + suffix, image_type)",
            "",
            "        def raw(fname):",
            "            return image(fname, image_type='raw')",
            "",
            "        # ensure directories exist and are writable",
            "        fileutils.ensure_tree(libvirt_utils.get_instance_path(instance))",
            "",
            "        LOG.info(_LI('Creating image'), instance=instance)",
            "",
            "        # NOTE(dprince): for rescue console.log may already exist... chown it.",
            "        self._chown_console_log_for_instance(instance)",
            "",
            "        # NOTE(yaguang): For evacuate disk.config already exist in shared",
            "        # storage, chown it.",
            "        self._chown_disk_config_for_instance(instance)",
            "",
            "        # NOTE(vish): No need add the suffix to console.log",
            "        libvirt_utils.write_to_file(",
            "            self._get_console_log_path(instance), '', 7)",
            "",
            "        if not disk_images:",
            "            disk_images = {'image_id': instance.image_ref,",
            "                           'kernel_id': instance.kernel_id,",
            "                           'ramdisk_id': instance.ramdisk_id}",
            "",
            "        if disk_images['kernel_id']:",
            "            fname = imagecache.get_cache_fname(disk_images, 'kernel_id')",
            "            raw('kernel').cache(fetch_func=libvirt_utils.fetch_raw_image,",
            "                                context=context,",
            "                                filename=fname,",
            "                                image_id=disk_images['kernel_id'],",
            "                                user_id=instance.user_id,",
            "                                project_id=instance.project_id)",
            "            if disk_images['ramdisk_id']:",
            "                fname = imagecache.get_cache_fname(disk_images, 'ramdisk_id')",
            "                raw('ramdisk').cache(fetch_func=libvirt_utils.fetch_raw_image,",
            "                                     context=context,",
            "                                     filename=fname,",
            "                                     image_id=disk_images['ramdisk_id'],",
            "                                     user_id=instance.user_id,",
            "                                     project_id=instance.project_id)",
            "",
            "        inst_type = instance.get_flavor()",
            "",
            "        # NOTE(ndipanov): Even if disk_mapping was passed in, which",
            "        # currently happens only on rescue - we still don't want to",
            "        # create a base image.",
            "        if not booted_from_volume:",
            "            root_fname = imagecache.get_cache_fname(disk_images, 'image_id')",
            "            size = instance.root_gb * units.Gi",
            "",
            "            if size == 0 or suffix == '.rescue':",
            "                size = None",
            "",
            "            backend = image('disk')",
            "            if instance.task_state == task_states.RESIZE_FINISH:",
            "                backend.create_snap(libvirt_utils.RESIZE_SNAPSHOT_NAME)",
            "            if backend.SUPPORTS_CLONE:",
            "                def clone_fallback_to_fetch(*args, **kwargs):",
            "                    try:",
            "                        backend.clone(context, disk_images['image_id'])",
            "                    except exception.ImageUnacceptable:",
            "                        libvirt_utils.fetch_image(*args, **kwargs)",
            "                fetch_func = clone_fallback_to_fetch",
            "            else:",
            "                fetch_func = libvirt_utils.fetch_image",
            "            self._try_fetch_image_cache(backend, fetch_func, context,",
            "                                        root_fname, disk_images['image_id'],",
            "                                        instance, size, fallback_from_host)",
            "",
            "        # Lookup the filesystem type if required",
            "        os_type_with_default = disk.get_fs_type_for_os_type(instance.os_type)",
            "        # Generate a file extension based on the file system",
            "        # type and the mkfs commands configured if any",
            "        file_extension = disk.get_file_extension_for_os_type(",
            "                                                          os_type_with_default)",
            "",
            "        ephemeral_gb = instance.ephemeral_gb",
            "        if 'disk.local' in disk_mapping:",
            "            disk_image = image('disk.local')",
            "            fn = functools.partial(self._create_ephemeral,",
            "                                   fs_label='ephemeral0',",
            "                                   os_type=instance.os_type,",
            "                                   is_block_dev=disk_image.is_block_dev)",
            "            fname = \"ephemeral_%s_%s\" % (ephemeral_gb, file_extension)",
            "            size = ephemeral_gb * units.Gi",
            "            disk_image.cache(fetch_func=fn,",
            "                             context=context,",
            "                             filename=fname,",
            "                             size=size,",
            "                             ephemeral_size=ephemeral_gb)",
            "",
            "        for idx, eph in enumerate(driver.block_device_info_get_ephemerals(",
            "                block_device_info)):",
            "            disk_image = image(blockinfo.get_eph_disk(idx))",
            "",
            "            specified_fs = eph.get('guest_format')",
            "            if specified_fs and not self.is_supported_fs_format(specified_fs):",
            "                msg = _(\"%s format is not supported\") % specified_fs",
            "                raise exception.InvalidBDMFormat(details=msg)",
            "",
            "            fn = functools.partial(self._create_ephemeral,",
            "                                   fs_label='ephemeral%d' % idx,",
            "                                   os_type=instance.os_type,",
            "                                   is_block_dev=disk_image.is_block_dev)",
            "            size = eph['size'] * units.Gi",
            "            fname = \"ephemeral_%s_%s\" % (eph['size'], file_extension)",
            "            disk_image.cache(fetch_func=fn,",
            "                             context=context,",
            "                             filename=fname,",
            "                             size=size,",
            "                             ephemeral_size=eph['size'],",
            "                             specified_fs=specified_fs)",
            "",
            "        if 'disk.swap' in disk_mapping:",
            "            mapping = disk_mapping['disk.swap']",
            "            swap_mb = 0",
            "",
            "            swap = driver.block_device_info_get_swap(block_device_info)",
            "            if driver.swap_is_usable(swap):",
            "                swap_mb = swap['swap_size']",
            "            elif (inst_type['swap'] > 0 and",
            "                  not block_device.volume_in_mapping(",
            "                    mapping['dev'], block_device_info)):",
            "                swap_mb = inst_type['swap']",
            "",
            "            if swap_mb > 0:",
            "                size = swap_mb * units.Mi",
            "                image('disk.swap').cache(fetch_func=self._create_swap,",
            "                                         context=context,",
            "                                         filename=\"swap_%s\" % swap_mb,",
            "                                         size=size,",
            "                                         swap_mb=swap_mb)",
            "",
            "        # Config drive",
            "        if configdrive.required_by(instance):",
            "            LOG.info(_LI('Using config drive'), instance=instance)",
            "            extra_md = {}",
            "            if admin_pass:",
            "                extra_md['admin_pass'] = admin_pass",
            "",
            "            inst_md = instance_metadata.InstanceMetadata(instance,",
            "                content=files, extra_md=extra_md, network_info=network_info)",
            "            with configdrive.ConfigDriveBuilder(instance_md=inst_md) as cdb:",
            "                configdrive_path = self._get_disk_config_path(instance, suffix)",
            "                LOG.info(_LI('Creating config drive at %(path)s'),",
            "                         {'path': configdrive_path}, instance=instance)",
            "",
            "                try:",
            "                    cdb.make_drive(configdrive_path)",
            "                except processutils.ProcessExecutionError as e:",
            "                    with excutils.save_and_reraise_exception():",
            "                        LOG.error(_LE('Creating config drive failed '",
            "                                      'with error: %s'),",
            "                                  e, instance=instance)",
            "",
            "            try:",
            "                # Tell the storage backend about the config drive",
            "                config_drive_image = self.image_backend.image(",
            "                    instance, 'disk.config' + suffix,",
            "                    self._get_disk_config_image_type())",
            "",
            "                config_drive_image.import_file(",
            "                    instance, configdrive_path, 'disk.config' + suffix)",
            "            finally:",
            "                # NOTE(mikal): if the config drive was imported into RBD, then",
            "                # we no longer need the local copy",
            "                if CONF.libvirt.images_type == 'rbd':",
            "                    os.unlink(configdrive_path)",
            "",
            "        # File injection only if needed",
            "        elif inject_files and CONF.libvirt.inject_partition != -2:",
            "            if booted_from_volume:",
            "                LOG.warn(_LW('File injection into a boot from volume '",
            "                             'instance is not supported'), instance=instance)",
            "            self._inject_data(",
            "                instance, network_info, admin_pass, files, suffix)",
            "",
            "        if CONF.libvirt.virt_type == 'uml':",
            "            libvirt_utils.chown(image('disk').path, 'root')",
            "",
            "    def _prepare_pci_devices_for_use(self, pci_devices):",
            "        # kvm , qemu support managed mode",
            "        # In managed mode, the configured device will be automatically",
            "        # detached from the host OS drivers when the guest is started,",
            "        # and then re-attached when the guest shuts down.",
            "        if CONF.libvirt.virt_type != 'xen':",
            "            # we do manual detach only for xen",
            "            return",
            "        try:",
            "            for dev in pci_devices:",
            "                libvirt_dev_addr = dev['hypervisor_name']",
            "                libvirt_dev = \\",
            "                        self._host.device_lookup_by_name(libvirt_dev_addr)",
            "                # Note(yjiang5) Spelling for 'dettach' is correct, see",
            "                # http://libvirt.org/html/libvirt-libvirt.html.",
            "                libvirt_dev.dettach()",
            "",
            "            # Note(yjiang5): A reset of one PCI device may impact other",
            "            # devices on the same bus, thus we need two separated loops",
            "            # to detach and then reset it.",
            "            for dev in pci_devices:",
            "                libvirt_dev_addr = dev['hypervisor_name']",
            "                libvirt_dev = \\",
            "                        self._host.device_lookup_by_name(libvirt_dev_addr)",
            "                libvirt_dev.reset()",
            "",
            "        except libvirt.libvirtError as exc:",
            "            raise exception.PciDevicePrepareFailed(id=dev['id'],",
            "                                                   instance_uuid=",
            "                                                   dev['instance_uuid'],",
            "                                                   reason=six.text_type(exc))",
            "",
            "    def _detach_pci_devices(self, guest, pci_devs):",
            "",
            "        # for libvirt version < 1.1.1, this is race condition",
            "        # so forbid detach if not had this version",
            "        if not self._host.has_min_version(MIN_LIBVIRT_DEVICE_CALLBACK_VERSION):",
            "            if pci_devs:",
            "                reason = (_(\"Detaching PCI devices with libvirt < %(ver)s\"",
            "                           \" is not permitted\") %",
            "                           {'ver': MIN_LIBVIRT_DEVICE_CALLBACK_VERSION})",
            "                raise exception.PciDeviceDetachFailed(reason=reason,",
            "                                                      dev=pci_devs)",
            "        try:",
            "            for dev in pci_devs:",
            "                guest.detach_device(self._get_guest_pci_device(dev), live=True)",
            "                # after detachDeviceFlags returned, we should check the dom to",
            "                # ensure the detaching is finished",
            "                xml = guest.get_xml_desc()",
            "                xml_doc = etree.fromstring(xml)",
            "                guest_config = vconfig.LibvirtConfigGuest()",
            "                guest_config.parse_dom(xml_doc)",
            "",
            "                for hdev in [d for d in guest_config.devices",
            "                    if isinstance(d, vconfig.LibvirtConfigGuestHostdevPCI)]:",
            "                    hdbsf = [hdev.domain, hdev.bus, hdev.slot, hdev.function]",
            "                    dbsf = pci_utils.parse_address(dev['address'])",
            "                    if [int(x, 16) for x in hdbsf] ==\\",
            "                            [int(x, 16) for x in dbsf]:",
            "                        raise exception.PciDeviceDetachFailed(reason=",
            "                                                              \"timeout\",",
            "                                                              dev=dev)",
            "",
            "        except libvirt.libvirtError as ex:",
            "            error_code = ex.get_error_code()",
            "            if error_code == libvirt.VIR_ERR_NO_DOMAIN:",
            "                LOG.warn(_LW(\"Instance disappeared while detaching \"",
            "                             \"a PCI device from it.\"))",
            "            else:",
            "                raise",
            "",
            "    def _attach_pci_devices(self, guest, pci_devs):",
            "        try:",
            "            for dev in pci_devs:",
            "                guest.attach_device(self._get_guest_pci_device(dev))",
            "",
            "        except libvirt.libvirtError:",
            "            LOG.error(_LE('Attaching PCI devices %(dev)s to %(dom)s failed.'),",
            "                      {'dev': pci_devs, 'dom': guest.id})",
            "            raise",
            "",
            "    @staticmethod",
            "    def _has_sriov_port(network_info):",
            "        for vif in network_info:",
            "            if vif['vnic_type'] == network_model.VNIC_TYPE_DIRECT:",
            "                return True",
            "        return False",
            "",
            "    def _attach_sriov_ports(self, context, instance, guest, network_info=None):",
            "        if network_info is None:",
            "            network_info = instance.info_cache.network_info",
            "        if network_info is None:",
            "            return",
            "",
            "        if self._has_sriov_port(network_info):",
            "            for vif in network_info:",
            "                if vif['vnic_type'] in network_model.VNIC_TYPES_SRIOV:",
            "                    cfg = self.vif_driver.get_config(instance,",
            "                                                     vif,",
            "                                                     instance.image_meta,",
            "                                                     instance.flavor,",
            "                                                     CONF.libvirt.virt_type,",
            "                                                     self._host)",
            "                    LOG.debug('Attaching SR-IOV port %(port)s to %(dom)s',",
            "                              {'port': vif, 'dom': guest.id},",
            "                              instance=instance)",
            "                    guest.attach_device(cfg)",
            "",
            "    def _detach_sriov_ports(self, context, instance, guest):",
            "        network_info = instance.info_cache.network_info",
            "        if network_info is None:",
            "            return",
            "",
            "        if self._has_sriov_port(network_info):",
            "            # for libvirt version < 1.1.1, this is race condition",
            "            # so forbid detach if it's an older version",
            "            if not self._host.has_min_version(",
            "                            MIN_LIBVIRT_DEVICE_CALLBACK_VERSION):",
            "                reason = (_(\"Detaching SR-IOV ports with\"",
            "                           \" libvirt < %(ver)s is not permitted\") %",
            "                           {'ver': MIN_LIBVIRT_DEVICE_CALLBACK_VERSION})",
            "                raise exception.PciDeviceDetachFailed(reason=reason,",
            "                                                      dev=network_info)",
            "",
            "            image_meta = objects.ImageMeta.from_instance(instance)",
            "            sriov_pci_addresses = [",
            "                self.vif_driver.get_config(instance,",
            "                                           vif,",
            "                                           image_meta,",
            "                                           instance.flavor,",
            "                                           CONF.libvirt.virt_type,",
            "                                           self._host).source_dev",
            "                for vif in network_info",
            "                if vif['vnic_type'] in network_model.VNIC_TYPES_SRIOV",
            "            ]",
            "",
            "            # use detach_pci_devices to avoid failure in case of",
            "            # multiple guest SRIOV ports with the same MAC",
            "            # (protection use-case, ports are on different physical",
            "            # interfaces)",
            "            pci_devs = pci_manager.get_instance_pci_devs(instance, 'all')",
            "            sriov_devs = [pci_dev for pci_dev in pci_devs",
            "                          if pci_dev.address in sriov_pci_addresses]",
            "            self._detach_pci_devices(guest, sriov_devs)",
            "",
            "    def _set_host_enabled(self, enabled,",
            "                          disable_reason=DISABLE_REASON_UNDEFINED):",
            "        \"\"\"Enables / Disables the compute service on this host.",
            "",
            "           This doesn't override non-automatic disablement with an automatic",
            "           setting; thereby permitting operators to keep otherwise",
            "           healthy hosts out of rotation.",
            "        \"\"\"",
            "",
            "        status_name = {True: 'disabled',",
            "                       False: 'enabled'}",
            "",
            "        disable_service = not enabled",
            "",
            "        ctx = nova_context.get_admin_context()",
            "        try:",
            "            service = objects.Service.get_by_compute_host(ctx, CONF.host)",
            "",
            "            if service.disabled != disable_service:",
            "                # Note(jang): this is a quick fix to stop operator-",
            "                # disabled compute hosts from re-enabling themselves",
            "                # automatically. We prefix any automatic reason code",
            "                # with a fixed string. We only re-enable a host",
            "                # automatically if we find that string in place.",
            "                # This should probably be replaced with a separate flag.",
            "                if not service.disabled or (",
            "                        service.disabled_reason and",
            "                        service.disabled_reason.startswith(DISABLE_PREFIX)):",
            "                    service.disabled = disable_service",
            "                    service.disabled_reason = (",
            "                       DISABLE_PREFIX + disable_reason",
            "                       if disable_service else DISABLE_REASON_UNDEFINED)",
            "                    service.save()",
            "                    LOG.debug('Updating compute service status to %s',",
            "                              status_name[disable_service])",
            "                else:",
            "                    LOG.debug('Not overriding manual compute service '",
            "                              'status with: %s',",
            "                              status_name[disable_service])",
            "        except exception.ComputeHostNotFound:",
            "            LOG.warn(_LW('Cannot update service status on host \"%s\" '",
            "                         'since it is not registered.'), CONF.host)",
            "        except Exception:",
            "            LOG.warn(_LW('Cannot update service status on host \"%s\" '",
            "                         'due to an unexpected exception.'), CONF.host,",
            "                     exc_info=True)",
            "",
            "    def _get_guest_cpu_model_config(self):",
            "        mode = CONF.libvirt.cpu_mode",
            "        model = CONF.libvirt.cpu_model",
            "",
            "        if (CONF.libvirt.virt_type == \"kvm\" or",
            "            CONF.libvirt.virt_type == \"qemu\"):",
            "            if mode is None:",
            "                mode = \"host-model\"",
            "            if mode == \"none\":",
            "                return vconfig.LibvirtConfigGuestCPU()",
            "        else:",
            "            if mode is None or mode == \"none\":",
            "                return None",
            "",
            "        if ((CONF.libvirt.virt_type != \"kvm\" and",
            "             CONF.libvirt.virt_type != \"qemu\")):",
            "            msg = _(\"Config requested an explicit CPU model, but \"",
            "                    \"the current libvirt hypervisor '%s' does not \"",
            "                    \"support selecting CPU models\") % CONF.libvirt.virt_type",
            "            raise exception.Invalid(msg)",
            "",
            "        if mode == \"custom\" and model is None:",
            "            msg = _(\"Config requested a custom CPU model, but no \"",
            "                    \"model name was provided\")",
            "            raise exception.Invalid(msg)",
            "        elif mode != \"custom\" and model is not None:",
            "            msg = _(\"A CPU model name should not be set when a \"",
            "                    \"host CPU model is requested\")",
            "            raise exception.Invalid(msg)",
            "",
            "        LOG.debug(\"CPU mode '%(mode)s' model '%(model)s' was chosen\",",
            "                  {'mode': mode, 'model': (model or \"\")})",
            "",
            "        cpu = vconfig.LibvirtConfigGuestCPU()",
            "        cpu.mode = mode",
            "        cpu.model = model",
            "",
            "        return cpu",
            "",
            "    def _get_guest_cpu_config(self, flavor, image_meta,",
            "                              guest_cpu_numa_config, instance_numa_topology):",
            "        cpu = self._get_guest_cpu_model_config()",
            "",
            "        if cpu is None:",
            "            return None",
            "",
            "        topology = hardware.get_best_cpu_topology(",
            "                flavor, image_meta, numa_topology=instance_numa_topology)",
            "",
            "        cpu.sockets = topology.sockets",
            "        cpu.cores = topology.cores",
            "        cpu.threads = topology.threads",
            "        cpu.numa = guest_cpu_numa_config",
            "",
            "        return cpu",
            "",
            "    def _get_guest_disk_config(self, instance, name, disk_mapping, inst_type,",
            "                               image_type=None):",
            "        if CONF.libvirt.hw_disk_discard:",
            "            if not self._host.has_min_version(MIN_LIBVIRT_DISCARD_VERSION,",
            "                                              MIN_QEMU_DISCARD_VERSION,",
            "                                              host.HV_DRIVER_QEMU):",
            "                msg = (_('Volume sets discard option, but libvirt %(libvirt)s'",
            "                         ' or later is required, qemu %(qemu)s'",
            "                         ' or later is required.') %",
            "                      {'libvirt': MIN_LIBVIRT_DISCARD_VERSION,",
            "                       'qemu': MIN_QEMU_DISCARD_VERSION})",
            "                raise exception.Invalid(msg)",
            "",
            "        image = self.image_backend.image(instance,",
            "                                         name,",
            "                                         image_type)",
            "        disk_info = disk_mapping[name]",
            "        return image.libvirt_info(disk_info['bus'],",
            "                                  disk_info['dev'],",
            "                                  disk_info['type'],",
            "                                  self.disk_cachemode,",
            "                                  inst_type['extra_specs'],",
            "                                  self._host.get_version())",
            "",
            "    def _get_guest_fs_config(self, instance, name, image_type=None):",
            "        image = self.image_backend.image(instance,",
            "                                         name,",
            "                                         image_type)",
            "        return image.libvirt_fs_info(\"/\", \"ploop\")",
            "",
            "    def _get_guest_storage_config(self, instance, image_meta,",
            "                                  disk_info,",
            "                                  rescue, block_device_info,",
            "                                  inst_type, os_type):",
            "        devices = []",
            "        disk_mapping = disk_info['mapping']",
            "",
            "        block_device_mapping = driver.block_device_info_get_mapping(",
            "            block_device_info)",
            "        mount_rootfs = CONF.libvirt.virt_type == \"lxc\"",
            "        if mount_rootfs:",
            "            fs = vconfig.LibvirtConfigGuestFilesys()",
            "            fs.source_type = \"mount\"",
            "            fs.source_dir = os.path.join(",
            "                libvirt_utils.get_instance_path(instance), 'rootfs')",
            "            devices.append(fs)",
            "        elif os_type == vm_mode.EXE and CONF.libvirt.virt_type == \"parallels\":",
            "            if 'disk' in disk_mapping:",
            "                fs = self._get_guest_fs_config(instance, \"disk\")",
            "                devices.append(fs)",
            "        else:",
            "",
            "            if rescue:",
            "                diskrescue = self._get_guest_disk_config(instance,",
            "                                                         'disk.rescue',",
            "                                                         disk_mapping,",
            "                                                         inst_type)",
            "                devices.append(diskrescue)",
            "",
            "                diskos = self._get_guest_disk_config(instance,",
            "                                                     'disk',",
            "                                                     disk_mapping,",
            "                                                     inst_type)",
            "                devices.append(diskos)",
            "            else:",
            "                if 'disk' in disk_mapping:",
            "                    diskos = self._get_guest_disk_config(instance,",
            "                                                         'disk',",
            "                                                         disk_mapping,",
            "                                                         inst_type)",
            "                    devices.append(diskos)",
            "",
            "                if 'disk.local' in disk_mapping:",
            "                    disklocal = self._get_guest_disk_config(instance,",
            "                                                            'disk.local',",
            "                                                            disk_mapping,",
            "                                                            inst_type)",
            "                    devices.append(disklocal)",
            "                    instance.default_ephemeral_device = (",
            "                        block_device.prepend_dev(disklocal.target_dev))",
            "",
            "                for idx, eph in enumerate(",
            "                    driver.block_device_info_get_ephemerals(",
            "                        block_device_info)):",
            "                    diskeph = self._get_guest_disk_config(",
            "                        instance,",
            "                        blockinfo.get_eph_disk(idx),",
            "                        disk_mapping, inst_type)",
            "                    devices.append(diskeph)",
            "",
            "                if 'disk.swap' in disk_mapping:",
            "                    diskswap = self._get_guest_disk_config(instance,",
            "                                                           'disk.swap',",
            "                                                           disk_mapping,",
            "                                                           inst_type)",
            "                    devices.append(diskswap)",
            "                    instance.default_swap_device = (",
            "                        block_device.prepend_dev(diskswap.target_dev))",
            "",
            "            if 'disk.config' in disk_mapping:",
            "                diskconfig = self._get_guest_disk_config(",
            "                    instance, 'disk.config', disk_mapping, inst_type,",
            "                    self._get_disk_config_image_type())",
            "                devices.append(diskconfig)",
            "",
            "        for vol in block_device.get_bdms_to_connect(block_device_mapping,",
            "                                                   mount_rootfs):",
            "            connection_info = vol['connection_info']",
            "            vol_dev = block_device.prepend_dev(vol['mount_device'])",
            "            info = disk_mapping[vol_dev]",
            "            self._connect_volume(connection_info, info)",
            "            cfg = self._get_volume_config(connection_info, info)",
            "            devices.append(cfg)",
            "            vol['connection_info'] = connection_info",
            "            vol.save()",
            "",
            "        for d in devices:",
            "            self._set_cache_mode(d)",
            "",
            "        if image_meta.properties.get('hw_scsi_model'):",
            "            hw_scsi_model = image_meta.properties.hw_scsi_model",
            "            scsi_controller = vconfig.LibvirtConfigGuestController()",
            "            scsi_controller.type = 'scsi'",
            "            scsi_controller.model = hw_scsi_model",
            "            devices.append(scsi_controller)",
            "",
            "        return devices",
            "",
            "    def _get_host_sysinfo_serial_hardware(self):",
            "        \"\"\"Get a UUID from the host hardware",
            "",
            "        Get a UUID for the host hardware reported by libvirt.",
            "        This is typically from the SMBIOS data, unless it has",
            "        been overridden in /etc/libvirt/libvirtd.conf",
            "        \"\"\"",
            "        caps = self._host.get_capabilities()",
            "        return caps.host.uuid",
            "",
            "    def _get_host_sysinfo_serial_os(self):",
            "        \"\"\"Get a UUID from the host operating system",
            "",
            "        Get a UUID for the host operating system. Modern Linux",
            "        distros based on systemd provide a /etc/machine-id",
            "        file containing a UUID. This is also provided inside",
            "        systemd based containers and can be provided by other",
            "        init systems too, since it is just a plain text file.",
            "        \"\"\"",
            "        if not os.path.exists(\"/etc/machine-id\"):",
            "            msg = _(\"Unable to get host UUID: /etc/machine-id does not exist\")",
            "            raise exception.NovaException(msg)",
            "",
            "        with open(\"/etc/machine-id\") as f:",
            "            # We want to have '-' in the right place",
            "            # so we parse & reformat the value",
            "            lines = f.read().split()",
            "            if not lines:",
            "                msg = _(\"Unable to get host UUID: /etc/machine-id is empty\")",
            "                raise exception.NovaException(msg)",
            "",
            "            return str(uuid.UUID(lines[0]))",
            "",
            "    def _get_host_sysinfo_serial_auto(self):",
            "        if os.path.exists(\"/etc/machine-id\"):",
            "            return self._get_host_sysinfo_serial_os()",
            "        else:",
            "            return self._get_host_sysinfo_serial_hardware()",
            "",
            "    def _get_guest_config_sysinfo(self, instance):",
            "        sysinfo = vconfig.LibvirtConfigGuestSysinfo()",
            "",
            "        sysinfo.system_manufacturer = version.vendor_string()",
            "        sysinfo.system_product = version.product_string()",
            "        sysinfo.system_version = version.version_string_with_package()",
            "",
            "        sysinfo.system_serial = self._sysinfo_serial_func()",
            "        sysinfo.system_uuid = instance.uuid",
            "",
            "        sysinfo.system_family = \"Virtual Machine\"",
            "",
            "        return sysinfo",
            "",
            "    def _get_guest_pci_device(self, pci_device):",
            "",
            "        dbsf = pci_utils.parse_address(pci_device.address)",
            "        dev = vconfig.LibvirtConfigGuestHostdevPCI()",
            "        dev.domain, dev.bus, dev.slot, dev.function = dbsf",
            "",
            "        # only kvm support managed mode",
            "        if CONF.libvirt.virt_type in ('xen', 'parallels',):",
            "            dev.managed = 'no'",
            "        if CONF.libvirt.virt_type in ('kvm', 'qemu'):",
            "            dev.managed = 'yes'",
            "",
            "        return dev",
            "",
            "    def _get_guest_config_meta(self, context, instance):",
            "        \"\"\"Get metadata config for guest.\"\"\"",
            "",
            "        meta = vconfig.LibvirtConfigGuestMetaNovaInstance()",
            "        meta.package = version.version_string_with_package()",
            "        meta.name = instance.display_name",
            "        meta.creationTime = time.time()",
            "",
            "        if instance.image_ref not in (\"\", None):",
            "            meta.roottype = \"image\"",
            "            meta.rootid = instance.image_ref",
            "",
            "        if context is not None:",
            "            ometa = vconfig.LibvirtConfigGuestMetaNovaOwner()",
            "            ometa.userid = context.user_id",
            "            ometa.username = context.user_name",
            "            ometa.projectid = context.project_id",
            "            ometa.projectname = context.project_name",
            "            meta.owner = ometa",
            "",
            "        fmeta = vconfig.LibvirtConfigGuestMetaNovaFlavor()",
            "        flavor = instance.flavor",
            "        fmeta.name = flavor.name",
            "        fmeta.memory = flavor.memory_mb",
            "        fmeta.vcpus = flavor.vcpus",
            "        fmeta.ephemeral = flavor.ephemeral_gb",
            "        fmeta.disk = flavor.root_gb",
            "        fmeta.swap = flavor.swap",
            "",
            "        meta.flavor = fmeta",
            "",
            "        return meta",
            "",
            "    def _machine_type_mappings(self):",
            "        mappings = {}",
            "        for mapping in CONF.libvirt.hw_machine_type:",
            "            host_arch, _, machine_type = mapping.partition('=')",
            "            mappings[host_arch] = machine_type",
            "        return mappings",
            "",
            "    def _get_machine_type(self, image_meta, caps):",
            "        # The underlying machine type can be set as an image attribute,",
            "        # or otherwise based on some architecture specific defaults",
            "",
            "        mach_type = None",
            "",
            "        if image_meta.properties.get('hw_machine_type') is not None:",
            "            mach_type = image_meta.properties.hw_machine_type",
            "        else:",
            "            # For ARM systems we will default to vexpress-a15 for armv7",
            "            # and virt for aarch64",
            "            if caps.host.cpu.arch == arch.ARMV7:",
            "                mach_type = \"vexpress-a15\"",
            "",
            "            if caps.host.cpu.arch == arch.AARCH64:",
            "                mach_type = \"virt\"",
            "",
            "            if caps.host.cpu.arch in (arch.S390, arch.S390X):",
            "                mach_type = 's390-ccw-virtio'",
            "",
            "            # If set in the config, use that as the default.",
            "            if CONF.libvirt.hw_machine_type:",
            "                mappings = self._machine_type_mappings()",
            "                mach_type = mappings.get(caps.host.cpu.arch)",
            "",
            "        return mach_type",
            "",
            "    @staticmethod",
            "    def _create_idmaps(klass, map_strings):",
            "        idmaps = []",
            "        if len(map_strings) > 5:",
            "            map_strings = map_strings[0:5]",
            "            LOG.warn(_LW(\"Too many id maps, only included first five.\"))",
            "        for map_string in map_strings:",
            "            try:",
            "                idmap = klass()",
            "                values = [int(i) for i in map_string.split(\":\")]",
            "                idmap.start = values[0]",
            "                idmap.target = values[1]",
            "                idmap.count = values[2]",
            "                idmaps.append(idmap)",
            "            except (ValueError, IndexError):",
            "                LOG.warn(_LW(\"Invalid value for id mapping %s\"), map_string)",
            "        return idmaps",
            "",
            "    def _get_guest_idmaps(self):",
            "        id_maps = []",
            "        if CONF.libvirt.virt_type == 'lxc' and CONF.libvirt.uid_maps:",
            "            uid_maps = self._create_idmaps(vconfig.LibvirtConfigGuestUIDMap,",
            "                                           CONF.libvirt.uid_maps)",
            "            id_maps.extend(uid_maps)",
            "        if CONF.libvirt.virt_type == 'lxc' and CONF.libvirt.gid_maps:",
            "            gid_maps = self._create_idmaps(vconfig.LibvirtConfigGuestGIDMap,",
            "                                           CONF.libvirt.gid_maps)",
            "            id_maps.extend(gid_maps)",
            "        return id_maps",
            "",
            "    def _update_guest_cputune(self, guest, flavor, virt_type):",
            "        is_able = self._host.is_cpu_control_policy_capable()",
            "",
            "        cputuning = ['shares', 'period', 'quota']",
            "        wants_cputune = any([k for k in cputuning",
            "            if \"quota:cpu_\" + k in flavor.extra_specs.keys()])",
            "",
            "        if wants_cputune and not is_able:",
            "            raise exception.UnsupportedHostCPUControlPolicy()",
            "",
            "        if not is_able or virt_type not in ('lxc', 'kvm', 'qemu'):",
            "            return",
            "",
            "        if guest.cputune is None:",
            "            guest.cputune = vconfig.LibvirtConfigGuestCPUTune()",
            "            # Setting the default cpu.shares value to be a value",
            "            # dependent on the number of vcpus",
            "        guest.cputune.shares = 1024 * guest.vcpus",
            "",
            "        for name in cputuning:",
            "            key = \"quota:cpu_\" + name",
            "            if key in flavor.extra_specs:",
            "                setattr(guest.cputune, name,",
            "                        int(flavor.extra_specs[key]))",
            "",
            "    def _get_cpu_numa_config_from_instance(self, instance_numa_topology,",
            "                                           wants_hugepages):",
            "        if instance_numa_topology:",
            "            guest_cpu_numa = vconfig.LibvirtConfigGuestCPUNUMA()",
            "            for instance_cell in instance_numa_topology.cells:",
            "                guest_cell = vconfig.LibvirtConfigGuestCPUNUMACell()",
            "                guest_cell.id = instance_cell.id",
            "                guest_cell.cpus = instance_cell.cpuset",
            "                guest_cell.memory = instance_cell.memory * units.Ki",
            "",
            "                # The vhost-user network backend requires file backed",
            "                # guest memory (ie huge pages) to be marked as shared",
            "                # access, not private, so an external process can read",
            "                # and write the pages.",
            "                #",
            "                # You can't change the shared vs private flag for an",
            "                # already running guest, and since we can't predict what",
            "                # types of NIC may be hotplugged, we have no choice but",
            "                # to unconditionally turn on the shared flag. This has",
            "                # no real negative functional effect on the guest, so",
            "                # is a reasonable approach to take",
            "                if wants_hugepages:",
            "                    guest_cell.memAccess = \"shared\"",
            "                guest_cpu_numa.cells.append(guest_cell)",
            "            return guest_cpu_numa",
            "",
            "    def _has_cpu_policy_support(self):",
            "        for ver in BAD_LIBVIRT_CPU_POLICY_VERSIONS:",
            "            if self._host.has_version(ver):",
            "                ver_ = self._version_to_string(ver)",
            "                raise exception.CPUPinningNotSupported(reason=_(",
            "                    'Invalid libvirt version %(version)s') % {'version': ver_})",
            "        return True",
            "",
            "    def _wants_hugepages(self, host_topology, instance_topology):",
            "        \"\"\"Determine if the guest / host topology implies the",
            "           use of huge pages for guest RAM backing",
            "        \"\"\"",
            "",
            "        if host_topology is None or instance_topology is None:",
            "            return False",
            "",
            "        avail_pagesize = [page.size_kb",
            "                          for page in host_topology.cells[0].mempages]",
            "        avail_pagesize.sort()",
            "        # Remove smallest page size as that's not classed as a largepage",
            "        avail_pagesize = avail_pagesize[1:]",
            "",
            "        # See if we have page size set",
            "        for cell in instance_topology.cells:",
            "            if (cell.pagesize is not None and",
            "                cell.pagesize in avail_pagesize):",
            "                return True",
            "",
            "        return False",
            "",
            "    def _get_guest_numa_config(self, instance_numa_topology, flavor, pci_devs,",
            "                               allowed_cpus=None, image_meta=None):",
            "        \"\"\"Returns the config objects for the guest NUMA specs.",
            "",
            "        Determines the CPUs that the guest can be pinned to if the guest",
            "        specifies a cell topology and the host supports it. Constructs the",
            "        libvirt XML config object representing the NUMA topology selected",
            "        for the guest. Returns a tuple of:",
            "",
            "            (cpu_set, guest_cpu_tune, guest_cpu_numa, guest_numa_tune)",
            "",
            "        With the following caveats:",
            "",
            "            a) If there is no specified guest NUMA topology, then",
            "               all tuple elements except cpu_set shall be None. cpu_set",
            "               will be populated with the chosen CPUs that the guest",
            "               allowed CPUs fit within, which could be the supplied",
            "               allowed_cpus value if the host doesn't support NUMA",
            "               topologies.",
            "",
            "            b) If there is a specified guest NUMA topology, then",
            "               cpu_set will be None and guest_cpu_numa will be the",
            "               LibvirtConfigGuestCPUNUMA object representing the guest's",
            "               NUMA topology. If the host supports NUMA, then guest_cpu_tune",
            "               will contain a LibvirtConfigGuestCPUTune object representing",
            "               the optimized chosen cells that match the host capabilities",
            "               with the instance's requested topology. If the host does",
            "               not support NUMA, then guest_cpu_tune and guest_numa_tune",
            "               will be None.",
            "        \"\"\"",
            "",
            "        if (not self._has_numa_support() and",
            "                instance_numa_topology is not None):",
            "            # We should not get here, since we should have avoided",
            "            # reporting NUMA topology from _get_host_numa_topology",
            "            # in the first place. Just in case of a scheduler",
            "            # mess up though, raise an exception",
            "            raise exception.NUMATopologyUnsupported()",
            "",
            "        topology = self._get_host_numa_topology()",
            "",
            "        # We have instance NUMA so translate it to the config class",
            "        guest_cpu_numa_config = self._get_cpu_numa_config_from_instance(",
            "                instance_numa_topology,",
            "                self._wants_hugepages(topology, instance_numa_topology))",
            "",
            "        if not guest_cpu_numa_config:",
            "            # No NUMA topology defined for instance - let the host kernel deal",
            "            # with the NUMA effects.",
            "            # TODO(ndipanov): Attempt to spread the instance",
            "            # across NUMA nodes and expose the topology to the",
            "            # instance as an optimisation",
            "            return GuestNumaConfig(allowed_cpus, None, None, None)",
            "        else:",
            "            if topology:",
            "                # Now get the CpuTune configuration from the numa_topology",
            "                guest_cpu_tune = vconfig.LibvirtConfigGuestCPUTune()",
            "                guest_numa_tune = vconfig.LibvirtConfigGuestNUMATune()",
            "                allpcpus = []",
            "",
            "                numa_mem = vconfig.LibvirtConfigGuestNUMATuneMemory()",
            "                numa_memnodes = [vconfig.LibvirtConfigGuestNUMATuneMemNode()",
            "                                 for _ in guest_cpu_numa_config.cells]",
            "",
            "                for host_cell in topology.cells:",
            "                    for guest_node_id, guest_config_cell in enumerate(",
            "                            guest_cpu_numa_config.cells):",
            "                        if guest_config_cell.id == host_cell.id:",
            "                            node = numa_memnodes[guest_node_id]",
            "                            node.cellid = guest_config_cell.id",
            "                            node.nodeset = [host_cell.id]",
            "                            node.mode = \"strict\"",
            "",
            "                            numa_mem.nodeset.append(host_cell.id)",
            "",
            "                            object_numa_cell = (",
            "                                    instance_numa_topology.cells[guest_node_id]",
            "                                )",
            "                            for cpu in guest_config_cell.cpus:",
            "                                pin_cpuset = (",
            "                                    vconfig.LibvirtConfigGuestCPUTuneVCPUPin())",
            "                                pin_cpuset.id = cpu",
            "                                # If there is pinning information in the cell",
            "                                # we pin to individual CPUs, otherwise we float",
            "                                # over the whole host NUMA node",
            "",
            "                                if (object_numa_cell.cpu_pinning and",
            "                                        self._has_cpu_policy_support()):",
            "                                    pcpu = object_numa_cell.cpu_pinning[cpu]",
            "                                    pin_cpuset.cpuset = set([pcpu])",
            "                                else:",
            "                                    pin_cpuset.cpuset = host_cell.cpuset",
            "                                allpcpus.extend(pin_cpuset.cpuset)",
            "                                guest_cpu_tune.vcpupin.append(pin_cpuset)",
            "",
            "                # TODO(berrange) When the guest has >1 NUMA node, it will",
            "                # span multiple host NUMA nodes. By pinning emulator threads",
            "                # to the union of all nodes, we guarantee there will be",
            "                # cross-node memory access by the emulator threads when",
            "                # responding to guest I/O operations. The only way to avoid",
            "                # this would be to pin emulator threads to a single node and",
            "                # tell the guest OS to only do I/O from one of its virtual",
            "                # NUMA nodes. This is not even remotely practical.",
            "                #",
            "                # The long term solution is to make use of a new QEMU feature",
            "                # called \"I/O Threads\" which will let us configure an explicit",
            "                # I/O thread for each guest vCPU or guest NUMA node. It is",
            "                # still TBD how to make use of this feature though, especially",
            "                # how to associate IO threads with guest devices to eliminiate",
            "                # cross NUMA node traffic. This is an area of investigation",
            "                # for QEMU community devs.",
            "                emulatorpin = vconfig.LibvirtConfigGuestCPUTuneEmulatorPin()",
            "                emulatorpin.cpuset = set(allpcpus)",
            "                guest_cpu_tune.emulatorpin = emulatorpin",
            "                # Sort the vcpupin list per vCPU id for human-friendlier XML",
            "                guest_cpu_tune.vcpupin.sort(key=operator.attrgetter(\"id\"))",
            "",
            "                if hardware.is_realtime_enabled(flavor):",
            "                    if not self._host.has_min_version(",
            "                            MIN_LIBVIRT_REALTIME_VERSION):",
            "                        raise exception.RealtimePolicyNotSupported()",
            "",
            "                    vcpus_rt, vcpus_em = hardware.vcpus_realtime_topology(",
            "                        set(cpu.id for cpu in guest_cpu_tune.vcpupin),",
            "                        flavor, image_meta)",
            "",
            "                    vcpusched = vconfig.LibvirtConfigGuestCPUTuneVCPUSched()",
            "                    vcpusched.vcpus = vcpus_rt",
            "                    vcpusched.scheduler = \"fifo\"",
            "                    vcpusched.priority = (",
            "                        CONF.libvirt.realtime_scheduler_priority)",
            "                    guest_cpu_tune.vcpusched.append(vcpusched)",
            "                    guest_cpu_tune.emulatorpin.cpuset = vcpus_em",
            "",
            "                guest_numa_tune.memory = numa_mem",
            "                guest_numa_tune.memnodes = numa_memnodes",
            "",
            "                # normalize cell.id",
            "                for i, (cell, memnode) in enumerate(",
            "                                            zip(guest_cpu_numa_config.cells,",
            "                                                guest_numa_tune.memnodes)):",
            "                    cell.id = i",
            "                    memnode.cellid = i",
            "",
            "                return GuestNumaConfig(None, guest_cpu_tune,",
            "                                       guest_cpu_numa_config,",
            "                                       guest_numa_tune)",
            "            else:",
            "                return GuestNumaConfig(allowed_cpus, None,",
            "                                       guest_cpu_numa_config, None)",
            "",
            "    def _get_guest_os_type(self, virt_type):",
            "        \"\"\"Returns the guest OS type based on virt type.\"\"\"",
            "        if virt_type == \"lxc\":",
            "            ret = vm_mode.EXE",
            "        elif virt_type == \"uml\":",
            "            ret = vm_mode.UML",
            "        elif virt_type == \"xen\":",
            "            ret = vm_mode.XEN",
            "        else:",
            "            ret = vm_mode.HVM",
            "        return ret",
            "",
            "    def _set_guest_for_rescue(self, rescue, guest, inst_path, virt_type,",
            "                              root_device_name):",
            "        if rescue.get('kernel_id'):",
            "            guest.os_kernel = os.path.join(inst_path, \"kernel.rescue\")",
            "            if virt_type == \"xen\":",
            "                guest.os_cmdline = \"ro root=%s\" % root_device_name",
            "            else:",
            "                guest.os_cmdline = (\"root=%s %s\" % (root_device_name, CONSOLE))",
            "                if virt_type == \"qemu\":",
            "                    guest.os_cmdline += \" no_timer_check\"",
            "        if rescue.get('ramdisk_id'):",
            "            guest.os_initrd = os.path.join(inst_path, \"ramdisk.rescue\")",
            "",
            "    def _set_guest_for_inst_kernel(self, instance, guest, inst_path, virt_type,",
            "                                root_device_name, image_meta):",
            "        guest.os_kernel = os.path.join(inst_path, \"kernel\")",
            "        if virt_type == \"xen\":",
            "            guest.os_cmdline = \"ro root=%s\" % root_device_name",
            "        else:",
            "            guest.os_cmdline = (\"root=%s %s\" % (root_device_name, CONSOLE))",
            "            if virt_type == \"qemu\":",
            "                guest.os_cmdline += \" no_timer_check\"",
            "        if instance.ramdisk_id:",
            "            guest.os_initrd = os.path.join(inst_path, \"ramdisk\")",
            "        # we only support os_command_line with images with an explicit",
            "        # kernel set and don't want to break nova if there's an",
            "        # os_command_line property without a specified kernel_id param",
            "        if image_meta.properties.get(\"os_command_line\"):",
            "            guest.os_cmdline = image_meta.properties.os_command_line",
            "",
            "    def _set_clock(self, guest, os_type, image_meta, virt_type):",
            "        # NOTE(mikal): Microsoft Windows expects the clock to be in",
            "        # \"localtime\". If the clock is set to UTC, then you can use a",
            "        # registry key to let windows know, but Microsoft says this is",
            "        # buggy in http://support.microsoft.com/kb/2687252",
            "        clk = vconfig.LibvirtConfigGuestClock()",
            "        if os_type == 'windows':",
            "            LOG.info(_LI('Configuring timezone for windows instance to '",
            "                         'localtime'))",
            "            clk.offset = 'localtime'",
            "        else:",
            "            clk.offset = 'utc'",
            "        guest.set_clock(clk)",
            "",
            "        if virt_type == \"kvm\":",
            "            self._set_kvm_timers(clk, os_type, image_meta)",
            "",
            "    def _set_kvm_timers(self, clk, os_type, image_meta):",
            "        # TODO(berrange) One day this should be per-guest",
            "        # OS type configurable",
            "        tmpit = vconfig.LibvirtConfigGuestTimer()",
            "        tmpit.name = \"pit\"",
            "        tmpit.tickpolicy = \"delay\"",
            "",
            "        tmrtc = vconfig.LibvirtConfigGuestTimer()",
            "        tmrtc.name = \"rtc\"",
            "        tmrtc.tickpolicy = \"catchup\"",
            "",
            "        clk.add_timer(tmpit)",
            "        clk.add_timer(tmrtc)",
            "",
            "        guestarch = libvirt_utils.get_arch(image_meta)",
            "        if guestarch in (arch.I686, arch.X86_64):",
            "            # NOTE(rfolco): HPET is a hardware timer for x86 arch.",
            "            # qemu -no-hpet is not supported on non-x86 targets.",
            "            tmhpet = vconfig.LibvirtConfigGuestTimer()",
            "            tmhpet.name = \"hpet\"",
            "            tmhpet.present = False",
            "            clk.add_timer(tmhpet)",
            "",
            "        # With new enough QEMU we can provide Windows guests",
            "        # with the paravirtualized hyperv timer source. This",
            "        # is the windows equiv of kvm-clock, allowing Windows",
            "        # guests to accurately keep time.",
            "        if (os_type == 'windows' and",
            "            self._host.has_min_version(MIN_LIBVIRT_HYPERV_TIMER_VERSION,",
            "                                       MIN_QEMU_HYPERV_TIMER_VERSION)):",
            "            tmhyperv = vconfig.LibvirtConfigGuestTimer()",
            "            tmhyperv.name = \"hypervclock\"",
            "            tmhyperv.present = True",
            "            clk.add_timer(tmhyperv)",
            "",
            "    def _set_features(self, guest, os_type, caps, virt_type):",
            "        if virt_type == \"xen\":",
            "            # PAE only makes sense in X86",
            "            if caps.host.cpu.arch in (arch.I686, arch.X86_64):",
            "                guest.features.append(vconfig.LibvirtConfigGuestFeaturePAE())",
            "",
            "        if (virt_type not in (\"lxc\", \"uml\", \"parallels\", \"xen\") or",
            "                (virt_type == \"xen\" and guest.os_type == vm_mode.HVM)):",
            "            guest.features.append(vconfig.LibvirtConfigGuestFeatureACPI())",
            "            guest.features.append(vconfig.LibvirtConfigGuestFeatureAPIC())",
            "",
            "        if (virt_type in (\"qemu\", \"kvm\") and",
            "                os_type == 'windows' and",
            "                self._host.has_min_version(MIN_LIBVIRT_HYPERV_FEATURE_VERSION,",
            "                                           MIN_QEMU_HYPERV_FEATURE_VERSION)):",
            "            hv = vconfig.LibvirtConfigGuestFeatureHyperV()",
            "            hv.relaxed = True",
            "",
            "            if self._host.has_min_version(",
            "                    MIN_LIBVIRT_HYPERV_FEATURE_EXTRA_VERSION):",
            "                hv.spinlocks = True",
            "                # Increase spinlock retries - value recommended by",
            "                # KVM maintainers who certify Windows guests",
            "                # with Microsoft",
            "                hv.spinlock_retries = 8191",
            "                hv.vapic = True",
            "            guest.features.append(hv)",
            "",
            "    def _create_serial_console_devices(self, guest, instance, flavor,",
            "                                       image_meta):",
            "        guest_arch = libvirt_utils.get_arch(image_meta)",
            "",
            "        if CONF.serial_console.enabled:",
            "            num_ports = hardware.get_number_of_serial_ports(",
            "                flavor, image_meta)",
            "            for port in six.moves.range(num_ports):",
            "                if guest_arch in (arch.S390, arch.S390X):",
            "                    console = vconfig.LibvirtConfigGuestConsole()",
            "                else:",
            "                    console = vconfig.LibvirtConfigGuestSerial()",
            "                console.port = port",
            "                console.type = \"tcp\"",
            "                console.listen_host = (",
            "                    CONF.serial_console.proxyclient_address)",
            "                console.listen_port = (",
            "                    serial_console.acquire_port(",
            "                        console.listen_host))",
            "                guest.add_device(console)",
            "        else:",
            "            # The QEMU 'pty' driver throws away any data if no",
            "            # client app is connected. Thus we can't get away",
            "            # with a single type=pty console. Instead we have",
            "            # to configure two separate consoles.",
            "            if guest_arch in (arch.S390, arch.S390X):",
            "                consolelog = vconfig.LibvirtConfigGuestConsole()",
            "                consolelog.target_type = \"sclplm\"",
            "            else:",
            "                consolelog = vconfig.LibvirtConfigGuestSerial()",
            "            consolelog.type = \"file\"",
            "            consolelog.source_path = self._get_console_log_path(instance)",
            "            guest.add_device(consolelog)",
            "",
            "    def _add_video_driver(self, guest, image_meta, flavor):",
            "        VALID_VIDEO_DEVICES = (\"vga\", \"cirrus\", \"vmvga\", \"xen\", \"qxl\")",
            "        video = vconfig.LibvirtConfigGuestVideo()",
            "        # NOTE(ldbragst): The following logic sets the video.type",
            "        # depending on supported defaults given the architecture,",
            "        # virtualization type, and features. The video.type attribute can",
            "        # be overridden by the user with image_meta.properties, which",
            "        # is carried out in the next if statement below this one.",
            "        guestarch = libvirt_utils.get_arch(image_meta)",
            "        if guest.os_type == vm_mode.XEN:",
            "            video.type = 'xen'",
            "        elif CONF.libvirt.virt_type == 'parallels':",
            "            video.type = 'vga'",
            "        elif guestarch in (arch.PPC, arch.PPC64, arch.PPC64LE):",
            "            # NOTE(ldbragst): PowerKVM doesn't support 'cirrus' be default",
            "            # so use 'vga' instead when running on Power hardware.",
            "            video.type = 'vga'",
            "        elif CONF.spice.enabled:",
            "            video.type = 'qxl'",
            "        if image_meta.properties.get('hw_video_model'):",
            "            video.type = image_meta.properties.hw_video_model",
            "            if (video.type not in VALID_VIDEO_DEVICES):",
            "                raise exception.InvalidVideoMode(model=video.type)",
            "",
            "        # Set video memory, only if the flavor's limit is set",
            "        video_ram = image_meta.properties.get('hw_video_ram', 0)",
            "        max_vram = int(flavor.extra_specs.get('hw_video:ram_max_mb', 0))",
            "        if video_ram > max_vram:",
            "            raise exception.RequestedVRamTooHigh(req_vram=video_ram,",
            "                                                 max_vram=max_vram)",
            "        if max_vram and video_ram:",
            "            video.vram = video_ram * units.Mi / units.Ki",
            "        guest.add_device(video)",
            "",
            "    def _add_qga_device(self, guest, instance):",
            "        qga = vconfig.LibvirtConfigGuestChannel()",
            "        qga.type = \"unix\"",
            "        qga.target_name = \"org.qemu.guest_agent.0\"",
            "        qga.source_path = (\"/var/lib/libvirt/qemu/%s.%s.sock\" %",
            "                          (\"org.qemu.guest_agent.0\", instance.name))",
            "        guest.add_device(qga)",
            "",
            "    def _add_rng_device(self, guest, flavor):",
            "        rng_device = vconfig.LibvirtConfigGuestRng()",
            "        rate_bytes = flavor.extra_specs.get('hw_rng:rate_bytes', 0)",
            "        period = flavor.extra_specs.get('hw_rng:rate_period', 0)",
            "        if rate_bytes:",
            "            rng_device.rate_bytes = int(rate_bytes)",
            "            rng_device.rate_period = int(period)",
            "        rng_path = CONF.libvirt.rng_dev_path",
            "        if (rng_path and not os.path.exists(rng_path)):",
            "            raise exception.RngDeviceNotExist(path=rng_path)",
            "        rng_device.backend = rng_path",
            "        guest.add_device(rng_device)",
            "",
            "    def _set_qemu_guest_agent(self, guest, flavor, instance, image_meta):",
            "        # Enable qga only if the 'hw_qemu_guest_agent' is equal to yes",
            "        if image_meta.properties.get('hw_qemu_guest_agent', False):",
            "            LOG.debug(\"Qemu guest agent is enabled through image \"",
            "                      \"metadata\", instance=instance)",
            "            self._add_qga_device(guest, instance)",
            "        rng_is_virtio = image_meta.properties.get('hw_rng_model') == 'virtio'",
            "        rng_allowed_str = flavor.extra_specs.get('hw_rng:allowed', '')",
            "        rng_allowed = strutils.bool_from_string(rng_allowed_str)",
            "        if rng_is_virtio and rng_allowed:",
            "            self._add_rng_device(guest, flavor)",
            "",
            "    def _get_guest_memory_backing_config(",
            "            self, inst_topology, numatune, flavor):",
            "        wantsmempages = False",
            "        if inst_topology:",
            "            for cell in inst_topology.cells:",
            "                if cell.pagesize:",
            "                    wantsmempages = True",
            "                    break",
            "",
            "        wantsrealtime = hardware.is_realtime_enabled(flavor)",
            "",
            "        membacking = None",
            "        if wantsmempages:",
            "            pages = self._get_memory_backing_hugepages_support(",
            "                inst_topology, numatune)",
            "            if pages:",
            "                membacking = vconfig.LibvirtConfigGuestMemoryBacking()",
            "                membacking.hugepages = pages",
            "        if wantsrealtime:",
            "            if not membacking:",
            "                membacking = vconfig.LibvirtConfigGuestMemoryBacking()",
            "            membacking.locked = True",
            "            membacking.sharedpages = False",
            "",
            "        return membacking",
            "",
            "    def _get_memory_backing_hugepages_support(self, inst_topology, numatune):",
            "        if not self._has_hugepage_support():",
            "            # We should not get here, since we should have avoided",
            "            # reporting NUMA topology from _get_host_numa_topology",
            "            # in the first place. Just in case of a scheduler",
            "            # mess up though, raise an exception",
            "            raise exception.MemoryPagesUnsupported()",
            "",
            "        host_topology = self._get_host_numa_topology()",
            "",
            "        if host_topology is None:",
            "            # As above, we should not get here but just in case...",
            "            raise exception.MemoryPagesUnsupported()",
            "",
            "        # Currently libvirt does not support the smallest",
            "        # pagesize set as a backend memory.",
            "        # https://bugzilla.redhat.com/show_bug.cgi?id=1173507",
            "        avail_pagesize = [page.size_kb",
            "                          for page in host_topology.cells[0].mempages]",
            "        avail_pagesize.sort()",
            "        smallest = avail_pagesize[0]",
            "",
            "        pages = []",
            "        for guest_cellid, inst_cell in enumerate(inst_topology.cells):",
            "            if inst_cell.pagesize and inst_cell.pagesize > smallest:",
            "                for memnode in numatune.memnodes:",
            "                    if guest_cellid == memnode.cellid:",
            "                        page = (",
            "                            vconfig.LibvirtConfigGuestMemoryBackingPage())",
            "                        page.nodeset = [guest_cellid]",
            "                        page.size_kb = inst_cell.pagesize",
            "                        pages.append(page)",
            "                        break  # Quit early...",
            "        return pages",
            "",
            "    def _get_flavor(self, ctxt, instance, flavor):",
            "        if flavor is not None:",
            "            return flavor",
            "        return instance.flavor",
            "",
            "    def _has_uefi_support(self):",
            "        # This means that the host can support uefi booting for guests",
            "        supported_archs = [arch.X86_64, arch.AARCH64]",
            "        caps = self._host.get_capabilities()",
            "        return ((caps.host.cpu.arch in supported_archs) and",
            "                self._host.has_min_version(MIN_LIBVIRT_UEFI_VERSION) and",
            "                os.path.exists(DEFAULT_UEFI_LOADER_PATH[caps.host.cpu.arch]))",
            "",
            "    def _configure_guest_by_virt_type(self, guest, virt_type, caps, instance,",
            "                                      image_meta, flavor, root_device_name):",
            "        if virt_type == \"xen\":",
            "            if guest.os_type == vm_mode.HVM:",
            "                guest.os_loader = CONF.libvirt.xen_hvmloader_path",
            "        elif virt_type in (\"kvm\", \"qemu\"):",
            "            if caps.host.cpu.arch in (arch.I686, arch.X86_64):",
            "                guest.sysinfo = self._get_guest_config_sysinfo(instance)",
            "                guest.os_smbios = vconfig.LibvirtConfigGuestSMBIOS()",
            "            hw_firmware_type = image_meta.properties.get('hw_firmware_type')",
            "            if hw_firmware_type == fields.FirmwareType.UEFI:",
            "                if self._has_uefi_support():",
            "                    global uefi_logged",
            "                    if not uefi_logged:",
            "                        LOG.warn(_LW(\"uefi support is without some kind of \"",
            "                                     \"functional testing and therefore \"",
            "                                     \"considered experimental.\"))",
            "                        uefi_logged = True",
            "                    guest.os_loader = DEFAULT_UEFI_LOADER_PATH[",
            "                        caps.host.cpu.arch]",
            "                    guest.os_loader_type = \"pflash\"",
            "                else:",
            "                    raise exception.UEFINotSupported()",
            "            guest.os_mach_type = self._get_machine_type(image_meta, caps)",
            "            if image_meta.properties.get('hw_boot_menu') is None:",
            "                guest.os_bootmenu = strutils.bool_from_string(",
            "                    flavor.extra_specs.get('hw:boot_menu', 'no'))",
            "            else:",
            "                guest.os_bootmenu = image_meta.properties.hw_boot_menu",
            "",
            "        elif virt_type == \"lxc\":",
            "            guest.os_init_path = \"/sbin/init\"",
            "            guest.os_cmdline = CONSOLE",
            "        elif virt_type == \"uml\":",
            "            guest.os_kernel = \"/usr/bin/linux\"",
            "            guest.os_root = root_device_name",
            "        elif virt_type == \"parallels\":",
            "            if guest.os_type == vm_mode.EXE:",
            "                guest.os_init_path = \"/sbin/init\"",
            "",
            "    def _conf_non_lxc_uml(self, virt_type, guest, root_device_name, rescue,",
            "                    instance, inst_path, image_meta, disk_info):",
            "        if rescue:",
            "            self._set_guest_for_rescue(rescue, guest, inst_path, virt_type,",
            "                                       root_device_name)",
            "        elif instance.kernel_id:",
            "            self._set_guest_for_inst_kernel(instance, guest, inst_path,",
            "                                            virt_type, root_device_name,",
            "                                            image_meta)",
            "        else:",
            "            guest.os_boot_dev = blockinfo.get_boot_order(disk_info)",
            "",
            "    def _create_consoles(self, virt_type, guest, instance, flavor, image_meta,",
            "                         caps):",
            "        if virt_type in (\"qemu\", \"kvm\"):",
            "            # Create the serial console char devices",
            "            self._create_serial_console_devices(guest, instance, flavor,",
            "                                                image_meta)",
            "            if caps.host.cpu.arch in (arch.S390, arch.S390X):",
            "                consolepty = vconfig.LibvirtConfigGuestConsole()",
            "                consolepty.target_type = \"sclp\"",
            "            else:",
            "                consolepty = vconfig.LibvirtConfigGuestSerial()",
            "        else:",
            "            consolepty = vconfig.LibvirtConfigGuestConsole()",
            "        return consolepty",
            "",
            "    def _cpu_config_to_vcpu_model(self, cpu_config, vcpu_model):",
            "        \"\"\"Update VirtCPUModel object according to libvirt CPU config.",
            "",
            "        :param:cpu_config: vconfig.LibvirtConfigGuestCPU presenting the",
            "                           instance's virtual cpu configuration.",
            "        :param:vcpu_model: VirtCPUModel object. A new object will be created",
            "                           if None.",
            "",
            "        :return: Updated VirtCPUModel object, or None if cpu_config is None",
            "",
            "        \"\"\"",
            "",
            "        if not cpu_config:",
            "            return",
            "        if not vcpu_model:",
            "            vcpu_model = objects.VirtCPUModel()",
            "",
            "        vcpu_model.arch = cpu_config.arch",
            "        vcpu_model.vendor = cpu_config.vendor",
            "        vcpu_model.model = cpu_config.model",
            "        vcpu_model.mode = cpu_config.mode",
            "        vcpu_model.match = cpu_config.match",
            "",
            "        if cpu_config.sockets:",
            "            vcpu_model.topology = objects.VirtCPUTopology(",
            "                sockets=cpu_config.sockets,",
            "                cores=cpu_config.cores,",
            "                threads=cpu_config.threads)",
            "        else:",
            "            vcpu_model.topology = None",
            "",
            "        features = [objects.VirtCPUFeature(",
            "            name=f.name,",
            "            policy=f.policy) for f in cpu_config.features]",
            "        vcpu_model.features = features",
            "",
            "        return vcpu_model",
            "",
            "    def _vcpu_model_to_cpu_config(self, vcpu_model):",
            "        \"\"\"Create libvirt CPU config according to VirtCPUModel object.",
            "",
            "        :param:vcpu_model: VirtCPUModel object.",
            "",
            "        :return: vconfig.LibvirtConfigGuestCPU.",
            "",
            "        \"\"\"",
            "",
            "        cpu_config = vconfig.LibvirtConfigGuestCPU()",
            "        cpu_config.arch = vcpu_model.arch",
            "        cpu_config.model = vcpu_model.model",
            "        cpu_config.mode = vcpu_model.mode",
            "        cpu_config.match = vcpu_model.match",
            "        cpu_config.vendor = vcpu_model.vendor",
            "        if vcpu_model.topology:",
            "            cpu_config.sockets = vcpu_model.topology.sockets",
            "            cpu_config.cores = vcpu_model.topology.cores",
            "            cpu_config.threads = vcpu_model.topology.threads",
            "        if vcpu_model.features:",
            "            for f in vcpu_model.features:",
            "                xf = vconfig.LibvirtConfigGuestCPUFeature()",
            "                xf.name = f.name",
            "                xf.policy = f.policy",
            "                cpu_config.features.add(xf)",
            "        return cpu_config",
            "",
            "    def _get_guest_config(self, instance, network_info, image_meta,",
            "                          disk_info, rescue=None, block_device_info=None,",
            "                          context=None):",
            "        \"\"\"Get config data for parameters.",
            "",
            "        :param rescue: optional dictionary that should contain the key",
            "            'ramdisk_id' if a ramdisk is needed for the rescue image and",
            "            'kernel_id' if a kernel is needed for the rescue image.",
            "        \"\"\"",
            "        flavor = instance.flavor",
            "        inst_path = libvirt_utils.get_instance_path(instance)",
            "        disk_mapping = disk_info['mapping']",
            "",
            "        virt_type = CONF.libvirt.virt_type",
            "        guest = vconfig.LibvirtConfigGuest()",
            "        guest.virt_type = virt_type",
            "        guest.name = instance.name",
            "        guest.uuid = instance.uuid",
            "        # We are using default unit for memory: KiB",
            "        guest.memory = flavor.memory_mb * units.Ki",
            "        guest.vcpus = flavor.vcpus",
            "        allowed_cpus = hardware.get_vcpu_pin_set()",
            "        pci_devs = pci_manager.get_instance_pci_devs(instance, 'all')",
            "",
            "        guest_numa_config = self._get_guest_numa_config(",
            "            instance.numa_topology, flavor, pci_devs, allowed_cpus, image_meta)",
            "",
            "        guest.cpuset = guest_numa_config.cpuset",
            "        guest.cputune = guest_numa_config.cputune",
            "        guest.numatune = guest_numa_config.numatune",
            "",
            "        guest.membacking = self._get_guest_memory_backing_config(",
            "            instance.numa_topology,",
            "            guest_numa_config.numatune,",
            "            flavor)",
            "",
            "        guest.metadata.append(self._get_guest_config_meta(context,",
            "                                                          instance))",
            "        guest.idmaps = self._get_guest_idmaps()",
            "",
            "        self._update_guest_cputune(guest, flavor, virt_type)",
            "",
            "        guest.cpu = self._get_guest_cpu_config(",
            "            flavor, image_meta, guest_numa_config.numaconfig,",
            "            instance.numa_topology)",
            "",
            "        # Notes(yjiang5): we always sync the instance's vcpu model with",
            "        # the corresponding config file.",
            "        instance.vcpu_model = self._cpu_config_to_vcpu_model(",
            "            guest.cpu, instance.vcpu_model)",
            "",
            "        if 'root' in disk_mapping:",
            "            root_device_name = block_device.prepend_dev(",
            "                disk_mapping['root']['dev'])",
            "        else:",
            "            root_device_name = None",
            "",
            "        if root_device_name:",
            "            # NOTE(yamahata):",
            "            # for nova.api.ec2.cloud.CloudController.get_metadata()",
            "            instance.root_device_name = root_device_name",
            "",
            "        guest.os_type = (vm_mode.get_from_instance(instance) or",
            "                self._get_guest_os_type(virt_type))",
            "        caps = self._host.get_capabilities()",
            "",
            "        self._configure_guest_by_virt_type(guest, virt_type, caps, instance,",
            "                                           image_meta, flavor,",
            "                                           root_device_name)",
            "        if virt_type not in ('lxc', 'uml'):",
            "            self._conf_non_lxc_uml(virt_type, guest, root_device_name, rescue,",
            "                    instance, inst_path, image_meta, disk_info)",
            "",
            "        self._set_features(guest, instance.os_type, caps, virt_type)",
            "        self._set_clock(guest, instance.os_type, image_meta, virt_type)",
            "",
            "        storage_configs = self._get_guest_storage_config(",
            "                instance, image_meta, disk_info, rescue, block_device_info,",
            "                flavor, guest.os_type)",
            "        for config in storage_configs:",
            "            guest.add_device(config)",
            "",
            "        for vif in network_info:",
            "            config = self.vif_driver.get_config(",
            "                instance, vif, image_meta,",
            "                flavor, virt_type, self._host)",
            "            guest.add_device(config)",
            "",
            "        consolepty = self._create_consoles(virt_type, guest, instance, flavor,",
            "                                           image_meta, caps)",
            "        if virt_type != 'parallels':",
            "            consolepty.type = \"pty\"",
            "            guest.add_device(consolepty)",
            "",
            "        tablet = self._get_guest_usb_tablet(guest.os_type)",
            "        if tablet:",
            "            guest.add_device(tablet)",
            "",
            "        if (CONF.spice.enabled and CONF.spice.agent_enabled and",
            "                virt_type not in ('lxc', 'uml', 'xen')):",
            "            channel = vconfig.LibvirtConfigGuestChannel()",
            "            channel.target_name = \"com.redhat.spice.0\"",
            "            guest.add_device(channel)",
            "",
            "        # NB some versions of libvirt support both SPICE and VNC",
            "        # at the same time. We're not trying to second guess which",
            "        # those versions are. We'll just let libvirt report the",
            "        # errors appropriately if the user enables both.",
            "        add_video_driver = False",
            "        if ((CONF.vnc.enabled and",
            "             virt_type not in ('lxc', 'uml'))):",
            "            graphics = vconfig.LibvirtConfigGuestGraphics()",
            "            graphics.type = \"vnc\"",
            "            graphics.keymap = CONF.vnc.keymap",
            "            graphics.listen = CONF.vnc.vncserver_listen",
            "            guest.add_device(graphics)",
            "            add_video_driver = True",
            "",
            "        if (CONF.spice.enabled and",
            "                virt_type not in ('lxc', 'uml', 'xen')):",
            "            graphics = vconfig.LibvirtConfigGuestGraphics()",
            "            graphics.type = \"spice\"",
            "            graphics.keymap = CONF.spice.keymap",
            "            graphics.listen = CONF.spice.server_listen",
            "            guest.add_device(graphics)",
            "            add_video_driver = True",
            "",
            "        if add_video_driver:",
            "            self._add_video_driver(guest, image_meta, flavor)",
            "",
            "        # Qemu guest agent only support 'qemu' and 'kvm' hypervisor",
            "        if virt_type in ('qemu', 'kvm'):",
            "            self._set_qemu_guest_agent(guest, flavor, instance, image_meta)",
            "",
            "        if virt_type in ('xen', 'qemu', 'kvm'):",
            "            for pci_dev in pci_manager.get_instance_pci_devs(instance):",
            "                guest.add_device(self._get_guest_pci_device(pci_dev))",
            "        else:",
            "            if len(pci_devs) > 0:",
            "                raise exception.PciDeviceUnsupportedHypervisor(",
            "                    type=virt_type)",
            "",
            "        if 'hw_watchdog_action' in flavor.extra_specs:",
            "            LOG.warn(_LW('Old property name \"hw_watchdog_action\" is now '",
            "                         'deprecated and will be removed in the next release. '",
            "                         'Use updated property name '",
            "                         '\"hw:watchdog_action\" instead'), instance=instance)",
            "        # TODO(pkholkin): accepting old property name 'hw_watchdog_action'",
            "        #                should be removed in the next release",
            "        watchdog_action = (flavor.extra_specs.get('hw_watchdog_action') or",
            "                           flavor.extra_specs.get('hw:watchdog_action')",
            "                           or 'disabled')",
            "        watchdog_action = image_meta.properties.get('hw_watchdog_action',",
            "                                                    watchdog_action)",
            "",
            "        # NB(sross): currently only actually supported by KVM/QEmu",
            "        if watchdog_action != 'disabled':",
            "            if watchdog_actions.is_valid_watchdog_action(watchdog_action):",
            "                bark = vconfig.LibvirtConfigGuestWatchdog()",
            "                bark.action = watchdog_action",
            "                guest.add_device(bark)",
            "            else:",
            "                raise exception.InvalidWatchdogAction(action=watchdog_action)",
            "",
            "        # Memory balloon device only support 'qemu/kvm' and 'xen' hypervisor",
            "        if (virt_type in ('xen', 'qemu', 'kvm') and",
            "                CONF.libvirt.mem_stats_period_seconds > 0):",
            "            balloon = vconfig.LibvirtConfigMemoryBalloon()",
            "            if virt_type in ('qemu', 'kvm'):",
            "                balloon.model = 'virtio'",
            "            else:",
            "                balloon.model = 'xen'",
            "            balloon.period = CONF.libvirt.mem_stats_period_seconds",
            "            guest.add_device(balloon)",
            "",
            "        return guest",
            "",
            "    def _get_guest_usb_tablet(self, os_type):",
            "        # We want a tablet if VNC is enabled, or SPICE is enabled and",
            "        # the SPICE agent is disabled. If the SPICE agent is enabled",
            "        # it provides a paravirt mouse which drastically reduces",
            "        # overhead (by eliminating USB polling).",
            "        #",
            "        # NB: this implies that if both SPICE + VNC are enabled",
            "        # at the same time, we'll get the tablet whether the",
            "        # SPICE agent is used or not.",
            "        need_usb_tablet = False",
            "        if CONF.vnc.enabled:",
            "            need_usb_tablet = CONF.libvirt.use_usb_tablet",
            "        elif CONF.spice.enabled and not CONF.spice.agent_enabled:",
            "            need_usb_tablet = CONF.libvirt.use_usb_tablet",
            "",
            "        tablet = None",
            "        if need_usb_tablet and os_type == vm_mode.HVM:",
            "            tablet = vconfig.LibvirtConfigGuestInput()",
            "            tablet.type = \"tablet\"",
            "            tablet.bus = \"usb\"",
            "        return tablet",
            "",
            "    def _get_guest_xml(self, context, instance, network_info, disk_info,",
            "                       image_meta, rescue=None,",
            "                       block_device_info=None, write_to_disk=False):",
            "        # NOTE(danms): Stringifying a NetworkInfo will take a lock. Do",
            "        # this ahead of time so that we don't acquire it while also",
            "        # holding the logging lock.",
            "        network_info_str = str(network_info)",
            "        msg = ('Start _get_guest_xml '",
            "               'network_info=%(network_info)s '",
            "               'disk_info=%(disk_info)s '",
            "               'image_meta=%(image_meta)s rescue=%(rescue)s '",
            "               'block_device_info=%(block_device_info)s' %",
            "               {'network_info': network_info_str, 'disk_info': disk_info,",
            "                'image_meta': image_meta, 'rescue': rescue,",
            "                'block_device_info': block_device_info})",
            "        # NOTE(mriedem): block_device_info can contain auth_password so we",
            "        # need to sanitize the password in the message.",
            "        LOG.debug(strutils.mask_password(msg), instance=instance)",
            "        conf = self._get_guest_config(instance, network_info, image_meta,",
            "                                      disk_info, rescue, block_device_info,",
            "                                      context)",
            "        xml = conf.to_xml()",
            "",
            "        if write_to_disk:",
            "            instance_dir = libvirt_utils.get_instance_path(instance)",
            "            xml_path = os.path.join(instance_dir, 'libvirt.xml')",
            "            libvirt_utils.write_to_file(xml_path, xml)",
            "",
            "        LOG.debug('End _get_guest_xml xml=%(xml)s',",
            "                  {'xml': xml}, instance=instance)",
            "        return xml",
            "",
            "    def get_info(self, instance):",
            "        \"\"\"Retrieve information from libvirt for a specific instance name.",
            "",
            "        If a libvirt error is encountered during lookup, we might raise a",
            "        NotFound exception or Error exception depending on how severe the",
            "        libvirt error is.",
            "",
            "        \"\"\"",
            "        guest = self._host.get_guest(instance)",
            "        # Kind of ugly but we need to pass host to get_info as for a",
            "        # workaround, see libvirt/compat.py",
            "        return guest.get_info(self._host)",
            "",
            "    def _create_domain_setup_lxc(self, instance, image_meta,",
            "                                 block_device_info, disk_info):",
            "        inst_path = libvirt_utils.get_instance_path(instance)",
            "        disk_info = disk_info or {}",
            "        disk_mapping = disk_info.get('mapping', {})",
            "",
            "        if self._is_booted_from_volume(instance, disk_mapping):",
            "            block_device_mapping = driver.block_device_info_get_mapping(",
            "                                                            block_device_info)",
            "            root_disk = block_device.get_root_bdm(block_device_mapping)",
            "            disk_info = blockinfo.get_info_from_bdm(",
            "                instance, CONF.libvirt.virt_type, image_meta, root_disk)",
            "            self._connect_volume(root_disk['connection_info'], disk_info)",
            "            disk_path = root_disk['connection_info']['data']['device_path']",
            "",
            "            # NOTE(apmelton) - Even though the instance is being booted from a",
            "            # cinder volume, it is still presented as a local block device.",
            "            # LocalBlockImage is used here to indicate that the instance's",
            "            # disk is backed by a local block device.",
            "            image_model = imgmodel.LocalBlockImage(disk_path)",
            "        else:",
            "            image = self.image_backend.image(instance, 'disk')",
            "            image_model = image.get_model(self._conn)",
            "",
            "        container_dir = os.path.join(inst_path, 'rootfs')",
            "        fileutils.ensure_tree(container_dir)",
            "        rootfs_dev = disk.setup_container(image_model,",
            "                                          container_dir=container_dir)",
            "",
            "        try:",
            "            # Save rootfs device to disconnect it when deleting the instance",
            "            if rootfs_dev:",
            "                instance.system_metadata['rootfs_device_name'] = rootfs_dev",
            "            if CONF.libvirt.uid_maps or CONF.libvirt.gid_maps:",
            "                id_maps = self._get_guest_idmaps()",
            "                libvirt_utils.chown_for_id_maps(container_dir, id_maps)",
            "        except Exception:",
            "            with excutils.save_and_reraise_exception():",
            "                self._create_domain_cleanup_lxc(instance)",
            "",
            "    def _create_domain_cleanup_lxc(self, instance):",
            "        inst_path = libvirt_utils.get_instance_path(instance)",
            "        container_dir = os.path.join(inst_path, 'rootfs')",
            "",
            "        try:",
            "            state = self.get_info(instance).state",
            "        except exception.InstanceNotFound:",
            "            # The domain may not be present if the instance failed to start",
            "            state = None",
            "",
            "        if state == power_state.RUNNING:",
            "            # NOTE(uni): Now the container is running with its own private",
            "            # mount namespace and so there is no need to keep the container",
            "            # rootfs mounted in the host namespace",
            "            LOG.debug('Attempting to unmount container filesystem: %s',",
            "                      container_dir, instance=instance)",
            "            disk.clean_lxc_namespace(container_dir=container_dir)",
            "        else:",
            "            disk.teardown_container(container_dir=container_dir)",
            "",
            "    @contextlib.contextmanager",
            "    def _lxc_disk_handler(self, instance, image_meta,",
            "                          block_device_info, disk_info):",
            "        \"\"\"Context manager to handle the pre and post instance boot,",
            "           LXC specific disk operations.",
            "",
            "           An image or a volume path will be prepared and setup to be",
            "           used by the container, prior to starting it.",
            "           The disk will be disconnected and unmounted if a container has",
            "           failed to start.",
            "        \"\"\"",
            "",
            "        if CONF.libvirt.virt_type != 'lxc':",
            "            yield",
            "            return",
            "",
            "        self._create_domain_setup_lxc(instance, image_meta,",
            "                                      block_device_info, disk_info)",
            "",
            "        try:",
            "            yield",
            "        finally:",
            "            self._create_domain_cleanup_lxc(instance)",
            "",
            "    # TODO(sahid): Consider renaming this to _create_guest.",
            "    def _create_domain(self, xml=None, domain=None,",
            "                       power_on=True, pause=False):",
            "        \"\"\"Create a domain.",
            "",
            "        Either domain or xml must be passed in. If both are passed, then",
            "        the domain definition is overwritten from the xml.",
            "",
            "        :returns guest.Guest: Guest just created",
            "        \"\"\"",
            "        if xml:",
            "            guest = libvirt_guest.Guest.create(xml, self._host)",
            "        else:",
            "            guest = libvirt_guest.Guest(domain)",
            "",
            "        if power_on or pause:",
            "            guest.launch(pause=pause)",
            "",
            "        if not utils.is_neutron():",
            "            guest.enable_hairpin()",
            "",
            "        return guest",
            "",
            "    def _neutron_failed_callback(self, event_name, instance):",
            "        LOG.error(_LE('Neutron Reported failure on event '",
            "                      '%(event)s for instance %(uuid)s'),",
            "                  {'event': event_name, 'uuid': instance.uuid},",
            "                  instance=instance)",
            "        if CONF.vif_plugging_is_fatal:",
            "            raise exception.VirtualInterfaceCreateException()",
            "",
            "    def _get_neutron_events(self, network_info):",
            "        # NOTE(danms): We need to collect any VIFs that are currently",
            "        # down that we expect a down->up event for. Anything that is",
            "        # already up will not undergo that transition, and for",
            "        # anything that might be stale (cache-wise) assume it's",
            "        # already up so we don't block on it.",
            "        return [('network-vif-plugged', vif['id'])",
            "                for vif in network_info if vif.get('active', True) is False]",
            "",
            "    def _create_domain_and_network(self, context, xml, instance, network_info,",
            "                                   disk_info, block_device_info=None,",
            "                                   power_on=True, reboot=False,",
            "                                   vifs_already_plugged=False):",
            "",
            "        \"\"\"Do required network setup and create domain.\"\"\"",
            "        block_device_mapping = driver.block_device_info_get_mapping(",
            "            block_device_info)",
            "",
            "        for vol in block_device_mapping:",
            "            connection_info = vol['connection_info']",
            "",
            "            if (not reboot and 'data' in connection_info and",
            "                    'volume_id' in connection_info['data']):",
            "                volume_id = connection_info['data']['volume_id']",
            "                encryption = encryptors.get_encryption_metadata(",
            "                    context, self._volume_api, volume_id, connection_info)",
            "",
            "                if encryption:",
            "                    encryptor = self._get_volume_encryptor(connection_info,",
            "                                                           encryption)",
            "                    encryptor.attach_volume(context, **encryption)",
            "",
            "        timeout = CONF.vif_plugging_timeout",
            "        if (self._conn_supports_start_paused and",
            "            utils.is_neutron() and not",
            "            vifs_already_plugged and power_on and timeout):",
            "            events = self._get_neutron_events(network_info)",
            "        else:",
            "            events = []",
            "",
            "        pause = bool(events)",
            "        guest = None",
            "        try:",
            "            with self.virtapi.wait_for_instance_event(",
            "                    instance, events, deadline=timeout,",
            "                    error_callback=self._neutron_failed_callback):",
            "                self.plug_vifs(instance, network_info)",
            "                self.firewall_driver.setup_basic_filtering(instance,",
            "                                                           network_info)",
            "                self.firewall_driver.prepare_instance_filter(instance,",
            "                                                             network_info)",
            "                with self._lxc_disk_handler(instance, instance.image_meta,",
            "                                            block_device_info, disk_info):",
            "                    guest = self._create_domain(",
            "                        xml, pause=pause, power_on=power_on)",
            "",
            "                self.firewall_driver.apply_instance_filter(instance,",
            "                                                           network_info)",
            "        except exception.VirtualInterfaceCreateException:",
            "            # Neutron reported failure and we didn't swallow it, so",
            "            # bail here",
            "            with excutils.save_and_reraise_exception():",
            "                if guest:",
            "                    guest.poweroff()",
            "                self.cleanup(context, instance, network_info=network_info,",
            "                             block_device_info=block_device_info)",
            "        except eventlet.timeout.Timeout:",
            "            # We never heard from Neutron",
            "            LOG.warn(_LW('Timeout waiting for vif plugging callback for '",
            "                         'instance %(uuid)s'), {'uuid': instance.uuid},",
            "                     instance=instance)",
            "            if CONF.vif_plugging_is_fatal:",
            "                if guest:",
            "                    guest.poweroff()",
            "                self.cleanup(context, instance, network_info=network_info,",
            "                             block_device_info=block_device_info)",
            "                raise exception.VirtualInterfaceCreateException()",
            "",
            "        # Resume only if domain has been paused",
            "        if pause:",
            "            guest.resume()",
            "        return guest",
            "",
            "    def _get_all_block_devices(self):",
            "        \"\"\"Return all block devices in use on this node.\"\"\"",
            "        devices = []",
            "        for guest in self._host.list_guests():",
            "            try:",
            "                doc = etree.fromstring(guest.get_xml_desc())",
            "            except libvirt.libvirtError as e:",
            "                LOG.warn(_LW(\"couldn't obtain the XML from domain:\"",
            "                             \" %(uuid)s, exception: %(ex)s\") %",
            "                         {\"uuid\": guest.id, \"ex\": e})",
            "                continue",
            "            except Exception:",
            "                continue",
            "            sources = doc.findall(\"./devices/disk[@type='block']/source\")",
            "            for source in sources:",
            "                devices.append(source.get('dev'))",
            "        return devices",
            "",
            "    def _get_interfaces(self, xml):",
            "        \"\"\"Note that this function takes a domain xml.",
            "",
            "        Returns a list of all network interfaces for this instance.",
            "        \"\"\"",
            "        doc = None",
            "",
            "        try:",
            "            doc = etree.fromstring(xml)",
            "        except Exception:",
            "            return []",
            "",
            "        interfaces = []",
            "",
            "        nodes = doc.findall('./devices/interface/target')",
            "        for target in nodes:",
            "            interfaces.append(target.get('dev'))",
            "",
            "        return interfaces",
            "",
            "    def _get_vcpu_total(self):",
            "        \"\"\"Get available vcpu number of physical computer.",
            "",
            "        :returns: the number of cpu core instances can be used.",
            "",
            "        \"\"\"",
            "        try:",
            "            total_pcpus = self._host.get_cpu_count()",
            "        except libvirt.libvirtError:",
            "            LOG.warn(_LW(\"Cannot get the number of cpu, because this \"",
            "                         \"function is not implemented for this platform. \"))",
            "            return 0",
            "",
            "        if CONF.vcpu_pin_set is None:",
            "            return total_pcpus",
            "",
            "        available_ids = hardware.get_vcpu_pin_set()",
            "        # We get the list of online CPUs on the host and see if the requested",
            "        # set falls under these. If not, we retain the old behavior.",
            "        online_pcpus = None",
            "        try:",
            "            online_pcpus = self._host.get_online_cpus()",
            "        except libvirt.libvirtError as ex:",
            "            error_code = ex.get_error_code()",
            "            LOG.warn(_LW(\"Couldn't retrieve the online CPUs due to a Libvirt \"",
            "                         \"error: %(error)s with error code: %(error_code)s\"),",
            "                     {'error': ex, 'error_code': error_code})",
            "        if online_pcpus:",
            "            if not (available_ids <= online_pcpus):",
            "                msg = (_(\"Invalid vcpu_pin_set config, one or more of the \"",
            "                         \"specified cpuset is not online. Online cpuset(s): \"",
            "                         \"%(online)s, requested cpuset(s): %(req)s\"),",
            "                       {'online': sorted(online_pcpus),",
            "                        'req': sorted(available_ids)})",
            "                raise exception.Invalid(msg)",
            "        elif sorted(available_ids)[-1] >= total_pcpus:",
            "            raise exception.Invalid(_(\"Invalid vcpu_pin_set config, \"",
            "                                      \"out of hypervisor cpu range.\"))",
            "        return len(available_ids)",
            "",
            "    @staticmethod",
            "    def _get_local_gb_info():",
            "        \"\"\"Get local storage info of the compute node in GB.",
            "",
            "        :returns: A dict containing:",
            "             :total: How big the overall usable filesystem is (in gigabytes)",
            "             :free: How much space is free (in gigabytes)",
            "             :used: How much space is used (in gigabytes)",
            "        \"\"\"",
            "",
            "        if CONF.libvirt.images_type == 'lvm':",
            "            info = lvm.get_volume_group_info(",
            "                               CONF.libvirt.images_volume_group)",
            "        elif CONF.libvirt.images_type == 'rbd':",
            "            info = LibvirtDriver._get_rbd_driver().get_pool_info()",
            "        else:",
            "            info = libvirt_utils.get_fs_info(CONF.instances_path)",
            "",
            "        for (k, v) in six.iteritems(info):",
            "            info[k] = v / units.Gi",
            "",
            "        return info",
            "",
            "    def _get_vcpu_used(self):",
            "        \"\"\"Get vcpu usage number of physical computer.",
            "",
            "        :returns: The total number of vcpu(s) that are currently being used.",
            "",
            "        \"\"\"",
            "",
            "        total = 0",
            "        if CONF.libvirt.virt_type == 'lxc':",
            "            return total + 1",
            "",
            "        for guest in self._host.list_guests():",
            "            try:",
            "                vcpus = guest.get_vcpus_info()",
            "                if vcpus is not None:",
            "                    total += len(list(vcpus))",
            "            except libvirt.libvirtError as e:",
            "                LOG.warn(_LW(\"couldn't obtain the vcpu count from domain id:\"",
            "                             \" %(uuid)s, exception: %(ex)s\"),",
            "                         {\"uuid\": guest.uuid, \"ex\": e})",
            "            # NOTE(gtt116): give other tasks a chance.",
            "            greenthread.sleep(0)",
            "        return total",
            "",
            "    def _get_instance_capabilities(self):",
            "        \"\"\"Get hypervisor instance capabilities",
            "",
            "        Returns a list of tuples that describe instances the",
            "        hypervisor is capable of hosting.  Each tuple consists",
            "        of the triplet (arch, hypervisor_type, vm_mode).",
            "",
            "        :returns: List of tuples describing instance capabilities",
            "        \"\"\"",
            "        caps = self._host.get_capabilities()",
            "        instance_caps = list()",
            "        for g in caps.guests:",
            "            for dt in g.domtype:",
            "                instance_cap = (",
            "                    arch.canonicalize(g.arch),",
            "                    hv_type.canonicalize(dt),",
            "                    vm_mode.canonicalize(g.ostype))",
            "                instance_caps.append(instance_cap)",
            "",
            "        return instance_caps",
            "",
            "    def _get_cpu_info(self):",
            "        \"\"\"Get cpuinfo information.",
            "",
            "        Obtains cpu feature from virConnect.getCapabilities.",
            "",
            "        :return: see above description",
            "",
            "        \"\"\"",
            "",
            "        caps = self._host.get_capabilities()",
            "        cpu_info = dict()",
            "",
            "        cpu_info['arch'] = caps.host.cpu.arch",
            "        cpu_info['model'] = caps.host.cpu.model",
            "        cpu_info['vendor'] = caps.host.cpu.vendor",
            "",
            "        topology = dict()",
            "        topology['cells'] = len(getattr(caps.host.topology, 'cells', [1]))",
            "        topology['sockets'] = caps.host.cpu.sockets",
            "        topology['cores'] = caps.host.cpu.cores",
            "        topology['threads'] = caps.host.cpu.threads",
            "        cpu_info['topology'] = topology",
            "",
            "        features = set()",
            "        for f in caps.host.cpu.features:",
            "            features.add(f.name)",
            "        cpu_info['features'] = features",
            "        return cpu_info",
            "",
            "    def _get_pcidev_info(self, devname):",
            "        \"\"\"Returns a dict of PCI device.\"\"\"",
            "",
            "        def _get_device_type(cfgdev, pci_address):",
            "            \"\"\"Get a PCI device's device type.",
            "",
            "            An assignable PCI device can be a normal PCI device,",
            "            a SR-IOV Physical Function (PF), or a SR-IOV Virtual",
            "            Function (VF). Only normal PCI devices or SR-IOV VFs",
            "            are assignable, while SR-IOV PFs are always owned by",
            "            hypervisor.",
            "            \"\"\"",
            "            for fun_cap in cfgdev.pci_capability.fun_capability:",
            "                if fun_cap.type == 'virt_functions':",
            "                    return {",
            "                        'dev_type': fields.PciDeviceType.SRIOV_PF,",
            "                    }",
            "                if (fun_cap.type == 'phys_function' and",
            "                    len(fun_cap.device_addrs) != 0):",
            "                    phys_address = \"%04x:%02x:%02x.%01x\" % (",
            "                        fun_cap.device_addrs[0][0],",
            "                        fun_cap.device_addrs[0][1],",
            "                        fun_cap.device_addrs[0][2],",
            "                        fun_cap.device_addrs[0][3])",
            "                    return {",
            "                        'dev_type': fields.PciDeviceType.SRIOV_VF,",
            "                        'parent_addr': phys_address,",
            "                    }",
            "",
            "            # Note(moshele): libvirt < 1.3 reported virt_functions capability",
            "            # only when VFs are enabled. The check below is a workaround",
            "            # to get the correct report regardless of whether or not any",
            "            # VFs are enabled for the device.",
            "            if not self._host.has_min_version(",
            "                MIN_LIBVIRT_PF_WITH_NO_VFS_CAP_VERSION):",
            "                is_physical_function = pci_utils.is_physical_function(",
            "                    *pci_utils.get_pci_address_fields(pci_address))",
            "                if is_physical_function:",
            "                    return {'dev_type': fields.PciDeviceType.SRIOV_PF}",
            "",
            "            return {'dev_type': fields.PciDeviceType.STANDARD}",
            "",
            "        virtdev = self._host.device_lookup_by_name(devname)",
            "        xmlstr = virtdev.XMLDesc(0)",
            "        cfgdev = vconfig.LibvirtConfigNodeDevice()",
            "        cfgdev.parse_str(xmlstr)",
            "",
            "        address = \"%04x:%02x:%02x.%1x\" % (",
            "            cfgdev.pci_capability.domain,",
            "            cfgdev.pci_capability.bus,",
            "            cfgdev.pci_capability.slot,",
            "            cfgdev.pci_capability.function)",
            "",
            "        device = {",
            "            \"dev_id\": cfgdev.name,",
            "            \"address\": address,",
            "            \"product_id\": \"%04x\" % cfgdev.pci_capability.product_id,",
            "            \"vendor_id\": \"%04x\" % cfgdev.pci_capability.vendor_id,",
            "            }",
            "",
            "        device[\"numa_node\"] = cfgdev.pci_capability.numa_node",
            "",
            "        # requirement by DataBase Model",
            "        device['label'] = 'label_%(vendor_id)s_%(product_id)s' % device",
            "        device.update(_get_device_type(cfgdev, address))",
            "        return device",
            "",
            "    def _get_pci_passthrough_devices(self):",
            "        \"\"\"Get host PCI devices information.",
            "",
            "        Obtains pci devices information from libvirt, and returns",
            "        as a JSON string.",
            "",
            "        Each device information is a dictionary, with mandatory keys",
            "        of 'address', 'vendor_id', 'product_id', 'dev_type', 'dev_id',",
            "        'label' and other optional device specific information.",
            "",
            "        Refer to the objects/pci_device.py for more idea of these keys.",
            "",
            "        :returns: a JSON string containaing a list of the assignable PCI",
            "                  devices information",
            "        \"\"\"",
            "        # Bail early if we know we can't support `listDevices` to avoid",
            "        # repeated warnings within a periodic task",
            "        if not getattr(self, '_list_devices_supported', True):",
            "            return jsonutils.dumps([])",
            "",
            "        try:",
            "            dev_names = self._host.list_pci_devices() or []",
            "        except libvirt.libvirtError as ex:",
            "            error_code = ex.get_error_code()",
            "            if error_code == libvirt.VIR_ERR_NO_SUPPORT:",
            "                self._list_devices_supported = False",
            "                LOG.warn(_LW(\"URI %(uri)s does not support \"",
            "                             \"listDevices: %(error)s\"),",
            "                             {'uri': self._uri(), 'error': ex})",
            "                return jsonutils.dumps([])",
            "            else:",
            "                raise",
            "",
            "        pci_info = []",
            "        for name in dev_names:",
            "            pci_info.append(self._get_pcidev_info(name))",
            "",
            "        return jsonutils.dumps(pci_info)",
            "",
            "    def _has_numa_support(self):",
            "        # This means that the host can support LibvirtConfigGuestNUMATune",
            "        # and the nodeset field in LibvirtConfigGuestMemoryBackingPage",
            "        for ver in BAD_LIBVIRT_NUMA_VERSIONS:",
            "            if self._host.has_version(ver):",
            "                if not getattr(self, '_bad_libvirt_numa_version_warn', False):",
            "                    LOG.warn(_LW('You are running with libvirt version %s '",
            "                                 'which is known to have broken NUMA support. '",
            "                                 'Consider patching or updating libvirt on '",
            "                                 'this host if you need NUMA support.'),",
            "                             self._version_to_string(ver))",
            "                    self._bad_libvirt_numa_version_warn = True",
            "                return False",
            "",
            "        support_matrix = {(arch.I686, arch.X86_64): MIN_LIBVIRT_NUMA_VERSION,",
            "                          (arch.PPC64,",
            "                           arch.PPC64LE): MIN_LIBVIRT_NUMA_VERSION_PPC}",
            "        caps = self._host.get_capabilities()",
            "        is_supported = False",
            "        for archs, libvirt_ver in support_matrix.items():",
            "            if ((caps.host.cpu.arch in archs) and",
            "                    self._host.has_min_version(libvirt_ver,",
            "                                               MIN_QEMU_NUMA_HUGEPAGE_VERSION,",
            "                                               host.HV_DRIVER_QEMU)):",
            "                is_supported = True",
            "        return is_supported",
            "",
            "    def _has_hugepage_support(self):",
            "        # This means that the host can support multiple values for the size",
            "        # field in LibvirtConfigGuestMemoryBackingPage",
            "        supported_archs = [arch.I686, arch.X86_64]",
            "        caps = self._host.get_capabilities()",
            "        return ((caps.host.cpu.arch in supported_archs) and",
            "                self._host.has_min_version(MIN_LIBVIRT_HUGEPAGE_VERSION,",
            "                                           MIN_QEMU_NUMA_HUGEPAGE_VERSION,",
            "                                           host.HV_DRIVER_QEMU))",
            "",
            "    def _get_host_numa_topology(self):",
            "        if not self._has_numa_support():",
            "            return",
            "",
            "        caps = self._host.get_capabilities()",
            "        topology = caps.host.topology",
            "",
            "        if topology is None or not topology.cells:",
            "            return",
            "",
            "        cells = []",
            "        allowed_cpus = hardware.get_vcpu_pin_set()",
            "        online_cpus = self._host.get_online_cpus()",
            "        if allowed_cpus:",
            "            allowed_cpus &= online_cpus",
            "        else:",
            "            allowed_cpus = online_cpus",
            "",
            "        for cell in topology.cells:",
            "            cpuset = set(cpu.id for cpu in cell.cpus)",
            "            siblings = sorted(map(set,",
            "                                  set(tuple(cpu.siblings)",
            "                                        if cpu.siblings else ()",
            "                                      for cpu in cell.cpus)",
            "                                  ))",
            "            cpuset &= allowed_cpus",
            "            siblings = [sib & allowed_cpus for sib in siblings]",
            "            # Filter out singles and empty sibling sets that may be left",
            "            siblings = [sib for sib in siblings if len(sib) > 1]",
            "",
            "            mempages = []",
            "            if self._has_hugepage_support():",
            "                mempages = [",
            "                    objects.NUMAPagesTopology(",
            "                        size_kb=pages.size,",
            "                        total=pages.total,",
            "                        used=0)",
            "                    for pages in cell.mempages]",
            "",
            "            cell = objects.NUMACell(id=cell.id, cpuset=cpuset,",
            "                                    memory=cell.memory / units.Ki,",
            "                                    cpu_usage=0, memory_usage=0,",
            "                                    siblings=siblings,",
            "                                    pinned_cpus=set([]),",
            "                                    mempages=mempages)",
            "            cells.append(cell)",
            "",
            "        return objects.NUMATopology(cells=cells)",
            "",
            "    def get_all_volume_usage(self, context, compute_host_bdms):",
            "        \"\"\"Return usage info for volumes attached to vms on",
            "           a given host.",
            "        \"\"\"",
            "        vol_usage = []",
            "",
            "        for instance_bdms in compute_host_bdms:",
            "            instance = instance_bdms['instance']",
            "",
            "            for bdm in instance_bdms['instance_bdms']:",
            "                mountpoint = bdm['device_name']",
            "                if mountpoint.startswith('/dev/'):",
            "                    mountpoint = mountpoint[5:]",
            "                volume_id = bdm['volume_id']",
            "",
            "                LOG.debug(\"Trying to get stats for the volume %s\",",
            "                          volume_id, instance=instance)",
            "                vol_stats = self.block_stats(instance, mountpoint)",
            "",
            "                if vol_stats:",
            "                    stats = dict(volume=volume_id,",
            "                                 instance=instance,",
            "                                 rd_req=vol_stats[0],",
            "                                 rd_bytes=vol_stats[1],",
            "                                 wr_req=vol_stats[2],",
            "                                 wr_bytes=vol_stats[3])",
            "                    LOG.debug(",
            "                        \"Got volume usage stats for the volume=%(volume)s,\"",
            "                        \" rd_req=%(rd_req)d, rd_bytes=%(rd_bytes)d, \"",
            "                        \"wr_req=%(wr_req)d, wr_bytes=%(wr_bytes)d\",",
            "                        stats, instance=instance)",
            "                    vol_usage.append(stats)",
            "",
            "        return vol_usage",
            "",
            "    def block_stats(self, instance, disk_id):",
            "        \"\"\"Note that this function takes an instance name.\"\"\"",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "",
            "            # TODO(sahid): We are converting all calls from a",
            "            # virDomain object to use nova.virt.libvirt.Guest.",
            "            # We should be able to remove domain at the end.",
            "            domain = guest._domain",
            "            return domain.blockStats(disk_id)",
            "        except libvirt.libvirtError as e:",
            "            errcode = e.get_error_code()",
            "            LOG.info(_LI('Getting block stats failed, device might have '",
            "                         'been detached. Instance=%(instance_name)s '",
            "                         'Disk=%(disk)s Code=%(errcode)s Error=%(e)s'),",
            "                     {'instance_name': instance.name, 'disk': disk_id,",
            "                      'errcode': errcode, 'e': e},",
            "                     instance=instance)",
            "        except exception.InstanceNotFound:",
            "            LOG.info(_LI('Could not find domain in libvirt for instance %s. '",
            "                         'Cannot get block stats for device'), instance.name,",
            "                     instance=instance)",
            "",
            "    def get_console_pool_info(self, console_type):",
            "        # TODO(mdragon): console proxy should be implemented for libvirt,",
            "        #                in case someone wants to use it with kvm or",
            "        #                such. For now return fake data.",
            "        return {'address': '127.0.0.1',",
            "                'username': 'fakeuser',",
            "                'password': 'fakepassword'}",
            "",
            "    def refresh_security_group_rules(self, security_group_id):",
            "        self.firewall_driver.refresh_security_group_rules(security_group_id)",
            "",
            "    def refresh_instance_security_rules(self, instance):",
            "        self.firewall_driver.refresh_instance_security_rules(instance)",
            "",
            "    def get_available_resource(self, nodename):",
            "        \"\"\"Retrieve resource information.",
            "",
            "        This method is called when nova-compute launches, and",
            "        as part of a periodic task that records the results in the DB.",
            "",
            "        :param nodename: unused in this driver",
            "        :returns: dictionary containing resource info",
            "        \"\"\"",
            "",
            "        disk_info_dict = self._get_local_gb_info()",
            "        data = {}",
            "",
            "        # NOTE(dprince): calling capabilities before getVersion works around",
            "        # an initialization issue with some versions of Libvirt (1.0.5.5).",
            "        # See: https://bugzilla.redhat.com/show_bug.cgi?id=1000116",
            "        # See: https://bugs.launchpad.net/nova/+bug/1215593",
            "        data[\"supported_instances\"] = self._get_instance_capabilities()",
            "",
            "        data[\"vcpus\"] = self._get_vcpu_total()",
            "        data[\"memory_mb\"] = self._host.get_memory_mb_total()",
            "        data[\"local_gb\"] = disk_info_dict['total']",
            "        data[\"vcpus_used\"] = self._get_vcpu_used()",
            "        data[\"memory_mb_used\"] = self._host.get_memory_mb_used()",
            "        data[\"local_gb_used\"] = disk_info_dict['used']",
            "        data[\"hypervisor_type\"] = self._host.get_driver_type()",
            "        data[\"hypervisor_version\"] = self._host.get_version()",
            "        data[\"hypervisor_hostname\"] = self._host.get_hostname()",
            "        # TODO(berrange): why do we bother converting the",
            "        # libvirt capabilities XML into a special JSON format ?",
            "        # The data format is different across all the drivers",
            "        # so we could just return the raw capabilities XML",
            "        # which 'compare_cpu' could use directly",
            "        #",
            "        # That said, arch_filter.py now seems to rely on",
            "        # the libvirt drivers format which suggests this",
            "        # data format needs to be standardized across drivers",
            "        data[\"cpu_info\"] = jsonutils.dumps(self._get_cpu_info())",
            "",
            "        disk_free_gb = disk_info_dict['free']",
            "        disk_over_committed = self._get_disk_over_committed_size_total()",
            "        available_least = disk_free_gb * units.Gi - disk_over_committed",
            "        data['disk_available_least'] = available_least / units.Gi",
            "",
            "        data['pci_passthrough_devices'] = \\",
            "            self._get_pci_passthrough_devices()",
            "",
            "        numa_topology = self._get_host_numa_topology()",
            "        if numa_topology:",
            "            data['numa_topology'] = numa_topology._to_json()",
            "        else:",
            "            data['numa_topology'] = None",
            "",
            "        return data",
            "",
            "    def check_instance_shared_storage_local(self, context, instance):",
            "        \"\"\"Check if instance files located on shared storage.",
            "",
            "        This runs check on the destination host, and then calls",
            "        back to the source host to check the results.",
            "",
            "        :param context: security context",
            "        :param instance: nova.objects.instance.Instance object",
            "        :returns:",
            "         - tempfile: A dict containing the tempfile info on the destination",
            "                     host",
            "         - None:",
            "",
            "            1. If the instance path is not existing.",
            "            2. If the image backend is shared block storage type.",
            "        \"\"\"",
            "        if self.image_backend.backend().is_shared_block_storage():",
            "            return None",
            "",
            "        dirpath = libvirt_utils.get_instance_path(instance)",
            "",
            "        if not os.path.exists(dirpath):",
            "            return None",
            "",
            "        fd, tmp_file = tempfile.mkstemp(dir=dirpath)",
            "        LOG.debug(\"Creating tmpfile %s to verify with other \"",
            "                  \"compute node that the instance is on \"",
            "                  \"the same shared storage.\",",
            "                  tmp_file, instance=instance)",
            "        os.close(fd)",
            "        return {\"filename\": tmp_file}",
            "",
            "    def check_instance_shared_storage_remote(self, context, data):",
            "        return os.path.exists(data['filename'])",
            "",
            "    def check_instance_shared_storage_cleanup(self, context, data):",
            "        fileutils.delete_if_exists(data[\"filename\"])",
            "",
            "    def check_can_live_migrate_destination(self, context, instance,",
            "                                           src_compute_info, dst_compute_info,",
            "                                           block_migration=False,",
            "                                           disk_over_commit=False):",
            "        \"\"\"Check if it is possible to execute live migration.",
            "",
            "        This runs checks on the destination host, and then calls",
            "        back to the source host to check the results.",
            "",
            "        :param context: security context",
            "        :param instance: nova.db.sqlalchemy.models.Instance",
            "        :param block_migration: if true, prepare for block migration",
            "        :param disk_over_commit: if true, allow disk over commit",
            "        :returns: a LibvirtLiveMigrateData object",
            "        \"\"\"",
            "        disk_available_gb = dst_compute_info['disk_available_least']",
            "        disk_available_mb = (",
            "            (disk_available_gb * units.Ki) - CONF.reserved_host_disk_mb)",
            "",
            "        # Compare CPU",
            "        if not instance.vcpu_model or not instance.vcpu_model.model:",
            "            source_cpu_info = src_compute_info['cpu_info']",
            "            self._compare_cpu(None, source_cpu_info)",
            "        else:",
            "            self._compare_cpu(instance.vcpu_model, None)",
            "",
            "        # Create file on storage, to be checked on source host",
            "        filename = self._create_shared_storage_test_file()",
            "",
            "        data = objects.LibvirtLiveMigrateData()",
            "        data.filename = filename",
            "        data.image_type = CONF.libvirt.images_type",
            "        # Notes(eliqiao): block_migration and disk_over_commit are not",
            "        # nullable, so just don't set them if they are None",
            "        if block_migration is not None:",
            "            data.block_migration = block_migration",
            "        if disk_over_commit is not None:",
            "            data.disk_over_commit = disk_over_commit",
            "        data.disk_available_mb = disk_available_mb",
            "        return data",
            "",
            "    def check_can_live_migrate_destination_cleanup(self, context,",
            "                                                   dest_check_data):",
            "        \"\"\"Do required cleanup on dest host after check_can_live_migrate calls",
            "",
            "        :param context: security context",
            "        \"\"\"",
            "        filename = dest_check_data.filename",
            "        self._cleanup_shared_storage_test_file(filename)",
            "",
            "    def check_can_live_migrate_source(self, context, instance,",
            "                                      dest_check_data,",
            "                                      block_device_info=None):",
            "        \"\"\"Check if it is possible to execute live migration.",
            "",
            "        This checks if the live migration can succeed, based on the",
            "        results from check_can_live_migrate_destination.",
            "",
            "        :param context: security context",
            "        :param instance: nova.db.sqlalchemy.models.Instance",
            "        :param dest_check_data: result of check_can_live_migrate_destination",
            "        :param block_device_info: result of _get_instance_block_device_info",
            "        :returns: a LibvirtLiveMigrateData object",
            "        \"\"\"",
            "        # Checking shared storage connectivity",
            "        # if block migration, instances_paths should not be on shared storage.",
            "        source = CONF.host",
            "",
            "        if not isinstance(dest_check_data, migrate_data_obj.LiveMigrateData):",
            "            md_obj = objects.LibvirtLiveMigrateData()",
            "            md_obj.from_legacy_dict(dest_check_data)",
            "            dest_check_data = md_obj",
            "",
            "        dest_check_data.is_shared_instance_path = (",
            "            self._check_shared_storage_test_file(",
            "                dest_check_data.filename))",
            "",
            "        dest_check_data.is_shared_block_storage = (",
            "            self._is_shared_block_storage(instance, dest_check_data,",
            "                                          block_device_info))",
            "",
            "        disk_info_text = self.get_instance_disk_info(",
            "            instance, block_device_info=block_device_info)",
            "        booted_from_volume = self._is_booted_from_volume(instance,",
            "                                                         disk_info_text)",
            "        has_local_disk = self._has_local_disk(instance, disk_info_text)",
            "",
            "        if 'block_migration' not in dest_check_data:",
            "            dest_check_data.block_migration = (",
            "                not dest_check_data.is_on_shared_storage())",
            "",
            "        if dest_check_data.block_migration:",
            "            # TODO(eliqiao): Once block_migration flag is removed from the API",
            "            # we can safely remove the if condition",
            "            if dest_check_data.is_on_shared_storage():",
            "                reason = _(\"Block migration can not be used \"",
            "                           \"with shared storage.\")",
            "                raise exception.InvalidLocalStorage(reason=reason, path=source)",
            "            if 'disk_over_commit' in dest_check_data:",
            "                self._assert_dest_node_has_enough_disk(context, instance,",
            "                                        dest_check_data.disk_available_mb,",
            "                                        dest_check_data.disk_over_commit,",
            "                                        block_device_info)",
            "            if block_device_info:",
            "                bdm = block_device_info.get('block_device_mapping')",
            "                # NOTE(pkoniszewski): libvirt from version 1.2.17 upwards",
            "                # supports selective block device migration. It means that it",
            "                # is possible to define subset of block devices to be copied",
            "                # during migration. If they are not specified - block devices",
            "                # won't be migrated. However, it does not work when live",
            "                # migration is tunnelled through libvirt.",
            "                if bdm and not self._host.has_min_version(",
            "                        MIN_LIBVIRT_BLOCK_LM_WITH_VOLUMES_VERSION):",
            "                    # NOTE(stpierre): if this instance has mapped volumes,",
            "                    # we can't do a block migration, since that will result",
            "                    # in volumes being copied from themselves to themselves,",
            "                    # which is a recipe for disaster.",
            "                    ver = \".\".join([str(x) for x in",
            "                                    MIN_LIBVIRT_BLOCK_LM_WITH_VOLUMES_VERSION])",
            "                    msg = (_('Cannot block migrate instance %(uuid)s with'",
            "                             ' mapped volumes. Selective block device'",
            "                             ' migration feature requires libvirt version'",
            "                             ' %(libvirt_ver)s') %",
            "                           {'uuid': instance.uuid, 'libvirt_ver': ver})",
            "                    LOG.error(msg, instance=instance)",
            "                    raise exception.MigrationPreCheckError(reason=msg)",
            "        elif not (dest_check_data.is_shared_block_storage or",
            "                  dest_check_data.is_shared_instance_path or",
            "                  (booted_from_volume and not has_local_disk)):",
            "            reason = _(\"Live migration can not be used \"",
            "                       \"without shared storage except \"",
            "                       \"a booted from volume VM which \"",
            "                       \"does not have a local disk.\")",
            "            raise exception.InvalidSharedStorage(reason=reason, path=source)",
            "",
            "        # NOTE(mikal): include the instance directory name here because it",
            "        # doesn't yet exist on the destination but we want to force that",
            "        # same name to be used",
            "        instance_path = libvirt_utils.get_instance_path(instance,",
            "                                                        relative=True)",
            "        dest_check_data.instance_relative_path = instance_path",
            "",
            "        return dest_check_data",
            "",
            "    def _is_shared_block_storage(self, instance, dest_check_data,",
            "                                 block_device_info=None):",
            "        \"\"\"Check if all block storage of an instance can be shared",
            "        between source and destination of a live migration.",
            "",
            "        Returns true if the instance is volume backed and has no local disks,",
            "        or if the image backend is the same on source and destination and the",
            "        backend shares block storage between compute nodes.",
            "",
            "        :param instance: nova.objects.instance.Instance object",
            "        :param dest_check_data: dict with boolean fields image_type,",
            "                                is_shared_instance_path, and is_volume_backed",
            "        \"\"\"",
            "        if (dest_check_data.obj_attr_is_set('image_type') and",
            "                CONF.libvirt.images_type == dest_check_data.image_type and",
            "                self.image_backend.backend().is_shared_block_storage()):",
            "            # NOTE(dgenin): currently true only for RBD image backend",
            "            return True",
            "",
            "        if (dest_check_data.is_shared_instance_path and",
            "                self.image_backend.backend().is_file_in_instance_path()):",
            "            # NOTE(angdraug): file based image backends (Raw, Qcow2)",
            "            # place block device files under the instance path",
            "            return True",
            "",
            "        if (dest_check_data.is_volume_backed and",
            "                not bool(jsonutils.loads(",
            "                    self.get_instance_disk_info(instance,",
            "                                                block_device_info)))):",
            "            return True",
            "",
            "        return False",
            "",
            "    def _assert_dest_node_has_enough_disk(self, context, instance,",
            "                                             available_mb, disk_over_commit,",
            "                                             block_device_info=None):",
            "        \"\"\"Checks if destination has enough disk for block migration.\"\"\"",
            "        # Libvirt supports qcow2 disk format,which is usually compressed",
            "        # on compute nodes.",
            "        # Real disk image (compressed) may enlarged to \"virtual disk size\",",
            "        # that is specified as the maximum disk size.",
            "        # (See qemu-img -f path-to-disk)",
            "        # Scheduler recognizes destination host still has enough disk space",
            "        # if real disk size < available disk size",
            "        # if disk_over_commit is True,",
            "        #  otherwise virtual disk size < available disk size.",
            "",
            "        available = 0",
            "        if available_mb:",
            "            available = available_mb * units.Mi",
            "",
            "        ret = self.get_instance_disk_info(instance,",
            "                                          block_device_info=block_device_info)",
            "        disk_infos = jsonutils.loads(ret)",
            "",
            "        necessary = 0",
            "        if disk_over_commit:",
            "            for info in disk_infos:",
            "                necessary += int(info['disk_size'])",
            "        else:",
            "            for info in disk_infos:",
            "                necessary += int(info['virt_disk_size'])",
            "",
            "        # Check that available disk > necessary disk",
            "        if (available - necessary) < 0:",
            "            reason = (_('Unable to migrate %(instance_uuid)s: '",
            "                        'Disk of instance is too large(available'",
            "                        ' on destination host:%(available)s '",
            "                        '< need:%(necessary)s)') %",
            "                      {'instance_uuid': instance.uuid,",
            "                       'available': available,",
            "                       'necessary': necessary})",
            "            raise exception.MigrationPreCheckError(reason=reason)",
            "",
            "    def _compare_cpu(self, guest_cpu, host_cpu_str):",
            "        \"\"\"Check the host is compatible with the requested CPU",
            "",
            "        :param guest_cpu: nova.objects.VirtCPUModel or None",
            "        :param host_cpu_str: JSON from _get_cpu_info() method",
            "",
            "        If the 'guest_cpu' parameter is not None, this will be",
            "        validated for migration compatibility with the host.",
            "        Otherwise the 'host_cpu_str' JSON string will be used for",
            "        validation.",
            "",
            "        :returns:",
            "            None. if given cpu info is not compatible to this server,",
            "            raise exception.",
            "        \"\"\"",
            "",
            "        # NOTE(berendt): virConnectCompareCPU not working for Xen",
            "        if CONF.libvirt.virt_type not in ['qemu', 'kvm']:",
            "            return",
            "",
            "        if guest_cpu is None:",
            "            info = jsonutils.loads(host_cpu_str)",
            "            LOG.info(_LI('Instance launched has CPU info: %s'), host_cpu_str)",
            "            cpu = vconfig.LibvirtConfigCPU()",
            "            cpu.arch = info['arch']",
            "            cpu.model = info['model']",
            "            cpu.vendor = info['vendor']",
            "            cpu.sockets = info['topology']['sockets']",
            "            cpu.cores = info['topology']['cores']",
            "            cpu.threads = info['topology']['threads']",
            "            for f in info['features']:",
            "                cpu.add_feature(vconfig.LibvirtConfigCPUFeature(f))",
            "        else:",
            "            cpu = self._vcpu_model_to_cpu_config(guest_cpu)",
            "",
            "        u = (\"http://libvirt.org/html/libvirt-libvirt-host.html#\"",
            "             \"virCPUCompareResult\")",
            "        m = _(\"CPU doesn't have compatibility.\\n\\n%(ret)s\\n\\nRefer to %(u)s\")",
            "        # unknown character exists in xml, then libvirt complains",
            "        try:",
            "            ret = self._host.compare_cpu(cpu.to_xml())",
            "        except libvirt.libvirtError as e:",
            "            error_code = e.get_error_code()",
            "            if error_code == libvirt.VIR_ERR_NO_SUPPORT:",
            "                LOG.debug(\"URI %(uri)s does not support cpu comparison. \"",
            "                          \"It will be proceeded though. Error: %(error)s\",",
            "                          {'uri': self._uri(), 'error': e})",
            "                return",
            "            else:",
            "                LOG.error(m, {'ret': e, 'u': u})",
            "                raise exception.MigrationPreCheckError(",
            "                    reason=m % {'ret': e, 'u': u})",
            "",
            "        if ret <= 0:",
            "            LOG.error(m, {'ret': ret, 'u': u})",
            "            raise exception.InvalidCPUInfo(reason=m % {'ret': ret, 'u': u})",
            "",
            "    def _create_shared_storage_test_file(self):",
            "        \"\"\"Makes tmpfile under CONF.instances_path.\"\"\"",
            "        dirpath = CONF.instances_path",
            "        fd, tmp_file = tempfile.mkstemp(dir=dirpath)",
            "        LOG.debug(\"Creating tmpfile %s to notify to other \"",
            "                  \"compute nodes that they should mount \"",
            "                  \"the same storage.\", tmp_file)",
            "        os.close(fd)",
            "        return os.path.basename(tmp_file)",
            "",
            "    def _check_shared_storage_test_file(self, filename):",
            "        \"\"\"Confirms existence of the tmpfile under CONF.instances_path.",
            "",
            "        Cannot confirm tmpfile return False.",
            "        \"\"\"",
            "        tmp_file = os.path.join(CONF.instances_path, filename)",
            "        if not os.path.exists(tmp_file):",
            "            return False",
            "        else:",
            "            return True",
            "",
            "    def _cleanup_shared_storage_test_file(self, filename):",
            "        \"\"\"Removes existence of the tmpfile under CONF.instances_path.\"\"\"",
            "        tmp_file = os.path.join(CONF.instances_path, filename)",
            "        os.remove(tmp_file)",
            "",
            "    def ensure_filtering_rules_for_instance(self, instance, network_info):",
            "        \"\"\"Ensure that an instance's filtering rules are enabled.",
            "",
            "        When migrating an instance, we need the filtering rules to",
            "        be configured on the destination host before starting the",
            "        migration.",
            "",
            "        Also, when restarting the compute service, we need to ensure",
            "        that filtering rules exist for all running services.",
            "        \"\"\"",
            "",
            "        self.firewall_driver.setup_basic_filtering(instance, network_info)",
            "        self.firewall_driver.prepare_instance_filter(instance,",
            "                network_info)",
            "",
            "        # nwfilters may be defined in a separate thread in the case",
            "        # of libvirt non-blocking mode, so we wait for completion",
            "        timeout_count = list(range(CONF.live_migration_retry_count))",
            "        while timeout_count:",
            "            if self.firewall_driver.instance_filter_exists(instance,",
            "                                                           network_info):",
            "                break",
            "            timeout_count.pop()",
            "            if len(timeout_count) == 0:",
            "                msg = _('The firewall filter for %s does not exist')",
            "                raise exception.NovaException(msg % instance.name)",
            "            greenthread.sleep(1)",
            "",
            "    def filter_defer_apply_on(self):",
            "        self.firewall_driver.filter_defer_apply_on()",
            "",
            "    def filter_defer_apply_off(self):",
            "        self.firewall_driver.filter_defer_apply_off()",
            "",
            "    def live_migration(self, context, instance, dest,",
            "                       post_method, recover_method, block_migration=False,",
            "                       migrate_data=None):",
            "        \"\"\"Spawning live_migration operation for distributing high-load.",
            "",
            "        :param context: security context",
            "        :param instance:",
            "            nova.db.sqlalchemy.models.Instance object",
            "            instance object that is migrated.",
            "        :param dest: destination host",
            "        :param post_method:",
            "            post operation method.",
            "            expected nova.compute.manager._post_live_migration.",
            "        :param recover_method:",
            "            recovery method when any exception occurs.",
            "            expected nova.compute.manager._rollback_live_migration.",
            "        :param block_migration: if true, do block migration.",
            "        :param migrate_data: a LibvirtLiveMigrateData object",
            "",
            "        \"\"\"",
            "",
            "        # 'dest' will be substituted into 'migration_uri' so ensure",
            "        # it does't contain any characters that could be used to",
            "        # exploit the URI accepted by libivrt",
            "        if not libvirt_utils.is_valid_hostname(dest):",
            "            raise exception.InvalidHostname(hostname=dest)",
            "",
            "        self._live_migration(context, instance, dest,",
            "                             post_method, recover_method, block_migration,",
            "                             migrate_data)",
            "",
            "    def live_migration_abort(self, instance):",
            "        \"\"\"Aborting a running live-migration.",
            "",
            "        :param instance: instance object that is in migration",
            "",
            "        \"\"\"",
            "",
            "        guest = self._host.get_guest(instance)",
            "        dom = guest._domain",
            "",
            "        try:",
            "            dom.abortJob()",
            "        except libvirt.libvirtError as e:",
            "            LOG.error(_LE(\"Failed to cancel migration %s\"),",
            "                      e, instance=instance)",
            "            raise",
            "",
            "    def _update_xml(self, xml_str, migrate_bdm_info, listen_addrs,",
            "                    serial_listen_addr):",
            "        xml_doc = etree.fromstring(xml_str)",
            "",
            "        if migrate_bdm_info:",
            "            xml_doc = self._update_volume_xml(xml_doc, migrate_bdm_info)",
            "        if listen_addrs:",
            "            xml_doc = self._update_graphics_xml(xml_doc, listen_addrs)",
            "        else:",
            "            self._check_graphics_addresses_can_live_migrate(listen_addrs)",
            "        if serial_listen_addr:",
            "            xml_doc = self._update_serial_xml(xml_doc, serial_listen_addr)",
            "        else:",
            "            self._verify_serial_console_is_disabled()",
            "",
            "        return etree.tostring(xml_doc)",
            "",
            "    def _update_graphics_xml(self, xml_doc, listen_addrs):",
            "",
            "        # change over listen addresses",
            "        for dev in xml_doc.findall('./devices/graphics'):",
            "            gr_type = dev.get('type')",
            "            listen_tag = dev.find('listen')",
            "            if gr_type in ('vnc', 'spice'):",
            "                if listen_tag is not None:",
            "                    listen_tag.set('address', listen_addrs[gr_type])",
            "                if dev.get('listen') is not None:",
            "                    dev.set('listen', listen_addrs[gr_type])",
            "",
            "        return xml_doc",
            "",
            "    def _update_volume_xml(self, xml_doc, migrate_bdm_info):",
            "        \"\"\"Update XML using device information of destination host.\"\"\"",
            "",
            "        # Update volume xml",
            "        parser = etree.XMLParser(remove_blank_text=True)",
            "        disk_nodes = xml_doc.findall('./devices/disk')",
            "",
            "        bdm_info_by_serial = {x.serial: x for x in migrate_bdm_info}",
            "        for pos, disk_dev in enumerate(disk_nodes):",
            "            serial_source = disk_dev.findtext('serial')",
            "            bdm_info = bdm_info_by_serial.get(serial_source)",
            "            if (serial_source is None or",
            "                    not bdm_info or not bdm_info.connection_info or",
            "                    serial_source not in bdm_info_by_serial):",
            "                continue",
            "            conf = self._get_volume_config(",
            "                bdm_info.connection_info, bdm_info.as_disk_info())",
            "            xml_doc2 = etree.XML(conf.to_xml(), parser)",
            "            serial_dest = xml_doc2.findtext('serial')",
            "",
            "            # Compare source serial and destination serial number.",
            "            # If these serial numbers match, continue the process.",
            "            if (serial_dest and (serial_source == serial_dest)):",
            "                LOG.debug(\"Find same serial number: pos=%(pos)s, \"",
            "                          \"serial=%(num)s\",",
            "                          {'pos': pos, 'num': serial_source})",
            "                for cnt, item_src in enumerate(disk_dev):",
            "                    # If source and destination have same item, update",
            "                    # the item using destination value.",
            "                    for item_dst in xml_doc2.findall(item_src.tag):",
            "                        disk_dev.remove(item_src)",
            "                        item_dst.tail = None",
            "                        disk_dev.insert(cnt, item_dst)",
            "",
            "                # If destination has additional items, thses items should be",
            "                # added here.",
            "                for item_dst in list(xml_doc2):",
            "                    item_dst.tail = None",
            "                    disk_dev.insert(cnt, item_dst)",
            "",
            "        return xml_doc",
            "",
            "    def _update_serial_xml(self, xml_doc, listen_addr):",
            "        for dev in xml_doc.findall(\"./devices/serial[@type='tcp']/source\"):",
            "            if dev.get('host') is not None:",
            "                dev.set('host', listen_addr)",
            "",
            "        for dev in xml_doc.findall(\"./devices/console[@type='tcp']/source\"):",
            "            if dev.get('host') is not None:",
            "                dev.set('host', listen_addr)",
            "",
            "        return xml_doc",
            "",
            "    def _check_graphics_addresses_can_live_migrate(self, listen_addrs):",
            "        LOCAL_ADDRS = ('0.0.0.0', '127.0.0.1', '::', '::1')",
            "",
            "        local_vnc = CONF.vnc.vncserver_listen in LOCAL_ADDRS",
            "        local_spice = CONF.spice.server_listen in LOCAL_ADDRS",
            "",
            "        if ((CONF.vnc.enabled and not local_vnc) or",
            "            (CONF.spice.enabled and not local_spice)):",
            "",
            "            msg = _('Your libvirt version does not support the'",
            "                    ' VIR_DOMAIN_XML_MIGRATABLE flag or your'",
            "                    ' destination node does not support'",
            "                    ' retrieving listen addresses.  In order'",
            "                    ' for live migration to work properly, you'",
            "                    ' must configure the graphics (VNC and/or'",
            "                    ' SPICE) listen addresses to be either'",
            "                    ' the catch-all address (0.0.0.0 or ::) or'",
            "                    ' the local address (127.0.0.1 or ::1).')",
            "            raise exception.MigrationError(reason=msg)",
            "",
            "        if listen_addrs:",
            "            dest_local_vnc = listen_addrs.get('vnc') in LOCAL_ADDRS",
            "            dest_local_spice = listen_addrs.get('spice') in LOCAL_ADDRS",
            "",
            "            if ((CONF.vnc.enabled and not dest_local_vnc) or",
            "                (CONF.spice.enabled and not dest_local_spice)):",
            "",
            "                LOG.warn(_LW('Your libvirt version does not support the'",
            "                             ' VIR_DOMAIN_XML_MIGRATABLE flag, and the'",
            "                             ' graphics (VNC and/or SPICE) listen'",
            "                             ' addresses on the destination node do not'",
            "                             ' match the addresses on the source node.'",
            "                             ' Since the source node has listen'",
            "                             ' addresses set to either the catch-all'",
            "                             ' address (0.0.0.0 or ::) or the local'",
            "                             ' address (127.0.0.1 or ::1), the live'",
            "                             ' migration will succeed, but the VM will'",
            "                             ' continue to listen on the current'",
            "                             ' addresses.'))",
            "",
            "    def _verify_serial_console_is_disabled(self):",
            "        if CONF.serial_console.enabled:",
            "",
            "            msg = _('Your libvirt version does not support the'",
            "                    ' VIR_DOMAIN_XML_MIGRATABLE flag or your'",
            "                    ' destination node does not support'",
            "                    ' retrieving listen addresses.  In order'",
            "                    ' for live migration to work properly you'",
            "                    ' must either disable serial console or'",
            "                    ' upgrade your libvirt version.')",
            "            raise exception.MigrationError(reason=msg)",
            "",
            "    def _live_migration_operation(self, context, instance, dest,",
            "                                  block_migration, migrate_data, dom,",
            "                                  device_names):",
            "        \"\"\"Invoke the live migration operation",
            "",
            "        :param context: security context",
            "        :param instance:",
            "            nova.db.sqlalchemy.models.Instance object",
            "            instance object that is migrated.",
            "        :param dest: destination host",
            "        :param block_migration: if true, do block migration.",
            "        :param migrate_data: a LibvirtLiveMigrateData object",
            "        :param dom: the libvirt domain object",
            "        :param device_names: list of device names that are being migrated with",
            "            instance",
            "",
            "        This method is intended to be run in a background thread and will",
            "        block that thread until the migration is finished or failed.",
            "        \"\"\"",
            "        # TODO(sahid): Should pass a guest to this method.",
            "        guest = libvirt_guest.Guest(dom)",
            "",
            "        try:",
            "            if block_migration:",
            "                migration_flags = self._block_migration_flags",
            "            else:",
            "                migration_flags = self._live_migration_flags",
            "",
            "            listen_addrs = {}",
            "            if 'graphics_listen_addr_vnc' in migrate_data:",
            "                listen_addrs['vnc'] = str(",
            "                    migrate_data.graphics_listen_addr_vnc)",
            "            if 'graphics_listen_addr_spice' in migrate_data:",
            "                listen_addrs['spice'] = str(",
            "                    migrate_data.graphics_listen_addr_spice)",
            "            serial_listen_addr = migrate_data.serial_listen_addr",
            "            if migrate_data.target_connect_addr is not None:",
            "                dest = migrate_data.target_connect_addr",
            "",
            "            migratable_flag = getattr(libvirt, 'VIR_DOMAIN_XML_MIGRATABLE',",
            "                                      None)",
            "",
            "            if (migratable_flag is None or (",
            "                    not listen_addrs and not migrate_data.bdms)):",
            "                # TODO(alexs-h): These checks could be moved to the",
            "                # check_can_live_migrate_destination/source phase",
            "                self._check_graphics_addresses_can_live_migrate(listen_addrs)",
            "                self._verify_serial_console_is_disabled()",
            "                dom.migrateToURI(self._live_migration_uri(dest),",
            "                                 migration_flags,",
            "                                 None,",
            "                                 CONF.libvirt.live_migration_bandwidth)",
            "            else:",
            "                old_xml_str = guest.get_xml_desc(dump_migratable=True)",
            "                new_xml_str = self._update_xml(old_xml_str,",
            "                                               migrate_data.bdms,",
            "                                               listen_addrs,",
            "                                               serial_listen_addr)",
            "                try:",
            "                    if self._host.has_min_version(",
            "                            MIN_LIBVIRT_BLOCK_LM_WITH_VOLUMES_VERSION):",
            "                        params = {",
            "                            'bandwidth': CONF.libvirt.live_migration_bandwidth,",
            "                            'destination_xml': new_xml_str,",
            "                            'migrate_disks': device_names,",
            "                        }",
            "                        dom.migrateToURI3(",
            "                            self._live_migration_uri(dest),",
            "                            params,",
            "                            migration_flags)",
            "                    else:",
            "                        dom.migrateToURI2(",
            "                            self._live_migration_uri(dest),",
            "                            None,",
            "                            new_xml_str,",
            "                            migration_flags,",
            "                            None,",
            "                            CONF.libvirt.live_migration_bandwidth)",
            "                except libvirt.libvirtError as ex:",
            "                    # NOTE(mriedem): There is a bug in older versions of",
            "                    # libvirt where the VIR_DOMAIN_XML_MIGRATABLE flag causes",
            "                    # virDomainDefCheckABIStability to not compare the source",
            "                    # and target domain xml's correctly for the CPU model.",
            "                    # We try to handle that error here and attempt the legacy",
            "                    # migrateToURI path, which could fail if the console",
            "                    # addresses are not correct, but in that case we have the",
            "                    # _check_graphics_addresses_can_live_migrate check in place",
            "                    # to catch it.",
            "                    # TODO(mriedem): Remove this workaround when",
            "                    # Red Hat BZ #1141838 is closed.",
            "                    error_code = ex.get_error_code()",
            "                    if error_code == libvirt.VIR_ERR_CONFIG_UNSUPPORTED:",
            "                        LOG.warn(_LW('An error occurred trying to live '",
            "                                     'migrate. Falling back to legacy live '",
            "                                     'migrate flow. Error: %s'), ex,",
            "                                 instance=instance)",
            "                        self._check_graphics_addresses_can_live_migrate(",
            "                            listen_addrs)",
            "                        self._verify_serial_console_is_disabled()",
            "                        dom.migrateToURI(",
            "                            self._live_migration_uri(dest),",
            "                            migration_flags,",
            "                            None,",
            "                            CONF.libvirt.live_migration_bandwidth)",
            "                    else:",
            "                        raise",
            "        except Exception as e:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.error(_LE(\"Live Migration failure: %s\"), e,",
            "                          instance=instance)",
            "",
            "        # If 'migrateToURI' fails we don't know what state the",
            "        # VM instances on each host are in. Possibilities include",
            "        #",
            "        #  1. src==running, dst==none",
            "        #",
            "        #     Migration failed & rolled back, or never started",
            "        #",
            "        #  2. src==running, dst==paused",
            "        #",
            "        #     Migration started but is still ongoing",
            "        #",
            "        #  3. src==paused,  dst==paused",
            "        #",
            "        #     Migration data transfer completed, but switchover",
            "        #     is still ongoing, or failed",
            "        #",
            "        #  4. src==paused,  dst==running",
            "        #",
            "        #     Migration data transfer completed, switchover",
            "        #     happened but cleanup on source failed",
            "        #",
            "        #  5. src==none,    dst==running",
            "        #",
            "        #     Migration fully succeeded.",
            "        #",
            "        # Libvirt will aim to complete any migration operation",
            "        # or roll it back. So even if the migrateToURI call has",
            "        # returned an error, if the migration was not finished",
            "        # libvirt should clean up.",
            "        #",
            "        # So we take the error raise here with a pinch of salt",
            "        # and rely on the domain job info status to figure out",
            "        # what really happened to the VM, which is a much more",
            "        # reliable indicator.",
            "        #",
            "        # In particular we need to try very hard to ensure that",
            "        # Nova does not \"forget\" about the guest. ie leaving it",
            "        # running on a different host to the one recorded in",
            "        # the database, as that would be a serious resource leak",
            "",
            "        LOG.debug(\"Migration operation thread has finished\",",
            "                  instance=instance)",
            "",
            "    @staticmethod",
            "    def _migration_downtime_steps(data_gb):",
            "        '''Calculate downtime value steps and time between increases.",
            "",
            "        :param data_gb: total GB of RAM and disk to transfer",
            "",
            "        This looks at the total downtime steps and upper bound",
            "        downtime value and uses an exponential backoff. So initially",
            "        max downtime is increased by small amounts, and as time goes",
            "        by it is increased by ever larger amounts",
            "",
            "        For example, with 10 steps, 30 second step delay, 3 GB",
            "        of RAM and 400ms target maximum downtime, the downtime will",
            "        be increased every 90 seconds in the following progression:",
            "",
            "        -   0 seconds -> set downtime to  37ms",
            "        -  90 seconds -> set downtime to  38ms",
            "        - 180 seconds -> set downtime to  39ms",
            "        - 270 seconds -> set downtime to  42ms",
            "        - 360 seconds -> set downtime to  46ms",
            "        - 450 seconds -> set downtime to  55ms",
            "        - 540 seconds -> set downtime to  70ms",
            "        - 630 seconds -> set downtime to  98ms",
            "        - 720 seconds -> set downtime to 148ms",
            "        - 810 seconds -> set downtime to 238ms",
            "        - 900 seconds -> set downtime to 400ms",
            "",
            "        This allows the guest a good chance to complete migration",
            "        with a small downtime value.",
            "        '''",
            "        downtime = CONF.libvirt.live_migration_downtime",
            "        steps = CONF.libvirt.live_migration_downtime_steps",
            "        delay = CONF.libvirt.live_migration_downtime_delay",
            "",
            "        if downtime < LIVE_MIGRATION_DOWNTIME_MIN:",
            "            downtime = LIVE_MIGRATION_DOWNTIME_MIN",
            "        if steps < LIVE_MIGRATION_DOWNTIME_STEPS_MIN:",
            "            steps = LIVE_MIGRATION_DOWNTIME_STEPS_MIN",
            "        if delay < LIVE_MIGRATION_DOWNTIME_DELAY_MIN:",
            "            delay = LIVE_MIGRATION_DOWNTIME_DELAY_MIN",
            "        delay = int(delay * data_gb)",
            "",
            "        offset = downtime / float(steps + 1)",
            "        base = (downtime - offset) ** (1 / float(steps))",
            "",
            "        for i in range(steps + 1):",
            "            yield (int(delay * i), int(offset + base ** i))",
            "",
            "    def _live_migration_copy_disk_paths(self, context, instance, guest):",
            "        '''Get list of disks to copy during migration",
            "",
            "        :param context: security context",
            "        :param instance: the instance being migrated",
            "        :param guest: the Guest instance being migrated",
            "",
            "        Get the list of disks to copy during migration.",
            "",
            "        :returns: a list of local source paths and a list of device names to",
            "            copy",
            "        '''",
            "",
            "        disk_paths = []",
            "        device_names = []",
            "        block_devices = []",
            "",
            "        # TODO(pkoniszewski): Remove this if-statement when we bump min libvirt",
            "        # version to >= 1.2.17",
            "        if self._host.has_min_version(",
            "                MIN_LIBVIRT_BLOCK_LM_WITH_VOLUMES_VERSION):",
            "            bdm_list = objects.BlockDeviceMappingList.get_by_instance_uuid(",
            "                context, instance.uuid)",
            "            block_device_info = driver.get_block_device_info(instance,",
            "                                                             bdm_list)",
            "",
            "            block_device_mappings = driver.block_device_info_get_mapping(",
            "                block_device_info)",
            "            for bdm in block_device_mappings:",
            "                device_name = str(bdm['mount_device'].rsplit('/', 1)[1])",
            "                block_devices.append(device_name)",
            "",
            "        for dev in guest.get_all_disks():",
            "            if dev.readonly or dev.shareable:",
            "                continue",
            "            if dev.source_type not in [\"file\", \"block\"]:",
            "                continue",
            "            if dev.target_dev in block_devices:",
            "                continue",
            "            disk_paths.append(dev.source_path)",
            "            device_names.append(dev.target_dev)",
            "        return (disk_paths, device_names)",
            "",
            "    def _live_migration_data_gb(self, instance, disk_paths):",
            "        '''Calculate total amount of data to be transferred",
            "",
            "        :param instance: the nova.objects.Instance being migrated",
            "        :param disk_paths: list of disk paths that are being migrated",
            "        with instance",
            "",
            "        Calculates the total amount of data that needs to be",
            "        transferred during the live migration. The actual",
            "        amount copied will be larger than this, due to the",
            "        guest OS continuing to dirty RAM while the migration",
            "        is taking place. So this value represents the minimal",
            "        data size possible.",
            "",
            "        :returns: data size to be copied in GB",
            "        '''",
            "",
            "        ram_gb = instance.flavor.memory_mb * units.Mi / units.Gi",
            "        if ram_gb < 2:",
            "            ram_gb = 2",
            "",
            "        disk_gb = 0",
            "        for path in disk_paths:",
            "            try:",
            "                size = os.stat(path).st_size",
            "                size_gb = (size / units.Gi)",
            "                if size_gb < 2:",
            "                    size_gb = 2",
            "                disk_gb += size_gb",
            "            except OSError as e:",
            "                LOG.warn(_LW(\"Unable to stat %(disk)s: %(ex)s\"),",
            "                         {'disk': path, 'ex': e})",
            "                # Ignore error since we don't want to break",
            "                # the migration monitoring thread operation",
            "",
            "        return ram_gb + disk_gb",
            "",
            "    def _live_migration_monitor(self, context, instance, guest,",
            "                                dest, post_method,",
            "                                recover_method, block_migration,",
            "                                migrate_data, dom, finish_event,",
            "                                disk_paths):",
            "        data_gb = self._live_migration_data_gb(instance, disk_paths)",
            "        downtime_steps = list(self._migration_downtime_steps(data_gb))",
            "        completion_timeout = int(",
            "            CONF.libvirt.live_migration_completion_timeout * data_gb)",
            "        progress_timeout = CONF.libvirt.live_migration_progress_timeout",
            "        migration = migrate_data.migration",
            "",
            "        n = 0",
            "        start = time.time()",
            "        progress_time = start",
            "        progress_watermark = None",
            "        while True:",
            "            info = host.DomainJobInfo.for_domain(dom)",
            "",
            "            if info.type == libvirt.VIR_DOMAIN_JOB_NONE:",
            "                # Annoyingly this could indicate many possible",
            "                # states, so we must fix the mess:",
            "                #",
            "                #   1. Migration has not yet begun",
            "                #   2. Migration has stopped due to failure",
            "                #   3. Migration has stopped due to completion",
            "                #",
            "                # We can detect option 1 by seeing if thread is still",
            "                # running. We can distinguish 2 vs 3 by seeing if the",
            "                # VM still exists & running on the current host",
            "                #",
            "                if not finish_event.ready():",
            "                    LOG.debug(\"Operation thread is still running\",",
            "                              instance=instance)",
            "                    # Leave type untouched",
            "                else:",
            "                    try:",
            "                        if guest.is_active():",
            "                            LOG.debug(\"VM running on src, migration failed\",",
            "                                      instance=instance)",
            "                            info.type = libvirt.VIR_DOMAIN_JOB_FAILED",
            "                        else:",
            "                            LOG.debug(\"VM is shutoff, migration finished\",",
            "                                      instance=instance)",
            "                            info.type = libvirt.VIR_DOMAIN_JOB_COMPLETED",
            "                    except libvirt.libvirtError as ex:",
            "                        LOG.debug(\"Error checking domain status %(ex)s\",",
            "                                  ex, instance=instance)",
            "                        if ex.get_error_code() == libvirt.VIR_ERR_NO_DOMAIN:",
            "                            LOG.debug(\"VM is missing, migration finished\",",
            "                                      instance=instance)",
            "                            info.type = libvirt.VIR_DOMAIN_JOB_COMPLETED",
            "                        else:",
            "                            LOG.info(_LI(\"Error %(ex)s, migration failed\"),",
            "                                     instance=instance)",
            "                            info.type = libvirt.VIR_DOMAIN_JOB_FAILED",
            "",
            "                if info.type != libvirt.VIR_DOMAIN_JOB_NONE:",
            "                    LOG.debug(\"Fixed incorrect job type to be %d\",",
            "                              info.type, instance=instance)",
            "",
            "            if info.type == libvirt.VIR_DOMAIN_JOB_NONE:",
            "                # Migration is not yet started",
            "                LOG.debug(\"Migration not running yet\",",
            "                          instance=instance)",
            "            elif info.type == libvirt.VIR_DOMAIN_JOB_UNBOUNDED:",
            "                # Migration is still running",
            "                #",
            "                # This is where we wire up calls to change live",
            "                # migration status. eg change max downtime, cancel",
            "                # the operation, change max bandwidth",
            "                now = time.time()",
            "                elapsed = now - start",
            "                abort = False",
            "",
            "                if ((progress_watermark is None) or",
            "                    (progress_watermark > info.data_remaining)):",
            "                    progress_watermark = info.data_remaining",
            "                    progress_time = now",
            "",
            "                if (progress_timeout != 0 and",
            "                    (now - progress_time) > progress_timeout):",
            "                    LOG.warn(_LW(\"Live migration stuck for %d sec\"),",
            "                             (now - progress_time), instance=instance)",
            "                    abort = True",
            "",
            "                if (completion_timeout != 0 and",
            "                    elapsed > completion_timeout):",
            "                    LOG.warn(_LW(\"Live migration not completed after %d sec\"),",
            "                             completion_timeout, instance=instance)",
            "                    abort = True",
            "",
            "                if abort:",
            "                    try:",
            "                        dom.abortJob()",
            "                    except libvirt.libvirtError as e:",
            "                        LOG.warn(_LW(\"Failed to abort migration %s\"),",
            "                                 e, instance=instance)",
            "                        raise",
            "",
            "                # See if we need to increase the max downtime. We",
            "                # ignore failures, since we'd rather continue trying",
            "                # to migrate",
            "                if (len(downtime_steps) > 0 and",
            "                    elapsed > downtime_steps[0][0]):",
            "                    downtime = downtime_steps.pop(0)",
            "                    LOG.info(_LI(\"Increasing downtime to %(downtime)d ms \"",
            "                                 \"after %(waittime)d sec elapsed time\"),",
            "                             {\"downtime\": downtime[1],",
            "                              \"waittime\": downtime[0]},",
            "                             instance=instance)",
            "",
            "                    try:",
            "                        dom.migrateSetMaxDowntime(downtime[1])",
            "                    except libvirt.libvirtError as e:",
            "                        LOG.warn(",
            "                            _LW(\"Unable to increase max downtime to %(time)d\"",
            "                                \"ms: %(e)s\"),",
            "                            {\"time\": downtime[1], \"e\": e}, instance=instance)",
            "",
            "                # We loop every 500ms, so don't log on every",
            "                # iteration to avoid spamming logs for long",
            "                # running migrations. Just once every 5 secs",
            "                # is sufficient for developers to debug problems.",
            "                # We log once every 30 seconds at info to help",
            "                # admins see slow running migration operations",
            "                # when debug logs are off.",
            "                if (n % 10) == 0:",
            "                    # Note(Shaohe Feng) every 5 secs to update the migration",
            "                    # db, that keeps updates to the instance and migration",
            "                    # objects in sync.",
            "                    migration.memory_total = info.memory_total",
            "                    migration.memory_processed = info.memory_processed",
            "                    migration.memory_remaining = info.memory_remaining",
            "                    migration.disk_total = info.disk_total",
            "                    migration.disk_processed = info.disk_processed",
            "                    migration.disk_remaining = info.disk_remaining",
            "                    migration.save()",
            "                    # Ignoring memory_processed, as due to repeated",
            "                    # dirtying of data, this can be way larger than",
            "                    # memory_total. Best to just look at what's",
            "                    # remaining to copy and ignore what's done already",
            "                    #",
            "                    # TODO(berrange) perhaps we could include disk",
            "                    # transfer stats in the progress too, but it",
            "                    # might make memory info more obscure as large",
            "                    # disk sizes might dwarf memory size",
            "                    remaining = 100",
            "                    if info.memory_total != 0:",
            "                        remaining = round(info.memory_remaining *",
            "                                          100 / info.memory_total)",
            "                    instance.progress = 100 - remaining",
            "                    instance.save()",
            "",
            "                    lg = LOG.debug",
            "                    if (n % 60) == 0:",
            "                        lg = LOG.info",
            "",
            "                    lg(_LI(\"Migration running for %(secs)d secs, \"",
            "                           \"memory %(remaining)d%% remaining; \"",
            "                           \"(bytes processed=%(processed_memory)d, \"",
            "                           \"remaining=%(remaining_memory)d, \"",
            "                           \"total=%(total_memory)d)\"),",
            "                       {\"secs\": n / 2, \"remaining\": remaining,",
            "                        \"processed_memory\": info.memory_processed,",
            "                        \"remaining_memory\": info.memory_remaining,",
            "                        \"total_memory\": info.memory_total}, instance=instance)",
            "                    if info.data_remaining > progress_watermark:",
            "                        lg(_LI(\"Data remaining %(remaining)d bytes, \"",
            "                               \"low watermark %(watermark)d bytes \"",
            "                               \"%(last)d seconds ago\"),",
            "                           {\"remaining\": info.data_remaining,",
            "                            \"watermark\": progress_watermark,",
            "                            \"last\": (now - progress_time)}, instance=instance)",
            "",
            "                n = n + 1",
            "            elif info.type == libvirt.VIR_DOMAIN_JOB_COMPLETED:",
            "                # Migration is all done",
            "                LOG.info(_LI(\"Migration operation has completed\"),",
            "                         instance=instance)",
            "                post_method(context, instance, dest, block_migration,",
            "                            migrate_data)",
            "                break",
            "            elif info.type == libvirt.VIR_DOMAIN_JOB_FAILED:",
            "                # Migration did not succeed",
            "                LOG.error(_LE(\"Migration operation has aborted\"),",
            "                          instance=instance)",
            "                recover_method(context, instance, dest, block_migration,",
            "                               migrate_data)",
            "                break",
            "            elif info.type == libvirt.VIR_DOMAIN_JOB_CANCELLED:",
            "                # Migration was stopped by admin",
            "                LOG.warn(_LW(\"Migration operation was cancelled\"),",
            "                         instance=instance)",
            "                recover_method(context, instance, dest, block_migration,",
            "                               migrate_data, migration_status='cancelled')",
            "                break",
            "            else:",
            "                LOG.warn(_LW(\"Unexpected migration job type: %d\"),",
            "                         info.type, instance=instance)",
            "",
            "            time.sleep(0.5)",
            "",
            "    def _live_migration(self, context, instance, dest, post_method,",
            "                        recover_method, block_migration,",
            "                        migrate_data):",
            "        \"\"\"Do live migration.",
            "",
            "        :param context: security context",
            "        :param instance:",
            "            nova.db.sqlalchemy.models.Instance object",
            "            instance object that is migrated.",
            "        :param dest: destination host",
            "        :param post_method:",
            "            post operation method.",
            "            expected nova.compute.manager._post_live_migration.",
            "        :param recover_method:",
            "            recovery method when any exception occurs.",
            "            expected nova.compute.manager._rollback_live_migration.",
            "        :param block_migration: if true, do block migration.",
            "        :param migrate_data: a LibvirtLiveMigrateData object",
            "",
            "        This fires off a new thread to run the blocking migration",
            "        operation, and then this thread monitors the progress of",
            "        migration and controls its operation",
            "        \"\"\"",
            "",
            "        guest = self._host.get_guest(instance)",
            "",
            "        disk_paths = []",
            "        device_names = []",
            "        if block_migration:",
            "            disk_paths, device_names = self._live_migration_copy_disk_paths(",
            "                context, instance, guest)",
            "",
            "        # TODO(sahid): We are converting all calls from a",
            "        # virDomain object to use nova.virt.libvirt.Guest.",
            "        # We should be able to remove dom at the end.",
            "        dom = guest._domain",
            "",
            "        opthread = utils.spawn(self._live_migration_operation,",
            "                                     context, instance, dest,",
            "                                     block_migration,",
            "                                     migrate_data, dom,",
            "                                     device_names)",
            "",
            "        finish_event = eventlet.event.Event()",
            "",
            "        def thread_finished(thread, event):",
            "            LOG.debug(\"Migration operation thread notification\",",
            "                      instance=instance)",
            "            event.send()",
            "        opthread.link(thread_finished, finish_event)",
            "",
            "        # Let eventlet schedule the new thread right away",
            "        time.sleep(0)",
            "",
            "        try:",
            "            LOG.debug(\"Starting monitoring of live migration\",",
            "                      instance=instance)",
            "            self._live_migration_monitor(context, instance, guest, dest,",
            "                                         post_method, recover_method,",
            "                                         block_migration, migrate_data,",
            "                                         dom, finish_event, disk_paths)",
            "        except Exception as ex:",
            "            LOG.warn(_LW(\"Error monitoring migration: %(ex)s\"),",
            "                     {\"ex\": ex}, instance=instance, exc_info=True)",
            "            raise",
            "        finally:",
            "            LOG.debug(\"Live migration monitoring is all done\",",
            "                      instance=instance)",
            "",
            "    def live_migration_force_complete(self, instance):",
            "        # NOTE(pkoniszewski): currently only pause during live migration is",
            "        # supported to force live migration to complete, so just try to pause",
            "        # the instance",
            "        self.pause(instance)",
            "",
            "    def _try_fetch_image(self, context, path, image_id, instance,",
            "                         fallback_from_host=None):",
            "        try:",
            "            libvirt_utils.fetch_image(context, path,",
            "                                      image_id,",
            "                                      instance.user_id,",
            "                                      instance.project_id)",
            "        except exception.ImageNotFound:",
            "            if not fallback_from_host:",
            "                raise",
            "            LOG.debug(\"Image %(image_id)s doesn't exist anymore on \"",
            "                      \"image service, attempting to copy image \"",
            "                      \"from %(host)s\",",
            "                      {'image_id': image_id, 'host': fallback_from_host})",
            "            libvirt_utils.copy_image(src=path, dest=path,",
            "                                     host=fallback_from_host,",
            "                                     receive=True)",
            "",
            "    def _fetch_instance_kernel_ramdisk(self, context, instance,",
            "                                       fallback_from_host=None):",
            "        \"\"\"Download kernel and ramdisk for instance in instance directory.\"\"\"",
            "        instance_dir = libvirt_utils.get_instance_path(instance)",
            "        if instance.kernel_id:",
            "            kernel_path = os.path.join(instance_dir, 'kernel')",
            "            # NOTE(dsanders): only fetch image if it's not available at",
            "            # kernel_path. This also avoids ImageNotFound exception if",
            "            # the image has been deleted from glance",
            "            if not os.path.exists(kernel_path):",
            "                self._try_fetch_image(context,",
            "                                      kernel_path,",
            "                                      instance.kernel_id,",
            "                                      instance, fallback_from_host)",
            "            if instance.ramdisk_id:",
            "                ramdisk_path = os.path.join(instance_dir, 'ramdisk')",
            "                # NOTE(dsanders): only fetch image if it's not available at",
            "                # ramdisk_path. This also avoids ImageNotFound exception if",
            "                # the image has been deleted from glance",
            "                if not os.path.exists(ramdisk_path):",
            "                    self._try_fetch_image(context,",
            "                                          ramdisk_path,",
            "                                          instance.ramdisk_id,",
            "                                          instance, fallback_from_host)",
            "",
            "    def rollback_live_migration_at_destination(self, context, instance,",
            "                                               network_info,",
            "                                               block_device_info,",
            "                                               destroy_disks=True,",
            "                                               migrate_data=None):",
            "        \"\"\"Clean up destination node after a failed live migration.\"\"\"",
            "        try:",
            "            self.destroy(context, instance, network_info, block_device_info,",
            "                         destroy_disks, migrate_data)",
            "        finally:",
            "            # NOTE(gcb): Failed block live migration may leave instance",
            "            # directory at destination node, ensure it is always deleted.",
            "            is_shared_instance_path = True",
            "            if migrate_data:",
            "                is_shared_instance_path = migrate_data.is_shared_instance_path",
            "            if not is_shared_instance_path:",
            "                instance_dir = libvirt_utils.get_instance_path_at_destination(",
            "                    instance, migrate_data)",
            "                if os.path.exists(instance_dir):",
            "                        shutil.rmtree(instance_dir)",
            "",
            "    def pre_live_migration(self, context, instance, block_device_info,",
            "                           network_info, disk_info, migrate_data=None):",
            "        \"\"\"Preparation live migration.\"\"\"",
            "        if disk_info is not None:",
            "            disk_info = jsonutils.loads(disk_info)",
            "",
            "        # Steps for volume backed instance live migration w/o shared storage.",
            "        is_shared_block_storage = True",
            "        is_shared_instance_path = True",
            "        is_block_migration = True",
            "        if migrate_data:",
            "            if not isinstance(migrate_data, migrate_data_obj.LiveMigrateData):",
            "                obj = objects.LibvirtLiveMigrateData()",
            "                obj.from_legacy_dict(migrate_data)",
            "                migrate_data = obj",
            "            LOG.debug('migrate_data in pre_live_migration: %s', migrate_data,",
            "                      instance=instance)",
            "            is_shared_block_storage = migrate_data.is_shared_block_storage",
            "            is_shared_instance_path = migrate_data.is_shared_instance_path",
            "            is_block_migration = migrate_data.block_migration",
            "",
            "        if configdrive.required_by(instance):",
            "                # NOTE(sileht): configdrive is stored into the block storage",
            "                # kvm is a block device, live migration will work",
            "                # NOTE(sileht): the configdrive is stored into a shared path",
            "                # kvm don't need to migrate it, live migration will work",
            "                # NOTE(dims): Using config drive with iso format does not work",
            "                # because of a bug in libvirt with read only devices. However",
            "                # one can use vfat as config_drive_format which works fine.",
            "                # Please see bug/1246201 for details on the libvirt bug.",
            "            if (is_shared_block_storage or",
            "                is_shared_instance_path or",
            "                CONF.config_drive_format == 'vfat'):",
            "                pass",
            "            else:",
            "                raise exception.NoLiveMigrationForConfigDriveInLibVirt()",
            "",
            "        if not is_shared_instance_path:",
            "            instance_dir = libvirt_utils.get_instance_path_at_destination(",
            "                            instance, migrate_data)",
            "",
            "            if os.path.exists(instance_dir):",
            "                raise exception.DestinationDiskExists(path=instance_dir)",
            "",
            "            LOG.debug('Creating instance directory: %s', instance_dir,",
            "                      instance=instance)",
            "            os.mkdir(instance_dir)",
            "",
            "            if not is_shared_block_storage:",
            "                # Ensure images and backing files are present.",
            "                LOG.debug('Checking to make sure images and backing files are '",
            "                          'present before live migration.', instance=instance)",
            "                self._create_images_and_backing(",
            "                    context, instance, instance_dir, disk_info,",
            "                    fallback_from_host=instance.host)",
            "",
            "            if not is_block_migration:",
            "                # NOTE(angdraug): when block storage is shared between source",
            "                # and destination and instance path isn't (e.g. volume backed",
            "                # or rbd backed instance), instance path on destination has to",
            "                # be prepared",
            "",
            "                # Touch the console.log file, required by libvirt.",
            "                console_file = self._get_console_log_path(instance)",
            "                LOG.debug('Touch instance console log: %s', console_file,",
            "                          instance=instance)",
            "                libvirt_utils.file_open(console_file, 'a').close()",
            "",
            "                # if image has kernel and ramdisk, just download",
            "                # following normal way.",
            "                self._fetch_instance_kernel_ramdisk(context, instance)",
            "",
            "        # Establishing connection to volume server.",
            "        block_device_mapping = driver.block_device_info_get_mapping(",
            "            block_device_info)",
            "",
            "        if len(block_device_mapping):",
            "            LOG.debug('Connecting volumes before live migration.',",
            "                      instance=instance)",
            "",
            "        for bdm in block_device_mapping:",
            "            connection_info = bdm['connection_info']",
            "            disk_info = blockinfo.get_info_from_bdm(",
            "                instance, CONF.libvirt.virt_type,",
            "                instance.image_meta, bdm)",
            "            self._connect_volume(connection_info, disk_info)",
            "",
            "        # We call plug_vifs before the compute manager calls",
            "        # ensure_filtering_rules_for_instance, to ensure bridge is set up",
            "        # Retry operation is necessary because continuously request comes,",
            "        # concurrent request occurs to iptables, then it complains.",
            "        LOG.debug('Plugging VIFs before live migration.', instance=instance)",
            "        max_retry = CONF.live_migration_retry_count",
            "        for cnt in range(max_retry):",
            "            try:",
            "                self.plug_vifs(instance, network_info)",
            "                break",
            "            except processutils.ProcessExecutionError:",
            "                if cnt == max_retry - 1:",
            "                    raise",
            "                else:",
            "                    LOG.warn(_LW('plug_vifs() failed %(cnt)d. Retry up to '",
            "                                 '%(max_retry)d.'),",
            "                             {'cnt': cnt,",
            "                              'max_retry': max_retry},",
            "                             instance=instance)",
            "                    greenthread.sleep(1)",
            "",
            "        # Store vncserver_listen and latest disk device info",
            "        if not migrate_data:",
            "            migrate_data = objects.LibvirtLiveMigrateData(bdms=[])",
            "        else:",
            "            migrate_data.bdms = []",
            "        migrate_data.graphics_listen_addr_vnc = CONF.vnc.vncserver_listen",
            "        migrate_data.graphics_listen_addr_spice = CONF.spice.server_listen",
            "        migrate_data.serial_listen_addr = \\",
            "            CONF.serial_console.proxyclient_address",
            "        # Store live_migration_inbound_addr",
            "        migrate_data.target_connect_addr = \\",
            "            CONF.libvirt.live_migration_inbound_addr",
            "",
            "        for vol in block_device_mapping:",
            "            connection_info = vol['connection_info']",
            "            if connection_info.get('serial'):",
            "                disk_info = blockinfo.get_info_from_bdm(",
            "                    instance, CONF.libvirt.virt_type,",
            "                    instance.image_meta, vol)",
            "",
            "                bdmi = objects.LibvirtLiveMigrateBDMInfo()",
            "                bdmi.serial = connection_info['serial']",
            "                bdmi.connection_info = connection_info",
            "                bdmi.bus = disk_info['bus']",
            "                bdmi.dev = disk_info['dev']",
            "                bdmi.type = disk_info['type']",
            "                bdmi.format = disk_info.get('format')",
            "                bdmi.boot_index = disk_info.get('boot_index')",
            "                migrate_data.bdms.append(bdmi)",
            "",
            "        return migrate_data",
            "",
            "    def _try_fetch_image_cache(self, image, fetch_func, context, filename,",
            "                               image_id, instance, size,",
            "                               fallback_from_host=None):",
            "        try:",
            "            image.cache(fetch_func=fetch_func,",
            "                        context=context,",
            "                        filename=filename,",
            "                        image_id=image_id,",
            "                        user_id=instance.user_id,",
            "                        project_id=instance.project_id,",
            "                        size=size)",
            "        except exception.ImageNotFound:",
            "            if not fallback_from_host:",
            "                raise",
            "            LOG.debug(\"Image %(image_id)s doesn't exist anymore \"",
            "                      \"on image service, attempting to copy \"",
            "                      \"image from %(host)s\",",
            "                      {'image_id': image_id, 'host': fallback_from_host},",
            "                      instance=instance)",
            "",
            "            def copy_from_host(target, max_size):",
            "                libvirt_utils.copy_image(src=target,",
            "                                         dest=target,",
            "                                         host=fallback_from_host,",
            "                                         receive=True)",
            "            image.cache(fetch_func=copy_from_host,",
            "                        filename=filename)",
            "",
            "    def _create_images_and_backing(self, context, instance, instance_dir,",
            "                                   disk_info, fallback_from_host=None):",
            "        \"\"\":param context: security context",
            "           :param instance:",
            "               nova.db.sqlalchemy.models.Instance object",
            "               instance object that is migrated.",
            "           :param instance_dir:",
            "               instance path to use, calculated externally to handle block",
            "               migrating an instance with an old style instance path",
            "           :param disk_info:",
            "               disk info specified in _get_instance_disk_info (list of dicts)",
            "           :param fallback_from_host:",
            "               host where we can retrieve images if the glance images are",
            "               not available.",
            "",
            "        \"\"\"",
            "        if not disk_info:",
            "            disk_info = []",
            "",
            "        for info in disk_info:",
            "            base = os.path.basename(info['path'])",
            "            # Get image type and create empty disk image, and",
            "            # create backing file in case of qcow2.",
            "            instance_disk = os.path.join(instance_dir, base)",
            "            if not info['backing_file'] and not os.path.exists(instance_disk):",
            "                libvirt_utils.create_image(info['type'], instance_disk,",
            "                                           info['virt_disk_size'])",
            "            elif info['backing_file']:",
            "                # Creating backing file follows same way as spawning instances.",
            "                cache_name = os.path.basename(info['backing_file'])",
            "",
            "                image = self.image_backend.image(instance,",
            "                                                 instance_disk,",
            "                                                 CONF.libvirt.images_type)",
            "                if cache_name.startswith('ephemeral'):",
            "                    image.cache(fetch_func=self._create_ephemeral,",
            "                                fs_label=cache_name,",
            "                                os_type=instance.os_type,",
            "                                filename=cache_name,",
            "                                size=info['virt_disk_size'],",
            "                                ephemeral_size=instance.ephemeral_gb)",
            "                elif cache_name.startswith('swap'):",
            "                    inst_type = instance.get_flavor()",
            "                    swap_mb = inst_type.swap",
            "                    image.cache(fetch_func=self._create_swap,",
            "                                filename=\"swap_%s\" % swap_mb,",
            "                                size=swap_mb * units.Mi,",
            "                                swap_mb=swap_mb)",
            "                else:",
            "                    self._try_fetch_image_cache(image,",
            "                                                libvirt_utils.fetch_image,",
            "                                                context, cache_name,",
            "                                                instance.image_ref,",
            "                                                instance,",
            "                                                info['virt_disk_size'],",
            "                                                fallback_from_host)",
            "",
            "        # if image has kernel and ramdisk, just download",
            "        # following normal way.",
            "        self._fetch_instance_kernel_ramdisk(",
            "            context, instance, fallback_from_host=fallback_from_host)",
            "",
            "    def post_live_migration(self, context, instance, block_device_info,",
            "                            migrate_data=None):",
            "        # Disconnect from volume server",
            "        block_device_mapping = driver.block_device_info_get_mapping(",
            "                block_device_info)",
            "        connector = self.get_volume_connector(instance)",
            "        volume_api = self._volume_api",
            "        for vol in block_device_mapping:",
            "            # Retrieve connection info from Cinder's initialize_connection API.",
            "            # The info returned will be accurate for the source server.",
            "            volume_id = vol['connection_info']['serial']",
            "            connection_info = volume_api.initialize_connection(context,",
            "                                                               volume_id,",
            "                                                               connector)",
            "",
            "            # TODO(leeantho) The following multipath_id logic is temporary",
            "            # and will be removed in the future once os-brick is updated",
            "            # to handle multipath for drivers in a more efficient way.",
            "            # For now this logic is needed to ensure the connection info",
            "            # data is correct.",
            "",
            "            # Pull out multipath_id from the bdm information. The",
            "            # multipath_id can be placed into the connection info",
            "            # because it is based off of the volume and will be the",
            "            # same on the source and destination hosts.",
            "            if 'multipath_id' in vol['connection_info']['data']:",
            "                multipath_id = vol['connection_info']['data']['multipath_id']",
            "                connection_info['data']['multipath_id'] = multipath_id",
            "",
            "            disk_dev = vol['mount_device'].rpartition(\"/\")[2]",
            "            self._disconnect_volume(connection_info, disk_dev)",
            "",
            "    def post_live_migration_at_source(self, context, instance, network_info):",
            "        \"\"\"Unplug VIFs from networks at source.",
            "",
            "        :param context: security context",
            "        :param instance: instance object reference",
            "        :param network_info: instance network information",
            "        \"\"\"",
            "        self.unplug_vifs(instance, network_info)",
            "",
            "    def post_live_migration_at_destination(self, context,",
            "                                           instance,",
            "                                           network_info,",
            "                                           block_migration=False,",
            "                                           block_device_info=None):",
            "        \"\"\"Post operation of live migration at destination host.",
            "",
            "        :param context: security context",
            "        :param instance:",
            "            nova.db.sqlalchemy.models.Instance object",
            "            instance object that is migrated.",
            "        :param network_info: instance network information",
            "        :param block_migration: if true, post operation of block_migration.",
            "        \"\"\"",
            "        # Define migrated instance, otherwise, suspend/destroy does not work.",
            "        # In case of block migration, destination does not have",
            "        # libvirt.xml",
            "        disk_info = blockinfo.get_disk_info(",
            "            CONF.libvirt.virt_type, instance,",
            "            instance.image_meta, block_device_info)",
            "        xml = self._get_guest_xml(context, instance,",
            "                                  network_info, disk_info,",
            "                                  instance.image_meta,",
            "                                  block_device_info=block_device_info,",
            "                                  write_to_disk=True)",
            "        self._host.write_instance_config(xml)",
            "",
            "    def _get_instance_disk_info(self, instance_name, xml,",
            "                                block_device_info=None):",
            "        \"\"\"Get the non-volume disk information from the domain xml",
            "",
            "        :param str instance_name: the name of the instance (domain)",
            "        :param str xml: the libvirt domain xml for the instance",
            "        :param dict block_device_info: block device info for BDMs",
            "        :returns disk_info: list of dicts with keys:",
            "",
            "          * 'type': the disk type (str)",
            "          * 'path': the disk path (str)",
            "          * 'virt_disk_size': the virtual disk size (int)",
            "          * 'backing_file': backing file of a disk image (str)",
            "          * 'disk_size': physical disk size (int)",
            "          * 'over_committed_disk_size': virt_disk_size - disk_size or 0",
            "        \"\"\"",
            "        block_device_mapping = driver.block_device_info_get_mapping(",
            "            block_device_info)",
            "",
            "        volume_devices = set()",
            "        for vol in block_device_mapping:",
            "            disk_dev = vol['mount_device'].rpartition(\"/\")[2]",
            "            volume_devices.add(disk_dev)",
            "",
            "        disk_info = []",
            "        doc = etree.fromstring(xml)",
            "        disk_nodes = doc.findall('.//devices/disk')",
            "        path_nodes = doc.findall('.//devices/disk/source')",
            "        driver_nodes = doc.findall('.//devices/disk/driver')",
            "        target_nodes = doc.findall('.//devices/disk/target')",
            "",
            "        for cnt, path_node in enumerate(path_nodes):",
            "            disk_type = disk_nodes[cnt].get('type')",
            "            path = path_node.get('file') or path_node.get('dev')",
            "            target = target_nodes[cnt].attrib['dev']",
            "",
            "            if not path:",
            "                LOG.debug('skipping disk for %s as it does not have a path',",
            "                          instance_name)",
            "                continue",
            "",
            "            if disk_type not in ['file', 'block']:",
            "                LOG.debug('skipping disk because it looks like a volume', path)",
            "                continue",
            "",
            "            if target in volume_devices:",
            "                LOG.debug('skipping disk %(path)s (%(target)s) as it is a '",
            "                          'volume', {'path': path, 'target': target})",
            "                continue",
            "",
            "            # get the real disk size or",
            "            # raise a localized error if image is unavailable",
            "            if disk_type == 'file':",
            "                dk_size = int(os.path.getsize(path))",
            "            elif disk_type == 'block' and block_device_info:",
            "                dk_size = lvm.get_volume_size(path)",
            "            else:",
            "                LOG.debug('skipping disk %(path)s (%(target)s) - unable to '",
            "                          'determine if volume',",
            "                          {'path': path, 'target': target})",
            "                continue",
            "",
            "            disk_type = driver_nodes[cnt].get('type')",
            "            if disk_type == \"qcow2\":",
            "                backing_file = libvirt_utils.get_disk_backing_file(path)",
            "                virt_size = disk.get_disk_size(path)",
            "                over_commit_size = int(virt_size) - dk_size",
            "            else:",
            "                backing_file = \"\"",
            "                virt_size = dk_size",
            "                over_commit_size = 0",
            "",
            "            disk_info.append({'type': disk_type,",
            "                              'path': path,",
            "                              'virt_disk_size': virt_size,",
            "                              'backing_file': backing_file,",
            "                              'disk_size': dk_size,",
            "                              'over_committed_disk_size': over_commit_size})",
            "        return disk_info",
            "",
            "    def get_instance_disk_info(self, instance,",
            "                               block_device_info=None):",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "            xml = guest.get_xml_desc()",
            "        except libvirt.libvirtError as ex:",
            "            error_code = ex.get_error_code()",
            "            LOG.warn(_LW('Error from libvirt while getting description of '",
            "                         '%(instance_name)s: [Error Code %(error_code)s] '",
            "                         '%(ex)s'),",
            "                     {'instance_name': instance.name,",
            "                      'error_code': error_code,",
            "                      'ex': ex},",
            "                     instance=instance)",
            "            raise exception.InstanceNotFound(instance_id=instance.uuid)",
            "",
            "        return jsonutils.dumps(",
            "                self._get_instance_disk_info(instance.name, xml,",
            "                                             block_device_info))",
            "",
            "    def _get_disk_over_committed_size_total(self):",
            "        \"\"\"Return total over committed disk size for all instances.\"\"\"",
            "        # Disk size that all instance uses : virtual_size - disk_size",
            "        disk_over_committed_size = 0",
            "        instance_domains = self._host.list_instance_domains()",
            "        if not instance_domains:",
            "            return disk_over_committed_size",
            "",
            "        # Get all instance uuids",
            "        instance_uuids = [dom.UUIDString() for dom in instance_domains]",
            "        ctx = nova_context.get_admin_context()",
            "        # Get instance object list by uuid filter",
            "        filters = {'uuid': instance_uuids}",
            "        # NOTE(ankit): objects.InstanceList.get_by_filters method is",
            "        # getting called twice one is here and another in the",
            "        # _update_available_resource method of resource_tracker. Since",
            "        # _update_available_resource method is synchronized, there is a",
            "        # possibility the instances list retrieved here to calculate",
            "        # disk_over_committed_size would differ to the list you would get",
            "        # in _update_available_resource method for calculating usages based",
            "        # on instance utilization.",
            "        local_instance_list = objects.InstanceList.get_by_filters(",
            "            ctx, filters, use_slave=True)",
            "        # Convert instance list to dictionary with instace uuid as key.",
            "        local_instances = {inst.uuid: inst for inst in local_instance_list}",
            "",
            "        # Get bdms by instance uuids",
            "        bdms = objects.BlockDeviceMappingList.bdms_by_instance_uuid(",
            "            ctx, instance_uuids)",
            "",
            "        for dom in instance_domains:",
            "            try:",
            "                guest = libvirt_guest.Guest(dom)",
            "                xml = guest.get_xml_desc()",
            "",
            "                block_device_info = None",
            "                if guest.uuid in local_instances:",
            "                    # Get block device info for instance",
            "                    block_device_info = driver.get_block_device_info(",
            "                        local_instances[guest.uuid], bdms[guest.uuid])",
            "",
            "                disk_infos = self._get_instance_disk_info(guest.name, xml,",
            "                                 block_device_info=block_device_info)",
            "",
            "                for info in disk_infos:",
            "                    disk_over_committed_size += int(",
            "                        info['over_committed_disk_size'])",
            "            except libvirt.libvirtError as ex:",
            "                error_code = ex.get_error_code()",
            "                LOG.warn(_LW(",
            "                    'Error from libvirt while getting description of '",
            "                    '%(instance_name)s: [Error Code %(error_code)s] %(ex)s'",
            "                ), {'instance_name': guest.name,",
            "                    'error_code': error_code,",
            "                    'ex': ex})",
            "            except OSError as e:",
            "                if e.errno == errno.ENOENT:",
            "                    LOG.warn(_LW('Periodic task is updating the host stat, '",
            "                                 'it is trying to get disk %(i_name)s, '",
            "                                 'but disk file was removed by concurrent '",
            "                                 'operations such as resize.'),",
            "                                {'i_name': guest.name})",
            "                elif e.errno == errno.EACCES:",
            "                    LOG.warn(_LW('Periodic task is updating the host stat, '",
            "                                 'it is trying to get disk %(i_name)s, '",
            "                                 'but access is denied. It is most likely '",
            "                                 'due to a VM that exists on the compute '",
            "                                 'node but is not managed by Nova.'),",
            "                             {'i_name': guest.name})",
            "                else:",
            "                    raise",
            "            except exception.VolumeBDMPathNotFound as e:",
            "                LOG.warn(_LW('Periodic task is updating the host stats, '",
            "                             'it is trying to get disk info for %(i_name)s, '",
            "                             'but the backing volume block device was removed '",
            "                             'by concurrent operations such as resize. '",
            "                             'Error: %(error)s'),",
            "                         {'i_name': guest.name,",
            "                          'error': e})",
            "            # NOTE(gtt116): give other tasks a chance.",
            "            greenthread.sleep(0)",
            "        return disk_over_committed_size",
            "",
            "    def unfilter_instance(self, instance, network_info):",
            "        \"\"\"See comments of same method in firewall_driver.\"\"\"",
            "        self.firewall_driver.unfilter_instance(instance,",
            "                                               network_info=network_info)",
            "",
            "    def get_available_nodes(self, refresh=False):",
            "        return [self._host.get_hostname()]",
            "",
            "    def get_host_cpu_stats(self):",
            "        \"\"\"Return the current CPU state of the host.\"\"\"",
            "        return self._host.get_cpu_stats()",
            "",
            "    def get_host_uptime(self):",
            "        \"\"\"Returns the result of calling \"uptime\".\"\"\"",
            "        out, err = utils.execute('env', 'LANG=C', 'uptime')",
            "        return out",
            "",
            "    def manage_image_cache(self, context, all_instances):",
            "        \"\"\"Manage the local cache of images.\"\"\"",
            "        self.image_cache_manager.update(context, all_instances)",
            "",
            "    def _cleanup_remote_migration(self, dest, inst_base, inst_base_resize,",
            "                                  shared_storage=False):",
            "        \"\"\"Used only for cleanup in case migrate_disk_and_power_off fails.\"\"\"",
            "        try:",
            "            if os.path.exists(inst_base_resize):",
            "                utils.execute('rm', '-rf', inst_base)",
            "                utils.execute('mv', inst_base_resize, inst_base)",
            "                if not shared_storage:",
            "                    self._remotefs.remove_dir(dest, inst_base)",
            "        except Exception:",
            "            pass",
            "",
            "    def _is_storage_shared_with(self, dest, inst_base):",
            "        # NOTE (rmk): There are two methods of determining whether we are",
            "        #             on the same filesystem: the source and dest IP are the",
            "        #             same, or we create a file on the dest system via SSH",
            "        #             and check whether the source system can also see it.",
            "        shared_storage = (dest == self.get_host_ip_addr())",
            "        if not shared_storage:",
            "            tmp_file = uuid.uuid4().hex + '.tmp'",
            "            tmp_path = os.path.join(inst_base, tmp_file)",
            "",
            "            try:",
            "                self._remotefs.create_file(dest, tmp_path)",
            "                if os.path.exists(tmp_path):",
            "                    shared_storage = True",
            "                    os.unlink(tmp_path)",
            "                else:",
            "                    self._remotefs.remove_file(dest, tmp_path)",
            "            except Exception:",
            "                pass",
            "        return shared_storage",
            "",
            "    def migrate_disk_and_power_off(self, context, instance, dest,",
            "                                   flavor, network_info,",
            "                                   block_device_info=None,",
            "                                   timeout=0, retry_interval=0):",
            "        LOG.debug(\"Starting migrate_disk_and_power_off\",",
            "                   instance=instance)",
            "",
            "        ephemerals = driver.block_device_info_get_ephemerals(block_device_info)",
            "",
            "        # get_bdm_ephemeral_disk_size() will return 0 if the new",
            "        # instance's requested block device mapping contain no",
            "        # ephemeral devices. However, we still want to check if",
            "        # the original instance's ephemeral_gb property was set and",
            "        # ensure that the new requested flavor ephemeral size is greater",
            "        eph_size = (block_device.get_bdm_ephemeral_disk_size(ephemerals) or",
            "                    instance.ephemeral_gb)",
            "",
            "        # Checks if the migration needs a disk resize down.",
            "        root_down = flavor.root_gb < instance.root_gb",
            "        ephemeral_down = flavor.ephemeral_gb < eph_size",
            "        disk_info_text = self.get_instance_disk_info(",
            "            instance, block_device_info=block_device_info)",
            "        booted_from_volume = self._is_booted_from_volume(instance,",
            "                                                         disk_info_text)",
            "        if (root_down and not booted_from_volume) or ephemeral_down:",
            "            reason = _(\"Unable to resize disk down.\")",
            "            raise exception.InstanceFaultRollback(",
            "                exception.ResizeError(reason=reason))",
            "",
            "        disk_info = jsonutils.loads(disk_info_text)",
            "",
            "        # NOTE(dgenin): Migration is not implemented for LVM backed instances.",
            "        if CONF.libvirt.images_type == 'lvm' and not booted_from_volume:",
            "            reason = _(\"Migration is not supported for LVM backed instances\")",
            "            raise exception.InstanceFaultRollback(",
            "                exception.MigrationPreCheckError(reason=reason))",
            "",
            "        # copy disks to destination",
            "        # rename instance dir to +_resize at first for using",
            "        # shared storage for instance dir (eg. NFS).",
            "        inst_base = libvirt_utils.get_instance_path(instance)",
            "        inst_base_resize = inst_base + \"_resize\"",
            "        shared_storage = self._is_storage_shared_with(dest, inst_base)",
            "",
            "        # try to create the directory on the remote compute node",
            "        # if this fails we pass the exception up the stack so we can catch",
            "        # failures here earlier",
            "        if not shared_storage:",
            "            try:",
            "                self._remotefs.create_dir(dest, inst_base)",
            "            except processutils.ProcessExecutionError as e:",
            "                reason = _(\"not able to execute ssh command: %s\") % e",
            "                raise exception.InstanceFaultRollback(",
            "                    exception.ResizeError(reason=reason))",
            "",
            "        self.power_off(instance, timeout, retry_interval)",
            "",
            "        block_device_mapping = driver.block_device_info_get_mapping(",
            "            block_device_info)",
            "        for vol in block_device_mapping:",
            "            connection_info = vol['connection_info']",
            "            disk_dev = vol['mount_device'].rpartition(\"/\")[2]",
            "            self._disconnect_volume(connection_info, disk_dev)",
            "",
            "        try:",
            "            utils.execute('mv', inst_base, inst_base_resize)",
            "            # if we are migrating the instance with shared storage then",
            "            # create the directory.  If it is a remote node the directory",
            "            # has already been created",
            "            if shared_storage:",
            "                dest = None",
            "                utils.execute('mkdir', '-p', inst_base)",
            "",
            "            active_flavor = instance.get_flavor()",
            "            for info in disk_info:",
            "                # assume inst_base == dirname(info['path'])",
            "                img_path = info['path']",
            "                fname = os.path.basename(img_path)",
            "                from_path = os.path.join(inst_base_resize, fname)",
            "",
            "                # To properly resize the swap partition, it must be",
            "                # re-created with the proper size.  This is acceptable",
            "                # because when an OS is shut down, the contents of the",
            "                # swap space are just garbage, the OS doesn't bother about",
            "                # what is in it.",
            "",
            "                # We will not copy over the swap disk here, and rely on",
            "                # finish_migration/_create_image to re-create it for us.",
            "                if not (fname == 'disk.swap' and",
            "                    active_flavor.get('swap', 0) != flavor.get('swap', 0)):",
            "",
            "                    on_execute = lambda process: self.job_tracker.add_job(",
            "                        instance, process.pid)",
            "                    on_completion = lambda process: self.job_tracker.\\",
            "                        remove_job(instance, process.pid)",
            "                    compression = info['type'] not in NO_COMPRESSION_TYPES",
            "                    libvirt_utils.copy_image(from_path, img_path, host=dest,",
            "                                             on_execute=on_execute,",
            "                                             on_completion=on_completion,",
            "                                             compression=compression)",
            "        except Exception:",
            "            with excutils.save_and_reraise_exception():",
            "                self._cleanup_remote_migration(dest, inst_base,",
            "                                               inst_base_resize,",
            "                                               shared_storage)",
            "",
            "        return disk_info_text",
            "",
            "    def _wait_for_running(self, instance):",
            "        state = self.get_info(instance).state",
            "",
            "        if state == power_state.RUNNING:",
            "            LOG.info(_LI(\"Instance running successfully.\"), instance=instance)",
            "            raise loopingcall.LoopingCallDone()",
            "",
            "    @staticmethod",
            "    def _disk_size_from_instance(instance, info):",
            "        \"\"\"Determines the disk size from instance properties",
            "",
            "        Returns the disk size by using the disk name to determine whether it",
            "        is a root or an ephemeral disk, then by checking properties of the",
            "        instance returns the size converted to bytes.",
            "",
            "        Returns 0 if the disk name not match (disk, disk.local).",
            "        \"\"\"",
            "        fname = os.path.basename(info['path'])",
            "        if fname == 'disk':",
            "            size = instance.root_gb",
            "        elif fname == 'disk.local':",
            "            size = instance.ephemeral_gb",
            "        else:",
            "            size = 0",
            "        return size * units.Gi",
            "",
            "    @staticmethod",
            "    def _disk_raw_to_qcow2(path):",
            "        \"\"\"Converts a raw disk to qcow2.\"\"\"",
            "        path_qcow = path + '_qcow'",
            "        utils.execute('qemu-img', 'convert', '-f', 'raw',",
            "                      '-O', 'qcow2', path, path_qcow)",
            "        utils.execute('mv', path_qcow, path)",
            "",
            "    @staticmethod",
            "    def _disk_qcow2_to_raw(path):",
            "        \"\"\"Converts a qcow2 disk to raw.\"\"\"",
            "        path_raw = path + '_raw'",
            "        utils.execute('qemu-img', 'convert', '-f', 'qcow2',",
            "                      '-O', 'raw', path, path_raw)",
            "        utils.execute('mv', path_raw, path)",
            "",
            "    def _disk_resize(self, image, size):",
            "        \"\"\"Attempts to resize a disk to size",
            "",
            "        :param image: an instance of nova.virt.image.model.Image",
            "",
            "        Attempts to resize a disk by checking the capabilities and",
            "        preparing the format, then calling disk.api.extend.",
            "",
            "        Note: Currently only support disk extend.",
            "        \"\"\"",
            "",
            "        if not isinstance(image, imgmodel.LocalFileImage):",
            "            LOG.debug(\"Skipping resize of non-local image\")",
            "            return",
            "",
            "        # If we have a non partitioned image that we can extend",
            "        # then ensure we're in 'raw' format so we can extend file system.",
            "        converted = False",
            "        if (size and",
            "            image.format == imgmodel.FORMAT_QCOW2 and",
            "            disk.can_resize_image(image.path, size) and",
            "            disk.is_image_extendable(image)):",
            "            self._disk_qcow2_to_raw(image.path)",
            "            converted = True",
            "            image = imgmodel.LocalFileImage(image.path,",
            "                                            imgmodel.FORMAT_RAW)",
            "",
            "        if size:",
            "            disk.extend(image, size)",
            "",
            "        if converted:",
            "            # back to qcow2 (no backing_file though) so that snapshot",
            "            # will be available",
            "            self._disk_raw_to_qcow2(image.path)",
            "",
            "    def finish_migration(self, context, migration, instance, disk_info,",
            "                         network_info, image_meta, resize_instance,",
            "                         block_device_info=None, power_on=True):",
            "        LOG.debug(\"Starting finish_migration\", instance=instance)",
            "",
            "        # resize disks. only \"disk\" and \"disk.local\" are necessary.",
            "        disk_info = jsonutils.loads(disk_info)",
            "        for info in disk_info:",
            "            size = self._disk_size_from_instance(instance, info)",
            "            if resize_instance:",
            "                image = imgmodel.LocalFileImage(info['path'],",
            "                                                info['type'])",
            "                self._disk_resize(image, size)",
            "            if info['type'] == 'raw' and CONF.use_cow_images:",
            "                self._disk_raw_to_qcow2(info['path'])",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta,",
            "                                            block_device_info)",
            "        # assume _create_image do nothing if a target file exists.",
            "        self._create_image(context, instance, disk_info['mapping'],",
            "                           network_info=network_info,",
            "                           block_device_info=None, inject_files=False,",
            "                           fallback_from_host=migration.source_compute)",
            "        xml = self._get_guest_xml(context, instance, network_info, disk_info,",
            "                                  image_meta,",
            "                                  block_device_info=block_device_info,",
            "                                  write_to_disk=True)",
            "        # NOTE(mriedem): vifs_already_plugged=True here, regardless of whether",
            "        # or not we've migrated to another host, because we unplug VIFs locally",
            "        # and the status change in the port might go undetected by the neutron",
            "        # L2 agent (or neutron server) so neutron may not know that the VIF was",
            "        # unplugged in the first place and never send an event.",
            "        self._create_domain_and_network(context, xml, instance, network_info,",
            "                                        disk_info,",
            "                                        block_device_info=block_device_info,",
            "                                        power_on=power_on,",
            "                                        vifs_already_plugged=True)",
            "        if power_on:",
            "            timer = loopingcall.FixedIntervalLoopingCall(",
            "                                                    self._wait_for_running,",
            "                                                    instance)",
            "            timer.start(interval=0.5).wait()",
            "",
            "        LOG.debug(\"finish_migration finished successfully.\", instance=instance)",
            "",
            "    def _cleanup_failed_migration(self, inst_base):",
            "        \"\"\"Make sure that a failed migrate doesn't prevent us from rolling",
            "        back in a revert.",
            "        \"\"\"",
            "        try:",
            "            shutil.rmtree(inst_base)",
            "        except OSError as e:",
            "            if e.errno != errno.ENOENT:",
            "                raise",
            "",
            "    def finish_revert_migration(self, context, instance, network_info,",
            "                                block_device_info=None, power_on=True):",
            "        LOG.debug(\"Starting finish_revert_migration\",",
            "                  instance=instance)",
            "",
            "        inst_base = libvirt_utils.get_instance_path(instance)",
            "        inst_base_resize = inst_base + \"_resize\"",
            "",
            "        # NOTE(danms): if we're recovering from a failed migration,",
            "        # make sure we don't have a left-over same-host base directory",
            "        # that would conflict. Also, don't fail on the rename if the",
            "        # failure happened early.",
            "        if os.path.exists(inst_base_resize):",
            "            self._cleanup_failed_migration(inst_base)",
            "            utils.execute('mv', inst_base_resize, inst_base)",
            "",
            "        backend = self.image_backend.image(instance, 'disk')",
            "        # Once we rollback, the snapshot is no longer needed, so remove it",
            "        # TODO(nic): Remove the try/except/finally in a future release",
            "        # To avoid any upgrade issues surrounding instances being in pending",
            "        # resize state when the software is updated, this portion of the",
            "        # method logs exceptions rather than failing on them.  Once it can be",
            "        # reasonably assumed that no such instances exist in the wild",
            "        # anymore, the try/except/finally should be removed,",
            "        # and ignore_errors should be set back to False (the default) so",
            "        # that problems throw errors, like they should.",
            "        try:",
            "            backend.rollback_to_snap(libvirt_utils.RESIZE_SNAPSHOT_NAME)",
            "        except exception.SnapshotNotFound:",
            "            LOG.warning(_LW(\"Failed to rollback snapshot (%s)\"),",
            "                        libvirt_utils.RESIZE_SNAPSHOT_NAME)",
            "        finally:",
            "            backend.remove_snap(libvirt_utils.RESIZE_SNAPSHOT_NAME,",
            "                                ignore_errors=True)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            instance.image_meta,",
            "                                            block_device_info)",
            "        xml = self._get_guest_xml(context, instance, network_info, disk_info,",
            "                                  instance.image_meta,",
            "                                  block_device_info=block_device_info)",
            "        self._create_domain_and_network(context, xml, instance, network_info,",
            "                                        disk_info,",
            "                                        block_device_info=block_device_info,",
            "                                        power_on=power_on,",
            "                                        vifs_already_plugged=True)",
            "",
            "        if power_on:",
            "            timer = loopingcall.FixedIntervalLoopingCall(",
            "                                                    self._wait_for_running,",
            "                                                    instance)",
            "            timer.start(interval=0.5).wait()",
            "",
            "        LOG.debug(\"finish_revert_migration finished successfully.\",",
            "                  instance=instance)",
            "",
            "    def confirm_migration(self, migration, instance, network_info):",
            "        \"\"\"Confirms a resize, destroying the source VM.\"\"\"",
            "        self._cleanup_resize(instance, network_info)",
            "",
            "    @staticmethod",
            "    def _get_io_devices(xml_doc):",
            "        \"\"\"get the list of io devices from the xml document.\"\"\"",
            "        result = {\"volumes\": [], \"ifaces\": []}",
            "        try:",
            "            doc = etree.fromstring(xml_doc)",
            "        except Exception:",
            "            return result",
            "        blocks = [('./devices/disk', 'volumes'),",
            "            ('./devices/interface', 'ifaces')]",
            "        for block, key in blocks:",
            "            section = doc.findall(block)",
            "            for node in section:",
            "                for child in node.getchildren():",
            "                    if child.tag == 'target' and child.get('dev'):",
            "                        result[key].append(child.get('dev'))",
            "        return result",
            "",
            "    def get_diagnostics(self, instance):",
            "        guest = self._host.get_guest(instance)",
            "",
            "        # TODO(sahid): We are converting all calls from a",
            "        # virDomain object to use nova.virt.libvirt.Guest.",
            "        # We should be able to remove domain at the end.",
            "        domain = guest._domain",
            "        output = {}",
            "        # get cpu time, might launch an exception if the method",
            "        # is not supported by the underlying hypervisor being",
            "        # used by libvirt",
            "        try:",
            "            for vcpu in guest.get_vcpus_info():",
            "                output[\"cpu\" + str(vcpu.id) + \"_time\"] = vcpu.time",
            "        except libvirt.libvirtError:",
            "            pass",
            "        # get io status",
            "        xml = guest.get_xml_desc()",
            "        dom_io = LibvirtDriver._get_io_devices(xml)",
            "        for guest_disk in dom_io[\"volumes\"]:",
            "            try:",
            "                # blockStats might launch an exception if the method",
            "                # is not supported by the underlying hypervisor being",
            "                # used by libvirt",
            "                stats = domain.blockStats(guest_disk)",
            "                output[guest_disk + \"_read_req\"] = stats[0]",
            "                output[guest_disk + \"_read\"] = stats[1]",
            "                output[guest_disk + \"_write_req\"] = stats[2]",
            "                output[guest_disk + \"_write\"] = stats[3]",
            "                output[guest_disk + \"_errors\"] = stats[4]",
            "            except libvirt.libvirtError:",
            "                pass",
            "        for interface in dom_io[\"ifaces\"]:",
            "            try:",
            "                # interfaceStats might launch an exception if the method",
            "                # is not supported by the underlying hypervisor being",
            "                # used by libvirt",
            "                stats = domain.interfaceStats(interface)",
            "                output[interface + \"_rx\"] = stats[0]",
            "                output[interface + \"_rx_packets\"] = stats[1]",
            "                output[interface + \"_rx_errors\"] = stats[2]",
            "                output[interface + \"_rx_drop\"] = stats[3]",
            "                output[interface + \"_tx\"] = stats[4]",
            "                output[interface + \"_tx_packets\"] = stats[5]",
            "                output[interface + \"_tx_errors\"] = stats[6]",
            "                output[interface + \"_tx_drop\"] = stats[7]",
            "            except libvirt.libvirtError:",
            "                pass",
            "        output[\"memory\"] = domain.maxMemory()",
            "        # memoryStats might launch an exception if the method",
            "        # is not supported by the underlying hypervisor being",
            "        # used by libvirt",
            "        try:",
            "            mem = domain.memoryStats()",
            "            for key in mem.keys():",
            "                output[\"memory-\" + key] = mem[key]",
            "        except (libvirt.libvirtError, AttributeError):",
            "            pass",
            "        return output",
            "",
            "    def get_instance_diagnostics(self, instance):",
            "        guest = self._host.get_guest(instance)",
            "",
            "        # TODO(sahid): We are converting all calls from a",
            "        # virDomain object to use nova.virt.libvirt.Guest.",
            "        # We should be able to remove domain at the end.",
            "        domain = guest._domain",
            "",
            "        xml = guest.get_xml_desc()",
            "        xml_doc = etree.fromstring(xml)",
            "",
            "        # TODO(sahid): Needs to use get_info but more changes have to",
            "        # be done since a mapping STATE_MAP LIBVIRT_POWER_STATE is",
            "        # needed.",
            "        (state, max_mem, mem, num_cpu, cpu_time) = \\",
            "            guest._get_domain_info(self._host)",
            "        config_drive = configdrive.required_by(instance)",
            "        launched_at = timeutils.normalize_time(instance.launched_at)",
            "        uptime = timeutils.delta_seconds(launched_at,",
            "                                         timeutils.utcnow())",
            "        diags = diagnostics.Diagnostics(state=power_state.STATE_MAP[state],",
            "                                        driver='libvirt',",
            "                                        config_drive=config_drive,",
            "                                        hypervisor_os='linux',",
            "                                        uptime=uptime)",
            "        diags.memory_details.maximum = max_mem / units.Mi",
            "        diags.memory_details.used = mem / units.Mi",
            "",
            "        # get cpu time, might launch an exception if the method",
            "        # is not supported by the underlying hypervisor being",
            "        # used by libvirt",
            "        try:",
            "            for vcpu in guest.get_vcpus_info():",
            "                diags.add_cpu(time=vcpu.time)",
            "        except libvirt.libvirtError:",
            "            pass",
            "        # get io status",
            "        dom_io = LibvirtDriver._get_io_devices(xml)",
            "        for guest_disk in dom_io[\"volumes\"]:",
            "            try:",
            "                # blockStats might launch an exception if the method",
            "                # is not supported by the underlying hypervisor being",
            "                # used by libvirt",
            "                stats = domain.blockStats(guest_disk)",
            "                diags.add_disk(read_bytes=stats[1],",
            "                               read_requests=stats[0],",
            "                               write_bytes=stats[3],",
            "                               write_requests=stats[2])",
            "            except libvirt.libvirtError:",
            "                pass",
            "        for interface in dom_io[\"ifaces\"]:",
            "            try:",
            "                # interfaceStats might launch an exception if the method",
            "                # is not supported by the underlying hypervisor being",
            "                # used by libvirt",
            "                stats = domain.interfaceStats(interface)",
            "                diags.add_nic(rx_octets=stats[0],",
            "                              rx_errors=stats[2],",
            "                              rx_drop=stats[3],",
            "                              rx_packets=stats[1],",
            "                              tx_octets=stats[4],",
            "                              tx_errors=stats[6],",
            "                              tx_drop=stats[7],",
            "                              tx_packets=stats[5])",
            "            except libvirt.libvirtError:",
            "                pass",
            "",
            "        # Update mac addresses of interface if stats have been reported",
            "        if diags.nic_details:",
            "            nodes = xml_doc.findall('./devices/interface/mac')",
            "            for index, node in enumerate(nodes):",
            "                diags.nic_details[index].mac_address = node.get('address')",
            "        return diags",
            "",
            "    def instance_on_disk(self, instance):",
            "        # ensure directories exist and are writable",
            "        instance_path = libvirt_utils.get_instance_path(instance)",
            "        LOG.debug('Checking instance files accessibility %s', instance_path,",
            "                  instance=instance)",
            "        shared_instance_path = os.access(instance_path, os.W_OK)",
            "        # NOTE(flwang): For shared block storage scenario, the file system is",
            "        # not really shared by the two hosts, but the volume of evacuated",
            "        # instance is reachable.",
            "        shared_block_storage = (self.image_backend.backend().",
            "                                is_shared_block_storage())",
            "        return shared_instance_path or shared_block_storage",
            "",
            "    def inject_network_info(self, instance, nw_info):",
            "        self.firewall_driver.setup_basic_filtering(instance, nw_info)",
            "",
            "    def delete_instance_files(self, instance):",
            "        target = libvirt_utils.get_instance_path(instance)",
            "        # A resize may be in progress",
            "        target_resize = target + '_resize'",
            "        # Other threads may attempt to rename the path, so renaming the path",
            "        # to target + '_del' (because it is atomic) and iterating through",
            "        # twice in the unlikely event that a concurrent rename occurs between",
            "        # the two rename attempts in this method. In general this method",
            "        # should be fairly thread-safe without these additional checks, since",
            "        # other operations involving renames are not permitted when the task",
            "        # state is not None and the task state should be set to something",
            "        # other than None by the time this method is invoked.",
            "        target_del = target + '_del'",
            "        for i in six.moves.range(2):",
            "            try:",
            "                utils.execute('mv', target, target_del)",
            "                break",
            "            except Exception:",
            "                pass",
            "            try:",
            "                utils.execute('mv', target_resize, target_del)",
            "                break",
            "            except Exception:",
            "                pass",
            "        # Either the target or target_resize path may still exist if all",
            "        # rename attempts failed.",
            "        remaining_path = None",
            "        for p in (target, target_resize):",
            "            if os.path.exists(p):",
            "                remaining_path = p",
            "                break",
            "",
            "        # A previous delete attempt may have been interrupted, so target_del",
            "        # may exist even if all rename attempts during the present method",
            "        # invocation failed due to the absence of both target and",
            "        # target_resize.",
            "        if not remaining_path and os.path.exists(target_del):",
            "            self.job_tracker.terminate_jobs(instance)",
            "",
            "            LOG.info(_LI('Deleting instance files %s'), target_del,",
            "                     instance=instance)",
            "            remaining_path = target_del",
            "            try:",
            "                shutil.rmtree(target_del)",
            "            except OSError as e:",
            "                LOG.error(_LE('Failed to cleanup directory %(target)s: '",
            "                              '%(e)s'), {'target': target_del, 'e': e},",
            "                            instance=instance)",
            "",
            "        # It is possible that the delete failed, if so don't mark the instance",
            "        # as cleaned.",
            "        if remaining_path and os.path.exists(remaining_path):",
            "            LOG.info(_LI('Deletion of %s failed'), remaining_path,",
            "                     instance=instance)",
            "            return False",
            "",
            "        LOG.info(_LI('Deletion of %s complete'), target_del, instance=instance)",
            "        return True",
            "",
            "    @property",
            "    def need_legacy_block_device_info(self):",
            "        return False",
            "",
            "    def default_root_device_name(self, instance, image_meta, root_bdm):",
            "        disk_bus = blockinfo.get_disk_bus_for_device_type(",
            "            instance, CONF.libvirt.virt_type, image_meta, \"disk\")",
            "        cdrom_bus = blockinfo.get_disk_bus_for_device_type(",
            "            instance, CONF.libvirt.virt_type, image_meta, \"cdrom\")",
            "        root_info = blockinfo.get_root_info(",
            "            instance, CONF.libvirt.virt_type, image_meta,",
            "            root_bdm, disk_bus, cdrom_bus)",
            "        return block_device.prepend_dev(root_info['dev'])",
            "",
            "    def default_device_names_for_instance(self, instance, root_device_name,",
            "                                          *block_device_lists):",
            "        block_device_mapping = list(itertools.chain(*block_device_lists))",
            "        # NOTE(ndipanov): Null out the device names so that blockinfo code",
            "        #                 will assign them",
            "        for bdm in block_device_mapping:",
            "            if bdm.device_name is not None:",
            "                LOG.warn(_LW(\"Ignoring supplied device name: %(device_name)s. \"",
            "                             \"Libvirt can't honour user-supplied dev names\"),",
            "                         {'device_name': bdm.device_name}, instance=instance)",
            "                bdm.device_name = None",
            "        block_device_info = driver.get_block_device_info(instance,",
            "                                                         block_device_mapping)",
            "",
            "        blockinfo.default_device_names(CONF.libvirt.virt_type,",
            "                                       nova_context.get_admin_context(),",
            "                                       instance,",
            "                                       block_device_info,",
            "                                       instance.image_meta)",
            "",
            "    def get_device_name_for_instance(self, instance, bdms, block_device_obj):",
            "        block_device_info = driver.get_block_device_info(instance, bdms)",
            "        instance_info = blockinfo.get_disk_info(",
            "                CONF.libvirt.virt_type, instance,",
            "                instance.image_meta, block_device_info=block_device_info)",
            "",
            "        suggested_dev_name = block_device_obj.device_name",
            "        if suggested_dev_name is not None:",
            "            LOG.warn(_LW('Ignoring supplied device name: %(suggested_dev)s'),",
            "                     {'suggested_dev': suggested_dev_name}, instance=instance)",
            "",
            "        # NOTE(ndipanov): get_info_from_bdm will generate the new device name",
            "        #                 only when it's actually not set on the bd object",
            "        block_device_obj.device_name = None",
            "        disk_info = blockinfo.get_info_from_bdm(",
            "            instance, CONF.libvirt.virt_type, instance.image_meta,",
            "            block_device_obj, mapping=instance_info['mapping'])",
            "        return block_device.prepend_dev(disk_info['dev'])",
            "",
            "    def is_supported_fs_format(self, fs_type):",
            "        return fs_type in [disk.FS_FORMAT_EXT2, disk.FS_FORMAT_EXT3,",
            "                           disk.FS_FORMAT_EXT4, disk.FS_FORMAT_XFS]"
        ],
        "afterPatchFile": [
            "# Copyright 2010 United States Government as represented by the",
            "# Administrator of the National Aeronautics and Space Administration.",
            "# All Rights Reserved.",
            "# Copyright (c) 2010 Citrix Systems, Inc.",
            "# Copyright (c) 2011 Piston Cloud Computing, Inc",
            "# Copyright (c) 2012 University Of Minho",
            "# (c) Copyright 2013 Hewlett-Packard Development Company, L.P.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "\"\"\"",
            "A connection to a hypervisor through libvirt.",
            "",
            "Supports KVM, LXC, QEMU, UML, XEN and Parallels.",
            "",
            "\"\"\"",
            "",
            "import collections",
            "import contextlib",
            "import errno",
            "import functools",
            "import glob",
            "import itertools",
            "import mmap",
            "import operator",
            "import os",
            "import shutil",
            "import tempfile",
            "import time",
            "import uuid",
            "",
            "import eventlet",
            "from eventlet import greenthread",
            "from eventlet import tpool",
            "from lxml import etree",
            "from os_brick.initiator import connector",
            "from oslo_concurrency import processutils",
            "from oslo_config import cfg",
            "from oslo_log import log as logging",
            "from oslo_serialization import jsonutils",
            "from oslo_service import loopingcall",
            "from oslo_utils import excutils",
            "from oslo_utils import fileutils",
            "from oslo_utils import importutils",
            "from oslo_utils import strutils",
            "from oslo_utils import timeutils",
            "from oslo_utils import units",
            "import six",
            "from six.moves import range",
            "",
            "from nova.api.metadata import base as instance_metadata",
            "from nova import block_device",
            "from nova.compute import arch",
            "from nova.compute import hv_type",
            "from nova.compute import power_state",
            "from nova.compute import task_states",
            "from nova.compute import utils as compute_utils",
            "from nova.compute import vm_mode",
            "import nova.conf",
            "from nova.console import serial as serial_console",
            "from nova.console import type as ctype",
            "from nova import context as nova_context",
            "from nova import exception",
            "from nova.i18n import _",
            "from nova.i18n import _LE",
            "from nova.i18n import _LI",
            "from nova.i18n import _LW",
            "from nova import image",
            "from nova.network import model as network_model",
            "from nova import objects",
            "from nova.objects import fields",
            "from nova.objects import migrate_data as migrate_data_obj",
            "from nova.pci import manager as pci_manager",
            "from nova.pci import utils as pci_utils",
            "from nova import utils",
            "from nova import version",
            "from nova.virt import block_device as driver_block_device",
            "from nova.virt import configdrive",
            "from nova.virt import diagnostics",
            "from nova.virt.disk import api as disk",
            "from nova.virt.disk.vfs import guestfs",
            "from nova.virt import driver",
            "from nova.virt import firewall",
            "from nova.virt import hardware",
            "from nova.virt.image import model as imgmodel",
            "from nova.virt import images",
            "from nova.virt.libvirt import blockinfo",
            "from nova.virt.libvirt import config as vconfig",
            "from nova.virt.libvirt import firewall as libvirt_firewall",
            "from nova.virt.libvirt import guest as libvirt_guest",
            "from nova.virt.libvirt import host",
            "from nova.virt.libvirt import imagebackend",
            "from nova.virt.libvirt import imagecache",
            "from nova.virt.libvirt import instancejobtracker",
            "from nova.virt.libvirt.storage import dmcrypt",
            "from nova.virt.libvirt.storage import lvm",
            "from nova.virt.libvirt.storage import rbd_utils",
            "from nova.virt.libvirt import utils as libvirt_utils",
            "from nova.virt.libvirt import vif as libvirt_vif",
            "from nova.virt.libvirt.volume import remotefs",
            "from nova.virt import netutils",
            "from nova.virt import watchdog_actions",
            "from nova import volume",
            "from nova.volume import encryptors",
            "",
            "libvirt = None",
            "",
            "uefi_logged = False",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "# Downtime period in milliseconds",
            "LIVE_MIGRATION_DOWNTIME_MIN = 100",
            "# Step count",
            "LIVE_MIGRATION_DOWNTIME_STEPS_MIN = 3",
            "# Delay in seconds",
            "LIVE_MIGRATION_DOWNTIME_DELAY_MIN = 10",
            "",
            "libvirt_opts = [",
            "    cfg.StrOpt('rescue_image_id',",
            "               help='Rescue ami image. This will not be used if an image id '",
            "                    'is provided by the user.'),",
            "    cfg.StrOpt('rescue_kernel_id',",
            "               help='Rescue aki image'),",
            "    cfg.StrOpt('rescue_ramdisk_id',",
            "               help='Rescue ari image'),",
            "    cfg.StrOpt('virt_type',",
            "               default='kvm',",
            "               choices=('kvm', 'lxc', 'qemu', 'uml', 'xen', 'parallels'),",
            "               help='Libvirt domain type'),",
            "    cfg.StrOpt('connection_uri',",
            "               default='',",
            "               help='Override the default libvirt URI '",
            "                    '(which is dependent on virt_type)'),",
            "    cfg.BoolOpt('inject_password',",
            "                default=False,",
            "                help='Inject the admin password at boot time, '",
            "                     'without an agent.'),",
            "    cfg.BoolOpt('inject_key',",
            "                default=False,",
            "                help='Inject the ssh public key at boot time'),",
            "    cfg.IntOpt('inject_partition',",
            "                default=-2,",
            "                help='The partition to inject to : '",
            "                     '-2 => disable, -1 => inspect (libguestfs only), '",
            "                     '0 => not partitioned, >0 => partition number'),",
            "    cfg.BoolOpt('use_usb_tablet',",
            "                default=True,",
            "                help='Sync virtual and real mouse cursors in Windows VMs'),",
            "    cfg.StrOpt('live_migration_inbound_addr',",
            "               default=None,",
            "               help='Live migration target ip or hostname '",
            "                    '(if this option is set to be None,'",
            "                    'the hostname of the migration target'",
            "                    'compute node will be used)'),",
            "    cfg.StrOpt('live_migration_uri',",
            "               help='Override the default libvirt live migration target URI '",
            "                    '(which is dependent on virt_type) '",
            "                    '(any included \"%s\" is replaced with '",
            "                    'the migration target hostname)'),",
            "    cfg.StrOpt('live_migration_flag',",
            "               default='VIR_MIGRATE_UNDEFINE_SOURCE, VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, VIR_MIGRATE_TUNNELLED',",
            "               help='Migration flags to be set for live migration',",
            "               deprecated_for_removal=True,",
            "               deprecated_reason='The correct live migration flags can be '",
            "                                 'inferred from the new '",
            "                                 'live_migration_tunnelled config option. '",
            "                                 'live_migration_flag will be removed to '",
            "                                 'avoid potential misconfiguration.'),",
            "    cfg.StrOpt('block_migration_flag',",
            "               default='VIR_MIGRATE_UNDEFINE_SOURCE, VIR_MIGRATE_PEER2PEER, '",
            "                       'VIR_MIGRATE_LIVE, VIR_MIGRATE_TUNNELLED, '",
            "                       'VIR_MIGRATE_NON_SHARED_INC',",
            "               help='Migration flags to be set for block migration',",
            "               deprecated_for_removal=True,",
            "               deprecated_reason='The correct block migration flags can be '",
            "                                 'inferred from the new '",
            "                                 'live_migration_tunnelled config option. '",
            "                                 'block_migration_flag will be removed to '",
            "                                 'avoid potential misconfiguration.'),",
            "    cfg.BoolOpt('live_migration_tunnelled',",
            "                help='Whether to use tunnelled migration, where migration '",
            "                     'data is transported over the libvirtd connection. If '",
            "                     'True, we use the VIR_MIGRATE_TUNNELLED migration flag, '",
            "                     'avoiding the need to configure the network to allow '",
            "                     'direct hypervisor to hypervisor communication. If '",
            "                     'False, use the native transport. If not set, Nova '",
            "                     'will choose a sensible default based on, for example '",
            "                     'the availability of native encryption support in the '",
            "                     'hypervisor.'),",
            "    cfg.IntOpt('live_migration_bandwidth',",
            "               default=0,",
            "               help='Maximum bandwidth(in MiB/s) to be used during migration. '",
            "                    'If set to 0, will choose a suitable default. Some '",
            "                    'hypervisors do not support this feature and will return '",
            "                    'an error if bandwidth is not 0. Please refer to the '",
            "                    'libvirt documentation for further details'),",
            "    cfg.IntOpt('live_migration_downtime',",
            "               default=500,",
            "               help='Maximum permitted downtime, in milliseconds, for live '",
            "                    'migration switchover. Will be rounded up to a minimum '",
            "                    'of %dms. Use a large value if guest liveness is '",
            "                    'unimportant.' % LIVE_MIGRATION_DOWNTIME_MIN),",
            "    cfg.IntOpt('live_migration_downtime_steps',",
            "               default=10,",
            "               help='Number of incremental steps to reach max downtime value. '",
            "                    'Will be rounded up to a minimum of %d steps' %",
            "                    LIVE_MIGRATION_DOWNTIME_STEPS_MIN),",
            "    cfg.IntOpt('live_migration_downtime_delay',",
            "               default=75,",
            "               help='Time to wait, in seconds, between each step increase '",
            "                    'of the migration downtime. Minimum delay is %d seconds. '",
            "                    'Value is per GiB of guest RAM + disk to be transferred, '",
            "                    'with lower bound of a minimum of 2 GiB per device' %",
            "                    LIVE_MIGRATION_DOWNTIME_DELAY_MIN),",
            "    cfg.IntOpt('live_migration_completion_timeout',",
            "               default=800,",
            "               help='Time to wait, in seconds, for migration to successfully '",
            "                    'complete transferring data before aborting the '",
            "                    'operation. Value is per GiB of guest RAM + disk to be '",
            "                    'transferred, with lower bound of a minimum of 2 GiB. '",
            "                    'Should usually be larger than downtime delay * downtime '",
            "                    'steps. Set to 0 to disable timeouts.'),",
            "    cfg.IntOpt('live_migration_progress_timeout',",
            "               default=150,",
            "               help='Time to wait, in seconds, for migration to make forward '",
            "                    'progress in transferring data before aborting the '",
            "                    'operation. Set to 0 to disable timeouts.'),",
            "    cfg.StrOpt('snapshot_image_format',",
            "               choices=('raw', 'qcow2', 'vmdk', 'vdi'),",
            "               help='Snapshot image format. Defaults to same as source image'),",
            "    cfg.StrOpt('disk_prefix',",
            "               help='Override the default disk prefix for the devices attached'",
            "                    ' to a server, which is dependent on virt_type. '",
            "                    '(valid options are: sd, xvd, uvd, vd)'),",
            "    cfg.IntOpt('wait_soft_reboot_seconds',",
            "               default=120,",
            "               help='Number of seconds to wait for instance to shut down after'",
            "                    ' soft reboot request is made. We fall back to hard reboot'",
            "                    ' if instance does not shutdown within this window.'),",
            "    cfg.StrOpt('cpu_mode',",
            "               choices=('host-model', 'host-passthrough', 'custom', 'none'),",
            "               help='Set to \"host-model\" to clone the host CPU feature flags; '",
            "                    'to \"host-passthrough\" to use the host CPU model exactly; '",
            "                    'to \"custom\" to use a named CPU model; '",
            "                    'to \"none\" to not set any CPU model. '",
            "                    'If virt_type=\"kvm|qemu\", it will default to '",
            "                    '\"host-model\", otherwise it will default to \"none\"'),",
            "    cfg.StrOpt('cpu_model',",
            "               help='Set to a named libvirt CPU model (see names listed '",
            "                    'in /usr/share/libvirt/cpu_map.xml). Only has effect if '",
            "                    'cpu_mode=\"custom\" and virt_type=\"kvm|qemu\"'),",
            "    cfg.StrOpt('snapshots_directory',",
            "               default='$instances_path/snapshots',",
            "               help='Location where libvirt driver will store snapshots '",
            "                    'before uploading them to image service'),",
            "    cfg.StrOpt('xen_hvmloader_path',",
            "                default='/usr/lib/xen/boot/hvmloader',",
            "                help='Location where the Xen hvmloader is kept'),",
            "    cfg.ListOpt('disk_cachemodes',",
            "                 default=[],",
            "                 help='Specific cachemodes to use for different disk types '",
            "                      'e.g: file=directsync,block=none'),",
            "    cfg.StrOpt('rng_dev_path',",
            "                help='A path to a device that will be used as source of '",
            "                     'entropy on the host. Permitted options are: '",
            "                     '/dev/random or /dev/hwrng'),",
            "    cfg.ListOpt('hw_machine_type',",
            "               help='For qemu or KVM guests, set this option to specify '",
            "                    'a default machine type per host architecture. '",
            "                    'You can find a list of supported machine types '",
            "                    'in your environment by checking the output of '",
            "                    'the \"virsh capabilities\"command. The format of the '",
            "                    'value for this config option is host-arch=machine-type. '",
            "                    'For example: x86_64=machinetype1,armv7l=machinetype2'),",
            "    cfg.StrOpt('sysinfo_serial',",
            "               default='auto',",
            "               choices=('none', 'os', 'hardware', 'auto'),",
            "               help='The data source used to the populate the host \"serial\" '",
            "                    'UUID exposed to guest in the virtual BIOS.'),",
            "    cfg.IntOpt('mem_stats_period_seconds',",
            "                default=10,",
            "                help='A number of seconds to memory usage statistics period. '",
            "                     'Zero or negative value mean to disable memory usage '",
            "                     'statistics.'),",
            "    cfg.ListOpt('uid_maps',",
            "                default=[],",
            "                help='List of uid targets and ranges.'",
            "                     'Syntax is guest-uid:host-uid:count'",
            "                     'Maximum of 5 allowed.'),",
            "    cfg.ListOpt('gid_maps',",
            "                default=[],",
            "                help='List of guid targets and ranges.'",
            "                     'Syntax is guest-gid:host-gid:count'",
            "                     'Maximum of 5 allowed.'),",
            "    cfg.IntOpt('realtime_scheduler_priority',",
            "               default=1,",
            "               help='In a realtime host context vCPUs for guest will run in '",
            "               'that scheduling priority. Priority depends on the host '",
            "               'kernel (usually 1-99)')",
            "    ]",
            "",
            "CONF = nova.conf.CONF",
            "CONF.register_opts(libvirt_opts, 'libvirt')",
            "CONF.import_opt('host', 'nova.netconf')",
            "CONF.import_opt('my_ip', 'nova.netconf')",
            "CONF.import_opt('enabled', 'nova.compute.api',",
            "                group='ephemeral_storage_encryption')",
            "CONF.import_opt('cipher', 'nova.compute.api',",
            "                group='ephemeral_storage_encryption')",
            "CONF.import_opt('key_size', 'nova.compute.api',",
            "                group='ephemeral_storage_encryption')",
            "CONF.import_opt('live_migration_retry_count', 'nova.compute.manager')",
            "CONF.import_opt('server_proxyclient_address', 'nova.spice', group='spice')",
            "CONF.import_opt('vcpu_pin_set', 'nova.conf.virt')",
            "CONF.import_opt('hw_disk_discard', 'nova.virt.libvirt.imagebackend',",
            "                group='libvirt')",
            "CONF.import_group('workarounds', 'nova.utils')",
            "CONF.import_opt('iscsi_use_multipath', 'nova.virt.libvirt.volume.iscsi',",
            "                group='libvirt')",
            "",
            "DEFAULT_FIREWALL_DRIVER = \"%s.%s\" % (",
            "    libvirt_firewall.__name__,",
            "    libvirt_firewall.IptablesFirewallDriver.__name__)",
            "",
            "DEFAULT_UEFI_LOADER_PATH = {",
            "    \"x86_64\": \"/usr/share/OVMF/OVMF_CODE.fd\",",
            "    \"aarch64\": \"/usr/share/AAVMF/AAVMF_CODE.fd\"",
            "}",
            "",
            "MAX_CONSOLE_BYTES = 100 * units.Ki",
            "",
            "# The libvirt driver will prefix any disable reason codes with this string.",
            "DISABLE_PREFIX = 'AUTO: '",
            "# Disable reason for the service which was enabled or disabled without reason",
            "DISABLE_REASON_UNDEFINED = None",
            "",
            "# Guest config console string",
            "CONSOLE = \"console=tty0 console=ttyS0\"",
            "",
            "GuestNumaConfig = collections.namedtuple(",
            "    'GuestNumaConfig', ['cpuset', 'cputune', 'numaconfig', 'numatune'])",
            "",
            "libvirt_volume_drivers = [",
            "    'iscsi=nova.virt.libvirt.volume.iscsi.LibvirtISCSIVolumeDriver',",
            "    'iser=nova.virt.libvirt.volume.iser.LibvirtISERVolumeDriver',",
            "    'local=nova.virt.libvirt.volume.volume.LibvirtVolumeDriver',",
            "    'fake=nova.virt.libvirt.volume.volume.LibvirtFakeVolumeDriver',",
            "    'rbd=nova.virt.libvirt.volume.net.LibvirtNetVolumeDriver',",
            "    'sheepdog=nova.virt.libvirt.volume.net.LibvirtNetVolumeDriver',",
            "    'nfs=nova.virt.libvirt.volume.nfs.LibvirtNFSVolumeDriver',",
            "    'smbfs=nova.virt.libvirt.volume.smbfs.LibvirtSMBFSVolumeDriver',",
            "    'aoe=nova.virt.libvirt.volume.aoe.LibvirtAOEVolumeDriver',",
            "    'glusterfs='",
            "        'nova.virt.libvirt.volume.glusterfs.LibvirtGlusterfsVolumeDriver',",
            "    'fibre_channel='",
            "        'nova.virt.libvirt.volume.fibrechannel.'",
            "        'LibvirtFibreChannelVolumeDriver',",
            "    'scality=nova.virt.libvirt.volume.scality.LibvirtScalityVolumeDriver',",
            "    'gpfs=nova.virt.libvirt.volume.gpfs.LibvirtGPFSVolumeDriver',",
            "    'quobyte=nova.virt.libvirt.volume.quobyte.LibvirtQuobyteVolumeDriver',",
            "    'hgst=nova.virt.libvirt.volume.hgst.LibvirtHGSTVolumeDriver',",
            "    'scaleio=nova.virt.libvirt.volume.scaleio.LibvirtScaleIOVolumeDriver',",
            "    'disco=nova.virt.libvirt.volume.disco.LibvirtDISCOVolumeDriver',",
            "]",
            "",
            "",
            "def patch_tpool_proxy():",
            "    \"\"\"eventlet.tpool.Proxy doesn't work with old-style class in __str__()",
            "    or __repr__() calls. See bug #962840 for details.",
            "    We perform a monkey patch to replace those two instance methods.",
            "    \"\"\"",
            "    def str_method(self):",
            "        return str(self._obj)",
            "",
            "    def repr_method(self):",
            "        return repr(self._obj)",
            "",
            "    tpool.Proxy.__str__ = str_method",
            "    tpool.Proxy.__repr__ = repr_method",
            "",
            "",
            "patch_tpool_proxy()",
            "",
            "# For information about when MIN_LIBVIRT_VERSION and",
            "# NEXT_MIN_LIBVIRT_VERSION can be changed, consult",
            "#",
            "#   https://wiki.openstack.org/wiki/LibvirtDistroSupportMatrix",
            "#",
            "# Currently this is effectively the min version for i686/x86_64",
            "# + KVM/QEMU, as other architectures/hypervisors require newer",
            "# versions. Over time, this will become a common min version",
            "# for all architectures/hypervisors, as this value rises to",
            "# meet them.",
            "MIN_LIBVIRT_VERSION = (0, 10, 2)",
            "# TODO(berrange): Re-evaluate this at start of each release cycle",
            "# to decide if we want to plan a future min version bump.",
            "# MIN_LIBVIRT_VERSION can be updated to match this after",
            "# NEXT_MIN_LIBVIRT_VERSION  has been at a higher value for",
            "# one cycle",
            "NEXT_MIN_LIBVIRT_VERSION = (1, 2, 1)",
            "",
            "# When the above version matches/exceeds this version",
            "# delete it & corresponding code using it",
            "MIN_LIBVIRT_DEVICE_CALLBACK_VERSION = (1, 1, 1)",
            "# Live snapshot requirements",
            "MIN_LIBVIRT_LIVESNAPSHOT_VERSION = (1, 0, 0)",
            "MIN_QEMU_LIVESNAPSHOT_VERSION = (1, 3, 0)",
            "# BlockJobInfo management requirement",
            "MIN_LIBVIRT_BLOCKJOBINFO_VERSION = (1, 1, 1)",
            "# Relative block commit & rebase (feature is detected,",
            "# this version is only used for messaging)",
            "MIN_LIBVIRT_BLOCKJOB_RELATIVE_VERSION = (1, 2, 7)",
            "# Libvirt version 1.2.17 is required for successfull block live migration",
            "# of vm booted from image with attached devices",
            "MIN_LIBVIRT_BLOCK_LM_WITH_VOLUMES_VERSION = (1, 2, 17)",
            "# libvirt discard feature",
            "MIN_LIBVIRT_DISCARD_VERSION = (1, 0, 6)",
            "MIN_QEMU_DISCARD_VERSION = (1, 6, 0)",
            "# While earlier versions could support NUMA reporting and",
            "# NUMA placement, not until 1.2.7 was there the ability",
            "# to pin guest nodes to host nodes, so mandate that. Without",
            "# this the scheduler cannot make guaranteed decisions, as the",
            "# guest placement may not match what was requested",
            "MIN_LIBVIRT_NUMA_VERSION = (1, 2, 7)",
            "# PowerPC based hosts that support NUMA using libvirt",
            "MIN_LIBVIRT_NUMA_VERSION_PPC = (1, 2, 19)",
            "# Versions of libvirt with known NUMA topology issues",
            "# See bug #1449028",
            "BAD_LIBVIRT_NUMA_VERSIONS = [(1, 2, 9, 2)]",
            "# While earlier versions could support hugepage backed",
            "# guests, not until 1.2.8 was there the ability to request",
            "# a particular huge page size. Without this the scheduler",
            "# cannot make guaranteed decisions, as the huge page size",
            "# used by the guest may not match what was requested",
            "MIN_LIBVIRT_HUGEPAGE_VERSION = (1, 2, 8)",
            "# Versions of libvirt with broken cpu pinning support. This excludes",
            "# versions of libvirt with broken NUMA support since pinning needs",
            "# NUMA",
            "# See bug #1438226",
            "BAD_LIBVIRT_CPU_POLICY_VERSIONS = [(1, 2, 10)]",
            "# qemu 2.1 introduces support for pinning memory on host",
            "# NUMA nodes, along with the ability to specify hugepage",
            "# sizes per guest NUMA node",
            "MIN_QEMU_NUMA_HUGEPAGE_VERSION = (2, 1, 0)",
            "# fsFreeze/fsThaw requirement",
            "MIN_LIBVIRT_FSFREEZE_VERSION = (1, 2, 5)",
            "",
            "# UEFI booting support",
            "MIN_LIBVIRT_UEFI_VERSION = (1, 2, 9)",
            "",
            "# Hyper-V paravirtualized time source",
            "MIN_LIBVIRT_HYPERV_TIMER_VERSION = (1, 2, 2)",
            "MIN_QEMU_HYPERV_TIMER_VERSION = (2, 0, 0)",
            "",
            "MIN_LIBVIRT_HYPERV_FEATURE_VERSION = (1, 0, 0)",
            "MIN_LIBVIRT_HYPERV_FEATURE_EXTRA_VERSION = (1, 1, 0)",
            "MIN_QEMU_HYPERV_FEATURE_VERSION = (1, 1, 0)",
            "",
            "# parallels driver support",
            "MIN_LIBVIRT_PARALLELS_VERSION = (1, 2, 12)",
            "",
            "# Ability to set the user guest password with Qemu",
            "MIN_LIBVIRT_SET_ADMIN_PASSWD = (1, 2, 16)",
            "",
            "# s/390 & s/390x architectures with KVM",
            "MIN_LIBVIRT_KVM_S390_VERSION = (1, 2, 13)",
            "MIN_QEMU_S390_VERSION = (2, 3, 0)",
            "",
            "# libvirt < 1.3 reported virt_functions capability",
            "# only when VFs are enabled.",
            "# libvirt 1.3 fix f391889f4e942e22b9ef8ecca492de05106ce41e",
            "MIN_LIBVIRT_PF_WITH_NO_VFS_CAP_VERSION = (1, 3, 0)",
            "",
            "# ppc64/ppc64le architectures with KVM",
            "# NOTE(rfolco): Same levels for Libvirt/Qemu on Big Endian and Little",
            "# Endian giving the nuance around guest vs host architectures",
            "MIN_LIBVIRT_KVM_PPC64_VERSION = (1, 2, 12)",
            "MIN_QEMU_PPC64_VERSION = (2, 1, 0)",
            "",
            "# Names of the types that do not get compressed during migration",
            "NO_COMPRESSION_TYPES = ('qcow2',)",
            "",
            "# realtime suppport",
            "MIN_LIBVIRT_REALTIME_VERSION = (1, 2, 13)",
            "",
            "MIN_LIBVIRT_OTHER_ARCH = {arch.S390: MIN_LIBVIRT_KVM_S390_VERSION,",
            "                          arch.S390X: MIN_LIBVIRT_KVM_S390_VERSION,",
            "                          arch.PPC: MIN_LIBVIRT_KVM_PPC64_VERSION,",
            "                          arch.PPC64: MIN_LIBVIRT_KVM_PPC64_VERSION,",
            "                          arch.PPC64LE: MIN_LIBVIRT_KVM_PPC64_VERSION,",
            "                         }",
            "MIN_QEMU_OTHER_ARCH = {arch.S390: MIN_QEMU_S390_VERSION,",
            "                       arch.S390X: MIN_QEMU_S390_VERSION,",
            "                       arch.PPC: MIN_QEMU_PPC64_VERSION,",
            "                       arch.PPC64: MIN_QEMU_PPC64_VERSION,",
            "                       arch.PPC64LE: MIN_QEMU_PPC64_VERSION,",
            "                      }",
            "",
            "",
            "class LibvirtDriver(driver.ComputeDriver):",
            "    capabilities = {",
            "        \"has_imagecache\": True,",
            "        \"supports_recreate\": True,",
            "        \"supports_migrate_to_same_host\": False",
            "    }",
            "",
            "    def __init__(self, virtapi, read_only=False):",
            "        super(LibvirtDriver, self).__init__(virtapi)",
            "",
            "        global libvirt",
            "        if libvirt is None:",
            "            libvirt = importutils.import_module('libvirt')",
            "",
            "        self._host = host.Host(self._uri(), read_only,",
            "                               lifecycle_event_handler=self.emit_event,",
            "                               conn_event_handler=self._handle_conn_event)",
            "        self._initiator = None",
            "        self._fc_wwnns = None",
            "        self._fc_wwpns = None",
            "        self._caps = None",
            "        self.firewall_driver = firewall.load_driver(",
            "            DEFAULT_FIREWALL_DRIVER,",
            "            host=self._host)",
            "",
            "        self.vif_driver = libvirt_vif.LibvirtGenericVIFDriver()",
            "",
            "        self.volume_drivers = driver.driver_dict_from_config(",
            "            self._get_volume_drivers(), self)",
            "",
            "        self._disk_cachemode = None",
            "        self.image_cache_manager = imagecache.ImageCacheManager()",
            "        self.image_backend = imagebackend.Backend(CONF.use_cow_images)",
            "",
            "        self.disk_cachemodes = {}",
            "",
            "        self.valid_cachemodes = [\"default\",",
            "                                 \"none\",",
            "                                 \"writethrough\",",
            "                                 \"writeback\",",
            "                                 \"directsync\",",
            "                                 \"unsafe\",",
            "                                ]",
            "        self._conn_supports_start_paused = CONF.libvirt.virt_type in ('kvm',",
            "                                                                      'qemu')",
            "",
            "        for mode_str in CONF.libvirt.disk_cachemodes:",
            "            disk_type, sep, cache_mode = mode_str.partition('=')",
            "            if cache_mode not in self.valid_cachemodes:",
            "                LOG.warn(_LW('Invalid cachemode %(cache_mode)s specified '",
            "                             'for disk type %(disk_type)s.'),",
            "                         {'cache_mode': cache_mode, 'disk_type': disk_type})",
            "                continue",
            "            self.disk_cachemodes[disk_type] = cache_mode",
            "",
            "        self._volume_api = volume.API()",
            "        self._image_api = image.API()",
            "",
            "        sysinfo_serial_funcs = {",
            "            'none': lambda: None,",
            "            'hardware': self._get_host_sysinfo_serial_hardware,",
            "            'os': self._get_host_sysinfo_serial_os,",
            "            'auto': self._get_host_sysinfo_serial_auto,",
            "        }",
            "",
            "        self._sysinfo_serial_func = sysinfo_serial_funcs.get(",
            "            CONF.libvirt.sysinfo_serial)",
            "",
            "        self.job_tracker = instancejobtracker.InstanceJobTracker()",
            "        self._remotefs = remotefs.RemoteFilesystem()",
            "",
            "        self._live_migration_flags = self._block_migration_flags = None",
            "",
            "    def _get_volume_drivers(self):",
            "        return libvirt_volume_drivers",
            "",
            "    @property",
            "    def disk_cachemode(self):",
            "        if self._disk_cachemode is None:",
            "            # We prefer 'none' for consistent performance, host crash",
            "            # safety & migration correctness by avoiding host page cache.",
            "            # Some filesystems (eg GlusterFS via FUSE) don't support",
            "            # O_DIRECT though. For those we fallback to 'writethrough'",
            "            # which gives host crash safety, and is safe for migration",
            "            # provided the filesystem is cache coherent (cluster filesystems",
            "            # typically are, but things like NFS are not).",
            "            self._disk_cachemode = \"none\"",
            "            if not self._supports_direct_io(CONF.instances_path):",
            "                self._disk_cachemode = \"writethrough\"",
            "        return self._disk_cachemode",
            "",
            "    def _set_cache_mode(self, conf):",
            "        \"\"\"Set cache mode on LibvirtConfigGuestDisk object.\"\"\"",
            "        try:",
            "            source_type = conf.source_type",
            "            driver_cache = conf.driver_cache",
            "        except AttributeError:",
            "            return",
            "",
            "        cache_mode = self.disk_cachemodes.get(source_type,",
            "                                              driver_cache)",
            "        conf.driver_cache = cache_mode",
            "",
            "    def _do_quality_warnings(self):",
            "        \"\"\"Warn about untested driver configurations.",
            "",
            "        This will log a warning message about untested driver or host arch",
            "        configurations to indicate to administrators that the quality is",
            "        unknown. Currently, only qemu or kvm on intel 32- or 64-bit systems",
            "        is tested upstream.",
            "        \"\"\"",
            "        caps = self._host.get_capabilities()",
            "        hostarch = caps.host.cpu.arch",
            "        if (CONF.libvirt.virt_type not in ('qemu', 'kvm') or",
            "            hostarch not in (arch.I686, arch.X86_64)):",
            "            LOG.warn(_LW('The libvirt driver is not tested on '",
            "                         '%(type)s/%(arch)s by the OpenStack project and '",
            "                         'thus its quality can not be ensured. For more '",
            "                         'information, see: https://wiki.openstack.org/wiki/'",
            "                         'HypervisorSupportMatrix'),",
            "                        {'type': CONF.libvirt.virt_type, 'arch': hostarch})",
            "",
            "    def _handle_conn_event(self, enabled, reason):",
            "        LOG.info(_LI(\"Connection event '%(enabled)d' reason '%(reason)s'\"),",
            "                 {'enabled': enabled, 'reason': reason})",
            "        self._set_host_enabled(enabled, reason)",
            "",
            "    def _version_to_string(self, version):",
            "        return '.'.join([str(x) for x in version])",
            "",
            "    def init_host(self, host):",
            "        self._host.initialize()",
            "",
            "        self._do_quality_warnings()",
            "",
            "        self._parse_migration_flags()",
            "",
            "        if (CONF.libvirt.virt_type == 'lxc' and",
            "                not (CONF.libvirt.uid_maps and CONF.libvirt.gid_maps)):",
            "            LOG.warn(_LW(\"Running libvirt-lxc without user namespaces is \"",
            "                         \"dangerous. Containers spawned by Nova will be run \"",
            "                         \"as the host's root user. It is highly suggested \"",
            "                         \"that user namespaces be used in a public or \"",
            "                         \"multi-tenant environment.\"))",
            "",
            "        # Stop libguestfs using KVM unless we're also configured",
            "        # to use this. This solves problem where people need to",
            "        # stop Nova use of KVM because nested-virt is broken",
            "        if CONF.libvirt.virt_type != \"kvm\":",
            "            guestfs.force_tcg()",
            "",
            "        if not self._host.has_min_version(MIN_LIBVIRT_VERSION):",
            "            raise exception.NovaException(",
            "                _('Nova requires libvirt version %s or greater.') %",
            "                self._version_to_string(MIN_LIBVIRT_VERSION))",
            "",
            "        if (CONF.libvirt.virt_type == 'parallels' and",
            "            not self._host.has_min_version(MIN_LIBVIRT_PARALLELS_VERSION)):",
            "            raise exception.NovaException(",
            "                _('Running Nova with parallels virt_type requires '",
            "                  'libvirt version %s') %",
            "                self._version_to_string(MIN_LIBVIRT_PARALLELS_VERSION))",
            "",
            "        # Give the cloud admin a heads up if we are intending to",
            "        # change the MIN_LIBVIRT_VERSION in the next release.",
            "        if not self._host.has_min_version(NEXT_MIN_LIBVIRT_VERSION):",
            "            LOG.warning(_LW('Running Nova with a libvirt version less than '",
            "                            '%(version)s is deprecated. The required minimum '",
            "                            'version of libvirt will be raised to %(version)s '",
            "                            'in the next release.'),",
            "                        {'version': self._version_to_string(",
            "                            NEXT_MIN_LIBVIRT_VERSION)})",
            "",
            "        kvm_arch = arch.from_host()",
            "        if (CONF.libvirt.virt_type in ('kvm', 'qemu') and",
            "            kvm_arch in MIN_LIBVIRT_OTHER_ARCH and",
            "                not self._host.has_min_version(",
            "                                        MIN_LIBVIRT_OTHER_ARCH.get(kvm_arch),",
            "                                        MIN_QEMU_OTHER_ARCH.get(kvm_arch))):",
            "                raise exception.NovaException(",
            "                    _('Running Nova with qemu/kvm virt_type on %(arch)s '",
            "                      'requires libvirt version %(libvirt_ver)s and '",
            "                      'qemu version %(qemu_ver)s, or greater') %",
            "                    {'arch': kvm_arch,",
            "                     'libvirt_ver': self._version_to_string(",
            "                        MIN_LIBVIRT_OTHER_ARCH.get(kvm_arch)),",
            "                     'qemu_ver': self._version_to_string(",
            "                        MIN_QEMU_OTHER_ARCH.get(kvm_arch))})",
            "",
            "    def _check_required_migration_flags(self, migration_flags, config_name):",
            "        if CONF.libvirt.virt_type == 'xen':",
            "            if (migration_flags & libvirt.VIR_MIGRATE_PEER2PEER) != 0:",
            "                LOG.warning(_LW('Removing the VIR_MIGRATE_PEER2PEER flag from '",
            "                                '%(config_name)s because peer-to-peer '",
            "                                'migrations are not supported by the \"xen\" '",
            "                                'virt type'),",
            "                            {'config_name': config_name})",
            "                migration_flags &= ~libvirt.VIR_MIGRATE_PEER2PEER",
            "        else:",
            "            if (migration_flags & libvirt.VIR_MIGRATE_PEER2PEER) == 0:",
            "                LOG.warning(_LW('Adding the VIR_MIGRATE_PEER2PEER flag to '",
            "                                '%(config_name)s because direct migrations '",
            "                                'are not supported by the %(virt_type)s '",
            "                                'virt type'),",
            "                            {'config_name': config_name,",
            "                             'virt_type': CONF.libvirt.virt_type})",
            "                migration_flags |= libvirt.VIR_MIGRATE_PEER2PEER",
            "",
            "        if (migration_flags & libvirt.VIR_MIGRATE_UNDEFINE_SOURCE) == 0:",
            "            LOG.warning(_LW('Adding the VIR_MIGRATE_UNDEFINE_SOURCE flag to '",
            "                            '%(config_name)s because, without it, migrated '",
            "                            'VMs will remain defined on the source host'),",
            "                        {'config_name': config_name})",
            "            migration_flags |= libvirt.VIR_MIGRATE_UNDEFINE_SOURCE",
            "",
            "        if (migration_flags & libvirt.VIR_MIGRATE_PERSIST_DEST) != 0:",
            "            LOG.warning(_LW('Removing the VIR_MIGRATE_PERSIST_DEST flag from '",
            "                            '%(config_name)s as Nova ensures the VM is '",
            "                            'persisted on the destination host'),",
            "                        {'config_name': config_name})",
            "            migration_flags &= ~libvirt.VIR_MIGRATE_PERSIST_DEST",
            "",
            "        return migration_flags",
            "",
            "    def _check_block_migration_flags(self, live_migration_flags,",
            "                                     block_migration_flags):",
            "        if (live_migration_flags & libvirt.VIR_MIGRATE_NON_SHARED_INC) != 0:",
            "            LOG.warning(_LW('Removing the VIR_MIGRATE_NON_SHARED_INC flag '",
            "                            'from the live_migration_flag config option '",
            "                            'because it will cause all live-migrations to be '",
            "                            'block-migrations instead.'))",
            "            live_migration_flags &= ~libvirt.VIR_MIGRATE_NON_SHARED_INC",
            "",
            "        if (block_migration_flags & libvirt.VIR_MIGRATE_NON_SHARED_INC) == 0:",
            "            LOG.warning(_LW('Adding the VIR_MIGRATE_NON_SHARED_INC flag to '",
            "                            'the block_migration_flag config option, '",
            "                            'otherwise all block-migrations will be '",
            "                            'live-migrations instead.'))",
            "            block_migration_flags |= libvirt.VIR_MIGRATE_NON_SHARED_INC",
            "",
            "        return (live_migration_flags, block_migration_flags)",
            "",
            "    def _handle_live_migration_tunnelled(self, migration_flags, config_name):",
            "        if CONF.libvirt.live_migration_tunnelled is None:",
            "            return migration_flags",
            "",
            "        if CONF.libvirt.live_migration_tunnelled:",
            "            if (migration_flags & libvirt.VIR_MIGRATE_TUNNELLED) == 0:",
            "                LOG.warning(_LW('The %(config_name)s config option does not '",
            "                                'contain the VIR_MIGRATE_TUNNELLED flag but '",
            "                                'the live_migration_tunnelled is set to True '",
            "                                'which causes VIR_MIGRATE_TUNNELLED to be '",
            "                                'set'),",
            "                            {'config_name': config_name})",
            "            migration_flags |= libvirt.VIR_MIGRATE_TUNNELLED",
            "        else:",
            "            if (migration_flags & libvirt.VIR_MIGRATE_TUNNELLED) != 0:",
            "                LOG.warning(_LW('The %(config_name)s config option contains '",
            "                                'the VIR_MIGRATE_TUNNELLED flag but the '",
            "                                'live_migration_tunnelled is set to False '",
            "                                'which causes VIR_MIGRATE_TUNNELLED to be '",
            "                                'unset'),",
            "                            {'config_name': config_name})",
            "            migration_flags &= ~libvirt.VIR_MIGRATE_TUNNELLED",
            "",
            "        return migration_flags",
            "",
            "    def _parse_migration_flags(self):",
            "        def str2sum(str_val):",
            "            logical_sum = 0",
            "            for s in [i.strip() for i in str_val.split(',') if i]:",
            "                try:",
            "                    logical_sum |= getattr(libvirt, s)",
            "                except AttributeError:",
            "                    LOG.warning(_LW(\"Ignoring unknown libvirt live migration \"",
            "                                    \"flag '%(flag)s'\"), {'flag': s})",
            "            return logical_sum",
            "",
            "        live_migration_flags = str2sum(CONF.libvirt.live_migration_flag)",
            "        block_migration_flags = str2sum(CONF.libvirt.block_migration_flag)",
            "",
            "        live_config_name = 'live_migration_flag'",
            "        block_config_name = 'block_migration_flag'",
            "",
            "        live_migration_flags = self._check_required_migration_flags(",
            "            live_migration_flags, live_config_name)",
            "        block_migration_flags = self._check_required_migration_flags(",
            "            block_migration_flags, block_config_name)",
            "",
            "        (live_migration_flags,",
            "         block_migration_flags) = self._check_block_migration_flags(",
            "             live_migration_flags, block_migration_flags)",
            "",
            "        live_migration_flags = self._handle_live_migration_tunnelled(",
            "            live_migration_flags, live_config_name)",
            "        block_migration_flags = self._handle_live_migration_tunnelled(",
            "            block_migration_flags, block_config_name)",
            "",
            "        self._live_migration_flags = live_migration_flags",
            "        self._block_migration_flags = block_migration_flags",
            "",
            "    # TODO(sahid): This method is targeted for removal when the tests",
            "    # have been updated to avoid its use",
            "    #",
            "    # All libvirt API calls on the libvirt.Connect object should be",
            "    # encapsulated by methods on the nova.virt.libvirt.host.Host",
            "    # object, rather than directly invoking the libvirt APIs. The goal",
            "    # is to avoid a direct dependency on the libvirt API from the",
            "    # driver.py file.",
            "    def _get_connection(self):",
            "        return self._host.get_connection()",
            "",
            "    _conn = property(_get_connection)",
            "",
            "    @staticmethod",
            "    def _uri():",
            "        if CONF.libvirt.virt_type == 'uml':",
            "            uri = CONF.libvirt.connection_uri or 'uml:///system'",
            "        elif CONF.libvirt.virt_type == 'xen':",
            "            uri = CONF.libvirt.connection_uri or 'xen:///'",
            "        elif CONF.libvirt.virt_type == 'lxc':",
            "            uri = CONF.libvirt.connection_uri or 'lxc:///'",
            "        elif CONF.libvirt.virt_type == 'parallels':",
            "            uri = CONF.libvirt.connection_uri or 'parallels:///system'",
            "        else:",
            "            uri = CONF.libvirt.connection_uri or 'qemu:///system'",
            "        return uri",
            "",
            "    @staticmethod",
            "    def _live_migration_uri(dest):",
            "        # Only Xen and QEMU support live migration, see",
            "        # https://libvirt.org/migration.html#scenarios for reference",
            "        uris = {",
            "            'kvm': 'qemu+tcp://%s/system',",
            "            'qemu': 'qemu+tcp://%s/system',",
            "            'xen': 'xenmigr://%s/system',",
            "        }",
            "        virt_type = CONF.libvirt.virt_type",
            "        uri = CONF.libvirt.live_migration_uri or uris.get(virt_type)",
            "        if uri is None:",
            "            raise exception.LiveMigrationURINotAvailable(virt_type=virt_type)",
            "        return uri % dest",
            "",
            "    def instance_exists(self, instance):",
            "        \"\"\"Efficient override of base instance_exists method.\"\"\"",
            "        try:",
            "            self._host.get_guest(instance)",
            "            return True",
            "        except exception.NovaException:",
            "            return False",
            "",
            "    def list_instances(self):",
            "        names = []",
            "        for guest in self._host.list_guests(only_running=False):",
            "            names.append(guest.name)",
            "",
            "        return names",
            "",
            "    def list_instance_uuids(self):",
            "        uuids = []",
            "        for guest in self._host.list_guests(only_running=False):",
            "            uuids.append(guest.uuid)",
            "",
            "        return uuids",
            "",
            "    def plug_vifs(self, instance, network_info):",
            "        \"\"\"Plug VIFs into networks.\"\"\"",
            "        for vif in network_info:",
            "            self.vif_driver.plug(instance, vif)",
            "",
            "    def _unplug_vifs(self, instance, network_info, ignore_errors):",
            "        \"\"\"Unplug VIFs from networks.\"\"\"",
            "        for vif in network_info:",
            "            try:",
            "                self.vif_driver.unplug(instance, vif)",
            "            except exception.NovaException:",
            "                if not ignore_errors:",
            "                    raise",
            "",
            "    def unplug_vifs(self, instance, network_info):",
            "        self._unplug_vifs(instance, network_info, False)",
            "",
            "    def _teardown_container(self, instance):",
            "        inst_path = libvirt_utils.get_instance_path(instance)",
            "        container_dir = os.path.join(inst_path, 'rootfs')",
            "        rootfs_dev = instance.system_metadata.get('rootfs_device_name')",
            "        LOG.debug('Attempting to teardown container at path %(dir)s with '",
            "                  'root device: %(rootfs_dev)s',",
            "                  {'dir': container_dir, 'rootfs_dev': rootfs_dev},",
            "                  instance=instance)",
            "        disk.teardown_container(container_dir, rootfs_dev)",
            "",
            "    def _destroy(self, instance, attempt=1):",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "        except exception.InstanceNotFound:",
            "            guest = None",
            "",
            "        # If the instance is already terminated, we're still happy",
            "        # Otherwise, destroy it",
            "        old_domid = -1",
            "        if guest is not None:",
            "            try:",
            "                old_domid = guest.id",
            "                guest.poweroff()",
            "",
            "            except libvirt.libvirtError as e:",
            "                is_okay = False",
            "                errcode = e.get_error_code()",
            "                if errcode == libvirt.VIR_ERR_NO_DOMAIN:",
            "                    # Domain already gone. This can safely be ignored.",
            "                    is_okay = True",
            "                elif errcode == libvirt.VIR_ERR_OPERATION_INVALID:",
            "                    # If the instance is already shut off, we get this:",
            "                    # Code=55 Error=Requested operation is not valid:",
            "                    # domain is not running",
            "",
            "                    state = guest.get_power_state(self._host)",
            "                    if state == power_state.SHUTDOWN:",
            "                        is_okay = True",
            "                elif errcode == libvirt.VIR_ERR_INTERNAL_ERROR:",
            "                    errmsg = e.get_error_message()",
            "                    if (CONF.libvirt.virt_type == 'lxc' and",
            "                        errmsg == 'internal error: '",
            "                                  'Some processes refused to die'):",
            "                        # Some processes in the container didn't die",
            "                        # fast enough for libvirt. The container will",
            "                        # eventually die. For now, move on and let",
            "                        # the wait_for_destroy logic take over.",
            "                        is_okay = True",
            "                elif errcode == libvirt.VIR_ERR_OPERATION_TIMEOUT:",
            "                    LOG.warn(_LW(\"Cannot destroy instance, operation time \"",
            "                                 \"out\"),",
            "                             instance=instance)",
            "                    reason = _(\"operation time out\")",
            "                    raise exception.InstancePowerOffFailure(reason=reason)",
            "                elif errcode == libvirt.VIR_ERR_SYSTEM_ERROR:",
            "                    if e.get_int1() == errno.EBUSY:",
            "                        # NOTE(danpb): When libvirt kills a process it sends it",
            "                        # SIGTERM first and waits 10 seconds. If it hasn't gone",
            "                        # it sends SIGKILL and waits another 5 seconds. If it",
            "                        # still hasn't gone then you get this EBUSY error.",
            "                        # Usually when a QEMU process fails to go away upon",
            "                        # SIGKILL it is because it is stuck in an",
            "                        # uninterruptable kernel sleep waiting on I/O from",
            "                        # some non-responsive server.",
            "                        # Given the CPU load of the gate tests though, it is",
            "                        # conceivable that the 15 second timeout is too short,",
            "                        # particularly if the VM running tempest has a high",
            "                        # steal time from the cloud host. ie 15 wallclock",
            "                        # seconds may have passed, but the VM might have only",
            "                        # have a few seconds of scheduled run time.",
            "                        LOG.warn(_LW('Error from libvirt during destroy. '",
            "                                     'Code=%(errcode)s Error=%(e)s; '",
            "                                     'attempt %(attempt)d of 3'),",
            "                                 {'errcode': errcode, 'e': e,",
            "                                  'attempt': attempt},",
            "                                 instance=instance)",
            "                        with excutils.save_and_reraise_exception() as ctxt:",
            "                            # Try up to 3 times before giving up.",
            "                            if attempt < 3:",
            "                                ctxt.reraise = False",
            "                                self._destroy(instance, attempt + 1)",
            "                                return",
            "",
            "                if not is_okay:",
            "                    with excutils.save_and_reraise_exception():",
            "                        LOG.error(_LE('Error from libvirt during destroy. '",
            "                                      'Code=%(errcode)s Error=%(e)s'),",
            "                                  {'errcode': errcode, 'e': e},",
            "                                  instance=instance)",
            "",
            "        def _wait_for_destroy(expected_domid):",
            "            \"\"\"Called at an interval until the VM is gone.\"\"\"",
            "            # NOTE(vish): If the instance disappears during the destroy",
            "            #             we ignore it so the cleanup can still be",
            "            #             attempted because we would prefer destroy to",
            "            #             never fail.",
            "            try:",
            "                dom_info = self.get_info(instance)",
            "                state = dom_info.state",
            "                new_domid = dom_info.id",
            "            except exception.InstanceNotFound:",
            "                LOG.info(_LI(\"During wait destroy, instance disappeared.\"),",
            "                         instance=instance)",
            "                raise loopingcall.LoopingCallDone()",
            "",
            "            if state == power_state.SHUTDOWN:",
            "                LOG.info(_LI(\"Instance destroyed successfully.\"),",
            "                         instance=instance)",
            "                raise loopingcall.LoopingCallDone()",
            "",
            "            # NOTE(wangpan): If the instance was booted again after destroy,",
            "            #                this may be an endless loop, so check the id of",
            "            #                domain here, if it changed and the instance is",
            "            #                still running, we should destroy it again.",
            "            # see https://bugs.launchpad.net/nova/+bug/1111213 for more details",
            "            if new_domid != expected_domid:",
            "                LOG.info(_LI(\"Instance may be started again.\"),",
            "                         instance=instance)",
            "                kwargs['is_running'] = True",
            "                raise loopingcall.LoopingCallDone()",
            "",
            "        kwargs = {'is_running': False}",
            "        timer = loopingcall.FixedIntervalLoopingCall(_wait_for_destroy,",
            "                                                     old_domid)",
            "        timer.start(interval=0.5).wait()",
            "        if kwargs['is_running']:",
            "            LOG.info(_LI(\"Going to destroy instance again.\"),",
            "                     instance=instance)",
            "            self._destroy(instance)",
            "        else:",
            "            # NOTE(GuanQiang): teardown container to avoid resource leak",
            "            if CONF.libvirt.virt_type == 'lxc':",
            "                self._teardown_container(instance)",
            "",
            "    def destroy(self, context, instance, network_info, block_device_info=None,",
            "                destroy_disks=True, migrate_data=None):",
            "        self._destroy(instance)",
            "        self.cleanup(context, instance, network_info, block_device_info,",
            "                     destroy_disks, migrate_data)",
            "",
            "    def _undefine_domain(self, instance):",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "            try:",
            "                guest.delete_configuration()",
            "            except libvirt.libvirtError as e:",
            "                with excutils.save_and_reraise_exception():",
            "                    errcode = e.get_error_code()",
            "                    LOG.error(_LE('Error from libvirt during undefine. '",
            "                                  'Code=%(errcode)s Error=%(e)s'),",
            "                              {'errcode': errcode, 'e': e}, instance=instance)",
            "        except exception.InstanceNotFound:",
            "            pass",
            "",
            "    def cleanup(self, context, instance, network_info, block_device_info=None,",
            "                destroy_disks=True, migrate_data=None, destroy_vifs=True):",
            "        if destroy_vifs:",
            "            self._unplug_vifs(instance, network_info, True)",
            "",
            "        retry = True",
            "        while retry:",
            "            try:",
            "                self.unfilter_instance(instance, network_info)",
            "            except libvirt.libvirtError as e:",
            "                try:",
            "                    state = self.get_info(instance).state",
            "                except exception.InstanceNotFound:",
            "                    state = power_state.SHUTDOWN",
            "",
            "                if state != power_state.SHUTDOWN:",
            "                    LOG.warn(_LW(\"Instance may be still running, destroy \"",
            "                                 \"it again.\"), instance=instance)",
            "                    self._destroy(instance)",
            "                else:",
            "                    retry = False",
            "                    errcode = e.get_error_code()",
            "                    LOG.exception(_LE('Error from libvirt during unfilter. '",
            "                                      'Code=%(errcode)s Error=%(e)s'),",
            "                                  {'errcode': errcode, 'e': e},",
            "                                  instance=instance)",
            "                    reason = \"Error unfiltering instance.\"",
            "                    raise exception.InstanceTerminationFailure(reason=reason)",
            "            except Exception:",
            "                retry = False",
            "                raise",
            "            else:",
            "                retry = False",
            "",
            "        # FIXME(wangpan): if the instance is booted again here, such as the",
            "        #                 the soft reboot operation boot it here, it will",
            "        #                 become \"running deleted\", should we check and destroy",
            "        #                 it at the end of this method?",
            "",
            "        # NOTE(vish): we disconnect from volumes regardless",
            "        block_device_mapping = driver.block_device_info_get_mapping(",
            "            block_device_info)",
            "        for vol in block_device_mapping:",
            "            connection_info = vol['connection_info']",
            "            disk_dev = vol['mount_device']",
            "            if disk_dev is not None:",
            "                disk_dev = disk_dev.rpartition(\"/\")[2]",
            "",
            "            if ('data' in connection_info and",
            "                    'volume_id' in connection_info['data']):",
            "                volume_id = connection_info['data']['volume_id']",
            "                encryption = encryptors.get_encryption_metadata(",
            "                    context, self._volume_api, volume_id, connection_info)",
            "",
            "                if encryption:",
            "                    # The volume must be detached from the VM before",
            "                    # disconnecting it from its encryptor. Otherwise, the",
            "                    # encryptor may report that the volume is still in use.",
            "                    encryptor = self._get_volume_encryptor(connection_info,",
            "                                                           encryption)",
            "                    encryptor.detach_volume(**encryption)",
            "",
            "            try:",
            "                self._disconnect_volume(connection_info, disk_dev)",
            "            except Exception as exc:",
            "                with excutils.save_and_reraise_exception() as ctxt:",
            "                    if destroy_disks:",
            "                        # Don't block on Volume errors if we're trying to",
            "                        # delete the instance as we may be partially created",
            "                        # or deleted",
            "                        ctxt.reraise = False",
            "                        LOG.warn(_LW(\"Ignoring Volume Error on vol %(vol_id)s \"",
            "                                     \"during delete %(exc)s\"),",
            "                                 {'vol_id': vol.get('volume_id'), 'exc': exc},",
            "                                 instance=instance)",
            "",
            "        if destroy_disks:",
            "            # NOTE(haomai): destroy volumes if needed",
            "            if CONF.libvirt.images_type == 'lvm':",
            "                self._cleanup_lvm(instance, block_device_info)",
            "            if CONF.libvirt.images_type == 'rbd':",
            "                self._cleanup_rbd(instance)",
            "",
            "        is_shared_block_storage = False",
            "        if migrate_data and 'is_shared_block_storage' in migrate_data:",
            "            is_shared_block_storage = migrate_data.is_shared_block_storage",
            "        if destroy_disks or is_shared_block_storage:",
            "            attempts = int(instance.system_metadata.get('clean_attempts',",
            "                                                        '0'))",
            "            success = self.delete_instance_files(instance)",
            "            # NOTE(mriedem): This is used in the _run_pending_deletes periodic",
            "            # task in the compute manager. The tight coupling is not great...",
            "            instance.system_metadata['clean_attempts'] = str(attempts + 1)",
            "            if success:",
            "                instance.cleaned = True",
            "            instance.save()",
            "",
            "        if CONF.serial_console.enabled:",
            "            try:",
            "                guest = self._host.get_guest(instance)",
            "                serials = self._get_serial_ports_from_guest(guest)",
            "                for hostname, port in serials:",
            "                    serial_console.release_port(host=hostname, port=port)",
            "            except exception.InstanceNotFound:",
            "                pass",
            "",
            "        self._undefine_domain(instance)",
            "",
            "    def _detach_encrypted_volumes(self, instance, block_device_info):",
            "        \"\"\"Detaches encrypted volumes attached to instance.\"\"\"",
            "        disks = jsonutils.loads(self.get_instance_disk_info(instance,",
            "                                                            block_device_info))",
            "        encrypted_volumes = filter(dmcrypt.is_encrypted,",
            "                                   [disk['path'] for disk in disks])",
            "        for path in encrypted_volumes:",
            "            dmcrypt.delete_volume(path)",
            "",
            "    def _get_serial_ports_from_guest(self, guest, mode=None):",
            "        \"\"\"Returns an iterator over serial port(s) configured on guest.",
            "",
            "        :param mode: Should be a value in (None, bind, connect)",
            "        \"\"\"",
            "        xml = guest.get_xml_desc()",
            "        tree = etree.fromstring(xml)",
            "",
            "        # The 'serial' device is the base for x86 platforms. Other platforms",
            "        # (e.g. kvm on system z = arch.S390X) can only use 'console' devices.",
            "        xpath_mode = \"[@mode='%s']\" % mode if mode else \"\"",
            "        serial_tcp = \"./devices/serial[@type='tcp']/source\" + xpath_mode",
            "        console_tcp = \"./devices/console[@type='tcp']/source\" + xpath_mode",
            "",
            "        tcp_devices = tree.findall(serial_tcp)",
            "        if len(tcp_devices) == 0:",
            "            tcp_devices = tree.findall(console_tcp)",
            "        for source in tcp_devices:",
            "            yield (source.get(\"host\"), int(source.get(\"service\")))",
            "",
            "    @staticmethod",
            "    def _get_rbd_driver():",
            "        return rbd_utils.RBDDriver(",
            "                pool=CONF.libvirt.images_rbd_pool,",
            "                ceph_conf=CONF.libvirt.images_rbd_ceph_conf,",
            "                rbd_user=CONF.libvirt.rbd_user)",
            "",
            "    def _cleanup_rbd(self, instance):",
            "        LibvirtDriver._get_rbd_driver().cleanup_volumes(instance)",
            "",
            "    def _cleanup_lvm(self, instance, block_device_info):",
            "        \"\"\"Delete all LVM disks for given instance object.\"\"\"",
            "        if instance.get('ephemeral_key_uuid') is not None:",
            "            self._detach_encrypted_volumes(instance, block_device_info)",
            "",
            "        disks = self._lvm_disks(instance)",
            "        if disks:",
            "            lvm.remove_volumes(disks)",
            "",
            "    def _lvm_disks(self, instance):",
            "        \"\"\"Returns all LVM disks for given instance object.\"\"\"",
            "        if CONF.libvirt.images_volume_group:",
            "            vg = os.path.join('/dev', CONF.libvirt.images_volume_group)",
            "            if not os.path.exists(vg):",
            "                return []",
            "            pattern = '%s_' % instance.uuid",
            "",
            "            def belongs_to_instance(disk):",
            "                return disk.startswith(pattern)",
            "",
            "            def fullpath(name):",
            "                return os.path.join(vg, name)",
            "",
            "            logical_volumes = lvm.list_volumes(vg)",
            "",
            "            disk_names = filter(belongs_to_instance, logical_volumes)",
            "            disks = map(fullpath, disk_names)",
            "            return disks",
            "        return []",
            "",
            "    def get_volume_connector(self, instance):",
            "        root_helper = utils.get_root_helper()",
            "        return connector.get_connector_properties(",
            "            root_helper, CONF.my_block_storage_ip,",
            "            CONF.libvirt.iscsi_use_multipath,",
            "            enforce_multipath=True,",
            "            host=CONF.host)",
            "",
            "    def _cleanup_resize(self, instance, network_info):",
            "        # NOTE(wangpan): we get the pre-grizzly instance path firstly,",
            "        #                so the backup dir of pre-grizzly instance can",
            "        #                be deleted correctly with grizzly or later nova.",
            "        pre_grizzly_name = libvirt_utils.get_instance_path(instance,",
            "                                                           forceold=True)",
            "        target = pre_grizzly_name + '_resize'",
            "        if not os.path.exists(target):",
            "            target = libvirt_utils.get_instance_path(instance) + '_resize'",
            "",
            "        if os.path.exists(target):",
            "            # Deletion can fail over NFS, so retry the deletion as required.",
            "            # Set maximum attempt as 5, most test can remove the directory",
            "            # for the second time.",
            "            utils.execute('rm', '-rf', target, delay_on_retry=True,",
            "                          attempts=5)",
            "",
            "        backend = self.image_backend.image(instance, 'disk')",
            "        # TODO(nic): Set ignore_errors=False in a future release.",
            "        # It is set to True here to avoid any upgrade issues surrounding",
            "        # instances being in pending resize state when the software is updated;",
            "        # in that case there will be no snapshot to remove.  Once it can be",
            "        # reasonably assumed that no such instances exist in the wild",
            "        # anymore, it should be set back to False (the default) so it will",
            "        # throw errors, like it should.",
            "        backend.remove_snap(libvirt_utils.RESIZE_SNAPSHOT_NAME,",
            "                            ignore_errors=True)",
            "",
            "        if instance.host != CONF.host:",
            "            self._undefine_domain(instance)",
            "            self.unplug_vifs(instance, network_info)",
            "            self.unfilter_instance(instance, network_info)",
            "",
            "    def _get_volume_driver(self, connection_info):",
            "        driver_type = connection_info.get('driver_volume_type')",
            "        if driver_type not in self.volume_drivers:",
            "            raise exception.VolumeDriverNotFound(driver_type=driver_type)",
            "        return self.volume_drivers[driver_type]",
            "",
            "    def _connect_volume(self, connection_info, disk_info):",
            "        vol_driver = self._get_volume_driver(connection_info)",
            "        vol_driver.connect_volume(connection_info, disk_info)",
            "",
            "    def _disconnect_volume(self, connection_info, disk_dev):",
            "        vol_driver = self._get_volume_driver(connection_info)",
            "        vol_driver.disconnect_volume(connection_info, disk_dev)",
            "",
            "    def _get_volume_config(self, connection_info, disk_info):",
            "        vol_driver = self._get_volume_driver(connection_info)",
            "        return vol_driver.get_config(connection_info, disk_info)",
            "",
            "    def _get_volume_encryptor(self, connection_info, encryption):",
            "        encryptor = encryptors.get_volume_encryptor(connection_info,",
            "                                                    **encryption)",
            "        return encryptor",
            "",
            "    def _check_discard_for_attach_volume(self, conf, instance):",
            "        \"\"\"Perform some checks for volumes configured for discard support.",
            "",
            "        If discard is configured for the volume, and the guest is using a",
            "        configuration known to not work, we will log a message explaining",
            "        the reason why.",
            "        \"\"\"",
            "        if conf.driver_discard == 'unmap' and conf.target_bus == 'virtio':",
            "            LOG.debug('Attempting to attach volume %(id)s with discard '",
            "                      'support enabled to an instance using an '",
            "                      'unsupported configuration. target_bus = '",
            "                      '%(bus)s. Trim commands will not be issued to '",
            "                      'the storage device.',",
            "                      {'bus': conf.target_bus,",
            "                       'id': conf.serial},",
            "                      instance=instance)",
            "",
            "    def attach_volume(self, context, connection_info, instance, mountpoint,",
            "                      disk_bus=None, device_type=None, encryption=None):",
            "        guest = self._host.get_guest(instance)",
            "",
            "        disk_dev = mountpoint.rpartition(\"/\")[2]",
            "        bdm = {",
            "            'device_name': disk_dev,",
            "            'disk_bus': disk_bus,",
            "            'device_type': device_type}",
            "",
            "        # Note(cfb): If the volume has a custom block size, check that",
            "        #            that we are using QEMU/KVM and libvirt >= 0.10.2. The",
            "        #            presence of a block size is considered mandatory by",
            "        #            cinder so we fail if we can't honor the request.",
            "        data = {}",
            "        if ('data' in connection_info):",
            "            data = connection_info['data']",
            "        if ('logical_block_size' in data or 'physical_block_size' in data):",
            "            if ((CONF.libvirt.virt_type != \"kvm\" and",
            "                 CONF.libvirt.virt_type != \"qemu\")):",
            "                msg = _(\"Volume sets block size, but the current \"",
            "                        \"libvirt hypervisor '%s' does not support custom \"",
            "                        \"block size\") % CONF.libvirt.virt_type",
            "                raise exception.InvalidHypervisorType(msg)",
            "",
            "        disk_info = blockinfo.get_info_from_bdm(",
            "            instance, CONF.libvirt.virt_type, instance.image_meta, bdm)",
            "        self._connect_volume(connection_info, disk_info)",
            "        conf = self._get_volume_config(connection_info, disk_info)",
            "        self._set_cache_mode(conf)",
            "",
            "        self._check_discard_for_attach_volume(conf, instance)",
            "",
            "        try:",
            "            state = guest.get_power_state(self._host)",
            "            live = state in (power_state.RUNNING, power_state.PAUSED)",
            "",
            "            if encryption:",
            "                encryptor = self._get_volume_encryptor(connection_info,",
            "                                                       encryption)",
            "                encryptor.attach_volume(context, **encryption)",
            "",
            "            guest.attach_device(conf, persistent=True, live=live)",
            "        except Exception as ex:",
            "            LOG.exception(_LE('Failed to attach volume at mountpoint: %s'),",
            "                          mountpoint, instance=instance)",
            "            if isinstance(ex, libvirt.libvirtError):",
            "                errcode = ex.get_error_code()",
            "                if errcode == libvirt.VIR_ERR_OPERATION_FAILED:",
            "                    self._disconnect_volume(connection_info, disk_dev)",
            "                    raise exception.DeviceIsBusy(device=disk_dev)",
            "",
            "            with excutils.save_and_reraise_exception():",
            "                self._disconnect_volume(connection_info, disk_dev)",
            "",
            "    def _swap_volume(self, guest, disk_path, new_path, resize_to):",
            "        \"\"\"Swap existing disk with a new block device.\"\"\"",
            "        dev = guest.get_block_device(disk_path)",
            "",
            "        # Save a copy of the domain's persistent XML file",
            "        xml = guest.get_xml_desc(dump_inactive=True, dump_sensitive=True)",
            "",
            "        # Abort is an idempotent operation, so make sure any block",
            "        # jobs which may have failed are ended.",
            "        try:",
            "            dev.abort_job()",
            "        except Exception:",
            "            pass",
            "",
            "        try:",
            "            # NOTE (rmk): blockRebase cannot be executed on persistent",
            "            #             domains, so we need to temporarily undefine it.",
            "            #             If any part of this block fails, the domain is",
            "            #             re-defined regardless.",
            "            if guest.has_persistent_configuration():",
            "                guest.delete_configuration()",
            "",
            "            # Start copy with VIR_DOMAIN_REBASE_REUSE_EXT flag to",
            "            # allow writing to existing external volume file",
            "            dev.rebase(new_path, copy=True, reuse_ext=True)",
            "",
            "            while dev.wait_for_job():",
            "                time.sleep(0.5)",
            "",
            "            dev.abort_job(pivot=True)",
            "            if resize_to:",
            "                # NOTE(alex_xu): domain.blockJobAbort isn't sync call. This",
            "                # is bug in libvirt. So we need waiting for the pivot is",
            "                # finished. libvirt bug #1119173",
            "                while dev.wait_for_job(wait_for_job_clean=True):",
            "                    time.sleep(0.5)",
            "                dev.resize(resize_to * units.Gi / units.Ki)",
            "        finally:",
            "            self._host.write_instance_config(xml)",
            "",
            "    def swap_volume(self, old_connection_info,",
            "                    new_connection_info, instance, mountpoint, resize_to):",
            "",
            "        guest = self._host.get_guest(instance)",
            "",
            "        disk_dev = mountpoint.rpartition(\"/\")[2]",
            "        if not guest.get_disk(disk_dev):",
            "            raise exception.DiskNotFound(location=disk_dev)",
            "        disk_info = {",
            "            'dev': disk_dev,",
            "            'bus': blockinfo.get_disk_bus_for_disk_dev(",
            "                CONF.libvirt.virt_type, disk_dev),",
            "            'type': 'disk',",
            "            }",
            "        self._connect_volume(new_connection_info, disk_info)",
            "        conf = self._get_volume_config(new_connection_info, disk_info)",
            "        if not conf.source_path:",
            "            self._disconnect_volume(new_connection_info, disk_dev)",
            "            raise NotImplementedError(_(\"Swap only supports host devices\"))",
            "",
            "        # Save updates made in connection_info when connect_volume was called",
            "        volume_id = new_connection_info.get('serial')",
            "        bdm = objects.BlockDeviceMapping.get_by_volume_and_instance(",
            "            nova_context.get_admin_context(), volume_id, instance.uuid)",
            "        driver_bdm = driver_block_device.DriverVolumeBlockDevice(bdm)",
            "        driver_bdm['connection_info'] = new_connection_info",
            "        driver_bdm.save()",
            "",
            "        self._swap_volume(guest, disk_dev, conf.source_path, resize_to)",
            "        self._disconnect_volume(old_connection_info, disk_dev)",
            "",
            "    def _get_existing_domain_xml(self, instance, network_info,",
            "                                 block_device_info=None):",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "            xml = guest.get_xml_desc()",
            "        except exception.InstanceNotFound:",
            "            disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                                instance,",
            "                                                instance.image_meta,",
            "                                                block_device_info)",
            "            xml = self._get_guest_xml(nova_context.get_admin_context(),",
            "                                      instance, network_info, disk_info,",
            "                                      instance.image_meta,",
            "                                      block_device_info=block_device_info)",
            "        return xml",
            "",
            "    def detach_volume(self, connection_info, instance, mountpoint,",
            "                      encryption=None):",
            "        disk_dev = mountpoint.rpartition(\"/\")[2]",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "",
            "            state = guest.get_power_state(self._host)",
            "            live = state in (power_state.RUNNING, power_state.PAUSED)",
            "",
            "            wait_for_detach = guest.detach_device_with_retry(guest.get_disk,",
            "                                                             disk_dev,",
            "                                                             persistent=True,",
            "                                                             live=live)",
            "",
            "            if encryption:",
            "                # The volume must be detached from the VM before",
            "                # disconnecting it from its encryptor. Otherwise, the",
            "                # encryptor may report that the volume is still in use.",
            "                encryptor = self._get_volume_encryptor(connection_info,",
            "                                                       encryption)",
            "                encryptor.detach_volume(**encryption)",
            "",
            "            wait_for_detach()",
            "        except exception.InstanceNotFound:",
            "            # NOTE(zhaoqin): If the instance does not exist, _lookup_by_name()",
            "            #                will throw InstanceNotFound exception. Need to",
            "            #                disconnect volume under this circumstance.",
            "            LOG.warn(_LW(\"During detach_volume, instance disappeared.\"),",
            "                     instance=instance)",
            "        except exception.DeviceNotFound:",
            "            raise exception.DiskNotFound(location=disk_dev)",
            "        except libvirt.libvirtError as ex:",
            "            # NOTE(vish): This is called to cleanup volumes after live",
            "            #             migration, so we should still disconnect even if",
            "            #             the instance doesn't exist here anymore.",
            "            error_code = ex.get_error_code()",
            "            if error_code == libvirt.VIR_ERR_NO_DOMAIN:",
            "                # NOTE(vish):",
            "                LOG.warn(_LW(\"During detach_volume, instance disappeared.\"),",
            "                         instance=instance)",
            "            else:",
            "                raise",
            "",
            "        self._disconnect_volume(connection_info, disk_dev)",
            "",
            "    def attach_interface(self, instance, image_meta, vif):",
            "        guest = self._host.get_guest(instance)",
            "",
            "        self.vif_driver.plug(instance, vif)",
            "        self.firewall_driver.setup_basic_filtering(instance, [vif])",
            "        cfg = self.vif_driver.get_config(instance, vif, image_meta,",
            "                                         instance.flavor,",
            "                                         CONF.libvirt.virt_type,",
            "                                         self._host)",
            "        try:",
            "            state = guest.get_power_state(self._host)",
            "            live = state in (power_state.RUNNING, power_state.PAUSED)",
            "            guest.attach_device(cfg, persistent=True, live=live)",
            "        except libvirt.libvirtError:",
            "            LOG.error(_LE('attaching network adapter failed.'),",
            "                     instance=instance, exc_info=True)",
            "            self.vif_driver.unplug(instance, vif)",
            "            raise exception.InterfaceAttachFailed(",
            "                    instance_uuid=instance.uuid)",
            "",
            "    def detach_interface(self, instance, vif):",
            "        guest = self._host.get_guest(instance)",
            "        cfg = self.vif_driver.get_config(instance, vif,",
            "                                         instance.image_meta,",
            "                                         instance.flavor,",
            "                                         CONF.libvirt.virt_type, self._host)",
            "        try:",
            "            self.vif_driver.unplug(instance, vif)",
            "            state = guest.get_power_state(self._host)",
            "            live = state in (power_state.RUNNING, power_state.PAUSED)",
            "            guest.detach_device(cfg, persistent=True, live=live)",
            "        except libvirt.libvirtError as ex:",
            "            error_code = ex.get_error_code()",
            "            if error_code == libvirt.VIR_ERR_NO_DOMAIN:",
            "                LOG.warn(_LW(\"During detach_interface, \"",
            "                             \"instance disappeared.\"),",
            "                         instance=instance)",
            "            else:",
            "                # NOTE(mriedem): When deleting an instance and using Neutron,",
            "                # we can be racing against Neutron deleting the port and",
            "                # sending the vif-deleted event which then triggers a call to",
            "                # detach the interface, so we might have failed because the",
            "                # network device no longer exists. Libvirt will fail with",
            "                # \"operation failed: no matching network device was found\"",
            "                # which unfortunately does not have a unique error code so we",
            "                # need to look up the interface by MAC and if it's not found",
            "                # then we can just log it as a warning rather than tracing an",
            "                # error.",
            "                mac = vif.get('address')",
            "                interface = guest.get_interface_by_mac(mac)",
            "                if interface:",
            "                    LOG.error(_LE('detaching network adapter failed.'),",
            "                             instance=instance, exc_info=True)",
            "                    raise exception.InterfaceDetachFailed(",
            "                            instance_uuid=instance.uuid)",
            "",
            "                # The interface is gone so just log it as a warning.",
            "                LOG.warning(_LW('Detaching interface %(mac)s failed  because '",
            "                                'the device is no longer found on the guest.'),",
            "                            {'mac': mac}, instance=instance)",
            "",
            "    def _create_snapshot_metadata(self, image_meta, instance,",
            "                                  img_fmt, snp_name):",
            "        metadata = {'is_public': False,",
            "                    'status': 'active',",
            "                    'name': snp_name,",
            "                    'properties': {",
            "                                   'kernel_id': instance.kernel_id,",
            "                                   'image_location': 'snapshot',",
            "                                   'image_state': 'available',",
            "                                   'owner_id': instance.project_id,",
            "                                   'ramdisk_id': instance.ramdisk_id,",
            "                                   }",
            "                    }",
            "        if instance.os_type:",
            "            metadata['properties']['os_type'] = instance.os_type",
            "",
            "        # NOTE(vish): glance forces ami disk format to be ami",
            "        if image_meta.disk_format == 'ami':",
            "            metadata['disk_format'] = 'ami'",
            "        else:",
            "            metadata['disk_format'] = img_fmt",
            "",
            "        if image_meta.obj_attr_is_set(\"container_format\"):",
            "            metadata['container_format'] = image_meta.container_format",
            "        else:",
            "            metadata['container_format'] = \"bare\"",
            "",
            "        return metadata",
            "",
            "    def snapshot(self, context, instance, image_id, update_task_state):",
            "        \"\"\"Create snapshot from a running VM instance.",
            "",
            "        This command only works with qemu 0.14+",
            "        \"\"\"",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "",
            "            # TODO(sahid): We are converting all calls from a",
            "            # virDomain object to use nova.virt.libvirt.Guest.",
            "            # We should be able to remove virt_dom at the end.",
            "            virt_dom = guest._domain",
            "        except exception.InstanceNotFound:",
            "            raise exception.InstanceNotRunning(instance_id=instance.uuid)",
            "",
            "        snapshot = self._image_api.get(context, image_id)",
            "",
            "        # source_format is an on-disk format",
            "        # source_type is a backend type",
            "        disk_path, source_format = libvirt_utils.find_disk(virt_dom)",
            "        source_type = libvirt_utils.get_disk_type_from_path(disk_path)",
            "",
            "        # We won't have source_type for raw or qcow2 disks, because we can't",
            "        # determine that from the path. We should have it from the libvirt",
            "        # xml, though.",
            "        if source_type is None:",
            "            source_type = source_format",
            "        # For lxc instances we won't have it either from libvirt xml",
            "        # (because we just gave libvirt the mounted filesystem), or the path,",
            "        # so source_type is still going to be None. In this case,",
            "        # snapshot_backend is going to default to CONF.libvirt.images_type",
            "        # below, which is still safe.",
            "",
            "        image_format = CONF.libvirt.snapshot_image_format or source_type",
            "",
            "        # NOTE(bfilippov): save lvm and rbd as raw",
            "        if image_format == 'lvm' or image_format == 'rbd':",
            "            image_format = 'raw'",
            "",
            "        metadata = self._create_snapshot_metadata(instance.image_meta,",
            "                                                  instance,",
            "                                                  image_format,",
            "                                                  snapshot['name'])",
            "",
            "        snapshot_name = uuid.uuid4().hex",
            "",
            "        state = guest.get_power_state(self._host)",
            "",
            "        # NOTE(rmk): Live snapshots require QEMU 1.3 and Libvirt 1.0.0.",
            "        #            These restrictions can be relaxed as other configurations",
            "        #            can be validated.",
            "        # NOTE(dgenin): Instances with LVM encrypted ephemeral storage require",
            "        #               cold snapshots. Currently, checking for encryption is",
            "        #               redundant because LVM supports only cold snapshots.",
            "        #               It is necessary in case this situation changes in the",
            "        #               future.",
            "        if (self._host.has_min_version(MIN_LIBVIRT_LIVESNAPSHOT_VERSION,",
            "                                       MIN_QEMU_LIVESNAPSHOT_VERSION,",
            "                                       host.HV_DRIVER_QEMU)",
            "             and source_type not in ('lvm', 'rbd')",
            "             and not CONF.ephemeral_storage_encryption.enabled",
            "             and not CONF.workarounds.disable_libvirt_livesnapshot):",
            "            live_snapshot = True",
            "            # Abort is an idempotent operation, so make sure any block",
            "            # jobs which may have failed are ended. This operation also",
            "            # confirms the running instance, as opposed to the system as a",
            "            # whole, has a new enough version of the hypervisor (bug 1193146).",
            "            try:",
            "                guest.get_block_device(disk_path).abort_job()",
            "            except libvirt.libvirtError as ex:",
            "                error_code = ex.get_error_code()",
            "                if error_code == libvirt.VIR_ERR_CONFIG_UNSUPPORTED:",
            "                    live_snapshot = False",
            "                else:",
            "                    pass",
            "        else:",
            "            live_snapshot = False",
            "",
            "        # NOTE(rmk): We cannot perform live snapshots when a managedSave",
            "        #            file is present, so we will use the cold/legacy method",
            "        #            for instances which are shutdown.",
            "        if state == power_state.SHUTDOWN:",
            "            live_snapshot = False",
            "",
            "        # NOTE(dkang): managedSave does not work for LXC",
            "        if CONF.libvirt.virt_type != 'lxc' and not live_snapshot:",
            "            if state == power_state.RUNNING or state == power_state.PAUSED:",
            "                self._detach_pci_devices(guest,",
            "                    pci_manager.get_instance_pci_devs(instance))",
            "                self._detach_sriov_ports(context, instance, guest)",
            "                guest.save_memory_state()",
            "",
            "        snapshot_backend = self.image_backend.snapshot(instance,",
            "                disk_path,",
            "                image_type=source_type)",
            "",
            "        if live_snapshot:",
            "            LOG.info(_LI(\"Beginning live snapshot process\"),",
            "                     instance=instance)",
            "        else:",
            "            LOG.info(_LI(\"Beginning cold snapshot process\"),",
            "                     instance=instance)",
            "",
            "        update_task_state(task_state=task_states.IMAGE_PENDING_UPLOAD)",
            "",
            "        try:",
            "            update_task_state(task_state=task_states.IMAGE_UPLOADING,",
            "                              expected_state=task_states.IMAGE_PENDING_UPLOAD)",
            "            metadata['location'] = snapshot_backend.direct_snapshot(",
            "                context, snapshot_name, image_format, image_id,",
            "                instance.image_ref)",
            "            self._snapshot_domain(context, live_snapshot, virt_dom, state,",
            "                                  instance)",
            "            self._image_api.update(context, image_id, metadata,",
            "                                   purge_props=False)",
            "        except (NotImplementedError, exception.ImageUnacceptable,",
            "                exception.Forbidden) as e:",
            "            if type(e) != NotImplementedError:",
            "                LOG.warning(_LW('Performing standard snapshot because direct '",
            "                                'snapshot failed: %(error)s'), {'error': e})",
            "            failed_snap = metadata.pop('location', None)",
            "            if failed_snap:",
            "                failed_snap = {'url': str(failed_snap)}",
            "            snapshot_backend.cleanup_direct_snapshot(failed_snap,",
            "                                                     also_destroy_volume=True,",
            "                                                     ignore_errors=True)",
            "            update_task_state(task_state=task_states.IMAGE_PENDING_UPLOAD,",
            "                              expected_state=task_states.IMAGE_UPLOADING)",
            "",
            "            snapshot_directory = CONF.libvirt.snapshots_directory",
            "            fileutils.ensure_tree(snapshot_directory)",
            "            with utils.tempdir(dir=snapshot_directory) as tmpdir:",
            "                try:",
            "                    out_path = os.path.join(tmpdir, snapshot_name)",
            "                    if live_snapshot:",
            "                        # NOTE(xqueralt): libvirt needs o+x in the tempdir",
            "                        os.chmod(tmpdir, 0o701)",
            "                        self._live_snapshot(context, instance, guest,",
            "                                            disk_path, out_path, source_format,",
            "                                            image_format, instance.image_meta)",
            "                    else:",
            "                        snapshot_backend.snapshot_extract(out_path,",
            "                                                          image_format)",
            "                finally:",
            "                    self._snapshot_domain(context, live_snapshot, virt_dom,",
            "                                          state, instance)",
            "                    LOG.info(_LI(\"Snapshot extracted, beginning image upload\"),",
            "                             instance=instance)",
            "",
            "                # Upload that image to the image service",
            "                update_task_state(task_state=task_states.IMAGE_UPLOADING,",
            "                        expected_state=task_states.IMAGE_PENDING_UPLOAD)",
            "                with libvirt_utils.file_open(out_path) as image_file:",
            "                    self._image_api.update(context,",
            "                                           image_id,",
            "                                           metadata,",
            "                                           image_file)",
            "        except Exception:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.exception(_LE(\"Failed to snapshot image\"))",
            "                failed_snap = metadata.pop('location', None)",
            "                if failed_snap:",
            "                    failed_snap = {'url': str(failed_snap)}",
            "                snapshot_backend.cleanup_direct_snapshot(",
            "                        failed_snap, also_destroy_volume=True,",
            "                        ignore_errors=True)",
            "",
            "        LOG.info(_LI(\"Snapshot image upload complete\"), instance=instance)",
            "",
            "    def _snapshot_domain(self, context, live_snapshot, virt_dom, state,",
            "                         instance):",
            "        guest = None",
            "        # NOTE(dkang): because previous managedSave is not called",
            "        #              for LXC, _create_domain must not be called.",
            "        if CONF.libvirt.virt_type != 'lxc' and not live_snapshot:",
            "            if state == power_state.RUNNING:",
            "                guest = self._create_domain(domain=virt_dom)",
            "            elif state == power_state.PAUSED:",
            "                guest = self._create_domain(domain=virt_dom, pause=True)",
            "",
            "            if guest is not None:",
            "                self._attach_pci_devices(",
            "                    guest, pci_manager.get_instance_pci_devs(instance))",
            "                self._attach_sriov_ports(context, instance, guest)",
            "",
            "    def _can_set_admin_password(self, image_meta):",
            "        if (CONF.libvirt.virt_type not in ('kvm', 'qemu') or",
            "            not self._host.has_min_version(MIN_LIBVIRT_SET_ADMIN_PASSWD)):",
            "            raise exception.SetAdminPasswdNotSupported()",
            "",
            "        hw_qga = image_meta.properties.get('hw_qemu_guest_agent', '')",
            "        if not strutils.bool_from_string(hw_qga):",
            "            raise exception.QemuGuestAgentNotEnabled()",
            "",
            "    def set_admin_password(self, instance, new_pass):",
            "        self._can_set_admin_password(instance.image_meta)",
            "",
            "        guest = self._host.get_guest(instance)",
            "        user = instance.image_meta.properties.get(\"os_admin_user\")",
            "        if not user:",
            "            if instance.os_type == \"windows\":",
            "                user = \"Administrator\"",
            "            else:",
            "                user = \"root\"",
            "        try:",
            "            guest.set_user_password(user, new_pass)",
            "        except libvirt.libvirtError as ex:",
            "            error_code = ex.get_error_code()",
            "            msg = (_('Error from libvirt while set password for username '",
            "                     '\"%(user)s\": [Error Code %(error_code)s] %(ex)s')",
            "                   % {'user': user, 'error_code': error_code, 'ex': ex})",
            "            raise exception.NovaException(msg)",
            "",
            "    def _can_quiesce(self, instance, image_meta):",
            "        if (CONF.libvirt.virt_type not in ('kvm', 'qemu') or",
            "            not self._host.has_min_version(MIN_LIBVIRT_FSFREEZE_VERSION)):",
            "            raise exception.InstanceQuiesceNotSupported(",
            "                instance_id=instance.uuid)",
            "",
            "        if not image_meta.properties.get('hw_qemu_guest_agent', False):",
            "            raise exception.QemuGuestAgentNotEnabled()",
            "",
            "    def _set_quiesced(self, context, instance, image_meta, quiesced):",
            "        self._can_quiesce(instance, image_meta)",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "            if quiesced:",
            "                guest.freeze_filesystems()",
            "            else:",
            "                guest.thaw_filesystems()",
            "        except libvirt.libvirtError as ex:",
            "            error_code = ex.get_error_code()",
            "            msg = (_('Error from libvirt while quiescing %(instance_name)s: '",
            "                     '[Error Code %(error_code)s] %(ex)s')",
            "                   % {'instance_name': instance.name,",
            "                      'error_code': error_code, 'ex': ex})",
            "            raise exception.NovaException(msg)",
            "",
            "    def quiesce(self, context, instance, image_meta):",
            "        \"\"\"Freeze the guest filesystems to prepare for snapshot.",
            "",
            "        The qemu-guest-agent must be setup to execute fsfreeze.",
            "        \"\"\"",
            "        self._set_quiesced(context, instance, image_meta, True)",
            "",
            "    def unquiesce(self, context, instance, image_meta):",
            "        \"\"\"Thaw the guest filesystems after snapshot.\"\"\"",
            "        self._set_quiesced(context, instance, image_meta, False)",
            "",
            "    def _live_snapshot(self, context, instance, guest, disk_path, out_path,",
            "                       source_format, image_format, image_meta):",
            "        \"\"\"Snapshot an instance without downtime.\"\"\"",
            "        dev = guest.get_block_device(disk_path)",
            "",
            "        # Save a copy of the domain's persistent XML file",
            "        xml = guest.get_xml_desc(dump_inactive=True, dump_sensitive=True)",
            "",
            "        # Abort is an idempotent operation, so make sure any block",
            "        # jobs which may have failed are ended.",
            "        try:",
            "            dev.abort_job()",
            "        except Exception:",
            "            pass",
            "",
            "        # NOTE (rmk): We are using shallow rebases as a workaround to a bug",
            "        #             in QEMU 1.3. In order to do this, we need to create",
            "        #             a destination image with the original backing file",
            "        #             and matching size of the instance root disk.",
            "        src_disk_size = libvirt_utils.get_disk_size(disk_path,",
            "                                                    format=source_format)",
            "        src_back_path = libvirt_utils.get_disk_backing_file(disk_path,",
            "                                                        format=source_format,",
            "                                                        basename=False)",
            "        disk_delta = out_path + '.delta'",
            "        libvirt_utils.create_cow_image(src_back_path, disk_delta,",
            "                                       src_disk_size)",
            "",
            "        quiesced = False",
            "        try:",
            "            self._set_quiesced(context, instance, image_meta, True)",
            "            quiesced = True",
            "        except exception.NovaException as err:",
            "            if image_meta.properties.get('os_require_quiesce', False):",
            "                raise",
            "            LOG.info(_LI('Skipping quiescing instance: %(reason)s.'),",
            "                     {'reason': err}, instance=instance)",
            "",
            "        try:",
            "            # NOTE (rmk): blockRebase cannot be executed on persistent",
            "            #             domains, so we need to temporarily undefine it.",
            "            #             If any part of this block fails, the domain is",
            "            #             re-defined regardless.",
            "            if guest.has_persistent_configuration():",
            "                guest.delete_configuration()",
            "",
            "            # NOTE (rmk): Establish a temporary mirror of our root disk and",
            "            #             issue an abort once we have a complete copy.",
            "            dev.rebase(disk_delta, copy=True, reuse_ext=True, shallow=True)",
            "",
            "            while dev.wait_for_job():",
            "                time.sleep(0.5)",
            "",
            "            dev.abort_job()",
            "            libvirt_utils.chown(disk_delta, os.getuid())",
            "        finally:",
            "            self._host.write_instance_config(xml)",
            "            if quiesced:",
            "                self._set_quiesced(context, instance, image_meta, False)",
            "",
            "        # Convert the delta (CoW) image with a backing file to a flat",
            "        # image with no backing file.",
            "        libvirt_utils.extract_snapshot(disk_delta, 'qcow2',",
            "                                       out_path, image_format)",
            "",
            "    def _volume_snapshot_update_status(self, context, snapshot_id, status):",
            "        \"\"\"Send a snapshot status update to Cinder.",
            "",
            "        This method captures and logs exceptions that occur",
            "        since callers cannot do anything useful with these exceptions.",
            "",
            "        Operations on the Cinder side waiting for this will time out if",
            "        a failure occurs sending the update.",
            "",
            "        :param context: security context",
            "        :param snapshot_id: id of snapshot being updated",
            "        :param status: new status value",
            "",
            "        \"\"\"",
            "",
            "        try:",
            "            self._volume_api.update_snapshot_status(context,",
            "                                                    snapshot_id,",
            "                                                    status)",
            "        except Exception:",
            "            LOG.exception(_LE('Failed to send updated snapshot status '",
            "                              'to volume service.'))",
            "",
            "    def _volume_snapshot_create(self, context, instance, guest,",
            "                                volume_id, new_file):",
            "        \"\"\"Perform volume snapshot.",
            "",
            "           :param guest: VM that volume is attached to",
            "           :param volume_id: volume UUID to snapshot",
            "           :param new_file: relative path to new qcow2 file present on share",
            "",
            "        \"\"\"",
            "        xml = guest.get_xml_desc()",
            "        xml_doc = etree.fromstring(xml)",
            "",
            "        device_info = vconfig.LibvirtConfigGuest()",
            "        device_info.parse_dom(xml_doc)",
            "",
            "        disks_to_snap = []          # to be snapshotted by libvirt",
            "        network_disks_to_snap = []  # network disks (netfs, gluster, etc.)",
            "        disks_to_skip = []          # local disks not snapshotted",
            "",
            "        for guest_disk in device_info.devices:",
            "            if (guest_disk.root_name != 'disk'):",
            "                continue",
            "",
            "            if (guest_disk.target_dev is None):",
            "                continue",
            "",
            "            if (guest_disk.serial is None or guest_disk.serial != volume_id):",
            "                disks_to_skip.append(guest_disk.target_dev)",
            "                continue",
            "",
            "            # disk is a Cinder volume with the correct volume_id",
            "",
            "            disk_info = {",
            "                'dev': guest_disk.target_dev,",
            "                'serial': guest_disk.serial,",
            "                'current_file': guest_disk.source_path,",
            "                'source_protocol': guest_disk.source_protocol,",
            "                'source_name': guest_disk.source_name,",
            "                'source_hosts': guest_disk.source_hosts,",
            "                'source_ports': guest_disk.source_ports",
            "            }",
            "",
            "            # Determine path for new_file based on current path",
            "            if disk_info['current_file'] is not None:",
            "                current_file = disk_info['current_file']",
            "                new_file_path = os.path.join(os.path.dirname(current_file),",
            "                                             new_file)",
            "                disks_to_snap.append((current_file, new_file_path))",
            "            elif disk_info['source_protocol'] in ('gluster', 'netfs'):",
            "                network_disks_to_snap.append((disk_info, new_file))",
            "",
            "        if not disks_to_snap and not network_disks_to_snap:",
            "            msg = _('Found no disk to snapshot.')",
            "            raise exception.NovaException(msg)",
            "",
            "        snapshot = vconfig.LibvirtConfigGuestSnapshot()",
            "",
            "        for current_name, new_filename in disks_to_snap:",
            "            snap_disk = vconfig.LibvirtConfigGuestSnapshotDisk()",
            "            snap_disk.name = current_name",
            "            snap_disk.source_path = new_filename",
            "            snap_disk.source_type = 'file'",
            "            snap_disk.snapshot = 'external'",
            "            snap_disk.driver_name = 'qcow2'",
            "",
            "            snapshot.add_disk(snap_disk)",
            "",
            "        for disk_info, new_filename in network_disks_to_snap:",
            "            snap_disk = vconfig.LibvirtConfigGuestSnapshotDisk()",
            "            snap_disk.name = disk_info['dev']",
            "            snap_disk.source_type = 'network'",
            "            snap_disk.source_protocol = disk_info['source_protocol']",
            "            snap_disk.snapshot = 'external'",
            "            snap_disk.source_path = new_filename",
            "            old_dir = disk_info['source_name'].split('/')[0]",
            "            snap_disk.source_name = '%s/%s' % (old_dir, new_filename)",
            "            snap_disk.source_hosts = disk_info['source_hosts']",
            "            snap_disk.source_ports = disk_info['source_ports']",
            "",
            "            snapshot.add_disk(snap_disk)",
            "",
            "        for dev in disks_to_skip:",
            "            snap_disk = vconfig.LibvirtConfigGuestSnapshotDisk()",
            "            snap_disk.name = dev",
            "            snap_disk.snapshot = 'no'",
            "",
            "            snapshot.add_disk(snap_disk)",
            "",
            "        snapshot_xml = snapshot.to_xml()",
            "        LOG.debug(\"snap xml: %s\", snapshot_xml, instance=instance)",
            "",
            "        try:",
            "            guest.snapshot(snapshot, no_metadata=True, disk_only=True,",
            "                           reuse_ext=True, quiesce=True)",
            "            return",
            "        except libvirt.libvirtError:",
            "            LOG.exception(_LE('Unable to create quiesced VM snapshot, '",
            "                              'attempting again with quiescing disabled.'),",
            "                          instance=instance)",
            "",
            "        try:",
            "            guest.snapshot(snapshot, no_metadata=True, disk_only=True,",
            "                           reuse_ext=True, quiesce=False)",
            "        except libvirt.libvirtError:",
            "            LOG.exception(_LE('Unable to create VM snapshot, '",
            "                              'failing volume_snapshot operation.'),",
            "                          instance=instance)",
            "",
            "            raise",
            "",
            "    def _volume_refresh_connection_info(self, context, instance, volume_id):",
            "        bdm = objects.BlockDeviceMapping.get_by_volume_and_instance(",
            "                  context, volume_id, instance.uuid)",
            "",
            "        driver_bdm = driver_block_device.convert_volume(bdm)",
            "        if driver_bdm:",
            "            driver_bdm.refresh_connection_info(context, instance,",
            "                                               self._volume_api, self)",
            "",
            "    def volume_snapshot_create(self, context, instance, volume_id,",
            "                               create_info):",
            "        \"\"\"Create snapshots of a Cinder volume via libvirt.",
            "",
            "        :param instance: VM instance object reference",
            "        :param volume_id: id of volume being snapshotted",
            "        :param create_info: dict of information used to create snapshots",
            "                     - snapshot_id : ID of snapshot",
            "                     - type : qcow2 / <other>",
            "                     - new_file : qcow2 file created by Cinder which",
            "                     becomes the VM's active image after",
            "                     the snapshot is complete",
            "        \"\"\"",
            "",
            "        LOG.debug(\"volume_snapshot_create: create_info: %(c_info)s\",",
            "                  {'c_info': create_info}, instance=instance)",
            "",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "        except exception.InstanceNotFound:",
            "            raise exception.InstanceNotRunning(instance_id=instance.uuid)",
            "",
            "        if create_info['type'] != 'qcow2':",
            "            raise exception.NovaException(_('Unknown type: %s') %",
            "                                          create_info['type'])",
            "",
            "        snapshot_id = create_info.get('snapshot_id', None)",
            "        if snapshot_id is None:",
            "            raise exception.NovaException(_('snapshot_id required '",
            "                                            'in create_info'))",
            "",
            "        try:",
            "            self._volume_snapshot_create(context, instance, guest,",
            "                                         volume_id, create_info['new_file'])",
            "        except Exception:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.exception(_LE('Error occurred during '",
            "                                  'volume_snapshot_create, '",
            "                                  'sending error status to Cinder.'),",
            "                              instance=instance)",
            "                self._volume_snapshot_update_status(",
            "                    context, snapshot_id, 'error')",
            "",
            "        self._volume_snapshot_update_status(",
            "            context, snapshot_id, 'creating')",
            "",
            "        def _wait_for_snapshot():",
            "            snapshot = self._volume_api.get_snapshot(context, snapshot_id)",
            "",
            "            if snapshot.get('status') != 'creating':",
            "                self._volume_refresh_connection_info(context, instance,",
            "                                                     volume_id)",
            "                raise loopingcall.LoopingCallDone()",
            "",
            "        timer = loopingcall.FixedIntervalLoopingCall(_wait_for_snapshot)",
            "        timer.start(interval=0.5).wait()",
            "",
            "    @staticmethod",
            "    def _rebase_with_qemu_img(guest, device, active_disk_object,",
            "                              rebase_base):",
            "        \"\"\"Rebase a device tied to a guest using qemu-img.",
            "",
            "        :param guest:the Guest which owns the device being rebased",
            "        :type guest: nova.virt.libvirt.guest.Guest",
            "        :param device: the guest block device to rebase",
            "        :type device: nova.virt.libvirt.guest.BlockDevice",
            "        :param active_disk_object: the guest block device to rebase",
            "        :type active_disk_object: nova.virt.libvirt.config.\\",
            "                                    LibvirtConfigGuestDisk",
            "        :param rebase_base: the new parent in the backing chain",
            "        :type rebase_base: None or string",
            "        \"\"\"",
            "",
            "        # It's unsure how well qemu-img handles network disks for",
            "        # every protocol. So let's be safe.",
            "        active_protocol = active_disk_object.source_protocol",
            "        if active_protocol is not None:",
            "            msg = _(\"Something went wrong when deleting a volume snapshot: \"",
            "                    \"rebasing a %(protocol)s network disk using qemu-img \"",
            "                    \"has not been fully tested\") % {'protocol':",
            "                    active_protocol}",
            "            LOG.error(msg)",
            "            raise exception.NovaException(msg)",
            "",
            "        if rebase_base is None:",
            "            # If backing_file is specified as \"\" (the empty string), then",
            "            # the image is rebased onto no backing file (i.e. it will exist",
            "            # independently of any backing file).",
            "            backing_file = \"\"",
            "            qemu_img_extra_arg = []",
            "        else:",
            "            # If the rebased image is going to have a backing file then",
            "            # explicitly set the backing file format to avoid any security",
            "            # concerns related to file format auto detection.",
            "            backing_file = rebase_base",
            "            b_file_fmt = images.qemu_img_info(backing_file).file_format",
            "            qemu_img_extra_arg = ['-F', b_file_fmt]",
            "",
            "        qemu_img_extra_arg.append(active_disk_object.source_path)",
            "        utils.execute(\"qemu-img\", \"rebase\", \"-b\", backing_file,",
            "                      *qemu_img_extra_arg)",
            "",
            "    def _volume_snapshot_delete(self, context, instance, volume_id,",
            "                                snapshot_id, delete_info=None):",
            "        \"\"\"Note:",
            "            if file being merged into == active image:",
            "                do a blockRebase (pull) operation",
            "            else:",
            "                do a blockCommit operation",
            "            Files must be adjacent in snap chain.",
            "",
            "        :param instance: instance object reference",
            "        :param volume_id: volume UUID",
            "        :param snapshot_id: snapshot UUID (unused currently)",
            "        :param delete_info: {",
            "            'type':              'qcow2',",
            "            'file_to_merge':     'a.img',",
            "            'merge_target_file': 'b.img' or None (if merging file_to_merge into",
            "                                                  active image)",
            "          }",
            "",
            "",
            "        Libvirt blockjob handling required for this method is broken",
            "        in versions of libvirt that do not contain:",
            "        http://libvirt.org/git/?p=libvirt.git;h=0f9e67bfad (1.1.1)",
            "        (Patch is pending in 1.0.5-maint branch as well, but we cannot detect",
            "        libvirt 1.0.5.5 vs. 1.0.5.6 here.)",
            "        \"\"\"",
            "",
            "        if not self._host.has_min_version(MIN_LIBVIRT_BLOCKJOBINFO_VERSION):",
            "            ver = '.'.join([str(x) for x in MIN_LIBVIRT_BLOCKJOBINFO_VERSION])",
            "            msg = _(\"Libvirt '%s' or later is required for online deletion \"",
            "                    \"of volume snapshots.\") % ver",
            "            raise exception.Invalid(msg)",
            "",
            "        LOG.debug('volume_snapshot_delete: delete_info: %s', delete_info,",
            "                  instance=instance)",
            "",
            "        if delete_info['type'] != 'qcow2':",
            "            msg = _('Unknown delete_info type %s') % delete_info['type']",
            "            raise exception.NovaException(msg)",
            "",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "        except exception.InstanceNotFound:",
            "            raise exception.InstanceNotRunning(instance_id=instance.uuid)",
            "",
            "        # Find dev name",
            "        my_dev = None",
            "        active_disk = None",
            "",
            "        xml = guest.get_xml_desc()",
            "        xml_doc = etree.fromstring(xml)",
            "",
            "        device_info = vconfig.LibvirtConfigGuest()",
            "        device_info.parse_dom(xml_doc)",
            "",
            "        active_disk_object = None",
            "",
            "        for guest_disk in device_info.devices:",
            "            if (guest_disk.root_name != 'disk'):",
            "                continue",
            "",
            "            if (guest_disk.target_dev is None or guest_disk.serial is None):",
            "                continue",
            "",
            "            if guest_disk.serial == volume_id:",
            "                my_dev = guest_disk.target_dev",
            "",
            "                active_disk = guest_disk.source_path",
            "                active_protocol = guest_disk.source_protocol",
            "                active_disk_object = guest_disk",
            "                break",
            "",
            "        if my_dev is None or (active_disk is None and active_protocol is None):",
            "            msg = _('Disk with id: %s '",
            "                    'not found attached to instance.') % volume_id",
            "            LOG.debug('Domain XML: %s', xml, instance=instance)",
            "            raise exception.NovaException(msg)",
            "",
            "        LOG.debug(\"found device at %s\", my_dev, instance=instance)",
            "",
            "        def _get_snap_dev(filename, backing_store):",
            "            if filename is None:",
            "                msg = _('filename cannot be None')",
            "                raise exception.NovaException(msg)",
            "",
            "            # libgfapi delete",
            "            LOG.debug(\"XML: %s\" % xml)",
            "",
            "            LOG.debug(\"active disk object: %s\", active_disk_object)",
            "",
            "            # determine reference within backing store for desired image",
            "            filename_to_merge = filename",
            "            matched_name = None",
            "            b = backing_store",
            "            index = None",
            "",
            "            current_filename = active_disk_object.source_name.split('/')[1]",
            "            if current_filename == filename_to_merge:",
            "                return my_dev + '[0]'",
            "",
            "            while b is not None:",
            "                source_filename = b.source_name.split('/')[1]",
            "                if source_filename == filename_to_merge:",
            "                    LOG.debug('found match: %s', b.source_name)",
            "                    matched_name = b.source_name",
            "                    index = b.index",
            "                    break",
            "",
            "                b = b.backing_store",
            "",
            "            if matched_name is None:",
            "                msg = _('no match found for %s') % (filename_to_merge)",
            "                raise exception.NovaException(msg)",
            "",
            "            LOG.debug('index of match (%s) is %s', b.source_name, index)",
            "",
            "            my_snap_dev = '%s[%s]' % (my_dev, index)",
            "            return my_snap_dev",
            "",
            "        if delete_info['merge_target_file'] is None:",
            "            # pull via blockRebase()",
            "",
            "            # Merge the most recent snapshot into the active image",
            "",
            "            rebase_disk = my_dev",
            "            rebase_base = delete_info['file_to_merge']  # often None",
            "            if (active_protocol is not None) and (rebase_base is not None):",
            "                rebase_base = _get_snap_dev(rebase_base,",
            "                                            active_disk_object.backing_store)",
            "",
            "            # NOTE(deepakcs): libvirt added support for _RELATIVE in v1.2.7,",
            "            # and when available this flag _must_ be used to ensure backing",
            "            # paths are maintained relative by qemu.",
            "            #",
            "            # If _RELATIVE flag not found, continue with old behaviour",
            "            # (relative backing path seems to work for this case)",
            "            try:",
            "                libvirt.VIR_DOMAIN_BLOCK_REBASE_RELATIVE",
            "                relative = rebase_base is not None",
            "            except AttributeError:",
            "                LOG.warn(_LW(\"Relative blockrebase support was not detected. \"",
            "                             \"Continuing with old behaviour.\"))",
            "                relative = False",
            "",
            "            LOG.debug(",
            "                'disk: %(disk)s, base: %(base)s, '",
            "                'bw: %(bw)s, relative: %(relative)s',",
            "                {'disk': rebase_disk,",
            "                 'base': rebase_base,",
            "                 'bw': libvirt_guest.BlockDevice.REBASE_DEFAULT_BANDWIDTH,",
            "                 'relative': str(relative)}, instance=instance)",
            "",
            "            dev = guest.get_block_device(rebase_disk)",
            "            if guest.is_active():",
            "                result = dev.rebase(rebase_base, relative=relative)",
            "                if result == 0:",
            "                    LOG.debug('blockRebase started successfully',",
            "                              instance=instance)",
            "",
            "                while dev.wait_for_job(abort_on_error=True):",
            "                    LOG.debug('waiting for blockRebase job completion',",
            "                              instance=instance)",
            "                    time.sleep(0.5)",
            "",
            "            # If the guest is not running libvirt won't do a blockRebase.",
            "            # In that case, let's ask qemu-img to rebase the disk.",
            "            else:",
            "                LOG.debug('Guest is not running so doing a block rebase '",
            "                          'using \"qemu-img rebase\"', instance=instance)",
            "                self._rebase_with_qemu_img(guest, dev, active_disk_object,",
            "                                           rebase_base)",
            "",
            "        else:",
            "            # commit with blockCommit()",
            "            my_snap_base = None",
            "            my_snap_top = None",
            "            commit_disk = my_dev",
            "",
            "            # NOTE(deepakcs): libvirt added support for _RELATIVE in v1.2.7,",
            "            # and when available this flag _must_ be used to ensure backing",
            "            # paths are maintained relative by qemu.",
            "            #",
            "            # If _RELATIVE flag not found, raise exception as relative backing",
            "            # path may not be maintained and Cinder flow is broken if allowed",
            "            # to continue.",
            "            try:",
            "                libvirt.VIR_DOMAIN_BLOCK_COMMIT_RELATIVE",
            "            except AttributeError:",
            "                ver = '.'.join(",
            "                    [str(x) for x in",
            "                     MIN_LIBVIRT_BLOCKJOB_RELATIVE_VERSION])",
            "                msg = _(\"Relative blockcommit support was not detected. \"",
            "                        \"Libvirt '%s' or later is required for online \"",
            "                        \"deletion of file/network storage-backed volume \"",
            "                        \"snapshots.\") % ver",
            "                raise exception.Invalid(msg)",
            "",
            "            if active_protocol is not None:",
            "                my_snap_base = _get_snap_dev(delete_info['merge_target_file'],",
            "                                             active_disk_object.backing_store)",
            "                my_snap_top = _get_snap_dev(delete_info['file_to_merge'],",
            "                                            active_disk_object.backing_store)",
            "",
            "            commit_base = my_snap_base or delete_info['merge_target_file']",
            "            commit_top = my_snap_top or delete_info['file_to_merge']",
            "",
            "            LOG.debug('will call blockCommit with commit_disk=%(commit_disk)s '",
            "                      'commit_base=%(commit_base)s '",
            "                      'commit_top=%(commit_top)s ',",
            "                      {'commit_disk': commit_disk,",
            "                       'commit_base': commit_base,",
            "                       'commit_top': commit_top}, instance=instance)",
            "",
            "            dev = guest.get_block_device(commit_disk)",
            "            result = dev.commit(commit_base, commit_top, relative=True)",
            "",
            "            if result == 0:",
            "                LOG.debug('blockCommit started successfully',",
            "                          instance=instance)",
            "",
            "            while dev.wait_for_job(abort_on_error=True):",
            "                LOG.debug('waiting for blockCommit job completion',",
            "                          instance=instance)",
            "                time.sleep(0.5)",
            "",
            "    def volume_snapshot_delete(self, context, instance, volume_id, snapshot_id,",
            "                               delete_info):",
            "        try:",
            "            self._volume_snapshot_delete(context, instance, volume_id,",
            "                                         snapshot_id, delete_info=delete_info)",
            "        except Exception:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.exception(_LE('Error occurred during '",
            "                                  'volume_snapshot_delete, '",
            "                                  'sending error status to Cinder.'),",
            "                              instance=instance)",
            "                self._volume_snapshot_update_status(",
            "                    context, snapshot_id, 'error_deleting')",
            "",
            "        self._volume_snapshot_update_status(context, snapshot_id, 'deleting')",
            "        self._volume_refresh_connection_info(context, instance, volume_id)",
            "",
            "    def reboot(self, context, instance, network_info, reboot_type,",
            "               block_device_info=None, bad_volumes_callback=None):",
            "        \"\"\"Reboot a virtual machine, given an instance reference.\"\"\"",
            "        if reboot_type == 'SOFT':",
            "            # NOTE(vish): This will attempt to do a graceful shutdown/restart.",
            "            try:",
            "                soft_reboot_success = self._soft_reboot(instance)",
            "            except libvirt.libvirtError as e:",
            "                LOG.debug(\"Instance soft reboot failed: %s\", e,",
            "                          instance=instance)",
            "                soft_reboot_success = False",
            "",
            "            if soft_reboot_success:",
            "                LOG.info(_LI(\"Instance soft rebooted successfully.\"),",
            "                         instance=instance)",
            "                return",
            "            else:",
            "                LOG.warn(_LW(\"Failed to soft reboot instance. \"",
            "                             \"Trying hard reboot.\"),",
            "                         instance=instance)",
            "        return self._hard_reboot(context, instance, network_info,",
            "                                 block_device_info)",
            "",
            "    def _soft_reboot(self, instance):",
            "        \"\"\"Attempt to shutdown and restart the instance gracefully.",
            "",
            "        We use shutdown and create here so we can return if the guest",
            "        responded and actually rebooted. Note that this method only",
            "        succeeds if the guest responds to acpi. Therefore we return",
            "        success or failure so we can fall back to a hard reboot if",
            "        necessary.",
            "",
            "        :returns: True if the reboot succeeded",
            "        \"\"\"",
            "        guest = self._host.get_guest(instance)",
            "",
            "        state = guest.get_power_state(self._host)",
            "        old_domid = guest.id",
            "        # NOTE(vish): This check allows us to reboot an instance that",
            "        #             is already shutdown.",
            "        if state == power_state.RUNNING:",
            "            guest.shutdown()",
            "        # NOTE(vish): This actually could take slightly longer than the",
            "        #             FLAG defines depending on how long the get_info",
            "        #             call takes to return.",
            "        self._prepare_pci_devices_for_use(",
            "            pci_manager.get_instance_pci_devs(instance, 'all'))",
            "        for x in range(CONF.libvirt.wait_soft_reboot_seconds):",
            "            guest = self._host.get_guest(instance)",
            "",
            "            state = guest.get_power_state(self._host)",
            "            new_domid = guest.id",
            "",
            "            # NOTE(ivoks): By checking domain IDs, we make sure we are",
            "            #              not recreating domain that's already running.",
            "            if old_domid != new_domid:",
            "                if state in [power_state.SHUTDOWN,",
            "                             power_state.CRASHED]:",
            "                    LOG.info(_LI(\"Instance shutdown successfully.\"),",
            "                             instance=instance)",
            "                    self._create_domain(domain=guest._domain)",
            "                    timer = loopingcall.FixedIntervalLoopingCall(",
            "                        self._wait_for_running, instance)",
            "                    timer.start(interval=0.5).wait()",
            "                    return True",
            "                else:",
            "                    LOG.info(_LI(\"Instance may have been rebooted during soft \"",
            "                                 \"reboot, so return now.\"), instance=instance)",
            "                    return True",
            "            greenthread.sleep(1)",
            "        return False",
            "",
            "    def _hard_reboot(self, context, instance, network_info,",
            "                     block_device_info=None):",
            "        \"\"\"Reboot a virtual machine, given an instance reference.",
            "",
            "        Performs a Libvirt reset (if supported) on the domain.",
            "",
            "        If Libvirt reset is unavailable this method actually destroys and",
            "        re-creates the domain to ensure the reboot happens, as the guest",
            "        OS cannot ignore this action.",
            "        \"\"\"",
            "",
            "        self._destroy(instance)",
            "",
            "        # Convert the system metadata to image metadata",
            "        instance_dir = libvirt_utils.get_instance_path(instance)",
            "        fileutils.ensure_tree(instance_dir)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            instance.image_meta,",
            "                                            block_device_info)",
            "        # NOTE(vish): This could generate the wrong device_format if we are",
            "        #             using the raw backend and the images don't exist yet.",
            "        #             The create_images_and_backing below doesn't properly",
            "        #             regenerate raw backend images, however, so when it",
            "        #             does we need to (re)generate the xml after the images",
            "        #             are in place.",
            "        xml = self._get_guest_xml(context, instance, network_info, disk_info,",
            "                                  instance.image_meta,",
            "                                  block_device_info=block_device_info,",
            "                                  write_to_disk=True)",
            "",
            "        if context.auth_token is not None:",
            "            # NOTE (rmk): Re-populate any missing backing files.",
            "            backing_disk_info = self._get_instance_disk_info(instance.name,",
            "                                                             xml,",
            "                                                             block_device_info)",
            "            self._create_images_and_backing(context, instance, instance_dir,",
            "                                            backing_disk_info)",
            "",
            "        # Initialize all the necessary networking, block devices and",
            "        # start the instance.",
            "        self._create_domain_and_network(context, xml, instance, network_info,",
            "                                        disk_info,",
            "                                        block_device_info=block_device_info,",
            "                                        reboot=True,",
            "                                        vifs_already_plugged=True)",
            "        self._prepare_pci_devices_for_use(",
            "            pci_manager.get_instance_pci_devs(instance, 'all'))",
            "",
            "        def _wait_for_reboot():",
            "            \"\"\"Called at an interval until the VM is running again.\"\"\"",
            "            state = self.get_info(instance).state",
            "",
            "            if state == power_state.RUNNING:",
            "                LOG.info(_LI(\"Instance rebooted successfully.\"),",
            "                         instance=instance)",
            "                raise loopingcall.LoopingCallDone()",
            "",
            "        timer = loopingcall.FixedIntervalLoopingCall(_wait_for_reboot)",
            "        timer.start(interval=0.5).wait()",
            "",
            "    def pause(self, instance):",
            "        \"\"\"Pause VM instance.\"\"\"",
            "        self._host.get_guest(instance).pause()",
            "",
            "    def unpause(self, instance):",
            "        \"\"\"Unpause paused VM instance.\"\"\"",
            "        self._host.get_guest(instance).resume()",
            "",
            "    def _clean_shutdown(self, instance, timeout, retry_interval):",
            "        \"\"\"Attempt to shutdown the instance gracefully.",
            "",
            "        :param instance: The instance to be shutdown",
            "        :param timeout: How long to wait in seconds for the instance to",
            "                        shutdown",
            "        :param retry_interval: How often in seconds to signal the instance",
            "                               to shutdown while waiting",
            "",
            "        :returns: True if the shutdown succeeded",
            "        \"\"\"",
            "",
            "        # List of states that represent a shutdown instance",
            "        SHUTDOWN_STATES = [power_state.SHUTDOWN,",
            "                           power_state.CRASHED]",
            "",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "        except exception.InstanceNotFound:",
            "            # If the instance has gone then we don't need to",
            "            # wait for it to shutdown",
            "            return True",
            "",
            "        state = guest.get_power_state(self._host)",
            "        if state in SHUTDOWN_STATES:",
            "            LOG.info(_LI(\"Instance already shutdown.\"),",
            "                     instance=instance)",
            "            return True",
            "",
            "        LOG.debug(\"Shutting down instance from state %s\", state,",
            "                  instance=instance)",
            "        guest.shutdown()",
            "        retry_countdown = retry_interval",
            "",
            "        for sec in six.moves.range(timeout):",
            "",
            "            guest = self._host.get_guest(instance)",
            "            state = guest.get_power_state(self._host)",
            "",
            "            if state in SHUTDOWN_STATES:",
            "                LOG.info(_LI(\"Instance shutdown successfully after %d \"",
            "                              \"seconds.\"), sec, instance=instance)",
            "                return True",
            "",
            "            # Note(PhilD): We can't assume that the Guest was able to process",
            "            #              any previous shutdown signal (for example it may",
            "            #              have still been startingup, so within the overall",
            "            #              timeout we re-trigger the shutdown every",
            "            #              retry_interval",
            "            if retry_countdown == 0:",
            "                retry_countdown = retry_interval",
            "                # Instance could shutdown at any time, in which case we",
            "                # will get an exception when we call shutdown",
            "                try:",
            "                    LOG.debug(\"Instance in state %s after %d seconds - \"",
            "                              \"resending shutdown\", state, sec,",
            "                              instance=instance)",
            "                    guest.shutdown()",
            "                except libvirt.libvirtError:",
            "                    # Assume this is because its now shutdown, so loop",
            "                    # one more time to clean up.",
            "                    LOG.debug(\"Ignoring libvirt exception from shutdown \"",
            "                              \"request.\", instance=instance)",
            "                    continue",
            "            else:",
            "                retry_countdown -= 1",
            "",
            "            time.sleep(1)",
            "",
            "        LOG.info(_LI(\"Instance failed to shutdown in %d seconds.\"),",
            "                 timeout, instance=instance)",
            "        return False",
            "",
            "    def power_off(self, instance, timeout=0, retry_interval=0):",
            "        \"\"\"Power off the specified instance.\"\"\"",
            "        if timeout:",
            "            self._clean_shutdown(instance, timeout, retry_interval)",
            "        self._destroy(instance)",
            "",
            "    def power_on(self, context, instance, network_info,",
            "                 block_device_info=None):",
            "        \"\"\"Power on the specified instance.\"\"\"",
            "        # We use _hard_reboot here to ensure that all backing files,",
            "        # network, and block device connections, etc. are established",
            "        # and available before we attempt to start the instance.",
            "        self._hard_reboot(context, instance, network_info, block_device_info)",
            "",
            "    def trigger_crash_dump(self, instance):",
            "",
            "        \"\"\"Trigger crash dump by injecting an NMI to the specified instance.\"\"\"",
            "        try:",
            "            self._host.get_guest(instance).inject_nmi()",
            "        except libvirt.libvirtError as ex:",
            "            error_code = ex.get_error_code()",
            "",
            "            if error_code == libvirt.VIR_ERR_NO_SUPPORT:",
            "                raise exception.TriggerCrashDumpNotSupported()",
            "            elif error_code == libvirt.VIR_ERR_OPERATION_INVALID:",
            "                raise exception.InstanceNotRunning(instance_id=instance.uuid)",
            "",
            "            LOG.exception(_LE('Error from libvirt while injecting an NMI to '",
            "                              '%(instance_uuid)s: '",
            "                              '[Error Code %(error_code)s] %(ex)s'),",
            "                          {'instance_uuid': instance.uuid,",
            "                           'error_code': error_code, 'ex': ex})",
            "            raise",
            "",
            "    def suspend(self, context, instance):",
            "        \"\"\"Suspend the specified instance.\"\"\"",
            "        guest = self._host.get_guest(instance)",
            "",
            "        self._detach_pci_devices(guest,",
            "            pci_manager.get_instance_pci_devs(instance))",
            "        self._detach_sriov_ports(context, instance, guest)",
            "        guest.save_memory_state()",
            "",
            "    def resume(self, context, instance, network_info, block_device_info=None):",
            "        \"\"\"resume the specified instance.\"\"\"",
            "        disk_info = blockinfo.get_disk_info(",
            "                CONF.libvirt.virt_type, instance, instance.image_meta,",
            "                block_device_info=block_device_info)",
            "",
            "        xml = self._get_existing_domain_xml(instance, network_info,",
            "                                            block_device_info)",
            "        guest = self._create_domain_and_network(context, xml, instance,",
            "                           network_info, disk_info,",
            "                           block_device_info=block_device_info,",
            "                           vifs_already_plugged=True)",
            "        self._attach_pci_devices(guest,",
            "            pci_manager.get_instance_pci_devs(instance))",
            "        self._attach_sriov_ports(context, instance, guest, network_info)",
            "",
            "    def resume_state_on_host_boot(self, context, instance, network_info,",
            "                                  block_device_info=None):",
            "        \"\"\"resume guest state when a host is booted.\"\"\"",
            "        # Check if the instance is running already and avoid doing",
            "        # anything if it is.",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "            state = guest.get_power_state(self._host)",
            "",
            "            ignored_states = (power_state.RUNNING,",
            "                              power_state.SUSPENDED,",
            "                              power_state.NOSTATE,",
            "                              power_state.PAUSED)",
            "",
            "            if state in ignored_states:",
            "                return",
            "        except exception.NovaException:",
            "            pass",
            "",
            "        # Instance is not up and could be in an unknown state.",
            "        # Be as absolute as possible about getting it back into",
            "        # a known and running state.",
            "        self._hard_reboot(context, instance, network_info, block_device_info)",
            "",
            "    def rescue(self, context, instance, network_info, image_meta,",
            "               rescue_password):",
            "        \"\"\"Loads a VM using rescue images.",
            "",
            "        A rescue is normally performed when something goes wrong with the",
            "        primary images and data needs to be corrected/recovered. Rescuing",
            "        should not edit or over-ride the original image, only allow for",
            "        data recovery.",
            "",
            "        \"\"\"",
            "        instance_dir = libvirt_utils.get_instance_path(instance)",
            "        unrescue_xml = self._get_existing_domain_xml(instance, network_info)",
            "        unrescue_xml_path = os.path.join(instance_dir, 'unrescue.xml')",
            "        libvirt_utils.write_to_file(unrescue_xml_path, unrescue_xml)",
            "",
            "        rescue_image_id = None",
            "        if image_meta.obj_attr_is_set(\"id\"):",
            "            rescue_image_id = image_meta.id",
            "",
            "        rescue_images = {",
            "            'image_id': (rescue_image_id or",
            "                        CONF.libvirt.rescue_image_id or instance.image_ref),",
            "            'kernel_id': (CONF.libvirt.rescue_kernel_id or",
            "                          instance.kernel_id),",
            "            'ramdisk_id': (CONF.libvirt.rescue_ramdisk_id or",
            "                           instance.ramdisk_id),",
            "        }",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta,",
            "                                            rescue=True)",
            "        self._create_image(context, instance, disk_info['mapping'],",
            "                           suffix='.rescue', disk_images=rescue_images,",
            "                           network_info=network_info,",
            "                           admin_pass=rescue_password)",
            "        xml = self._get_guest_xml(context, instance, network_info, disk_info,",
            "                                  image_meta, rescue=rescue_images,",
            "                                  write_to_disk=True)",
            "        self._destroy(instance)",
            "        self._create_domain(xml)",
            "",
            "    def unrescue(self, instance, network_info):",
            "        \"\"\"Reboot the VM which is being rescued back into primary images.",
            "        \"\"\"",
            "        instance_dir = libvirt_utils.get_instance_path(instance)",
            "        unrescue_xml_path = os.path.join(instance_dir, 'unrescue.xml')",
            "        xml = libvirt_utils.load_file(unrescue_xml_path)",
            "        guest = self._host.get_guest(instance)",
            "",
            "        # TODO(sahid): We are converting all calls from a",
            "        # virDomain object to use nova.virt.libvirt.Guest.",
            "        # We should be able to remove virt_dom at the end.",
            "        virt_dom = guest._domain",
            "        self._destroy(instance)",
            "        self._create_domain(xml, virt_dom)",
            "        libvirt_utils.file_delete(unrescue_xml_path)",
            "        rescue_files = os.path.join(instance_dir, \"*.rescue\")",
            "        for rescue_file in glob.iglob(rescue_files):",
            "            libvirt_utils.file_delete(rescue_file)",
            "        # cleanup rescue volume",
            "        lvm.remove_volumes([lvmdisk for lvmdisk in self._lvm_disks(instance)",
            "                                if lvmdisk.endswith('.rescue')])",
            "",
            "    def poll_rebooting_instances(self, timeout, instances):",
            "        pass",
            "",
            "    # NOTE(ilyaalekseyev): Implementation like in multinics",
            "    # for xenapi(tr3buchet)",
            "    def spawn(self, context, instance, image_meta, injected_files,",
            "              admin_password, network_info=None, block_device_info=None):",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta,",
            "                                            block_device_info)",
            "        self._create_image(context, instance,",
            "                           disk_info['mapping'],",
            "                           network_info=network_info,",
            "                           block_device_info=block_device_info,",
            "                           files=injected_files,",
            "                           admin_pass=admin_password)",
            "        xml = self._get_guest_xml(context, instance, network_info,",
            "                                  disk_info, image_meta,",
            "                                  block_device_info=block_device_info,",
            "                                  write_to_disk=True)",
            "        self._create_domain_and_network(context, xml, instance, network_info,",
            "                                        disk_info,",
            "                                        block_device_info=block_device_info)",
            "        LOG.debug(\"Instance is running\", instance=instance)",
            "",
            "        def _wait_for_boot():",
            "            \"\"\"Called at an interval until the VM is running.\"\"\"",
            "            state = self.get_info(instance).state",
            "",
            "            if state == power_state.RUNNING:",
            "                LOG.info(_LI(\"Instance spawned successfully.\"),",
            "                         instance=instance)",
            "                raise loopingcall.LoopingCallDone()",
            "",
            "        timer = loopingcall.FixedIntervalLoopingCall(_wait_for_boot)",
            "        timer.start(interval=0.5).wait()",
            "",
            "    def _flush_libvirt_console(self, pty):",
            "        out, err = utils.execute('dd',",
            "                                 'if=%s' % pty,",
            "                                 'iflag=nonblock',",
            "                                 run_as_root=True,",
            "                                 check_exit_code=False)",
            "        return out",
            "",
            "    def _append_to_file(self, data, fpath):",
            "        LOG.info(_LI('data: %(data)r, fpath: %(fpath)r'),",
            "                 {'data': data, 'fpath': fpath})",
            "        with open(fpath, 'a+') as fp:",
            "            fp.write(data)",
            "",
            "        return fpath",
            "",
            "    def get_console_output(self, context, instance):",
            "        guest = self._host.get_guest(instance)",
            "",
            "        xml = guest.get_xml_desc()",
            "        tree = etree.fromstring(xml)",
            "",
            "        console_types = {}",
            "",
            "        # NOTE(comstud): We want to try 'file' types first, then try 'pty'",
            "        # types.  We can't use Python 2.7 syntax of:",
            "        # tree.find(\"./devices/console[@type='file']/source\")",
            "        # because we need to support 2.6.",
            "        console_nodes = tree.findall('./devices/console')",
            "        for console_node in console_nodes:",
            "            console_type = console_node.get('type')",
            "            console_types.setdefault(console_type, [])",
            "            console_types[console_type].append(console_node)",
            "",
            "        # If the guest has a console logging to a file prefer to use that",
            "        if console_types.get('file'):",
            "            for file_console in console_types.get('file'):",
            "                source_node = file_console.find('./source')",
            "                if source_node is None:",
            "                    continue",
            "                path = source_node.get(\"path\")",
            "                if not path:",
            "                    continue",
            "",
            "                if not os.path.exists(path):",
            "                    LOG.info(_LI('Instance is configured with a file console, '",
            "                                 'but the backing file is not (yet?) present'),",
            "                             instance=instance)",
            "                    return \"\"",
            "",
            "                libvirt_utils.chown(path, os.getuid())",
            "",
            "                with libvirt_utils.file_open(path, 'rb') as fp:",
            "                    log_data, remaining = utils.last_bytes(fp,",
            "                                                           MAX_CONSOLE_BYTES)",
            "                    if remaining > 0:",
            "                        LOG.info(_LI('Truncated console log returned, '",
            "                                     '%d bytes ignored'), remaining,",
            "                                 instance=instance)",
            "                    return log_data",
            "",
            "        # Try 'pty' types",
            "        if console_types.get('pty'):",
            "            for pty_console in console_types.get('pty'):",
            "                source_node = pty_console.find('./source')",
            "                if source_node is None:",
            "                    continue",
            "                pty = source_node.get(\"path\")",
            "                if not pty:",
            "                    continue",
            "                break",
            "        else:",
            "            msg = _(\"Guest does not have a console available\")",
            "            raise exception.NovaException(msg)",
            "",
            "        self._chown_console_log_for_instance(instance)",
            "        data = self._flush_libvirt_console(pty)",
            "        console_log = self._get_console_log_path(instance)",
            "        fpath = self._append_to_file(data, console_log)",
            "",
            "        with libvirt_utils.file_open(fpath, 'rb') as fp:",
            "            log_data, remaining = utils.last_bytes(fp, MAX_CONSOLE_BYTES)",
            "            if remaining > 0:",
            "                LOG.info(_LI('Truncated console log returned, '",
            "                             '%d bytes ignored'),",
            "                         remaining, instance=instance)",
            "            return log_data",
            "",
            "    def get_host_ip_addr(self):",
            "        ips = compute_utils.get_machine_ips()",
            "        if CONF.my_ip not in ips:",
            "            LOG.warn(_LW('my_ip address (%(my_ip)s) was not found on '",
            "                         'any of the interfaces: %(ifaces)s'),",
            "                     {'my_ip': CONF.my_ip, 'ifaces': \", \".join(ips)})",
            "        return CONF.my_ip",
            "",
            "    def get_vnc_console(self, context, instance):",
            "        def get_vnc_port_for_instance(instance_name):",
            "            guest = self._host.get_guest(instance)",
            "",
            "            xml = guest.get_xml_desc()",
            "            xml_dom = etree.fromstring(xml)",
            "",
            "            graphic = xml_dom.find(\"./devices/graphics[@type='vnc']\")",
            "            if graphic is not None:",
            "                return graphic.get('port')",
            "            # NOTE(rmk): We had VNC consoles enabled but the instance in",
            "            # question is not actually listening for connections.",
            "            raise exception.ConsoleTypeUnavailable(console_type='vnc')",
            "",
            "        port = get_vnc_port_for_instance(instance.name)",
            "        host = CONF.vnc.vncserver_proxyclient_address",
            "",
            "        return ctype.ConsoleVNC(host=host, port=port)",
            "",
            "    def get_spice_console(self, context, instance):",
            "        def get_spice_ports_for_instance(instance_name):",
            "            guest = self._host.get_guest(instance)",
            "",
            "            xml = guest.get_xml_desc()",
            "            xml_dom = etree.fromstring(xml)",
            "",
            "            graphic = xml_dom.find(\"./devices/graphics[@type='spice']\")",
            "            if graphic is not None:",
            "                return (graphic.get('port'), graphic.get('tlsPort'))",
            "            # NOTE(rmk): We had Spice consoles enabled but the instance in",
            "            # question is not actually listening for connections.",
            "            raise exception.ConsoleTypeUnavailable(console_type='spice')",
            "",
            "        ports = get_spice_ports_for_instance(instance.name)",
            "        host = CONF.spice.server_proxyclient_address",
            "",
            "        return ctype.ConsoleSpice(host=host, port=ports[0], tlsPort=ports[1])",
            "",
            "    def get_serial_console(self, context, instance):",
            "        guest = self._host.get_guest(instance)",
            "        for hostname, port in self._get_serial_ports_from_guest(",
            "                guest, mode='bind'):",
            "            return ctype.ConsoleSerial(host=hostname, port=port)",
            "        raise exception.ConsoleTypeUnavailable(console_type='serial')",
            "",
            "    @staticmethod",
            "    def _supports_direct_io(dirpath):",
            "",
            "        if not hasattr(os, 'O_DIRECT'):",
            "            LOG.debug(\"This python runtime does not support direct I/O\")",
            "            return False",
            "",
            "        testfile = os.path.join(dirpath, \".directio.test\")",
            "",
            "        hasDirectIO = True",
            "        try:",
            "            f = os.open(testfile, os.O_CREAT | os.O_WRONLY | os.O_DIRECT)",
            "            # Check is the write allowed with 512 byte alignment",
            "            align_size = 512",
            "            m = mmap.mmap(-1, align_size)",
            "            m.write(r\"x\" * align_size)",
            "            os.write(f, m)",
            "            os.close(f)",
            "            LOG.debug(\"Path '%(path)s' supports direct I/O\",",
            "                      {'path': dirpath})",
            "        except OSError as e:",
            "            if e.errno == errno.EINVAL:",
            "                LOG.debug(\"Path '%(path)s' does not support direct I/O: \"",
            "                          \"'%(ex)s'\", {'path': dirpath, 'ex': e})",
            "                hasDirectIO = False",
            "            else:",
            "                with excutils.save_and_reraise_exception():",
            "                    LOG.error(_LE(\"Error on '%(path)s' while checking \"",
            "                                  \"direct I/O: '%(ex)s'\"),",
            "                              {'path': dirpath, 'ex': e})",
            "        except Exception as e:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.error(_LE(\"Error on '%(path)s' while checking direct I/O: \"",
            "                              \"'%(ex)s'\"), {'path': dirpath, 'ex': e})",
            "        finally:",
            "            try:",
            "                os.unlink(testfile)",
            "            except Exception:",
            "                pass",
            "",
            "        return hasDirectIO",
            "",
            "    @staticmethod",
            "    def _create_ephemeral(target, ephemeral_size,",
            "                          fs_label, os_type, is_block_dev=False,",
            "                          max_size=None, context=None, specified_fs=None):",
            "        if not is_block_dev:",
            "            libvirt_utils.create_image('raw', target, '%dG' % ephemeral_size)",
            "",
            "        # Run as root only for block devices.",
            "        disk.mkfs(os_type, fs_label, target, run_as_root=is_block_dev,",
            "                  specified_fs=specified_fs)",
            "",
            "    @staticmethod",
            "    def _create_swap(target, swap_mb, max_size=None, context=None):",
            "        \"\"\"Create a swap file of specified size.\"\"\"",
            "        libvirt_utils.create_image('raw', target, '%dM' % swap_mb)",
            "        utils.mkfs('swap', target)",
            "",
            "    @staticmethod",
            "    def _get_console_log_path(instance):",
            "        return os.path.join(libvirt_utils.get_instance_path(instance),",
            "                            'console.log')",
            "",
            "    @staticmethod",
            "    def _get_disk_config_path(instance, suffix=''):",
            "        return os.path.join(libvirt_utils.get_instance_path(instance),",
            "                            'disk.config' + suffix)",
            "",
            "    @staticmethod",
            "    def _get_disk_config_image_type():",
            "        # TODO(mikal): there is a bug here if images_type has",
            "        # changed since creation of the instance, but I am pretty",
            "        # sure that this bug already exists.",
            "        return 'rbd' if CONF.libvirt.images_type == 'rbd' else 'raw'",
            "",
            "    def _chown_console_log_for_instance(self, instance):",
            "        console_log = self._get_console_log_path(instance)",
            "        if os.path.exists(console_log):",
            "            libvirt_utils.chown(console_log, os.getuid())",
            "",
            "    def _chown_disk_config_for_instance(self, instance):",
            "        disk_config = self._get_disk_config_path(instance)",
            "        if os.path.exists(disk_config):",
            "            libvirt_utils.chown(disk_config, os.getuid())",
            "",
            "    @staticmethod",
            "    def _is_booted_from_volume(instance, disk_mapping):",
            "        \"\"\"Determines whether the VM is booting from volume",
            "",
            "        Determines whether the disk mapping indicates that the VM",
            "        is booting from a volume.",
            "        \"\"\"",
            "        return ((not bool(instance.get('image_ref')))",
            "                or 'disk' not in disk_mapping)",
            "",
            "    @staticmethod",
            "    def _has_local_disk(instance, disk_mapping):",
            "        \"\"\"Determines whether the VM has a local disk",
            "",
            "        Determines whether the disk mapping indicates that the VM",
            "        has a local disk (e.g. ephemeral, swap disk and config-drive).",
            "        \"\"\"",
            "        if disk_mapping:",
            "            if ('disk.local' in disk_mapping or",
            "                'disk.swap' in disk_mapping or",
            "                'disk.config' in disk_mapping):",
            "                return True",
            "        return False",
            "",
            "    def _inject_data(self, instance, network_info, admin_pass, files, suffix):",
            "        \"\"\"Injects data in a disk image",
            "",
            "        Helper used for injecting data in a disk image file system.",
            "",
            "        Keyword arguments:",
            "          instance -- a dict that refers instance specifications",
            "          network_info -- a dict that refers network speficications",
            "          admin_pass -- a string used to set an admin password",
            "          files -- a list of files needs to be injected",
            "          suffix -- a string used as an image name suffix",
            "        \"\"\"",
            "        # Handles the partition need to be used.",
            "        target_partition = None",
            "        if not instance.kernel_id:",
            "            target_partition = CONF.libvirt.inject_partition",
            "            if target_partition == 0:",
            "                target_partition = None",
            "        if CONF.libvirt.virt_type == 'lxc':",
            "            target_partition = None",
            "",
            "        # Handles the key injection.",
            "        if CONF.libvirt.inject_key and instance.get('key_data'):",
            "            key = str(instance.key_data)",
            "        else:",
            "            key = None",
            "",
            "        # Handles the admin password injection.",
            "        if not CONF.libvirt.inject_password:",
            "            admin_pass = None",
            "",
            "        # Handles the network injection.",
            "        net = netutils.get_injected_network_template(",
            "                network_info, libvirt_virt_type=CONF.libvirt.virt_type)",
            "",
            "        # Handles the metadata injection",
            "        metadata = instance.get('metadata')",
            "",
            "        image_type = CONF.libvirt.images_type",
            "        if any((key, net, metadata, admin_pass, files)):",
            "            injection_image = self.image_backend.image(",
            "                instance,",
            "                'disk' + suffix,",
            "                image_type)",
            "            img_id = instance.image_ref",
            "",
            "            if not injection_image.check_image_exists():",
            "                LOG.warn(_LW('Image %s not found on disk storage. '",
            "                         'Continue without injecting data'),",
            "                         injection_image.path, instance=instance)",
            "                return",
            "            try:",
            "                disk.inject_data(injection_image.get_model(self._conn),",
            "                                 key, net, metadata, admin_pass, files,",
            "                                 partition=target_partition,",
            "                                 mandatory=('files',))",
            "            except Exception as e:",
            "                with excutils.save_and_reraise_exception():",
            "                    LOG.error(_LE('Error injecting data into image '",
            "                                  '%(img_id)s (%(e)s)'),",
            "                              {'img_id': img_id, 'e': e},",
            "                              instance=instance)",
            "",
            "    # NOTE(sileht): many callers of this method assume that this",
            "    # method doesn't fail if an image already exists but instead",
            "    # think that it will be reused (ie: (live)-migration/resize)",
            "    def _create_image(self, context, instance,",
            "                      disk_mapping, suffix='',",
            "                      disk_images=None, network_info=None,",
            "                      block_device_info=None, files=None,",
            "                      admin_pass=None, inject_files=True,",
            "                      fallback_from_host=None):",
            "        booted_from_volume = self._is_booted_from_volume(",
            "            instance, disk_mapping)",
            "",
            "        def image(fname, image_type=CONF.libvirt.images_type):",
            "            return self.image_backend.image(instance,",
            "                                            fname + suffix, image_type)",
            "",
            "        def raw(fname):",
            "            return image(fname, image_type='raw')",
            "",
            "        # ensure directories exist and are writable",
            "        fileutils.ensure_tree(libvirt_utils.get_instance_path(instance))",
            "",
            "        LOG.info(_LI('Creating image'), instance=instance)",
            "",
            "        # NOTE(dprince): for rescue console.log may already exist... chown it.",
            "        self._chown_console_log_for_instance(instance)",
            "",
            "        # NOTE(yaguang): For evacuate disk.config already exist in shared",
            "        # storage, chown it.",
            "        self._chown_disk_config_for_instance(instance)",
            "",
            "        # NOTE(vish): No need add the suffix to console.log",
            "        libvirt_utils.write_to_file(",
            "            self._get_console_log_path(instance), '', 7)",
            "",
            "        if not disk_images:",
            "            disk_images = {'image_id': instance.image_ref,",
            "                           'kernel_id': instance.kernel_id,",
            "                           'ramdisk_id': instance.ramdisk_id}",
            "",
            "        if disk_images['kernel_id']:",
            "            fname = imagecache.get_cache_fname(disk_images, 'kernel_id')",
            "            raw('kernel').cache(fetch_func=libvirt_utils.fetch_raw_image,",
            "                                context=context,",
            "                                filename=fname,",
            "                                image_id=disk_images['kernel_id'],",
            "                                user_id=instance.user_id,",
            "                                project_id=instance.project_id)",
            "            if disk_images['ramdisk_id']:",
            "                fname = imagecache.get_cache_fname(disk_images, 'ramdisk_id')",
            "                raw('ramdisk').cache(fetch_func=libvirt_utils.fetch_raw_image,",
            "                                     context=context,",
            "                                     filename=fname,",
            "                                     image_id=disk_images['ramdisk_id'],",
            "                                     user_id=instance.user_id,",
            "                                     project_id=instance.project_id)",
            "",
            "        inst_type = instance.get_flavor()",
            "",
            "        # NOTE(ndipanov): Even if disk_mapping was passed in, which",
            "        # currently happens only on rescue - we still don't want to",
            "        # create a base image.",
            "        if not booted_from_volume:",
            "            root_fname = imagecache.get_cache_fname(disk_images, 'image_id')",
            "            size = instance.root_gb * units.Gi",
            "",
            "            if size == 0 or suffix == '.rescue':",
            "                size = None",
            "",
            "            backend = image('disk')",
            "            if instance.task_state == task_states.RESIZE_FINISH:",
            "                backend.create_snap(libvirt_utils.RESIZE_SNAPSHOT_NAME)",
            "            if backend.SUPPORTS_CLONE:",
            "                def clone_fallback_to_fetch(*args, **kwargs):",
            "                    try:",
            "                        backend.clone(context, disk_images['image_id'])",
            "                    except exception.ImageUnacceptable:",
            "                        libvirt_utils.fetch_image(*args, **kwargs)",
            "                fetch_func = clone_fallback_to_fetch",
            "            else:",
            "                fetch_func = libvirt_utils.fetch_image",
            "            self._try_fetch_image_cache(backend, fetch_func, context,",
            "                                        root_fname, disk_images['image_id'],",
            "                                        instance, size, fallback_from_host)",
            "",
            "        # Lookup the filesystem type if required",
            "        os_type_with_default = disk.get_fs_type_for_os_type(instance.os_type)",
            "        # Generate a file extension based on the file system",
            "        # type and the mkfs commands configured if any",
            "        file_extension = disk.get_file_extension_for_os_type(",
            "                                                          os_type_with_default)",
            "",
            "        ephemeral_gb = instance.ephemeral_gb",
            "        if 'disk.local' in disk_mapping:",
            "            disk_image = image('disk.local')",
            "            fn = functools.partial(self._create_ephemeral,",
            "                                   fs_label='ephemeral0',",
            "                                   os_type=instance.os_type,",
            "                                   is_block_dev=disk_image.is_block_dev)",
            "            fname = \"ephemeral_%s_%s\" % (ephemeral_gb, file_extension)",
            "            size = ephemeral_gb * units.Gi",
            "            disk_image.cache(fetch_func=fn,",
            "                             context=context,",
            "                             filename=fname,",
            "                             size=size,",
            "                             ephemeral_size=ephemeral_gb)",
            "",
            "        for idx, eph in enumerate(driver.block_device_info_get_ephemerals(",
            "                block_device_info)):",
            "            disk_image = image(blockinfo.get_eph_disk(idx))",
            "",
            "            specified_fs = eph.get('guest_format')",
            "            if specified_fs and not self.is_supported_fs_format(specified_fs):",
            "                msg = _(\"%s format is not supported\") % specified_fs",
            "                raise exception.InvalidBDMFormat(details=msg)",
            "",
            "            fn = functools.partial(self._create_ephemeral,",
            "                                   fs_label='ephemeral%d' % idx,",
            "                                   os_type=instance.os_type,",
            "                                   is_block_dev=disk_image.is_block_dev)",
            "            size = eph['size'] * units.Gi",
            "            fname = \"ephemeral_%s_%s\" % (eph['size'], file_extension)",
            "            disk_image.cache(fetch_func=fn,",
            "                             context=context,",
            "                             filename=fname,",
            "                             size=size,",
            "                             ephemeral_size=eph['size'],",
            "                             specified_fs=specified_fs)",
            "",
            "        if 'disk.swap' in disk_mapping:",
            "            mapping = disk_mapping['disk.swap']",
            "            swap_mb = 0",
            "",
            "            swap = driver.block_device_info_get_swap(block_device_info)",
            "            if driver.swap_is_usable(swap):",
            "                swap_mb = swap['swap_size']",
            "            elif (inst_type['swap'] > 0 and",
            "                  not block_device.volume_in_mapping(",
            "                    mapping['dev'], block_device_info)):",
            "                swap_mb = inst_type['swap']",
            "",
            "            if swap_mb > 0:",
            "                size = swap_mb * units.Mi",
            "                image('disk.swap').cache(fetch_func=self._create_swap,",
            "                                         context=context,",
            "                                         filename=\"swap_%s\" % swap_mb,",
            "                                         size=size,",
            "                                         swap_mb=swap_mb)",
            "",
            "        # Config drive",
            "        if configdrive.required_by(instance):",
            "            LOG.info(_LI('Using config drive'), instance=instance)",
            "            extra_md = {}",
            "            if admin_pass:",
            "                extra_md['admin_pass'] = admin_pass",
            "",
            "            inst_md = instance_metadata.InstanceMetadata(instance,",
            "                content=files, extra_md=extra_md, network_info=network_info)",
            "            with configdrive.ConfigDriveBuilder(instance_md=inst_md) as cdb:",
            "                configdrive_path = self._get_disk_config_path(instance, suffix)",
            "                LOG.info(_LI('Creating config drive at %(path)s'),",
            "                         {'path': configdrive_path}, instance=instance)",
            "",
            "                try:",
            "                    cdb.make_drive(configdrive_path)",
            "                except processutils.ProcessExecutionError as e:",
            "                    with excutils.save_and_reraise_exception():",
            "                        LOG.error(_LE('Creating config drive failed '",
            "                                      'with error: %s'),",
            "                                  e, instance=instance)",
            "",
            "            try:",
            "                # Tell the storage backend about the config drive",
            "                config_drive_image = self.image_backend.image(",
            "                    instance, 'disk.config' + suffix,",
            "                    self._get_disk_config_image_type())",
            "",
            "                config_drive_image.import_file(",
            "                    instance, configdrive_path, 'disk.config' + suffix)",
            "            finally:",
            "                # NOTE(mikal): if the config drive was imported into RBD, then",
            "                # we no longer need the local copy",
            "                if CONF.libvirt.images_type == 'rbd':",
            "                    os.unlink(configdrive_path)",
            "",
            "        # File injection only if needed",
            "        elif inject_files and CONF.libvirt.inject_partition != -2:",
            "            if booted_from_volume:",
            "                LOG.warn(_LW('File injection into a boot from volume '",
            "                             'instance is not supported'), instance=instance)",
            "            self._inject_data(",
            "                instance, network_info, admin_pass, files, suffix)",
            "",
            "        if CONF.libvirt.virt_type == 'uml':",
            "            libvirt_utils.chown(image('disk').path, 'root')",
            "",
            "    def _prepare_pci_devices_for_use(self, pci_devices):",
            "        # kvm , qemu support managed mode",
            "        # In managed mode, the configured device will be automatically",
            "        # detached from the host OS drivers when the guest is started,",
            "        # and then re-attached when the guest shuts down.",
            "        if CONF.libvirt.virt_type != 'xen':",
            "            # we do manual detach only for xen",
            "            return",
            "        try:",
            "            for dev in pci_devices:",
            "                libvirt_dev_addr = dev['hypervisor_name']",
            "                libvirt_dev = \\",
            "                        self._host.device_lookup_by_name(libvirt_dev_addr)",
            "                # Note(yjiang5) Spelling for 'dettach' is correct, see",
            "                # http://libvirt.org/html/libvirt-libvirt.html.",
            "                libvirt_dev.dettach()",
            "",
            "            # Note(yjiang5): A reset of one PCI device may impact other",
            "            # devices on the same bus, thus we need two separated loops",
            "            # to detach and then reset it.",
            "            for dev in pci_devices:",
            "                libvirt_dev_addr = dev['hypervisor_name']",
            "                libvirt_dev = \\",
            "                        self._host.device_lookup_by_name(libvirt_dev_addr)",
            "                libvirt_dev.reset()",
            "",
            "        except libvirt.libvirtError as exc:",
            "            raise exception.PciDevicePrepareFailed(id=dev['id'],",
            "                                                   instance_uuid=",
            "                                                   dev['instance_uuid'],",
            "                                                   reason=six.text_type(exc))",
            "",
            "    def _detach_pci_devices(self, guest, pci_devs):",
            "",
            "        # for libvirt version < 1.1.1, this is race condition",
            "        # so forbid detach if not had this version",
            "        if not self._host.has_min_version(MIN_LIBVIRT_DEVICE_CALLBACK_VERSION):",
            "            if pci_devs:",
            "                reason = (_(\"Detaching PCI devices with libvirt < %(ver)s\"",
            "                           \" is not permitted\") %",
            "                           {'ver': MIN_LIBVIRT_DEVICE_CALLBACK_VERSION})",
            "                raise exception.PciDeviceDetachFailed(reason=reason,",
            "                                                      dev=pci_devs)",
            "        try:",
            "            for dev in pci_devs:",
            "                guest.detach_device(self._get_guest_pci_device(dev), live=True)",
            "                # after detachDeviceFlags returned, we should check the dom to",
            "                # ensure the detaching is finished",
            "                xml = guest.get_xml_desc()",
            "                xml_doc = etree.fromstring(xml)",
            "                guest_config = vconfig.LibvirtConfigGuest()",
            "                guest_config.parse_dom(xml_doc)",
            "",
            "                for hdev in [d for d in guest_config.devices",
            "                    if isinstance(d, vconfig.LibvirtConfigGuestHostdevPCI)]:",
            "                    hdbsf = [hdev.domain, hdev.bus, hdev.slot, hdev.function]",
            "                    dbsf = pci_utils.parse_address(dev['address'])",
            "                    if [int(x, 16) for x in hdbsf] ==\\",
            "                            [int(x, 16) for x in dbsf]:",
            "                        raise exception.PciDeviceDetachFailed(reason=",
            "                                                              \"timeout\",",
            "                                                              dev=dev)",
            "",
            "        except libvirt.libvirtError as ex:",
            "            error_code = ex.get_error_code()",
            "            if error_code == libvirt.VIR_ERR_NO_DOMAIN:",
            "                LOG.warn(_LW(\"Instance disappeared while detaching \"",
            "                             \"a PCI device from it.\"))",
            "            else:",
            "                raise",
            "",
            "    def _attach_pci_devices(self, guest, pci_devs):",
            "        try:",
            "            for dev in pci_devs:",
            "                guest.attach_device(self._get_guest_pci_device(dev))",
            "",
            "        except libvirt.libvirtError:",
            "            LOG.error(_LE('Attaching PCI devices %(dev)s to %(dom)s failed.'),",
            "                      {'dev': pci_devs, 'dom': guest.id})",
            "            raise",
            "",
            "    @staticmethod",
            "    def _has_sriov_port(network_info):",
            "        for vif in network_info:",
            "            if vif['vnic_type'] == network_model.VNIC_TYPE_DIRECT:",
            "                return True",
            "        return False",
            "",
            "    def _attach_sriov_ports(self, context, instance, guest, network_info=None):",
            "        if network_info is None:",
            "            network_info = instance.info_cache.network_info",
            "        if network_info is None:",
            "            return",
            "",
            "        if self._has_sriov_port(network_info):",
            "            for vif in network_info:",
            "                if vif['vnic_type'] in network_model.VNIC_TYPES_SRIOV:",
            "                    cfg = self.vif_driver.get_config(instance,",
            "                                                     vif,",
            "                                                     instance.image_meta,",
            "                                                     instance.flavor,",
            "                                                     CONF.libvirt.virt_type,",
            "                                                     self._host)",
            "                    LOG.debug('Attaching SR-IOV port %(port)s to %(dom)s',",
            "                              {'port': vif, 'dom': guest.id},",
            "                              instance=instance)",
            "                    guest.attach_device(cfg)",
            "",
            "    def _detach_sriov_ports(self, context, instance, guest):",
            "        network_info = instance.info_cache.network_info",
            "        if network_info is None:",
            "            return",
            "",
            "        if self._has_sriov_port(network_info):",
            "            # for libvirt version < 1.1.1, this is race condition",
            "            # so forbid detach if it's an older version",
            "            if not self._host.has_min_version(",
            "                            MIN_LIBVIRT_DEVICE_CALLBACK_VERSION):",
            "                reason = (_(\"Detaching SR-IOV ports with\"",
            "                           \" libvirt < %(ver)s is not permitted\") %",
            "                           {'ver': MIN_LIBVIRT_DEVICE_CALLBACK_VERSION})",
            "                raise exception.PciDeviceDetachFailed(reason=reason,",
            "                                                      dev=network_info)",
            "",
            "            image_meta = objects.ImageMeta.from_instance(instance)",
            "            sriov_pci_addresses = [",
            "                self.vif_driver.get_config(instance,",
            "                                           vif,",
            "                                           image_meta,",
            "                                           instance.flavor,",
            "                                           CONF.libvirt.virt_type,",
            "                                           self._host).source_dev",
            "                for vif in network_info",
            "                if vif['vnic_type'] in network_model.VNIC_TYPES_SRIOV",
            "            ]",
            "",
            "            # use detach_pci_devices to avoid failure in case of",
            "            # multiple guest SRIOV ports with the same MAC",
            "            # (protection use-case, ports are on different physical",
            "            # interfaces)",
            "            pci_devs = pci_manager.get_instance_pci_devs(instance, 'all')",
            "            sriov_devs = [pci_dev for pci_dev in pci_devs",
            "                          if pci_dev.address in sriov_pci_addresses]",
            "            self._detach_pci_devices(guest, sriov_devs)",
            "",
            "    def _set_host_enabled(self, enabled,",
            "                          disable_reason=DISABLE_REASON_UNDEFINED):",
            "        \"\"\"Enables / Disables the compute service on this host.",
            "",
            "           This doesn't override non-automatic disablement with an automatic",
            "           setting; thereby permitting operators to keep otherwise",
            "           healthy hosts out of rotation.",
            "        \"\"\"",
            "",
            "        status_name = {True: 'disabled',",
            "                       False: 'enabled'}",
            "",
            "        disable_service = not enabled",
            "",
            "        ctx = nova_context.get_admin_context()",
            "        try:",
            "            service = objects.Service.get_by_compute_host(ctx, CONF.host)",
            "",
            "            if service.disabled != disable_service:",
            "                # Note(jang): this is a quick fix to stop operator-",
            "                # disabled compute hosts from re-enabling themselves",
            "                # automatically. We prefix any automatic reason code",
            "                # with a fixed string. We only re-enable a host",
            "                # automatically if we find that string in place.",
            "                # This should probably be replaced with a separate flag.",
            "                if not service.disabled or (",
            "                        service.disabled_reason and",
            "                        service.disabled_reason.startswith(DISABLE_PREFIX)):",
            "                    service.disabled = disable_service",
            "                    service.disabled_reason = (",
            "                       DISABLE_PREFIX + disable_reason",
            "                       if disable_service else DISABLE_REASON_UNDEFINED)",
            "                    service.save()",
            "                    LOG.debug('Updating compute service status to %s',",
            "                              status_name[disable_service])",
            "                else:",
            "                    LOG.debug('Not overriding manual compute service '",
            "                              'status with: %s',",
            "                              status_name[disable_service])",
            "        except exception.ComputeHostNotFound:",
            "            LOG.warn(_LW('Cannot update service status on host \"%s\" '",
            "                         'since it is not registered.'), CONF.host)",
            "        except Exception:",
            "            LOG.warn(_LW('Cannot update service status on host \"%s\" '",
            "                         'due to an unexpected exception.'), CONF.host,",
            "                     exc_info=True)",
            "",
            "    def _get_guest_cpu_model_config(self):",
            "        mode = CONF.libvirt.cpu_mode",
            "        model = CONF.libvirt.cpu_model",
            "",
            "        if (CONF.libvirt.virt_type == \"kvm\" or",
            "            CONF.libvirt.virt_type == \"qemu\"):",
            "            if mode is None:",
            "                mode = \"host-model\"",
            "            if mode == \"none\":",
            "                return vconfig.LibvirtConfigGuestCPU()",
            "        else:",
            "            if mode is None or mode == \"none\":",
            "                return None",
            "",
            "        if ((CONF.libvirt.virt_type != \"kvm\" and",
            "             CONF.libvirt.virt_type != \"qemu\")):",
            "            msg = _(\"Config requested an explicit CPU model, but \"",
            "                    \"the current libvirt hypervisor '%s' does not \"",
            "                    \"support selecting CPU models\") % CONF.libvirt.virt_type",
            "            raise exception.Invalid(msg)",
            "",
            "        if mode == \"custom\" and model is None:",
            "            msg = _(\"Config requested a custom CPU model, but no \"",
            "                    \"model name was provided\")",
            "            raise exception.Invalid(msg)",
            "        elif mode != \"custom\" and model is not None:",
            "            msg = _(\"A CPU model name should not be set when a \"",
            "                    \"host CPU model is requested\")",
            "            raise exception.Invalid(msg)",
            "",
            "        LOG.debug(\"CPU mode '%(mode)s' model '%(model)s' was chosen\",",
            "                  {'mode': mode, 'model': (model or \"\")})",
            "",
            "        cpu = vconfig.LibvirtConfigGuestCPU()",
            "        cpu.mode = mode",
            "        cpu.model = model",
            "",
            "        return cpu",
            "",
            "    def _get_guest_cpu_config(self, flavor, image_meta,",
            "                              guest_cpu_numa_config, instance_numa_topology):",
            "        cpu = self._get_guest_cpu_model_config()",
            "",
            "        if cpu is None:",
            "            return None",
            "",
            "        topology = hardware.get_best_cpu_topology(",
            "                flavor, image_meta, numa_topology=instance_numa_topology)",
            "",
            "        cpu.sockets = topology.sockets",
            "        cpu.cores = topology.cores",
            "        cpu.threads = topology.threads",
            "        cpu.numa = guest_cpu_numa_config",
            "",
            "        return cpu",
            "",
            "    def _get_guest_disk_config(self, instance, name, disk_mapping, inst_type,",
            "                               image_type=None):",
            "        if CONF.libvirt.hw_disk_discard:",
            "            if not self._host.has_min_version(MIN_LIBVIRT_DISCARD_VERSION,",
            "                                              MIN_QEMU_DISCARD_VERSION,",
            "                                              host.HV_DRIVER_QEMU):",
            "                msg = (_('Volume sets discard option, but libvirt %(libvirt)s'",
            "                         ' or later is required, qemu %(qemu)s'",
            "                         ' or later is required.') %",
            "                      {'libvirt': MIN_LIBVIRT_DISCARD_VERSION,",
            "                       'qemu': MIN_QEMU_DISCARD_VERSION})",
            "                raise exception.Invalid(msg)",
            "",
            "        image = self.image_backend.image(instance,",
            "                                         name,",
            "                                         image_type)",
            "        disk_info = disk_mapping[name]",
            "        return image.libvirt_info(disk_info['bus'],",
            "                                  disk_info['dev'],",
            "                                  disk_info['type'],",
            "                                  self.disk_cachemode,",
            "                                  inst_type['extra_specs'],",
            "                                  self._host.get_version())",
            "",
            "    def _get_guest_fs_config(self, instance, name, image_type=None):",
            "        image = self.image_backend.image(instance,",
            "                                         name,",
            "                                         image_type)",
            "        return image.libvirt_fs_info(\"/\", \"ploop\")",
            "",
            "    def _get_guest_storage_config(self, instance, image_meta,",
            "                                  disk_info,",
            "                                  rescue, block_device_info,",
            "                                  inst_type, os_type):",
            "        devices = []",
            "        disk_mapping = disk_info['mapping']",
            "",
            "        block_device_mapping = driver.block_device_info_get_mapping(",
            "            block_device_info)",
            "        mount_rootfs = CONF.libvirt.virt_type == \"lxc\"",
            "        if mount_rootfs:",
            "            fs = vconfig.LibvirtConfigGuestFilesys()",
            "            fs.source_type = \"mount\"",
            "            fs.source_dir = os.path.join(",
            "                libvirt_utils.get_instance_path(instance), 'rootfs')",
            "            devices.append(fs)",
            "        elif os_type == vm_mode.EXE and CONF.libvirt.virt_type == \"parallels\":",
            "            if 'disk' in disk_mapping:",
            "                fs = self._get_guest_fs_config(instance, \"disk\")",
            "                devices.append(fs)",
            "        else:",
            "",
            "            if rescue:",
            "                diskrescue = self._get_guest_disk_config(instance,",
            "                                                         'disk.rescue',",
            "                                                         disk_mapping,",
            "                                                         inst_type)",
            "                devices.append(diskrescue)",
            "",
            "                diskos = self._get_guest_disk_config(instance,",
            "                                                     'disk',",
            "                                                     disk_mapping,",
            "                                                     inst_type)",
            "                devices.append(diskos)",
            "            else:",
            "                if 'disk' in disk_mapping:",
            "                    diskos = self._get_guest_disk_config(instance,",
            "                                                         'disk',",
            "                                                         disk_mapping,",
            "                                                         inst_type)",
            "                    devices.append(diskos)",
            "",
            "                if 'disk.local' in disk_mapping:",
            "                    disklocal = self._get_guest_disk_config(instance,",
            "                                                            'disk.local',",
            "                                                            disk_mapping,",
            "                                                            inst_type)",
            "                    devices.append(disklocal)",
            "                    instance.default_ephemeral_device = (",
            "                        block_device.prepend_dev(disklocal.target_dev))",
            "",
            "                for idx, eph in enumerate(",
            "                    driver.block_device_info_get_ephemerals(",
            "                        block_device_info)):",
            "                    diskeph = self._get_guest_disk_config(",
            "                        instance,",
            "                        blockinfo.get_eph_disk(idx),",
            "                        disk_mapping, inst_type)",
            "                    devices.append(diskeph)",
            "",
            "                if 'disk.swap' in disk_mapping:",
            "                    diskswap = self._get_guest_disk_config(instance,",
            "                                                           'disk.swap',",
            "                                                           disk_mapping,",
            "                                                           inst_type)",
            "                    devices.append(diskswap)",
            "                    instance.default_swap_device = (",
            "                        block_device.prepend_dev(diskswap.target_dev))",
            "",
            "            if 'disk.config' in disk_mapping:",
            "                diskconfig = self._get_guest_disk_config(",
            "                    instance, 'disk.config', disk_mapping, inst_type,",
            "                    self._get_disk_config_image_type())",
            "                devices.append(diskconfig)",
            "",
            "        for vol in block_device.get_bdms_to_connect(block_device_mapping,",
            "                                                   mount_rootfs):",
            "            connection_info = vol['connection_info']",
            "            vol_dev = block_device.prepend_dev(vol['mount_device'])",
            "            info = disk_mapping[vol_dev]",
            "            self._connect_volume(connection_info, info)",
            "            cfg = self._get_volume_config(connection_info, info)",
            "            devices.append(cfg)",
            "            vol['connection_info'] = connection_info",
            "            vol.save()",
            "",
            "        for d in devices:",
            "            self._set_cache_mode(d)",
            "",
            "        if image_meta.properties.get('hw_scsi_model'):",
            "            hw_scsi_model = image_meta.properties.hw_scsi_model",
            "            scsi_controller = vconfig.LibvirtConfigGuestController()",
            "            scsi_controller.type = 'scsi'",
            "            scsi_controller.model = hw_scsi_model",
            "            devices.append(scsi_controller)",
            "",
            "        return devices",
            "",
            "    def _get_host_sysinfo_serial_hardware(self):",
            "        \"\"\"Get a UUID from the host hardware",
            "",
            "        Get a UUID for the host hardware reported by libvirt.",
            "        This is typically from the SMBIOS data, unless it has",
            "        been overridden in /etc/libvirt/libvirtd.conf",
            "        \"\"\"",
            "        caps = self._host.get_capabilities()",
            "        return caps.host.uuid",
            "",
            "    def _get_host_sysinfo_serial_os(self):",
            "        \"\"\"Get a UUID from the host operating system",
            "",
            "        Get a UUID for the host operating system. Modern Linux",
            "        distros based on systemd provide a /etc/machine-id",
            "        file containing a UUID. This is also provided inside",
            "        systemd based containers and can be provided by other",
            "        init systems too, since it is just a plain text file.",
            "        \"\"\"",
            "        if not os.path.exists(\"/etc/machine-id\"):",
            "            msg = _(\"Unable to get host UUID: /etc/machine-id does not exist\")",
            "            raise exception.NovaException(msg)",
            "",
            "        with open(\"/etc/machine-id\") as f:",
            "            # We want to have '-' in the right place",
            "            # so we parse & reformat the value",
            "            lines = f.read().split()",
            "            if not lines:",
            "                msg = _(\"Unable to get host UUID: /etc/machine-id is empty\")",
            "                raise exception.NovaException(msg)",
            "",
            "            return str(uuid.UUID(lines[0]))",
            "",
            "    def _get_host_sysinfo_serial_auto(self):",
            "        if os.path.exists(\"/etc/machine-id\"):",
            "            return self._get_host_sysinfo_serial_os()",
            "        else:",
            "            return self._get_host_sysinfo_serial_hardware()",
            "",
            "    def _get_guest_config_sysinfo(self, instance):",
            "        sysinfo = vconfig.LibvirtConfigGuestSysinfo()",
            "",
            "        sysinfo.system_manufacturer = version.vendor_string()",
            "        sysinfo.system_product = version.product_string()",
            "        sysinfo.system_version = version.version_string_with_package()",
            "",
            "        sysinfo.system_serial = self._sysinfo_serial_func()",
            "        sysinfo.system_uuid = instance.uuid",
            "",
            "        sysinfo.system_family = \"Virtual Machine\"",
            "",
            "        return sysinfo",
            "",
            "    def _get_guest_pci_device(self, pci_device):",
            "",
            "        dbsf = pci_utils.parse_address(pci_device.address)",
            "        dev = vconfig.LibvirtConfigGuestHostdevPCI()",
            "        dev.domain, dev.bus, dev.slot, dev.function = dbsf",
            "",
            "        # only kvm support managed mode",
            "        if CONF.libvirt.virt_type in ('xen', 'parallels',):",
            "            dev.managed = 'no'",
            "        if CONF.libvirt.virt_type in ('kvm', 'qemu'):",
            "            dev.managed = 'yes'",
            "",
            "        return dev",
            "",
            "    def _get_guest_config_meta(self, context, instance):",
            "        \"\"\"Get metadata config for guest.\"\"\"",
            "",
            "        meta = vconfig.LibvirtConfigGuestMetaNovaInstance()",
            "        meta.package = version.version_string_with_package()",
            "        meta.name = instance.display_name",
            "        meta.creationTime = time.time()",
            "",
            "        if instance.image_ref not in (\"\", None):",
            "            meta.roottype = \"image\"",
            "            meta.rootid = instance.image_ref",
            "",
            "        if context is not None:",
            "            ometa = vconfig.LibvirtConfigGuestMetaNovaOwner()",
            "            ometa.userid = context.user_id",
            "            ometa.username = context.user_name",
            "            ometa.projectid = context.project_id",
            "            ometa.projectname = context.project_name",
            "            meta.owner = ometa",
            "",
            "        fmeta = vconfig.LibvirtConfigGuestMetaNovaFlavor()",
            "        flavor = instance.flavor",
            "        fmeta.name = flavor.name",
            "        fmeta.memory = flavor.memory_mb",
            "        fmeta.vcpus = flavor.vcpus",
            "        fmeta.ephemeral = flavor.ephemeral_gb",
            "        fmeta.disk = flavor.root_gb",
            "        fmeta.swap = flavor.swap",
            "",
            "        meta.flavor = fmeta",
            "",
            "        return meta",
            "",
            "    def _machine_type_mappings(self):",
            "        mappings = {}",
            "        for mapping in CONF.libvirt.hw_machine_type:",
            "            host_arch, _, machine_type = mapping.partition('=')",
            "            mappings[host_arch] = machine_type",
            "        return mappings",
            "",
            "    def _get_machine_type(self, image_meta, caps):",
            "        # The underlying machine type can be set as an image attribute,",
            "        # or otherwise based on some architecture specific defaults",
            "",
            "        mach_type = None",
            "",
            "        if image_meta.properties.get('hw_machine_type') is not None:",
            "            mach_type = image_meta.properties.hw_machine_type",
            "        else:",
            "            # For ARM systems we will default to vexpress-a15 for armv7",
            "            # and virt for aarch64",
            "            if caps.host.cpu.arch == arch.ARMV7:",
            "                mach_type = \"vexpress-a15\"",
            "",
            "            if caps.host.cpu.arch == arch.AARCH64:",
            "                mach_type = \"virt\"",
            "",
            "            if caps.host.cpu.arch in (arch.S390, arch.S390X):",
            "                mach_type = 's390-ccw-virtio'",
            "",
            "            # If set in the config, use that as the default.",
            "            if CONF.libvirt.hw_machine_type:",
            "                mappings = self._machine_type_mappings()",
            "                mach_type = mappings.get(caps.host.cpu.arch)",
            "",
            "        return mach_type",
            "",
            "    @staticmethod",
            "    def _create_idmaps(klass, map_strings):",
            "        idmaps = []",
            "        if len(map_strings) > 5:",
            "            map_strings = map_strings[0:5]",
            "            LOG.warn(_LW(\"Too many id maps, only included first five.\"))",
            "        for map_string in map_strings:",
            "            try:",
            "                idmap = klass()",
            "                values = [int(i) for i in map_string.split(\":\")]",
            "                idmap.start = values[0]",
            "                idmap.target = values[1]",
            "                idmap.count = values[2]",
            "                idmaps.append(idmap)",
            "            except (ValueError, IndexError):",
            "                LOG.warn(_LW(\"Invalid value for id mapping %s\"), map_string)",
            "        return idmaps",
            "",
            "    def _get_guest_idmaps(self):",
            "        id_maps = []",
            "        if CONF.libvirt.virt_type == 'lxc' and CONF.libvirt.uid_maps:",
            "            uid_maps = self._create_idmaps(vconfig.LibvirtConfigGuestUIDMap,",
            "                                           CONF.libvirt.uid_maps)",
            "            id_maps.extend(uid_maps)",
            "        if CONF.libvirt.virt_type == 'lxc' and CONF.libvirt.gid_maps:",
            "            gid_maps = self._create_idmaps(vconfig.LibvirtConfigGuestGIDMap,",
            "                                           CONF.libvirt.gid_maps)",
            "            id_maps.extend(gid_maps)",
            "        return id_maps",
            "",
            "    def _update_guest_cputune(self, guest, flavor, virt_type):",
            "        is_able = self._host.is_cpu_control_policy_capable()",
            "",
            "        cputuning = ['shares', 'period', 'quota']",
            "        wants_cputune = any([k for k in cputuning",
            "            if \"quota:cpu_\" + k in flavor.extra_specs.keys()])",
            "",
            "        if wants_cputune and not is_able:",
            "            raise exception.UnsupportedHostCPUControlPolicy()",
            "",
            "        if not is_able or virt_type not in ('lxc', 'kvm', 'qemu'):",
            "            return",
            "",
            "        if guest.cputune is None:",
            "            guest.cputune = vconfig.LibvirtConfigGuestCPUTune()",
            "            # Setting the default cpu.shares value to be a value",
            "            # dependent on the number of vcpus",
            "        guest.cputune.shares = 1024 * guest.vcpus",
            "",
            "        for name in cputuning:",
            "            key = \"quota:cpu_\" + name",
            "            if key in flavor.extra_specs:",
            "                setattr(guest.cputune, name,",
            "                        int(flavor.extra_specs[key]))",
            "",
            "    def _get_cpu_numa_config_from_instance(self, instance_numa_topology,",
            "                                           wants_hugepages):",
            "        if instance_numa_topology:",
            "            guest_cpu_numa = vconfig.LibvirtConfigGuestCPUNUMA()",
            "            for instance_cell in instance_numa_topology.cells:",
            "                guest_cell = vconfig.LibvirtConfigGuestCPUNUMACell()",
            "                guest_cell.id = instance_cell.id",
            "                guest_cell.cpus = instance_cell.cpuset",
            "                guest_cell.memory = instance_cell.memory * units.Ki",
            "",
            "                # The vhost-user network backend requires file backed",
            "                # guest memory (ie huge pages) to be marked as shared",
            "                # access, not private, so an external process can read",
            "                # and write the pages.",
            "                #",
            "                # You can't change the shared vs private flag for an",
            "                # already running guest, and since we can't predict what",
            "                # types of NIC may be hotplugged, we have no choice but",
            "                # to unconditionally turn on the shared flag. This has",
            "                # no real negative functional effect on the guest, so",
            "                # is a reasonable approach to take",
            "                if wants_hugepages:",
            "                    guest_cell.memAccess = \"shared\"",
            "                guest_cpu_numa.cells.append(guest_cell)",
            "            return guest_cpu_numa",
            "",
            "    def _has_cpu_policy_support(self):",
            "        for ver in BAD_LIBVIRT_CPU_POLICY_VERSIONS:",
            "            if self._host.has_version(ver):",
            "                ver_ = self._version_to_string(ver)",
            "                raise exception.CPUPinningNotSupported(reason=_(",
            "                    'Invalid libvirt version %(version)s') % {'version': ver_})",
            "        return True",
            "",
            "    def _wants_hugepages(self, host_topology, instance_topology):",
            "        \"\"\"Determine if the guest / host topology implies the",
            "           use of huge pages for guest RAM backing",
            "        \"\"\"",
            "",
            "        if host_topology is None or instance_topology is None:",
            "            return False",
            "",
            "        avail_pagesize = [page.size_kb",
            "                          for page in host_topology.cells[0].mempages]",
            "        avail_pagesize.sort()",
            "        # Remove smallest page size as that's not classed as a largepage",
            "        avail_pagesize = avail_pagesize[1:]",
            "",
            "        # See if we have page size set",
            "        for cell in instance_topology.cells:",
            "            if (cell.pagesize is not None and",
            "                cell.pagesize in avail_pagesize):",
            "                return True",
            "",
            "        return False",
            "",
            "    def _get_guest_numa_config(self, instance_numa_topology, flavor, pci_devs,",
            "                               allowed_cpus=None, image_meta=None):",
            "        \"\"\"Returns the config objects for the guest NUMA specs.",
            "",
            "        Determines the CPUs that the guest can be pinned to if the guest",
            "        specifies a cell topology and the host supports it. Constructs the",
            "        libvirt XML config object representing the NUMA topology selected",
            "        for the guest. Returns a tuple of:",
            "",
            "            (cpu_set, guest_cpu_tune, guest_cpu_numa, guest_numa_tune)",
            "",
            "        With the following caveats:",
            "",
            "            a) If there is no specified guest NUMA topology, then",
            "               all tuple elements except cpu_set shall be None. cpu_set",
            "               will be populated with the chosen CPUs that the guest",
            "               allowed CPUs fit within, which could be the supplied",
            "               allowed_cpus value if the host doesn't support NUMA",
            "               topologies.",
            "",
            "            b) If there is a specified guest NUMA topology, then",
            "               cpu_set will be None and guest_cpu_numa will be the",
            "               LibvirtConfigGuestCPUNUMA object representing the guest's",
            "               NUMA topology. If the host supports NUMA, then guest_cpu_tune",
            "               will contain a LibvirtConfigGuestCPUTune object representing",
            "               the optimized chosen cells that match the host capabilities",
            "               with the instance's requested topology. If the host does",
            "               not support NUMA, then guest_cpu_tune and guest_numa_tune",
            "               will be None.",
            "        \"\"\"",
            "",
            "        if (not self._has_numa_support() and",
            "                instance_numa_topology is not None):",
            "            # We should not get here, since we should have avoided",
            "            # reporting NUMA topology from _get_host_numa_topology",
            "            # in the first place. Just in case of a scheduler",
            "            # mess up though, raise an exception",
            "            raise exception.NUMATopologyUnsupported()",
            "",
            "        topology = self._get_host_numa_topology()",
            "",
            "        # We have instance NUMA so translate it to the config class",
            "        guest_cpu_numa_config = self._get_cpu_numa_config_from_instance(",
            "                instance_numa_topology,",
            "                self._wants_hugepages(topology, instance_numa_topology))",
            "",
            "        if not guest_cpu_numa_config:",
            "            # No NUMA topology defined for instance - let the host kernel deal",
            "            # with the NUMA effects.",
            "            # TODO(ndipanov): Attempt to spread the instance",
            "            # across NUMA nodes and expose the topology to the",
            "            # instance as an optimisation",
            "            return GuestNumaConfig(allowed_cpus, None, None, None)",
            "        else:",
            "            if topology:",
            "                # Now get the CpuTune configuration from the numa_topology",
            "                guest_cpu_tune = vconfig.LibvirtConfigGuestCPUTune()",
            "                guest_numa_tune = vconfig.LibvirtConfigGuestNUMATune()",
            "                allpcpus = []",
            "",
            "                numa_mem = vconfig.LibvirtConfigGuestNUMATuneMemory()",
            "                numa_memnodes = [vconfig.LibvirtConfigGuestNUMATuneMemNode()",
            "                                 for _ in guest_cpu_numa_config.cells]",
            "",
            "                for host_cell in topology.cells:",
            "                    for guest_node_id, guest_config_cell in enumerate(",
            "                            guest_cpu_numa_config.cells):",
            "                        if guest_config_cell.id == host_cell.id:",
            "                            node = numa_memnodes[guest_node_id]",
            "                            node.cellid = guest_config_cell.id",
            "                            node.nodeset = [host_cell.id]",
            "                            node.mode = \"strict\"",
            "",
            "                            numa_mem.nodeset.append(host_cell.id)",
            "",
            "                            object_numa_cell = (",
            "                                    instance_numa_topology.cells[guest_node_id]",
            "                                )",
            "                            for cpu in guest_config_cell.cpus:",
            "                                pin_cpuset = (",
            "                                    vconfig.LibvirtConfigGuestCPUTuneVCPUPin())",
            "                                pin_cpuset.id = cpu",
            "                                # If there is pinning information in the cell",
            "                                # we pin to individual CPUs, otherwise we float",
            "                                # over the whole host NUMA node",
            "",
            "                                if (object_numa_cell.cpu_pinning and",
            "                                        self._has_cpu_policy_support()):",
            "                                    pcpu = object_numa_cell.cpu_pinning[cpu]",
            "                                    pin_cpuset.cpuset = set([pcpu])",
            "                                else:",
            "                                    pin_cpuset.cpuset = host_cell.cpuset",
            "                                allpcpus.extend(pin_cpuset.cpuset)",
            "                                guest_cpu_tune.vcpupin.append(pin_cpuset)",
            "",
            "                # TODO(berrange) When the guest has >1 NUMA node, it will",
            "                # span multiple host NUMA nodes. By pinning emulator threads",
            "                # to the union of all nodes, we guarantee there will be",
            "                # cross-node memory access by the emulator threads when",
            "                # responding to guest I/O operations. The only way to avoid",
            "                # this would be to pin emulator threads to a single node and",
            "                # tell the guest OS to only do I/O from one of its virtual",
            "                # NUMA nodes. This is not even remotely practical.",
            "                #",
            "                # The long term solution is to make use of a new QEMU feature",
            "                # called \"I/O Threads\" which will let us configure an explicit",
            "                # I/O thread for each guest vCPU or guest NUMA node. It is",
            "                # still TBD how to make use of this feature though, especially",
            "                # how to associate IO threads with guest devices to eliminiate",
            "                # cross NUMA node traffic. This is an area of investigation",
            "                # for QEMU community devs.",
            "                emulatorpin = vconfig.LibvirtConfigGuestCPUTuneEmulatorPin()",
            "                emulatorpin.cpuset = set(allpcpus)",
            "                guest_cpu_tune.emulatorpin = emulatorpin",
            "                # Sort the vcpupin list per vCPU id for human-friendlier XML",
            "                guest_cpu_tune.vcpupin.sort(key=operator.attrgetter(\"id\"))",
            "",
            "                if hardware.is_realtime_enabled(flavor):",
            "                    if not self._host.has_min_version(",
            "                            MIN_LIBVIRT_REALTIME_VERSION):",
            "                        raise exception.RealtimePolicyNotSupported()",
            "",
            "                    vcpus_rt, vcpus_em = hardware.vcpus_realtime_topology(",
            "                        set(cpu.id for cpu in guest_cpu_tune.vcpupin),",
            "                        flavor, image_meta)",
            "",
            "                    vcpusched = vconfig.LibvirtConfigGuestCPUTuneVCPUSched()",
            "                    vcpusched.vcpus = vcpus_rt",
            "                    vcpusched.scheduler = \"fifo\"",
            "                    vcpusched.priority = (",
            "                        CONF.libvirt.realtime_scheduler_priority)",
            "                    guest_cpu_tune.vcpusched.append(vcpusched)",
            "                    guest_cpu_tune.emulatorpin.cpuset = vcpus_em",
            "",
            "                guest_numa_tune.memory = numa_mem",
            "                guest_numa_tune.memnodes = numa_memnodes",
            "",
            "                # normalize cell.id",
            "                for i, (cell, memnode) in enumerate(",
            "                                            zip(guest_cpu_numa_config.cells,",
            "                                                guest_numa_tune.memnodes)):",
            "                    cell.id = i",
            "                    memnode.cellid = i",
            "",
            "                return GuestNumaConfig(None, guest_cpu_tune,",
            "                                       guest_cpu_numa_config,",
            "                                       guest_numa_tune)",
            "            else:",
            "                return GuestNumaConfig(allowed_cpus, None,",
            "                                       guest_cpu_numa_config, None)",
            "",
            "    def _get_guest_os_type(self, virt_type):",
            "        \"\"\"Returns the guest OS type based on virt type.\"\"\"",
            "        if virt_type == \"lxc\":",
            "            ret = vm_mode.EXE",
            "        elif virt_type == \"uml\":",
            "            ret = vm_mode.UML",
            "        elif virt_type == \"xen\":",
            "            ret = vm_mode.XEN",
            "        else:",
            "            ret = vm_mode.HVM",
            "        return ret",
            "",
            "    def _set_guest_for_rescue(self, rescue, guest, inst_path, virt_type,",
            "                              root_device_name):",
            "        if rescue.get('kernel_id'):",
            "            guest.os_kernel = os.path.join(inst_path, \"kernel.rescue\")",
            "            if virt_type == \"xen\":",
            "                guest.os_cmdline = \"ro root=%s\" % root_device_name",
            "            else:",
            "                guest.os_cmdline = (\"root=%s %s\" % (root_device_name, CONSOLE))",
            "                if virt_type == \"qemu\":",
            "                    guest.os_cmdline += \" no_timer_check\"",
            "        if rescue.get('ramdisk_id'):",
            "            guest.os_initrd = os.path.join(inst_path, \"ramdisk.rescue\")",
            "",
            "    def _set_guest_for_inst_kernel(self, instance, guest, inst_path, virt_type,",
            "                                root_device_name, image_meta):",
            "        guest.os_kernel = os.path.join(inst_path, \"kernel\")",
            "        if virt_type == \"xen\":",
            "            guest.os_cmdline = \"ro root=%s\" % root_device_name",
            "        else:",
            "            guest.os_cmdline = (\"root=%s %s\" % (root_device_name, CONSOLE))",
            "            if virt_type == \"qemu\":",
            "                guest.os_cmdline += \" no_timer_check\"",
            "        if instance.ramdisk_id:",
            "            guest.os_initrd = os.path.join(inst_path, \"ramdisk\")",
            "        # we only support os_command_line with images with an explicit",
            "        # kernel set and don't want to break nova if there's an",
            "        # os_command_line property without a specified kernel_id param",
            "        if image_meta.properties.get(\"os_command_line\"):",
            "            guest.os_cmdline = image_meta.properties.os_command_line",
            "",
            "    def _set_clock(self, guest, os_type, image_meta, virt_type):",
            "        # NOTE(mikal): Microsoft Windows expects the clock to be in",
            "        # \"localtime\". If the clock is set to UTC, then you can use a",
            "        # registry key to let windows know, but Microsoft says this is",
            "        # buggy in http://support.microsoft.com/kb/2687252",
            "        clk = vconfig.LibvirtConfigGuestClock()",
            "        if os_type == 'windows':",
            "            LOG.info(_LI('Configuring timezone for windows instance to '",
            "                         'localtime'))",
            "            clk.offset = 'localtime'",
            "        else:",
            "            clk.offset = 'utc'",
            "        guest.set_clock(clk)",
            "",
            "        if virt_type == \"kvm\":",
            "            self._set_kvm_timers(clk, os_type, image_meta)",
            "",
            "    def _set_kvm_timers(self, clk, os_type, image_meta):",
            "        # TODO(berrange) One day this should be per-guest",
            "        # OS type configurable",
            "        tmpit = vconfig.LibvirtConfigGuestTimer()",
            "        tmpit.name = \"pit\"",
            "        tmpit.tickpolicy = \"delay\"",
            "",
            "        tmrtc = vconfig.LibvirtConfigGuestTimer()",
            "        tmrtc.name = \"rtc\"",
            "        tmrtc.tickpolicy = \"catchup\"",
            "",
            "        clk.add_timer(tmpit)",
            "        clk.add_timer(tmrtc)",
            "",
            "        guestarch = libvirt_utils.get_arch(image_meta)",
            "        if guestarch in (arch.I686, arch.X86_64):",
            "            # NOTE(rfolco): HPET is a hardware timer for x86 arch.",
            "            # qemu -no-hpet is not supported on non-x86 targets.",
            "            tmhpet = vconfig.LibvirtConfigGuestTimer()",
            "            tmhpet.name = \"hpet\"",
            "            tmhpet.present = False",
            "            clk.add_timer(tmhpet)",
            "",
            "        # With new enough QEMU we can provide Windows guests",
            "        # with the paravirtualized hyperv timer source. This",
            "        # is the windows equiv of kvm-clock, allowing Windows",
            "        # guests to accurately keep time.",
            "        if (os_type == 'windows' and",
            "            self._host.has_min_version(MIN_LIBVIRT_HYPERV_TIMER_VERSION,",
            "                                       MIN_QEMU_HYPERV_TIMER_VERSION)):",
            "            tmhyperv = vconfig.LibvirtConfigGuestTimer()",
            "            tmhyperv.name = \"hypervclock\"",
            "            tmhyperv.present = True",
            "            clk.add_timer(tmhyperv)",
            "",
            "    def _set_features(self, guest, os_type, caps, virt_type):",
            "        if virt_type == \"xen\":",
            "            # PAE only makes sense in X86",
            "            if caps.host.cpu.arch in (arch.I686, arch.X86_64):",
            "                guest.features.append(vconfig.LibvirtConfigGuestFeaturePAE())",
            "",
            "        if (virt_type not in (\"lxc\", \"uml\", \"parallels\", \"xen\") or",
            "                (virt_type == \"xen\" and guest.os_type == vm_mode.HVM)):",
            "            guest.features.append(vconfig.LibvirtConfigGuestFeatureACPI())",
            "            guest.features.append(vconfig.LibvirtConfigGuestFeatureAPIC())",
            "",
            "        if (virt_type in (\"qemu\", \"kvm\") and",
            "                os_type == 'windows' and",
            "                self._host.has_min_version(MIN_LIBVIRT_HYPERV_FEATURE_VERSION,",
            "                                           MIN_QEMU_HYPERV_FEATURE_VERSION)):",
            "            hv = vconfig.LibvirtConfigGuestFeatureHyperV()",
            "            hv.relaxed = True",
            "",
            "            if self._host.has_min_version(",
            "                    MIN_LIBVIRT_HYPERV_FEATURE_EXTRA_VERSION):",
            "                hv.spinlocks = True",
            "                # Increase spinlock retries - value recommended by",
            "                # KVM maintainers who certify Windows guests",
            "                # with Microsoft",
            "                hv.spinlock_retries = 8191",
            "                hv.vapic = True",
            "            guest.features.append(hv)",
            "",
            "    def _create_serial_console_devices(self, guest, instance, flavor,",
            "                                       image_meta):",
            "        guest_arch = libvirt_utils.get_arch(image_meta)",
            "",
            "        if CONF.serial_console.enabled:",
            "            num_ports = hardware.get_number_of_serial_ports(",
            "                flavor, image_meta)",
            "            for port in six.moves.range(num_ports):",
            "                if guest_arch in (arch.S390, arch.S390X):",
            "                    console = vconfig.LibvirtConfigGuestConsole()",
            "                else:",
            "                    console = vconfig.LibvirtConfigGuestSerial()",
            "                console.port = port",
            "                console.type = \"tcp\"",
            "                console.listen_host = (",
            "                    CONF.serial_console.proxyclient_address)",
            "                console.listen_port = (",
            "                    serial_console.acquire_port(",
            "                        console.listen_host))",
            "                guest.add_device(console)",
            "        else:",
            "            # The QEMU 'pty' driver throws away any data if no",
            "            # client app is connected. Thus we can't get away",
            "            # with a single type=pty console. Instead we have",
            "            # to configure two separate consoles.",
            "            if guest_arch in (arch.S390, arch.S390X):",
            "                consolelog = vconfig.LibvirtConfigGuestConsole()",
            "                consolelog.target_type = \"sclplm\"",
            "            else:",
            "                consolelog = vconfig.LibvirtConfigGuestSerial()",
            "            consolelog.type = \"file\"",
            "            consolelog.source_path = self._get_console_log_path(instance)",
            "            guest.add_device(consolelog)",
            "",
            "    def _add_video_driver(self, guest, image_meta, flavor):",
            "        VALID_VIDEO_DEVICES = (\"vga\", \"cirrus\", \"vmvga\", \"xen\", \"qxl\")",
            "        video = vconfig.LibvirtConfigGuestVideo()",
            "        # NOTE(ldbragst): The following logic sets the video.type",
            "        # depending on supported defaults given the architecture,",
            "        # virtualization type, and features. The video.type attribute can",
            "        # be overridden by the user with image_meta.properties, which",
            "        # is carried out in the next if statement below this one.",
            "        guestarch = libvirt_utils.get_arch(image_meta)",
            "        if guest.os_type == vm_mode.XEN:",
            "            video.type = 'xen'",
            "        elif CONF.libvirt.virt_type == 'parallels':",
            "            video.type = 'vga'",
            "        elif guestarch in (arch.PPC, arch.PPC64, arch.PPC64LE):",
            "            # NOTE(ldbragst): PowerKVM doesn't support 'cirrus' be default",
            "            # so use 'vga' instead when running on Power hardware.",
            "            video.type = 'vga'",
            "        elif CONF.spice.enabled:",
            "            video.type = 'qxl'",
            "        if image_meta.properties.get('hw_video_model'):",
            "            video.type = image_meta.properties.hw_video_model",
            "            if (video.type not in VALID_VIDEO_DEVICES):",
            "                raise exception.InvalidVideoMode(model=video.type)",
            "",
            "        # Set video memory, only if the flavor's limit is set",
            "        video_ram = image_meta.properties.get('hw_video_ram', 0)",
            "        max_vram = int(flavor.extra_specs.get('hw_video:ram_max_mb', 0))",
            "        if video_ram > max_vram:",
            "            raise exception.RequestedVRamTooHigh(req_vram=video_ram,",
            "                                                 max_vram=max_vram)",
            "        if max_vram and video_ram:",
            "            video.vram = video_ram * units.Mi / units.Ki",
            "        guest.add_device(video)",
            "",
            "    def _add_qga_device(self, guest, instance):",
            "        qga = vconfig.LibvirtConfigGuestChannel()",
            "        qga.type = \"unix\"",
            "        qga.target_name = \"org.qemu.guest_agent.0\"",
            "        qga.source_path = (\"/var/lib/libvirt/qemu/%s.%s.sock\" %",
            "                          (\"org.qemu.guest_agent.0\", instance.name))",
            "        guest.add_device(qga)",
            "",
            "    def _add_rng_device(self, guest, flavor):",
            "        rng_device = vconfig.LibvirtConfigGuestRng()",
            "        rate_bytes = flavor.extra_specs.get('hw_rng:rate_bytes', 0)",
            "        period = flavor.extra_specs.get('hw_rng:rate_period', 0)",
            "        if rate_bytes:",
            "            rng_device.rate_bytes = int(rate_bytes)",
            "            rng_device.rate_period = int(period)",
            "        rng_path = CONF.libvirt.rng_dev_path",
            "        if (rng_path and not os.path.exists(rng_path)):",
            "            raise exception.RngDeviceNotExist(path=rng_path)",
            "        rng_device.backend = rng_path",
            "        guest.add_device(rng_device)",
            "",
            "    def _set_qemu_guest_agent(self, guest, flavor, instance, image_meta):",
            "        # Enable qga only if the 'hw_qemu_guest_agent' is equal to yes",
            "        if image_meta.properties.get('hw_qemu_guest_agent', False):",
            "            LOG.debug(\"Qemu guest agent is enabled through image \"",
            "                      \"metadata\", instance=instance)",
            "            self._add_qga_device(guest, instance)",
            "        rng_is_virtio = image_meta.properties.get('hw_rng_model') == 'virtio'",
            "        rng_allowed_str = flavor.extra_specs.get('hw_rng:allowed', '')",
            "        rng_allowed = strutils.bool_from_string(rng_allowed_str)",
            "        if rng_is_virtio and rng_allowed:",
            "            self._add_rng_device(guest, flavor)",
            "",
            "    def _get_guest_memory_backing_config(",
            "            self, inst_topology, numatune, flavor):",
            "        wantsmempages = False",
            "        if inst_topology:",
            "            for cell in inst_topology.cells:",
            "                if cell.pagesize:",
            "                    wantsmempages = True",
            "                    break",
            "",
            "        wantsrealtime = hardware.is_realtime_enabled(flavor)",
            "",
            "        membacking = None",
            "        if wantsmempages:",
            "            pages = self._get_memory_backing_hugepages_support(",
            "                inst_topology, numatune)",
            "            if pages:",
            "                membacking = vconfig.LibvirtConfigGuestMemoryBacking()",
            "                membacking.hugepages = pages",
            "        if wantsrealtime:",
            "            if not membacking:",
            "                membacking = vconfig.LibvirtConfigGuestMemoryBacking()",
            "            membacking.locked = True",
            "            membacking.sharedpages = False",
            "",
            "        return membacking",
            "",
            "    def _get_memory_backing_hugepages_support(self, inst_topology, numatune):",
            "        if not self._has_hugepage_support():",
            "            # We should not get here, since we should have avoided",
            "            # reporting NUMA topology from _get_host_numa_topology",
            "            # in the first place. Just in case of a scheduler",
            "            # mess up though, raise an exception",
            "            raise exception.MemoryPagesUnsupported()",
            "",
            "        host_topology = self._get_host_numa_topology()",
            "",
            "        if host_topology is None:",
            "            # As above, we should not get here but just in case...",
            "            raise exception.MemoryPagesUnsupported()",
            "",
            "        # Currently libvirt does not support the smallest",
            "        # pagesize set as a backend memory.",
            "        # https://bugzilla.redhat.com/show_bug.cgi?id=1173507",
            "        avail_pagesize = [page.size_kb",
            "                          for page in host_topology.cells[0].mempages]",
            "        avail_pagesize.sort()",
            "        smallest = avail_pagesize[0]",
            "",
            "        pages = []",
            "        for guest_cellid, inst_cell in enumerate(inst_topology.cells):",
            "            if inst_cell.pagesize and inst_cell.pagesize > smallest:",
            "                for memnode in numatune.memnodes:",
            "                    if guest_cellid == memnode.cellid:",
            "                        page = (",
            "                            vconfig.LibvirtConfigGuestMemoryBackingPage())",
            "                        page.nodeset = [guest_cellid]",
            "                        page.size_kb = inst_cell.pagesize",
            "                        pages.append(page)",
            "                        break  # Quit early...",
            "        return pages",
            "",
            "    def _get_flavor(self, ctxt, instance, flavor):",
            "        if flavor is not None:",
            "            return flavor",
            "        return instance.flavor",
            "",
            "    def _has_uefi_support(self):",
            "        # This means that the host can support uefi booting for guests",
            "        supported_archs = [arch.X86_64, arch.AARCH64]",
            "        caps = self._host.get_capabilities()",
            "        return ((caps.host.cpu.arch in supported_archs) and",
            "                self._host.has_min_version(MIN_LIBVIRT_UEFI_VERSION) and",
            "                os.path.exists(DEFAULT_UEFI_LOADER_PATH[caps.host.cpu.arch]))",
            "",
            "    def _configure_guest_by_virt_type(self, guest, virt_type, caps, instance,",
            "                                      image_meta, flavor, root_device_name):",
            "        if virt_type == \"xen\":",
            "            if guest.os_type == vm_mode.HVM:",
            "                guest.os_loader = CONF.libvirt.xen_hvmloader_path",
            "        elif virt_type in (\"kvm\", \"qemu\"):",
            "            if caps.host.cpu.arch in (arch.I686, arch.X86_64):",
            "                guest.sysinfo = self._get_guest_config_sysinfo(instance)",
            "                guest.os_smbios = vconfig.LibvirtConfigGuestSMBIOS()",
            "            hw_firmware_type = image_meta.properties.get('hw_firmware_type')",
            "            if hw_firmware_type == fields.FirmwareType.UEFI:",
            "                if self._has_uefi_support():",
            "                    global uefi_logged",
            "                    if not uefi_logged:",
            "                        LOG.warn(_LW(\"uefi support is without some kind of \"",
            "                                     \"functional testing and therefore \"",
            "                                     \"considered experimental.\"))",
            "                        uefi_logged = True",
            "                    guest.os_loader = DEFAULT_UEFI_LOADER_PATH[",
            "                        caps.host.cpu.arch]",
            "                    guest.os_loader_type = \"pflash\"",
            "                else:",
            "                    raise exception.UEFINotSupported()",
            "            guest.os_mach_type = self._get_machine_type(image_meta, caps)",
            "            if image_meta.properties.get('hw_boot_menu') is None:",
            "                guest.os_bootmenu = strutils.bool_from_string(",
            "                    flavor.extra_specs.get('hw:boot_menu', 'no'))",
            "            else:",
            "                guest.os_bootmenu = image_meta.properties.hw_boot_menu",
            "",
            "        elif virt_type == \"lxc\":",
            "            guest.os_init_path = \"/sbin/init\"",
            "            guest.os_cmdline = CONSOLE",
            "        elif virt_type == \"uml\":",
            "            guest.os_kernel = \"/usr/bin/linux\"",
            "            guest.os_root = root_device_name",
            "        elif virt_type == \"parallels\":",
            "            if guest.os_type == vm_mode.EXE:",
            "                guest.os_init_path = \"/sbin/init\"",
            "",
            "    def _conf_non_lxc_uml(self, virt_type, guest, root_device_name, rescue,",
            "                    instance, inst_path, image_meta, disk_info):",
            "        if rescue:",
            "            self._set_guest_for_rescue(rescue, guest, inst_path, virt_type,",
            "                                       root_device_name)",
            "        elif instance.kernel_id:",
            "            self._set_guest_for_inst_kernel(instance, guest, inst_path,",
            "                                            virt_type, root_device_name,",
            "                                            image_meta)",
            "        else:",
            "            guest.os_boot_dev = blockinfo.get_boot_order(disk_info)",
            "",
            "    def _create_consoles(self, virt_type, guest, instance, flavor, image_meta,",
            "                         caps):",
            "        if virt_type in (\"qemu\", \"kvm\"):",
            "            # Create the serial console char devices",
            "            self._create_serial_console_devices(guest, instance, flavor,",
            "                                                image_meta)",
            "            if caps.host.cpu.arch in (arch.S390, arch.S390X):",
            "                consolepty = vconfig.LibvirtConfigGuestConsole()",
            "                consolepty.target_type = \"sclp\"",
            "            else:",
            "                consolepty = vconfig.LibvirtConfigGuestSerial()",
            "        else:",
            "            consolepty = vconfig.LibvirtConfigGuestConsole()",
            "        return consolepty",
            "",
            "    def _cpu_config_to_vcpu_model(self, cpu_config, vcpu_model):",
            "        \"\"\"Update VirtCPUModel object according to libvirt CPU config.",
            "",
            "        :param:cpu_config: vconfig.LibvirtConfigGuestCPU presenting the",
            "                           instance's virtual cpu configuration.",
            "        :param:vcpu_model: VirtCPUModel object. A new object will be created",
            "                           if None.",
            "",
            "        :return: Updated VirtCPUModel object, or None if cpu_config is None",
            "",
            "        \"\"\"",
            "",
            "        if not cpu_config:",
            "            return",
            "        if not vcpu_model:",
            "            vcpu_model = objects.VirtCPUModel()",
            "",
            "        vcpu_model.arch = cpu_config.arch",
            "        vcpu_model.vendor = cpu_config.vendor",
            "        vcpu_model.model = cpu_config.model",
            "        vcpu_model.mode = cpu_config.mode",
            "        vcpu_model.match = cpu_config.match",
            "",
            "        if cpu_config.sockets:",
            "            vcpu_model.topology = objects.VirtCPUTopology(",
            "                sockets=cpu_config.sockets,",
            "                cores=cpu_config.cores,",
            "                threads=cpu_config.threads)",
            "        else:",
            "            vcpu_model.topology = None",
            "",
            "        features = [objects.VirtCPUFeature(",
            "            name=f.name,",
            "            policy=f.policy) for f in cpu_config.features]",
            "        vcpu_model.features = features",
            "",
            "        return vcpu_model",
            "",
            "    def _vcpu_model_to_cpu_config(self, vcpu_model):",
            "        \"\"\"Create libvirt CPU config according to VirtCPUModel object.",
            "",
            "        :param:vcpu_model: VirtCPUModel object.",
            "",
            "        :return: vconfig.LibvirtConfigGuestCPU.",
            "",
            "        \"\"\"",
            "",
            "        cpu_config = vconfig.LibvirtConfigGuestCPU()",
            "        cpu_config.arch = vcpu_model.arch",
            "        cpu_config.model = vcpu_model.model",
            "        cpu_config.mode = vcpu_model.mode",
            "        cpu_config.match = vcpu_model.match",
            "        cpu_config.vendor = vcpu_model.vendor",
            "        if vcpu_model.topology:",
            "            cpu_config.sockets = vcpu_model.topology.sockets",
            "            cpu_config.cores = vcpu_model.topology.cores",
            "            cpu_config.threads = vcpu_model.topology.threads",
            "        if vcpu_model.features:",
            "            for f in vcpu_model.features:",
            "                xf = vconfig.LibvirtConfigGuestCPUFeature()",
            "                xf.name = f.name",
            "                xf.policy = f.policy",
            "                cpu_config.features.add(xf)",
            "        return cpu_config",
            "",
            "    def _get_guest_config(self, instance, network_info, image_meta,",
            "                          disk_info, rescue=None, block_device_info=None,",
            "                          context=None):",
            "        \"\"\"Get config data for parameters.",
            "",
            "        :param rescue: optional dictionary that should contain the key",
            "            'ramdisk_id' if a ramdisk is needed for the rescue image and",
            "            'kernel_id' if a kernel is needed for the rescue image.",
            "        \"\"\"",
            "        flavor = instance.flavor",
            "        inst_path = libvirt_utils.get_instance_path(instance)",
            "        disk_mapping = disk_info['mapping']",
            "",
            "        virt_type = CONF.libvirt.virt_type",
            "        guest = vconfig.LibvirtConfigGuest()",
            "        guest.virt_type = virt_type",
            "        guest.name = instance.name",
            "        guest.uuid = instance.uuid",
            "        # We are using default unit for memory: KiB",
            "        guest.memory = flavor.memory_mb * units.Ki",
            "        guest.vcpus = flavor.vcpus",
            "        allowed_cpus = hardware.get_vcpu_pin_set()",
            "        pci_devs = pci_manager.get_instance_pci_devs(instance, 'all')",
            "",
            "        guest_numa_config = self._get_guest_numa_config(",
            "            instance.numa_topology, flavor, pci_devs, allowed_cpus, image_meta)",
            "",
            "        guest.cpuset = guest_numa_config.cpuset",
            "        guest.cputune = guest_numa_config.cputune",
            "        guest.numatune = guest_numa_config.numatune",
            "",
            "        guest.membacking = self._get_guest_memory_backing_config(",
            "            instance.numa_topology,",
            "            guest_numa_config.numatune,",
            "            flavor)",
            "",
            "        guest.metadata.append(self._get_guest_config_meta(context,",
            "                                                          instance))",
            "        guest.idmaps = self._get_guest_idmaps()",
            "",
            "        self._update_guest_cputune(guest, flavor, virt_type)",
            "",
            "        guest.cpu = self._get_guest_cpu_config(",
            "            flavor, image_meta, guest_numa_config.numaconfig,",
            "            instance.numa_topology)",
            "",
            "        # Notes(yjiang5): we always sync the instance's vcpu model with",
            "        # the corresponding config file.",
            "        instance.vcpu_model = self._cpu_config_to_vcpu_model(",
            "            guest.cpu, instance.vcpu_model)",
            "",
            "        if 'root' in disk_mapping:",
            "            root_device_name = block_device.prepend_dev(",
            "                disk_mapping['root']['dev'])",
            "        else:",
            "            root_device_name = None",
            "",
            "        if root_device_name:",
            "            # NOTE(yamahata):",
            "            # for nova.api.ec2.cloud.CloudController.get_metadata()",
            "            instance.root_device_name = root_device_name",
            "",
            "        guest.os_type = (vm_mode.get_from_instance(instance) or",
            "                self._get_guest_os_type(virt_type))",
            "        caps = self._host.get_capabilities()",
            "",
            "        self._configure_guest_by_virt_type(guest, virt_type, caps, instance,",
            "                                           image_meta, flavor,",
            "                                           root_device_name)",
            "        if virt_type not in ('lxc', 'uml'):",
            "            self._conf_non_lxc_uml(virt_type, guest, root_device_name, rescue,",
            "                    instance, inst_path, image_meta, disk_info)",
            "",
            "        self._set_features(guest, instance.os_type, caps, virt_type)",
            "        self._set_clock(guest, instance.os_type, image_meta, virt_type)",
            "",
            "        storage_configs = self._get_guest_storage_config(",
            "                instance, image_meta, disk_info, rescue, block_device_info,",
            "                flavor, guest.os_type)",
            "        for config in storage_configs:",
            "            guest.add_device(config)",
            "",
            "        for vif in network_info:",
            "            config = self.vif_driver.get_config(",
            "                instance, vif, image_meta,",
            "                flavor, virt_type, self._host)",
            "            guest.add_device(config)",
            "",
            "        consolepty = self._create_consoles(virt_type, guest, instance, flavor,",
            "                                           image_meta, caps)",
            "        if virt_type != 'parallels':",
            "            consolepty.type = \"pty\"",
            "            guest.add_device(consolepty)",
            "",
            "        tablet = self._get_guest_usb_tablet(guest.os_type)",
            "        if tablet:",
            "            guest.add_device(tablet)",
            "",
            "        if (CONF.spice.enabled and CONF.spice.agent_enabled and",
            "                virt_type not in ('lxc', 'uml', 'xen')):",
            "            channel = vconfig.LibvirtConfigGuestChannel()",
            "            channel.target_name = \"com.redhat.spice.0\"",
            "            guest.add_device(channel)",
            "",
            "        # NB some versions of libvirt support both SPICE and VNC",
            "        # at the same time. We're not trying to second guess which",
            "        # those versions are. We'll just let libvirt report the",
            "        # errors appropriately if the user enables both.",
            "        add_video_driver = False",
            "        if ((CONF.vnc.enabled and",
            "             virt_type not in ('lxc', 'uml'))):",
            "            graphics = vconfig.LibvirtConfigGuestGraphics()",
            "            graphics.type = \"vnc\"",
            "            graphics.keymap = CONF.vnc.keymap",
            "            graphics.listen = CONF.vnc.vncserver_listen",
            "            guest.add_device(graphics)",
            "            add_video_driver = True",
            "",
            "        if (CONF.spice.enabled and",
            "                virt_type not in ('lxc', 'uml', 'xen')):",
            "            graphics = vconfig.LibvirtConfigGuestGraphics()",
            "            graphics.type = \"spice\"",
            "            graphics.keymap = CONF.spice.keymap",
            "            graphics.listen = CONF.spice.server_listen",
            "            guest.add_device(graphics)",
            "            add_video_driver = True",
            "",
            "        if add_video_driver:",
            "            self._add_video_driver(guest, image_meta, flavor)",
            "",
            "        # Qemu guest agent only support 'qemu' and 'kvm' hypervisor",
            "        if virt_type in ('qemu', 'kvm'):",
            "            self._set_qemu_guest_agent(guest, flavor, instance, image_meta)",
            "",
            "        if virt_type in ('xen', 'qemu', 'kvm'):",
            "            for pci_dev in pci_manager.get_instance_pci_devs(instance):",
            "                guest.add_device(self._get_guest_pci_device(pci_dev))",
            "        else:",
            "            if len(pci_devs) > 0:",
            "                raise exception.PciDeviceUnsupportedHypervisor(",
            "                    type=virt_type)",
            "",
            "        if 'hw_watchdog_action' in flavor.extra_specs:",
            "            LOG.warn(_LW('Old property name \"hw_watchdog_action\" is now '",
            "                         'deprecated and will be removed in the next release. '",
            "                         'Use updated property name '",
            "                         '\"hw:watchdog_action\" instead'), instance=instance)",
            "        # TODO(pkholkin): accepting old property name 'hw_watchdog_action'",
            "        #                should be removed in the next release",
            "        watchdog_action = (flavor.extra_specs.get('hw_watchdog_action') or",
            "                           flavor.extra_specs.get('hw:watchdog_action')",
            "                           or 'disabled')",
            "        watchdog_action = image_meta.properties.get('hw_watchdog_action',",
            "                                                    watchdog_action)",
            "",
            "        # NB(sross): currently only actually supported by KVM/QEmu",
            "        if watchdog_action != 'disabled':",
            "            if watchdog_actions.is_valid_watchdog_action(watchdog_action):",
            "                bark = vconfig.LibvirtConfigGuestWatchdog()",
            "                bark.action = watchdog_action",
            "                guest.add_device(bark)",
            "            else:",
            "                raise exception.InvalidWatchdogAction(action=watchdog_action)",
            "",
            "        # Memory balloon device only support 'qemu/kvm' and 'xen' hypervisor",
            "        if (virt_type in ('xen', 'qemu', 'kvm') and",
            "                CONF.libvirt.mem_stats_period_seconds > 0):",
            "            balloon = vconfig.LibvirtConfigMemoryBalloon()",
            "            if virt_type in ('qemu', 'kvm'):",
            "                balloon.model = 'virtio'",
            "            else:",
            "                balloon.model = 'xen'",
            "            balloon.period = CONF.libvirt.mem_stats_period_seconds",
            "            guest.add_device(balloon)",
            "",
            "        return guest",
            "",
            "    def _get_guest_usb_tablet(self, os_type):",
            "        # We want a tablet if VNC is enabled, or SPICE is enabled and",
            "        # the SPICE agent is disabled. If the SPICE agent is enabled",
            "        # it provides a paravirt mouse which drastically reduces",
            "        # overhead (by eliminating USB polling).",
            "        #",
            "        # NB: this implies that if both SPICE + VNC are enabled",
            "        # at the same time, we'll get the tablet whether the",
            "        # SPICE agent is used or not.",
            "        need_usb_tablet = False",
            "        if CONF.vnc.enabled:",
            "            need_usb_tablet = CONF.libvirt.use_usb_tablet",
            "        elif CONF.spice.enabled and not CONF.spice.agent_enabled:",
            "            need_usb_tablet = CONF.libvirt.use_usb_tablet",
            "",
            "        tablet = None",
            "        if need_usb_tablet and os_type == vm_mode.HVM:",
            "            tablet = vconfig.LibvirtConfigGuestInput()",
            "            tablet.type = \"tablet\"",
            "            tablet.bus = \"usb\"",
            "        return tablet",
            "",
            "    def _get_guest_xml(self, context, instance, network_info, disk_info,",
            "                       image_meta, rescue=None,",
            "                       block_device_info=None, write_to_disk=False):",
            "        # NOTE(danms): Stringifying a NetworkInfo will take a lock. Do",
            "        # this ahead of time so that we don't acquire it while also",
            "        # holding the logging lock.",
            "        network_info_str = str(network_info)",
            "        msg = ('Start _get_guest_xml '",
            "               'network_info=%(network_info)s '",
            "               'disk_info=%(disk_info)s '",
            "               'image_meta=%(image_meta)s rescue=%(rescue)s '",
            "               'block_device_info=%(block_device_info)s' %",
            "               {'network_info': network_info_str, 'disk_info': disk_info,",
            "                'image_meta': image_meta, 'rescue': rescue,",
            "                'block_device_info': block_device_info})",
            "        # NOTE(mriedem): block_device_info can contain auth_password so we",
            "        # need to sanitize the password in the message.",
            "        LOG.debug(strutils.mask_password(msg), instance=instance)",
            "        conf = self._get_guest_config(instance, network_info, image_meta,",
            "                                      disk_info, rescue, block_device_info,",
            "                                      context)",
            "        xml = conf.to_xml()",
            "",
            "        if write_to_disk:",
            "            instance_dir = libvirt_utils.get_instance_path(instance)",
            "            xml_path = os.path.join(instance_dir, 'libvirt.xml')",
            "            libvirt_utils.write_to_file(xml_path, xml)",
            "",
            "        LOG.debug('End _get_guest_xml xml=%(xml)s',",
            "                  {'xml': xml}, instance=instance)",
            "        return xml",
            "",
            "    def get_info(self, instance):",
            "        \"\"\"Retrieve information from libvirt for a specific instance name.",
            "",
            "        If a libvirt error is encountered during lookup, we might raise a",
            "        NotFound exception or Error exception depending on how severe the",
            "        libvirt error is.",
            "",
            "        \"\"\"",
            "        guest = self._host.get_guest(instance)",
            "        # Kind of ugly but we need to pass host to get_info as for a",
            "        # workaround, see libvirt/compat.py",
            "        return guest.get_info(self._host)",
            "",
            "    def _create_domain_setup_lxc(self, instance, image_meta,",
            "                                 block_device_info, disk_info):",
            "        inst_path = libvirt_utils.get_instance_path(instance)",
            "        disk_info = disk_info or {}",
            "        disk_mapping = disk_info.get('mapping', {})",
            "",
            "        if self._is_booted_from_volume(instance, disk_mapping):",
            "            block_device_mapping = driver.block_device_info_get_mapping(",
            "                                                            block_device_info)",
            "            root_disk = block_device.get_root_bdm(block_device_mapping)",
            "            disk_info = blockinfo.get_info_from_bdm(",
            "                instance, CONF.libvirt.virt_type, image_meta, root_disk)",
            "            self._connect_volume(root_disk['connection_info'], disk_info)",
            "            disk_path = root_disk['connection_info']['data']['device_path']",
            "",
            "            # NOTE(apmelton) - Even though the instance is being booted from a",
            "            # cinder volume, it is still presented as a local block device.",
            "            # LocalBlockImage is used here to indicate that the instance's",
            "            # disk is backed by a local block device.",
            "            image_model = imgmodel.LocalBlockImage(disk_path)",
            "        else:",
            "            image = self.image_backend.image(instance, 'disk')",
            "            image_model = image.get_model(self._conn)",
            "",
            "        container_dir = os.path.join(inst_path, 'rootfs')",
            "        fileutils.ensure_tree(container_dir)",
            "        rootfs_dev = disk.setup_container(image_model,",
            "                                          container_dir=container_dir)",
            "",
            "        try:",
            "            # Save rootfs device to disconnect it when deleting the instance",
            "            if rootfs_dev:",
            "                instance.system_metadata['rootfs_device_name'] = rootfs_dev",
            "            if CONF.libvirt.uid_maps or CONF.libvirt.gid_maps:",
            "                id_maps = self._get_guest_idmaps()",
            "                libvirt_utils.chown_for_id_maps(container_dir, id_maps)",
            "        except Exception:",
            "            with excutils.save_and_reraise_exception():",
            "                self._create_domain_cleanup_lxc(instance)",
            "",
            "    def _create_domain_cleanup_lxc(self, instance):",
            "        inst_path = libvirt_utils.get_instance_path(instance)",
            "        container_dir = os.path.join(inst_path, 'rootfs')",
            "",
            "        try:",
            "            state = self.get_info(instance).state",
            "        except exception.InstanceNotFound:",
            "            # The domain may not be present if the instance failed to start",
            "            state = None",
            "",
            "        if state == power_state.RUNNING:",
            "            # NOTE(uni): Now the container is running with its own private",
            "            # mount namespace and so there is no need to keep the container",
            "            # rootfs mounted in the host namespace",
            "            LOG.debug('Attempting to unmount container filesystem: %s',",
            "                      container_dir, instance=instance)",
            "            disk.clean_lxc_namespace(container_dir=container_dir)",
            "        else:",
            "            disk.teardown_container(container_dir=container_dir)",
            "",
            "    @contextlib.contextmanager",
            "    def _lxc_disk_handler(self, instance, image_meta,",
            "                          block_device_info, disk_info):",
            "        \"\"\"Context manager to handle the pre and post instance boot,",
            "           LXC specific disk operations.",
            "",
            "           An image or a volume path will be prepared and setup to be",
            "           used by the container, prior to starting it.",
            "           The disk will be disconnected and unmounted if a container has",
            "           failed to start.",
            "        \"\"\"",
            "",
            "        if CONF.libvirt.virt_type != 'lxc':",
            "            yield",
            "            return",
            "",
            "        self._create_domain_setup_lxc(instance, image_meta,",
            "                                      block_device_info, disk_info)",
            "",
            "        try:",
            "            yield",
            "        finally:",
            "            self._create_domain_cleanup_lxc(instance)",
            "",
            "    # TODO(sahid): Consider renaming this to _create_guest.",
            "    def _create_domain(self, xml=None, domain=None,",
            "                       power_on=True, pause=False):",
            "        \"\"\"Create a domain.",
            "",
            "        Either domain or xml must be passed in. If both are passed, then",
            "        the domain definition is overwritten from the xml.",
            "",
            "        :returns guest.Guest: Guest just created",
            "        \"\"\"",
            "        if xml:",
            "            guest = libvirt_guest.Guest.create(xml, self._host)",
            "        else:",
            "            guest = libvirt_guest.Guest(domain)",
            "",
            "        if power_on or pause:",
            "            guest.launch(pause=pause)",
            "",
            "        if not utils.is_neutron():",
            "            guest.enable_hairpin()",
            "",
            "        return guest",
            "",
            "    def _neutron_failed_callback(self, event_name, instance):",
            "        LOG.error(_LE('Neutron Reported failure on event '",
            "                      '%(event)s for instance %(uuid)s'),",
            "                  {'event': event_name, 'uuid': instance.uuid},",
            "                  instance=instance)",
            "        if CONF.vif_plugging_is_fatal:",
            "            raise exception.VirtualInterfaceCreateException()",
            "",
            "    def _get_neutron_events(self, network_info):",
            "        # NOTE(danms): We need to collect any VIFs that are currently",
            "        # down that we expect a down->up event for. Anything that is",
            "        # already up will not undergo that transition, and for",
            "        # anything that might be stale (cache-wise) assume it's",
            "        # already up so we don't block on it.",
            "        return [('network-vif-plugged', vif['id'])",
            "                for vif in network_info if vif.get('active', True) is False]",
            "",
            "    def _create_domain_and_network(self, context, xml, instance, network_info,",
            "                                   disk_info, block_device_info=None,",
            "                                   power_on=True, reboot=False,",
            "                                   vifs_already_plugged=False):",
            "",
            "        \"\"\"Do required network setup and create domain.\"\"\"",
            "        block_device_mapping = driver.block_device_info_get_mapping(",
            "            block_device_info)",
            "",
            "        for vol in block_device_mapping:",
            "            connection_info = vol['connection_info']",
            "",
            "            if (not reboot and 'data' in connection_info and",
            "                    'volume_id' in connection_info['data']):",
            "                volume_id = connection_info['data']['volume_id']",
            "                encryption = encryptors.get_encryption_metadata(",
            "                    context, self._volume_api, volume_id, connection_info)",
            "",
            "                if encryption:",
            "                    encryptor = self._get_volume_encryptor(connection_info,",
            "                                                           encryption)",
            "                    encryptor.attach_volume(context, **encryption)",
            "",
            "        timeout = CONF.vif_plugging_timeout",
            "        if (self._conn_supports_start_paused and",
            "            utils.is_neutron() and not",
            "            vifs_already_plugged and power_on and timeout):",
            "            events = self._get_neutron_events(network_info)",
            "        else:",
            "            events = []",
            "",
            "        pause = bool(events)",
            "        guest = None",
            "        try:",
            "            with self.virtapi.wait_for_instance_event(",
            "                    instance, events, deadline=timeout,",
            "                    error_callback=self._neutron_failed_callback):",
            "                self.plug_vifs(instance, network_info)",
            "                self.firewall_driver.setup_basic_filtering(instance,",
            "                                                           network_info)",
            "                self.firewall_driver.prepare_instance_filter(instance,",
            "                                                             network_info)",
            "                with self._lxc_disk_handler(instance, instance.image_meta,",
            "                                            block_device_info, disk_info):",
            "                    guest = self._create_domain(",
            "                        xml, pause=pause, power_on=power_on)",
            "",
            "                self.firewall_driver.apply_instance_filter(instance,",
            "                                                           network_info)",
            "        except exception.VirtualInterfaceCreateException:",
            "            # Neutron reported failure and we didn't swallow it, so",
            "            # bail here",
            "            with excutils.save_and_reraise_exception():",
            "                if guest:",
            "                    guest.poweroff()",
            "                self.cleanup(context, instance, network_info=network_info,",
            "                             block_device_info=block_device_info)",
            "        except eventlet.timeout.Timeout:",
            "            # We never heard from Neutron",
            "            LOG.warn(_LW('Timeout waiting for vif plugging callback for '",
            "                         'instance %(uuid)s'), {'uuid': instance.uuid},",
            "                     instance=instance)",
            "            if CONF.vif_plugging_is_fatal:",
            "                if guest:",
            "                    guest.poweroff()",
            "                self.cleanup(context, instance, network_info=network_info,",
            "                             block_device_info=block_device_info)",
            "                raise exception.VirtualInterfaceCreateException()",
            "",
            "        # Resume only if domain has been paused",
            "        if pause:",
            "            guest.resume()",
            "        return guest",
            "",
            "    def _get_all_block_devices(self):",
            "        \"\"\"Return all block devices in use on this node.\"\"\"",
            "        devices = []",
            "        for guest in self._host.list_guests():",
            "            try:",
            "                doc = etree.fromstring(guest.get_xml_desc())",
            "            except libvirt.libvirtError as e:",
            "                LOG.warn(_LW(\"couldn't obtain the XML from domain:\"",
            "                             \" %(uuid)s, exception: %(ex)s\") %",
            "                         {\"uuid\": guest.id, \"ex\": e})",
            "                continue",
            "            except Exception:",
            "                continue",
            "            sources = doc.findall(\"./devices/disk[@type='block']/source\")",
            "            for source in sources:",
            "                devices.append(source.get('dev'))",
            "        return devices",
            "",
            "    def _get_interfaces(self, xml):",
            "        \"\"\"Note that this function takes a domain xml.",
            "",
            "        Returns a list of all network interfaces for this instance.",
            "        \"\"\"",
            "        doc = None",
            "",
            "        try:",
            "            doc = etree.fromstring(xml)",
            "        except Exception:",
            "            return []",
            "",
            "        interfaces = []",
            "",
            "        nodes = doc.findall('./devices/interface/target')",
            "        for target in nodes:",
            "            interfaces.append(target.get('dev'))",
            "",
            "        return interfaces",
            "",
            "    def _get_vcpu_total(self):",
            "        \"\"\"Get available vcpu number of physical computer.",
            "",
            "        :returns: the number of cpu core instances can be used.",
            "",
            "        \"\"\"",
            "        try:",
            "            total_pcpus = self._host.get_cpu_count()",
            "        except libvirt.libvirtError:",
            "            LOG.warn(_LW(\"Cannot get the number of cpu, because this \"",
            "                         \"function is not implemented for this platform. \"))",
            "            return 0",
            "",
            "        if CONF.vcpu_pin_set is None:",
            "            return total_pcpus",
            "",
            "        available_ids = hardware.get_vcpu_pin_set()",
            "        # We get the list of online CPUs on the host and see if the requested",
            "        # set falls under these. If not, we retain the old behavior.",
            "        online_pcpus = None",
            "        try:",
            "            online_pcpus = self._host.get_online_cpus()",
            "        except libvirt.libvirtError as ex:",
            "            error_code = ex.get_error_code()",
            "            LOG.warn(_LW(\"Couldn't retrieve the online CPUs due to a Libvirt \"",
            "                         \"error: %(error)s with error code: %(error_code)s\"),",
            "                     {'error': ex, 'error_code': error_code})",
            "        if online_pcpus:",
            "            if not (available_ids <= online_pcpus):",
            "                msg = (_(\"Invalid vcpu_pin_set config, one or more of the \"",
            "                         \"specified cpuset is not online. Online cpuset(s): \"",
            "                         \"%(online)s, requested cpuset(s): %(req)s\"),",
            "                       {'online': sorted(online_pcpus),",
            "                        'req': sorted(available_ids)})",
            "                raise exception.Invalid(msg)",
            "        elif sorted(available_ids)[-1] >= total_pcpus:",
            "            raise exception.Invalid(_(\"Invalid vcpu_pin_set config, \"",
            "                                      \"out of hypervisor cpu range.\"))",
            "        return len(available_ids)",
            "",
            "    @staticmethod",
            "    def _get_local_gb_info():",
            "        \"\"\"Get local storage info of the compute node in GB.",
            "",
            "        :returns: A dict containing:",
            "             :total: How big the overall usable filesystem is (in gigabytes)",
            "             :free: How much space is free (in gigabytes)",
            "             :used: How much space is used (in gigabytes)",
            "        \"\"\"",
            "",
            "        if CONF.libvirt.images_type == 'lvm':",
            "            info = lvm.get_volume_group_info(",
            "                               CONF.libvirt.images_volume_group)",
            "        elif CONF.libvirt.images_type == 'rbd':",
            "            info = LibvirtDriver._get_rbd_driver().get_pool_info()",
            "        else:",
            "            info = libvirt_utils.get_fs_info(CONF.instances_path)",
            "",
            "        for (k, v) in six.iteritems(info):",
            "            info[k] = v / units.Gi",
            "",
            "        return info",
            "",
            "    def _get_vcpu_used(self):",
            "        \"\"\"Get vcpu usage number of physical computer.",
            "",
            "        :returns: The total number of vcpu(s) that are currently being used.",
            "",
            "        \"\"\"",
            "",
            "        total = 0",
            "        if CONF.libvirt.virt_type == 'lxc':",
            "            return total + 1",
            "",
            "        for guest in self._host.list_guests():",
            "            try:",
            "                vcpus = guest.get_vcpus_info()",
            "                if vcpus is not None:",
            "                    total += len(list(vcpus))",
            "            except libvirt.libvirtError as e:",
            "                LOG.warn(_LW(\"couldn't obtain the vcpu count from domain id:\"",
            "                             \" %(uuid)s, exception: %(ex)s\"),",
            "                         {\"uuid\": guest.uuid, \"ex\": e})",
            "            # NOTE(gtt116): give other tasks a chance.",
            "            greenthread.sleep(0)",
            "        return total",
            "",
            "    def _get_instance_capabilities(self):",
            "        \"\"\"Get hypervisor instance capabilities",
            "",
            "        Returns a list of tuples that describe instances the",
            "        hypervisor is capable of hosting.  Each tuple consists",
            "        of the triplet (arch, hypervisor_type, vm_mode).",
            "",
            "        :returns: List of tuples describing instance capabilities",
            "        \"\"\"",
            "        caps = self._host.get_capabilities()",
            "        instance_caps = list()",
            "        for g in caps.guests:",
            "            for dt in g.domtype:",
            "                instance_cap = (",
            "                    arch.canonicalize(g.arch),",
            "                    hv_type.canonicalize(dt),",
            "                    vm_mode.canonicalize(g.ostype))",
            "                instance_caps.append(instance_cap)",
            "",
            "        return instance_caps",
            "",
            "    def _get_cpu_info(self):",
            "        \"\"\"Get cpuinfo information.",
            "",
            "        Obtains cpu feature from virConnect.getCapabilities.",
            "",
            "        :return: see above description",
            "",
            "        \"\"\"",
            "",
            "        caps = self._host.get_capabilities()",
            "        cpu_info = dict()",
            "",
            "        cpu_info['arch'] = caps.host.cpu.arch",
            "        cpu_info['model'] = caps.host.cpu.model",
            "        cpu_info['vendor'] = caps.host.cpu.vendor",
            "",
            "        topology = dict()",
            "        topology['cells'] = len(getattr(caps.host.topology, 'cells', [1]))",
            "        topology['sockets'] = caps.host.cpu.sockets",
            "        topology['cores'] = caps.host.cpu.cores",
            "        topology['threads'] = caps.host.cpu.threads",
            "        cpu_info['topology'] = topology",
            "",
            "        features = set()",
            "        for f in caps.host.cpu.features:",
            "            features.add(f.name)",
            "        cpu_info['features'] = features",
            "        return cpu_info",
            "",
            "    def _get_pcidev_info(self, devname):",
            "        \"\"\"Returns a dict of PCI device.\"\"\"",
            "",
            "        def _get_device_type(cfgdev, pci_address):",
            "            \"\"\"Get a PCI device's device type.",
            "",
            "            An assignable PCI device can be a normal PCI device,",
            "            a SR-IOV Physical Function (PF), or a SR-IOV Virtual",
            "            Function (VF). Only normal PCI devices or SR-IOV VFs",
            "            are assignable, while SR-IOV PFs are always owned by",
            "            hypervisor.",
            "            \"\"\"",
            "            for fun_cap in cfgdev.pci_capability.fun_capability:",
            "                if fun_cap.type == 'virt_functions':",
            "                    return {",
            "                        'dev_type': fields.PciDeviceType.SRIOV_PF,",
            "                    }",
            "                if (fun_cap.type == 'phys_function' and",
            "                    len(fun_cap.device_addrs) != 0):",
            "                    phys_address = \"%04x:%02x:%02x.%01x\" % (",
            "                        fun_cap.device_addrs[0][0],",
            "                        fun_cap.device_addrs[0][1],",
            "                        fun_cap.device_addrs[0][2],",
            "                        fun_cap.device_addrs[0][3])",
            "                    return {",
            "                        'dev_type': fields.PciDeviceType.SRIOV_VF,",
            "                        'parent_addr': phys_address,",
            "                    }",
            "",
            "            # Note(moshele): libvirt < 1.3 reported virt_functions capability",
            "            # only when VFs are enabled. The check below is a workaround",
            "            # to get the correct report regardless of whether or not any",
            "            # VFs are enabled for the device.",
            "            if not self._host.has_min_version(",
            "                MIN_LIBVIRT_PF_WITH_NO_VFS_CAP_VERSION):",
            "                is_physical_function = pci_utils.is_physical_function(",
            "                    *pci_utils.get_pci_address_fields(pci_address))",
            "                if is_physical_function:",
            "                    return {'dev_type': fields.PciDeviceType.SRIOV_PF}",
            "",
            "            return {'dev_type': fields.PciDeviceType.STANDARD}",
            "",
            "        virtdev = self._host.device_lookup_by_name(devname)",
            "        xmlstr = virtdev.XMLDesc(0)",
            "        cfgdev = vconfig.LibvirtConfigNodeDevice()",
            "        cfgdev.parse_str(xmlstr)",
            "",
            "        address = \"%04x:%02x:%02x.%1x\" % (",
            "            cfgdev.pci_capability.domain,",
            "            cfgdev.pci_capability.bus,",
            "            cfgdev.pci_capability.slot,",
            "            cfgdev.pci_capability.function)",
            "",
            "        device = {",
            "            \"dev_id\": cfgdev.name,",
            "            \"address\": address,",
            "            \"product_id\": \"%04x\" % cfgdev.pci_capability.product_id,",
            "            \"vendor_id\": \"%04x\" % cfgdev.pci_capability.vendor_id,",
            "            }",
            "",
            "        device[\"numa_node\"] = cfgdev.pci_capability.numa_node",
            "",
            "        # requirement by DataBase Model",
            "        device['label'] = 'label_%(vendor_id)s_%(product_id)s' % device",
            "        device.update(_get_device_type(cfgdev, address))",
            "        return device",
            "",
            "    def _get_pci_passthrough_devices(self):",
            "        \"\"\"Get host PCI devices information.",
            "",
            "        Obtains pci devices information from libvirt, and returns",
            "        as a JSON string.",
            "",
            "        Each device information is a dictionary, with mandatory keys",
            "        of 'address', 'vendor_id', 'product_id', 'dev_type', 'dev_id',",
            "        'label' and other optional device specific information.",
            "",
            "        Refer to the objects/pci_device.py for more idea of these keys.",
            "",
            "        :returns: a JSON string containaing a list of the assignable PCI",
            "                  devices information",
            "        \"\"\"",
            "        # Bail early if we know we can't support `listDevices` to avoid",
            "        # repeated warnings within a periodic task",
            "        if not getattr(self, '_list_devices_supported', True):",
            "            return jsonutils.dumps([])",
            "",
            "        try:",
            "            dev_names = self._host.list_pci_devices() or []",
            "        except libvirt.libvirtError as ex:",
            "            error_code = ex.get_error_code()",
            "            if error_code == libvirt.VIR_ERR_NO_SUPPORT:",
            "                self._list_devices_supported = False",
            "                LOG.warn(_LW(\"URI %(uri)s does not support \"",
            "                             \"listDevices: %(error)s\"),",
            "                             {'uri': self._uri(), 'error': ex})",
            "                return jsonutils.dumps([])",
            "            else:",
            "                raise",
            "",
            "        pci_info = []",
            "        for name in dev_names:",
            "            pci_info.append(self._get_pcidev_info(name))",
            "",
            "        return jsonutils.dumps(pci_info)",
            "",
            "    def _has_numa_support(self):",
            "        # This means that the host can support LibvirtConfigGuestNUMATune",
            "        # and the nodeset field in LibvirtConfigGuestMemoryBackingPage",
            "        for ver in BAD_LIBVIRT_NUMA_VERSIONS:",
            "            if self._host.has_version(ver):",
            "                if not getattr(self, '_bad_libvirt_numa_version_warn', False):",
            "                    LOG.warn(_LW('You are running with libvirt version %s '",
            "                                 'which is known to have broken NUMA support. '",
            "                                 'Consider patching or updating libvirt on '",
            "                                 'this host if you need NUMA support.'),",
            "                             self._version_to_string(ver))",
            "                    self._bad_libvirt_numa_version_warn = True",
            "                return False",
            "",
            "        support_matrix = {(arch.I686, arch.X86_64): MIN_LIBVIRT_NUMA_VERSION,",
            "                          (arch.PPC64,",
            "                           arch.PPC64LE): MIN_LIBVIRT_NUMA_VERSION_PPC}",
            "        caps = self._host.get_capabilities()",
            "        is_supported = False",
            "        for archs, libvirt_ver in support_matrix.items():",
            "            if ((caps.host.cpu.arch in archs) and",
            "                    self._host.has_min_version(libvirt_ver,",
            "                                               MIN_QEMU_NUMA_HUGEPAGE_VERSION,",
            "                                               host.HV_DRIVER_QEMU)):",
            "                is_supported = True",
            "        return is_supported",
            "",
            "    def _has_hugepage_support(self):",
            "        # This means that the host can support multiple values for the size",
            "        # field in LibvirtConfigGuestMemoryBackingPage",
            "        supported_archs = [arch.I686, arch.X86_64]",
            "        caps = self._host.get_capabilities()",
            "        return ((caps.host.cpu.arch in supported_archs) and",
            "                self._host.has_min_version(MIN_LIBVIRT_HUGEPAGE_VERSION,",
            "                                           MIN_QEMU_NUMA_HUGEPAGE_VERSION,",
            "                                           host.HV_DRIVER_QEMU))",
            "",
            "    def _get_host_numa_topology(self):",
            "        if not self._has_numa_support():",
            "            return",
            "",
            "        caps = self._host.get_capabilities()",
            "        topology = caps.host.topology",
            "",
            "        if topology is None or not topology.cells:",
            "            return",
            "",
            "        cells = []",
            "        allowed_cpus = hardware.get_vcpu_pin_set()",
            "        online_cpus = self._host.get_online_cpus()",
            "        if allowed_cpus:",
            "            allowed_cpus &= online_cpus",
            "        else:",
            "            allowed_cpus = online_cpus",
            "",
            "        for cell in topology.cells:",
            "            cpuset = set(cpu.id for cpu in cell.cpus)",
            "            siblings = sorted(map(set,",
            "                                  set(tuple(cpu.siblings)",
            "                                        if cpu.siblings else ()",
            "                                      for cpu in cell.cpus)",
            "                                  ))",
            "            cpuset &= allowed_cpus",
            "            siblings = [sib & allowed_cpus for sib in siblings]",
            "            # Filter out singles and empty sibling sets that may be left",
            "            siblings = [sib for sib in siblings if len(sib) > 1]",
            "",
            "            mempages = []",
            "            if self._has_hugepage_support():",
            "                mempages = [",
            "                    objects.NUMAPagesTopology(",
            "                        size_kb=pages.size,",
            "                        total=pages.total,",
            "                        used=0)",
            "                    for pages in cell.mempages]",
            "",
            "            cell = objects.NUMACell(id=cell.id, cpuset=cpuset,",
            "                                    memory=cell.memory / units.Ki,",
            "                                    cpu_usage=0, memory_usage=0,",
            "                                    siblings=siblings,",
            "                                    pinned_cpus=set([]),",
            "                                    mempages=mempages)",
            "            cells.append(cell)",
            "",
            "        return objects.NUMATopology(cells=cells)",
            "",
            "    def get_all_volume_usage(self, context, compute_host_bdms):",
            "        \"\"\"Return usage info for volumes attached to vms on",
            "           a given host.",
            "        \"\"\"",
            "        vol_usage = []",
            "",
            "        for instance_bdms in compute_host_bdms:",
            "            instance = instance_bdms['instance']",
            "",
            "            for bdm in instance_bdms['instance_bdms']:",
            "                mountpoint = bdm['device_name']",
            "                if mountpoint.startswith('/dev/'):",
            "                    mountpoint = mountpoint[5:]",
            "                volume_id = bdm['volume_id']",
            "",
            "                LOG.debug(\"Trying to get stats for the volume %s\",",
            "                          volume_id, instance=instance)",
            "                vol_stats = self.block_stats(instance, mountpoint)",
            "",
            "                if vol_stats:",
            "                    stats = dict(volume=volume_id,",
            "                                 instance=instance,",
            "                                 rd_req=vol_stats[0],",
            "                                 rd_bytes=vol_stats[1],",
            "                                 wr_req=vol_stats[2],",
            "                                 wr_bytes=vol_stats[3])",
            "                    LOG.debug(",
            "                        \"Got volume usage stats for the volume=%(volume)s,\"",
            "                        \" rd_req=%(rd_req)d, rd_bytes=%(rd_bytes)d, \"",
            "                        \"wr_req=%(wr_req)d, wr_bytes=%(wr_bytes)d\",",
            "                        stats, instance=instance)",
            "                    vol_usage.append(stats)",
            "",
            "        return vol_usage",
            "",
            "    def block_stats(self, instance, disk_id):",
            "        \"\"\"Note that this function takes an instance name.\"\"\"",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "",
            "            # TODO(sahid): We are converting all calls from a",
            "            # virDomain object to use nova.virt.libvirt.Guest.",
            "            # We should be able to remove domain at the end.",
            "            domain = guest._domain",
            "            return domain.blockStats(disk_id)",
            "        except libvirt.libvirtError as e:",
            "            errcode = e.get_error_code()",
            "            LOG.info(_LI('Getting block stats failed, device might have '",
            "                         'been detached. Instance=%(instance_name)s '",
            "                         'Disk=%(disk)s Code=%(errcode)s Error=%(e)s'),",
            "                     {'instance_name': instance.name, 'disk': disk_id,",
            "                      'errcode': errcode, 'e': e},",
            "                     instance=instance)",
            "        except exception.InstanceNotFound:",
            "            LOG.info(_LI('Could not find domain in libvirt for instance %s. '",
            "                         'Cannot get block stats for device'), instance.name,",
            "                     instance=instance)",
            "",
            "    def get_console_pool_info(self, console_type):",
            "        # TODO(mdragon): console proxy should be implemented for libvirt,",
            "        #                in case someone wants to use it with kvm or",
            "        #                such. For now return fake data.",
            "        return {'address': '127.0.0.1',",
            "                'username': 'fakeuser',",
            "                'password': 'fakepassword'}",
            "",
            "    def refresh_security_group_rules(self, security_group_id):",
            "        self.firewall_driver.refresh_security_group_rules(security_group_id)",
            "",
            "    def refresh_instance_security_rules(self, instance):",
            "        self.firewall_driver.refresh_instance_security_rules(instance)",
            "",
            "    def get_available_resource(self, nodename):",
            "        \"\"\"Retrieve resource information.",
            "",
            "        This method is called when nova-compute launches, and",
            "        as part of a periodic task that records the results in the DB.",
            "",
            "        :param nodename: unused in this driver",
            "        :returns: dictionary containing resource info",
            "        \"\"\"",
            "",
            "        disk_info_dict = self._get_local_gb_info()",
            "        data = {}",
            "",
            "        # NOTE(dprince): calling capabilities before getVersion works around",
            "        # an initialization issue with some versions of Libvirt (1.0.5.5).",
            "        # See: https://bugzilla.redhat.com/show_bug.cgi?id=1000116",
            "        # See: https://bugs.launchpad.net/nova/+bug/1215593",
            "        data[\"supported_instances\"] = self._get_instance_capabilities()",
            "",
            "        data[\"vcpus\"] = self._get_vcpu_total()",
            "        data[\"memory_mb\"] = self._host.get_memory_mb_total()",
            "        data[\"local_gb\"] = disk_info_dict['total']",
            "        data[\"vcpus_used\"] = self._get_vcpu_used()",
            "        data[\"memory_mb_used\"] = self._host.get_memory_mb_used()",
            "        data[\"local_gb_used\"] = disk_info_dict['used']",
            "        data[\"hypervisor_type\"] = self._host.get_driver_type()",
            "        data[\"hypervisor_version\"] = self._host.get_version()",
            "        data[\"hypervisor_hostname\"] = self._host.get_hostname()",
            "        # TODO(berrange): why do we bother converting the",
            "        # libvirt capabilities XML into a special JSON format ?",
            "        # The data format is different across all the drivers",
            "        # so we could just return the raw capabilities XML",
            "        # which 'compare_cpu' could use directly",
            "        #",
            "        # That said, arch_filter.py now seems to rely on",
            "        # the libvirt drivers format which suggests this",
            "        # data format needs to be standardized across drivers",
            "        data[\"cpu_info\"] = jsonutils.dumps(self._get_cpu_info())",
            "",
            "        disk_free_gb = disk_info_dict['free']",
            "        disk_over_committed = self._get_disk_over_committed_size_total()",
            "        available_least = disk_free_gb * units.Gi - disk_over_committed",
            "        data['disk_available_least'] = available_least / units.Gi",
            "",
            "        data['pci_passthrough_devices'] = \\",
            "            self._get_pci_passthrough_devices()",
            "",
            "        numa_topology = self._get_host_numa_topology()",
            "        if numa_topology:",
            "            data['numa_topology'] = numa_topology._to_json()",
            "        else:",
            "            data['numa_topology'] = None",
            "",
            "        return data",
            "",
            "    def check_instance_shared_storage_local(self, context, instance):",
            "        \"\"\"Check if instance files located on shared storage.",
            "",
            "        This runs check on the destination host, and then calls",
            "        back to the source host to check the results.",
            "",
            "        :param context: security context",
            "        :param instance: nova.objects.instance.Instance object",
            "        :returns:",
            "         - tempfile: A dict containing the tempfile info on the destination",
            "                     host",
            "         - None:",
            "",
            "            1. If the instance path is not existing.",
            "            2. If the image backend is shared block storage type.",
            "        \"\"\"",
            "        if self.image_backend.backend().is_shared_block_storage():",
            "            return None",
            "",
            "        dirpath = libvirt_utils.get_instance_path(instance)",
            "",
            "        if not os.path.exists(dirpath):",
            "            return None",
            "",
            "        fd, tmp_file = tempfile.mkstemp(dir=dirpath)",
            "        LOG.debug(\"Creating tmpfile %s to verify with other \"",
            "                  \"compute node that the instance is on \"",
            "                  \"the same shared storage.\",",
            "                  tmp_file, instance=instance)",
            "        os.close(fd)",
            "        return {\"filename\": tmp_file}",
            "",
            "    def check_instance_shared_storage_remote(self, context, data):",
            "        return os.path.exists(data['filename'])",
            "",
            "    def check_instance_shared_storage_cleanup(self, context, data):",
            "        fileutils.delete_if_exists(data[\"filename\"])",
            "",
            "    def check_can_live_migrate_destination(self, context, instance,",
            "                                           src_compute_info, dst_compute_info,",
            "                                           block_migration=False,",
            "                                           disk_over_commit=False):",
            "        \"\"\"Check if it is possible to execute live migration.",
            "",
            "        This runs checks on the destination host, and then calls",
            "        back to the source host to check the results.",
            "",
            "        :param context: security context",
            "        :param instance: nova.db.sqlalchemy.models.Instance",
            "        :param block_migration: if true, prepare for block migration",
            "        :param disk_over_commit: if true, allow disk over commit",
            "        :returns: a LibvirtLiveMigrateData object",
            "        \"\"\"",
            "        disk_available_gb = dst_compute_info['disk_available_least']",
            "        disk_available_mb = (",
            "            (disk_available_gb * units.Ki) - CONF.reserved_host_disk_mb)",
            "",
            "        # Compare CPU",
            "        if not instance.vcpu_model or not instance.vcpu_model.model:",
            "            source_cpu_info = src_compute_info['cpu_info']",
            "            self._compare_cpu(None, source_cpu_info)",
            "        else:",
            "            self._compare_cpu(instance.vcpu_model, None)",
            "",
            "        # Create file on storage, to be checked on source host",
            "        filename = self._create_shared_storage_test_file()",
            "",
            "        data = objects.LibvirtLiveMigrateData()",
            "        data.filename = filename",
            "        data.image_type = CONF.libvirt.images_type",
            "        # Notes(eliqiao): block_migration and disk_over_commit are not",
            "        # nullable, so just don't set them if they are None",
            "        if block_migration is not None:",
            "            data.block_migration = block_migration",
            "        if disk_over_commit is not None:",
            "            data.disk_over_commit = disk_over_commit",
            "        data.disk_available_mb = disk_available_mb",
            "        return data",
            "",
            "    def check_can_live_migrate_destination_cleanup(self, context,",
            "                                                   dest_check_data):",
            "        \"\"\"Do required cleanup on dest host after check_can_live_migrate calls",
            "",
            "        :param context: security context",
            "        \"\"\"",
            "        filename = dest_check_data.filename",
            "        self._cleanup_shared_storage_test_file(filename)",
            "",
            "    def check_can_live_migrate_source(self, context, instance,",
            "                                      dest_check_data,",
            "                                      block_device_info=None):",
            "        \"\"\"Check if it is possible to execute live migration.",
            "",
            "        This checks if the live migration can succeed, based on the",
            "        results from check_can_live_migrate_destination.",
            "",
            "        :param context: security context",
            "        :param instance: nova.db.sqlalchemy.models.Instance",
            "        :param dest_check_data: result of check_can_live_migrate_destination",
            "        :param block_device_info: result of _get_instance_block_device_info",
            "        :returns: a LibvirtLiveMigrateData object",
            "        \"\"\"",
            "        # Checking shared storage connectivity",
            "        # if block migration, instances_paths should not be on shared storage.",
            "        source = CONF.host",
            "",
            "        if not isinstance(dest_check_data, migrate_data_obj.LiveMigrateData):",
            "            md_obj = objects.LibvirtLiveMigrateData()",
            "            md_obj.from_legacy_dict(dest_check_data)",
            "            dest_check_data = md_obj",
            "",
            "        dest_check_data.is_shared_instance_path = (",
            "            self._check_shared_storage_test_file(",
            "                dest_check_data.filename))",
            "",
            "        dest_check_data.is_shared_block_storage = (",
            "            self._is_shared_block_storage(instance, dest_check_data,",
            "                                          block_device_info))",
            "",
            "        disk_info_text = self.get_instance_disk_info(",
            "            instance, block_device_info=block_device_info)",
            "        booted_from_volume = self._is_booted_from_volume(instance,",
            "                                                         disk_info_text)",
            "        has_local_disk = self._has_local_disk(instance, disk_info_text)",
            "",
            "        if 'block_migration' not in dest_check_data:",
            "            dest_check_data.block_migration = (",
            "                not dest_check_data.is_on_shared_storage())",
            "",
            "        if dest_check_data.block_migration:",
            "            # TODO(eliqiao): Once block_migration flag is removed from the API",
            "            # we can safely remove the if condition",
            "            if dest_check_data.is_on_shared_storage():",
            "                reason = _(\"Block migration can not be used \"",
            "                           \"with shared storage.\")",
            "                raise exception.InvalidLocalStorage(reason=reason, path=source)",
            "            if 'disk_over_commit' in dest_check_data:",
            "                self._assert_dest_node_has_enough_disk(context, instance,",
            "                                        dest_check_data.disk_available_mb,",
            "                                        dest_check_data.disk_over_commit,",
            "                                        block_device_info)",
            "            if block_device_info:",
            "                bdm = block_device_info.get('block_device_mapping')",
            "                # NOTE(pkoniszewski): libvirt from version 1.2.17 upwards",
            "                # supports selective block device migration. It means that it",
            "                # is possible to define subset of block devices to be copied",
            "                # during migration. If they are not specified - block devices",
            "                # won't be migrated. However, it does not work when live",
            "                # migration is tunnelled through libvirt.",
            "                if bdm and not self._host.has_min_version(",
            "                        MIN_LIBVIRT_BLOCK_LM_WITH_VOLUMES_VERSION):",
            "                    # NOTE(stpierre): if this instance has mapped volumes,",
            "                    # we can't do a block migration, since that will result",
            "                    # in volumes being copied from themselves to themselves,",
            "                    # which is a recipe for disaster.",
            "                    ver = \".\".join([str(x) for x in",
            "                                    MIN_LIBVIRT_BLOCK_LM_WITH_VOLUMES_VERSION])",
            "                    msg = (_('Cannot block migrate instance %(uuid)s with'",
            "                             ' mapped volumes. Selective block device'",
            "                             ' migration feature requires libvirt version'",
            "                             ' %(libvirt_ver)s') %",
            "                           {'uuid': instance.uuid, 'libvirt_ver': ver})",
            "                    LOG.error(msg, instance=instance)",
            "                    raise exception.MigrationPreCheckError(reason=msg)",
            "        elif not (dest_check_data.is_shared_block_storage or",
            "                  dest_check_data.is_shared_instance_path or",
            "                  (booted_from_volume and not has_local_disk)):",
            "            reason = _(\"Live migration can not be used \"",
            "                       \"without shared storage except \"",
            "                       \"a booted from volume VM which \"",
            "                       \"does not have a local disk.\")",
            "            raise exception.InvalidSharedStorage(reason=reason, path=source)",
            "",
            "        # NOTE(mikal): include the instance directory name here because it",
            "        # doesn't yet exist on the destination but we want to force that",
            "        # same name to be used",
            "        instance_path = libvirt_utils.get_instance_path(instance,",
            "                                                        relative=True)",
            "        dest_check_data.instance_relative_path = instance_path",
            "",
            "        return dest_check_data",
            "",
            "    def _is_shared_block_storage(self, instance, dest_check_data,",
            "                                 block_device_info=None):",
            "        \"\"\"Check if all block storage of an instance can be shared",
            "        between source and destination of a live migration.",
            "",
            "        Returns true if the instance is volume backed and has no local disks,",
            "        or if the image backend is the same on source and destination and the",
            "        backend shares block storage between compute nodes.",
            "",
            "        :param instance: nova.objects.instance.Instance object",
            "        :param dest_check_data: dict with boolean fields image_type,",
            "                                is_shared_instance_path, and is_volume_backed",
            "        \"\"\"",
            "        if (dest_check_data.obj_attr_is_set('image_type') and",
            "                CONF.libvirt.images_type == dest_check_data.image_type and",
            "                self.image_backend.backend().is_shared_block_storage()):",
            "            # NOTE(dgenin): currently true only for RBD image backend",
            "            return True",
            "",
            "        if (dest_check_data.is_shared_instance_path and",
            "                self.image_backend.backend().is_file_in_instance_path()):",
            "            # NOTE(angdraug): file based image backends (Raw, Qcow2)",
            "            # place block device files under the instance path",
            "            return True",
            "",
            "        if (dest_check_data.is_volume_backed and",
            "                not bool(jsonutils.loads(",
            "                    self.get_instance_disk_info(instance,",
            "                                                block_device_info)))):",
            "            return True",
            "",
            "        return False",
            "",
            "    def _assert_dest_node_has_enough_disk(self, context, instance,",
            "                                             available_mb, disk_over_commit,",
            "                                             block_device_info=None):",
            "        \"\"\"Checks if destination has enough disk for block migration.\"\"\"",
            "        # Libvirt supports qcow2 disk format,which is usually compressed",
            "        # on compute nodes.",
            "        # Real disk image (compressed) may enlarged to \"virtual disk size\",",
            "        # that is specified as the maximum disk size.",
            "        # (See qemu-img -f path-to-disk)",
            "        # Scheduler recognizes destination host still has enough disk space",
            "        # if real disk size < available disk size",
            "        # if disk_over_commit is True,",
            "        #  otherwise virtual disk size < available disk size.",
            "",
            "        available = 0",
            "        if available_mb:",
            "            available = available_mb * units.Mi",
            "",
            "        ret = self.get_instance_disk_info(instance,",
            "                                          block_device_info=block_device_info)",
            "        disk_infos = jsonutils.loads(ret)",
            "",
            "        necessary = 0",
            "        if disk_over_commit:",
            "            for info in disk_infos:",
            "                necessary += int(info['disk_size'])",
            "        else:",
            "            for info in disk_infos:",
            "                necessary += int(info['virt_disk_size'])",
            "",
            "        # Check that available disk > necessary disk",
            "        if (available - necessary) < 0:",
            "            reason = (_('Unable to migrate %(instance_uuid)s: '",
            "                        'Disk of instance is too large(available'",
            "                        ' on destination host:%(available)s '",
            "                        '< need:%(necessary)s)') %",
            "                      {'instance_uuid': instance.uuid,",
            "                       'available': available,",
            "                       'necessary': necessary})",
            "            raise exception.MigrationPreCheckError(reason=reason)",
            "",
            "    def _compare_cpu(self, guest_cpu, host_cpu_str):",
            "        \"\"\"Check the host is compatible with the requested CPU",
            "",
            "        :param guest_cpu: nova.objects.VirtCPUModel or None",
            "        :param host_cpu_str: JSON from _get_cpu_info() method",
            "",
            "        If the 'guest_cpu' parameter is not None, this will be",
            "        validated for migration compatibility with the host.",
            "        Otherwise the 'host_cpu_str' JSON string will be used for",
            "        validation.",
            "",
            "        :returns:",
            "            None. if given cpu info is not compatible to this server,",
            "            raise exception.",
            "        \"\"\"",
            "",
            "        # NOTE(berendt): virConnectCompareCPU not working for Xen",
            "        if CONF.libvirt.virt_type not in ['qemu', 'kvm']:",
            "            return",
            "",
            "        if guest_cpu is None:",
            "            info = jsonutils.loads(host_cpu_str)",
            "            LOG.info(_LI('Instance launched has CPU info: %s'), host_cpu_str)",
            "            cpu = vconfig.LibvirtConfigCPU()",
            "            cpu.arch = info['arch']",
            "            cpu.model = info['model']",
            "            cpu.vendor = info['vendor']",
            "            cpu.sockets = info['topology']['sockets']",
            "            cpu.cores = info['topology']['cores']",
            "            cpu.threads = info['topology']['threads']",
            "            for f in info['features']:",
            "                cpu.add_feature(vconfig.LibvirtConfigCPUFeature(f))",
            "        else:",
            "            cpu = self._vcpu_model_to_cpu_config(guest_cpu)",
            "",
            "        u = (\"http://libvirt.org/html/libvirt-libvirt-host.html#\"",
            "             \"virCPUCompareResult\")",
            "        m = _(\"CPU doesn't have compatibility.\\n\\n%(ret)s\\n\\nRefer to %(u)s\")",
            "        # unknown character exists in xml, then libvirt complains",
            "        try:",
            "            ret = self._host.compare_cpu(cpu.to_xml())",
            "        except libvirt.libvirtError as e:",
            "            error_code = e.get_error_code()",
            "            if error_code == libvirt.VIR_ERR_NO_SUPPORT:",
            "                LOG.debug(\"URI %(uri)s does not support cpu comparison. \"",
            "                          \"It will be proceeded though. Error: %(error)s\",",
            "                          {'uri': self._uri(), 'error': e})",
            "                return",
            "            else:",
            "                LOG.error(m, {'ret': e, 'u': u})",
            "                raise exception.MigrationPreCheckError(",
            "                    reason=m % {'ret': e, 'u': u})",
            "",
            "        if ret <= 0:",
            "            LOG.error(m, {'ret': ret, 'u': u})",
            "            raise exception.InvalidCPUInfo(reason=m % {'ret': ret, 'u': u})",
            "",
            "    def _create_shared_storage_test_file(self):",
            "        \"\"\"Makes tmpfile under CONF.instances_path.\"\"\"",
            "        dirpath = CONF.instances_path",
            "        fd, tmp_file = tempfile.mkstemp(dir=dirpath)",
            "        LOG.debug(\"Creating tmpfile %s to notify to other \"",
            "                  \"compute nodes that they should mount \"",
            "                  \"the same storage.\", tmp_file)",
            "        os.close(fd)",
            "        return os.path.basename(tmp_file)",
            "",
            "    def _check_shared_storage_test_file(self, filename):",
            "        \"\"\"Confirms existence of the tmpfile under CONF.instances_path.",
            "",
            "        Cannot confirm tmpfile return False.",
            "        \"\"\"",
            "        tmp_file = os.path.join(CONF.instances_path, filename)",
            "        if not os.path.exists(tmp_file):",
            "            return False",
            "        else:",
            "            return True",
            "",
            "    def _cleanup_shared_storage_test_file(self, filename):",
            "        \"\"\"Removes existence of the tmpfile under CONF.instances_path.\"\"\"",
            "        tmp_file = os.path.join(CONF.instances_path, filename)",
            "        os.remove(tmp_file)",
            "",
            "    def ensure_filtering_rules_for_instance(self, instance, network_info):",
            "        \"\"\"Ensure that an instance's filtering rules are enabled.",
            "",
            "        When migrating an instance, we need the filtering rules to",
            "        be configured on the destination host before starting the",
            "        migration.",
            "",
            "        Also, when restarting the compute service, we need to ensure",
            "        that filtering rules exist for all running services.",
            "        \"\"\"",
            "",
            "        self.firewall_driver.setup_basic_filtering(instance, network_info)",
            "        self.firewall_driver.prepare_instance_filter(instance,",
            "                network_info)",
            "",
            "        # nwfilters may be defined in a separate thread in the case",
            "        # of libvirt non-blocking mode, so we wait for completion",
            "        timeout_count = list(range(CONF.live_migration_retry_count))",
            "        while timeout_count:",
            "            if self.firewall_driver.instance_filter_exists(instance,",
            "                                                           network_info):",
            "                break",
            "            timeout_count.pop()",
            "            if len(timeout_count) == 0:",
            "                msg = _('The firewall filter for %s does not exist')",
            "                raise exception.NovaException(msg % instance.name)",
            "            greenthread.sleep(1)",
            "",
            "    def filter_defer_apply_on(self):",
            "        self.firewall_driver.filter_defer_apply_on()",
            "",
            "    def filter_defer_apply_off(self):",
            "        self.firewall_driver.filter_defer_apply_off()",
            "",
            "    def live_migration(self, context, instance, dest,",
            "                       post_method, recover_method, block_migration=False,",
            "                       migrate_data=None):",
            "        \"\"\"Spawning live_migration operation for distributing high-load.",
            "",
            "        :param context: security context",
            "        :param instance:",
            "            nova.db.sqlalchemy.models.Instance object",
            "            instance object that is migrated.",
            "        :param dest: destination host",
            "        :param post_method:",
            "            post operation method.",
            "            expected nova.compute.manager._post_live_migration.",
            "        :param recover_method:",
            "            recovery method when any exception occurs.",
            "            expected nova.compute.manager._rollback_live_migration.",
            "        :param block_migration: if true, do block migration.",
            "        :param migrate_data: a LibvirtLiveMigrateData object",
            "",
            "        \"\"\"",
            "",
            "        # 'dest' will be substituted into 'migration_uri' so ensure",
            "        # it does't contain any characters that could be used to",
            "        # exploit the URI accepted by libivrt",
            "        if not libvirt_utils.is_valid_hostname(dest):",
            "            raise exception.InvalidHostname(hostname=dest)",
            "",
            "        self._live_migration(context, instance, dest,",
            "                             post_method, recover_method, block_migration,",
            "                             migrate_data)",
            "",
            "    def live_migration_abort(self, instance):",
            "        \"\"\"Aborting a running live-migration.",
            "",
            "        :param instance: instance object that is in migration",
            "",
            "        \"\"\"",
            "",
            "        guest = self._host.get_guest(instance)",
            "        dom = guest._domain",
            "",
            "        try:",
            "            dom.abortJob()",
            "        except libvirt.libvirtError as e:",
            "            LOG.error(_LE(\"Failed to cancel migration %s\"),",
            "                      e, instance=instance)",
            "            raise",
            "",
            "    def _update_xml(self, xml_str, migrate_bdm_info, listen_addrs,",
            "                    serial_listen_addr):",
            "        xml_doc = etree.fromstring(xml_str)",
            "",
            "        if migrate_bdm_info:",
            "            xml_doc = self._update_volume_xml(xml_doc, migrate_bdm_info)",
            "        if listen_addrs:",
            "            xml_doc = self._update_graphics_xml(xml_doc, listen_addrs)",
            "        else:",
            "            self._check_graphics_addresses_can_live_migrate(listen_addrs)",
            "        if serial_listen_addr:",
            "            xml_doc = self._update_serial_xml(xml_doc, serial_listen_addr)",
            "        else:",
            "            self._verify_serial_console_is_disabled()",
            "",
            "        return etree.tostring(xml_doc)",
            "",
            "    def _update_graphics_xml(self, xml_doc, listen_addrs):",
            "",
            "        # change over listen addresses",
            "        for dev in xml_doc.findall('./devices/graphics'):",
            "            gr_type = dev.get('type')",
            "            listen_tag = dev.find('listen')",
            "            if gr_type in ('vnc', 'spice'):",
            "                if listen_tag is not None:",
            "                    listen_tag.set('address', listen_addrs[gr_type])",
            "                if dev.get('listen') is not None:",
            "                    dev.set('listen', listen_addrs[gr_type])",
            "",
            "        return xml_doc",
            "",
            "    def _update_volume_xml(self, xml_doc, migrate_bdm_info):",
            "        \"\"\"Update XML using device information of destination host.\"\"\"",
            "",
            "        # Update volume xml",
            "        parser = etree.XMLParser(remove_blank_text=True)",
            "        disk_nodes = xml_doc.findall('./devices/disk')",
            "",
            "        bdm_info_by_serial = {x.serial: x for x in migrate_bdm_info}",
            "        for pos, disk_dev in enumerate(disk_nodes):",
            "            serial_source = disk_dev.findtext('serial')",
            "            bdm_info = bdm_info_by_serial.get(serial_source)",
            "            if (serial_source is None or",
            "                    not bdm_info or not bdm_info.connection_info or",
            "                    serial_source not in bdm_info_by_serial):",
            "                continue",
            "            conf = self._get_volume_config(",
            "                bdm_info.connection_info, bdm_info.as_disk_info())",
            "            xml_doc2 = etree.XML(conf.to_xml(), parser)",
            "            serial_dest = xml_doc2.findtext('serial')",
            "",
            "            # Compare source serial and destination serial number.",
            "            # If these serial numbers match, continue the process.",
            "            if (serial_dest and (serial_source == serial_dest)):",
            "                LOG.debug(\"Find same serial number: pos=%(pos)s, \"",
            "                          \"serial=%(num)s\",",
            "                          {'pos': pos, 'num': serial_source})",
            "                for cnt, item_src in enumerate(disk_dev):",
            "                    # If source and destination have same item, update",
            "                    # the item using destination value.",
            "                    for item_dst in xml_doc2.findall(item_src.tag):",
            "                        disk_dev.remove(item_src)",
            "                        item_dst.tail = None",
            "                        disk_dev.insert(cnt, item_dst)",
            "",
            "                # If destination has additional items, thses items should be",
            "                # added here.",
            "                for item_dst in list(xml_doc2):",
            "                    item_dst.tail = None",
            "                    disk_dev.insert(cnt, item_dst)",
            "",
            "        return xml_doc",
            "",
            "    def _update_serial_xml(self, xml_doc, listen_addr):",
            "        for dev in xml_doc.findall(\"./devices/serial[@type='tcp']/source\"):",
            "            if dev.get('host') is not None:",
            "                dev.set('host', listen_addr)",
            "",
            "        for dev in xml_doc.findall(\"./devices/console[@type='tcp']/source\"):",
            "            if dev.get('host') is not None:",
            "                dev.set('host', listen_addr)",
            "",
            "        return xml_doc",
            "",
            "    def _check_graphics_addresses_can_live_migrate(self, listen_addrs):",
            "        LOCAL_ADDRS = ('0.0.0.0', '127.0.0.1', '::', '::1')",
            "",
            "        local_vnc = CONF.vnc.vncserver_listen in LOCAL_ADDRS",
            "        local_spice = CONF.spice.server_listen in LOCAL_ADDRS",
            "",
            "        if ((CONF.vnc.enabled and not local_vnc) or",
            "            (CONF.spice.enabled and not local_spice)):",
            "",
            "            msg = _('Your libvirt version does not support the'",
            "                    ' VIR_DOMAIN_XML_MIGRATABLE flag or your'",
            "                    ' destination node does not support'",
            "                    ' retrieving listen addresses.  In order'",
            "                    ' for live migration to work properly, you'",
            "                    ' must configure the graphics (VNC and/or'",
            "                    ' SPICE) listen addresses to be either'",
            "                    ' the catch-all address (0.0.0.0 or ::) or'",
            "                    ' the local address (127.0.0.1 or ::1).')",
            "            raise exception.MigrationError(reason=msg)",
            "",
            "        if listen_addrs:",
            "            dest_local_vnc = listen_addrs.get('vnc') in LOCAL_ADDRS",
            "            dest_local_spice = listen_addrs.get('spice') in LOCAL_ADDRS",
            "",
            "            if ((CONF.vnc.enabled and not dest_local_vnc) or",
            "                (CONF.spice.enabled and not dest_local_spice)):",
            "",
            "                LOG.warn(_LW('Your libvirt version does not support the'",
            "                             ' VIR_DOMAIN_XML_MIGRATABLE flag, and the'",
            "                             ' graphics (VNC and/or SPICE) listen'",
            "                             ' addresses on the destination node do not'",
            "                             ' match the addresses on the source node.'",
            "                             ' Since the source node has listen'",
            "                             ' addresses set to either the catch-all'",
            "                             ' address (0.0.0.0 or ::) or the local'",
            "                             ' address (127.0.0.1 or ::1), the live'",
            "                             ' migration will succeed, but the VM will'",
            "                             ' continue to listen on the current'",
            "                             ' addresses.'))",
            "",
            "    def _verify_serial_console_is_disabled(self):",
            "        if CONF.serial_console.enabled:",
            "",
            "            msg = _('Your libvirt version does not support the'",
            "                    ' VIR_DOMAIN_XML_MIGRATABLE flag or your'",
            "                    ' destination node does not support'",
            "                    ' retrieving listen addresses.  In order'",
            "                    ' for live migration to work properly you'",
            "                    ' must either disable serial console or'",
            "                    ' upgrade your libvirt version.')",
            "            raise exception.MigrationError(reason=msg)",
            "",
            "    def _live_migration_operation(self, context, instance, dest,",
            "                                  block_migration, migrate_data, dom,",
            "                                  device_names):",
            "        \"\"\"Invoke the live migration operation",
            "",
            "        :param context: security context",
            "        :param instance:",
            "            nova.db.sqlalchemy.models.Instance object",
            "            instance object that is migrated.",
            "        :param dest: destination host",
            "        :param block_migration: if true, do block migration.",
            "        :param migrate_data: a LibvirtLiveMigrateData object",
            "        :param dom: the libvirt domain object",
            "        :param device_names: list of device names that are being migrated with",
            "            instance",
            "",
            "        This method is intended to be run in a background thread and will",
            "        block that thread until the migration is finished or failed.",
            "        \"\"\"",
            "        # TODO(sahid): Should pass a guest to this method.",
            "        guest = libvirt_guest.Guest(dom)",
            "",
            "        try:",
            "            if block_migration:",
            "                migration_flags = self._block_migration_flags",
            "            else:",
            "                migration_flags = self._live_migration_flags",
            "",
            "            listen_addrs = {}",
            "            if 'graphics_listen_addr_vnc' in migrate_data:",
            "                listen_addrs['vnc'] = str(",
            "                    migrate_data.graphics_listen_addr_vnc)",
            "            if 'graphics_listen_addr_spice' in migrate_data:",
            "                listen_addrs['spice'] = str(",
            "                    migrate_data.graphics_listen_addr_spice)",
            "            serial_listen_addr = migrate_data.serial_listen_addr",
            "            if migrate_data.target_connect_addr is not None:",
            "                dest = migrate_data.target_connect_addr",
            "",
            "            migratable_flag = getattr(libvirt, 'VIR_DOMAIN_XML_MIGRATABLE',",
            "                                      None)",
            "",
            "            if (migratable_flag is None or (",
            "                    not listen_addrs and not migrate_data.bdms)):",
            "                # TODO(alexs-h): These checks could be moved to the",
            "                # check_can_live_migrate_destination/source phase",
            "                self._check_graphics_addresses_can_live_migrate(listen_addrs)",
            "                self._verify_serial_console_is_disabled()",
            "                dom.migrateToURI(self._live_migration_uri(dest),",
            "                                 migration_flags,",
            "                                 None,",
            "                                 CONF.libvirt.live_migration_bandwidth)",
            "            else:",
            "                old_xml_str = guest.get_xml_desc(dump_migratable=True)",
            "                new_xml_str = self._update_xml(old_xml_str,",
            "                                               migrate_data.bdms,",
            "                                               listen_addrs,",
            "                                               serial_listen_addr)",
            "                try:",
            "                    if self._host.has_min_version(",
            "                            MIN_LIBVIRT_BLOCK_LM_WITH_VOLUMES_VERSION):",
            "                        params = {",
            "                            'bandwidth': CONF.libvirt.live_migration_bandwidth,",
            "                            'destination_xml': new_xml_str,",
            "                            'migrate_disks': device_names,",
            "                        }",
            "                        dom.migrateToURI3(",
            "                            self._live_migration_uri(dest),",
            "                            params,",
            "                            migration_flags)",
            "                    else:",
            "                        dom.migrateToURI2(",
            "                            self._live_migration_uri(dest),",
            "                            None,",
            "                            new_xml_str,",
            "                            migration_flags,",
            "                            None,",
            "                            CONF.libvirt.live_migration_bandwidth)",
            "                except libvirt.libvirtError as ex:",
            "                    # NOTE(mriedem): There is a bug in older versions of",
            "                    # libvirt where the VIR_DOMAIN_XML_MIGRATABLE flag causes",
            "                    # virDomainDefCheckABIStability to not compare the source",
            "                    # and target domain xml's correctly for the CPU model.",
            "                    # We try to handle that error here and attempt the legacy",
            "                    # migrateToURI path, which could fail if the console",
            "                    # addresses are not correct, but in that case we have the",
            "                    # _check_graphics_addresses_can_live_migrate check in place",
            "                    # to catch it.",
            "                    # TODO(mriedem): Remove this workaround when",
            "                    # Red Hat BZ #1141838 is closed.",
            "                    error_code = ex.get_error_code()",
            "                    if error_code == libvirt.VIR_ERR_CONFIG_UNSUPPORTED:",
            "                        LOG.warn(_LW('An error occurred trying to live '",
            "                                     'migrate. Falling back to legacy live '",
            "                                     'migrate flow. Error: %s'), ex,",
            "                                 instance=instance)",
            "                        self._check_graphics_addresses_can_live_migrate(",
            "                            listen_addrs)",
            "                        self._verify_serial_console_is_disabled()",
            "                        dom.migrateToURI(",
            "                            self._live_migration_uri(dest),",
            "                            migration_flags,",
            "                            None,",
            "                            CONF.libvirt.live_migration_bandwidth)",
            "                    else:",
            "                        raise",
            "        except Exception as e:",
            "            with excutils.save_and_reraise_exception():",
            "                LOG.error(_LE(\"Live Migration failure: %s\"), e,",
            "                          instance=instance)",
            "",
            "        # If 'migrateToURI' fails we don't know what state the",
            "        # VM instances on each host are in. Possibilities include",
            "        #",
            "        #  1. src==running, dst==none",
            "        #",
            "        #     Migration failed & rolled back, or never started",
            "        #",
            "        #  2. src==running, dst==paused",
            "        #",
            "        #     Migration started but is still ongoing",
            "        #",
            "        #  3. src==paused,  dst==paused",
            "        #",
            "        #     Migration data transfer completed, but switchover",
            "        #     is still ongoing, or failed",
            "        #",
            "        #  4. src==paused,  dst==running",
            "        #",
            "        #     Migration data transfer completed, switchover",
            "        #     happened but cleanup on source failed",
            "        #",
            "        #  5. src==none,    dst==running",
            "        #",
            "        #     Migration fully succeeded.",
            "        #",
            "        # Libvirt will aim to complete any migration operation",
            "        # or roll it back. So even if the migrateToURI call has",
            "        # returned an error, if the migration was not finished",
            "        # libvirt should clean up.",
            "        #",
            "        # So we take the error raise here with a pinch of salt",
            "        # and rely on the domain job info status to figure out",
            "        # what really happened to the VM, which is a much more",
            "        # reliable indicator.",
            "        #",
            "        # In particular we need to try very hard to ensure that",
            "        # Nova does not \"forget\" about the guest. ie leaving it",
            "        # running on a different host to the one recorded in",
            "        # the database, as that would be a serious resource leak",
            "",
            "        LOG.debug(\"Migration operation thread has finished\",",
            "                  instance=instance)",
            "",
            "    @staticmethod",
            "    def _migration_downtime_steps(data_gb):",
            "        '''Calculate downtime value steps and time between increases.",
            "",
            "        :param data_gb: total GB of RAM and disk to transfer",
            "",
            "        This looks at the total downtime steps and upper bound",
            "        downtime value and uses an exponential backoff. So initially",
            "        max downtime is increased by small amounts, and as time goes",
            "        by it is increased by ever larger amounts",
            "",
            "        For example, with 10 steps, 30 second step delay, 3 GB",
            "        of RAM and 400ms target maximum downtime, the downtime will",
            "        be increased every 90 seconds in the following progression:",
            "",
            "        -   0 seconds -> set downtime to  37ms",
            "        -  90 seconds -> set downtime to  38ms",
            "        - 180 seconds -> set downtime to  39ms",
            "        - 270 seconds -> set downtime to  42ms",
            "        - 360 seconds -> set downtime to  46ms",
            "        - 450 seconds -> set downtime to  55ms",
            "        - 540 seconds -> set downtime to  70ms",
            "        - 630 seconds -> set downtime to  98ms",
            "        - 720 seconds -> set downtime to 148ms",
            "        - 810 seconds -> set downtime to 238ms",
            "        - 900 seconds -> set downtime to 400ms",
            "",
            "        This allows the guest a good chance to complete migration",
            "        with a small downtime value.",
            "        '''",
            "        downtime = CONF.libvirt.live_migration_downtime",
            "        steps = CONF.libvirt.live_migration_downtime_steps",
            "        delay = CONF.libvirt.live_migration_downtime_delay",
            "",
            "        if downtime < LIVE_MIGRATION_DOWNTIME_MIN:",
            "            downtime = LIVE_MIGRATION_DOWNTIME_MIN",
            "        if steps < LIVE_MIGRATION_DOWNTIME_STEPS_MIN:",
            "            steps = LIVE_MIGRATION_DOWNTIME_STEPS_MIN",
            "        if delay < LIVE_MIGRATION_DOWNTIME_DELAY_MIN:",
            "            delay = LIVE_MIGRATION_DOWNTIME_DELAY_MIN",
            "        delay = int(delay * data_gb)",
            "",
            "        offset = downtime / float(steps + 1)",
            "        base = (downtime - offset) ** (1 / float(steps))",
            "",
            "        for i in range(steps + 1):",
            "            yield (int(delay * i), int(offset + base ** i))",
            "",
            "    def _live_migration_copy_disk_paths(self, context, instance, guest):",
            "        '''Get list of disks to copy during migration",
            "",
            "        :param context: security context",
            "        :param instance: the instance being migrated",
            "        :param guest: the Guest instance being migrated",
            "",
            "        Get the list of disks to copy during migration.",
            "",
            "        :returns: a list of local source paths and a list of device names to",
            "            copy",
            "        '''",
            "",
            "        disk_paths = []",
            "        device_names = []",
            "        block_devices = []",
            "",
            "        # TODO(pkoniszewski): Remove this if-statement when we bump min libvirt",
            "        # version to >= 1.2.17",
            "        if self._host.has_min_version(",
            "                MIN_LIBVIRT_BLOCK_LM_WITH_VOLUMES_VERSION):",
            "            bdm_list = objects.BlockDeviceMappingList.get_by_instance_uuid(",
            "                context, instance.uuid)",
            "            block_device_info = driver.get_block_device_info(instance,",
            "                                                             bdm_list)",
            "",
            "            block_device_mappings = driver.block_device_info_get_mapping(",
            "                block_device_info)",
            "            for bdm in block_device_mappings:",
            "                device_name = str(bdm['mount_device'].rsplit('/', 1)[1])",
            "                block_devices.append(device_name)",
            "",
            "        for dev in guest.get_all_disks():",
            "            if dev.readonly or dev.shareable:",
            "                continue",
            "            if dev.source_type not in [\"file\", \"block\"]:",
            "                continue",
            "            if dev.target_dev in block_devices:",
            "                continue",
            "            disk_paths.append(dev.source_path)",
            "            device_names.append(dev.target_dev)",
            "        return (disk_paths, device_names)",
            "",
            "    def _live_migration_data_gb(self, instance, disk_paths):",
            "        '''Calculate total amount of data to be transferred",
            "",
            "        :param instance: the nova.objects.Instance being migrated",
            "        :param disk_paths: list of disk paths that are being migrated",
            "        with instance",
            "",
            "        Calculates the total amount of data that needs to be",
            "        transferred during the live migration. The actual",
            "        amount copied will be larger than this, due to the",
            "        guest OS continuing to dirty RAM while the migration",
            "        is taking place. So this value represents the minimal",
            "        data size possible.",
            "",
            "        :returns: data size to be copied in GB",
            "        '''",
            "",
            "        ram_gb = instance.flavor.memory_mb * units.Mi / units.Gi",
            "        if ram_gb < 2:",
            "            ram_gb = 2",
            "",
            "        disk_gb = 0",
            "        for path in disk_paths:",
            "            try:",
            "                size = os.stat(path).st_size",
            "                size_gb = (size / units.Gi)",
            "                if size_gb < 2:",
            "                    size_gb = 2",
            "                disk_gb += size_gb",
            "            except OSError as e:",
            "                LOG.warn(_LW(\"Unable to stat %(disk)s: %(ex)s\"),",
            "                         {'disk': path, 'ex': e})",
            "                # Ignore error since we don't want to break",
            "                # the migration monitoring thread operation",
            "",
            "        return ram_gb + disk_gb",
            "",
            "    def _live_migration_monitor(self, context, instance, guest,",
            "                                dest, post_method,",
            "                                recover_method, block_migration,",
            "                                migrate_data, dom, finish_event,",
            "                                disk_paths):",
            "        data_gb = self._live_migration_data_gb(instance, disk_paths)",
            "        downtime_steps = list(self._migration_downtime_steps(data_gb))",
            "        completion_timeout = int(",
            "            CONF.libvirt.live_migration_completion_timeout * data_gb)",
            "        progress_timeout = CONF.libvirt.live_migration_progress_timeout",
            "        migration = migrate_data.migration",
            "",
            "        n = 0",
            "        start = time.time()",
            "        progress_time = start",
            "        progress_watermark = None",
            "        while True:",
            "            info = host.DomainJobInfo.for_domain(dom)",
            "",
            "            if info.type == libvirt.VIR_DOMAIN_JOB_NONE:",
            "                # Annoyingly this could indicate many possible",
            "                # states, so we must fix the mess:",
            "                #",
            "                #   1. Migration has not yet begun",
            "                #   2. Migration has stopped due to failure",
            "                #   3. Migration has stopped due to completion",
            "                #",
            "                # We can detect option 1 by seeing if thread is still",
            "                # running. We can distinguish 2 vs 3 by seeing if the",
            "                # VM still exists & running on the current host",
            "                #",
            "                if not finish_event.ready():",
            "                    LOG.debug(\"Operation thread is still running\",",
            "                              instance=instance)",
            "                    # Leave type untouched",
            "                else:",
            "                    try:",
            "                        if guest.is_active():",
            "                            LOG.debug(\"VM running on src, migration failed\",",
            "                                      instance=instance)",
            "                            info.type = libvirt.VIR_DOMAIN_JOB_FAILED",
            "                        else:",
            "                            LOG.debug(\"VM is shutoff, migration finished\",",
            "                                      instance=instance)",
            "                            info.type = libvirt.VIR_DOMAIN_JOB_COMPLETED",
            "                    except libvirt.libvirtError as ex:",
            "                        LOG.debug(\"Error checking domain status %(ex)s\",",
            "                                  ex, instance=instance)",
            "                        if ex.get_error_code() == libvirt.VIR_ERR_NO_DOMAIN:",
            "                            LOG.debug(\"VM is missing, migration finished\",",
            "                                      instance=instance)",
            "                            info.type = libvirt.VIR_DOMAIN_JOB_COMPLETED",
            "                        else:",
            "                            LOG.info(_LI(\"Error %(ex)s, migration failed\"),",
            "                                     instance=instance)",
            "                            info.type = libvirt.VIR_DOMAIN_JOB_FAILED",
            "",
            "                if info.type != libvirt.VIR_DOMAIN_JOB_NONE:",
            "                    LOG.debug(\"Fixed incorrect job type to be %d\",",
            "                              info.type, instance=instance)",
            "",
            "            if info.type == libvirt.VIR_DOMAIN_JOB_NONE:",
            "                # Migration is not yet started",
            "                LOG.debug(\"Migration not running yet\",",
            "                          instance=instance)",
            "            elif info.type == libvirt.VIR_DOMAIN_JOB_UNBOUNDED:",
            "                # Migration is still running",
            "                #",
            "                # This is where we wire up calls to change live",
            "                # migration status. eg change max downtime, cancel",
            "                # the operation, change max bandwidth",
            "                now = time.time()",
            "                elapsed = now - start",
            "                abort = False",
            "",
            "                if ((progress_watermark is None) or",
            "                    (progress_watermark > info.data_remaining)):",
            "                    progress_watermark = info.data_remaining",
            "                    progress_time = now",
            "",
            "                if (progress_timeout != 0 and",
            "                    (now - progress_time) > progress_timeout):",
            "                    LOG.warn(_LW(\"Live migration stuck for %d sec\"),",
            "                             (now - progress_time), instance=instance)",
            "                    abort = True",
            "",
            "                if (completion_timeout != 0 and",
            "                    elapsed > completion_timeout):",
            "                    LOG.warn(_LW(\"Live migration not completed after %d sec\"),",
            "                             completion_timeout, instance=instance)",
            "                    abort = True",
            "",
            "                if abort:",
            "                    try:",
            "                        dom.abortJob()",
            "                    except libvirt.libvirtError as e:",
            "                        LOG.warn(_LW(\"Failed to abort migration %s\"),",
            "                                 e, instance=instance)",
            "                        raise",
            "",
            "                # See if we need to increase the max downtime. We",
            "                # ignore failures, since we'd rather continue trying",
            "                # to migrate",
            "                if (len(downtime_steps) > 0 and",
            "                    elapsed > downtime_steps[0][0]):",
            "                    downtime = downtime_steps.pop(0)",
            "                    LOG.info(_LI(\"Increasing downtime to %(downtime)d ms \"",
            "                                 \"after %(waittime)d sec elapsed time\"),",
            "                             {\"downtime\": downtime[1],",
            "                              \"waittime\": downtime[0]},",
            "                             instance=instance)",
            "",
            "                    try:",
            "                        dom.migrateSetMaxDowntime(downtime[1])",
            "                    except libvirt.libvirtError as e:",
            "                        LOG.warn(",
            "                            _LW(\"Unable to increase max downtime to %(time)d\"",
            "                                \"ms: %(e)s\"),",
            "                            {\"time\": downtime[1], \"e\": e}, instance=instance)",
            "",
            "                # We loop every 500ms, so don't log on every",
            "                # iteration to avoid spamming logs for long",
            "                # running migrations. Just once every 5 secs",
            "                # is sufficient for developers to debug problems.",
            "                # We log once every 30 seconds at info to help",
            "                # admins see slow running migration operations",
            "                # when debug logs are off.",
            "                if (n % 10) == 0:",
            "                    # Note(Shaohe Feng) every 5 secs to update the migration",
            "                    # db, that keeps updates to the instance and migration",
            "                    # objects in sync.",
            "                    migration.memory_total = info.memory_total",
            "                    migration.memory_processed = info.memory_processed",
            "                    migration.memory_remaining = info.memory_remaining",
            "                    migration.disk_total = info.disk_total",
            "                    migration.disk_processed = info.disk_processed",
            "                    migration.disk_remaining = info.disk_remaining",
            "                    migration.save()",
            "                    # Ignoring memory_processed, as due to repeated",
            "                    # dirtying of data, this can be way larger than",
            "                    # memory_total. Best to just look at what's",
            "                    # remaining to copy and ignore what's done already",
            "                    #",
            "                    # TODO(berrange) perhaps we could include disk",
            "                    # transfer stats in the progress too, but it",
            "                    # might make memory info more obscure as large",
            "                    # disk sizes might dwarf memory size",
            "                    remaining = 100",
            "                    if info.memory_total != 0:",
            "                        remaining = round(info.memory_remaining *",
            "                                          100 / info.memory_total)",
            "                    instance.progress = 100 - remaining",
            "                    instance.save()",
            "",
            "                    lg = LOG.debug",
            "                    if (n % 60) == 0:",
            "                        lg = LOG.info",
            "",
            "                    lg(_LI(\"Migration running for %(secs)d secs, \"",
            "                           \"memory %(remaining)d%% remaining; \"",
            "                           \"(bytes processed=%(processed_memory)d, \"",
            "                           \"remaining=%(remaining_memory)d, \"",
            "                           \"total=%(total_memory)d)\"),",
            "                       {\"secs\": n / 2, \"remaining\": remaining,",
            "                        \"processed_memory\": info.memory_processed,",
            "                        \"remaining_memory\": info.memory_remaining,",
            "                        \"total_memory\": info.memory_total}, instance=instance)",
            "                    if info.data_remaining > progress_watermark:",
            "                        lg(_LI(\"Data remaining %(remaining)d bytes, \"",
            "                               \"low watermark %(watermark)d bytes \"",
            "                               \"%(last)d seconds ago\"),",
            "                           {\"remaining\": info.data_remaining,",
            "                            \"watermark\": progress_watermark,",
            "                            \"last\": (now - progress_time)}, instance=instance)",
            "",
            "                n = n + 1",
            "            elif info.type == libvirt.VIR_DOMAIN_JOB_COMPLETED:",
            "                # Migration is all done",
            "                LOG.info(_LI(\"Migration operation has completed\"),",
            "                         instance=instance)",
            "                post_method(context, instance, dest, block_migration,",
            "                            migrate_data)",
            "                break",
            "            elif info.type == libvirt.VIR_DOMAIN_JOB_FAILED:",
            "                # Migration did not succeed",
            "                LOG.error(_LE(\"Migration operation has aborted\"),",
            "                          instance=instance)",
            "                recover_method(context, instance, dest, block_migration,",
            "                               migrate_data)",
            "                break",
            "            elif info.type == libvirt.VIR_DOMAIN_JOB_CANCELLED:",
            "                # Migration was stopped by admin",
            "                LOG.warn(_LW(\"Migration operation was cancelled\"),",
            "                         instance=instance)",
            "                recover_method(context, instance, dest, block_migration,",
            "                               migrate_data, migration_status='cancelled')",
            "                break",
            "            else:",
            "                LOG.warn(_LW(\"Unexpected migration job type: %d\"),",
            "                         info.type, instance=instance)",
            "",
            "            time.sleep(0.5)",
            "",
            "    def _live_migration(self, context, instance, dest, post_method,",
            "                        recover_method, block_migration,",
            "                        migrate_data):",
            "        \"\"\"Do live migration.",
            "",
            "        :param context: security context",
            "        :param instance:",
            "            nova.db.sqlalchemy.models.Instance object",
            "            instance object that is migrated.",
            "        :param dest: destination host",
            "        :param post_method:",
            "            post operation method.",
            "            expected nova.compute.manager._post_live_migration.",
            "        :param recover_method:",
            "            recovery method when any exception occurs.",
            "            expected nova.compute.manager._rollback_live_migration.",
            "        :param block_migration: if true, do block migration.",
            "        :param migrate_data: a LibvirtLiveMigrateData object",
            "",
            "        This fires off a new thread to run the blocking migration",
            "        operation, and then this thread monitors the progress of",
            "        migration and controls its operation",
            "        \"\"\"",
            "",
            "        guest = self._host.get_guest(instance)",
            "",
            "        disk_paths = []",
            "        device_names = []",
            "        if block_migration:",
            "            disk_paths, device_names = self._live_migration_copy_disk_paths(",
            "                context, instance, guest)",
            "",
            "        # TODO(sahid): We are converting all calls from a",
            "        # virDomain object to use nova.virt.libvirt.Guest.",
            "        # We should be able to remove dom at the end.",
            "        dom = guest._domain",
            "",
            "        opthread = utils.spawn(self._live_migration_operation,",
            "                                     context, instance, dest,",
            "                                     block_migration,",
            "                                     migrate_data, dom,",
            "                                     device_names)",
            "",
            "        finish_event = eventlet.event.Event()",
            "",
            "        def thread_finished(thread, event):",
            "            LOG.debug(\"Migration operation thread notification\",",
            "                      instance=instance)",
            "            event.send()",
            "        opthread.link(thread_finished, finish_event)",
            "",
            "        # Let eventlet schedule the new thread right away",
            "        time.sleep(0)",
            "",
            "        try:",
            "            LOG.debug(\"Starting monitoring of live migration\",",
            "                      instance=instance)",
            "            self._live_migration_monitor(context, instance, guest, dest,",
            "                                         post_method, recover_method,",
            "                                         block_migration, migrate_data,",
            "                                         dom, finish_event, disk_paths)",
            "        except Exception as ex:",
            "            LOG.warn(_LW(\"Error monitoring migration: %(ex)s\"),",
            "                     {\"ex\": ex}, instance=instance, exc_info=True)",
            "            raise",
            "        finally:",
            "            LOG.debug(\"Live migration monitoring is all done\",",
            "                      instance=instance)",
            "",
            "    def live_migration_force_complete(self, instance):",
            "        # NOTE(pkoniszewski): currently only pause during live migration is",
            "        # supported to force live migration to complete, so just try to pause",
            "        # the instance",
            "        self.pause(instance)",
            "",
            "    def _try_fetch_image(self, context, path, image_id, instance,",
            "                         fallback_from_host=None):",
            "        try:",
            "            libvirt_utils.fetch_image(context, path,",
            "                                      image_id,",
            "                                      instance.user_id,",
            "                                      instance.project_id)",
            "        except exception.ImageNotFound:",
            "            if not fallback_from_host:",
            "                raise",
            "            LOG.debug(\"Image %(image_id)s doesn't exist anymore on \"",
            "                      \"image service, attempting to copy image \"",
            "                      \"from %(host)s\",",
            "                      {'image_id': image_id, 'host': fallback_from_host})",
            "            libvirt_utils.copy_image(src=path, dest=path,",
            "                                     host=fallback_from_host,",
            "                                     receive=True)",
            "",
            "    def _fetch_instance_kernel_ramdisk(self, context, instance,",
            "                                       fallback_from_host=None):",
            "        \"\"\"Download kernel and ramdisk for instance in instance directory.\"\"\"",
            "        instance_dir = libvirt_utils.get_instance_path(instance)",
            "        if instance.kernel_id:",
            "            kernel_path = os.path.join(instance_dir, 'kernel')",
            "            # NOTE(dsanders): only fetch image if it's not available at",
            "            # kernel_path. This also avoids ImageNotFound exception if",
            "            # the image has been deleted from glance",
            "            if not os.path.exists(kernel_path):",
            "                self._try_fetch_image(context,",
            "                                      kernel_path,",
            "                                      instance.kernel_id,",
            "                                      instance, fallback_from_host)",
            "            if instance.ramdisk_id:",
            "                ramdisk_path = os.path.join(instance_dir, 'ramdisk')",
            "                # NOTE(dsanders): only fetch image if it's not available at",
            "                # ramdisk_path. This also avoids ImageNotFound exception if",
            "                # the image has been deleted from glance",
            "                if not os.path.exists(ramdisk_path):",
            "                    self._try_fetch_image(context,",
            "                                          ramdisk_path,",
            "                                          instance.ramdisk_id,",
            "                                          instance, fallback_from_host)",
            "",
            "    def rollback_live_migration_at_destination(self, context, instance,",
            "                                               network_info,",
            "                                               block_device_info,",
            "                                               destroy_disks=True,",
            "                                               migrate_data=None):",
            "        \"\"\"Clean up destination node after a failed live migration.\"\"\"",
            "        try:",
            "            self.destroy(context, instance, network_info, block_device_info,",
            "                         destroy_disks, migrate_data)",
            "        finally:",
            "            # NOTE(gcb): Failed block live migration may leave instance",
            "            # directory at destination node, ensure it is always deleted.",
            "            is_shared_instance_path = True",
            "            if migrate_data:",
            "                is_shared_instance_path = migrate_data.is_shared_instance_path",
            "            if not is_shared_instance_path:",
            "                instance_dir = libvirt_utils.get_instance_path_at_destination(",
            "                    instance, migrate_data)",
            "                if os.path.exists(instance_dir):",
            "                        shutil.rmtree(instance_dir)",
            "",
            "    def pre_live_migration(self, context, instance, block_device_info,",
            "                           network_info, disk_info, migrate_data=None):",
            "        \"\"\"Preparation live migration.\"\"\"",
            "        if disk_info is not None:",
            "            disk_info = jsonutils.loads(disk_info)",
            "",
            "        # Steps for volume backed instance live migration w/o shared storage.",
            "        is_shared_block_storage = True",
            "        is_shared_instance_path = True",
            "        is_block_migration = True",
            "        if migrate_data:",
            "            if not isinstance(migrate_data, migrate_data_obj.LiveMigrateData):",
            "                obj = objects.LibvirtLiveMigrateData()",
            "                obj.from_legacy_dict(migrate_data)",
            "                migrate_data = obj",
            "            LOG.debug('migrate_data in pre_live_migration: %s', migrate_data,",
            "                      instance=instance)",
            "            is_shared_block_storage = migrate_data.is_shared_block_storage",
            "            is_shared_instance_path = migrate_data.is_shared_instance_path",
            "            is_block_migration = migrate_data.block_migration",
            "",
            "        if configdrive.required_by(instance):",
            "                # NOTE(sileht): configdrive is stored into the block storage",
            "                # kvm is a block device, live migration will work",
            "                # NOTE(sileht): the configdrive is stored into a shared path",
            "                # kvm don't need to migrate it, live migration will work",
            "                # NOTE(dims): Using config drive with iso format does not work",
            "                # because of a bug in libvirt with read only devices. However",
            "                # one can use vfat as config_drive_format which works fine.",
            "                # Please see bug/1246201 for details on the libvirt bug.",
            "            if (is_shared_block_storage or",
            "                is_shared_instance_path or",
            "                CONF.config_drive_format == 'vfat'):",
            "                pass",
            "            else:",
            "                raise exception.NoLiveMigrationForConfigDriveInLibVirt()",
            "",
            "        if not is_shared_instance_path:",
            "            instance_dir = libvirt_utils.get_instance_path_at_destination(",
            "                            instance, migrate_data)",
            "",
            "            if os.path.exists(instance_dir):",
            "                raise exception.DestinationDiskExists(path=instance_dir)",
            "",
            "            LOG.debug('Creating instance directory: %s', instance_dir,",
            "                      instance=instance)",
            "            os.mkdir(instance_dir)",
            "",
            "            # Recreate the disk.info file and in doing so stop the",
            "            # imagebackend from recreating it incorrectly by inspecting the",
            "            # contents of each file when using the Raw backend.",
            "            if disk_info:",
            "                image_disk_info = {}",
            "                for info in disk_info:",
            "                    image_file = os.path.basename(info['path'])",
            "                    image_path = os.path.join(instance_dir, image_file)",
            "                    image_disk_info[image_path] = info['type']",
            "",
            "                LOG.debug('Creating disk.info with the contents: %s',",
            "                          image_disk_info, instance=instance)",
            "",
            "                image_disk_info_path = os.path.join(instance_dir,",
            "                                                    'disk.info')",
            "                libvirt_utils.write_to_file(image_disk_info_path,",
            "                                            jsonutils.dumps(image_disk_info))",
            "",
            "            if not is_shared_block_storage:",
            "                # Ensure images and backing files are present.",
            "                LOG.debug('Checking to make sure images and backing files are '",
            "                          'present before live migration.', instance=instance)",
            "                self._create_images_and_backing(",
            "                    context, instance, instance_dir, disk_info,",
            "                    fallback_from_host=instance.host)",
            "",
            "            if not is_block_migration:",
            "                # NOTE(angdraug): when block storage is shared between source",
            "                # and destination and instance path isn't (e.g. volume backed",
            "                # or rbd backed instance), instance path on destination has to",
            "                # be prepared",
            "",
            "                # Touch the console.log file, required by libvirt.",
            "                console_file = self._get_console_log_path(instance)",
            "                LOG.debug('Touch instance console log: %s', console_file,",
            "                          instance=instance)",
            "                libvirt_utils.file_open(console_file, 'a').close()",
            "",
            "                # if image has kernel and ramdisk, just download",
            "                # following normal way.",
            "                self._fetch_instance_kernel_ramdisk(context, instance)",
            "",
            "        # Establishing connection to volume server.",
            "        block_device_mapping = driver.block_device_info_get_mapping(",
            "            block_device_info)",
            "",
            "        if len(block_device_mapping):",
            "            LOG.debug('Connecting volumes before live migration.',",
            "                      instance=instance)",
            "",
            "        for bdm in block_device_mapping:",
            "            connection_info = bdm['connection_info']",
            "            disk_info = blockinfo.get_info_from_bdm(",
            "                instance, CONF.libvirt.virt_type,",
            "                instance.image_meta, bdm)",
            "            self._connect_volume(connection_info, disk_info)",
            "",
            "        # We call plug_vifs before the compute manager calls",
            "        # ensure_filtering_rules_for_instance, to ensure bridge is set up",
            "        # Retry operation is necessary because continuously request comes,",
            "        # concurrent request occurs to iptables, then it complains.",
            "        LOG.debug('Plugging VIFs before live migration.', instance=instance)",
            "        max_retry = CONF.live_migration_retry_count",
            "        for cnt in range(max_retry):",
            "            try:",
            "                self.plug_vifs(instance, network_info)",
            "                break",
            "            except processutils.ProcessExecutionError:",
            "                if cnt == max_retry - 1:",
            "                    raise",
            "                else:",
            "                    LOG.warn(_LW('plug_vifs() failed %(cnt)d. Retry up to '",
            "                                 '%(max_retry)d.'),",
            "                             {'cnt': cnt,",
            "                              'max_retry': max_retry},",
            "                             instance=instance)",
            "                    greenthread.sleep(1)",
            "",
            "        # Store vncserver_listen and latest disk device info",
            "        if not migrate_data:",
            "            migrate_data = objects.LibvirtLiveMigrateData(bdms=[])",
            "        else:",
            "            migrate_data.bdms = []",
            "        migrate_data.graphics_listen_addr_vnc = CONF.vnc.vncserver_listen",
            "        migrate_data.graphics_listen_addr_spice = CONF.spice.server_listen",
            "        migrate_data.serial_listen_addr = \\",
            "            CONF.serial_console.proxyclient_address",
            "        # Store live_migration_inbound_addr",
            "        migrate_data.target_connect_addr = \\",
            "            CONF.libvirt.live_migration_inbound_addr",
            "",
            "        for vol in block_device_mapping:",
            "            connection_info = vol['connection_info']",
            "            if connection_info.get('serial'):",
            "                disk_info = blockinfo.get_info_from_bdm(",
            "                    instance, CONF.libvirt.virt_type,",
            "                    instance.image_meta, vol)",
            "",
            "                bdmi = objects.LibvirtLiveMigrateBDMInfo()",
            "                bdmi.serial = connection_info['serial']",
            "                bdmi.connection_info = connection_info",
            "                bdmi.bus = disk_info['bus']",
            "                bdmi.dev = disk_info['dev']",
            "                bdmi.type = disk_info['type']",
            "                bdmi.format = disk_info.get('format')",
            "                bdmi.boot_index = disk_info.get('boot_index')",
            "                migrate_data.bdms.append(bdmi)",
            "",
            "        return migrate_data",
            "",
            "    def _try_fetch_image_cache(self, image, fetch_func, context, filename,",
            "                               image_id, instance, size,",
            "                               fallback_from_host=None):",
            "        try:",
            "            image.cache(fetch_func=fetch_func,",
            "                        context=context,",
            "                        filename=filename,",
            "                        image_id=image_id,",
            "                        user_id=instance.user_id,",
            "                        project_id=instance.project_id,",
            "                        size=size)",
            "        except exception.ImageNotFound:",
            "            if not fallback_from_host:",
            "                raise",
            "            LOG.debug(\"Image %(image_id)s doesn't exist anymore \"",
            "                      \"on image service, attempting to copy \"",
            "                      \"image from %(host)s\",",
            "                      {'image_id': image_id, 'host': fallback_from_host},",
            "                      instance=instance)",
            "",
            "            def copy_from_host(target, max_size):",
            "                libvirt_utils.copy_image(src=target,",
            "                                         dest=target,",
            "                                         host=fallback_from_host,",
            "                                         receive=True)",
            "            image.cache(fetch_func=copy_from_host,",
            "                        filename=filename)",
            "",
            "    def _create_images_and_backing(self, context, instance, instance_dir,",
            "                                   disk_info, fallback_from_host=None):",
            "        \"\"\":param context: security context",
            "           :param instance:",
            "               nova.db.sqlalchemy.models.Instance object",
            "               instance object that is migrated.",
            "           :param instance_dir:",
            "               instance path to use, calculated externally to handle block",
            "               migrating an instance with an old style instance path",
            "           :param disk_info:",
            "               disk info specified in _get_instance_disk_info (list of dicts)",
            "           :param fallback_from_host:",
            "               host where we can retrieve images if the glance images are",
            "               not available.",
            "",
            "        \"\"\"",
            "        if not disk_info:",
            "            disk_info = []",
            "",
            "        for info in disk_info:",
            "            base = os.path.basename(info['path'])",
            "            # Get image type and create empty disk image, and",
            "            # create backing file in case of qcow2.",
            "            instance_disk = os.path.join(instance_dir, base)",
            "            if not info['backing_file'] and not os.path.exists(instance_disk):",
            "                libvirt_utils.create_image(info['type'], instance_disk,",
            "                                           info['virt_disk_size'])",
            "            elif info['backing_file']:",
            "                # Creating backing file follows same way as spawning instances.",
            "                cache_name = os.path.basename(info['backing_file'])",
            "",
            "                image = self.image_backend.image(instance,",
            "                                                 instance_disk,",
            "                                                 CONF.libvirt.images_type)",
            "                if cache_name.startswith('ephemeral'):",
            "                    image.cache(fetch_func=self._create_ephemeral,",
            "                                fs_label=cache_name,",
            "                                os_type=instance.os_type,",
            "                                filename=cache_name,",
            "                                size=info['virt_disk_size'],",
            "                                ephemeral_size=instance.ephemeral_gb)",
            "                elif cache_name.startswith('swap'):",
            "                    inst_type = instance.get_flavor()",
            "                    swap_mb = inst_type.swap",
            "                    image.cache(fetch_func=self._create_swap,",
            "                                filename=\"swap_%s\" % swap_mb,",
            "                                size=swap_mb * units.Mi,",
            "                                swap_mb=swap_mb)",
            "                else:",
            "                    self._try_fetch_image_cache(image,",
            "                                                libvirt_utils.fetch_image,",
            "                                                context, cache_name,",
            "                                                instance.image_ref,",
            "                                                instance,",
            "                                                info['virt_disk_size'],",
            "                                                fallback_from_host)",
            "",
            "        # if image has kernel and ramdisk, just download",
            "        # following normal way.",
            "        self._fetch_instance_kernel_ramdisk(",
            "            context, instance, fallback_from_host=fallback_from_host)",
            "",
            "    def post_live_migration(self, context, instance, block_device_info,",
            "                            migrate_data=None):",
            "        # Disconnect from volume server",
            "        block_device_mapping = driver.block_device_info_get_mapping(",
            "                block_device_info)",
            "        connector = self.get_volume_connector(instance)",
            "        volume_api = self._volume_api",
            "        for vol in block_device_mapping:",
            "            # Retrieve connection info from Cinder's initialize_connection API.",
            "            # The info returned will be accurate for the source server.",
            "            volume_id = vol['connection_info']['serial']",
            "            connection_info = volume_api.initialize_connection(context,",
            "                                                               volume_id,",
            "                                                               connector)",
            "",
            "            # TODO(leeantho) The following multipath_id logic is temporary",
            "            # and will be removed in the future once os-brick is updated",
            "            # to handle multipath for drivers in a more efficient way.",
            "            # For now this logic is needed to ensure the connection info",
            "            # data is correct.",
            "",
            "            # Pull out multipath_id from the bdm information. The",
            "            # multipath_id can be placed into the connection info",
            "            # because it is based off of the volume and will be the",
            "            # same on the source and destination hosts.",
            "            if 'multipath_id' in vol['connection_info']['data']:",
            "                multipath_id = vol['connection_info']['data']['multipath_id']",
            "                connection_info['data']['multipath_id'] = multipath_id",
            "",
            "            disk_dev = vol['mount_device'].rpartition(\"/\")[2]",
            "            self._disconnect_volume(connection_info, disk_dev)",
            "",
            "    def post_live_migration_at_source(self, context, instance, network_info):",
            "        \"\"\"Unplug VIFs from networks at source.",
            "",
            "        :param context: security context",
            "        :param instance: instance object reference",
            "        :param network_info: instance network information",
            "        \"\"\"",
            "        self.unplug_vifs(instance, network_info)",
            "",
            "    def post_live_migration_at_destination(self, context,",
            "                                           instance,",
            "                                           network_info,",
            "                                           block_migration=False,",
            "                                           block_device_info=None):",
            "        \"\"\"Post operation of live migration at destination host.",
            "",
            "        :param context: security context",
            "        :param instance:",
            "            nova.db.sqlalchemy.models.Instance object",
            "            instance object that is migrated.",
            "        :param network_info: instance network information",
            "        :param block_migration: if true, post operation of block_migration.",
            "        \"\"\"",
            "        # Define migrated instance, otherwise, suspend/destroy does not work.",
            "        # In case of block migration, destination does not have",
            "        # libvirt.xml",
            "        disk_info = blockinfo.get_disk_info(",
            "            CONF.libvirt.virt_type, instance,",
            "            instance.image_meta, block_device_info)",
            "        xml = self._get_guest_xml(context, instance,",
            "                                  network_info, disk_info,",
            "                                  instance.image_meta,",
            "                                  block_device_info=block_device_info,",
            "                                  write_to_disk=True)",
            "        self._host.write_instance_config(xml)",
            "",
            "    def _get_instance_disk_info(self, instance_name, xml,",
            "                                block_device_info=None):",
            "        \"\"\"Get the non-volume disk information from the domain xml",
            "",
            "        :param str instance_name: the name of the instance (domain)",
            "        :param str xml: the libvirt domain xml for the instance",
            "        :param dict block_device_info: block device info for BDMs",
            "        :returns disk_info: list of dicts with keys:",
            "",
            "          * 'type': the disk type (str)",
            "          * 'path': the disk path (str)",
            "          * 'virt_disk_size': the virtual disk size (int)",
            "          * 'backing_file': backing file of a disk image (str)",
            "          * 'disk_size': physical disk size (int)",
            "          * 'over_committed_disk_size': virt_disk_size - disk_size or 0",
            "        \"\"\"",
            "        block_device_mapping = driver.block_device_info_get_mapping(",
            "            block_device_info)",
            "",
            "        volume_devices = set()",
            "        for vol in block_device_mapping:",
            "            disk_dev = vol['mount_device'].rpartition(\"/\")[2]",
            "            volume_devices.add(disk_dev)",
            "",
            "        disk_info = []",
            "        doc = etree.fromstring(xml)",
            "        disk_nodes = doc.findall('.//devices/disk')",
            "        path_nodes = doc.findall('.//devices/disk/source')",
            "        driver_nodes = doc.findall('.//devices/disk/driver')",
            "        target_nodes = doc.findall('.//devices/disk/target')",
            "",
            "        for cnt, path_node in enumerate(path_nodes):",
            "            disk_type = disk_nodes[cnt].get('type')",
            "            path = path_node.get('file') or path_node.get('dev')",
            "            target = target_nodes[cnt].attrib['dev']",
            "",
            "            if not path:",
            "                LOG.debug('skipping disk for %s as it does not have a path',",
            "                          instance_name)",
            "                continue",
            "",
            "            if disk_type not in ['file', 'block']:",
            "                LOG.debug('skipping disk because it looks like a volume', path)",
            "                continue",
            "",
            "            if target in volume_devices:",
            "                LOG.debug('skipping disk %(path)s (%(target)s) as it is a '",
            "                          'volume', {'path': path, 'target': target})",
            "                continue",
            "",
            "            # get the real disk size or",
            "            # raise a localized error if image is unavailable",
            "            if disk_type == 'file':",
            "                dk_size = int(os.path.getsize(path))",
            "            elif disk_type == 'block' and block_device_info:",
            "                dk_size = lvm.get_volume_size(path)",
            "            else:",
            "                LOG.debug('skipping disk %(path)s (%(target)s) - unable to '",
            "                          'determine if volume',",
            "                          {'path': path, 'target': target})",
            "                continue",
            "",
            "            disk_type = driver_nodes[cnt].get('type')",
            "            if disk_type == \"qcow2\":",
            "                backing_file = libvirt_utils.get_disk_backing_file(path)",
            "                virt_size = disk.get_disk_size(path)",
            "                over_commit_size = int(virt_size) - dk_size",
            "            else:",
            "                backing_file = \"\"",
            "                virt_size = dk_size",
            "                over_commit_size = 0",
            "",
            "            disk_info.append({'type': disk_type,",
            "                              'path': path,",
            "                              'virt_disk_size': virt_size,",
            "                              'backing_file': backing_file,",
            "                              'disk_size': dk_size,",
            "                              'over_committed_disk_size': over_commit_size})",
            "        return disk_info",
            "",
            "    def get_instance_disk_info(self, instance,",
            "                               block_device_info=None):",
            "        try:",
            "            guest = self._host.get_guest(instance)",
            "            xml = guest.get_xml_desc()",
            "        except libvirt.libvirtError as ex:",
            "            error_code = ex.get_error_code()",
            "            LOG.warn(_LW('Error from libvirt while getting description of '",
            "                         '%(instance_name)s: [Error Code %(error_code)s] '",
            "                         '%(ex)s'),",
            "                     {'instance_name': instance.name,",
            "                      'error_code': error_code,",
            "                      'ex': ex},",
            "                     instance=instance)",
            "            raise exception.InstanceNotFound(instance_id=instance.uuid)",
            "",
            "        return jsonutils.dumps(",
            "                self._get_instance_disk_info(instance.name, xml,",
            "                                             block_device_info))",
            "",
            "    def _get_disk_over_committed_size_total(self):",
            "        \"\"\"Return total over committed disk size for all instances.\"\"\"",
            "        # Disk size that all instance uses : virtual_size - disk_size",
            "        disk_over_committed_size = 0",
            "        instance_domains = self._host.list_instance_domains()",
            "        if not instance_domains:",
            "            return disk_over_committed_size",
            "",
            "        # Get all instance uuids",
            "        instance_uuids = [dom.UUIDString() for dom in instance_domains]",
            "        ctx = nova_context.get_admin_context()",
            "        # Get instance object list by uuid filter",
            "        filters = {'uuid': instance_uuids}",
            "        # NOTE(ankit): objects.InstanceList.get_by_filters method is",
            "        # getting called twice one is here and another in the",
            "        # _update_available_resource method of resource_tracker. Since",
            "        # _update_available_resource method is synchronized, there is a",
            "        # possibility the instances list retrieved here to calculate",
            "        # disk_over_committed_size would differ to the list you would get",
            "        # in _update_available_resource method for calculating usages based",
            "        # on instance utilization.",
            "        local_instance_list = objects.InstanceList.get_by_filters(",
            "            ctx, filters, use_slave=True)",
            "        # Convert instance list to dictionary with instace uuid as key.",
            "        local_instances = {inst.uuid: inst for inst in local_instance_list}",
            "",
            "        # Get bdms by instance uuids",
            "        bdms = objects.BlockDeviceMappingList.bdms_by_instance_uuid(",
            "            ctx, instance_uuids)",
            "",
            "        for dom in instance_domains:",
            "            try:",
            "                guest = libvirt_guest.Guest(dom)",
            "                xml = guest.get_xml_desc()",
            "",
            "                block_device_info = None",
            "                if guest.uuid in local_instances:",
            "                    # Get block device info for instance",
            "                    block_device_info = driver.get_block_device_info(",
            "                        local_instances[guest.uuid], bdms[guest.uuid])",
            "",
            "                disk_infos = self._get_instance_disk_info(guest.name, xml,",
            "                                 block_device_info=block_device_info)",
            "",
            "                for info in disk_infos:",
            "                    disk_over_committed_size += int(",
            "                        info['over_committed_disk_size'])",
            "            except libvirt.libvirtError as ex:",
            "                error_code = ex.get_error_code()",
            "                LOG.warn(_LW(",
            "                    'Error from libvirt while getting description of '",
            "                    '%(instance_name)s: [Error Code %(error_code)s] %(ex)s'",
            "                ), {'instance_name': guest.name,",
            "                    'error_code': error_code,",
            "                    'ex': ex})",
            "            except OSError as e:",
            "                if e.errno == errno.ENOENT:",
            "                    LOG.warn(_LW('Periodic task is updating the host stat, '",
            "                                 'it is trying to get disk %(i_name)s, '",
            "                                 'but disk file was removed by concurrent '",
            "                                 'operations such as resize.'),",
            "                                {'i_name': guest.name})",
            "                elif e.errno == errno.EACCES:",
            "                    LOG.warn(_LW('Periodic task is updating the host stat, '",
            "                                 'it is trying to get disk %(i_name)s, '",
            "                                 'but access is denied. It is most likely '",
            "                                 'due to a VM that exists on the compute '",
            "                                 'node but is not managed by Nova.'),",
            "                             {'i_name': guest.name})",
            "                else:",
            "                    raise",
            "            except exception.VolumeBDMPathNotFound as e:",
            "                LOG.warn(_LW('Periodic task is updating the host stats, '",
            "                             'it is trying to get disk info for %(i_name)s, '",
            "                             'but the backing volume block device was removed '",
            "                             'by concurrent operations such as resize. '",
            "                             'Error: %(error)s'),",
            "                         {'i_name': guest.name,",
            "                          'error': e})",
            "            # NOTE(gtt116): give other tasks a chance.",
            "            greenthread.sleep(0)",
            "        return disk_over_committed_size",
            "",
            "    def unfilter_instance(self, instance, network_info):",
            "        \"\"\"See comments of same method in firewall_driver.\"\"\"",
            "        self.firewall_driver.unfilter_instance(instance,",
            "                                               network_info=network_info)",
            "",
            "    def get_available_nodes(self, refresh=False):",
            "        return [self._host.get_hostname()]",
            "",
            "    def get_host_cpu_stats(self):",
            "        \"\"\"Return the current CPU state of the host.\"\"\"",
            "        return self._host.get_cpu_stats()",
            "",
            "    def get_host_uptime(self):",
            "        \"\"\"Returns the result of calling \"uptime\".\"\"\"",
            "        out, err = utils.execute('env', 'LANG=C', 'uptime')",
            "        return out",
            "",
            "    def manage_image_cache(self, context, all_instances):",
            "        \"\"\"Manage the local cache of images.\"\"\"",
            "        self.image_cache_manager.update(context, all_instances)",
            "",
            "    def _cleanup_remote_migration(self, dest, inst_base, inst_base_resize,",
            "                                  shared_storage=False):",
            "        \"\"\"Used only for cleanup in case migrate_disk_and_power_off fails.\"\"\"",
            "        try:",
            "            if os.path.exists(inst_base_resize):",
            "                utils.execute('rm', '-rf', inst_base)",
            "                utils.execute('mv', inst_base_resize, inst_base)",
            "                if not shared_storage:",
            "                    self._remotefs.remove_dir(dest, inst_base)",
            "        except Exception:",
            "            pass",
            "",
            "    def _is_storage_shared_with(self, dest, inst_base):",
            "        # NOTE (rmk): There are two methods of determining whether we are",
            "        #             on the same filesystem: the source and dest IP are the",
            "        #             same, or we create a file on the dest system via SSH",
            "        #             and check whether the source system can also see it.",
            "        shared_storage = (dest == self.get_host_ip_addr())",
            "        if not shared_storage:",
            "            tmp_file = uuid.uuid4().hex + '.tmp'",
            "            tmp_path = os.path.join(inst_base, tmp_file)",
            "",
            "            try:",
            "                self._remotefs.create_file(dest, tmp_path)",
            "                if os.path.exists(tmp_path):",
            "                    shared_storage = True",
            "                    os.unlink(tmp_path)",
            "                else:",
            "                    self._remotefs.remove_file(dest, tmp_path)",
            "            except Exception:",
            "                pass",
            "        return shared_storage",
            "",
            "    def migrate_disk_and_power_off(self, context, instance, dest,",
            "                                   flavor, network_info,",
            "                                   block_device_info=None,",
            "                                   timeout=0, retry_interval=0):",
            "        LOG.debug(\"Starting migrate_disk_and_power_off\",",
            "                   instance=instance)",
            "",
            "        ephemerals = driver.block_device_info_get_ephemerals(block_device_info)",
            "",
            "        # get_bdm_ephemeral_disk_size() will return 0 if the new",
            "        # instance's requested block device mapping contain no",
            "        # ephemeral devices. However, we still want to check if",
            "        # the original instance's ephemeral_gb property was set and",
            "        # ensure that the new requested flavor ephemeral size is greater",
            "        eph_size = (block_device.get_bdm_ephemeral_disk_size(ephemerals) or",
            "                    instance.ephemeral_gb)",
            "",
            "        # Checks if the migration needs a disk resize down.",
            "        root_down = flavor.root_gb < instance.root_gb",
            "        ephemeral_down = flavor.ephemeral_gb < eph_size",
            "        disk_info_text = self.get_instance_disk_info(",
            "            instance, block_device_info=block_device_info)",
            "        booted_from_volume = self._is_booted_from_volume(instance,",
            "                                                         disk_info_text)",
            "        if (root_down and not booted_from_volume) or ephemeral_down:",
            "            reason = _(\"Unable to resize disk down.\")",
            "            raise exception.InstanceFaultRollback(",
            "                exception.ResizeError(reason=reason))",
            "",
            "        disk_info = jsonutils.loads(disk_info_text)",
            "",
            "        # NOTE(dgenin): Migration is not implemented for LVM backed instances.",
            "        if CONF.libvirt.images_type == 'lvm' and not booted_from_volume:",
            "            reason = _(\"Migration is not supported for LVM backed instances\")",
            "            raise exception.InstanceFaultRollback(",
            "                exception.MigrationPreCheckError(reason=reason))",
            "",
            "        # copy disks to destination",
            "        # rename instance dir to +_resize at first for using",
            "        # shared storage for instance dir (eg. NFS).",
            "        inst_base = libvirt_utils.get_instance_path(instance)",
            "        inst_base_resize = inst_base + \"_resize\"",
            "        shared_storage = self._is_storage_shared_with(dest, inst_base)",
            "",
            "        # try to create the directory on the remote compute node",
            "        # if this fails we pass the exception up the stack so we can catch",
            "        # failures here earlier",
            "        if not shared_storage:",
            "            try:",
            "                self._remotefs.create_dir(dest, inst_base)",
            "            except processutils.ProcessExecutionError as e:",
            "                reason = _(\"not able to execute ssh command: %s\") % e",
            "                raise exception.InstanceFaultRollback(",
            "                    exception.ResizeError(reason=reason))",
            "",
            "        self.power_off(instance, timeout, retry_interval)",
            "",
            "        block_device_mapping = driver.block_device_info_get_mapping(",
            "            block_device_info)",
            "        for vol in block_device_mapping:",
            "            connection_info = vol['connection_info']",
            "            disk_dev = vol['mount_device'].rpartition(\"/\")[2]",
            "            self._disconnect_volume(connection_info, disk_dev)",
            "",
            "        try:",
            "            utils.execute('mv', inst_base, inst_base_resize)",
            "            # if we are migrating the instance with shared storage then",
            "            # create the directory.  If it is a remote node the directory",
            "            # has already been created",
            "            if shared_storage:",
            "                dest = None",
            "                utils.execute('mkdir', '-p', inst_base)",
            "",
            "            active_flavor = instance.get_flavor()",
            "            for info in disk_info:",
            "                # assume inst_base == dirname(info['path'])",
            "                img_path = info['path']",
            "                fname = os.path.basename(img_path)",
            "                from_path = os.path.join(inst_base_resize, fname)",
            "",
            "                # To properly resize the swap partition, it must be",
            "                # re-created with the proper size.  This is acceptable",
            "                # because when an OS is shut down, the contents of the",
            "                # swap space are just garbage, the OS doesn't bother about",
            "                # what is in it.",
            "",
            "                # We will not copy over the swap disk here, and rely on",
            "                # finish_migration/_create_image to re-create it for us.",
            "                if not (fname == 'disk.swap' and",
            "                    active_flavor.get('swap', 0) != flavor.get('swap', 0)):",
            "",
            "                    on_execute = lambda process: self.job_tracker.add_job(",
            "                        instance, process.pid)",
            "                    on_completion = lambda process: self.job_tracker.\\",
            "                        remove_job(instance, process.pid)",
            "                    compression = info['type'] not in NO_COMPRESSION_TYPES",
            "                    libvirt_utils.copy_image(from_path, img_path, host=dest,",
            "                                             on_execute=on_execute,",
            "                                             on_completion=on_completion,",
            "                                             compression=compression)",
            "",
            "            # Ensure disk.info is written to the new path to avoid disks being",
            "            # reinspected and potentially changing format.",
            "            src_disk_info_path = os.path.join(inst_base_resize, 'disk.info')",
            "            dst_disk_info_path = os.path.join(inst_base, 'disk.info')",
            "            libvirt_utils.copy_image(src_disk_info_path, dst_disk_info_path,",
            "                                     host=dest, on_execute=on_execute,",
            "                                     on_completion=on_completion,",
            "                                     compression=compression)",
            "        except Exception:",
            "            with excutils.save_and_reraise_exception():",
            "                self._cleanup_remote_migration(dest, inst_base,",
            "                                               inst_base_resize,",
            "                                               shared_storage)",
            "",
            "        return disk_info_text",
            "",
            "    def _wait_for_running(self, instance):",
            "        state = self.get_info(instance).state",
            "",
            "        if state == power_state.RUNNING:",
            "            LOG.info(_LI(\"Instance running successfully.\"), instance=instance)",
            "            raise loopingcall.LoopingCallDone()",
            "",
            "    @staticmethod",
            "    def _disk_size_from_instance(instance, info):",
            "        \"\"\"Determines the disk size from instance properties",
            "",
            "        Returns the disk size by using the disk name to determine whether it",
            "        is a root or an ephemeral disk, then by checking properties of the",
            "        instance returns the size converted to bytes.",
            "",
            "        Returns 0 if the disk name not match (disk, disk.local).",
            "        \"\"\"",
            "        fname = os.path.basename(info['path'])",
            "        if fname == 'disk':",
            "            size = instance.root_gb",
            "        elif fname == 'disk.local':",
            "            size = instance.ephemeral_gb",
            "        else:",
            "            size = 0",
            "        return size * units.Gi",
            "",
            "    @staticmethod",
            "    def _disk_raw_to_qcow2(path):",
            "        \"\"\"Converts a raw disk to qcow2.\"\"\"",
            "        path_qcow = path + '_qcow'",
            "        utils.execute('qemu-img', 'convert', '-f', 'raw',",
            "                      '-O', 'qcow2', path, path_qcow)",
            "        utils.execute('mv', path_qcow, path)",
            "",
            "    @staticmethod",
            "    def _disk_qcow2_to_raw(path):",
            "        \"\"\"Converts a qcow2 disk to raw.\"\"\"",
            "        path_raw = path + '_raw'",
            "        utils.execute('qemu-img', 'convert', '-f', 'qcow2',",
            "                      '-O', 'raw', path, path_raw)",
            "        utils.execute('mv', path_raw, path)",
            "",
            "    def _disk_resize(self, image, size):",
            "        \"\"\"Attempts to resize a disk to size",
            "",
            "        :param image: an instance of nova.virt.image.model.Image",
            "",
            "        Attempts to resize a disk by checking the capabilities and",
            "        preparing the format, then calling disk.api.extend.",
            "",
            "        Note: Currently only support disk extend.",
            "        \"\"\"",
            "",
            "        if not isinstance(image, imgmodel.LocalFileImage):",
            "            LOG.debug(\"Skipping resize of non-local image\")",
            "            return",
            "",
            "        # If we have a non partitioned image that we can extend",
            "        # then ensure we're in 'raw' format so we can extend file system.",
            "        converted = False",
            "        if (size and",
            "            image.format == imgmodel.FORMAT_QCOW2 and",
            "            disk.can_resize_image(image.path, size) and",
            "            disk.is_image_extendable(image)):",
            "            self._disk_qcow2_to_raw(image.path)",
            "            converted = True",
            "            image = imgmodel.LocalFileImage(image.path,",
            "                                            imgmodel.FORMAT_RAW)",
            "",
            "        if size:",
            "            disk.extend(image, size)",
            "",
            "        if converted:",
            "            # back to qcow2 (no backing_file though) so that snapshot",
            "            # will be available",
            "            self._disk_raw_to_qcow2(image.path)",
            "",
            "    def finish_migration(self, context, migration, instance, disk_info,",
            "                         network_info, image_meta, resize_instance,",
            "                         block_device_info=None, power_on=True):",
            "        LOG.debug(\"Starting finish_migration\", instance=instance)",
            "",
            "        # resize disks. only \"disk\" and \"disk.local\" are necessary.",
            "        disk_info = jsonutils.loads(disk_info)",
            "        for info in disk_info:",
            "            size = self._disk_size_from_instance(instance, info)",
            "            if resize_instance:",
            "                image = imgmodel.LocalFileImage(info['path'],",
            "                                                info['type'])",
            "                self._disk_resize(image, size)",
            "            if info['type'] == 'raw' and CONF.use_cow_images:",
            "                self._disk_raw_to_qcow2(info['path'])",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            image_meta,",
            "                                            block_device_info)",
            "        # assume _create_image do nothing if a target file exists.",
            "        self._create_image(context, instance, disk_info['mapping'],",
            "                           network_info=network_info,",
            "                           block_device_info=None, inject_files=False,",
            "                           fallback_from_host=migration.source_compute)",
            "        xml = self._get_guest_xml(context, instance, network_info, disk_info,",
            "                                  image_meta,",
            "                                  block_device_info=block_device_info,",
            "                                  write_to_disk=True)",
            "        # NOTE(mriedem): vifs_already_plugged=True here, regardless of whether",
            "        # or not we've migrated to another host, because we unplug VIFs locally",
            "        # and the status change in the port might go undetected by the neutron",
            "        # L2 agent (or neutron server) so neutron may not know that the VIF was",
            "        # unplugged in the first place and never send an event.",
            "        self._create_domain_and_network(context, xml, instance, network_info,",
            "                                        disk_info,",
            "                                        block_device_info=block_device_info,",
            "                                        power_on=power_on,",
            "                                        vifs_already_plugged=True)",
            "        if power_on:",
            "            timer = loopingcall.FixedIntervalLoopingCall(",
            "                                                    self._wait_for_running,",
            "                                                    instance)",
            "            timer.start(interval=0.5).wait()",
            "",
            "        LOG.debug(\"finish_migration finished successfully.\", instance=instance)",
            "",
            "    def _cleanup_failed_migration(self, inst_base):",
            "        \"\"\"Make sure that a failed migrate doesn't prevent us from rolling",
            "        back in a revert.",
            "        \"\"\"",
            "        try:",
            "            shutil.rmtree(inst_base)",
            "        except OSError as e:",
            "            if e.errno != errno.ENOENT:",
            "                raise",
            "",
            "    def finish_revert_migration(self, context, instance, network_info,",
            "                                block_device_info=None, power_on=True):",
            "        LOG.debug(\"Starting finish_revert_migration\",",
            "                  instance=instance)",
            "",
            "        inst_base = libvirt_utils.get_instance_path(instance)",
            "        inst_base_resize = inst_base + \"_resize\"",
            "",
            "        # NOTE(danms): if we're recovering from a failed migration,",
            "        # make sure we don't have a left-over same-host base directory",
            "        # that would conflict. Also, don't fail on the rename if the",
            "        # failure happened early.",
            "        if os.path.exists(inst_base_resize):",
            "            self._cleanup_failed_migration(inst_base)",
            "            utils.execute('mv', inst_base_resize, inst_base)",
            "",
            "        backend = self.image_backend.image(instance, 'disk')",
            "        # Once we rollback, the snapshot is no longer needed, so remove it",
            "        # TODO(nic): Remove the try/except/finally in a future release",
            "        # To avoid any upgrade issues surrounding instances being in pending",
            "        # resize state when the software is updated, this portion of the",
            "        # method logs exceptions rather than failing on them.  Once it can be",
            "        # reasonably assumed that no such instances exist in the wild",
            "        # anymore, the try/except/finally should be removed,",
            "        # and ignore_errors should be set back to False (the default) so",
            "        # that problems throw errors, like they should.",
            "        try:",
            "            backend.rollback_to_snap(libvirt_utils.RESIZE_SNAPSHOT_NAME)",
            "        except exception.SnapshotNotFound:",
            "            LOG.warning(_LW(\"Failed to rollback snapshot (%s)\"),",
            "                        libvirt_utils.RESIZE_SNAPSHOT_NAME)",
            "        finally:",
            "            backend.remove_snap(libvirt_utils.RESIZE_SNAPSHOT_NAME,",
            "                                ignore_errors=True)",
            "",
            "        disk_info = blockinfo.get_disk_info(CONF.libvirt.virt_type,",
            "                                            instance,",
            "                                            instance.image_meta,",
            "                                            block_device_info)",
            "        xml = self._get_guest_xml(context, instance, network_info, disk_info,",
            "                                  instance.image_meta,",
            "                                  block_device_info=block_device_info)",
            "        self._create_domain_and_network(context, xml, instance, network_info,",
            "                                        disk_info,",
            "                                        block_device_info=block_device_info,",
            "                                        power_on=power_on,",
            "                                        vifs_already_plugged=True)",
            "",
            "        if power_on:",
            "            timer = loopingcall.FixedIntervalLoopingCall(",
            "                                                    self._wait_for_running,",
            "                                                    instance)",
            "            timer.start(interval=0.5).wait()",
            "",
            "        LOG.debug(\"finish_revert_migration finished successfully.\",",
            "                  instance=instance)",
            "",
            "    def confirm_migration(self, migration, instance, network_info):",
            "        \"\"\"Confirms a resize, destroying the source VM.\"\"\"",
            "        self._cleanup_resize(instance, network_info)",
            "",
            "    @staticmethod",
            "    def _get_io_devices(xml_doc):",
            "        \"\"\"get the list of io devices from the xml document.\"\"\"",
            "        result = {\"volumes\": [], \"ifaces\": []}",
            "        try:",
            "            doc = etree.fromstring(xml_doc)",
            "        except Exception:",
            "            return result",
            "        blocks = [('./devices/disk', 'volumes'),",
            "            ('./devices/interface', 'ifaces')]",
            "        for block, key in blocks:",
            "            section = doc.findall(block)",
            "            for node in section:",
            "                for child in node.getchildren():",
            "                    if child.tag == 'target' and child.get('dev'):",
            "                        result[key].append(child.get('dev'))",
            "        return result",
            "",
            "    def get_diagnostics(self, instance):",
            "        guest = self._host.get_guest(instance)",
            "",
            "        # TODO(sahid): We are converting all calls from a",
            "        # virDomain object to use nova.virt.libvirt.Guest.",
            "        # We should be able to remove domain at the end.",
            "        domain = guest._domain",
            "        output = {}",
            "        # get cpu time, might launch an exception if the method",
            "        # is not supported by the underlying hypervisor being",
            "        # used by libvirt",
            "        try:",
            "            for vcpu in guest.get_vcpus_info():",
            "                output[\"cpu\" + str(vcpu.id) + \"_time\"] = vcpu.time",
            "        except libvirt.libvirtError:",
            "            pass",
            "        # get io status",
            "        xml = guest.get_xml_desc()",
            "        dom_io = LibvirtDriver._get_io_devices(xml)",
            "        for guest_disk in dom_io[\"volumes\"]:",
            "            try:",
            "                # blockStats might launch an exception if the method",
            "                # is not supported by the underlying hypervisor being",
            "                # used by libvirt",
            "                stats = domain.blockStats(guest_disk)",
            "                output[guest_disk + \"_read_req\"] = stats[0]",
            "                output[guest_disk + \"_read\"] = stats[1]",
            "                output[guest_disk + \"_write_req\"] = stats[2]",
            "                output[guest_disk + \"_write\"] = stats[3]",
            "                output[guest_disk + \"_errors\"] = stats[4]",
            "            except libvirt.libvirtError:",
            "                pass",
            "        for interface in dom_io[\"ifaces\"]:",
            "            try:",
            "                # interfaceStats might launch an exception if the method",
            "                # is not supported by the underlying hypervisor being",
            "                # used by libvirt",
            "                stats = domain.interfaceStats(interface)",
            "                output[interface + \"_rx\"] = stats[0]",
            "                output[interface + \"_rx_packets\"] = stats[1]",
            "                output[interface + \"_rx_errors\"] = stats[2]",
            "                output[interface + \"_rx_drop\"] = stats[3]",
            "                output[interface + \"_tx\"] = stats[4]",
            "                output[interface + \"_tx_packets\"] = stats[5]",
            "                output[interface + \"_tx_errors\"] = stats[6]",
            "                output[interface + \"_tx_drop\"] = stats[7]",
            "            except libvirt.libvirtError:",
            "                pass",
            "        output[\"memory\"] = domain.maxMemory()",
            "        # memoryStats might launch an exception if the method",
            "        # is not supported by the underlying hypervisor being",
            "        # used by libvirt",
            "        try:",
            "            mem = domain.memoryStats()",
            "            for key in mem.keys():",
            "                output[\"memory-\" + key] = mem[key]",
            "        except (libvirt.libvirtError, AttributeError):",
            "            pass",
            "        return output",
            "",
            "    def get_instance_diagnostics(self, instance):",
            "        guest = self._host.get_guest(instance)",
            "",
            "        # TODO(sahid): We are converting all calls from a",
            "        # virDomain object to use nova.virt.libvirt.Guest.",
            "        # We should be able to remove domain at the end.",
            "        domain = guest._domain",
            "",
            "        xml = guest.get_xml_desc()",
            "        xml_doc = etree.fromstring(xml)",
            "",
            "        # TODO(sahid): Needs to use get_info but more changes have to",
            "        # be done since a mapping STATE_MAP LIBVIRT_POWER_STATE is",
            "        # needed.",
            "        (state, max_mem, mem, num_cpu, cpu_time) = \\",
            "            guest._get_domain_info(self._host)",
            "        config_drive = configdrive.required_by(instance)",
            "        launched_at = timeutils.normalize_time(instance.launched_at)",
            "        uptime = timeutils.delta_seconds(launched_at,",
            "                                         timeutils.utcnow())",
            "        diags = diagnostics.Diagnostics(state=power_state.STATE_MAP[state],",
            "                                        driver='libvirt',",
            "                                        config_drive=config_drive,",
            "                                        hypervisor_os='linux',",
            "                                        uptime=uptime)",
            "        diags.memory_details.maximum = max_mem / units.Mi",
            "        diags.memory_details.used = mem / units.Mi",
            "",
            "        # get cpu time, might launch an exception if the method",
            "        # is not supported by the underlying hypervisor being",
            "        # used by libvirt",
            "        try:",
            "            for vcpu in guest.get_vcpus_info():",
            "                diags.add_cpu(time=vcpu.time)",
            "        except libvirt.libvirtError:",
            "            pass",
            "        # get io status",
            "        dom_io = LibvirtDriver._get_io_devices(xml)",
            "        for guest_disk in dom_io[\"volumes\"]:",
            "            try:",
            "                # blockStats might launch an exception if the method",
            "                # is not supported by the underlying hypervisor being",
            "                # used by libvirt",
            "                stats = domain.blockStats(guest_disk)",
            "                diags.add_disk(read_bytes=stats[1],",
            "                               read_requests=stats[0],",
            "                               write_bytes=stats[3],",
            "                               write_requests=stats[2])",
            "            except libvirt.libvirtError:",
            "                pass",
            "        for interface in dom_io[\"ifaces\"]:",
            "            try:",
            "                # interfaceStats might launch an exception if the method",
            "                # is not supported by the underlying hypervisor being",
            "                # used by libvirt",
            "                stats = domain.interfaceStats(interface)",
            "                diags.add_nic(rx_octets=stats[0],",
            "                              rx_errors=stats[2],",
            "                              rx_drop=stats[3],",
            "                              rx_packets=stats[1],",
            "                              tx_octets=stats[4],",
            "                              tx_errors=stats[6],",
            "                              tx_drop=stats[7],",
            "                              tx_packets=stats[5])",
            "            except libvirt.libvirtError:",
            "                pass",
            "",
            "        # Update mac addresses of interface if stats have been reported",
            "        if diags.nic_details:",
            "            nodes = xml_doc.findall('./devices/interface/mac')",
            "            for index, node in enumerate(nodes):",
            "                diags.nic_details[index].mac_address = node.get('address')",
            "        return diags",
            "",
            "    def instance_on_disk(self, instance):",
            "        # ensure directories exist and are writable",
            "        instance_path = libvirt_utils.get_instance_path(instance)",
            "        LOG.debug('Checking instance files accessibility %s', instance_path,",
            "                  instance=instance)",
            "        shared_instance_path = os.access(instance_path, os.W_OK)",
            "        # NOTE(flwang): For shared block storage scenario, the file system is",
            "        # not really shared by the two hosts, but the volume of evacuated",
            "        # instance is reachable.",
            "        shared_block_storage = (self.image_backend.backend().",
            "                                is_shared_block_storage())",
            "        return shared_instance_path or shared_block_storage",
            "",
            "    def inject_network_info(self, instance, nw_info):",
            "        self.firewall_driver.setup_basic_filtering(instance, nw_info)",
            "",
            "    def delete_instance_files(self, instance):",
            "        target = libvirt_utils.get_instance_path(instance)",
            "        # A resize may be in progress",
            "        target_resize = target + '_resize'",
            "        # Other threads may attempt to rename the path, so renaming the path",
            "        # to target + '_del' (because it is atomic) and iterating through",
            "        # twice in the unlikely event that a concurrent rename occurs between",
            "        # the two rename attempts in this method. In general this method",
            "        # should be fairly thread-safe without these additional checks, since",
            "        # other operations involving renames are not permitted when the task",
            "        # state is not None and the task state should be set to something",
            "        # other than None by the time this method is invoked.",
            "        target_del = target + '_del'",
            "        for i in six.moves.range(2):",
            "            try:",
            "                utils.execute('mv', target, target_del)",
            "                break",
            "            except Exception:",
            "                pass",
            "            try:",
            "                utils.execute('mv', target_resize, target_del)",
            "                break",
            "            except Exception:",
            "                pass",
            "        # Either the target or target_resize path may still exist if all",
            "        # rename attempts failed.",
            "        remaining_path = None",
            "        for p in (target, target_resize):",
            "            if os.path.exists(p):",
            "                remaining_path = p",
            "                break",
            "",
            "        # A previous delete attempt may have been interrupted, so target_del",
            "        # may exist even if all rename attempts during the present method",
            "        # invocation failed due to the absence of both target and",
            "        # target_resize.",
            "        if not remaining_path and os.path.exists(target_del):",
            "            self.job_tracker.terminate_jobs(instance)",
            "",
            "            LOG.info(_LI('Deleting instance files %s'), target_del,",
            "                     instance=instance)",
            "            remaining_path = target_del",
            "            try:",
            "                shutil.rmtree(target_del)",
            "            except OSError as e:",
            "                LOG.error(_LE('Failed to cleanup directory %(target)s: '",
            "                              '%(e)s'), {'target': target_del, 'e': e},",
            "                            instance=instance)",
            "",
            "        # It is possible that the delete failed, if so don't mark the instance",
            "        # as cleaned.",
            "        if remaining_path and os.path.exists(remaining_path):",
            "            LOG.info(_LI('Deletion of %s failed'), remaining_path,",
            "                     instance=instance)",
            "            return False",
            "",
            "        LOG.info(_LI('Deletion of %s complete'), target_del, instance=instance)",
            "        return True",
            "",
            "    @property",
            "    def need_legacy_block_device_info(self):",
            "        return False",
            "",
            "    def default_root_device_name(self, instance, image_meta, root_bdm):",
            "        disk_bus = blockinfo.get_disk_bus_for_device_type(",
            "            instance, CONF.libvirt.virt_type, image_meta, \"disk\")",
            "        cdrom_bus = blockinfo.get_disk_bus_for_device_type(",
            "            instance, CONF.libvirt.virt_type, image_meta, \"cdrom\")",
            "        root_info = blockinfo.get_root_info(",
            "            instance, CONF.libvirt.virt_type, image_meta,",
            "            root_bdm, disk_bus, cdrom_bus)",
            "        return block_device.prepend_dev(root_info['dev'])",
            "",
            "    def default_device_names_for_instance(self, instance, root_device_name,",
            "                                          *block_device_lists):",
            "        block_device_mapping = list(itertools.chain(*block_device_lists))",
            "        # NOTE(ndipanov): Null out the device names so that blockinfo code",
            "        #                 will assign them",
            "        for bdm in block_device_mapping:",
            "            if bdm.device_name is not None:",
            "                LOG.warn(_LW(\"Ignoring supplied device name: %(device_name)s. \"",
            "                             \"Libvirt can't honour user-supplied dev names\"),",
            "                         {'device_name': bdm.device_name}, instance=instance)",
            "                bdm.device_name = None",
            "        block_device_info = driver.get_block_device_info(instance,",
            "                                                         block_device_mapping)",
            "",
            "        blockinfo.default_device_names(CONF.libvirt.virt_type,",
            "                                       nova_context.get_admin_context(),",
            "                                       instance,",
            "                                       block_device_info,",
            "                                       instance.image_meta)",
            "",
            "    def get_device_name_for_instance(self, instance, bdms, block_device_obj):",
            "        block_device_info = driver.get_block_device_info(instance, bdms)",
            "        instance_info = blockinfo.get_disk_info(",
            "                CONF.libvirt.virt_type, instance,",
            "                instance.image_meta, block_device_info=block_device_info)",
            "",
            "        suggested_dev_name = block_device_obj.device_name",
            "        if suggested_dev_name is not None:",
            "            LOG.warn(_LW('Ignoring supplied device name: %(suggested_dev)s'),",
            "                     {'suggested_dev': suggested_dev_name}, instance=instance)",
            "",
            "        # NOTE(ndipanov): get_info_from_bdm will generate the new device name",
            "        #                 only when it's actually not set on the bd object",
            "        block_device_obj.device_name = None",
            "        disk_info = blockinfo.get_info_from_bdm(",
            "            instance, CONF.libvirt.virt_type, instance.image_meta,",
            "            block_device_obj, mapping=instance_info['mapping'])",
            "        return block_device.prepend_dev(disk_info['dev'])",
            "",
            "    def is_supported_fs_format(self, fs_type):",
            "        return fs_type in [disk.FS_FORMAT_EXT2, disk.FS_FORMAT_EXT3,",
            "                           disk.FS_FORMAT_EXT4, disk.FS_FORMAT_XFS]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "nova.virt.libvirt.driver.LibvirtDriver.migrate_disk_and_power_off.on_execute",
            "nova.virt.libvirt.driver.LibvirtDriver.migrate_disk_and_power_off.on_completion"
        ]
    }
}