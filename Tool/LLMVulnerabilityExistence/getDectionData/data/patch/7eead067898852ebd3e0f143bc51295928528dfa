{
    "src/Products/PluggableAuthService/plugins/CookieAuthHelper.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " import six"
            },
            "1": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " from six.moves.urllib.parse import quote"
            },
            "2": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from six.moves.urllib.parse import unquote"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+from six.moves.urllib.parse import urlparse"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+from six.moves.urllib.parse import urlunparse"
            },
            "5": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " from AccessControl.class_init import InitializeClass"
            },
            "7": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " from AccessControl.Permissions import view"
            },
            "8": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 227,
                "PatchRowcode": "                     # in an endless redirect loop."
            },
            "9": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "                     return 0"
            },
            "10": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 229,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+            # Sanitize the return URL ``came_from`` and only allow local URLs"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+            # to prevent an open exploitable redirect issue"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+            if came_from:"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+                parsed = urlparse(came_from)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+                came_from = urlunparse(('', '') + parsed[2:])"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "             if '?' in url:"
            },
            "18": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "                 sep = '&'"
            },
            "19": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 238,
                "PatchRowcode": "             else:"
            }
        },
        "frontPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2001 Zope Foundation and Contributors",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this",
            "# distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE.",
            "#",
            "##############################################################################",
            "\"\"\" Class: CookieAuthHelper",
            "\"\"\"",
            "",
            "try:",
            "    from base64 import decodebytes",
            "    from base64 import encodebytes",
            "except ImportError:  # Python < 3.1",
            "    from base64 import decodestring as decodebytes",
            "    from base64 import encodestring as encodebytes",
            "",
            "import codecs",
            "from binascii import Error",
            "from binascii import hexlify",
            "",
            "import six",
            "from six.moves.urllib.parse import quote",
            "from six.moves.urllib.parse import unquote",
            "",
            "from AccessControl.class_init import InitializeClass",
            "from AccessControl.Permissions import view",
            "from AccessControl.SecurityInfo import ClassSecurityInfo",
            "from OFS.Folder import Folder",
            "from Products.PageTemplates.PageTemplateFile import PageTemplateFile",
            "from Products.PageTemplates.ZopePageTemplate import ZopePageTemplate",
            "from zope.interface import Interface",
            "",
            "from ..interfaces.plugins import IChallengePlugin",
            "from ..interfaces.plugins import ICredentialsResetPlugin",
            "from ..interfaces.plugins import ICredentialsUpdatePlugin",
            "from ..interfaces.plugins import ILoginPasswordHostExtractionPlugin",
            "from ..plugins.BasePlugin import BasePlugin",
            "from ..utils import classImplements",
            "",
            "",
            "class ICookieAuthHelper(Interface):",
            "    \"\"\" Marker interface.",
            "    \"\"\"",
            "",
            "",
            "manage_addCookieAuthHelperForm = PageTemplateFile(",
            "    'www/caAdd', globals(), __name__='manage_addCookieAuthHelperForm')",
            "",
            "",
            "def addCookieAuthHelper(dispatcher, id, title=None, cookie_name='',",
            "                        REQUEST=None):",
            "    \"\"\" Add a Cookie Auth Helper to a Pluggable Auth Service. \"\"\"",
            "    sp = CookieAuthHelper(id, title, cookie_name)",
            "    dispatcher._setObject(sp.getId(), sp)",
            "",
            "    if REQUEST is not None:",
            "        REQUEST['RESPONSE'].redirect('%s/manage_workspace'",
            "                                     '?manage_tabs_message='",
            "                                     'CookieAuthHelper+added.' %",
            "                                     dispatcher.absolute_url())",
            "",
            "",
            "def decode_cookie(raw):",
            "    value = unquote(raw)",
            "    if six.PY3:",
            "        value = value.encode('utf8')",
            "    value = decodebytes(value)",
            "    if six.PY3:",
            "        value = value.decode('utf8')",
            "    return value",
            "",
            "",
            "def decode_hex(raw):",
            "    if isinstance(raw, six.text_type):",
            "        raw = raw.encode('utf8')",
            "    value = codecs.decode(raw, 'hex_codec')",
            "    if six.PY3:",
            "        value = value.decode('utf-8')",
            "    return value",
            "",
            "",
            "class CookieAuthHelper(Folder, BasePlugin):",
            "    \"\"\" Multi-plugin for managing details of Cookie Authentication. \"\"\"",
            "",
            "    meta_type = 'Cookie Auth Helper'",
            "    zmi_icon = 'fas fa-cookie-bite'",
            "    cookie_name = '__ginger_snap'",
            "    login_path = 'login_form'",
            "    security = ClassSecurityInfo()",
            "",
            "    _properties = ({'id': 'title', 'label': 'Title',",
            "                    'type': 'string', 'mode': 'w'},",
            "                   {'id': 'cookie_name', 'label': 'Cookie Name',",
            "                    'type': 'string', 'mode': 'w'},",
            "                   {'id': 'login_path', 'label': 'Login Form',",
            "                    'type': 'string', 'mode': 'w'})",
            "",
            "    manage_options = (BasePlugin.manage_options[:1]",
            "                      + Folder.manage_options[:1]",
            "                      + Folder.manage_options[2:])",
            "",
            "    def __init__(self, id, title=None, cookie_name=''):",
            "        self._setId(id)",
            "        self.title = title",
            "",
            "        if cookie_name:",
            "            self.cookie_name = cookie_name",
            "",
            "    @security.private",
            "    def extractCredentials(self, request):",
            "        \"\"\" Extract credentials from cookie or 'request'. \"\"\"",
            "        creds = {}",
            "        cookie = request.get(self.cookie_name, '')",
            "        # Look in the request.form for the names coming from the login form",
            "        login = request.form.get('__ac_name', '')",
            "",
            "        if login and '__ac_password' in request.form:",
            "            creds['login'] = login",
            "            creds['password'] = request.form.get('__ac_password', '')",
            "",
            "        elif cookie and cookie != 'deleted':",
            "            try:",
            "                cookie_val = decode_cookie(cookie)",
            "            except Error:",
            "                # Cookie is in a different format, so it is not ours",
            "                return creds",
            "",
            "            try:",
            "                login, password = cookie_val.split(':')",
            "            except ValueError:",
            "                # Cookie is in a different format, so it is not ours",
            "                return creds",
            "",
            "            try:",
            "                creds['login'] = decode_hex(login)",
            "                creds['password'] = decode_hex(password)",
            "            except (Error, TypeError):",
            "                # Cookie is in a different format, so it is not ours",
            "                return {}",
            "",
            "        if creds:",
            "            creds['remote_host'] = request.get('REMOTE_HOST', '')",
            "",
            "            try:",
            "                creds['remote_address'] = request.getClientAddr()",
            "            except AttributeError:",
            "                creds['remote_address'] = request.get('REMOTE_ADDR', '')",
            "",
            "        return creds",
            "",
            "    @security.private",
            "    def challenge(self, request, response, **kw):",
            "        \"\"\" Challenge the user for credentials. \"\"\"",
            "        return self.unauthorized()",
            "",
            "    @security.private",
            "    def get_cookie_value(self, login, new_password):",
            "        cookie_str = b':'.join([",
            "            hexlify(login.encode('utf-8')),",
            "            hexlify(new_password.encode('utf-8'))])",
            "        cookie_val = encodebytes(cookie_str)",
            "        cookie_val = cookie_val.rstrip()",
            "        return cookie_val",
            "",
            "    @security.private",
            "    def updateCredentials(self, request, response, login, new_password):",
            "        \"\"\" Respond to change of credentials (NOOP for basic auth). \"\"\"",
            "        cookie_val = self.get_cookie_value(login, new_password)",
            "        response.setCookie(self.cookie_name, quote(cookie_val), path='/')",
            "",
            "    @security.private",
            "    def resetCredentials(self, request, response):",
            "        \"\"\" Raise unauthorized to tell browser to clear credentials. \"\"\"",
            "        response.expireCookie(self.cookie_name, path='/')",
            "",
            "    @security.private",
            "    def manage_afterAdd(self, item, container):",
            "        \"\"\" Setup tasks upon instantiation \"\"\"",
            "        if 'login_form' not in self.objectIds():",
            "            login_form = ZopePageTemplate(id='login_form',",
            "                                          text=BASIC_LOGIN_FORM)",
            "            login_form.title = 'Login Form'",
            "            login_form.manage_permission(view, roles=['Anonymous'], acquire=1)",
            "            self._setObject('login_form', login_form, set_owner=0)",
            "",
            "    @security.private",
            "    def unauthorized(self):",
            "        req = self.REQUEST",
            "        resp = req['RESPONSE']",
            "",
            "        # If we set the auth cookie before, delete it now.",
            "        if self.cookie_name in resp.cookies:",
            "            del resp.cookies[self.cookie_name]",
            "",
            "        # Redirect if desired.",
            "        url = self.getLoginURL()",
            "        if url is not None:",
            "            came_from = req.get('came_from', None)",
            "",
            "            if came_from is None:",
            "                came_from = req.get('ACTUAL_URL', '')",
            "                query = req.get('QUERY_STRING')",
            "                if query:",
            "                    if not query.startswith('?'):",
            "                        query = '?' + query",
            "                    came_from = came_from + query",
            "            else:",
            "                # If came_from contains a value it means the user",
            "                # must be coming through here a second time",
            "                # Reasons could be typos when providing credentials",
            "                # or a redirect loop (see below)",
            "                req_url = req.get('ACTUAL_URL', '')",
            "",
            "                if req_url and req_url == url:",
            "                    # Oops... The login_form cannot be reached by the user -",
            "                    # it might be protected itself due to misconfiguration -",
            "                    # the only sane thing to do is to give up because we are",
            "                    # in an endless redirect loop.",
            "                    return 0",
            "",
            "            if '?' in url:",
            "                sep = '&'",
            "            else:",
            "                sep = '?'",
            "            url = '%s%scame_from=%s' % (url, sep, quote(came_from))",
            "            resp.redirect(url, lock=1)",
            "            resp.setHeader('Expires', 'Sat, 01 Jan 2000 00:00:00 GMT')",
            "            resp.setHeader('Cache-Control', 'no-cache')",
            "            return 1",
            "",
            "        # Could not challenge.",
            "        return 0",
            "",
            "    @security.private",
            "    def getLoginURL(self):",
            "        \"\"\" Where to send people for logging in \"\"\"",
            "        if self.login_path.startswith('/') or '://' in self.login_path:",
            "            return self.login_path",
            "        elif self.login_path != '':",
            "            return '%s/%s' % (self.absolute_url(), self.login_path)",
            "        else:",
            "            return None",
            "",
            "    @security.public",
            "    def login(self):",
            "        \"\"\" Set a cookie and redirect to the url that we tried to",
            "        authenticate against originally.",
            "        \"\"\"",
            "        request = self.REQUEST",
            "        response = request['RESPONSE']",
            "",
            "        login = request.get('__ac_name', '')",
            "        password = request.get('__ac_password', '')",
            "",
            "        # In order to use the CookieAuthHelper for its nice login page",
            "        # facility but store and manage credentials somewhere else we need",
            "        # to make sure that upon login only plugins activated as",
            "        # IUpdateCredentialPlugins get their updateCredentials method",
            "        # called. If the method is called on the CookieAuthHelper it will",
            "        # simply set its own auth cookie, to the exclusion of any other",
            "        # plugins that might want to store the credentials.",
            "        pas_instance = self._getPAS()",
            "",
            "        if pas_instance is not None:",
            "            pas_instance.updateCredentials(request, response, login, password)",
            "",
            "        came_from = request.form['came_from']",
            "",
            "        return response.redirect(came_from)",
            "",
            "",
            "classImplements(CookieAuthHelper, ICookieAuthHelper,",
            "                ILoginPasswordHostExtractionPlugin, IChallengePlugin,",
            "                ICredentialsUpdatePlugin, ICredentialsResetPlugin)",
            "",
            "InitializeClass(CookieAuthHelper)",
            "",
            "",
            "BASIC_LOGIN_FORM = \"\"\"<html>",
            "  <head>",
            "    <title> Login Form </title>",
            "  </head>",
            "",
            "  <body>",
            "",
            "    <h3> Please log in </h3>",
            "",
            "    <form method=\"post\" action=\"\"",
            "          tal:attributes=\"action string:${here/absolute_url}/login\">",
            "",
            "      <input type=\"hidden\" name=\"came_from\" value=\"\"",
            "             tal:attributes=\"value request/came_from | string:\"/>",
            "      <table cellpadding=\"2\">",
            "        <tr>",
            "          <td><b>Login:</b> </td>",
            "          <td><input type=\"text\" name=\"__ac_name\" size=\"30\" /></td>",
            "        </tr>",
            "        <tr>",
            "          <td><b>Password:</b></td>",
            "          <td><input type=\"password\" name=\"__ac_password\" size=\"30\" /></td>",
            "        </tr>",
            "        <tr>",
            "          <td colspan=\"2\">",
            "            <br />",
            "            <input type=\"submit\" value=\" Log In \" />",
            "          </td>",
            "        </tr>",
            "      </table>",
            "",
            "    </form>",
            "",
            "  </body>",
            "",
            "</html>",
            "\"\"\""
        ],
        "afterPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2001 Zope Foundation and Contributors",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this",
            "# distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE.",
            "#",
            "##############################################################################",
            "\"\"\" Class: CookieAuthHelper",
            "\"\"\"",
            "",
            "try:",
            "    from base64 import decodebytes",
            "    from base64 import encodebytes",
            "except ImportError:  # Python < 3.1",
            "    from base64 import decodestring as decodebytes",
            "    from base64 import encodestring as encodebytes",
            "",
            "import codecs",
            "from binascii import Error",
            "from binascii import hexlify",
            "",
            "import six",
            "from six.moves.urllib.parse import quote",
            "from six.moves.urllib.parse import unquote",
            "from six.moves.urllib.parse import urlparse",
            "from six.moves.urllib.parse import urlunparse",
            "",
            "from AccessControl.class_init import InitializeClass",
            "from AccessControl.Permissions import view",
            "from AccessControl.SecurityInfo import ClassSecurityInfo",
            "from OFS.Folder import Folder",
            "from Products.PageTemplates.PageTemplateFile import PageTemplateFile",
            "from Products.PageTemplates.ZopePageTemplate import ZopePageTemplate",
            "from zope.interface import Interface",
            "",
            "from ..interfaces.plugins import IChallengePlugin",
            "from ..interfaces.plugins import ICredentialsResetPlugin",
            "from ..interfaces.plugins import ICredentialsUpdatePlugin",
            "from ..interfaces.plugins import ILoginPasswordHostExtractionPlugin",
            "from ..plugins.BasePlugin import BasePlugin",
            "from ..utils import classImplements",
            "",
            "",
            "class ICookieAuthHelper(Interface):",
            "    \"\"\" Marker interface.",
            "    \"\"\"",
            "",
            "",
            "manage_addCookieAuthHelperForm = PageTemplateFile(",
            "    'www/caAdd', globals(), __name__='manage_addCookieAuthHelperForm')",
            "",
            "",
            "def addCookieAuthHelper(dispatcher, id, title=None, cookie_name='',",
            "                        REQUEST=None):",
            "    \"\"\" Add a Cookie Auth Helper to a Pluggable Auth Service. \"\"\"",
            "    sp = CookieAuthHelper(id, title, cookie_name)",
            "    dispatcher._setObject(sp.getId(), sp)",
            "",
            "    if REQUEST is not None:",
            "        REQUEST['RESPONSE'].redirect('%s/manage_workspace'",
            "                                     '?manage_tabs_message='",
            "                                     'CookieAuthHelper+added.' %",
            "                                     dispatcher.absolute_url())",
            "",
            "",
            "def decode_cookie(raw):",
            "    value = unquote(raw)",
            "    if six.PY3:",
            "        value = value.encode('utf8')",
            "    value = decodebytes(value)",
            "    if six.PY3:",
            "        value = value.decode('utf8')",
            "    return value",
            "",
            "",
            "def decode_hex(raw):",
            "    if isinstance(raw, six.text_type):",
            "        raw = raw.encode('utf8')",
            "    value = codecs.decode(raw, 'hex_codec')",
            "    if six.PY3:",
            "        value = value.decode('utf-8')",
            "    return value",
            "",
            "",
            "class CookieAuthHelper(Folder, BasePlugin):",
            "    \"\"\" Multi-plugin for managing details of Cookie Authentication. \"\"\"",
            "",
            "    meta_type = 'Cookie Auth Helper'",
            "    zmi_icon = 'fas fa-cookie-bite'",
            "    cookie_name = '__ginger_snap'",
            "    login_path = 'login_form'",
            "    security = ClassSecurityInfo()",
            "",
            "    _properties = ({'id': 'title', 'label': 'Title',",
            "                    'type': 'string', 'mode': 'w'},",
            "                   {'id': 'cookie_name', 'label': 'Cookie Name',",
            "                    'type': 'string', 'mode': 'w'},",
            "                   {'id': 'login_path', 'label': 'Login Form',",
            "                    'type': 'string', 'mode': 'w'})",
            "",
            "    manage_options = (BasePlugin.manage_options[:1]",
            "                      + Folder.manage_options[:1]",
            "                      + Folder.manage_options[2:])",
            "",
            "    def __init__(self, id, title=None, cookie_name=''):",
            "        self._setId(id)",
            "        self.title = title",
            "",
            "        if cookie_name:",
            "            self.cookie_name = cookie_name",
            "",
            "    @security.private",
            "    def extractCredentials(self, request):",
            "        \"\"\" Extract credentials from cookie or 'request'. \"\"\"",
            "        creds = {}",
            "        cookie = request.get(self.cookie_name, '')",
            "        # Look in the request.form for the names coming from the login form",
            "        login = request.form.get('__ac_name', '')",
            "",
            "        if login and '__ac_password' in request.form:",
            "            creds['login'] = login",
            "            creds['password'] = request.form.get('__ac_password', '')",
            "",
            "        elif cookie and cookie != 'deleted':",
            "            try:",
            "                cookie_val = decode_cookie(cookie)",
            "            except Error:",
            "                # Cookie is in a different format, so it is not ours",
            "                return creds",
            "",
            "            try:",
            "                login, password = cookie_val.split(':')",
            "            except ValueError:",
            "                # Cookie is in a different format, so it is not ours",
            "                return creds",
            "",
            "            try:",
            "                creds['login'] = decode_hex(login)",
            "                creds['password'] = decode_hex(password)",
            "            except (Error, TypeError):",
            "                # Cookie is in a different format, so it is not ours",
            "                return {}",
            "",
            "        if creds:",
            "            creds['remote_host'] = request.get('REMOTE_HOST', '')",
            "",
            "            try:",
            "                creds['remote_address'] = request.getClientAddr()",
            "            except AttributeError:",
            "                creds['remote_address'] = request.get('REMOTE_ADDR', '')",
            "",
            "        return creds",
            "",
            "    @security.private",
            "    def challenge(self, request, response, **kw):",
            "        \"\"\" Challenge the user for credentials. \"\"\"",
            "        return self.unauthorized()",
            "",
            "    @security.private",
            "    def get_cookie_value(self, login, new_password):",
            "        cookie_str = b':'.join([",
            "            hexlify(login.encode('utf-8')),",
            "            hexlify(new_password.encode('utf-8'))])",
            "        cookie_val = encodebytes(cookie_str)",
            "        cookie_val = cookie_val.rstrip()",
            "        return cookie_val",
            "",
            "    @security.private",
            "    def updateCredentials(self, request, response, login, new_password):",
            "        \"\"\" Respond to change of credentials (NOOP for basic auth). \"\"\"",
            "        cookie_val = self.get_cookie_value(login, new_password)",
            "        response.setCookie(self.cookie_name, quote(cookie_val), path='/')",
            "",
            "    @security.private",
            "    def resetCredentials(self, request, response):",
            "        \"\"\" Raise unauthorized to tell browser to clear credentials. \"\"\"",
            "        response.expireCookie(self.cookie_name, path='/')",
            "",
            "    @security.private",
            "    def manage_afterAdd(self, item, container):",
            "        \"\"\" Setup tasks upon instantiation \"\"\"",
            "        if 'login_form' not in self.objectIds():",
            "            login_form = ZopePageTemplate(id='login_form',",
            "                                          text=BASIC_LOGIN_FORM)",
            "            login_form.title = 'Login Form'",
            "            login_form.manage_permission(view, roles=['Anonymous'], acquire=1)",
            "            self._setObject('login_form', login_form, set_owner=0)",
            "",
            "    @security.private",
            "    def unauthorized(self):",
            "        req = self.REQUEST",
            "        resp = req['RESPONSE']",
            "",
            "        # If we set the auth cookie before, delete it now.",
            "        if self.cookie_name in resp.cookies:",
            "            del resp.cookies[self.cookie_name]",
            "",
            "        # Redirect if desired.",
            "        url = self.getLoginURL()",
            "        if url is not None:",
            "            came_from = req.get('came_from', None)",
            "",
            "            if came_from is None:",
            "                came_from = req.get('ACTUAL_URL', '')",
            "                query = req.get('QUERY_STRING')",
            "                if query:",
            "                    if not query.startswith('?'):",
            "                        query = '?' + query",
            "                    came_from = came_from + query",
            "            else:",
            "                # If came_from contains a value it means the user",
            "                # must be coming through here a second time",
            "                # Reasons could be typos when providing credentials",
            "                # or a redirect loop (see below)",
            "                req_url = req.get('ACTUAL_URL', '')",
            "",
            "                if req_url and req_url == url:",
            "                    # Oops... The login_form cannot be reached by the user -",
            "                    # it might be protected itself due to misconfiguration -",
            "                    # the only sane thing to do is to give up because we are",
            "                    # in an endless redirect loop.",
            "                    return 0",
            "",
            "            # Sanitize the return URL ``came_from`` and only allow local URLs",
            "            # to prevent an open exploitable redirect issue",
            "            if came_from:",
            "                parsed = urlparse(came_from)",
            "                came_from = urlunparse(('', '') + parsed[2:])",
            "",
            "            if '?' in url:",
            "                sep = '&'",
            "            else:",
            "                sep = '?'",
            "            url = '%s%scame_from=%s' % (url, sep, quote(came_from))",
            "            resp.redirect(url, lock=1)",
            "            resp.setHeader('Expires', 'Sat, 01 Jan 2000 00:00:00 GMT')",
            "            resp.setHeader('Cache-Control', 'no-cache')",
            "            return 1",
            "",
            "        # Could not challenge.",
            "        return 0",
            "",
            "    @security.private",
            "    def getLoginURL(self):",
            "        \"\"\" Where to send people for logging in \"\"\"",
            "        if self.login_path.startswith('/') or '://' in self.login_path:",
            "            return self.login_path",
            "        elif self.login_path != '':",
            "            return '%s/%s' % (self.absolute_url(), self.login_path)",
            "        else:",
            "            return None",
            "",
            "    @security.public",
            "    def login(self):",
            "        \"\"\" Set a cookie and redirect to the url that we tried to",
            "        authenticate against originally.",
            "        \"\"\"",
            "        request = self.REQUEST",
            "        response = request['RESPONSE']",
            "",
            "        login = request.get('__ac_name', '')",
            "        password = request.get('__ac_password', '')",
            "",
            "        # In order to use the CookieAuthHelper for its nice login page",
            "        # facility but store and manage credentials somewhere else we need",
            "        # to make sure that upon login only plugins activated as",
            "        # IUpdateCredentialPlugins get their updateCredentials method",
            "        # called. If the method is called on the CookieAuthHelper it will",
            "        # simply set its own auth cookie, to the exclusion of any other",
            "        # plugins that might want to store the credentials.",
            "        pas_instance = self._getPAS()",
            "",
            "        if pas_instance is not None:",
            "            pas_instance.updateCredentials(request, response, login, password)",
            "",
            "        came_from = request.form['came_from']",
            "",
            "        return response.redirect(came_from)",
            "",
            "",
            "classImplements(CookieAuthHelper, ICookieAuthHelper,",
            "                ILoginPasswordHostExtractionPlugin, IChallengePlugin,",
            "                ICredentialsUpdatePlugin, ICredentialsResetPlugin)",
            "",
            "InitializeClass(CookieAuthHelper)",
            "",
            "",
            "BASIC_LOGIN_FORM = \"\"\"<html>",
            "  <head>",
            "    <title> Login Form </title>",
            "  </head>",
            "",
            "  <body>",
            "",
            "    <h3> Please log in </h3>",
            "",
            "    <form method=\"post\" action=\"\"",
            "          tal:attributes=\"action string:${here/absolute_url}/login\">",
            "",
            "      <input type=\"hidden\" name=\"came_from\" value=\"\"",
            "             tal:attributes=\"value request/came_from | string:\"/>",
            "      <table cellpadding=\"2\">",
            "        <tr>",
            "          <td><b>Login:</b> </td>",
            "          <td><input type=\"text\" name=\"__ac_name\" size=\"30\" /></td>",
            "        </tr>",
            "        <tr>",
            "          <td><b>Password:</b></td>",
            "          <td><input type=\"password\" name=\"__ac_password\" size=\"30\" /></td>",
            "        </tr>",
            "        <tr>",
            "          <td colspan=\"2\">",
            "            <br />",
            "            <input type=\"submit\" value=\" Log In \" />",
            "          </td>",
            "        </tr>",
            "      </table>",
            "",
            "    </form>",
            "",
            "  </body>",
            "",
            "</html>",
            "\"\"\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "nicegui.nicegui",
            "src.Products.PluggableAuthService.plugins.CookieAuthHelper.CookieAuthHelper.challenge"
        ]
    },
    "src/Products/PluggableAuthService/plugins/tests/test_CookieAuthHelper.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "     def test_challenge(self):"
            },
            "1": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "         rc, root, folder, object = self._makeTree()"
            },
            "2": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "         response = FauxCookieResponse()"
            },
            "3": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        testURL = 'http://test'"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+        testPath = '/some/path'"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+        testURL = 'http://test' + testPath"
            },
            "6": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "         request = FauxRequest(RESPONSE=response, URL=testURL,"
            },
            "7": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "                               ACTUAL_URL=testURL)"
            },
            "8": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "         root.REQUEST = request"
            },
            "9": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "         helper.challenge(request, response)"
            },
            "10": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "         self.assertEqual(response.status, 302)"
            },
            "11": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "         self.assertEqual(len(response.headers), 3)"
            },
            "12": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertTrue(response.headers['Location'].endswith(quote(testURL)))"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+        loc = response.headers['Location']"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+        self.assertTrue(loc.endswith(quote(testPath)))"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+        self.assertNotIn(testURL, loc)"
            },
            "16": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "         self.assertEqual(response.headers['Cache-Control'], 'no-cache')"
            },
            "17": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "         self.assertEqual(response.headers['Expires'],"
            },
            "18": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "                          'Sat, 01 Jan 2000 00:00:00 GMT')"
            },
            "19": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "         self.assertEqual(response.status, 302)"
            },
            "20": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "         self.assertEqual(len(response.headers), 3)"
            },
            "21": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "         loc = response.headers['Location']"
            },
            "22": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.assertTrue(loc.endswith(quote(actualURL)))"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+        self.assertTrue(loc.endswith(quote('/xxx')))"
            },
            "24": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "         self.assertFalse(loc.endswith(quote(vhm)))"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+        self.assertNotIn(actualURL, loc)"
            },
            "26": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "         self.assertEqual(response.headers['Cache-Control'], 'no-cache')"
            },
            "27": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "         self.assertEqual(response.headers['Expires'],"
            },
            "28": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "                          'Sat, 01 Jan 2000 00:00:00 GMT')"
            }
        },
        "frontPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2001 Zope Foundation and Contributors",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this",
            "# distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE.",
            "#",
            "##############################################################################",
            "try:",
            "    from base64 import encodebytes",
            "except ImportError:  # Python < 3.1",
            "    from base64 import encodestring as encodebytes",
            "",
            "import codecs",
            "import unittest",
            "",
            "import six",
            "from six.moves.urllib.parse import quote",
            "",
            "from ...tests.conformance import IChallengePlugin_conformance",
            "from ...tests.conformance import ICredentialsResetPlugin_conformance",
            "from ...tests.conformance import ICredentialsUpdatePlugin_conformance",
            "from ...tests.conformance import ILoginPasswordHostExtractionPlugin_conformance",
            "from ...tests.test_PluggableAuthService import FauxContainer",
            "from ...tests.test_PluggableAuthService import FauxObject",
            "from ...tests.test_PluggableAuthService import FauxRequest",
            "from ...tests.test_PluggableAuthService import FauxResponse",
            "from ...tests.test_PluggableAuthService import FauxRoot",
            "",
            "",
            "class FauxSettableRequest(FauxRequest):",
            "",
            "    def set(self, name, value):",
            "        self._dict[name] = value",
            "",
            "",
            "class FauxCookieResponse(FauxResponse):",
            "",
            "    def __init__(self):",
            "        self.cookies = {}",
            "        self.redirected = False",
            "        self.status = '200'",
            "        self.headers = {}",
            "",
            "    def setCookie(self, cookie_name, cookie_value, path):",
            "        self.cookies[(cookie_name, path)] = cookie_value",
            "",
            "    def expireCookie(self, cookie_name, path):",
            "        if (cookie_name, path) in self.cookies:",
            "            del self.cookies[(cookie_name, path)]",
            "",
            "    def redirect(self, location, status=302, lock=0):",
            "        self.status = status",
            "        self.headers['Location'] = location",
            "",
            "    def setHeader(self, name, value):",
            "        self.headers[name] = value",
            "",
            "",
            "class CookieAuthHelperTests(unittest.TestCase,",
            "                            ILoginPasswordHostExtractionPlugin_conformance,",
            "                            IChallengePlugin_conformance,",
            "                            ICredentialsResetPlugin_conformance,",
            "                            ICredentialsUpdatePlugin_conformance):",
            "",
            "    def _getTargetClass(self):",
            "",
            "        from ...plugins.CookieAuthHelper import CookieAuthHelper",
            "",
            "        return CookieAuthHelper",
            "",
            "    def _makeOne(self, id='test', *args, **kw):",
            "",
            "        return self._getTargetClass()(id=id, *args, **kw)",
            "",
            "    def _makeTree(self):",
            "",
            "        rc = FauxObject('rc')",
            "        root = FauxRoot('root').__of__(rc)",
            "        folder = FauxContainer('folder').__of__(root)",
            "        object = FauxObject('object').__of__(folder)",
            "",
            "        return rc, root, folder, object",
            "",
            "    def test_extractCredentials_no_creds(self):",
            "",
            "        helper = self._makeOne()",
            "        response = FauxCookieResponse()",
            "        request = FauxRequest(RESPONSE=response)",
            "",
            "        self.assertEqual(helper.extractCredentials(request), {})",
            "",
            "    def test_extractCredentials_with_form_creds(self):",
            "",
            "        helper = self._makeOne()",
            "        response = FauxCookieResponse()",
            "        request = FauxSettableRequest(__ac_name='foo',",
            "                                      __ac_password='b:ar',",
            "                                      RESPONSE=response)",
            "",
            "        self.assertEqual(len(response.cookies), 0)",
            "        self.assertEqual(helper.extractCredentials(request),",
            "                         {'login': 'foo',",
            "                          'password': 'b:ar',",
            "                          'remote_host': '',",
            "                          'remote_address': ''})",
            "        self.assertEqual(len(response.cookies), 0)",
            "",
            "    def test_extractCredentials_with_deleted_cookie(self):",
            "        # http://www.zope.org/Collectors/PAS/43",
            "        # Edge case: The ZPublisher sets a cookie's value to \"deleted\"",
            "        # in the current request if expireCookie is called. If we hit",
            "        # extractCredentials in the same request after this, it would",
            "        # blow up trying to deal with the invalid cookie value.",
            "        helper = self._makeOne()",
            "        response = FauxCookieResponse()",
            "        req_data = {helper.cookie_name: 'deleted', 'RESPONSE': response}",
            "        request = FauxSettableRequest(**req_data)",
            "        self.assertEqual(len(response.cookies), 0)",
            "",
            "        self.assertEqual(helper.extractCredentials(request), {})",
            "",
            "    def test_challenge(self):",
            "        rc, root, folder, object = self._makeTree()",
            "        response = FauxCookieResponse()",
            "        testURL = 'http://test'",
            "        request = FauxRequest(RESPONSE=response, URL=testURL,",
            "                              ACTUAL_URL=testURL)",
            "        root.REQUEST = request",
            "",
            "        helper = self._makeOne().__of__(root)",
            "",
            "        helper.challenge(request, response)",
            "        self.assertEqual(response.status, 302)",
            "        self.assertEqual(len(response.headers), 3)",
            "        self.assertTrue(response.headers['Location'].endswith(quote(testURL)))",
            "        self.assertEqual(response.headers['Cache-Control'], 'no-cache')",
            "        self.assertEqual(response.headers['Expires'],",
            "                         'Sat, 01 Jan 2000 00:00:00 GMT')",
            "",
            "    def test_challenge_with_vhm(self):",
            "        rc, root, folder, object = self._makeTree()",
            "        response = FauxCookieResponse()",
            "        vhm = 'http://localhost/VirtualHostBase/http/test/VirtualHostRoot/xxx'",
            "        actualURL = 'http://test/xxx'",
            "",
            "        request = FauxRequest(RESPONSE=response, URL=vhm,",
            "                              ACTUAL_URL=actualURL)",
            "        root.REQUEST = request",
            "",
            "        helper = self._makeOne().__of__(root)",
            "",
            "        helper.challenge(request, response)",
            "        self.assertEqual(response.status, 302)",
            "        self.assertEqual(len(response.headers), 3)",
            "        loc = response.headers['Location']",
            "        self.assertTrue(loc.endswith(quote(actualURL)))",
            "        self.assertFalse(loc.endswith(quote(vhm)))",
            "        self.assertEqual(response.headers['Cache-Control'], 'no-cache')",
            "        self.assertEqual(response.headers['Expires'],",
            "                         'Sat, 01 Jan 2000 00:00:00 GMT')",
            "",
            "    def test_resetCredentials(self):",
            "        helper = self._makeOne()",
            "        response = FauxCookieResponse()",
            "        request = FauxRequest(RESPONSE=response)",
            "",
            "        helper.resetCredentials(request, response)",
            "        self.assertEqual(len(response.cookies), 0)",
            "",
            "    def test_loginWithoutCredentialsUpdate(self):",
            "        helper = self._makeOne()",
            "        response = FauxCookieResponse()",
            "        request = FauxSettableRequest(__ac_name='foo', __ac_password='bar',",
            "                                      RESPONSE=response)",
            "        request.form['came_from'] = ''",
            "        helper.REQUEST = request",
            "",
            "        helper.login()",
            "        self.assertEqual(len(response.cookies), 0)",
            "",
            "    def test_extractCredentials_from_cookie_with_colon_in_password(self):",
            "        # http://www.zope.org/Collectors/PAS/51",
            "        # Passwords with \":\" characters broke authentication",
            "        helper = self._makeOne()",
            "        response = FauxCookieResponse()",
            "        request = FauxSettableRequest(RESPONSE=response)",
            "",
            "        username = codecs.encode(b'foo', 'hex_codec')",
            "        password = codecs.encode(b'b:ar', 'hex_codec')",
            "        cookie_str = b'%s:%s' % (username, password)",
            "        cookie_val = encodebytes(cookie_str)",
            "        cookie_val = cookie_val.rstrip()",
            "        if six.PY3:",
            "            cookie_val = cookie_val.decode('utf8')",
            "        request.set(helper.cookie_name, cookie_val)",
            "",
            "        self.assertEqual(helper.extractCredentials(request),",
            "                         {'login': 'foo',",
            "                          'password': 'b:ar',",
            "                          'remote_host': '',",
            "                          'remote_address': ''})",
            "",
            "    def test_extractCredentials_from_cookie_with_colon_that_is_not_ours(self):",
            "        # http://article.gmane.org/gmane.comp.web.zope.plone.product-developers/5145",
            "        helper = self._makeOne()",
            "        response = FauxCookieResponse()",
            "        request = FauxSettableRequest(RESPONSE=response)",
            "",
            "        cookie_str = b'cookie:from_other_plugin'",
            "        cookie_val = encodebytes(cookie_str)",
            "        cookie_val = cookie_val.rstrip()",
            "        if six.PY3:",
            "            cookie_val = cookie_val.decode('utf8')",
            "        request.set(helper.cookie_name, cookie_val)",
            "",
            "        self.assertEqual(helper.extractCredentials(request), {})",
            "",
            "    def test_extractCredentials_from_cookie_with_bad_binascii(self):",
            "        # this might happen between browser implementations",
            "        helper = self._makeOne()",
            "        response = FauxCookieResponse()",
            "        request = FauxSettableRequest(RESPONSE=response)",
            "",
            "        cookie_val = 'NjE2NDZkNjk2ZTo3MDZjNmY2ZTY1MzQ3NQ%3D%3D'[:-1]",
            "        request.set(helper.cookie_name, cookie_val)",
            "",
            "        self.assertEqual(helper.extractCredentials(request), {})"
        ],
        "afterPatchFile": [
            "##############################################################################",
            "#",
            "# Copyright (c) 2001 Zope Foundation and Contributors",
            "#",
            "# This software is subject to the provisions of the Zope Public License,",
            "# Version 2.1 (ZPL).  A copy of the ZPL should accompany this",
            "# distribution.",
            "# THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY AND ALL EXPRESS OR IMPLIED",
            "# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",
            "# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS",
            "# FOR A PARTICULAR PURPOSE.",
            "#",
            "##############################################################################",
            "try:",
            "    from base64 import encodebytes",
            "except ImportError:  # Python < 3.1",
            "    from base64 import encodestring as encodebytes",
            "",
            "import codecs",
            "import unittest",
            "",
            "import six",
            "from six.moves.urllib.parse import quote",
            "",
            "from ...tests.conformance import IChallengePlugin_conformance",
            "from ...tests.conformance import ICredentialsResetPlugin_conformance",
            "from ...tests.conformance import ICredentialsUpdatePlugin_conformance",
            "from ...tests.conformance import ILoginPasswordHostExtractionPlugin_conformance",
            "from ...tests.test_PluggableAuthService import FauxContainer",
            "from ...tests.test_PluggableAuthService import FauxObject",
            "from ...tests.test_PluggableAuthService import FauxRequest",
            "from ...tests.test_PluggableAuthService import FauxResponse",
            "from ...tests.test_PluggableAuthService import FauxRoot",
            "",
            "",
            "class FauxSettableRequest(FauxRequest):",
            "",
            "    def set(self, name, value):",
            "        self._dict[name] = value",
            "",
            "",
            "class FauxCookieResponse(FauxResponse):",
            "",
            "    def __init__(self):",
            "        self.cookies = {}",
            "        self.redirected = False",
            "        self.status = '200'",
            "        self.headers = {}",
            "",
            "    def setCookie(self, cookie_name, cookie_value, path):",
            "        self.cookies[(cookie_name, path)] = cookie_value",
            "",
            "    def expireCookie(self, cookie_name, path):",
            "        if (cookie_name, path) in self.cookies:",
            "            del self.cookies[(cookie_name, path)]",
            "",
            "    def redirect(self, location, status=302, lock=0):",
            "        self.status = status",
            "        self.headers['Location'] = location",
            "",
            "    def setHeader(self, name, value):",
            "        self.headers[name] = value",
            "",
            "",
            "class CookieAuthHelperTests(unittest.TestCase,",
            "                            ILoginPasswordHostExtractionPlugin_conformance,",
            "                            IChallengePlugin_conformance,",
            "                            ICredentialsResetPlugin_conformance,",
            "                            ICredentialsUpdatePlugin_conformance):",
            "",
            "    def _getTargetClass(self):",
            "",
            "        from ...plugins.CookieAuthHelper import CookieAuthHelper",
            "",
            "        return CookieAuthHelper",
            "",
            "    def _makeOne(self, id='test', *args, **kw):",
            "",
            "        return self._getTargetClass()(id=id, *args, **kw)",
            "",
            "    def _makeTree(self):",
            "",
            "        rc = FauxObject('rc')",
            "        root = FauxRoot('root').__of__(rc)",
            "        folder = FauxContainer('folder').__of__(root)",
            "        object = FauxObject('object').__of__(folder)",
            "",
            "        return rc, root, folder, object",
            "",
            "    def test_extractCredentials_no_creds(self):",
            "",
            "        helper = self._makeOne()",
            "        response = FauxCookieResponse()",
            "        request = FauxRequest(RESPONSE=response)",
            "",
            "        self.assertEqual(helper.extractCredentials(request), {})",
            "",
            "    def test_extractCredentials_with_form_creds(self):",
            "",
            "        helper = self._makeOne()",
            "        response = FauxCookieResponse()",
            "        request = FauxSettableRequest(__ac_name='foo',",
            "                                      __ac_password='b:ar',",
            "                                      RESPONSE=response)",
            "",
            "        self.assertEqual(len(response.cookies), 0)",
            "        self.assertEqual(helper.extractCredentials(request),",
            "                         {'login': 'foo',",
            "                          'password': 'b:ar',",
            "                          'remote_host': '',",
            "                          'remote_address': ''})",
            "        self.assertEqual(len(response.cookies), 0)",
            "",
            "    def test_extractCredentials_with_deleted_cookie(self):",
            "        # http://www.zope.org/Collectors/PAS/43",
            "        # Edge case: The ZPublisher sets a cookie's value to \"deleted\"",
            "        # in the current request if expireCookie is called. If we hit",
            "        # extractCredentials in the same request after this, it would",
            "        # blow up trying to deal with the invalid cookie value.",
            "        helper = self._makeOne()",
            "        response = FauxCookieResponse()",
            "        req_data = {helper.cookie_name: 'deleted', 'RESPONSE': response}",
            "        request = FauxSettableRequest(**req_data)",
            "        self.assertEqual(len(response.cookies), 0)",
            "",
            "        self.assertEqual(helper.extractCredentials(request), {})",
            "",
            "    def test_challenge(self):",
            "        rc, root, folder, object = self._makeTree()",
            "        response = FauxCookieResponse()",
            "        testPath = '/some/path'",
            "        testURL = 'http://test' + testPath",
            "        request = FauxRequest(RESPONSE=response, URL=testURL,",
            "                              ACTUAL_URL=testURL)",
            "        root.REQUEST = request",
            "",
            "        helper = self._makeOne().__of__(root)",
            "",
            "        helper.challenge(request, response)",
            "        self.assertEqual(response.status, 302)",
            "        self.assertEqual(len(response.headers), 3)",
            "        loc = response.headers['Location']",
            "        self.assertTrue(loc.endswith(quote(testPath)))",
            "        self.assertNotIn(testURL, loc)",
            "        self.assertEqual(response.headers['Cache-Control'], 'no-cache')",
            "        self.assertEqual(response.headers['Expires'],",
            "                         'Sat, 01 Jan 2000 00:00:00 GMT')",
            "",
            "    def test_challenge_with_vhm(self):",
            "        rc, root, folder, object = self._makeTree()",
            "        response = FauxCookieResponse()",
            "        vhm = 'http://localhost/VirtualHostBase/http/test/VirtualHostRoot/xxx'",
            "        actualURL = 'http://test/xxx'",
            "",
            "        request = FauxRequest(RESPONSE=response, URL=vhm,",
            "                              ACTUAL_URL=actualURL)",
            "        root.REQUEST = request",
            "",
            "        helper = self._makeOne().__of__(root)",
            "",
            "        helper.challenge(request, response)",
            "        self.assertEqual(response.status, 302)",
            "        self.assertEqual(len(response.headers), 3)",
            "        loc = response.headers['Location']",
            "        self.assertTrue(loc.endswith(quote('/xxx')))",
            "        self.assertFalse(loc.endswith(quote(vhm)))",
            "        self.assertNotIn(actualURL, loc)",
            "        self.assertEqual(response.headers['Cache-Control'], 'no-cache')",
            "        self.assertEqual(response.headers['Expires'],",
            "                         'Sat, 01 Jan 2000 00:00:00 GMT')",
            "",
            "    def test_resetCredentials(self):",
            "        helper = self._makeOne()",
            "        response = FauxCookieResponse()",
            "        request = FauxRequest(RESPONSE=response)",
            "",
            "        helper.resetCredentials(request, response)",
            "        self.assertEqual(len(response.cookies), 0)",
            "",
            "    def test_loginWithoutCredentialsUpdate(self):",
            "        helper = self._makeOne()",
            "        response = FauxCookieResponse()",
            "        request = FauxSettableRequest(__ac_name='foo', __ac_password='bar',",
            "                                      RESPONSE=response)",
            "        request.form['came_from'] = ''",
            "        helper.REQUEST = request",
            "",
            "        helper.login()",
            "        self.assertEqual(len(response.cookies), 0)",
            "",
            "    def test_extractCredentials_from_cookie_with_colon_in_password(self):",
            "        # http://www.zope.org/Collectors/PAS/51",
            "        # Passwords with \":\" characters broke authentication",
            "        helper = self._makeOne()",
            "        response = FauxCookieResponse()",
            "        request = FauxSettableRequest(RESPONSE=response)",
            "",
            "        username = codecs.encode(b'foo', 'hex_codec')",
            "        password = codecs.encode(b'b:ar', 'hex_codec')",
            "        cookie_str = b'%s:%s' % (username, password)",
            "        cookie_val = encodebytes(cookie_str)",
            "        cookie_val = cookie_val.rstrip()",
            "        if six.PY3:",
            "            cookie_val = cookie_val.decode('utf8')",
            "        request.set(helper.cookie_name, cookie_val)",
            "",
            "        self.assertEqual(helper.extractCredentials(request),",
            "                         {'login': 'foo',",
            "                          'password': 'b:ar',",
            "                          'remote_host': '',",
            "                          'remote_address': ''})",
            "",
            "    def test_extractCredentials_from_cookie_with_colon_that_is_not_ours(self):",
            "        # http://article.gmane.org/gmane.comp.web.zope.plone.product-developers/5145",
            "        helper = self._makeOne()",
            "        response = FauxCookieResponse()",
            "        request = FauxSettableRequest(RESPONSE=response)",
            "",
            "        cookie_str = b'cookie:from_other_plugin'",
            "        cookie_val = encodebytes(cookie_str)",
            "        cookie_val = cookie_val.rstrip()",
            "        if six.PY3:",
            "            cookie_val = cookie_val.decode('utf8')",
            "        request.set(helper.cookie_name, cookie_val)",
            "",
            "        self.assertEqual(helper.extractCredentials(request), {})",
            "",
            "    def test_extractCredentials_from_cookie_with_bad_binascii(self):",
            "        # this might happen between browser implementations",
            "        helper = self._makeOne()",
            "        response = FauxCookieResponse()",
            "        request = FauxSettableRequest(RESPONSE=response)",
            "",
            "        cookie_val = 'NjE2NDZkNjk2ZTo3MDZjNmY2ZTY1MzQ3NQ%3D%3D'[:-1]",
            "        request.set(helper.cookie_name, cookie_val)",
            "",
            "        self.assertEqual(helper.extractCredentials(request), {})"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "131": [
                "CookieAuthHelperTests",
                "test_challenge"
            ],
            "141": [
                "CookieAuthHelperTests",
                "test_challenge"
            ],
            "162": [
                "CookieAuthHelperTests",
                "test_challenge_with_vhm"
            ]
        },
        "addLocation": []
    }
}