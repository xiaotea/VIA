{
    "scrapy/downloadermiddlewares/redirect.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "     kwargs['url'] = url"
            },
            "1": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": "     kwargs['cookies'] = None"
            },
            "2": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": "     redirect_request = source_request.replace(**kwargs)"
            },
            "3": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if 'Cookie' in redirect_request.headers:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+    has_cookie_header = \"Cookie\" in redirect_request.headers"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+    has_authorization_header = \"Authorization\" in redirect_request.headers"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+    if has_cookie_header or has_authorization_header:"
            },
            "7": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 21,
                "PatchRowcode": "         source_request_netloc = urlparse_cached(source_request).netloc"
            },
            "8": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "         redirect_request_netloc = urlparse_cached(redirect_request).netloc"
            },
            "9": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "         if source_request_netloc != redirect_request_netloc:"
            },
            "10": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            del redirect_request.headers['Cookie']"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+            if has_cookie_header:"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+                del redirect_request.headers[\"Cookie\"]"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+            # https://fetch.spec.whatwg.org/#ref-for-cors-non-wildcard-request-header-name"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+            if has_authorization_header:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+                del redirect_request.headers[\"Authorization\"]"
            },
            "16": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "     return redirect_request"
            },
            "17": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import logging",
            "from six.moves.urllib.parse import urljoin",
            "",
            "from w3lib.url import safe_url_string",
            "",
            "from scrapy.http import HtmlResponse",
            "from scrapy.utils.httpobj import urlparse_cached",
            "from scrapy.utils.response import get_meta_refresh",
            "from scrapy.exceptions import IgnoreRequest, NotConfigured",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def _build_redirect_request(source_request, url, **kwargs):",
            "    kwargs['url'] = url",
            "    kwargs['cookies'] = None",
            "    redirect_request = source_request.replace(**kwargs)",
            "    if 'Cookie' in redirect_request.headers:",
            "        source_request_netloc = urlparse_cached(source_request).netloc",
            "        redirect_request_netloc = urlparse_cached(redirect_request).netloc",
            "        if source_request_netloc != redirect_request_netloc:",
            "            del redirect_request.headers['Cookie']",
            "    return redirect_request",
            "",
            "",
            "class BaseRedirectMiddleware(object):",
            "",
            "    enabled_setting = 'REDIRECT_ENABLED'",
            "",
            "    def __init__(self, settings):",
            "        if not settings.getbool(self.enabled_setting):",
            "            raise NotConfigured",
            "",
            "        self.max_redirect_times = settings.getint('REDIRECT_MAX_TIMES')",
            "        self.priority_adjust = settings.getint('REDIRECT_PRIORITY_ADJUST')",
            "",
            "    @classmethod",
            "    def from_crawler(cls, crawler):",
            "        return cls(crawler.settings)",
            "",
            "    def _redirect(self, redirected, request, spider, reason):",
            "        ttl = request.meta.setdefault('redirect_ttl', self.max_redirect_times)",
            "        redirects = request.meta.get('redirect_times', 0) + 1",
            "",
            "        if ttl and redirects <= self.max_redirect_times:",
            "            redirected.meta['redirect_times'] = redirects",
            "            redirected.meta['redirect_ttl'] = ttl - 1",
            "            redirected.meta['redirect_urls'] = request.meta.get('redirect_urls', []) + \\",
            "                [request.url]",
            "            redirected.meta['redirect_reasons'] = request.meta.get('redirect_reasons', []) + \\",
            "                [reason]",
            "            redirected.dont_filter = request.dont_filter",
            "            redirected.priority = request.priority + self.priority_adjust",
            "            logger.debug(\"Redirecting (%(reason)s) to %(redirected)s from %(request)s\",",
            "                         {'reason': reason, 'redirected': redirected, 'request': request},",
            "                         extra={'spider': spider})",
            "            return redirected",
            "        else:",
            "            logger.debug(\"Discarding %(request)s: max redirections reached\",",
            "                         {'request': request}, extra={'spider': spider})",
            "            raise IgnoreRequest(\"max redirections reached\")",
            "",
            "    def _redirect_request_using_get(self, request, redirect_url):",
            "        redirect_request = _build_redirect_request(",
            "            request,",
            "            url=redirect_url,",
            "            method='GET',",
            "            body='',",
            "        )",
            "        redirect_request.headers.pop('Content-Type', None)",
            "        redirect_request.headers.pop('Content-Length', None)",
            "        return redirect_request",
            "",
            "",
            "class RedirectMiddleware(BaseRedirectMiddleware):",
            "    \"\"\"",
            "    Handle redirection of requests based on response status",
            "    and meta-refresh html tag.",
            "    \"\"\"",
            "    def process_response(self, request, response, spider):",
            "        if (request.meta.get('dont_redirect', False) or",
            "                response.status in getattr(spider, 'handle_httpstatus_list', []) or",
            "                response.status in request.meta.get('handle_httpstatus_list', []) or",
            "                request.meta.get('handle_httpstatus_all', False)):",
            "            return response",
            "",
            "        allowed_status = (301, 302, 303, 307, 308)",
            "        if 'Location' not in response.headers or response.status not in allowed_status:",
            "            return response",
            "",
            "        location = safe_url_string(response.headers['location'])",
            "",
            "        redirected_url = urljoin(request.url, location)",
            "",
            "        if response.status in (301, 307, 308) or request.method == 'HEAD':",
            "            redirected = _build_redirect_request(request, url=redirected_url)",
            "            return self._redirect(redirected, request, spider, response.status)",
            "",
            "        redirected = self._redirect_request_using_get(request, redirected_url)",
            "        return self._redirect(redirected, request, spider, response.status)",
            "",
            "",
            "class MetaRefreshMiddleware(BaseRedirectMiddleware):",
            "",
            "    enabled_setting = 'METAREFRESH_ENABLED'",
            "",
            "    def __init__(self, settings):",
            "        super(MetaRefreshMiddleware, self).__init__(settings)",
            "        self._ignore_tags = settings.getlist('METAREFRESH_IGNORE_TAGS')",
            "        self._maxdelay = settings.getint('REDIRECT_MAX_METAREFRESH_DELAY',",
            "                                         settings.getint('METAREFRESH_MAXDELAY'))",
            "",
            "    def process_response(self, request, response, spider):",
            "        if request.meta.get('dont_redirect', False) or request.method == 'HEAD' or \\",
            "                not isinstance(response, HtmlResponse):",
            "            return response",
            "",
            "        interval, url = get_meta_refresh(response,",
            "                                         ignore_tags=self._ignore_tags)",
            "        if url and interval < self._maxdelay:",
            "            redirected = self._redirect_request_using_get(request, url)",
            "            return self._redirect(redirected, request, spider, 'meta refresh')",
            "",
            "        return response"
        ],
        "afterPatchFile": [
            "import logging",
            "from six.moves.urllib.parse import urljoin",
            "",
            "from w3lib.url import safe_url_string",
            "",
            "from scrapy.http import HtmlResponse",
            "from scrapy.utils.httpobj import urlparse_cached",
            "from scrapy.utils.response import get_meta_refresh",
            "from scrapy.exceptions import IgnoreRequest, NotConfigured",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def _build_redirect_request(source_request, url, **kwargs):",
            "    kwargs['url'] = url",
            "    kwargs['cookies'] = None",
            "    redirect_request = source_request.replace(**kwargs)",
            "    has_cookie_header = \"Cookie\" in redirect_request.headers",
            "    has_authorization_header = \"Authorization\" in redirect_request.headers",
            "    if has_cookie_header or has_authorization_header:",
            "        source_request_netloc = urlparse_cached(source_request).netloc",
            "        redirect_request_netloc = urlparse_cached(redirect_request).netloc",
            "        if source_request_netloc != redirect_request_netloc:",
            "            if has_cookie_header:",
            "                del redirect_request.headers[\"Cookie\"]",
            "            # https://fetch.spec.whatwg.org/#ref-for-cors-non-wildcard-request-header-name",
            "            if has_authorization_header:",
            "                del redirect_request.headers[\"Authorization\"]",
            "    return redirect_request",
            "",
            "",
            "class BaseRedirectMiddleware(object):",
            "",
            "    enabled_setting = 'REDIRECT_ENABLED'",
            "",
            "    def __init__(self, settings):",
            "        if not settings.getbool(self.enabled_setting):",
            "            raise NotConfigured",
            "",
            "        self.max_redirect_times = settings.getint('REDIRECT_MAX_TIMES')",
            "        self.priority_adjust = settings.getint('REDIRECT_PRIORITY_ADJUST')",
            "",
            "    @classmethod",
            "    def from_crawler(cls, crawler):",
            "        return cls(crawler.settings)",
            "",
            "    def _redirect(self, redirected, request, spider, reason):",
            "        ttl = request.meta.setdefault('redirect_ttl', self.max_redirect_times)",
            "        redirects = request.meta.get('redirect_times', 0) + 1",
            "",
            "        if ttl and redirects <= self.max_redirect_times:",
            "            redirected.meta['redirect_times'] = redirects",
            "            redirected.meta['redirect_ttl'] = ttl - 1",
            "            redirected.meta['redirect_urls'] = request.meta.get('redirect_urls', []) + \\",
            "                [request.url]",
            "            redirected.meta['redirect_reasons'] = request.meta.get('redirect_reasons', []) + \\",
            "                [reason]",
            "            redirected.dont_filter = request.dont_filter",
            "            redirected.priority = request.priority + self.priority_adjust",
            "            logger.debug(\"Redirecting (%(reason)s) to %(redirected)s from %(request)s\",",
            "                         {'reason': reason, 'redirected': redirected, 'request': request},",
            "                         extra={'spider': spider})",
            "            return redirected",
            "        else:",
            "            logger.debug(\"Discarding %(request)s: max redirections reached\",",
            "                         {'request': request}, extra={'spider': spider})",
            "            raise IgnoreRequest(\"max redirections reached\")",
            "",
            "    def _redirect_request_using_get(self, request, redirect_url):",
            "        redirect_request = _build_redirect_request(",
            "            request,",
            "            url=redirect_url,",
            "            method='GET',",
            "            body='',",
            "        )",
            "        redirect_request.headers.pop('Content-Type', None)",
            "        redirect_request.headers.pop('Content-Length', None)",
            "        return redirect_request",
            "",
            "",
            "class RedirectMiddleware(BaseRedirectMiddleware):",
            "    \"\"\"",
            "    Handle redirection of requests based on response status",
            "    and meta-refresh html tag.",
            "    \"\"\"",
            "    def process_response(self, request, response, spider):",
            "        if (request.meta.get('dont_redirect', False) or",
            "                response.status in getattr(spider, 'handle_httpstatus_list', []) or",
            "                response.status in request.meta.get('handle_httpstatus_list', []) or",
            "                request.meta.get('handle_httpstatus_all', False)):",
            "            return response",
            "",
            "        allowed_status = (301, 302, 303, 307, 308)",
            "        if 'Location' not in response.headers or response.status not in allowed_status:",
            "            return response",
            "",
            "        location = safe_url_string(response.headers['location'])",
            "",
            "        redirected_url = urljoin(request.url, location)",
            "",
            "        if response.status in (301, 307, 308) or request.method == 'HEAD':",
            "            redirected = _build_redirect_request(request, url=redirected_url)",
            "            return self._redirect(redirected, request, spider, response.status)",
            "",
            "        redirected = self._redirect_request_using_get(request, redirected_url)",
            "        return self._redirect(redirected, request, spider, response.status)",
            "",
            "",
            "class MetaRefreshMiddleware(BaseRedirectMiddleware):",
            "",
            "    enabled_setting = 'METAREFRESH_ENABLED'",
            "",
            "    def __init__(self, settings):",
            "        super(MetaRefreshMiddleware, self).__init__(settings)",
            "        self._ignore_tags = settings.getlist('METAREFRESH_IGNORE_TAGS')",
            "        self._maxdelay = settings.getint('REDIRECT_MAX_METAREFRESH_DELAY',",
            "                                         settings.getint('METAREFRESH_MAXDELAY'))",
            "",
            "    def process_response(self, request, response, spider):",
            "        if request.meta.get('dont_redirect', False) or request.method == 'HEAD' or \\",
            "                not isinstance(response, HtmlResponse):",
            "            return response",
            "",
            "        interval, url = get_meta_refresh(response,",
            "                                         ignore_tags=self._ignore_tags)",
            "        if url and interval < self._maxdelay:",
            "            redirected = self._redirect_request_using_get(request, url)",
            "            return self._redirect(redirected, request, spider, 'meta refresh')",
            "",
            "        return response"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "18": [
                "_build_redirect_request"
            ],
            "22": [
                "_build_redirect_request"
            ]
        },
        "addLocation": []
    }
}