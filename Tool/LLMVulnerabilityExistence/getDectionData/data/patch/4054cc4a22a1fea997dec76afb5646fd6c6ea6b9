{
    "nova/api/openstack/compute/plugins/v3/servers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 908,
                "afterPatchRowNumber": 908,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 909,
                "afterPatchRowNumber": 909,
                "PatchRowcode": "         try:"
            },
            "2": {
                "beforePatchRowNumber": 910,
                "afterPatchRowNumber": 910,
                "PatchRowcode": "             inst_type = flavors.get_flavor_by_flavor_id("
            },
            "3": {
                "beforePatchRowNumber": 911,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    flavor_id, read_deleted=\"no\")"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 911,
                "PatchRowcode": "+                    flavor_id, ctxt=context, read_deleted=\"no\")"
            },
            "5": {
                "beforePatchRowNumber": 912,
                "afterPatchRowNumber": 912,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 913,
                "afterPatchRowNumber": 913,
                "PatchRowcode": "             (instances, resv_id) = self.compute_api.create(context,"
            },
            "7": {
                "beforePatchRowNumber": 914,
                "afterPatchRowNumber": 914,
                "PatchRowcode": "                             inst_type,"
            }
        },
        "frontPatchFile": [
            "# Copyright 2010 OpenStack Foundation",
            "# Copyright 2011 Piston Cloud Computing, Inc",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import base64",
            "import os",
            "import re",
            "import stevedore",
            "",
            "from oslo.config import cfg",
            "import webob",
            "from webob import exc",
            "",
            "from nova.api.openstack import common",
            "from nova.api.openstack.compute.plugins.v3 import ips",
            "from nova.api.openstack.compute.views import servers as views_servers",
            "from nova.api.openstack import extensions",
            "from nova.api.openstack import wsgi",
            "from nova.api.openstack import xmlutil",
            "from nova import compute",
            "from nova.compute import flavors",
            "from nova import exception",
            "from nova.objects import instance as instance_obj",
            "from nova.openstack.common.gettextutils import _",
            "from nova.openstack.common import importutils",
            "from nova.openstack.common import log as logging",
            "from nova.openstack.common.rpc import common as rpc_common",
            "from nova.openstack.common import strutils",
            "from nova.openstack.common import timeutils",
            "from nova.openstack.common import uuidutils",
            "from nova import utils",
            "",
            "",
            "CONF = cfg.CONF",
            "CONF.import_opt('enable_instance_password',",
            "                'nova.api.openstack.compute.servers')",
            "CONF.import_opt('network_api_class', 'nova.network')",
            "CONF.import_opt('reclaim_instance_interval', 'nova.compute.manager')",
            "CONF.import_opt('extensions_blacklist', 'nova.api.openstack', group='osapi_v3')",
            "CONF.import_opt('extensions_whitelist', 'nova.api.openstack', group='osapi_v3')",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "def make_fault(elem):",
            "    fault = xmlutil.SubTemplateElement(elem, 'fault', selector='fault')",
            "    fault.set('code')",
            "    fault.set('created')",
            "    msg = xmlutil.SubTemplateElement(fault, 'message')",
            "    msg.text = 'message'",
            "    det = xmlutil.SubTemplateElement(fault, 'details')",
            "    det.text = 'details'",
            "",
            "",
            "def make_server(elem, detailed=False):",
            "    elem.set('name')",
            "    elem.set('id')",
            "",
            "    if detailed:",
            "        elem.set('user_id')",
            "        elem.set('tenant_id')",
            "        elem.set('updated')",
            "        elem.set('created')",
            "        elem.set('host_id')",
            "        elem.set('access_ip_v4')",
            "        elem.set('access_ip_v6')",
            "        elem.set('status')",
            "        elem.set('progress')",
            "        elem.set('reservation_id')",
            "",
            "        # Attach image node",
            "        image = xmlutil.SubTemplateElement(elem, 'image', selector='image')",
            "        image.set('id')",
            "        xmlutil.make_links(image, 'links')",
            "",
            "        # Attach flavor node",
            "        flavor = xmlutil.SubTemplateElement(elem, 'flavor', selector='flavor')",
            "        flavor.set('id')",
            "        xmlutil.make_links(flavor, 'links')",
            "",
            "        # Attach fault node",
            "        make_fault(elem)",
            "",
            "        # Attach metadata node",
            "        elem.append(common.MetadataTemplate())",
            "",
            "        # Attach addresses node",
            "        elem.append(ips.AddressesTemplate())",
            "",
            "    xmlutil.make_links(elem, 'links')",
            "",
            "",
            "server_nsmap = {None: xmlutil.XMLNS_V11, 'atom': xmlutil.XMLNS_ATOM}",
            "",
            "",
            "class ServerTemplate(xmlutil.TemplateBuilder):",
            "    def construct(self):",
            "        root = xmlutil.TemplateElement('server', selector='server')",
            "        make_server(root, detailed=True)",
            "        return xmlutil.MasterTemplate(root, 1, nsmap=server_nsmap)",
            "",
            "",
            "class MinimalServersTemplate(xmlutil.TemplateBuilder):",
            "    def construct(self):",
            "        root = xmlutil.TemplateElement('servers')",
            "        elem = xmlutil.SubTemplateElement(root, 'server', selector='servers')",
            "        make_server(elem)",
            "        xmlutil.make_links(root, 'servers_links')",
            "        return xmlutil.MasterTemplate(root, 1, nsmap=server_nsmap)",
            "",
            "",
            "class ServersTemplate(xmlutil.TemplateBuilder):",
            "    def construct(self):",
            "        root = xmlutil.TemplateElement('servers')",
            "        elem = xmlutil.SubTemplateElement(root, 'server', selector='servers')",
            "        make_server(elem, detailed=True)",
            "        return xmlutil.MasterTemplate(root, 1, nsmap=server_nsmap)",
            "",
            "",
            "class ServerAdminPassTemplate(xmlutil.TemplateBuilder):",
            "    def construct(self):",
            "        root = xmlutil.TemplateElement('server')",
            "        root.set('admin_pass')",
            "        return xmlutil.SlaveTemplate(root, 1, nsmap=server_nsmap)",
            "",
            "",
            "class ServerMultipleCreateTemplate(xmlutil.TemplateBuilder):",
            "    def construct(self):",
            "        root = xmlutil.TemplateElement('server')",
            "        root.set('reservation_id')",
            "        return xmlutil.MasterTemplate(root, 1, nsmap=server_nsmap)",
            "",
            "",
            "def FullServerTemplate():",
            "    master = ServerTemplate()",
            "    master.attach(ServerAdminPassTemplate())",
            "    return master",
            "",
            "",
            "class CommonDeserializer(wsgi.MetadataXMLDeserializer):",
            "    \"\"\"Common deserializer to handle xml-formatted server create requests.",
            "",
            "    Handles standard server attributes as well as optional metadata",
            "    and personality attributes",
            "    \"\"\"",
            "",
            "    metadata_deserializer = common.MetadataXMLDeserializer()",
            "    want_controller = True",
            "",
            "    def __init__(self, controller):",
            "        self.controller = controller",
            "",
            "    def _extract_server(self, node):",
            "        \"\"\"Marshal the server attribute of a parsed request.\"\"\"",
            "        server = {}",
            "        server_node = self.find_first_child_named(node, 'server')",
            "",
            "        attributes = [\"name\", \"image_ref\", \"flavor_ref\", \"admin_pass\",",
            "                      \"access_ip_v4\", \"access_ip_v6\", \"key_name\",",
            "                      \"min_count\", \"max_count\"]",
            "        for attr in attributes:",
            "            if server_node.getAttribute(attr):",
            "                server[attr] = server_node.getAttribute(attr)",
            "",
            "        res_id = server_node.getAttribute('return_reservation_id')",
            "        if res_id:",
            "            server['return_reservation_id'] = strutils.bool_from_string(res_id)",
            "",
            "        metadata_node = self.find_first_child_named(server_node, \"metadata\")",
            "        if metadata_node is not None:",
            "            server[\"metadata\"] = self.extract_metadata(metadata_node)",
            "",
            "        networks = self._extract_networks(server_node)",
            "        if networks is not None:",
            "            server[\"networks\"] = networks",
            "",
            "        security_groups = self._extract_security_groups(server_node)",
            "        if security_groups is not None:",
            "            server[\"security_groups\"] = security_groups",
            "",
            "        # NOTE(vish): this is not namespaced in json, so leave it without a",
            "        #             namespace for now",
            "        block_device_mapping = self._extract_block_device_mapping(server_node)",
            "        if block_device_mapping is not None:",
            "            server[\"block_device_mapping\"] = block_device_mapping",
            "",
            "        if self.controller:",
            "            self.controller.server_create_xml_deserialize(server_node, server)",
            "",
            "        return server",
            "",
            "    def _extract_block_device_mapping(self, server_node):",
            "        \"\"\"Marshal the block_device_mapping node of a parsed request.\"\"\"",
            "        node = self.find_first_child_named(server_node, \"block_device_mapping\")",
            "        if node:",
            "            block_device_mapping = []",
            "            for child in self.extract_elements(node):",
            "                if child.nodeName != \"mapping\":",
            "                    continue",
            "                mapping = {}",
            "                attributes = [\"volume_id\", \"snapshot_id\", \"device_name\",",
            "                              \"virtual_name\", \"volume_size\"]",
            "                for attr in attributes:",
            "                    value = child.getAttribute(attr)",
            "                    if value:",
            "                        mapping[attr] = value",
            "                attributes = [\"delete_on_termination\", \"no_device\"]",
            "                for attr in attributes:",
            "                    value = child.getAttribute(attr)",
            "                    if value:",
            "                        mapping[attr] = strutils.bool_from_string(value)",
            "                block_device_mapping.append(mapping)",
            "            return block_device_mapping",
            "        else:",
            "            return None",
            "",
            "    def _extract_networks(self, server_node):",
            "        \"\"\"Marshal the networks attribute of a parsed request.\"\"\"",
            "        node = self.find_first_child_named(server_node, \"networks\")",
            "        if node is not None:",
            "            networks = []",
            "            for network_node in self.find_children_named(node,",
            "                                                         \"network\"):",
            "                item = {}",
            "                if network_node.hasAttribute(\"uuid\"):",
            "                    item[\"uuid\"] = network_node.getAttribute(\"uuid\")",
            "                if network_node.hasAttribute(\"fixed_ip\"):",
            "                    item[\"fixed_ip\"] = network_node.getAttribute(\"fixed_ip\")",
            "                if network_node.hasAttribute(\"port\"):",
            "                    item[\"port\"] = network_node.getAttribute(\"port\")",
            "                networks.append(item)",
            "            return networks",
            "        else:",
            "            return None",
            "",
            "    def _extract_security_groups(self, server_node):",
            "        \"\"\"Marshal the security_groups attribute of a parsed request.\"\"\"",
            "        node = self.find_first_child_named(server_node, \"security_groups\")",
            "        if node is not None:",
            "            security_groups = []",
            "            for sg_node in self.find_children_named(node, \"security_group\"):",
            "                item = {}",
            "                name = self.find_attribute_or_element(sg_node, 'name')",
            "                if name:",
            "                    item[\"name\"] = name",
            "                    security_groups.append(item)",
            "            return security_groups",
            "        else:",
            "            return None",
            "",
            "",
            "class ActionDeserializer(CommonDeserializer):",
            "    \"\"\"Deserializer to handle xml-formatted server action requests.",
            "",
            "    Handles standard server attributes as well as optional metadata",
            "    and personality attributes",
            "    \"\"\"",
            "",
            "    def default(self, string):",
            "        dom = xmlutil.safe_minidom_parse_string(string)",
            "        action_node = dom.childNodes[0]",
            "        action_name = action_node.tagName",
            "",
            "        action_deserializer = {",
            "            'create_image': self._action_create_image,",
            "            'reboot': self._action_reboot,",
            "            'rebuild': self._action_rebuild,",
            "            'resize': self._action_resize,",
            "            'confirm_resize': self._action_confirm_resize,",
            "            'revert_resize': self._action_revert_resize,",
            "        }.get(action_name, super(ActionDeserializer, self).default)",
            "",
            "        action_data = action_deserializer(action_node)",
            "",
            "        return {'body': {action_name: action_data}}",
            "",
            "    def _action_create_image(self, node):",
            "        return self._deserialize_image_action(node, ('name',))",
            "",
            "    def _action_reboot(self, node):",
            "        if not node.hasAttribute(\"type\"):",
            "            raise AttributeError(\"No reboot type was specified in request\")",
            "        return {\"type\": node.getAttribute(\"type\")}",
            "",
            "    def _action_rebuild(self, node):",
            "        rebuild = {}",
            "        if node.hasAttribute(\"name\"):",
            "            name = node.getAttribute(\"name\")",
            "            if not name:",
            "                raise AttributeError(\"Name cannot be blank\")",
            "            rebuild['name'] = name",
            "",
            "        metadata_node = self.find_first_child_named(node, \"metadata\")",
            "        if metadata_node is not None:",
            "            rebuild[\"metadata\"] = self.extract_metadata(metadata_node)",
            "",
            "        if not node.hasAttribute(\"image_ref\"):",
            "            raise AttributeError(\"No image_ref was specified in request\")",
            "        rebuild[\"image_ref\"] = node.getAttribute(\"image_ref\")",
            "",
            "        if node.hasAttribute(\"admin_pass\"):",
            "            rebuild[\"admin_pass\"] = node.getAttribute(\"admin_pass\")",
            "",
            "        if node.hasAttribute(\"access_ipv4\"):",
            "            rebuild[\"access_ip_v4\"] = node.getAttribute(\"access_ip_v4\")",
            "",
            "        if node.hasAttribute(\"access_ipv6\"):",
            "            rebuild[\"access_ip_v6\"] = node.getAttribute(\"access_ip_v6\")",
            "",
            "        if self.controller:",
            "            self.controller.server_rebuild_xml_deserialize(node, rebuild)",
            "        return rebuild",
            "",
            "    def _action_resize(self, node):",
            "        resize = {}",
            "",
            "        if node.hasAttribute(\"flavor_ref\"):",
            "            resize[\"flavor_ref\"] = node.getAttribute(\"flavor_ref\")",
            "        else:",
            "            raise AttributeError(\"No flavor_ref was specified in request\")",
            "",
            "        if self.controller:",
            "            self.controller.server_resize_xml_deserialize(node, resize)",
            "        return resize",
            "",
            "    def _action_confirm_resize(self, node):",
            "        return None",
            "",
            "    def _action_revert_resize(self, node):",
            "        return None",
            "",
            "    def _deserialize_image_action(self, node, allowed_attributes):",
            "        data = {}",
            "        for attribute in allowed_attributes:",
            "            value = node.getAttribute(attribute)",
            "            if value:",
            "                data[attribute] = value",
            "        metadata_node = self.find_first_child_named(node, 'metadata')",
            "        if metadata_node is not None:",
            "            metadata = self.metadata_deserializer.extract_metadata(",
            "                                                        metadata_node)",
            "            data['metadata'] = metadata",
            "        return data",
            "",
            "",
            "class CreateDeserializer(CommonDeserializer):",
            "    \"\"\"Deserializer to handle xml-formatted server create requests.",
            "",
            "    Handles standard server attributes as well as optional metadata",
            "    and personality attributes",
            "    \"\"\"",
            "",
            "    def default(self, string):",
            "        \"\"\"Deserialize an xml-formatted server create request.\"\"\"",
            "        dom = xmlutil.safe_minidom_parse_string(string)",
            "        server = self._extract_server(dom)",
            "        return {'body': {'server': server}}",
            "",
            "",
            "class ServersController(wsgi.Controller):",
            "    \"\"\"The Server API base controller class for the OpenStack API.\"\"\"",
            "",
            "    EXTENSION_CREATE_NAMESPACE = 'nova.api.v3.extensions.server.create'",
            "    EXTENSION_DESERIALIZE_EXTRACT_SERVER_NAMESPACE = (",
            "        'nova.api.v3.extensions.server.create.deserialize')",
            "",
            "    EXTENSION_REBUILD_NAMESPACE = 'nova.api.v3.extensions.server.rebuild'",
            "    EXTENSION_DESERIALIZE_EXTRACT_REBUILD_NAMESPACE = (",
            "        'nova.api.v3.extensions.server.rebuild.deserialize')",
            "",
            "    EXTENSION_RESIZE_NAMESPACE = 'nova.api.v3.extensions.server.resize'",
            "    EXTENSION_DESERIALIZE_EXTRACT_RESIZE_NAMESPACE = (",
            "        'nova.api.v3.extensions.server.resize.deserialize')",
            "",
            "    EXTENSION_UPDATE_NAMESPACE = 'nova.api.v3.extensions.server.update'",
            "",
            "    _view_builder_class = views_servers.ViewBuilderV3",
            "",
            "    @staticmethod",
            "    def _add_location(robj):",
            "        # Just in case...",
            "        if 'server' not in robj.obj:",
            "            return robj",
            "",
            "        link = filter(lambda l: l['rel'] == 'self',",
            "                      robj.obj['server']['links'])",
            "        if link:",
            "            robj['Location'] = link[0]['href'].encode('utf-8')",
            "",
            "        # Convenience return",
            "        return robj",
            "",
            "    def __init__(self, **kwargs):",
            "        def _check_load_extension(required_function):",
            "",
            "            def check_whiteblack_lists(ext):",
            "                # Check whitelist is either empty or if not then the extension",
            "                # is in the whitelist",
            "                if (not CONF.osapi_v3.extensions_whitelist or",
            "                        ext.obj.alias in CONF.osapi_v3.extensions_whitelist):",
            "",
            "                    # Check the extension is not in the blacklist",
            "                    if ext.obj.alias not in CONF.osapi_v3.extensions_blacklist:",
            "                        return True",
            "                    else:",
            "                        LOG.warning(_(\"Not loading %s because it is \"",
            "                                      \"in the blacklist\"), ext.obj.alias)",
            "                        return False",
            "                else:",
            "                    LOG.warning(",
            "                        _(\"Not loading %s because it is not in the whitelist\"),",
            "                        ext.obj.alias)",
            "                    return False",
            "",
            "            def check_load_extension(ext):",
            "                if isinstance(ext.obj, extensions.V3APIExtensionBase):",
            "                    # Filter out for the existence of the required",
            "                    # function here rather than on every request. We",
            "                    # don't have a new abstract base class to reduce",
            "                    # duplication in the extensions as they may want",
            "                    # to implement multiple server (and other) entry",
            "                    # points if hasattr(ext.obj, 'server_create'):",
            "                    if hasattr(ext.obj, required_function):",
            "                        LOG.debug(_('extension %(ext_alias)s detected by '",
            "                                    'servers extension for function %(func)s'),",
            "                                    {'ext_alias': ext.obj.alias,",
            "                                     'func': required_function})",
            "                        return check_whiteblack_lists(ext)",
            "                    else:",
            "                        LOG.debug(",
            "                            _('extension %(ext_alias)s is missing %(func)s'),",
            "                            {'ext_alias': ext.obj.alias,",
            "                            'func': required_function})",
            "                        return False",
            "                else:",
            "                    return False",
            "            return check_load_extension",
            "",
            "        self.extension_info = kwargs.pop('extension_info')",
            "        super(ServersController, self).__init__(**kwargs)",
            "        self.compute_api = compute.API()",
            "        self.neutron_attempted = False",
            "",
            "        # Look for implmentation of extension point of server creation",
            "        self.create_extension_manager = \\",
            "          stevedore.enabled.EnabledExtensionManager(",
            "              namespace=self.EXTENSION_CREATE_NAMESPACE,",
            "              check_func=_check_load_extension('server_create'),",
            "              invoke_on_load=True,",
            "              invoke_kwds={\"extension_info\": self.extension_info},",
            "              propagate_map_exceptions=True)",
            "        if not list(self.create_extension_manager):",
            "            LOG.debug(_(\"Did not find any server create extensions\"))",
            "",
            "        # Look for implmentation of extension point of server create",
            "        # XML deserialization",
            "        self.create_xml_deserialize_manager = \\",
            "          stevedore.enabled.EnabledExtensionManager(",
            "              namespace=self.EXTENSION_DESERIALIZE_EXTRACT_SERVER_NAMESPACE,",
            "              check_func=_check_load_extension(",
            "                  'server_xml_extract_server_deserialize'),",
            "              invoke_on_load=True,",
            "              invoke_kwds={\"extension_info\": self.extension_info},",
            "              propagate_map_exceptions=True)",
            "        if not list(self.create_xml_deserialize_manager):",
            "            LOG.debug(_(\"Did not find any server create xml deserializer\"",
            "                        \" extensions\"))",
            "",
            "        # Look for implmentation of extension point of server rebuild",
            "        self.rebuild_extension_manager = \\",
            "            stevedore.enabled.EnabledExtensionManager(",
            "                namespace=self.EXTENSION_REBUILD_NAMESPACE,",
            "                check_func=_check_load_extension('server_rebuild'),",
            "                invoke_on_load=True,",
            "                invoke_kwds={\"extension_info\": self.extension_info})",
            "        if not list(self.rebuild_extension_manager):",
            "            LOG.debug(_(\"Did not find any server rebuild extensions\"))",
            "",
            "        # Look for implmentation of extension point of server rebuild",
            "        # XML deserialization",
            "        self.rebuild_xml_deserialize_manager = \\",
            "            stevedore.enabled.EnabledExtensionManager(",
            "                namespace=self.EXTENSION_DESERIALIZE_EXTRACT_REBUILD_NAMESPACE,",
            "                check_func=_check_load_extension(",
            "                    'server_xml_extract_rebuild_deserialize'),",
            "                invoke_on_load=True,",
            "                invoke_kwds={\"extension_info\": self.extension_info})",
            "        if not list(self.rebuild_xml_deserialize_manager):",
            "            LOG.debug(_(\"Did not find any server rebuild xml deserializer\"",
            "                        \" extensions\"))",
            "",
            "        # Look for implmentation of extension point of server resize",
            "        self.resize_extension_manager = \\",
            "            stevedore.enabled.EnabledExtensionManager(",
            "                namespace=self.EXTENSION_RESIZE_NAMESPACE,",
            "                check_func=_check_load_extension('server_resize'),",
            "                invoke_on_load=True,",
            "                invoke_kwds={\"extension_info\": self.extension_info})",
            "        if not list(self.resize_extension_manager):",
            "            LOG.debug(_(\"Did not find any server resize extensions\"))",
            "",
            "        # Look for implmentation of extension point of server resize",
            "        # XML deserialization",
            "        self.resize_xml_deserialize_manager = \\",
            "            stevedore.enabled.EnabledExtensionManager(",
            "                namespace=self.EXTENSION_DESERIALIZE_EXTRACT_RESIZE_NAMESPACE,",
            "                check_func=_check_load_extension(",
            "                    'server_xml_extract_resize_deserialize'),",
            "                invoke_on_load=True,",
            "                invoke_kwds={\"extension_info\": self.extension_info})",
            "        if not list(self.resize_xml_deserialize_manager):",
            "            LOG.debug(_(\"Did not find any server resize xml deserializer\"",
            "                        \" extensions\"))",
            "",
            "        # Look for implmentation of extension point of server update",
            "        self.update_extension_manager = \\",
            "            stevedore.enabled.EnabledExtensionManager(",
            "                namespace=self.EXTENSION_UPDATE_NAMESPACE,",
            "                check_func=_check_load_extension('server_resize'),",
            "                invoke_on_load=True,",
            "                invoke_kwds={\"extension_info\": self.extension_info})",
            "        if not list(self.update_extension_manager):",
            "            LOG.debug(_(\"Did not find any server update extensions\"))",
            "",
            "    @wsgi.serializers(xml=MinimalServersTemplate)",
            "    def index(self, req):",
            "        \"\"\"Returns a list of server names and ids for a given user.\"\"\"",
            "        try:",
            "            servers = self._get_servers(req, is_detail=False)",
            "        except exception.Invalid as err:",
            "            raise exc.HTTPBadRequest(explanation=err.format_message())",
            "        return servers",
            "",
            "    @wsgi.serializers(xml=ServersTemplate)",
            "    def detail(self, req):",
            "        \"\"\"Returns a list of server details for a given user.\"\"\"",
            "        try:",
            "            servers = self._get_servers(req, is_detail=True)",
            "        except exception.Invalid as err:",
            "            raise exc.HTTPBadRequest(explanation=err.format_message())",
            "        return servers",
            "",
            "    def _get_servers(self, req, is_detail):",
            "        \"\"\"Returns a list of servers, based on any search options specified.\"\"\"",
            "",
            "        search_opts = {}",
            "        search_opts.update(req.GET)",
            "",
            "        context = req.environ['nova.context']",
            "        remove_invalid_options(context, search_opts,",
            "                self._get_server_search_options())",
            "",
            "        # Verify search by 'status' contains a valid status.",
            "        # Convert it to filter by vm_state for compute_api.",
            "        status = search_opts.pop('status', None)",
            "        if status is not None:",
            "            state = common.vm_state_from_status(status)",
            "            if state is None:",
            "                return {'servers': []}",
            "            search_opts['vm_state'] = state",
            "",
            "        if 'changes_since' in search_opts:",
            "            try:",
            "                parsed = timeutils.parse_isotime(search_opts['changes_since'])",
            "            except ValueError:",
            "                msg = _('Invalid changes_since value')",
            "                raise exc.HTTPBadRequest(explanation=msg)",
            "            search_opts['changes_since'] = parsed",
            "",
            "        # By default, compute's get_all() will return deleted instances.",
            "        # If an admin hasn't specified a 'deleted' search option, we need",
            "        # to filter out deleted instances by setting the filter ourselves.",
            "        # ... Unless 'changes_since' is specified, because 'changes_since'",
            "        # should return recently deleted images according to the API spec.",
            "",
            "        if 'deleted' not in search_opts:",
            "            if 'changes_since' not in search_opts:",
            "                # No 'changes_since', so we only want non-deleted servers",
            "                search_opts['deleted'] = False",
            "",
            "        if search_opts.get(\"vm_state\") == \"deleted\":",
            "            if context.is_admin:",
            "                search_opts['deleted'] = True",
            "            else:",
            "                msg = _(\"Only administrators may list deleted instances\")",
            "                raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        if 'all_tenants' not in search_opts:",
            "            if context.project_id:",
            "                search_opts['project_id'] = context.project_id",
            "            else:",
            "                search_opts['user_id'] = context.user_id",
            "",
            "        limit, marker = common.get_limit_and_marker(req)",
            "        try:",
            "            instance_list = self.compute_api.get_all(context,",
            "                                                     search_opts=search_opts,",
            "                                                     limit=limit,",
            "                                                     marker=marker,",
            "                                                     want_objects=True)",
            "        except exception.MarkerNotFound as e:",
            "            msg = _('marker [%s] not found') % marker",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.FlavorNotFound as e:",
            "            log_msg = _(\"Flavor '%s' could not be found \")",
            "            LOG.debug(log_msg, search_opts['flavor'])",
            "            instance_list = []",
            "",
            "        if is_detail:",
            "            instance_list.fill_faults()",
            "            response = self._view_builder.detail(req, instance_list)",
            "        else:",
            "            response = self._view_builder.index(req, instance_list)",
            "        req.cache_db_instances(instance_list)",
            "        return response",
            "",
            "    def _get_server(self, context, req, instance_uuid):",
            "        \"\"\"Utility function for looking up an instance by uuid.\"\"\"",
            "        try:",
            "            instance = self.compute_api.get(context, instance_uuid,",
            "                                            want_objects=True)",
            "        except exception.NotFound:",
            "            msg = _(\"Instance could not be found\")",
            "            raise exc.HTTPNotFound(explanation=msg)",
            "        req.cache_db_instance(instance)",
            "        return instance",
            "",
            "    def _check_string_length(self, value, name, max_length=None):",
            "        try:",
            "            utils.check_string_length(value, name, min_length=1,",
            "                                      max_length=max_length)",
            "        except exception.InvalidInput as e:",
            "            raise exc.HTTPBadRequest(explanation=e.format_message())",
            "",
            "    def _validate_server_name(self, value):",
            "        self._check_string_length(value, 'Server name', max_length=255)",
            "",
            "    def _validate_device_name(self, value):",
            "        self._check_string_length(value, 'Device name', max_length=255)",
            "",
            "        if ' ' in value:",
            "            msg = _(\"Device name cannot include spaces.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "    def _is_neutron_v2(self):",
            "        # NOTE(dprince): neutron is not a requirement",
            "        if self.neutron_attempted:",
            "            return self.have_neutron",
            "",
            "        try:",
            "            # compatibility with Folsom/Grizzly configs",
            "            cls_name = CONF.network_api_class",
            "            if cls_name == 'nova.network.quantumv2.api.API':",
            "                cls_name = 'nova.network.neutronv2.api.API'",
            "",
            "            self.neutron_attempted = True",
            "            from nova.network.neutronv2 import api as neutron_api",
            "            self.have_neutron = issubclass(",
            "                importutils.import_class(cls_name),",
            "                neutron_api.API)",
            "        except ImportError:",
            "            self.have_neutron = False",
            "",
            "        return self.have_neutron",
            "",
            "    def _get_requested_networks(self, requested_networks):",
            "        \"\"\"Create a list of requested networks from the networks attribute.\"\"\"",
            "        networks = []",
            "        for network in requested_networks:",
            "            try:",
            "                # fixed IP address is optional",
            "                # if the fixed IP address is not provided then",
            "                # it will use one of the available IP address from the network",
            "                address = network.get('fixed_ip', None)",
            "                if address is not None and not utils.is_valid_ipv4(address):",
            "                    msg = _(\"Invalid fixed IP address (%s)\") % address",
            "                    raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "                port_id = network.get('port', None)",
            "                if port_id:",
            "                    network_uuid = None",
            "                    if not self._is_neutron_v2():",
            "                        # port parameter is only for neutron v2.0",
            "                        msg = _(\"Unknown argument: port\")",
            "                        raise exc.HTTPBadRequest(explanation=msg)",
            "                    if not uuidutils.is_uuid_like(port_id):",
            "                        msg = _(\"Bad port format: port uuid is \"",
            "                                \"not in proper format \"",
            "                                \"(%s)\") % port_id",
            "                        raise exc.HTTPBadRequest(explanation=msg)",
            "                    if address is not None:",
            "                        msg = _(\"Specified Fixed IP '%(addr)s' cannot be used \"",
            "                                \"with port '%(port)s': port already has \"",
            "                                \"a Fixed IP allocated.\") % {\"addr\": address,",
            "                                                            \"port\": port_id}",
            "                        raise exc.HTTPBadRequest(explanation=msg)",
            "                else:",
            "                    network_uuid = network['uuid']",
            "",
            "                if not port_id and not uuidutils.is_uuid_like(network_uuid):",
            "                    br_uuid = network_uuid.split('-', 1)[-1]",
            "                    if not uuidutils.is_uuid_like(br_uuid):",
            "                        msg = _(\"Bad networks format: network uuid is \"",
            "                                \"not in proper format \"",
            "                                \"(%s)\") % network_uuid",
            "                        raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "                # For neutronv2, requested_networks",
            "                # should be tuple of (network_uuid, fixed_ip, port_id)",
            "                if self._is_neutron_v2():",
            "                    networks.append((network_uuid, address, port_id))",
            "                else:",
            "                    # check if the network id is already present in the list,",
            "                    # we don't want duplicate networks to be passed",
            "                    # at the boot time",
            "                    for id, ip in networks:",
            "                        if id == network_uuid:",
            "                            expl = (_(\"Duplicate networks\"",
            "                                      \" (%s) are not allowed\") %",
            "                                    network_uuid)",
            "                            raise exc.HTTPBadRequest(explanation=expl)",
            "                    networks.append((network_uuid, address))",
            "            except KeyError as key:",
            "                expl = _('Bad network format: missing %s') % key",
            "                raise exc.HTTPBadRequest(explanation=expl)",
            "            except TypeError:",
            "                expl = _('Bad networks format')",
            "                raise exc.HTTPBadRequest(explanation=expl)",
            "",
            "        return networks",
            "",
            "    # NOTE(vish): Without this regex, b64decode will happily",
            "    #             ignore illegal bytes in the base64 encoded",
            "    #             data.",
            "    B64_REGEX = re.compile('^(?:[A-Za-z0-9+\\/]{4})*'",
            "                           '(?:[A-Za-z0-9+\\/]{2}=='",
            "                           '|[A-Za-z0-9+\\/]{3}=)?$')",
            "",
            "    def _decode_base64(self, data):",
            "        data = re.sub(r'\\s', '', data)",
            "        if not self.B64_REGEX.match(data):",
            "            return None",
            "        try:",
            "            return base64.b64decode(data)",
            "        except TypeError:",
            "            return None",
            "",
            "    def _validate_access_ipv4(self, address):",
            "        if not utils.is_valid_ipv4(address):",
            "            expl = _('access_ip_v4 is not proper IPv4 format')",
            "            raise exc.HTTPBadRequest(explanation=expl)",
            "",
            "    def _validate_access_ipv6(self, address):",
            "        if not utils.is_valid_ipv6(address):",
            "            expl = _('access_ip_v6 is not proper IPv6 format')",
            "            raise exc.HTTPBadRequest(explanation=expl)",
            "",
            "    @wsgi.serializers(xml=ServerTemplate)",
            "    def show(self, req, id):",
            "        \"\"\"Returns server details by server id.\"\"\"",
            "        try:",
            "            context = req.environ['nova.context']",
            "            instance = self.compute_api.get(context, id, want_objects=True)",
            "            req.cache_db_instance(instance)",
            "            return self._view_builder.show(req, instance)",
            "        except exception.NotFound:",
            "            msg = _(\"Instance could not be found\")",
            "            raise exc.HTTPNotFound(explanation=msg)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=CreateDeserializer)",
            "    def create(self, req, body):",
            "        \"\"\"Creates a new server for a given user.\"\"\"",
            "        if not self.is_valid_body(body, 'server'):",
            "            raise exc.HTTPUnprocessableEntity()",
            "",
            "        context = req.environ['nova.context']",
            "        server_dict = body['server']",
            "        password = self._get_server_admin_password(server_dict)",
            "",
            "        if 'name' not in server_dict:",
            "            msg = _(\"Server name is not defined\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        name = server_dict['name']",
            "        self._validate_server_name(name)",
            "        name = name.strip()",
            "",
            "        image_uuid = self._image_from_req_data(body)",
            "",
            "        # Arguments to be passed to instance create function",
            "        create_kwargs = {}",
            "",
            "        # Query extensions which want to manipulate the keyword",
            "        # arguments.",
            "        # NOTE(cyeoh): This is the hook that extensions use",
            "        # to replace the extension specific code below.",
            "        # When the extensions are ported this will also result",
            "        # in some convenience function from this class being",
            "        # moved to the extension",
            "        if list(self.create_extension_manager):",
            "            self.create_extension_manager.map(self._create_extension_point,",
            "                                              server_dict, create_kwargs)",
            "        # TODO(cyeoh): bp v3-api-core-as-extensions",
            "        # Replace with an extension point when the security groups",
            "        # extension is ported",
            "        sg_names = []",
            "        #if self.ext_mgr.is_loaded('os-security-groups'):",
            "        #    security_groups = server_dict.get('security_groups')",
            "        #    if security_groups is not None:",
            "        #        sg_names = [sg['name'] for sg in security_groups",
            "        #                    if sg.get('name')]",
            "        if not sg_names:",
            "            sg_names.append('default')",
            "",
            "        sg_names = list(set(sg_names))",
            "",
            "        requested_networks = None",
            "        # TODO(cyeoh): bp v3-api-core-as-extensions",
            "        # Replace with an extension point when the os-networks",
            "        # extension is ported. Currently reworked",
            "        # to take into account _is_neutron_v2",
            "        #if (self.ext_mgr.is_loaded('os-networks')",
            "        #        or self._is_neutron_v2()):",
            "        #    requested_networks = server_dict.get('networks')",
            "",
            "        if self._is_neutron_v2():",
            "            requested_networks = server_dict.get('networks')",
            "        if requested_networks is not None:",
            "            requested_networks = self._get_requested_networks(",
            "                requested_networks)",
            "",
            "        (access_ip_v4, ) = server_dict.get('access_ip_v4'),",
            "        if access_ip_v4 is not None:",
            "            self._validate_access_ipv4(access_ip_v4)",
            "",
            "        (access_ip_v6, ) = server_dict.get('access_ip_v6'),",
            "        if access_ip_v6 is not None:",
            "            self._validate_access_ipv6(access_ip_v6)",
            "",
            "        try:",
            "            flavor_id = self._flavor_id_from_req_data(body)",
            "        except ValueError as error:",
            "            msg = _(\"Invalid flavor_ref provided.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        block_device_mapping = None",
            "        # TODO(cyeoh): bp v3-api-core-as-extensions",
            "        # Replace with an extension point when the os-volumes",
            "        # extension is ported",
            "        #if self.ext_mgr.is_loaded('os-volumes'):",
            "        #    block_device_mapping = server_dict.get('block_device_mapping', [])",
            "        #    for bdm in block_device_mapping:",
            "        #        self._validate_device_name(bdm[\"device_name\"])",
            "        #        if 'delete_on_termination' in bdm:",
            "        #            bdm['delete_on_termination'] = strutils.bool_from_string(",
            "        #                bdm['delete_on_termination'])",
            "",
            "        ret_resv_id = False",
            "        # min_count and max_count are optional.  If they exist, they may come",
            "        # in as strings.  Verify that they are valid integers and > 0.",
            "        # Also, we want to default 'min_count' to 1, and default",
            "        # 'max_count' to be 'min_count'.",
            "        min_count = 1",
            "        max_count = 1",
            "        # TODO(cyeoh): bp v3-api-core-as-extensions",
            "        # Replace with an extension point when the os-multiple-create",
            "        # extension is ported",
            "        #if self.ext_mgr.is_loaded('os-multiple-create'):",
            "        #    ret_resv_id = server_dict.get('return_reservation_id', False)",
            "        #    min_count = server_dict.get('min_count', 1)",
            "        #    max_count = server_dict.get('max_count', min_count)",
            "",
            "        try:",
            "            min_count = int(str(min_count))",
            "        except ValueError:",
            "            msg = _('min_count must be an integer value')",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        if min_count < 1:",
            "            msg = _('min_count must be > 0')",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        try:",
            "            max_count = int(str(max_count))",
            "        except ValueError:",
            "            msg = _('max_count must be an integer value')",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        if max_count < 1:",
            "            msg = _('max_count must be > 0')",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        if min_count > max_count:",
            "            msg = _('min_count must be <= max_count')",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        try:",
            "            inst_type = flavors.get_flavor_by_flavor_id(",
            "                    flavor_id, read_deleted=\"no\")",
            "",
            "            (instances, resv_id) = self.compute_api.create(context,",
            "                            inst_type,",
            "                            image_uuid,",
            "                            display_name=name,",
            "                            display_description=name,",
            "                            metadata=server_dict.get('metadata', {}),",
            "                            access_ip_v4=access_ip_v4,",
            "                            access_ip_v6=access_ip_v6,",
            "                            admin_password=password,",
            "                            min_count=min_count,",
            "                            max_count=max_count,",
            "                            requested_networks=requested_networks,",
            "                            security_group=sg_names,",
            "                            block_device_mapping=block_device_mapping,",
            "                            **create_kwargs)",
            "        except exception.QuotaError as error:",
            "            raise exc.HTTPRequestEntityTooLarge(",
            "                explanation=error.format_message(),",
            "                headers={'Retry-After': 0})",
            "        except exception.InvalidMetadataSize as error:",
            "            raise exc.HTTPRequestEntityTooLarge(",
            "                explanation=error.format_message())",
            "        except exception.ImageNotFound as error:",
            "            msg = _(\"Can not find requested image\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.FlavorNotFound as error:",
            "            msg = _(\"Invalid flavor_ref provided.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.KeypairNotFound as error:",
            "            msg = _(\"Invalid key_name provided.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.ConfigDriveInvalidValue:",
            "            msg = _(\"Invalid config_drive provided.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except rpc_common.RemoteError as err:",
            "            msg = \"%(err_type)s: %(err_msg)s\" % {'err_type': err.exc_type,",
            "                                                 'err_msg': err.value}",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except UnicodeDecodeError as error:",
            "            msg = \"UnicodeError: %s\" % unicode(error)",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except (exception.ImageNotActive,",
            "                exception.InstanceTypeDiskTooSmall,",
            "                exception.InstanceTypeMemoryTooSmall,",
            "                exception.InstanceTypeNotFound,",
            "                exception.InvalidMetadata,",
            "                exception.InvalidRequest,",
            "                exception.SecurityGroupNotFound,",
            "                exception.InstanceUserDataMalformed) as error:",
            "            raise exc.HTTPBadRequest(explanation=error.format_message())",
            "",
            "        # If the caller wanted a reservation_id, return it",
            "        if ret_resv_id:",
            "            return wsgi.ResponseObject({'reservation_id': resv_id},",
            "                                       xml=ServerMultipleCreateTemplate)",
            "",
            "        req.cache_db_instances(instances)",
            "        server = self._view_builder.create(req, instances[0])",
            "",
            "        if CONF.enable_instance_password:",
            "            server['server']['admin_pass'] = password",
            "",
            "        robj = wsgi.ResponseObject(server)",
            "",
            "        return self._add_location(robj)",
            "",
            "    def _create_extension_point(self, ext, server_dict, create_kwargs):",
            "        handler = ext.obj",
            "        LOG.debug(_(\"Running _create_extension_point for %s\"), ext.obj)",
            "",
            "        handler.server_create(server_dict, create_kwargs)",
            "",
            "    def _rebuild_extension_point(self, ext, rebuild_dict, rebuild_kwargs):",
            "        handler = ext.obj",
            "        LOG.debug(_(\"Running _rebuild_extension_point for %s\"), ext.obj)",
            "",
            "        handler.server_rebuild(rebuild_dict, rebuild_kwargs)",
            "",
            "    def _resize_extension_point(self, ext, resize_dict, resize_kwargs):",
            "        handler = ext.obj",
            "        LOG.debug(_(\"Running _resize_extension_point for %s\"), ext.obj)",
            "",
            "        handler.server_resize(resize_dict, resize_kwargs)",
            "",
            "    def _update_extension_point(self, ext, update_dict, update_kwargs):",
            "        handler = ext.obj",
            "        LOG.debug(_(\"Running _update_extension_point for %s\"), ext.obj)",
            "",
            "        handler.server_update(update_dict, update_kwargs)",
            "",
            "    def _delete(self, context, req, instance_uuid):",
            "        instance = self._get_server(context, req, instance_uuid)",
            "        if CONF.reclaim_instance_interval:",
            "            self.compute_api.soft_delete(context, instance)",
            "        else:",
            "            self.compute_api.delete(context, instance)",
            "",
            "    @wsgi.serializers(xml=ServerTemplate)",
            "    def update(self, req, id, body):",
            "        \"\"\"Update server then pass on to version-specific controller.\"\"\"",
            "        if not self.is_valid_body(body, 'server'):",
            "            raise exc.HTTPUnprocessableEntity()",
            "",
            "        ctxt = req.environ['nova.context']",
            "        update_dict = {}",
            "",
            "        if 'name' in body['server']:",
            "            name = body['server']['name']",
            "            self._validate_server_name(name)",
            "            update_dict['display_name'] = name.strip()",
            "",
            "        if 'access_ip_v4' in body['server']:",
            "            access_ipv4 = body['server']['access_ip_v4']",
            "            if access_ipv4:",
            "                self._validate_access_ipv4(access_ipv4)",
            "            update_dict['access_ip_v4'] = (",
            "                access_ipv4 and access_ipv4.strip() or None)",
            "",
            "        if 'access_ip_v6' in body['server']:",
            "            access_ipv6 = body['server']['access_ip_v6']",
            "            if access_ipv6:",
            "                self._validate_access_ipv6(access_ipv6)",
            "            update_dict['access_ip_v6'] = (",
            "                access_ipv6 and access_ipv6.strip() or None)",
            "",
            "        if 'host_id' in body['server']:",
            "            msg = _(\"host_id cannot be updated.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        if list(self.update_extension_manager):",
            "            self.update_extension_manager.map(self._update_extension_point,",
            "                                              body['server'], update_dict)",
            "",
            "        try:",
            "            instance = self.compute_api.get(ctxt, id, want_objects=True)",
            "            req.cache_db_instance(instance)",
            "            instance.update(update_dict)",
            "            instance.save()",
            "        except exception.NotFound:",
            "            msg = _(\"Instance could not be found\")",
            "            raise exc.HTTPNotFound(explanation=msg)",
            "",
            "        return self._view_builder.show(req, instance)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('confirm_resize')",
            "    def _action_confirm_resize(self, req, id, body):",
            "        context = req.environ['nova.context']",
            "        instance = self._get_server(context, req, id)",
            "        try:",
            "            self.compute_api.confirm_resize(context, instance)",
            "        except exception.MigrationNotFound:",
            "            msg = _(\"Instance has not been resized.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'confirm_resize')",
            "        return exc.HTTPNoContent()",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('revert_resize')",
            "    def _action_revert_resize(self, req, id, body):",
            "        context = req.environ['nova.context']",
            "        instance = self._get_server(context, req, id)",
            "        try:",
            "            self.compute_api.revert_resize(context, instance)",
            "        except exception.MigrationNotFound:",
            "            msg = _(\"Instance has not been resized.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.InstanceTypeNotFound:",
            "            msg = _(\"Flavor used by the instance could not be found.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'revert_resize')",
            "        return webob.Response(status_int=202)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('reboot')",
            "    def _action_reboot(self, req, id, body):",
            "        if 'reboot' in body and 'type' in body['reboot']:",
            "            valid_reboot_types = ['HARD', 'SOFT']",
            "            reboot_type = body['reboot']['type'].upper()",
            "            if not valid_reboot_types.count(reboot_type):",
            "                msg = _(\"Argument 'type' for reboot is not HARD or SOFT\")",
            "                LOG.error(msg)",
            "                raise exc.HTTPBadRequest(explanation=msg)",
            "        else:",
            "            msg = _(\"Missing argument 'type' for reboot\")",
            "            LOG.error(msg)",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        context = req.environ['nova.context']",
            "        instance = self._get_server(context, req, id)",
            "",
            "        try:",
            "            self.compute_api.reboot(context, instance, reboot_type)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'reboot')",
            "        return webob.Response(status_int=202)",
            "",
            "    def _resize(self, req, instance_id, flavor_id, **kwargs):",
            "        \"\"\"Begin the resize process with given instance/flavor.\"\"\"",
            "        context = req.environ[\"nova.context\"]",
            "        instance = self._get_server(context, req, instance_id)",
            "",
            "        try:",
            "            self.compute_api.resize(context, instance, flavor_id, **kwargs)",
            "        except exception.FlavorNotFound:",
            "            msg = _(\"Unable to locate requested flavor.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.CannotResizeToSameFlavor:",
            "            msg = _(\"Resize requires a flavor change.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'resize')",
            "        except exception.ImageNotAuthorized as image_error:",
            "            msg = _(\"You are not authorized to access the image \"",
            "                    \"the instance was started with.\")",
            "            raise exc.HTTPUnauthorized(explanation=msg)",
            "        except exception.ImageNotFound as image_error:",
            "            msg = _(\"Image that the instance was started \"",
            "                    \"with could not be found.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.Invalid:",
            "            msg = _(\"Invalid instance image.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        return webob.Response(status_int=202)",
            "",
            "    @wsgi.response(204)",
            "    def delete(self, req, id):",
            "        \"\"\"Destroys a server.\"\"\"",
            "        try:",
            "            self._delete(req.environ['nova.context'], req, id)",
            "        except exception.NotFound:",
            "            msg = _(\"Instance could not be found\")",
            "            raise exc.HTTPNotFound(explanation=msg)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'delete')",
            "",
            "    def _image_ref_from_req_data(self, data):",
            "        try:",
            "            return unicode(data['server']['image_ref'])",
            "        except (TypeError, KeyError):",
            "            msg = _(\"Missing image_ref attribute\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "    def _image_uuid_from_href(self, image_href):",
            "        # If the image href was generated by nova api, strip image_href",
            "        # down to an id and use the default glance connection params",
            "        image_uuid = image_href.split('/').pop()",
            "",
            "        if not uuidutils.is_uuid_like(image_uuid):",
            "            msg = _(\"Invalid image_ref provided.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        return image_uuid",
            "",
            "    def _image_from_req_data(self, data):",
            "        \"\"\"",
            "        Get image data from the request or raise appropriate",
            "        exceptions",
            "",
            "        If no image is supplied - checks to see if there is",
            "        block devices set and proper extesions loaded.",
            "        \"\"\"",
            "        image_ref = data['server'].get('image_ref')",
            "        bdm = data['server'].get('block_device_mapping')",
            "",
            "        # TODO(cyeoh): bp v3-api-core-as-extensions",
            "        # Replace with extension point. For the moment",
            "        # with no ep, assume os-volumes is not present",
            "        #if not image_ref and bdm and self.ext_mgr.is_loaded('os-volumes'):",
            "        #    return ''",
            "        #else:",
            "        #    image_href = self._image_ref_from_req_data(data)",
            "        #    image_uuid = self._image_uuid_from_href(image_href)",
            "        #    return image_uuid",
            "        image_href = self._image_ref_from_req_data(data)",
            "        image_uuid = self._image_uuid_from_href(image_href)",
            "        return image_uuid",
            "",
            "    def _flavor_id_from_req_data(self, data):",
            "        try:",
            "            flavor_ref = data['server']['flavor_ref']",
            "        except (TypeError, KeyError):",
            "            msg = _(\"Missing flavor_ref attribute\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        return common.get_id_from_href(flavor_ref)",
            "",
            "    def _validate_metadata(self, metadata):",
            "        \"\"\"Ensure that we can work with the metadata given.\"\"\"",
            "        try:",
            "            metadata.iteritems()",
            "        except AttributeError:",
            "            msg = _(\"Unable to parse metadata key/value pairs.\")",
            "            LOG.debug(msg)",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('resize')",
            "    def _action_resize(self, req, id, body):",
            "        \"\"\"Resizes a given instance to the flavor size requested.\"\"\"",
            "        resize_dict = body['resize']",
            "        try:",
            "            flavor_ref = str(resize_dict[\"flavor_ref\"])",
            "            if not flavor_ref:",
            "                msg = _(\"Resize request has invalid 'flavor_ref' attribute.\")",
            "                raise exc.HTTPBadRequest(explanation=msg)",
            "        except (KeyError, TypeError):",
            "            msg = _(\"Resize requests require 'flavor_ref' attribute.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        resize_kwargs = {}",
            "",
            "        if list(self.resize_extension_manager):",
            "            self.resize_extension_manager.map(self._resize_extension_point,",
            "                                              resize_dict, resize_kwargs)",
            "",
            "        return self._resize(req, id, flavor_ref, **resize_kwargs)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('rebuild')",
            "    def _action_rebuild(self, req, id, body):",
            "        \"\"\"Rebuild an instance with the given attributes.\"\"\"",
            "        try:",
            "            rebuild_dict = body['rebuild']",
            "        except (KeyError, TypeError):",
            "            msg = _('Invalid request body')",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        try:",
            "            image_href = rebuild_dict[\"image_ref\"]",
            "        except (KeyError, TypeError):",
            "            msg = _(\"Could not parse image_ref from request.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        image_href = self._image_uuid_from_href(image_href)",
            "",
            "        try:",
            "            password = rebuild_dict['admin_pass']",
            "        except (KeyError, TypeError):",
            "            password = utils.generate_password()",
            "",
            "        context = req.environ['nova.context']",
            "        instance = self._get_server(context, req, id)",
            "",
            "        attr_map = {",
            "            'name': 'display_name',",
            "            'access_ip_v4': 'access_ip_v4',",
            "            'access_ip_v6': 'access_ip_v6',",
            "            'metadata': 'metadata',",
            "        }",
            "",
            "        if 'access_ip_v4' in rebuild_dict:",
            "            self._validate_access_ipv4(rebuild_dict['access_ip_v4'])",
            "",
            "        if 'access_ip_v6' in rebuild_dict:",
            "            self._validate_access_ipv6(rebuild_dict['access_ip_v6'])",
            "",
            "        rebuild_kwargs = {}",
            "        if list(self.rebuild_extension_manager):",
            "            self.rebuild_extension_manager.map(self._rebuild_extension_point,",
            "                                               rebuild_dict, rebuild_kwargs)",
            "",
            "        for request_attribute, instance_attribute in attr_map.items():",
            "            try:",
            "                rebuild_kwargs[instance_attribute] = rebuild_dict[",
            "                    request_attribute]",
            "            except (KeyError, TypeError):",
            "                pass",
            "",
            "        self._validate_metadata(rebuild_kwargs.get('metadata', {}))",
            "",
            "        try:",
            "            self.compute_api.rebuild(context,",
            "                                     instance,",
            "                                     image_href,",
            "                                     password,",
            "                                     **rebuild_kwargs)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'rebuild')",
            "        except exception.InstanceNotFound:",
            "            msg = _(\"Instance could not be found\")",
            "            raise exc.HTTPNotFound(explanation=msg)",
            "        except exception.InvalidMetadataSize as error:",
            "            raise exc.HTTPRequestEntityTooLarge(",
            "                explanation=error.format_message())",
            "        except exception.ImageNotFound:",
            "            msg = _(\"Cannot find image for rebuild\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except (exception.ImageNotActive,",
            "                exception.InstanceTypeDiskTooSmall,",
            "                exception.InstanceTypeMemoryTooSmall,",
            "                exception.InvalidMetadata) as error:",
            "            raise exc.HTTPBadRequest(explanation=error.format_message())",
            "",
            "        instance = self._get_server(context, req, id)",
            "",
            "        view = self._view_builder.show(req, instance)",
            "",
            "        # Add on the admin_pass attribute since the view doesn't do it",
            "        # unless instance passwords are disabled",
            "        if CONF.enable_instance_password:",
            "            view['server']['admin_pass'] = password",
            "",
            "        robj = wsgi.ResponseObject(view)",
            "        return self._add_location(robj)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('create_image')",
            "    @common.check_snapshots_enabled",
            "    def _action_create_image(self, req, id, body):",
            "        \"\"\"Snapshot a server instance.\"\"\"",
            "        context = req.environ['nova.context']",
            "        entity = body.get(\"create_image\", {})",
            "",
            "        image_name = entity.get(\"name\")",
            "",
            "        if not image_name:",
            "            msg = _(\"create_image entity requires name attribute\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        props = {}",
            "        metadata = entity.get('metadata', {})",
            "        common.check_img_metadata_properties_quota(context, metadata)",
            "        try:",
            "            props.update(metadata)",
            "        except ValueError:",
            "            msg = _(\"Invalid metadata\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        instance = self._get_server(context, req, id)",
            "",
            "        bdms = self.compute_api.get_instance_bdms(context, instance)",
            "",
            "        try:",
            "            if self.compute_api.is_volume_backed_instance(context, instance,",
            "                                                          bdms):",
            "                img = instance['image_ref']",
            "                if not img:",
            "                    # NOTE(Vincent Hou) The private method",
            "                    # _get_volume_image_metadata only works, when boot",
            "                    # device is set to 'vda'. It needs to be fixed later,",
            "                    # but tentatively we use it here.",
            "                    image_meta = {'properties': self.compute_api.",
            "                                    _get_volume_image_metadata(context, bdms)}",
            "                else:",
            "                    src_image = self.compute_api.\\",
            "                        image_service.show(context, img)",
            "                    image_meta = dict(src_image)",
            "",
            "                image = self.compute_api.snapshot_volume_backed(",
            "                                                       context,",
            "                                                       instance,",
            "                                                       image_meta,",
            "                                                       image_name,",
            "                                                       extra_properties=props)",
            "            else:",
            "                image = self.compute_api.snapshot(context,",
            "                                                  instance,",
            "                                                  image_name,",
            "                                                  extra_properties=props)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                        'create_image')",
            "        except exception.Invalid as err:",
            "            raise exc.HTTPBadRequest(explanation=err.format_message())",
            "",
            "        # build location of newly-created image entity",
            "        image_id = str(image['id'])",
            "        image_ref = os.path.join(req.application_url,",
            "                                 context.project_id,",
            "                                 'images',",
            "                                 image_id)",
            "",
            "        resp = webob.Response(status_int=202)",
            "        resp.headers['Location'] = image_ref",
            "        return resp",
            "",
            "    def _get_server_admin_password(self, server):",
            "        \"\"\"Determine the admin password for a server on creation.\"\"\"",
            "        try:",
            "            password = server['admin_pass']",
            "            self._validate_admin_password(password)",
            "        except KeyError:",
            "            password = utils.generate_password()",
            "        except ValueError:",
            "            raise exc.HTTPBadRequest(explanation=_(\"Invalid admin_pass\"))",
            "",
            "        return password",
            "",
            "    def _validate_admin_password(self, password):",
            "        if not isinstance(password, basestring):",
            "            raise ValueError()",
            "",
            "    def _get_server_search_options(self):",
            "        \"\"\"Return server search options allowed by non-admin.\"\"\"",
            "        return ('reservation_id', 'name', 'status', 'image', 'flavor',",
            "                'ip', 'changes_since', 'all_tenants')",
            "",
            "    def _server_create_xml_deserialize_extension_point(self, ext, server_node,",
            "                                                       server_dict):",
            "        handler = ext.obj",
            "        LOG.debug(_(\"Running create xml deserialize ep for %s\"),",
            "                  handler.alias)",
            "        handler.server_xml_extract_server_deserialize(server_node,",
            "                                                      server_dict)",
            "",
            "    def server_create_xml_deserialize(self, server_node, server):",
            "        self.create_xml_deserialize_manager.map(",
            "            self._server_create_xml_deserialize_extension_point,",
            "            server_node, server)",
            "",
            "    def _server_rebuild_xml_deserialize_extension_point(self, ext,",
            "                                                        rebuild_node,",
            "                                                        rebuild_dict):",
            "        handler = ext.obj",
            "        LOG.debug(_(\"Running rebuild xml deserialize ep for %s\"),",
            "                  handler.alias)",
            "        handler.server_xml_extract_rebuild_deserialize(rebuild_node,",
            "                                                       rebuild_dict)",
            "",
            "    def server_rebuild_xml_deserialize(self, rebuild_node, rebuild_dict):",
            "        if list(self.rebuild_xml_deserialize_manager):",
            "            self.rebuild_xml_deserialize_manager.map(",
            "                self._server_rebuild_xml_deserialize_extension_point,",
            "                rebuild_node, rebuild_dict)",
            "",
            "    def _server_resize_xml_deserialize_extension_point(self, ext, resize_node,",
            "                                                       resize_dict):",
            "        handler = ext.obj",
            "        LOG.debug(_(\"Running rebuild xml deserialize ep for %s\"),",
            "                  handler.alias)",
            "        handler.server_xml_extract_resize_deserialize(resize_node, resize_dict)",
            "",
            "    def server_resize_xml_deserialize(self, resize_node, resize_dict):",
            "        if list(self.resize_xml_deserialize_manager):",
            "            self.resize_xml_deserialize_manager.map(",
            "                self._server_resize_xml_deserialize_extension_point,",
            "                resize_node, resize_dict)",
            "",
            "    def _get_instance(self, context, instance_uuid):",
            "        try:",
            "            attrs = ['system_metadata', 'metadata']",
            "            return instance_obj.Instance.get_by_uuid(context, instance_uuid,",
            "                                                     expected_attrs=attrs)",
            "        except exception.InstanceNotFound as e:",
            "            raise webob.exc.HTTPNotFound(explanation=e.format_message())",
            "",
            "    @extensions.expected_errors((404, 409))",
            "    @wsgi.action('start')",
            "    def _start_server(self, req, id, body):",
            "        \"\"\"Start an instance.\"\"\"",
            "        context = req.environ['nova.context']",
            "        instance = self._get_instance(context, id)",
            "        LOG.debug(_('start instance'), instance=instance)",
            "        try:",
            "            self.compute_api.start(context, instance)",
            "        except exception.InstanceNotReady as e:",
            "            raise webob.exc.HTTPConflict(explanation=e.format_message())",
            "        return webob.Response(status_int=202)",
            "",
            "    @extensions.expected_errors((404, 409))",
            "    @wsgi.action('stop')",
            "    def _stop_server(self, req, id, body):",
            "        \"\"\"Stop an instance.\"\"\"",
            "        context = req.environ['nova.context']",
            "        instance = self._get_instance(context, id)",
            "        LOG.debug(_('stop instance'), instance=instance)",
            "        try:",
            "            self.compute_api.stop(context, instance)",
            "        except exception.InstanceNotReady as e:",
            "            raise webob.exc.HTTPConflict(explanation=e.format_message())",
            "        return webob.Response(status_int=202)",
            "",
            "",
            "def remove_invalid_options(context, search_options, allowed_search_options):",
            "    \"\"\"Remove search options that are not valid for non-admin API/context.\"\"\"",
            "    if context.is_admin:",
            "        # Allow all options",
            "        return",
            "    # Otherwise, strip out all unknown options",
            "    unknown_options = [opt for opt in search_options",
            "                        if opt not in allowed_search_options]",
            "    LOG.debug(_(\"Removing options '%s' from query\"),",
            "              \", \".join(unknown_options))",
            "    for opt in unknown_options:",
            "        search_options.pop(opt, None)",
            "",
            "",
            "class Servers(extensions.V3APIExtensionBase):",
            "    \"\"\"Servers.\"\"\"",
            "",
            "    name = \"Servers\"",
            "    alias = \"servers\"",
            "    namespace = \"http://docs.openstack.org/compute/core/servers/v3\"",
            "    version = 1",
            "",
            "    def get_resources(self):",
            "        member_actions = {'action': 'POST'}",
            "        collection_actions = {'detail': 'GET'}",
            "        resources = [",
            "            extensions.ResourceExtension(",
            "                'servers',",
            "                ServersController(extension_info=self.extension_info),",
            "                member_name='server', collection_actions=collection_actions,",
            "                member_actions=member_actions)]",
            "",
            "        return resources",
            "",
            "    def get_controller_extensions(self):",
            "        return []"
        ],
        "afterPatchFile": [
            "# Copyright 2010 OpenStack Foundation",
            "# Copyright 2011 Piston Cloud Computing, Inc",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import base64",
            "import os",
            "import re",
            "import stevedore",
            "",
            "from oslo.config import cfg",
            "import webob",
            "from webob import exc",
            "",
            "from nova.api.openstack import common",
            "from nova.api.openstack.compute.plugins.v3 import ips",
            "from nova.api.openstack.compute.views import servers as views_servers",
            "from nova.api.openstack import extensions",
            "from nova.api.openstack import wsgi",
            "from nova.api.openstack import xmlutil",
            "from nova import compute",
            "from nova.compute import flavors",
            "from nova import exception",
            "from nova.objects import instance as instance_obj",
            "from nova.openstack.common.gettextutils import _",
            "from nova.openstack.common import importutils",
            "from nova.openstack.common import log as logging",
            "from nova.openstack.common.rpc import common as rpc_common",
            "from nova.openstack.common import strutils",
            "from nova.openstack.common import timeutils",
            "from nova.openstack.common import uuidutils",
            "from nova import utils",
            "",
            "",
            "CONF = cfg.CONF",
            "CONF.import_opt('enable_instance_password',",
            "                'nova.api.openstack.compute.servers')",
            "CONF.import_opt('network_api_class', 'nova.network')",
            "CONF.import_opt('reclaim_instance_interval', 'nova.compute.manager')",
            "CONF.import_opt('extensions_blacklist', 'nova.api.openstack', group='osapi_v3')",
            "CONF.import_opt('extensions_whitelist', 'nova.api.openstack', group='osapi_v3')",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "def make_fault(elem):",
            "    fault = xmlutil.SubTemplateElement(elem, 'fault', selector='fault')",
            "    fault.set('code')",
            "    fault.set('created')",
            "    msg = xmlutil.SubTemplateElement(fault, 'message')",
            "    msg.text = 'message'",
            "    det = xmlutil.SubTemplateElement(fault, 'details')",
            "    det.text = 'details'",
            "",
            "",
            "def make_server(elem, detailed=False):",
            "    elem.set('name')",
            "    elem.set('id')",
            "",
            "    if detailed:",
            "        elem.set('user_id')",
            "        elem.set('tenant_id')",
            "        elem.set('updated')",
            "        elem.set('created')",
            "        elem.set('host_id')",
            "        elem.set('access_ip_v4')",
            "        elem.set('access_ip_v6')",
            "        elem.set('status')",
            "        elem.set('progress')",
            "        elem.set('reservation_id')",
            "",
            "        # Attach image node",
            "        image = xmlutil.SubTemplateElement(elem, 'image', selector='image')",
            "        image.set('id')",
            "        xmlutil.make_links(image, 'links')",
            "",
            "        # Attach flavor node",
            "        flavor = xmlutil.SubTemplateElement(elem, 'flavor', selector='flavor')",
            "        flavor.set('id')",
            "        xmlutil.make_links(flavor, 'links')",
            "",
            "        # Attach fault node",
            "        make_fault(elem)",
            "",
            "        # Attach metadata node",
            "        elem.append(common.MetadataTemplate())",
            "",
            "        # Attach addresses node",
            "        elem.append(ips.AddressesTemplate())",
            "",
            "    xmlutil.make_links(elem, 'links')",
            "",
            "",
            "server_nsmap = {None: xmlutil.XMLNS_V11, 'atom': xmlutil.XMLNS_ATOM}",
            "",
            "",
            "class ServerTemplate(xmlutil.TemplateBuilder):",
            "    def construct(self):",
            "        root = xmlutil.TemplateElement('server', selector='server')",
            "        make_server(root, detailed=True)",
            "        return xmlutil.MasterTemplate(root, 1, nsmap=server_nsmap)",
            "",
            "",
            "class MinimalServersTemplate(xmlutil.TemplateBuilder):",
            "    def construct(self):",
            "        root = xmlutil.TemplateElement('servers')",
            "        elem = xmlutil.SubTemplateElement(root, 'server', selector='servers')",
            "        make_server(elem)",
            "        xmlutil.make_links(root, 'servers_links')",
            "        return xmlutil.MasterTemplate(root, 1, nsmap=server_nsmap)",
            "",
            "",
            "class ServersTemplate(xmlutil.TemplateBuilder):",
            "    def construct(self):",
            "        root = xmlutil.TemplateElement('servers')",
            "        elem = xmlutil.SubTemplateElement(root, 'server', selector='servers')",
            "        make_server(elem, detailed=True)",
            "        return xmlutil.MasterTemplate(root, 1, nsmap=server_nsmap)",
            "",
            "",
            "class ServerAdminPassTemplate(xmlutil.TemplateBuilder):",
            "    def construct(self):",
            "        root = xmlutil.TemplateElement('server')",
            "        root.set('admin_pass')",
            "        return xmlutil.SlaveTemplate(root, 1, nsmap=server_nsmap)",
            "",
            "",
            "class ServerMultipleCreateTemplate(xmlutil.TemplateBuilder):",
            "    def construct(self):",
            "        root = xmlutil.TemplateElement('server')",
            "        root.set('reservation_id')",
            "        return xmlutil.MasterTemplate(root, 1, nsmap=server_nsmap)",
            "",
            "",
            "def FullServerTemplate():",
            "    master = ServerTemplate()",
            "    master.attach(ServerAdminPassTemplate())",
            "    return master",
            "",
            "",
            "class CommonDeserializer(wsgi.MetadataXMLDeserializer):",
            "    \"\"\"Common deserializer to handle xml-formatted server create requests.",
            "",
            "    Handles standard server attributes as well as optional metadata",
            "    and personality attributes",
            "    \"\"\"",
            "",
            "    metadata_deserializer = common.MetadataXMLDeserializer()",
            "    want_controller = True",
            "",
            "    def __init__(self, controller):",
            "        self.controller = controller",
            "",
            "    def _extract_server(self, node):",
            "        \"\"\"Marshal the server attribute of a parsed request.\"\"\"",
            "        server = {}",
            "        server_node = self.find_first_child_named(node, 'server')",
            "",
            "        attributes = [\"name\", \"image_ref\", \"flavor_ref\", \"admin_pass\",",
            "                      \"access_ip_v4\", \"access_ip_v6\", \"key_name\",",
            "                      \"min_count\", \"max_count\"]",
            "        for attr in attributes:",
            "            if server_node.getAttribute(attr):",
            "                server[attr] = server_node.getAttribute(attr)",
            "",
            "        res_id = server_node.getAttribute('return_reservation_id')",
            "        if res_id:",
            "            server['return_reservation_id'] = strutils.bool_from_string(res_id)",
            "",
            "        metadata_node = self.find_first_child_named(server_node, \"metadata\")",
            "        if metadata_node is not None:",
            "            server[\"metadata\"] = self.extract_metadata(metadata_node)",
            "",
            "        networks = self._extract_networks(server_node)",
            "        if networks is not None:",
            "            server[\"networks\"] = networks",
            "",
            "        security_groups = self._extract_security_groups(server_node)",
            "        if security_groups is not None:",
            "            server[\"security_groups\"] = security_groups",
            "",
            "        # NOTE(vish): this is not namespaced in json, so leave it without a",
            "        #             namespace for now",
            "        block_device_mapping = self._extract_block_device_mapping(server_node)",
            "        if block_device_mapping is not None:",
            "            server[\"block_device_mapping\"] = block_device_mapping",
            "",
            "        if self.controller:",
            "            self.controller.server_create_xml_deserialize(server_node, server)",
            "",
            "        return server",
            "",
            "    def _extract_block_device_mapping(self, server_node):",
            "        \"\"\"Marshal the block_device_mapping node of a parsed request.\"\"\"",
            "        node = self.find_first_child_named(server_node, \"block_device_mapping\")",
            "        if node:",
            "            block_device_mapping = []",
            "            for child in self.extract_elements(node):",
            "                if child.nodeName != \"mapping\":",
            "                    continue",
            "                mapping = {}",
            "                attributes = [\"volume_id\", \"snapshot_id\", \"device_name\",",
            "                              \"virtual_name\", \"volume_size\"]",
            "                for attr in attributes:",
            "                    value = child.getAttribute(attr)",
            "                    if value:",
            "                        mapping[attr] = value",
            "                attributes = [\"delete_on_termination\", \"no_device\"]",
            "                for attr in attributes:",
            "                    value = child.getAttribute(attr)",
            "                    if value:",
            "                        mapping[attr] = strutils.bool_from_string(value)",
            "                block_device_mapping.append(mapping)",
            "            return block_device_mapping",
            "        else:",
            "            return None",
            "",
            "    def _extract_networks(self, server_node):",
            "        \"\"\"Marshal the networks attribute of a parsed request.\"\"\"",
            "        node = self.find_first_child_named(server_node, \"networks\")",
            "        if node is not None:",
            "            networks = []",
            "            for network_node in self.find_children_named(node,",
            "                                                         \"network\"):",
            "                item = {}",
            "                if network_node.hasAttribute(\"uuid\"):",
            "                    item[\"uuid\"] = network_node.getAttribute(\"uuid\")",
            "                if network_node.hasAttribute(\"fixed_ip\"):",
            "                    item[\"fixed_ip\"] = network_node.getAttribute(\"fixed_ip\")",
            "                if network_node.hasAttribute(\"port\"):",
            "                    item[\"port\"] = network_node.getAttribute(\"port\")",
            "                networks.append(item)",
            "            return networks",
            "        else:",
            "            return None",
            "",
            "    def _extract_security_groups(self, server_node):",
            "        \"\"\"Marshal the security_groups attribute of a parsed request.\"\"\"",
            "        node = self.find_first_child_named(server_node, \"security_groups\")",
            "        if node is not None:",
            "            security_groups = []",
            "            for sg_node in self.find_children_named(node, \"security_group\"):",
            "                item = {}",
            "                name = self.find_attribute_or_element(sg_node, 'name')",
            "                if name:",
            "                    item[\"name\"] = name",
            "                    security_groups.append(item)",
            "            return security_groups",
            "        else:",
            "            return None",
            "",
            "",
            "class ActionDeserializer(CommonDeserializer):",
            "    \"\"\"Deserializer to handle xml-formatted server action requests.",
            "",
            "    Handles standard server attributes as well as optional metadata",
            "    and personality attributes",
            "    \"\"\"",
            "",
            "    def default(self, string):",
            "        dom = xmlutil.safe_minidom_parse_string(string)",
            "        action_node = dom.childNodes[0]",
            "        action_name = action_node.tagName",
            "",
            "        action_deserializer = {",
            "            'create_image': self._action_create_image,",
            "            'reboot': self._action_reboot,",
            "            'rebuild': self._action_rebuild,",
            "            'resize': self._action_resize,",
            "            'confirm_resize': self._action_confirm_resize,",
            "            'revert_resize': self._action_revert_resize,",
            "        }.get(action_name, super(ActionDeserializer, self).default)",
            "",
            "        action_data = action_deserializer(action_node)",
            "",
            "        return {'body': {action_name: action_data}}",
            "",
            "    def _action_create_image(self, node):",
            "        return self._deserialize_image_action(node, ('name',))",
            "",
            "    def _action_reboot(self, node):",
            "        if not node.hasAttribute(\"type\"):",
            "            raise AttributeError(\"No reboot type was specified in request\")",
            "        return {\"type\": node.getAttribute(\"type\")}",
            "",
            "    def _action_rebuild(self, node):",
            "        rebuild = {}",
            "        if node.hasAttribute(\"name\"):",
            "            name = node.getAttribute(\"name\")",
            "            if not name:",
            "                raise AttributeError(\"Name cannot be blank\")",
            "            rebuild['name'] = name",
            "",
            "        metadata_node = self.find_first_child_named(node, \"metadata\")",
            "        if metadata_node is not None:",
            "            rebuild[\"metadata\"] = self.extract_metadata(metadata_node)",
            "",
            "        if not node.hasAttribute(\"image_ref\"):",
            "            raise AttributeError(\"No image_ref was specified in request\")",
            "        rebuild[\"image_ref\"] = node.getAttribute(\"image_ref\")",
            "",
            "        if node.hasAttribute(\"admin_pass\"):",
            "            rebuild[\"admin_pass\"] = node.getAttribute(\"admin_pass\")",
            "",
            "        if node.hasAttribute(\"access_ipv4\"):",
            "            rebuild[\"access_ip_v4\"] = node.getAttribute(\"access_ip_v4\")",
            "",
            "        if node.hasAttribute(\"access_ipv6\"):",
            "            rebuild[\"access_ip_v6\"] = node.getAttribute(\"access_ip_v6\")",
            "",
            "        if self.controller:",
            "            self.controller.server_rebuild_xml_deserialize(node, rebuild)",
            "        return rebuild",
            "",
            "    def _action_resize(self, node):",
            "        resize = {}",
            "",
            "        if node.hasAttribute(\"flavor_ref\"):",
            "            resize[\"flavor_ref\"] = node.getAttribute(\"flavor_ref\")",
            "        else:",
            "            raise AttributeError(\"No flavor_ref was specified in request\")",
            "",
            "        if self.controller:",
            "            self.controller.server_resize_xml_deserialize(node, resize)",
            "        return resize",
            "",
            "    def _action_confirm_resize(self, node):",
            "        return None",
            "",
            "    def _action_revert_resize(self, node):",
            "        return None",
            "",
            "    def _deserialize_image_action(self, node, allowed_attributes):",
            "        data = {}",
            "        for attribute in allowed_attributes:",
            "            value = node.getAttribute(attribute)",
            "            if value:",
            "                data[attribute] = value",
            "        metadata_node = self.find_first_child_named(node, 'metadata')",
            "        if metadata_node is not None:",
            "            metadata = self.metadata_deserializer.extract_metadata(",
            "                                                        metadata_node)",
            "            data['metadata'] = metadata",
            "        return data",
            "",
            "",
            "class CreateDeserializer(CommonDeserializer):",
            "    \"\"\"Deserializer to handle xml-formatted server create requests.",
            "",
            "    Handles standard server attributes as well as optional metadata",
            "    and personality attributes",
            "    \"\"\"",
            "",
            "    def default(self, string):",
            "        \"\"\"Deserialize an xml-formatted server create request.\"\"\"",
            "        dom = xmlutil.safe_minidom_parse_string(string)",
            "        server = self._extract_server(dom)",
            "        return {'body': {'server': server}}",
            "",
            "",
            "class ServersController(wsgi.Controller):",
            "    \"\"\"The Server API base controller class for the OpenStack API.\"\"\"",
            "",
            "    EXTENSION_CREATE_NAMESPACE = 'nova.api.v3.extensions.server.create'",
            "    EXTENSION_DESERIALIZE_EXTRACT_SERVER_NAMESPACE = (",
            "        'nova.api.v3.extensions.server.create.deserialize')",
            "",
            "    EXTENSION_REBUILD_NAMESPACE = 'nova.api.v3.extensions.server.rebuild'",
            "    EXTENSION_DESERIALIZE_EXTRACT_REBUILD_NAMESPACE = (",
            "        'nova.api.v3.extensions.server.rebuild.deserialize')",
            "",
            "    EXTENSION_RESIZE_NAMESPACE = 'nova.api.v3.extensions.server.resize'",
            "    EXTENSION_DESERIALIZE_EXTRACT_RESIZE_NAMESPACE = (",
            "        'nova.api.v3.extensions.server.resize.deserialize')",
            "",
            "    EXTENSION_UPDATE_NAMESPACE = 'nova.api.v3.extensions.server.update'",
            "",
            "    _view_builder_class = views_servers.ViewBuilderV3",
            "",
            "    @staticmethod",
            "    def _add_location(robj):",
            "        # Just in case...",
            "        if 'server' not in robj.obj:",
            "            return robj",
            "",
            "        link = filter(lambda l: l['rel'] == 'self',",
            "                      robj.obj['server']['links'])",
            "        if link:",
            "            robj['Location'] = link[0]['href'].encode('utf-8')",
            "",
            "        # Convenience return",
            "        return robj",
            "",
            "    def __init__(self, **kwargs):",
            "        def _check_load_extension(required_function):",
            "",
            "            def check_whiteblack_lists(ext):",
            "                # Check whitelist is either empty or if not then the extension",
            "                # is in the whitelist",
            "                if (not CONF.osapi_v3.extensions_whitelist or",
            "                        ext.obj.alias in CONF.osapi_v3.extensions_whitelist):",
            "",
            "                    # Check the extension is not in the blacklist",
            "                    if ext.obj.alias not in CONF.osapi_v3.extensions_blacklist:",
            "                        return True",
            "                    else:",
            "                        LOG.warning(_(\"Not loading %s because it is \"",
            "                                      \"in the blacklist\"), ext.obj.alias)",
            "                        return False",
            "                else:",
            "                    LOG.warning(",
            "                        _(\"Not loading %s because it is not in the whitelist\"),",
            "                        ext.obj.alias)",
            "                    return False",
            "",
            "            def check_load_extension(ext):",
            "                if isinstance(ext.obj, extensions.V3APIExtensionBase):",
            "                    # Filter out for the existence of the required",
            "                    # function here rather than on every request. We",
            "                    # don't have a new abstract base class to reduce",
            "                    # duplication in the extensions as they may want",
            "                    # to implement multiple server (and other) entry",
            "                    # points if hasattr(ext.obj, 'server_create'):",
            "                    if hasattr(ext.obj, required_function):",
            "                        LOG.debug(_('extension %(ext_alias)s detected by '",
            "                                    'servers extension for function %(func)s'),",
            "                                    {'ext_alias': ext.obj.alias,",
            "                                     'func': required_function})",
            "                        return check_whiteblack_lists(ext)",
            "                    else:",
            "                        LOG.debug(",
            "                            _('extension %(ext_alias)s is missing %(func)s'),",
            "                            {'ext_alias': ext.obj.alias,",
            "                            'func': required_function})",
            "                        return False",
            "                else:",
            "                    return False",
            "            return check_load_extension",
            "",
            "        self.extension_info = kwargs.pop('extension_info')",
            "        super(ServersController, self).__init__(**kwargs)",
            "        self.compute_api = compute.API()",
            "        self.neutron_attempted = False",
            "",
            "        # Look for implmentation of extension point of server creation",
            "        self.create_extension_manager = \\",
            "          stevedore.enabled.EnabledExtensionManager(",
            "              namespace=self.EXTENSION_CREATE_NAMESPACE,",
            "              check_func=_check_load_extension('server_create'),",
            "              invoke_on_load=True,",
            "              invoke_kwds={\"extension_info\": self.extension_info},",
            "              propagate_map_exceptions=True)",
            "        if not list(self.create_extension_manager):",
            "            LOG.debug(_(\"Did not find any server create extensions\"))",
            "",
            "        # Look for implmentation of extension point of server create",
            "        # XML deserialization",
            "        self.create_xml_deserialize_manager = \\",
            "          stevedore.enabled.EnabledExtensionManager(",
            "              namespace=self.EXTENSION_DESERIALIZE_EXTRACT_SERVER_NAMESPACE,",
            "              check_func=_check_load_extension(",
            "                  'server_xml_extract_server_deserialize'),",
            "              invoke_on_load=True,",
            "              invoke_kwds={\"extension_info\": self.extension_info},",
            "              propagate_map_exceptions=True)",
            "        if not list(self.create_xml_deserialize_manager):",
            "            LOG.debug(_(\"Did not find any server create xml deserializer\"",
            "                        \" extensions\"))",
            "",
            "        # Look for implmentation of extension point of server rebuild",
            "        self.rebuild_extension_manager = \\",
            "            stevedore.enabled.EnabledExtensionManager(",
            "                namespace=self.EXTENSION_REBUILD_NAMESPACE,",
            "                check_func=_check_load_extension('server_rebuild'),",
            "                invoke_on_load=True,",
            "                invoke_kwds={\"extension_info\": self.extension_info})",
            "        if not list(self.rebuild_extension_manager):",
            "            LOG.debug(_(\"Did not find any server rebuild extensions\"))",
            "",
            "        # Look for implmentation of extension point of server rebuild",
            "        # XML deserialization",
            "        self.rebuild_xml_deserialize_manager = \\",
            "            stevedore.enabled.EnabledExtensionManager(",
            "                namespace=self.EXTENSION_DESERIALIZE_EXTRACT_REBUILD_NAMESPACE,",
            "                check_func=_check_load_extension(",
            "                    'server_xml_extract_rebuild_deserialize'),",
            "                invoke_on_load=True,",
            "                invoke_kwds={\"extension_info\": self.extension_info})",
            "        if not list(self.rebuild_xml_deserialize_manager):",
            "            LOG.debug(_(\"Did not find any server rebuild xml deserializer\"",
            "                        \" extensions\"))",
            "",
            "        # Look for implmentation of extension point of server resize",
            "        self.resize_extension_manager = \\",
            "            stevedore.enabled.EnabledExtensionManager(",
            "                namespace=self.EXTENSION_RESIZE_NAMESPACE,",
            "                check_func=_check_load_extension('server_resize'),",
            "                invoke_on_load=True,",
            "                invoke_kwds={\"extension_info\": self.extension_info})",
            "        if not list(self.resize_extension_manager):",
            "            LOG.debug(_(\"Did not find any server resize extensions\"))",
            "",
            "        # Look for implmentation of extension point of server resize",
            "        # XML deserialization",
            "        self.resize_xml_deserialize_manager = \\",
            "            stevedore.enabled.EnabledExtensionManager(",
            "                namespace=self.EXTENSION_DESERIALIZE_EXTRACT_RESIZE_NAMESPACE,",
            "                check_func=_check_load_extension(",
            "                    'server_xml_extract_resize_deserialize'),",
            "                invoke_on_load=True,",
            "                invoke_kwds={\"extension_info\": self.extension_info})",
            "        if not list(self.resize_xml_deserialize_manager):",
            "            LOG.debug(_(\"Did not find any server resize xml deserializer\"",
            "                        \" extensions\"))",
            "",
            "        # Look for implmentation of extension point of server update",
            "        self.update_extension_manager = \\",
            "            stevedore.enabled.EnabledExtensionManager(",
            "                namespace=self.EXTENSION_UPDATE_NAMESPACE,",
            "                check_func=_check_load_extension('server_resize'),",
            "                invoke_on_load=True,",
            "                invoke_kwds={\"extension_info\": self.extension_info})",
            "        if not list(self.update_extension_manager):",
            "            LOG.debug(_(\"Did not find any server update extensions\"))",
            "",
            "    @wsgi.serializers(xml=MinimalServersTemplate)",
            "    def index(self, req):",
            "        \"\"\"Returns a list of server names and ids for a given user.\"\"\"",
            "        try:",
            "            servers = self._get_servers(req, is_detail=False)",
            "        except exception.Invalid as err:",
            "            raise exc.HTTPBadRequest(explanation=err.format_message())",
            "        return servers",
            "",
            "    @wsgi.serializers(xml=ServersTemplate)",
            "    def detail(self, req):",
            "        \"\"\"Returns a list of server details for a given user.\"\"\"",
            "        try:",
            "            servers = self._get_servers(req, is_detail=True)",
            "        except exception.Invalid as err:",
            "            raise exc.HTTPBadRequest(explanation=err.format_message())",
            "        return servers",
            "",
            "    def _get_servers(self, req, is_detail):",
            "        \"\"\"Returns a list of servers, based on any search options specified.\"\"\"",
            "",
            "        search_opts = {}",
            "        search_opts.update(req.GET)",
            "",
            "        context = req.environ['nova.context']",
            "        remove_invalid_options(context, search_opts,",
            "                self._get_server_search_options())",
            "",
            "        # Verify search by 'status' contains a valid status.",
            "        # Convert it to filter by vm_state for compute_api.",
            "        status = search_opts.pop('status', None)",
            "        if status is not None:",
            "            state = common.vm_state_from_status(status)",
            "            if state is None:",
            "                return {'servers': []}",
            "            search_opts['vm_state'] = state",
            "",
            "        if 'changes_since' in search_opts:",
            "            try:",
            "                parsed = timeutils.parse_isotime(search_opts['changes_since'])",
            "            except ValueError:",
            "                msg = _('Invalid changes_since value')",
            "                raise exc.HTTPBadRequest(explanation=msg)",
            "            search_opts['changes_since'] = parsed",
            "",
            "        # By default, compute's get_all() will return deleted instances.",
            "        # If an admin hasn't specified a 'deleted' search option, we need",
            "        # to filter out deleted instances by setting the filter ourselves.",
            "        # ... Unless 'changes_since' is specified, because 'changes_since'",
            "        # should return recently deleted images according to the API spec.",
            "",
            "        if 'deleted' not in search_opts:",
            "            if 'changes_since' not in search_opts:",
            "                # No 'changes_since', so we only want non-deleted servers",
            "                search_opts['deleted'] = False",
            "",
            "        if search_opts.get(\"vm_state\") == \"deleted\":",
            "            if context.is_admin:",
            "                search_opts['deleted'] = True",
            "            else:",
            "                msg = _(\"Only administrators may list deleted instances\")",
            "                raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        if 'all_tenants' not in search_opts:",
            "            if context.project_id:",
            "                search_opts['project_id'] = context.project_id",
            "            else:",
            "                search_opts['user_id'] = context.user_id",
            "",
            "        limit, marker = common.get_limit_and_marker(req)",
            "        try:",
            "            instance_list = self.compute_api.get_all(context,",
            "                                                     search_opts=search_opts,",
            "                                                     limit=limit,",
            "                                                     marker=marker,",
            "                                                     want_objects=True)",
            "        except exception.MarkerNotFound as e:",
            "            msg = _('marker [%s] not found') % marker",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.FlavorNotFound as e:",
            "            log_msg = _(\"Flavor '%s' could not be found \")",
            "            LOG.debug(log_msg, search_opts['flavor'])",
            "            instance_list = []",
            "",
            "        if is_detail:",
            "            instance_list.fill_faults()",
            "            response = self._view_builder.detail(req, instance_list)",
            "        else:",
            "            response = self._view_builder.index(req, instance_list)",
            "        req.cache_db_instances(instance_list)",
            "        return response",
            "",
            "    def _get_server(self, context, req, instance_uuid):",
            "        \"\"\"Utility function for looking up an instance by uuid.\"\"\"",
            "        try:",
            "            instance = self.compute_api.get(context, instance_uuid,",
            "                                            want_objects=True)",
            "        except exception.NotFound:",
            "            msg = _(\"Instance could not be found\")",
            "            raise exc.HTTPNotFound(explanation=msg)",
            "        req.cache_db_instance(instance)",
            "        return instance",
            "",
            "    def _check_string_length(self, value, name, max_length=None):",
            "        try:",
            "            utils.check_string_length(value, name, min_length=1,",
            "                                      max_length=max_length)",
            "        except exception.InvalidInput as e:",
            "            raise exc.HTTPBadRequest(explanation=e.format_message())",
            "",
            "    def _validate_server_name(self, value):",
            "        self._check_string_length(value, 'Server name', max_length=255)",
            "",
            "    def _validate_device_name(self, value):",
            "        self._check_string_length(value, 'Device name', max_length=255)",
            "",
            "        if ' ' in value:",
            "            msg = _(\"Device name cannot include spaces.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "    def _is_neutron_v2(self):",
            "        # NOTE(dprince): neutron is not a requirement",
            "        if self.neutron_attempted:",
            "            return self.have_neutron",
            "",
            "        try:",
            "            # compatibility with Folsom/Grizzly configs",
            "            cls_name = CONF.network_api_class",
            "            if cls_name == 'nova.network.quantumv2.api.API':",
            "                cls_name = 'nova.network.neutronv2.api.API'",
            "",
            "            self.neutron_attempted = True",
            "            from nova.network.neutronv2 import api as neutron_api",
            "            self.have_neutron = issubclass(",
            "                importutils.import_class(cls_name),",
            "                neutron_api.API)",
            "        except ImportError:",
            "            self.have_neutron = False",
            "",
            "        return self.have_neutron",
            "",
            "    def _get_requested_networks(self, requested_networks):",
            "        \"\"\"Create a list of requested networks from the networks attribute.\"\"\"",
            "        networks = []",
            "        for network in requested_networks:",
            "            try:",
            "                # fixed IP address is optional",
            "                # if the fixed IP address is not provided then",
            "                # it will use one of the available IP address from the network",
            "                address = network.get('fixed_ip', None)",
            "                if address is not None and not utils.is_valid_ipv4(address):",
            "                    msg = _(\"Invalid fixed IP address (%s)\") % address",
            "                    raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "                port_id = network.get('port', None)",
            "                if port_id:",
            "                    network_uuid = None",
            "                    if not self._is_neutron_v2():",
            "                        # port parameter is only for neutron v2.0",
            "                        msg = _(\"Unknown argument: port\")",
            "                        raise exc.HTTPBadRequest(explanation=msg)",
            "                    if not uuidutils.is_uuid_like(port_id):",
            "                        msg = _(\"Bad port format: port uuid is \"",
            "                                \"not in proper format \"",
            "                                \"(%s)\") % port_id",
            "                        raise exc.HTTPBadRequest(explanation=msg)",
            "                    if address is not None:",
            "                        msg = _(\"Specified Fixed IP '%(addr)s' cannot be used \"",
            "                                \"with port '%(port)s': port already has \"",
            "                                \"a Fixed IP allocated.\") % {\"addr\": address,",
            "                                                            \"port\": port_id}",
            "                        raise exc.HTTPBadRequest(explanation=msg)",
            "                else:",
            "                    network_uuid = network['uuid']",
            "",
            "                if not port_id and not uuidutils.is_uuid_like(network_uuid):",
            "                    br_uuid = network_uuid.split('-', 1)[-1]",
            "                    if not uuidutils.is_uuid_like(br_uuid):",
            "                        msg = _(\"Bad networks format: network uuid is \"",
            "                                \"not in proper format \"",
            "                                \"(%s)\") % network_uuid",
            "                        raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "                # For neutronv2, requested_networks",
            "                # should be tuple of (network_uuid, fixed_ip, port_id)",
            "                if self._is_neutron_v2():",
            "                    networks.append((network_uuid, address, port_id))",
            "                else:",
            "                    # check if the network id is already present in the list,",
            "                    # we don't want duplicate networks to be passed",
            "                    # at the boot time",
            "                    for id, ip in networks:",
            "                        if id == network_uuid:",
            "                            expl = (_(\"Duplicate networks\"",
            "                                      \" (%s) are not allowed\") %",
            "                                    network_uuid)",
            "                            raise exc.HTTPBadRequest(explanation=expl)",
            "                    networks.append((network_uuid, address))",
            "            except KeyError as key:",
            "                expl = _('Bad network format: missing %s') % key",
            "                raise exc.HTTPBadRequest(explanation=expl)",
            "            except TypeError:",
            "                expl = _('Bad networks format')",
            "                raise exc.HTTPBadRequest(explanation=expl)",
            "",
            "        return networks",
            "",
            "    # NOTE(vish): Without this regex, b64decode will happily",
            "    #             ignore illegal bytes in the base64 encoded",
            "    #             data.",
            "    B64_REGEX = re.compile('^(?:[A-Za-z0-9+\\/]{4})*'",
            "                           '(?:[A-Za-z0-9+\\/]{2}=='",
            "                           '|[A-Za-z0-9+\\/]{3}=)?$')",
            "",
            "    def _decode_base64(self, data):",
            "        data = re.sub(r'\\s', '', data)",
            "        if not self.B64_REGEX.match(data):",
            "            return None",
            "        try:",
            "            return base64.b64decode(data)",
            "        except TypeError:",
            "            return None",
            "",
            "    def _validate_access_ipv4(self, address):",
            "        if not utils.is_valid_ipv4(address):",
            "            expl = _('access_ip_v4 is not proper IPv4 format')",
            "            raise exc.HTTPBadRequest(explanation=expl)",
            "",
            "    def _validate_access_ipv6(self, address):",
            "        if not utils.is_valid_ipv6(address):",
            "            expl = _('access_ip_v6 is not proper IPv6 format')",
            "            raise exc.HTTPBadRequest(explanation=expl)",
            "",
            "    @wsgi.serializers(xml=ServerTemplate)",
            "    def show(self, req, id):",
            "        \"\"\"Returns server details by server id.\"\"\"",
            "        try:",
            "            context = req.environ['nova.context']",
            "            instance = self.compute_api.get(context, id, want_objects=True)",
            "            req.cache_db_instance(instance)",
            "            return self._view_builder.show(req, instance)",
            "        except exception.NotFound:",
            "            msg = _(\"Instance could not be found\")",
            "            raise exc.HTTPNotFound(explanation=msg)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=CreateDeserializer)",
            "    def create(self, req, body):",
            "        \"\"\"Creates a new server for a given user.\"\"\"",
            "        if not self.is_valid_body(body, 'server'):",
            "            raise exc.HTTPUnprocessableEntity()",
            "",
            "        context = req.environ['nova.context']",
            "        server_dict = body['server']",
            "        password = self._get_server_admin_password(server_dict)",
            "",
            "        if 'name' not in server_dict:",
            "            msg = _(\"Server name is not defined\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        name = server_dict['name']",
            "        self._validate_server_name(name)",
            "        name = name.strip()",
            "",
            "        image_uuid = self._image_from_req_data(body)",
            "",
            "        # Arguments to be passed to instance create function",
            "        create_kwargs = {}",
            "",
            "        # Query extensions which want to manipulate the keyword",
            "        # arguments.",
            "        # NOTE(cyeoh): This is the hook that extensions use",
            "        # to replace the extension specific code below.",
            "        # When the extensions are ported this will also result",
            "        # in some convenience function from this class being",
            "        # moved to the extension",
            "        if list(self.create_extension_manager):",
            "            self.create_extension_manager.map(self._create_extension_point,",
            "                                              server_dict, create_kwargs)",
            "        # TODO(cyeoh): bp v3-api-core-as-extensions",
            "        # Replace with an extension point when the security groups",
            "        # extension is ported",
            "        sg_names = []",
            "        #if self.ext_mgr.is_loaded('os-security-groups'):",
            "        #    security_groups = server_dict.get('security_groups')",
            "        #    if security_groups is not None:",
            "        #        sg_names = [sg['name'] for sg in security_groups",
            "        #                    if sg.get('name')]",
            "        if not sg_names:",
            "            sg_names.append('default')",
            "",
            "        sg_names = list(set(sg_names))",
            "",
            "        requested_networks = None",
            "        # TODO(cyeoh): bp v3-api-core-as-extensions",
            "        # Replace with an extension point when the os-networks",
            "        # extension is ported. Currently reworked",
            "        # to take into account _is_neutron_v2",
            "        #if (self.ext_mgr.is_loaded('os-networks')",
            "        #        or self._is_neutron_v2()):",
            "        #    requested_networks = server_dict.get('networks')",
            "",
            "        if self._is_neutron_v2():",
            "            requested_networks = server_dict.get('networks')",
            "        if requested_networks is not None:",
            "            requested_networks = self._get_requested_networks(",
            "                requested_networks)",
            "",
            "        (access_ip_v4, ) = server_dict.get('access_ip_v4'),",
            "        if access_ip_v4 is not None:",
            "            self._validate_access_ipv4(access_ip_v4)",
            "",
            "        (access_ip_v6, ) = server_dict.get('access_ip_v6'),",
            "        if access_ip_v6 is not None:",
            "            self._validate_access_ipv6(access_ip_v6)",
            "",
            "        try:",
            "            flavor_id = self._flavor_id_from_req_data(body)",
            "        except ValueError as error:",
            "            msg = _(\"Invalid flavor_ref provided.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        block_device_mapping = None",
            "        # TODO(cyeoh): bp v3-api-core-as-extensions",
            "        # Replace with an extension point when the os-volumes",
            "        # extension is ported",
            "        #if self.ext_mgr.is_loaded('os-volumes'):",
            "        #    block_device_mapping = server_dict.get('block_device_mapping', [])",
            "        #    for bdm in block_device_mapping:",
            "        #        self._validate_device_name(bdm[\"device_name\"])",
            "        #        if 'delete_on_termination' in bdm:",
            "        #            bdm['delete_on_termination'] = strutils.bool_from_string(",
            "        #                bdm['delete_on_termination'])",
            "",
            "        ret_resv_id = False",
            "        # min_count and max_count are optional.  If they exist, they may come",
            "        # in as strings.  Verify that they are valid integers and > 0.",
            "        # Also, we want to default 'min_count' to 1, and default",
            "        # 'max_count' to be 'min_count'.",
            "        min_count = 1",
            "        max_count = 1",
            "        # TODO(cyeoh): bp v3-api-core-as-extensions",
            "        # Replace with an extension point when the os-multiple-create",
            "        # extension is ported",
            "        #if self.ext_mgr.is_loaded('os-multiple-create'):",
            "        #    ret_resv_id = server_dict.get('return_reservation_id', False)",
            "        #    min_count = server_dict.get('min_count', 1)",
            "        #    max_count = server_dict.get('max_count', min_count)",
            "",
            "        try:",
            "            min_count = int(str(min_count))",
            "        except ValueError:",
            "            msg = _('min_count must be an integer value')",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        if min_count < 1:",
            "            msg = _('min_count must be > 0')",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        try:",
            "            max_count = int(str(max_count))",
            "        except ValueError:",
            "            msg = _('max_count must be an integer value')",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        if max_count < 1:",
            "            msg = _('max_count must be > 0')",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        if min_count > max_count:",
            "            msg = _('min_count must be <= max_count')",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        try:",
            "            inst_type = flavors.get_flavor_by_flavor_id(",
            "                    flavor_id, ctxt=context, read_deleted=\"no\")",
            "",
            "            (instances, resv_id) = self.compute_api.create(context,",
            "                            inst_type,",
            "                            image_uuid,",
            "                            display_name=name,",
            "                            display_description=name,",
            "                            metadata=server_dict.get('metadata', {}),",
            "                            access_ip_v4=access_ip_v4,",
            "                            access_ip_v6=access_ip_v6,",
            "                            admin_password=password,",
            "                            min_count=min_count,",
            "                            max_count=max_count,",
            "                            requested_networks=requested_networks,",
            "                            security_group=sg_names,",
            "                            block_device_mapping=block_device_mapping,",
            "                            **create_kwargs)",
            "        except exception.QuotaError as error:",
            "            raise exc.HTTPRequestEntityTooLarge(",
            "                explanation=error.format_message(),",
            "                headers={'Retry-After': 0})",
            "        except exception.InvalidMetadataSize as error:",
            "            raise exc.HTTPRequestEntityTooLarge(",
            "                explanation=error.format_message())",
            "        except exception.ImageNotFound as error:",
            "            msg = _(\"Can not find requested image\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.FlavorNotFound as error:",
            "            msg = _(\"Invalid flavor_ref provided.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.KeypairNotFound as error:",
            "            msg = _(\"Invalid key_name provided.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.ConfigDriveInvalidValue:",
            "            msg = _(\"Invalid config_drive provided.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except rpc_common.RemoteError as err:",
            "            msg = \"%(err_type)s: %(err_msg)s\" % {'err_type': err.exc_type,",
            "                                                 'err_msg': err.value}",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except UnicodeDecodeError as error:",
            "            msg = \"UnicodeError: %s\" % unicode(error)",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except (exception.ImageNotActive,",
            "                exception.InstanceTypeDiskTooSmall,",
            "                exception.InstanceTypeMemoryTooSmall,",
            "                exception.InstanceTypeNotFound,",
            "                exception.InvalidMetadata,",
            "                exception.InvalidRequest,",
            "                exception.SecurityGroupNotFound,",
            "                exception.InstanceUserDataMalformed) as error:",
            "            raise exc.HTTPBadRequest(explanation=error.format_message())",
            "",
            "        # If the caller wanted a reservation_id, return it",
            "        if ret_resv_id:",
            "            return wsgi.ResponseObject({'reservation_id': resv_id},",
            "                                       xml=ServerMultipleCreateTemplate)",
            "",
            "        req.cache_db_instances(instances)",
            "        server = self._view_builder.create(req, instances[0])",
            "",
            "        if CONF.enable_instance_password:",
            "            server['server']['admin_pass'] = password",
            "",
            "        robj = wsgi.ResponseObject(server)",
            "",
            "        return self._add_location(robj)",
            "",
            "    def _create_extension_point(self, ext, server_dict, create_kwargs):",
            "        handler = ext.obj",
            "        LOG.debug(_(\"Running _create_extension_point for %s\"), ext.obj)",
            "",
            "        handler.server_create(server_dict, create_kwargs)",
            "",
            "    def _rebuild_extension_point(self, ext, rebuild_dict, rebuild_kwargs):",
            "        handler = ext.obj",
            "        LOG.debug(_(\"Running _rebuild_extension_point for %s\"), ext.obj)",
            "",
            "        handler.server_rebuild(rebuild_dict, rebuild_kwargs)",
            "",
            "    def _resize_extension_point(self, ext, resize_dict, resize_kwargs):",
            "        handler = ext.obj",
            "        LOG.debug(_(\"Running _resize_extension_point for %s\"), ext.obj)",
            "",
            "        handler.server_resize(resize_dict, resize_kwargs)",
            "",
            "    def _update_extension_point(self, ext, update_dict, update_kwargs):",
            "        handler = ext.obj",
            "        LOG.debug(_(\"Running _update_extension_point for %s\"), ext.obj)",
            "",
            "        handler.server_update(update_dict, update_kwargs)",
            "",
            "    def _delete(self, context, req, instance_uuid):",
            "        instance = self._get_server(context, req, instance_uuid)",
            "        if CONF.reclaim_instance_interval:",
            "            self.compute_api.soft_delete(context, instance)",
            "        else:",
            "            self.compute_api.delete(context, instance)",
            "",
            "    @wsgi.serializers(xml=ServerTemplate)",
            "    def update(self, req, id, body):",
            "        \"\"\"Update server then pass on to version-specific controller.\"\"\"",
            "        if not self.is_valid_body(body, 'server'):",
            "            raise exc.HTTPUnprocessableEntity()",
            "",
            "        ctxt = req.environ['nova.context']",
            "        update_dict = {}",
            "",
            "        if 'name' in body['server']:",
            "            name = body['server']['name']",
            "            self._validate_server_name(name)",
            "            update_dict['display_name'] = name.strip()",
            "",
            "        if 'access_ip_v4' in body['server']:",
            "            access_ipv4 = body['server']['access_ip_v4']",
            "            if access_ipv4:",
            "                self._validate_access_ipv4(access_ipv4)",
            "            update_dict['access_ip_v4'] = (",
            "                access_ipv4 and access_ipv4.strip() or None)",
            "",
            "        if 'access_ip_v6' in body['server']:",
            "            access_ipv6 = body['server']['access_ip_v6']",
            "            if access_ipv6:",
            "                self._validate_access_ipv6(access_ipv6)",
            "            update_dict['access_ip_v6'] = (",
            "                access_ipv6 and access_ipv6.strip() or None)",
            "",
            "        if 'host_id' in body['server']:",
            "            msg = _(\"host_id cannot be updated.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        if list(self.update_extension_manager):",
            "            self.update_extension_manager.map(self._update_extension_point,",
            "                                              body['server'], update_dict)",
            "",
            "        try:",
            "            instance = self.compute_api.get(ctxt, id, want_objects=True)",
            "            req.cache_db_instance(instance)",
            "            instance.update(update_dict)",
            "            instance.save()",
            "        except exception.NotFound:",
            "            msg = _(\"Instance could not be found\")",
            "            raise exc.HTTPNotFound(explanation=msg)",
            "",
            "        return self._view_builder.show(req, instance)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('confirm_resize')",
            "    def _action_confirm_resize(self, req, id, body):",
            "        context = req.environ['nova.context']",
            "        instance = self._get_server(context, req, id)",
            "        try:",
            "            self.compute_api.confirm_resize(context, instance)",
            "        except exception.MigrationNotFound:",
            "            msg = _(\"Instance has not been resized.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'confirm_resize')",
            "        return exc.HTTPNoContent()",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('revert_resize')",
            "    def _action_revert_resize(self, req, id, body):",
            "        context = req.environ['nova.context']",
            "        instance = self._get_server(context, req, id)",
            "        try:",
            "            self.compute_api.revert_resize(context, instance)",
            "        except exception.MigrationNotFound:",
            "            msg = _(\"Instance has not been resized.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.InstanceTypeNotFound:",
            "            msg = _(\"Flavor used by the instance could not be found.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'revert_resize')",
            "        return webob.Response(status_int=202)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('reboot')",
            "    def _action_reboot(self, req, id, body):",
            "        if 'reboot' in body and 'type' in body['reboot']:",
            "            valid_reboot_types = ['HARD', 'SOFT']",
            "            reboot_type = body['reboot']['type'].upper()",
            "            if not valid_reboot_types.count(reboot_type):",
            "                msg = _(\"Argument 'type' for reboot is not HARD or SOFT\")",
            "                LOG.error(msg)",
            "                raise exc.HTTPBadRequest(explanation=msg)",
            "        else:",
            "            msg = _(\"Missing argument 'type' for reboot\")",
            "            LOG.error(msg)",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        context = req.environ['nova.context']",
            "        instance = self._get_server(context, req, id)",
            "",
            "        try:",
            "            self.compute_api.reboot(context, instance, reboot_type)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'reboot')",
            "        return webob.Response(status_int=202)",
            "",
            "    def _resize(self, req, instance_id, flavor_id, **kwargs):",
            "        \"\"\"Begin the resize process with given instance/flavor.\"\"\"",
            "        context = req.environ[\"nova.context\"]",
            "        instance = self._get_server(context, req, instance_id)",
            "",
            "        try:",
            "            self.compute_api.resize(context, instance, flavor_id, **kwargs)",
            "        except exception.FlavorNotFound:",
            "            msg = _(\"Unable to locate requested flavor.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.CannotResizeToSameFlavor:",
            "            msg = _(\"Resize requires a flavor change.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'resize')",
            "        except exception.ImageNotAuthorized as image_error:",
            "            msg = _(\"You are not authorized to access the image \"",
            "                    \"the instance was started with.\")",
            "            raise exc.HTTPUnauthorized(explanation=msg)",
            "        except exception.ImageNotFound as image_error:",
            "            msg = _(\"Image that the instance was started \"",
            "                    \"with could not be found.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.Invalid:",
            "            msg = _(\"Invalid instance image.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        return webob.Response(status_int=202)",
            "",
            "    @wsgi.response(204)",
            "    def delete(self, req, id):",
            "        \"\"\"Destroys a server.\"\"\"",
            "        try:",
            "            self._delete(req.environ['nova.context'], req, id)",
            "        except exception.NotFound:",
            "            msg = _(\"Instance could not be found\")",
            "            raise exc.HTTPNotFound(explanation=msg)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'delete')",
            "",
            "    def _image_ref_from_req_data(self, data):",
            "        try:",
            "            return unicode(data['server']['image_ref'])",
            "        except (TypeError, KeyError):",
            "            msg = _(\"Missing image_ref attribute\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "    def _image_uuid_from_href(self, image_href):",
            "        # If the image href was generated by nova api, strip image_href",
            "        # down to an id and use the default glance connection params",
            "        image_uuid = image_href.split('/').pop()",
            "",
            "        if not uuidutils.is_uuid_like(image_uuid):",
            "            msg = _(\"Invalid image_ref provided.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        return image_uuid",
            "",
            "    def _image_from_req_data(self, data):",
            "        \"\"\"",
            "        Get image data from the request or raise appropriate",
            "        exceptions",
            "",
            "        If no image is supplied - checks to see if there is",
            "        block devices set and proper extesions loaded.",
            "        \"\"\"",
            "        image_ref = data['server'].get('image_ref')",
            "        bdm = data['server'].get('block_device_mapping')",
            "",
            "        # TODO(cyeoh): bp v3-api-core-as-extensions",
            "        # Replace with extension point. For the moment",
            "        # with no ep, assume os-volumes is not present",
            "        #if not image_ref and bdm and self.ext_mgr.is_loaded('os-volumes'):",
            "        #    return ''",
            "        #else:",
            "        #    image_href = self._image_ref_from_req_data(data)",
            "        #    image_uuid = self._image_uuid_from_href(image_href)",
            "        #    return image_uuid",
            "        image_href = self._image_ref_from_req_data(data)",
            "        image_uuid = self._image_uuid_from_href(image_href)",
            "        return image_uuid",
            "",
            "    def _flavor_id_from_req_data(self, data):",
            "        try:",
            "            flavor_ref = data['server']['flavor_ref']",
            "        except (TypeError, KeyError):",
            "            msg = _(\"Missing flavor_ref attribute\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        return common.get_id_from_href(flavor_ref)",
            "",
            "    def _validate_metadata(self, metadata):",
            "        \"\"\"Ensure that we can work with the metadata given.\"\"\"",
            "        try:",
            "            metadata.iteritems()",
            "        except AttributeError:",
            "            msg = _(\"Unable to parse metadata key/value pairs.\")",
            "            LOG.debug(msg)",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('resize')",
            "    def _action_resize(self, req, id, body):",
            "        \"\"\"Resizes a given instance to the flavor size requested.\"\"\"",
            "        resize_dict = body['resize']",
            "        try:",
            "            flavor_ref = str(resize_dict[\"flavor_ref\"])",
            "            if not flavor_ref:",
            "                msg = _(\"Resize request has invalid 'flavor_ref' attribute.\")",
            "                raise exc.HTTPBadRequest(explanation=msg)",
            "        except (KeyError, TypeError):",
            "            msg = _(\"Resize requests require 'flavor_ref' attribute.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        resize_kwargs = {}",
            "",
            "        if list(self.resize_extension_manager):",
            "            self.resize_extension_manager.map(self._resize_extension_point,",
            "                                              resize_dict, resize_kwargs)",
            "",
            "        return self._resize(req, id, flavor_ref, **resize_kwargs)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('rebuild')",
            "    def _action_rebuild(self, req, id, body):",
            "        \"\"\"Rebuild an instance with the given attributes.\"\"\"",
            "        try:",
            "            rebuild_dict = body['rebuild']",
            "        except (KeyError, TypeError):",
            "            msg = _('Invalid request body')",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        try:",
            "            image_href = rebuild_dict[\"image_ref\"]",
            "        except (KeyError, TypeError):",
            "            msg = _(\"Could not parse image_ref from request.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        image_href = self._image_uuid_from_href(image_href)",
            "",
            "        try:",
            "            password = rebuild_dict['admin_pass']",
            "        except (KeyError, TypeError):",
            "            password = utils.generate_password()",
            "",
            "        context = req.environ['nova.context']",
            "        instance = self._get_server(context, req, id)",
            "",
            "        attr_map = {",
            "            'name': 'display_name',",
            "            'access_ip_v4': 'access_ip_v4',",
            "            'access_ip_v6': 'access_ip_v6',",
            "            'metadata': 'metadata',",
            "        }",
            "",
            "        if 'access_ip_v4' in rebuild_dict:",
            "            self._validate_access_ipv4(rebuild_dict['access_ip_v4'])",
            "",
            "        if 'access_ip_v6' in rebuild_dict:",
            "            self._validate_access_ipv6(rebuild_dict['access_ip_v6'])",
            "",
            "        rebuild_kwargs = {}",
            "        if list(self.rebuild_extension_manager):",
            "            self.rebuild_extension_manager.map(self._rebuild_extension_point,",
            "                                               rebuild_dict, rebuild_kwargs)",
            "",
            "        for request_attribute, instance_attribute in attr_map.items():",
            "            try:",
            "                rebuild_kwargs[instance_attribute] = rebuild_dict[",
            "                    request_attribute]",
            "            except (KeyError, TypeError):",
            "                pass",
            "",
            "        self._validate_metadata(rebuild_kwargs.get('metadata', {}))",
            "",
            "        try:",
            "            self.compute_api.rebuild(context,",
            "                                     instance,",
            "                                     image_href,",
            "                                     password,",
            "                                     **rebuild_kwargs)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'rebuild')",
            "        except exception.InstanceNotFound:",
            "            msg = _(\"Instance could not be found\")",
            "            raise exc.HTTPNotFound(explanation=msg)",
            "        except exception.InvalidMetadataSize as error:",
            "            raise exc.HTTPRequestEntityTooLarge(",
            "                explanation=error.format_message())",
            "        except exception.ImageNotFound:",
            "            msg = _(\"Cannot find image for rebuild\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except (exception.ImageNotActive,",
            "                exception.InstanceTypeDiskTooSmall,",
            "                exception.InstanceTypeMemoryTooSmall,",
            "                exception.InvalidMetadata) as error:",
            "            raise exc.HTTPBadRequest(explanation=error.format_message())",
            "",
            "        instance = self._get_server(context, req, id)",
            "",
            "        view = self._view_builder.show(req, instance)",
            "",
            "        # Add on the admin_pass attribute since the view doesn't do it",
            "        # unless instance passwords are disabled",
            "        if CONF.enable_instance_password:",
            "            view['server']['admin_pass'] = password",
            "",
            "        robj = wsgi.ResponseObject(view)",
            "        return self._add_location(robj)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('create_image')",
            "    @common.check_snapshots_enabled",
            "    def _action_create_image(self, req, id, body):",
            "        \"\"\"Snapshot a server instance.\"\"\"",
            "        context = req.environ['nova.context']",
            "        entity = body.get(\"create_image\", {})",
            "",
            "        image_name = entity.get(\"name\")",
            "",
            "        if not image_name:",
            "            msg = _(\"create_image entity requires name attribute\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        props = {}",
            "        metadata = entity.get('metadata', {})",
            "        common.check_img_metadata_properties_quota(context, metadata)",
            "        try:",
            "            props.update(metadata)",
            "        except ValueError:",
            "            msg = _(\"Invalid metadata\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        instance = self._get_server(context, req, id)",
            "",
            "        bdms = self.compute_api.get_instance_bdms(context, instance)",
            "",
            "        try:",
            "            if self.compute_api.is_volume_backed_instance(context, instance,",
            "                                                          bdms):",
            "                img = instance['image_ref']",
            "                if not img:",
            "                    # NOTE(Vincent Hou) The private method",
            "                    # _get_volume_image_metadata only works, when boot",
            "                    # device is set to 'vda'. It needs to be fixed later,",
            "                    # but tentatively we use it here.",
            "                    image_meta = {'properties': self.compute_api.",
            "                                    _get_volume_image_metadata(context, bdms)}",
            "                else:",
            "                    src_image = self.compute_api.\\",
            "                        image_service.show(context, img)",
            "                    image_meta = dict(src_image)",
            "",
            "                image = self.compute_api.snapshot_volume_backed(",
            "                                                       context,",
            "                                                       instance,",
            "                                                       image_meta,",
            "                                                       image_name,",
            "                                                       extra_properties=props)",
            "            else:",
            "                image = self.compute_api.snapshot(context,",
            "                                                  instance,",
            "                                                  image_name,",
            "                                                  extra_properties=props)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                        'create_image')",
            "        except exception.Invalid as err:",
            "            raise exc.HTTPBadRequest(explanation=err.format_message())",
            "",
            "        # build location of newly-created image entity",
            "        image_id = str(image['id'])",
            "        image_ref = os.path.join(req.application_url,",
            "                                 context.project_id,",
            "                                 'images',",
            "                                 image_id)",
            "",
            "        resp = webob.Response(status_int=202)",
            "        resp.headers['Location'] = image_ref",
            "        return resp",
            "",
            "    def _get_server_admin_password(self, server):",
            "        \"\"\"Determine the admin password for a server on creation.\"\"\"",
            "        try:",
            "            password = server['admin_pass']",
            "            self._validate_admin_password(password)",
            "        except KeyError:",
            "            password = utils.generate_password()",
            "        except ValueError:",
            "            raise exc.HTTPBadRequest(explanation=_(\"Invalid admin_pass\"))",
            "",
            "        return password",
            "",
            "    def _validate_admin_password(self, password):",
            "        if not isinstance(password, basestring):",
            "            raise ValueError()",
            "",
            "    def _get_server_search_options(self):",
            "        \"\"\"Return server search options allowed by non-admin.\"\"\"",
            "        return ('reservation_id', 'name', 'status', 'image', 'flavor',",
            "                'ip', 'changes_since', 'all_tenants')",
            "",
            "    def _server_create_xml_deserialize_extension_point(self, ext, server_node,",
            "                                                       server_dict):",
            "        handler = ext.obj",
            "        LOG.debug(_(\"Running create xml deserialize ep for %s\"),",
            "                  handler.alias)",
            "        handler.server_xml_extract_server_deserialize(server_node,",
            "                                                      server_dict)",
            "",
            "    def server_create_xml_deserialize(self, server_node, server):",
            "        self.create_xml_deserialize_manager.map(",
            "            self._server_create_xml_deserialize_extension_point,",
            "            server_node, server)",
            "",
            "    def _server_rebuild_xml_deserialize_extension_point(self, ext,",
            "                                                        rebuild_node,",
            "                                                        rebuild_dict):",
            "        handler = ext.obj",
            "        LOG.debug(_(\"Running rebuild xml deserialize ep for %s\"),",
            "                  handler.alias)",
            "        handler.server_xml_extract_rebuild_deserialize(rebuild_node,",
            "                                                       rebuild_dict)",
            "",
            "    def server_rebuild_xml_deserialize(self, rebuild_node, rebuild_dict):",
            "        if list(self.rebuild_xml_deserialize_manager):",
            "            self.rebuild_xml_deserialize_manager.map(",
            "                self._server_rebuild_xml_deserialize_extension_point,",
            "                rebuild_node, rebuild_dict)",
            "",
            "    def _server_resize_xml_deserialize_extension_point(self, ext, resize_node,",
            "                                                       resize_dict):",
            "        handler = ext.obj",
            "        LOG.debug(_(\"Running rebuild xml deserialize ep for %s\"),",
            "                  handler.alias)",
            "        handler.server_xml_extract_resize_deserialize(resize_node, resize_dict)",
            "",
            "    def server_resize_xml_deserialize(self, resize_node, resize_dict):",
            "        if list(self.resize_xml_deserialize_manager):",
            "            self.resize_xml_deserialize_manager.map(",
            "                self._server_resize_xml_deserialize_extension_point,",
            "                resize_node, resize_dict)",
            "",
            "    def _get_instance(self, context, instance_uuid):",
            "        try:",
            "            attrs = ['system_metadata', 'metadata']",
            "            return instance_obj.Instance.get_by_uuid(context, instance_uuid,",
            "                                                     expected_attrs=attrs)",
            "        except exception.InstanceNotFound as e:",
            "            raise webob.exc.HTTPNotFound(explanation=e.format_message())",
            "",
            "    @extensions.expected_errors((404, 409))",
            "    @wsgi.action('start')",
            "    def _start_server(self, req, id, body):",
            "        \"\"\"Start an instance.\"\"\"",
            "        context = req.environ['nova.context']",
            "        instance = self._get_instance(context, id)",
            "        LOG.debug(_('start instance'), instance=instance)",
            "        try:",
            "            self.compute_api.start(context, instance)",
            "        except exception.InstanceNotReady as e:",
            "            raise webob.exc.HTTPConflict(explanation=e.format_message())",
            "        return webob.Response(status_int=202)",
            "",
            "    @extensions.expected_errors((404, 409))",
            "    @wsgi.action('stop')",
            "    def _stop_server(self, req, id, body):",
            "        \"\"\"Stop an instance.\"\"\"",
            "        context = req.environ['nova.context']",
            "        instance = self._get_instance(context, id)",
            "        LOG.debug(_('stop instance'), instance=instance)",
            "        try:",
            "            self.compute_api.stop(context, instance)",
            "        except exception.InstanceNotReady as e:",
            "            raise webob.exc.HTTPConflict(explanation=e.format_message())",
            "        return webob.Response(status_int=202)",
            "",
            "",
            "def remove_invalid_options(context, search_options, allowed_search_options):",
            "    \"\"\"Remove search options that are not valid for non-admin API/context.\"\"\"",
            "    if context.is_admin:",
            "        # Allow all options",
            "        return",
            "    # Otherwise, strip out all unknown options",
            "    unknown_options = [opt for opt in search_options",
            "                        if opt not in allowed_search_options]",
            "    LOG.debug(_(\"Removing options '%s' from query\"),",
            "              \", \".join(unknown_options))",
            "    for opt in unknown_options:",
            "        search_options.pop(opt, None)",
            "",
            "",
            "class Servers(extensions.V3APIExtensionBase):",
            "    \"\"\"Servers.\"\"\"",
            "",
            "    name = \"Servers\"",
            "    alias = \"servers\"",
            "    namespace = \"http://docs.openstack.org/compute/core/servers/v3\"",
            "    version = 1",
            "",
            "    def get_resources(self):",
            "        member_actions = {'action': 'POST'}",
            "        collection_actions = {'detail': 'GET'}",
            "        resources = [",
            "            extensions.ResourceExtension(",
            "                'servers',",
            "                ServersController(extension_info=self.extension_info),",
            "                member_name='server', collection_actions=collection_actions,",
            "                member_actions=member_actions)]",
            "",
            "        return resources",
            "",
            "    def get_controller_extensions(self):",
            "        return []"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "911": [
                "ServersController",
                "create"
            ]
        },
        "addLocation": []
    },
    "nova/api/openstack/compute/servers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 920,
                "afterPatchRowNumber": 920,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 921,
                "afterPatchRowNumber": 921,
                "PatchRowcode": "         try:"
            },
            "2": {
                "beforePatchRowNumber": 922,
                "afterPatchRowNumber": 922,
                "PatchRowcode": "             _get_inst_type = flavors.get_flavor_by_flavor_id"
            },
            "3": {
                "beforePatchRowNumber": 923,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            inst_type = _get_inst_type(flavor_id, read_deleted=\"no\")"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 923,
                "PatchRowcode": "+            inst_type = _get_inst_type(flavor_id, ctxt=context,"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 924,
                "PatchRowcode": "+                                       read_deleted=\"no\")"
            },
            "6": {
                "beforePatchRowNumber": 924,
                "afterPatchRowNumber": 925,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 925,
                "afterPatchRowNumber": 926,
                "PatchRowcode": "             (instances, resv_id) = self.compute_api.create(context,"
            },
            "8": {
                "beforePatchRowNumber": 926,
                "afterPatchRowNumber": 927,
                "PatchRowcode": "                             inst_type,"
            }
        },
        "frontPatchFile": [
            "# Copyright 2010 OpenStack Foundation",
            "# Copyright 2011 Piston Cloud Computing, Inc",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import base64",
            "import os",
            "import re",
            "",
            "from oslo.config import cfg",
            "import webob",
            "from webob import exc",
            "",
            "from nova.api.openstack import common",
            "from nova.api.openstack.compute import ips",
            "from nova.api.openstack.compute.views import servers as views_servers",
            "from nova.api.openstack import wsgi",
            "from nova.api.openstack import xmlutil",
            "from nova import block_device",
            "from nova import compute",
            "from nova.compute import flavors",
            "from nova import exception",
            "from nova.openstack.common.gettextutils import _",
            "from nova.openstack.common import importutils",
            "from nova.openstack.common import log as logging",
            "from nova.openstack.common.rpc import common as rpc_common",
            "from nova.openstack.common import strutils",
            "from nova.openstack.common import timeutils",
            "from nova.openstack.common import uuidutils",
            "from nova import policy",
            "from nova import utils",
            "",
            "",
            "server_opts = [",
            "    cfg.BoolOpt('enable_instance_password',",
            "                default=True,",
            "                help='Allows use of instance password during '",
            "                     'server creation'),",
            "]",
            "CONF = cfg.CONF",
            "CONF.register_opts(server_opts)",
            "CONF.import_opt('network_api_class', 'nova.network')",
            "CONF.import_opt('reclaim_instance_interval', 'nova.compute.manager')",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "def make_fault(elem):",
            "    fault = xmlutil.SubTemplateElement(elem, 'fault', selector='fault')",
            "    fault.set('code')",
            "    fault.set('created')",
            "    msg = xmlutil.SubTemplateElement(fault, 'message')",
            "    msg.text = 'message'",
            "    det = xmlutil.SubTemplateElement(fault, 'details')",
            "    det.text = 'details'",
            "",
            "",
            "def make_server(elem, detailed=False):",
            "    elem.set('name')",
            "    elem.set('id')",
            "",
            "    if detailed:",
            "        elem.set('userId', 'user_id')",
            "        elem.set('tenantId', 'tenant_id')",
            "        elem.set('updated')",
            "        elem.set('created')",
            "        elem.set('hostId')",
            "        elem.set('accessIPv4')",
            "        elem.set('accessIPv6')",
            "        elem.set('status')",
            "        elem.set('progress')",
            "        elem.set('reservation_id')",
            "",
            "        # Attach image node",
            "        image = xmlutil.SubTemplateElement(elem, 'image', selector='image')",
            "        image.set('id')",
            "        xmlutil.make_links(image, 'links')",
            "",
            "        # Attach flavor node",
            "        flavor = xmlutil.SubTemplateElement(elem, 'flavor', selector='flavor')",
            "        flavor.set('id')",
            "        xmlutil.make_links(flavor, 'links')",
            "",
            "        # Attach fault node",
            "        make_fault(elem)",
            "",
            "        # Attach metadata node",
            "        elem.append(common.MetadataTemplate())",
            "",
            "        # Attach addresses node",
            "        elem.append(ips.AddressesTemplate())",
            "",
            "    xmlutil.make_links(elem, 'links')",
            "",
            "",
            "server_nsmap = {None: xmlutil.XMLNS_V11, 'atom': xmlutil.XMLNS_ATOM}",
            "",
            "",
            "class ServerTemplate(xmlutil.TemplateBuilder):",
            "    def construct(self):",
            "        root = xmlutil.TemplateElement('server', selector='server')",
            "        make_server(root, detailed=True)",
            "        return xmlutil.MasterTemplate(root, 1, nsmap=server_nsmap)",
            "",
            "",
            "class MinimalServersTemplate(xmlutil.TemplateBuilder):",
            "    def construct(self):",
            "        root = xmlutil.TemplateElement('servers')",
            "        elem = xmlutil.SubTemplateElement(root, 'server', selector='servers')",
            "        make_server(elem)",
            "        xmlutil.make_links(root, 'servers_links')",
            "        return xmlutil.MasterTemplate(root, 1, nsmap=server_nsmap)",
            "",
            "",
            "class ServersTemplate(xmlutil.TemplateBuilder):",
            "    def construct(self):",
            "        root = xmlutil.TemplateElement('servers')",
            "        elem = xmlutil.SubTemplateElement(root, 'server', selector='servers')",
            "        make_server(elem, detailed=True)",
            "        return xmlutil.MasterTemplate(root, 1, nsmap=server_nsmap)",
            "",
            "",
            "class ServerAdminPassTemplate(xmlutil.TemplateBuilder):",
            "    def construct(self):",
            "        root = xmlutil.TemplateElement('server')",
            "        root.set('adminPass')",
            "        return xmlutil.SlaveTemplate(root, 1, nsmap=server_nsmap)",
            "",
            "",
            "class ServerMultipleCreateTemplate(xmlutil.TemplateBuilder):",
            "    def construct(self):",
            "        root = xmlutil.TemplateElement('server')",
            "        root.set('reservation_id')",
            "        return xmlutil.MasterTemplate(root, 1, nsmap=server_nsmap)",
            "",
            "",
            "def FullServerTemplate():",
            "    master = ServerTemplate()",
            "    master.attach(ServerAdminPassTemplate())",
            "    return master",
            "",
            "",
            "class CommonDeserializer(wsgi.MetadataXMLDeserializer):",
            "    \"\"\"Common deserializer to handle xml-formatted server create requests.",
            "",
            "    Handles standard server attributes as well as optional metadata",
            "    and personality attributes",
            "    \"\"\"",
            "",
            "    metadata_deserializer = common.MetadataXMLDeserializer()",
            "",
            "    def _extract_personality(self, server_node):",
            "        \"\"\"Marshal the personality attribute of a parsed request.\"\"\"",
            "        node = self.find_first_child_named(server_node, \"personality\")",
            "        if node is not None:",
            "            personality = []",
            "            for file_node in self.find_children_named(node, \"file\"):",
            "                item = {}",
            "                if file_node.hasAttribute(\"path\"):",
            "                    item[\"path\"] = file_node.getAttribute(\"path\")",
            "                item[\"contents\"] = self.extract_text(file_node)",
            "                personality.append(item)",
            "            return personality",
            "        else:",
            "            return None",
            "",
            "    def _extract_server(self, node):",
            "        \"\"\"Marshal the server attribute of a parsed request.\"\"\"",
            "        server = {}",
            "        server_node = self.find_first_child_named(node, 'server')",
            "",
            "        attributes = [\"name\", \"imageRef\", \"flavorRef\", \"adminPass\",",
            "                      \"accessIPv4\", \"accessIPv6\", \"key_name\",",
            "                      \"availability_zone\", \"min_count\", \"max_count\"]",
            "        for attr in attributes:",
            "            if server_node.getAttribute(attr):",
            "                server[attr] = server_node.getAttribute(attr)",
            "",
            "        res_id = server_node.getAttribute('return_reservation_id')",
            "        if res_id:",
            "            server['return_reservation_id'] = \\",
            "                    strutils.bool_from_string(res_id)",
            "",
            "        scheduler_hints = self._extract_scheduler_hints(server_node)",
            "        if scheduler_hints:",
            "            server['OS-SCH-HNT:scheduler_hints'] = scheduler_hints",
            "",
            "        metadata_node = self.find_first_child_named(server_node, \"metadata\")",
            "        if metadata_node is not None:",
            "            server[\"metadata\"] = self.extract_metadata(metadata_node)",
            "",
            "        user_data_node = self.find_first_child_named(server_node, \"user_data\")",
            "        if user_data_node is not None:",
            "            server[\"user_data\"] = self.extract_text(user_data_node)",
            "",
            "        personality = self._extract_personality(server_node)",
            "        if personality is not None:",
            "            server[\"personality\"] = personality",
            "",
            "        networks = self._extract_networks(server_node)",
            "        if networks is not None:",
            "            server[\"networks\"] = networks",
            "",
            "        security_groups = self._extract_security_groups(server_node)",
            "        if security_groups is not None:",
            "            server[\"security_groups\"] = security_groups",
            "",
            "        # NOTE(vish): this is not namespaced in json, so leave it without a",
            "        #             namespace for now",
            "        block_device_mapping = self._extract_block_device_mapping(server_node)",
            "        if block_device_mapping is not None:",
            "            server[\"block_device_mapping\"] = block_device_mapping",
            "",
            "        block_device_mapping_v2 = self._extract_block_device_mapping_v2(",
            "            server_node)",
            "        if block_device_mapping_v2 is not None:",
            "            server[\"block_device_mapping_v2\"] = block_device_mapping_v2",
            "",
            "        # NOTE(vish): Support this incorrect version because it was in the code",
            "        #             base for a while and we don't want to accidentally break",
            "        #             anyone that might be using it.",
            "        auto_disk_config = server_node.getAttribute('auto_disk_config')",
            "        if auto_disk_config:",
            "            server['OS-DCF:diskConfig'] = auto_disk_config",
            "",
            "        auto_disk_config = server_node.getAttribute('OS-DCF:diskConfig')",
            "        if auto_disk_config:",
            "            server['OS-DCF:diskConfig'] = auto_disk_config",
            "",
            "        config_drive = server_node.getAttribute('config_drive')",
            "        if config_drive:",
            "            server['config_drive'] = config_drive",
            "",
            "        return server",
            "",
            "    def _extract_block_device_mapping(self, server_node):",
            "        \"\"\"Marshal the block_device_mapping node of a parsed request.\"\"\"",
            "        node = self.find_first_child_named(server_node, \"block_device_mapping\")",
            "        if node:",
            "            block_device_mapping = []",
            "            for child in self.extract_elements(node):",
            "                if child.nodeName != \"mapping\":",
            "                    continue",
            "                mapping = {}",
            "                attributes = [\"volume_id\", \"snapshot_id\", \"device_name\",",
            "                              \"virtual_name\", \"volume_size\"]",
            "                for attr in attributes:",
            "                    value = child.getAttribute(attr)",
            "                    if value:",
            "                        mapping[attr] = value",
            "                attributes = [\"delete_on_termination\", \"no_device\"]",
            "                for attr in attributes:",
            "                    value = child.getAttribute(attr)",
            "                    if value:",
            "                        mapping[attr] = strutils.bool_from_string(value)",
            "                block_device_mapping.append(mapping)",
            "            return block_device_mapping",
            "        else:",
            "            return None",
            "",
            "    def _extract_block_device_mapping_v2(self, server_node):",
            "        \"\"\"Marshal the new block_device_mappings.\"\"\"",
            "        node = self.find_first_child_named(server_node,",
            "                                           \"block_device_mapping_v2\")",
            "        if node:",
            "            block_device_mapping = []",
            "            for child in self.extract_elements(node):",
            "                if child.nodeName != \"mapping\":",
            "                    continue",
            "                block_device_mapping.append(",
            "                    dict((attr, child.getAttribute(attr))",
            "                        for attr in block_device.bdm_new_api_fields",
            "                        if child.getAttribute(attr)))",
            "            return block_device_mapping",
            "",
            "    def _extract_scheduler_hints(self, server_node):",
            "        \"\"\"Marshal the scheduler hints attribute of a parsed request.\"\"\"",
            "        node = self.find_first_child_named_in_namespace(server_node,",
            "            \"http://docs.openstack.org/compute/ext/scheduler-hints/api/v2\",",
            "            \"scheduler_hints\")",
            "        if node:",
            "            scheduler_hints = {}",
            "            for child in self.extract_elements(node):",
            "                scheduler_hints.setdefault(child.nodeName, [])",
            "                value = self.extract_text(child).strip()",
            "                scheduler_hints[child.nodeName].append(value)",
            "            return scheduler_hints",
            "        else:",
            "            return None",
            "",
            "    def _extract_networks(self, server_node):",
            "        \"\"\"Marshal the networks attribute of a parsed request.\"\"\"",
            "        node = self.find_first_child_named(server_node, \"networks\")",
            "        if node is not None:",
            "            networks = []",
            "            for network_node in self.find_children_named(node,",
            "                                                         \"network\"):",
            "                item = {}",
            "                if network_node.hasAttribute(\"uuid\"):",
            "                    item[\"uuid\"] = network_node.getAttribute(\"uuid\")",
            "                if network_node.hasAttribute(\"fixed_ip\"):",
            "                    item[\"fixed_ip\"] = network_node.getAttribute(\"fixed_ip\")",
            "                if network_node.hasAttribute(\"port\"):",
            "                    item[\"port\"] = network_node.getAttribute(\"port\")",
            "                networks.append(item)",
            "            return networks",
            "        else:",
            "            return None",
            "",
            "    def _extract_security_groups(self, server_node):",
            "        \"\"\"Marshal the security_groups attribute of a parsed request.\"\"\"",
            "        node = self.find_first_child_named(server_node, \"security_groups\")",
            "        if node is not None:",
            "            security_groups = []",
            "            for sg_node in self.find_children_named(node, \"security_group\"):",
            "                item = {}",
            "                name = self.find_attribute_or_element(sg_node, 'name')",
            "                if name:",
            "                    item[\"name\"] = name",
            "                    security_groups.append(item)",
            "            return security_groups",
            "        else:",
            "            return None",
            "",
            "",
            "class ActionDeserializer(CommonDeserializer):",
            "    \"\"\"Deserializer to handle xml-formatted server action requests.",
            "",
            "    Handles standard server attributes as well as optional metadata",
            "    and personality attributes",
            "    \"\"\"",
            "",
            "    def default(self, string):",
            "        dom = xmlutil.safe_minidom_parse_string(string)",
            "        action_node = dom.childNodes[0]",
            "        action_name = action_node.tagName",
            "",
            "        action_deserializer = {",
            "            'createImage': self._action_create_image,",
            "            'changePassword': self._action_change_password,",
            "            'reboot': self._action_reboot,",
            "            'rebuild': self._action_rebuild,",
            "            'resize': self._action_resize,",
            "            'confirmResize': self._action_confirm_resize,",
            "            'revertResize': self._action_revert_resize,",
            "        }.get(action_name, super(ActionDeserializer, self).default)",
            "",
            "        action_data = action_deserializer(action_node)",
            "",
            "        return {'body': {action_name: action_data}}",
            "",
            "    def _action_create_image(self, node):",
            "        return self._deserialize_image_action(node, ('name',))",
            "",
            "    def _action_change_password(self, node):",
            "        if not node.hasAttribute(\"adminPass\"):",
            "            raise AttributeError(\"No adminPass was specified in request\")",
            "        return {\"adminPass\": node.getAttribute(\"adminPass\")}",
            "",
            "    def _action_reboot(self, node):",
            "        if not node.hasAttribute(\"type\"):",
            "            raise AttributeError(\"No reboot type was specified in request\")",
            "        return {\"type\": node.getAttribute(\"type\")}",
            "",
            "    def _action_rebuild(self, node):",
            "        rebuild = {}",
            "        if node.hasAttribute(\"name\"):",
            "            name = node.getAttribute(\"name\")",
            "            if not name:",
            "                raise AttributeError(\"Name cannot be blank\")",
            "            rebuild['name'] = name",
            "",
            "        if node.hasAttribute(\"auto_disk_config\"):",
            "            rebuild['OS-DCF:diskConfig'] = node.getAttribute(",
            "                \"auto_disk_config\")",
            "",
            "        if node.hasAttribute(\"OS-DCF:diskConfig\"):",
            "            rebuild['OS-DCF:diskConfig'] = node.getAttribute(",
            "                \"OS-DCF:diskConfig\")",
            "",
            "        metadata_node = self.find_first_child_named(node, \"metadata\")",
            "        if metadata_node is not None:",
            "            rebuild[\"metadata\"] = self.extract_metadata(metadata_node)",
            "",
            "        personality = self._extract_personality(node)",
            "        if personality is not None:",
            "            rebuild[\"personality\"] = personality",
            "",
            "        if not node.hasAttribute(\"imageRef\"):",
            "            raise AttributeError(\"No imageRef was specified in request\")",
            "        rebuild[\"imageRef\"] = node.getAttribute(\"imageRef\")",
            "",
            "        if node.hasAttribute(\"adminPass\"):",
            "            rebuild[\"adminPass\"] = node.getAttribute(\"adminPass\")",
            "",
            "        if node.hasAttribute(\"accessIPv4\"):",
            "            rebuild[\"accessIPv4\"] = node.getAttribute(\"accessIPv4\")",
            "",
            "        if node.hasAttribute(\"accessIPv6\"):",
            "            rebuild[\"accessIPv6\"] = node.getAttribute(\"accessIPv6\")",
            "",
            "        return rebuild",
            "",
            "    def _action_resize(self, node):",
            "        resize = {}",
            "",
            "        if node.hasAttribute(\"flavorRef\"):",
            "            resize[\"flavorRef\"] = node.getAttribute(\"flavorRef\")",
            "        else:",
            "            raise AttributeError(\"No flavorRef was specified in request\")",
            "",
            "        if node.hasAttribute(\"auto_disk_config\"):",
            "            resize['OS-DCF:diskConfig'] = node.getAttribute(\"auto_disk_config\")",
            "",
            "        if node.hasAttribute(\"OS-DCF:diskConfig\"):",
            "            resize['OS-DCF:diskConfig'] = node.getAttribute(",
            "                \"OS-DCF:diskConfig\")",
            "",
            "        return resize",
            "",
            "    def _action_confirm_resize(self, node):",
            "        return None",
            "",
            "    def _action_revert_resize(self, node):",
            "        return None",
            "",
            "    def _deserialize_image_action(self, node, allowed_attributes):",
            "        data = {}",
            "        for attribute in allowed_attributes:",
            "            value = node.getAttribute(attribute)",
            "            if value:",
            "                data[attribute] = value",
            "        metadata_node = self.find_first_child_named(node, 'metadata')",
            "        if metadata_node is not None:",
            "            metadata = self.metadata_deserializer.extract_metadata(",
            "                                                        metadata_node)",
            "            data['metadata'] = metadata",
            "        return data",
            "",
            "",
            "class CreateDeserializer(CommonDeserializer):",
            "    \"\"\"Deserializer to handle xml-formatted server create requests.",
            "",
            "    Handles standard server attributes as well as optional metadata",
            "    and personality attributes",
            "    \"\"\"",
            "",
            "    def default(self, string):",
            "        \"\"\"Deserialize an xml-formatted server create request.\"\"\"",
            "        dom = xmlutil.safe_minidom_parse_string(string)",
            "        server = self._extract_server(dom)",
            "        return {'body': {'server': server}}",
            "",
            "",
            "class Controller(wsgi.Controller):",
            "    \"\"\"The Server API base controller class for the OpenStack API.\"\"\"",
            "",
            "    _view_builder_class = views_servers.ViewBuilder",
            "",
            "    @staticmethod",
            "    def _add_location(robj):",
            "        # Just in case...",
            "        if 'server' not in robj.obj:",
            "            return robj",
            "",
            "        link = filter(lambda l: l['rel'] == 'self',",
            "                      robj.obj['server']['links'])",
            "        if link:",
            "            robj['Location'] = link[0]['href'].encode('utf-8')",
            "",
            "        # Convenience return",
            "        return robj",
            "",
            "    def __init__(self, ext_mgr=None, **kwargs):",
            "        super(Controller, self).__init__(**kwargs)",
            "        self.compute_api = compute.API()",
            "        self.ext_mgr = ext_mgr",
            "        self.neutron_attempted = False",
            "",
            "    @wsgi.serializers(xml=MinimalServersTemplate)",
            "    def index(self, req):",
            "        \"\"\"Returns a list of server names and ids for a given user.\"\"\"",
            "        try:",
            "            servers = self._get_servers(req, is_detail=False)",
            "        except exception.Invalid as err:",
            "            raise exc.HTTPBadRequest(explanation=err.format_message())",
            "        return servers",
            "",
            "    @wsgi.serializers(xml=ServersTemplate)",
            "    def detail(self, req):",
            "        \"\"\"Returns a list of server details for a given user.\"\"\"",
            "        try:",
            "            servers = self._get_servers(req, is_detail=True)",
            "        except exception.Invalid as err:",
            "            raise exc.HTTPBadRequest(explanation=err.format_message())",
            "        return servers",
            "",
            "    def _get_servers(self, req, is_detail):",
            "        \"\"\"Returns a list of servers, based on any search options specified.\"\"\"",
            "",
            "        search_opts = {}",
            "        search_opts.update(req.GET)",
            "",
            "        context = req.environ['nova.context']",
            "        remove_invalid_options(context, search_opts,",
            "                self._get_server_search_options())",
            "",
            "        # Verify search by 'status' contains a valid status.",
            "        # Convert it to filter by vm_state for compute_api.",
            "        status = search_opts.pop('status', None)",
            "        if status is not None:",
            "            state = common.vm_state_from_status(status)",
            "            if state is None:",
            "                return {'servers': []}",
            "            search_opts['vm_state'] = state",
            "",
            "        if 'changes-since' in search_opts:",
            "            try:",
            "                parsed = timeutils.parse_isotime(search_opts['changes-since'])",
            "            except ValueError:",
            "                msg = _('Invalid changes-since value')",
            "                raise exc.HTTPBadRequest(explanation=msg)",
            "            search_opts['changes-since'] = parsed",
            "",
            "        # By default, compute's get_all() will return deleted instances.",
            "        # If an admin hasn't specified a 'deleted' search option, we need",
            "        # to filter out deleted instances by setting the filter ourselves.",
            "        # ... Unless 'changes-since' is specified, because 'changes-since'",
            "        # should return recently deleted images according to the API spec.",
            "",
            "        if 'deleted' not in search_opts:",
            "            if 'changes-since' not in search_opts:",
            "                # No 'changes-since', so we only want non-deleted servers",
            "                search_opts['deleted'] = False",
            "",
            "        if search_opts.get(\"vm_state\") == \"deleted\":",
            "            if context.is_admin:",
            "                search_opts['deleted'] = True",
            "            else:",
            "                msg = _(\"Only administrators may list deleted instances\")",
            "                raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        if 'all_tenants' not in search_opts:",
            "            if context.project_id:",
            "                search_opts['project_id'] = context.project_id",
            "            else:",
            "                search_opts['user_id'] = context.user_id",
            "",
            "        limit, marker = common.get_limit_and_marker(req)",
            "        try:",
            "            instance_list = self.compute_api.get_all(context,",
            "                                                     search_opts=search_opts,",
            "                                                     limit=limit,",
            "                                                     marker=marker,",
            "                                                     want_objects=True)",
            "        except exception.MarkerNotFound:",
            "            msg = _('marker [%s] not found') % marker",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.FlavorNotFound:",
            "            log_msg = _(\"Flavor '%s' could not be found \")",
            "            LOG.debug(log_msg, search_opts['flavor'])",
            "            instance_list = []",
            "",
            "        if is_detail:",
            "            instance_list.fill_faults()",
            "            response = self._view_builder.detail(req, instance_list)",
            "        else:",
            "            response = self._view_builder.index(req, instance_list)",
            "        req.cache_db_instances(instance_list)",
            "        return response",
            "",
            "    def _get_server(self, context, req, instance_uuid):",
            "        \"\"\"Utility function for looking up an instance by uuid.\"\"\"",
            "        try:",
            "            instance = self.compute_api.get(context, instance_uuid,",
            "                                            want_objects=True)",
            "        except exception.NotFound:",
            "            msg = _(\"Instance could not be found\")",
            "            raise exc.HTTPNotFound(explanation=msg)",
            "        req.cache_db_instance(instance)",
            "        return instance",
            "",
            "    def _check_string_length(self, value, name, max_length=None):",
            "        try:",
            "            if isinstance(value, basestring):",
            "                value = value.strip()",
            "            utils.check_string_length(value, name, min_length=1,",
            "                                      max_length=max_length)",
            "        except exception.InvalidInput as e:",
            "            raise exc.HTTPBadRequest(explanation=e.format_message())",
            "",
            "    def _validate_server_name(self, value):",
            "        self._check_string_length(value, 'Server name', max_length=255)",
            "",
            "    def _get_injected_files(self, personality):",
            "        \"\"\"Create a list of injected files from the personality attribute.",
            "",
            "        At this time, injected_files must be formatted as a list of",
            "        (file_path, file_content) pairs for compatibility with the",
            "        underlying compute service.",
            "        \"\"\"",
            "        injected_files = []",
            "",
            "        for item in personality:",
            "            try:",
            "                path = item['path']",
            "                contents = item['contents']",
            "            except KeyError as key:",
            "                expl = _('Bad personality format: missing %s') % key",
            "                raise exc.HTTPBadRequest(explanation=expl)",
            "            except TypeError:",
            "                expl = _('Bad personality format')",
            "                raise exc.HTTPBadRequest(explanation=expl)",
            "            if self._decode_base64(contents) is None:",
            "                expl = _('Personality content for %s cannot be decoded') % path",
            "                raise exc.HTTPBadRequest(explanation=expl)",
            "            injected_files.append((path, contents))",
            "        return injected_files",
            "",
            "    def _is_neutron_v2(self):",
            "        # NOTE(dprince): neutronclient is not a requirement",
            "        if self.neutron_attempted:",
            "            return self.have_neutron",
            "",
            "        try:",
            "            # compatibility with Folsom/Grizzly configs",
            "            cls_name = CONF.network_api_class",
            "            if cls_name == 'nova.network.quantumv2.api.API':",
            "                cls_name = 'nova.network.neutronv2.api.API'",
            "            self.neutron_attempted = True",
            "",
            "            from nova.network.neutronv2 import api as neutron_api",
            "            self.have_neutron = issubclass(",
            "                importutils.import_class(cls_name),",
            "                neutron_api.API)",
            "        except ImportError:",
            "            self.have_neutron = False",
            "",
            "        return self.have_neutron",
            "",
            "    def _get_requested_networks(self, requested_networks):",
            "        \"\"\"Create a list of requested networks from the networks attribute.\"\"\"",
            "        networks = []",
            "        for network in requested_networks:",
            "            try:",
            "                port_id = network.get('port', None)",
            "                if port_id:",
            "                    network_uuid = None",
            "                    if not self._is_neutron_v2():",
            "                        # port parameter is only for neutron v2.0",
            "                        msg = _(\"Unknown argment : port\")",
            "                        raise exc.HTTPBadRequest(explanation=msg)",
            "                    if not uuidutils.is_uuid_like(port_id):",
            "                        msg = _(\"Bad port format: port uuid is \"",
            "                                \"not in proper format \"",
            "                                \"(%s)\") % port_id",
            "                        raise exc.HTTPBadRequest(explanation=msg)",
            "                else:",
            "                    network_uuid = network['uuid']",
            "",
            "                if not port_id and not uuidutils.is_uuid_like(network_uuid):",
            "                    br_uuid = network_uuid.split('-', 1)[-1]",
            "                    if not uuidutils.is_uuid_like(br_uuid):",
            "                        msg = _(\"Bad networks format: network uuid is \"",
            "                                \"not in proper format \"",
            "                                \"(%s)\") % network_uuid",
            "                        raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "                #fixed IP address is optional",
            "                #if the fixed IP address is not provided then",
            "                #it will use one of the available IP address from the network",
            "                address = network.get('fixed_ip', None)",
            "                if address is not None and not utils.is_valid_ipv4(address):",
            "                    msg = _(\"Invalid fixed IP address (%s)\") % address",
            "                    raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "                # For neutronv2, requestd_networks",
            "                # should be tuple of (network_uuid, fixed_ip, port_id)",
            "                if self._is_neutron_v2():",
            "                    networks.append((network_uuid, address, port_id))",
            "                else:",
            "                    # check if the network id is already present in the list,",
            "                    # we don't want duplicate networks to be passed",
            "                    # at the boot time",
            "                    for id, ip in networks:",
            "                        if id == network_uuid:",
            "                            expl = (_(\"Duplicate networks\"",
            "                                      \" (%s) are not allowed\") %",
            "                                    network_uuid)",
            "                            raise exc.HTTPBadRequest(explanation=expl)",
            "                    networks.append((network_uuid, address))",
            "            except KeyError as key:",
            "                expl = _('Bad network format: missing %s') % key",
            "                raise exc.HTTPBadRequest(explanation=expl)",
            "            except TypeError:",
            "                expl = _('Bad networks format')",
            "                raise exc.HTTPBadRequest(explanation=expl)",
            "",
            "        return networks",
            "",
            "    # NOTE(vish): Without this regex, b64decode will happily",
            "    #             ignore illegal bytes in the base64 encoded",
            "    #             data.",
            "    B64_REGEX = re.compile('^(?:[A-Za-z0-9+\\/]{4})*'",
            "                           '(?:[A-Za-z0-9+\\/]{2}=='",
            "                           '|[A-Za-z0-9+\\/]{3}=)?$')",
            "",
            "    def _decode_base64(self, data):",
            "        data = re.sub(r'\\s', '', data)",
            "        if not self.B64_REGEX.match(data):",
            "            return None",
            "        try:",
            "            return base64.b64decode(data)",
            "        except TypeError:",
            "            return None",
            "",
            "    def _validate_user_data(self, user_data):",
            "        \"\"\"Check if the user_data is encoded properly.\"\"\"",
            "        if not user_data:",
            "            return",
            "        if self._decode_base64(user_data) is None:",
            "            expl = _('Userdata content cannot be decoded')",
            "            raise exc.HTTPBadRequest(explanation=expl)",
            "",
            "    def _validate_access_ipv4(self, address):",
            "        if not utils.is_valid_ipv4(address):",
            "            expl = _('accessIPv4 is not proper IPv4 format')",
            "            raise exc.HTTPBadRequest(explanation=expl)",
            "",
            "    def _validate_access_ipv6(self, address):",
            "        if not utils.is_valid_ipv6(address):",
            "            expl = _('accessIPv6 is not proper IPv6 format')",
            "            raise exc.HTTPBadRequest(explanation=expl)",
            "",
            "    @wsgi.serializers(xml=ServerTemplate)",
            "    def show(self, req, id):",
            "        \"\"\"Returns server details by server id.\"\"\"",
            "        try:",
            "            context = req.environ['nova.context']",
            "            instance = self.compute_api.get(context, id,",
            "                                            want_objects=True)",
            "            req.cache_db_instance(instance)",
            "            return self._view_builder.show(req, instance)",
            "        except exception.NotFound:",
            "            msg = _(\"Instance could not be found\")",
            "            raise exc.HTTPNotFound(explanation=msg)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=CreateDeserializer)",
            "    def create(self, req, body):",
            "        \"\"\"Creates a new server for a given user.\"\"\"",
            "        if not self.is_valid_body(body, 'server'):",
            "            raise exc.HTTPUnprocessableEntity()",
            "",
            "        context = req.environ['nova.context']",
            "        server_dict = body['server']",
            "        password = self._get_server_admin_password(server_dict)",
            "",
            "        if 'name' not in server_dict:",
            "            msg = _(\"Server name is not defined\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        name = server_dict['name']",
            "        self._validate_server_name(name)",
            "        name = name.strip()",
            "",
            "        image_uuid = self._image_from_req_data(body)",
            "",
            "        personality = server_dict.get('personality')",
            "        config_drive = None",
            "        if self.ext_mgr.is_loaded('os-config-drive'):",
            "            config_drive = server_dict.get('config_drive')",
            "",
            "        injected_files = []",
            "        if personality:",
            "            injected_files = self._get_injected_files(personality)",
            "",
            "        sg_names = []",
            "        if self.ext_mgr.is_loaded('os-security-groups'):",
            "            security_groups = server_dict.get('security_groups')",
            "            if security_groups is not None:",
            "                sg_names = [sg['name'] for sg in security_groups",
            "                            if sg.get('name')]",
            "        if not sg_names:",
            "            sg_names.append('default')",
            "",
            "        sg_names = list(set(sg_names))",
            "",
            "        requested_networks = None",
            "        if (self.ext_mgr.is_loaded('os-networks')",
            "                or self._is_neutron_v2()):",
            "            requested_networks = server_dict.get('networks')",
            "",
            "        if requested_networks is not None:",
            "            if not isinstance(requested_networks, list):",
            "                expl = _('Bad networks format')",
            "                raise exc.HTTPBadRequest(explanation=expl)",
            "            requested_networks = self._get_requested_networks(",
            "                requested_networks)",
            "",
            "        (access_ip_v4, ) = server_dict.get('accessIPv4'),",
            "        if access_ip_v4 is not None:",
            "            self._validate_access_ipv4(access_ip_v4)",
            "",
            "        (access_ip_v6, ) = server_dict.get('accessIPv6'),",
            "        if access_ip_v6 is not None:",
            "            self._validate_access_ipv6(access_ip_v6)",
            "",
            "        try:",
            "            flavor_id = self._flavor_id_from_req_data(body)",
            "        except ValueError as error:",
            "            msg = _(\"Invalid flavorRef provided.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        # optional openstack extensions:",
            "        key_name = None",
            "        if self.ext_mgr.is_loaded('os-keypairs'):",
            "            key_name = server_dict.get('key_name')",
            "",
            "        user_data = None",
            "        if self.ext_mgr.is_loaded('os-user-data'):",
            "            user_data = server_dict.get('user_data')",
            "        self._validate_user_data(user_data)",
            "",
            "        availability_zone = None",
            "        if self.ext_mgr.is_loaded('os-availability-zone'):",
            "            availability_zone = server_dict.get('availability_zone')",
            "",
            "        block_device_mapping = None",
            "        block_device_mapping_v2 = None",
            "        legacy_bdm = True",
            "        if self.ext_mgr.is_loaded('os-volumes'):",
            "            block_device_mapping = server_dict.get('block_device_mapping', [])",
            "            for bdm in block_device_mapping:",
            "                try:",
            "                    block_device.validate_device_name(bdm.get(\"device_name\"))",
            "                    block_device.validate_and_default_volume_size(bdm)",
            "                except exception.InvalidBDMFormat as e:",
            "                    raise exc.HTTPBadRequest(explanation=e.format_message())",
            "",
            "                if 'delete_on_termination' in bdm:",
            "                    bdm['delete_on_termination'] = strutils.bool_from_string(",
            "                        bdm['delete_on_termination'])",
            "",
            "            if self.ext_mgr.is_loaded('os-block-device-mapping-v2-boot'):",
            "                # Consider the new data format for block device mapping",
            "                block_device_mapping_v2 = server_dict.get(",
            "                    'block_device_mapping_v2', [])",
            "                # NOTE (ndipanov):  Disable usage of both legacy and new",
            "                #                   block device format in the same request",
            "                if block_device_mapping and block_device_mapping_v2:",
            "                    expl = _('Using different block_device_mapping syntaxes '",
            "                             'is not allowed in the same request.')",
            "                    raise exc.HTTPBadRequest(explanation=expl)",
            "",
            "                # Assume legacy format",
            "                legacy_bdm = not bool(block_device_mapping_v2)",
            "",
            "                # NOTE (ndipanov) Don't allow empty device_name values",
            "                #                 for now until we can handle it on the",
            "                #                 compute side.",
            "                if any('device_name' not in bdm",
            "                       for bdm in block_device_mapping_v2):",
            "                    expl = _('Missing device_name in some block devices.')",
            "                    raise exc.HTTPBadRequest(explanation=expl)",
            "",
            "                try:",
            "                    block_device_mapping_v2 = [",
            "                        block_device.BlockDeviceDict.from_api(bdm_dict)",
            "                        for bdm_dict in block_device_mapping_v2]",
            "                except exception.InvalidBDMFormat as e:",
            "                    raise exc.HTTPBadRequest(explanation=e.format_message())",
            "",
            "        block_device_mapping = (block_device_mapping or",
            "                                block_device_mapping_v2)",
            "",
            "        ret_resv_id = False",
            "        # min_count and max_count are optional.  If they exist, they may come",
            "        # in as strings.  Verify that they are valid integers and > 0.",
            "        # Also, we want to default 'min_count' to 1, and default",
            "        # 'max_count' to be 'min_count'.",
            "        min_count = 1",
            "        max_count = 1",
            "        if self.ext_mgr.is_loaded('os-multiple-create'):",
            "            ret_resv_id = server_dict.get('return_reservation_id', False)",
            "            min_count = server_dict.get('min_count', 1)",
            "            max_count = server_dict.get('max_count', min_count)",
            "",
            "        try:",
            "            min_count = utils.validate_integer(",
            "                min_count, \"min_count\", min_value=1)",
            "            max_count = utils.validate_integer(",
            "                max_count, \"max_count\", min_value=1)",
            "        except exception.InvalidInput as e:",
            "            raise exc.HTTPBadRequest(explanation=e.format_message())",
            "",
            "        if min_count > max_count:",
            "            msg = _('min_count must be <= max_count')",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        auto_disk_config = False",
            "        if self.ext_mgr.is_loaded('OS-DCF'):",
            "            auto_disk_config = server_dict.get('auto_disk_config')",
            "",
            "        scheduler_hints = {}",
            "        if self.ext_mgr.is_loaded('OS-SCH-HNT'):",
            "            scheduler_hints = server_dict.get('scheduler_hints', {})",
            "",
            "        try:",
            "            _get_inst_type = flavors.get_flavor_by_flavor_id",
            "            inst_type = _get_inst_type(flavor_id, read_deleted=\"no\")",
            "",
            "            (instances, resv_id) = self.compute_api.create(context,",
            "                            inst_type,",
            "                            image_uuid,",
            "                            display_name=name,",
            "                            display_description=name,",
            "                            key_name=key_name,",
            "                            metadata=server_dict.get('metadata', {}),",
            "                            access_ip_v4=access_ip_v4,",
            "                            access_ip_v6=access_ip_v6,",
            "                            injected_files=injected_files,",
            "                            admin_password=password,",
            "                            min_count=min_count,",
            "                            max_count=max_count,",
            "                            requested_networks=requested_networks,",
            "                            security_group=sg_names,",
            "                            user_data=user_data,",
            "                            availability_zone=availability_zone,",
            "                            config_drive=config_drive,",
            "                            block_device_mapping=block_device_mapping,",
            "                            auto_disk_config=auto_disk_config,",
            "                            scheduler_hints=scheduler_hints,",
            "                            legacy_bdm=legacy_bdm)",
            "        except exception.QuotaError as error:",
            "            raise exc.HTTPRequestEntityTooLarge(",
            "                explanation=error.format_message(),",
            "                headers={'Retry-After': 0})",
            "        except exception.InvalidMetadataSize as error:",
            "            raise exc.HTTPRequestEntityTooLarge(",
            "                explanation=error.format_message())",
            "        except exception.ImageNotFound as error:",
            "            msg = _(\"Can not find requested image\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.FlavorNotFound as error:",
            "            msg = _(\"Invalid flavorRef provided.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.KeypairNotFound as error:",
            "            msg = _(\"Invalid key_name provided.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.ConfigDriveInvalidValue:",
            "            msg = _(\"Invalid config_drive provided.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except rpc_common.RemoteError as err:",
            "            msg = \"%(err_type)s: %(err_msg)s\" % {'err_type': err.exc_type,",
            "                                                 'err_msg': err.value}",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except UnicodeDecodeError as error:",
            "            msg = \"UnicodeError: %s\" % unicode(error)",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except (exception.ImageNotActive,",
            "                exception.InstanceTypeDiskTooSmall,",
            "                exception.InstanceTypeMemoryTooSmall,",
            "                exception.InstanceTypeNotFound,",
            "                exception.InvalidMetadata,",
            "                exception.InvalidRequest,",
            "                exception.PortNotFound,",
            "                exception.SecurityGroupNotFound) as error:",
            "            raise exc.HTTPBadRequest(explanation=error.format_message())",
            "        except exception.PortInUse as error:",
            "            raise exc.HTTPConflict(explanation=error.format_message())",
            "",
            "        # If the caller wanted a reservation_id, return it",
            "        if ret_resv_id:",
            "            return wsgi.ResponseObject({'reservation_id': resv_id},",
            "                                       xml=ServerMultipleCreateTemplate)",
            "",
            "        req.cache_db_instances(instances)",
            "        server = self._view_builder.create(req, instances[0])",
            "",
            "        if CONF.enable_instance_password:",
            "            server['server']['adminPass'] = password",
            "",
            "        robj = wsgi.ResponseObject(server)",
            "",
            "        return self._add_location(robj)",
            "",
            "    def _delete(self, context, req, instance_uuid):",
            "        instance = self._get_server(context, req, instance_uuid)",
            "        if CONF.reclaim_instance_interval:",
            "            self.compute_api.soft_delete(context, instance)",
            "        else:",
            "            self.compute_api.delete(context, instance)",
            "",
            "    @wsgi.serializers(xml=ServerTemplate)",
            "    def update(self, req, id, body):",
            "        \"\"\"Update server then pass on to version-specific controller.\"\"\"",
            "        if not self.is_valid_body(body, 'server'):",
            "            raise exc.HTTPUnprocessableEntity()",
            "",
            "        ctxt = req.environ['nova.context']",
            "        update_dict = {}",
            "",
            "        if 'name' in body['server']:",
            "            name = body['server']['name']",
            "            self._validate_server_name(name)",
            "            update_dict['display_name'] = name.strip()",
            "",
            "        if 'accessIPv4' in body['server']:",
            "            access_ipv4 = body['server']['accessIPv4']",
            "            if access_ipv4:",
            "                self._validate_access_ipv4(access_ipv4)",
            "            update_dict['access_ip_v4'] = (",
            "                access_ipv4 and access_ipv4.strip() or None)",
            "",
            "        if 'accessIPv6' in body['server']:",
            "            access_ipv6 = body['server']['accessIPv6']",
            "            if access_ipv6:",
            "                self._validate_access_ipv6(access_ipv6)",
            "            update_dict['access_ip_v6'] = (",
            "                access_ipv6 and access_ipv6.strip() or None)",
            "",
            "        if 'auto_disk_config' in body['server']:",
            "            auto_disk_config = strutils.bool_from_string(",
            "                    body['server']['auto_disk_config'])",
            "            update_dict['auto_disk_config'] = auto_disk_config",
            "",
            "        if 'hostId' in body['server']:",
            "            msg = _(\"HostId cannot be updated.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        if 'personality' in body['server']:",
            "            msg = _(\"Personality cannot be updated.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        try:",
            "            instance = self.compute_api.get(ctxt, id,",
            "                                            want_objects=True)",
            "            req.cache_db_instance(instance)",
            "            policy.enforce(ctxt, 'compute:update', instance)",
            "            instance.update(update_dict)",
            "            instance.save()",
            "        except exception.NotFound:",
            "            msg = _(\"Instance could not be found\")",
            "            raise exc.HTTPNotFound(explanation=msg)",
            "",
            "        return self._view_builder.show(req, instance)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('confirmResize')",
            "    def _action_confirm_resize(self, req, id, body):",
            "        context = req.environ['nova.context']",
            "        instance = self._get_server(context, req, id)",
            "        try:",
            "            self.compute_api.confirm_resize(context, instance)",
            "        except exception.MigrationNotFound:",
            "            msg = _(\"Instance has not been resized.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'confirmResize')",
            "        return exc.HTTPNoContent()",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('revertResize')",
            "    def _action_revert_resize(self, req, id, body):",
            "        context = req.environ['nova.context']",
            "        instance = self._get_server(context, req, id)",
            "        try:",
            "            self.compute_api.revert_resize(context, instance)",
            "        except exception.MigrationNotFound:",
            "            msg = _(\"Instance has not been resized.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.InstanceTypeNotFound:",
            "            msg = _(\"Flavor used by the instance could not be found.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'revertResize')",
            "        return webob.Response(status_int=202)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('reboot')",
            "    def _action_reboot(self, req, id, body):",
            "        if 'reboot' in body and 'type' in body['reboot']:",
            "            valid_reboot_types = ['HARD', 'SOFT']",
            "            reboot_type = body['reboot']['type'].upper()",
            "            if not valid_reboot_types.count(reboot_type):",
            "                msg = _(\"Argument 'type' for reboot is not HARD or SOFT\")",
            "                LOG.error(msg)",
            "                raise exc.HTTPBadRequest(explanation=msg)",
            "        else:",
            "            msg = _(\"Missing argument 'type' for reboot\")",
            "            LOG.error(msg)",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        context = req.environ['nova.context']",
            "        instance = self._get_server(context, req, id)",
            "",
            "        try:",
            "            self.compute_api.reboot(context, instance, reboot_type)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'reboot')",
            "        return webob.Response(status_int=202)",
            "",
            "    def _resize(self, req, instance_id, flavor_id, **kwargs):",
            "        \"\"\"Begin the resize process with given instance/flavor.\"\"\"",
            "        context = req.environ[\"nova.context\"]",
            "        instance = self._get_server(context, req, instance_id)",
            "",
            "        try:",
            "            self.compute_api.resize(context, instance, flavor_id, **kwargs)",
            "        except exception.FlavorNotFound:",
            "            msg = _(\"Unable to locate requested flavor.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.CannotResizeToSameFlavor:",
            "            msg = _(\"Resize requires a flavor change.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'resize')",
            "        except exception.ImageNotAuthorized:",
            "            msg = _(\"You are not authorized to access the image \"",
            "                    \"the instance was started with.\")",
            "            raise exc.HTTPUnauthorized(explanation=msg)",
            "        except exception.ImageNotFound:",
            "            msg = _(\"Image that the instance was started \"",
            "                    \"with could not be found.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.Invalid:",
            "            msg = _(\"Invalid instance image.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        return webob.Response(status_int=202)",
            "",
            "    @wsgi.response(204)",
            "    def delete(self, req, id):",
            "        \"\"\"Destroys a server.\"\"\"",
            "        try:",
            "            self._delete(req.environ['nova.context'], req, id)",
            "        except exception.NotFound:",
            "            msg = _(\"Instance could not be found\")",
            "            raise exc.HTTPNotFound(explanation=msg)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'delete')",
            "",
            "    def _image_ref_from_req_data(self, data):",
            "        try:",
            "            return unicode(data['server']['imageRef'])",
            "        except (TypeError, KeyError):",
            "            msg = _(\"Missing imageRef attribute\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "    def _image_uuid_from_href(self, image_href):",
            "        # If the image href was generated by nova api, strip image_href",
            "        # down to an id and use the default glance connection params",
            "        image_uuid = image_href.split('/').pop()",
            "",
            "        if not uuidutils.is_uuid_like(image_uuid):",
            "            msg = _(\"Invalid imageRef provided.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        return image_uuid",
            "",
            "    def _image_from_req_data(self, data):",
            "        \"\"\"",
            "        Get image data from the request or raise appropriate",
            "        exceptions",
            "",
            "        If no image is supplied - checks to see if there is",
            "        block devices set and proper extesions loaded.",
            "        \"\"\"",
            "        image_ref = data['server'].get('imageRef')",
            "        bdm = data['server'].get('block_device_mapping')",
            "        bdm_v2 = data['server'].get('block_device_mapping_v2')",
            "",
            "        if (not image_ref and (",
            "                (bdm and self.ext_mgr.is_loaded('os-volumes')) or",
            "                (bdm_v2 and",
            "                 self.ext_mgr.is_loaded('os-block-device-mapping-v2-boot')))):",
            "            return ''",
            "        else:",
            "            image_href = self._image_ref_from_req_data(data)",
            "            image_uuid = self._image_uuid_from_href(image_href)",
            "            return image_uuid",
            "",
            "    def _flavor_id_from_req_data(self, data):",
            "        try:",
            "            flavor_ref = data['server']['flavorRef']",
            "        except (TypeError, KeyError):",
            "            msg = _(\"Missing flavorRef attribute\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        return common.get_id_from_href(flavor_ref)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('changePassword')",
            "    def _action_change_password(self, req, id, body):",
            "        context = req.environ['nova.context']",
            "        if (not 'changePassword' in body",
            "                or 'adminPass' not in body['changePassword']):",
            "            msg = _(\"No adminPass was specified\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        password = body['changePassword']['adminPass']",
            "        if not isinstance(password, basestring):",
            "            msg = _(\"Invalid adminPass\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        server = self._get_server(context, req, id)",
            "        try:",
            "            self.compute_api.set_admin_password(context, server, password)",
            "        except NotImplementedError:",
            "            msg = _(\"Unable to set password on instance\")",
            "            raise exc.HTTPNotImplemented(explanation=msg)",
            "        return webob.Response(status_int=202)",
            "",
            "    def _validate_metadata(self, metadata):",
            "        \"\"\"Ensure that we can work with the metadata given.\"\"\"",
            "        try:",
            "            metadata.iteritems()",
            "        except AttributeError:",
            "            msg = _(\"Unable to parse metadata key/value pairs.\")",
            "            LOG.debug(msg)",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('resize')",
            "    def _action_resize(self, req, id, body):",
            "        \"\"\"Resizes a given instance to the flavor size requested.\"\"\"",
            "        try:",
            "            flavor_ref = str(body[\"resize\"][\"flavorRef\"])",
            "            if not flavor_ref:",
            "                msg = _(\"Resize request has invalid 'flavorRef' attribute.\")",
            "                raise exc.HTTPBadRequest(explanation=msg)",
            "        except (KeyError, TypeError):",
            "            msg = _(\"Resize requests require 'flavorRef' attribute.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        kwargs = {}",
            "        if 'auto_disk_config' in body['resize']:",
            "            kwargs['auto_disk_config'] = body['resize']['auto_disk_config']",
            "",
            "        return self._resize(req, id, flavor_ref, **kwargs)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('rebuild')",
            "    def _action_rebuild(self, req, id, body):",
            "        \"\"\"Rebuild an instance with the given attributes.\"\"\"",
            "        try:",
            "            body = body['rebuild']",
            "        except (KeyError, TypeError):",
            "            msg = _('Invalid request body')",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        try:",
            "            image_href = body[\"imageRef\"]",
            "        except (KeyError, TypeError):",
            "            msg = _(\"Could not parse imageRef from request.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        image_href = self._image_uuid_from_href(image_href)",
            "",
            "        try:",
            "            password = body['adminPass']",
            "        except (KeyError, TypeError):",
            "            password = utils.generate_password()",
            "",
            "        context = req.environ['nova.context']",
            "        instance = self._get_server(context, req, id)",
            "",
            "        attr_map = {",
            "            'personality': 'files_to_inject',",
            "            'name': 'display_name',",
            "            'accessIPv4': 'access_ip_v4',",
            "            'accessIPv6': 'access_ip_v6',",
            "            'metadata': 'metadata',",
            "            'auto_disk_config': 'auto_disk_config',",
            "        }",
            "",
            "        if 'accessIPv4' in body:",
            "            self._validate_access_ipv4(body['accessIPv4'])",
            "",
            "        if 'accessIPv6' in body:",
            "            self._validate_access_ipv6(body['accessIPv6'])",
            "",
            "        if 'name' in body:",
            "            self._validate_server_name(body['name'])",
            "",
            "        kwargs = {}",
            "",
            "        for request_attribute, instance_attribute in attr_map.items():",
            "            try:",
            "                kwargs[instance_attribute] = body[request_attribute]",
            "            except (KeyError, TypeError):",
            "                pass",
            "",
            "        self._validate_metadata(kwargs.get('metadata', {}))",
            "",
            "        if 'files_to_inject' in kwargs:",
            "            personality = kwargs['files_to_inject']",
            "            kwargs['files_to_inject'] = self._get_injected_files(personality)",
            "",
            "        try:",
            "            self.compute_api.rebuild(context,",
            "                                     instance,",
            "                                     image_href,",
            "                                     password,",
            "                                     **kwargs)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'rebuild')",
            "        except exception.InstanceNotFound:",
            "            msg = _(\"Instance could not be found\")",
            "            raise exc.HTTPNotFound(explanation=msg)",
            "        except exception.InvalidMetadataSize as error:",
            "            raise exc.HTTPRequestEntityTooLarge(",
            "                explanation=error.format_message())",
            "        except exception.ImageNotFound:",
            "            msg = _(\"Cannot find image for rebuild\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except (exception.ImageNotActive,",
            "                exception.InstanceTypeDiskTooSmall,",
            "                exception.InstanceTypeMemoryTooSmall,",
            "                exception.InvalidMetadata) as error:",
            "            raise exc.HTTPBadRequest(explanation=error.format_message())",
            "",
            "        instance = self._get_server(context, req, id)",
            "",
            "        view = self._view_builder.show(req, instance)",
            "",
            "        # Add on the adminPass attribute since the view doesn't do it",
            "        # unless instance passwords are disabled",
            "        if CONF.enable_instance_password:",
            "            view['server']['adminPass'] = password",
            "",
            "        robj = wsgi.ResponseObject(view)",
            "        return self._add_location(robj)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('createImage')",
            "    @common.check_snapshots_enabled",
            "    def _action_create_image(self, req, id, body):",
            "        \"\"\"Snapshot a server instance.\"\"\"",
            "        context = req.environ['nova.context']",
            "        entity = body.get(\"createImage\", {})",
            "",
            "        image_name = entity.get(\"name\")",
            "",
            "        if not image_name:",
            "            msg = _(\"createImage entity requires name attribute\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        props = {}",
            "        metadata = entity.get('metadata', {})",
            "        common.check_img_metadata_properties_quota(context, metadata)",
            "        try:",
            "            props.update(metadata)",
            "        except ValueError:",
            "            msg = _(\"Invalid metadata\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        instance = self._get_server(context, req, id)",
            "",
            "        bdms = self.compute_api.get_instance_bdms(context, instance)",
            "",
            "        try:",
            "            if self.compute_api.is_volume_backed_instance(context, instance,",
            "                                                          bdms):",
            "                img = instance['image_ref']",
            "                if not img:",
            "                    # NOTE(Vincent Hou) The private method",
            "                    # _get_volume_image_metadata only works, when boot",
            "                    # device is set to 'vda'. It needs to be fixed later,",
            "                    # but tentatively we use it here.",
            "                    image_meta = {'properties': self.compute_api.",
            "                                    _get_volume_image_metadata(context, bdms)}",
            "                else:",
            "                    src_image = self.compute_api.image_service.\\",
            "                                                show(context, img)",
            "                    image_meta = dict(src_image)",
            "",
            "                image = self.compute_api.snapshot_volume_backed(",
            "                                                       context,",
            "                                                       instance,",
            "                                                       image_meta,",
            "                                                       image_name,",
            "                                                       extra_properties=props)",
            "            else:",
            "                image = self.compute_api.snapshot(context,",
            "                                                  instance,",
            "                                                  image_name,",
            "                                                  extra_properties=props)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                        'createImage')",
            "        except exception.Invalid as err:",
            "            raise exc.HTTPBadRequest(explanation=err.format_message())",
            "",
            "        # build location of newly-created image entity",
            "        image_id = str(image['id'])",
            "        image_ref = os.path.join(req.application_url,",
            "                                 context.project_id,",
            "                                 'images',",
            "                                 image_id)",
            "",
            "        resp = webob.Response(status_int=202)",
            "        resp.headers['Location'] = image_ref",
            "        return resp",
            "",
            "    def _get_server_admin_password(self, server):",
            "        \"\"\"Determine the admin password for a server on creation.\"\"\"",
            "        try:",
            "            password = server['adminPass']",
            "            self._validate_admin_password(password)",
            "        except KeyError:",
            "            password = utils.generate_password()",
            "        except ValueError:",
            "            raise exc.HTTPBadRequest(explanation=_(\"Invalid adminPass\"))",
            "",
            "        return password",
            "",
            "    def _validate_admin_password(self, password):",
            "        if not isinstance(password, basestring):",
            "            raise ValueError()",
            "",
            "    def _get_server_search_options(self):",
            "        \"\"\"Return server search options allowed by non-admin.\"\"\"",
            "        return ('reservation_id', 'name', 'status', 'image', 'flavor',",
            "                'ip', 'changes-since', 'all_tenants')",
            "",
            "",
            "def create_resource(ext_mgr):",
            "    return wsgi.Resource(Controller(ext_mgr))",
            "",
            "",
            "def remove_invalid_options(context, search_options, allowed_search_options):",
            "    \"\"\"Remove search options that are not valid for non-admin API/context.\"\"\"",
            "    if context.is_admin:",
            "        # Allow all options",
            "        return",
            "    # Otherwise, strip out all unknown options",
            "    unknown_options = [opt for opt in search_options",
            "                        if opt not in allowed_search_options]",
            "    LOG.debug(_(\"Removing options '%s' from query\"),",
            "              \", \".join(unknown_options))",
            "    for opt in unknown_options:",
            "        search_options.pop(opt, None)"
        ],
        "afterPatchFile": [
            "# Copyright 2010 OpenStack Foundation",
            "# Copyright 2011 Piston Cloud Computing, Inc",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import base64",
            "import os",
            "import re",
            "",
            "from oslo.config import cfg",
            "import webob",
            "from webob import exc",
            "",
            "from nova.api.openstack import common",
            "from nova.api.openstack.compute import ips",
            "from nova.api.openstack.compute.views import servers as views_servers",
            "from nova.api.openstack import wsgi",
            "from nova.api.openstack import xmlutil",
            "from nova import block_device",
            "from nova import compute",
            "from nova.compute import flavors",
            "from nova import exception",
            "from nova.openstack.common.gettextutils import _",
            "from nova.openstack.common import importutils",
            "from nova.openstack.common import log as logging",
            "from nova.openstack.common.rpc import common as rpc_common",
            "from nova.openstack.common import strutils",
            "from nova.openstack.common import timeutils",
            "from nova.openstack.common import uuidutils",
            "from nova import policy",
            "from nova import utils",
            "",
            "",
            "server_opts = [",
            "    cfg.BoolOpt('enable_instance_password',",
            "                default=True,",
            "                help='Allows use of instance password during '",
            "                     'server creation'),",
            "]",
            "CONF = cfg.CONF",
            "CONF.register_opts(server_opts)",
            "CONF.import_opt('network_api_class', 'nova.network')",
            "CONF.import_opt('reclaim_instance_interval', 'nova.compute.manager')",
            "",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "def make_fault(elem):",
            "    fault = xmlutil.SubTemplateElement(elem, 'fault', selector='fault')",
            "    fault.set('code')",
            "    fault.set('created')",
            "    msg = xmlutil.SubTemplateElement(fault, 'message')",
            "    msg.text = 'message'",
            "    det = xmlutil.SubTemplateElement(fault, 'details')",
            "    det.text = 'details'",
            "",
            "",
            "def make_server(elem, detailed=False):",
            "    elem.set('name')",
            "    elem.set('id')",
            "",
            "    if detailed:",
            "        elem.set('userId', 'user_id')",
            "        elem.set('tenantId', 'tenant_id')",
            "        elem.set('updated')",
            "        elem.set('created')",
            "        elem.set('hostId')",
            "        elem.set('accessIPv4')",
            "        elem.set('accessIPv6')",
            "        elem.set('status')",
            "        elem.set('progress')",
            "        elem.set('reservation_id')",
            "",
            "        # Attach image node",
            "        image = xmlutil.SubTemplateElement(elem, 'image', selector='image')",
            "        image.set('id')",
            "        xmlutil.make_links(image, 'links')",
            "",
            "        # Attach flavor node",
            "        flavor = xmlutil.SubTemplateElement(elem, 'flavor', selector='flavor')",
            "        flavor.set('id')",
            "        xmlutil.make_links(flavor, 'links')",
            "",
            "        # Attach fault node",
            "        make_fault(elem)",
            "",
            "        # Attach metadata node",
            "        elem.append(common.MetadataTemplate())",
            "",
            "        # Attach addresses node",
            "        elem.append(ips.AddressesTemplate())",
            "",
            "    xmlutil.make_links(elem, 'links')",
            "",
            "",
            "server_nsmap = {None: xmlutil.XMLNS_V11, 'atom': xmlutil.XMLNS_ATOM}",
            "",
            "",
            "class ServerTemplate(xmlutil.TemplateBuilder):",
            "    def construct(self):",
            "        root = xmlutil.TemplateElement('server', selector='server')",
            "        make_server(root, detailed=True)",
            "        return xmlutil.MasterTemplate(root, 1, nsmap=server_nsmap)",
            "",
            "",
            "class MinimalServersTemplate(xmlutil.TemplateBuilder):",
            "    def construct(self):",
            "        root = xmlutil.TemplateElement('servers')",
            "        elem = xmlutil.SubTemplateElement(root, 'server', selector='servers')",
            "        make_server(elem)",
            "        xmlutil.make_links(root, 'servers_links')",
            "        return xmlutil.MasterTemplate(root, 1, nsmap=server_nsmap)",
            "",
            "",
            "class ServersTemplate(xmlutil.TemplateBuilder):",
            "    def construct(self):",
            "        root = xmlutil.TemplateElement('servers')",
            "        elem = xmlutil.SubTemplateElement(root, 'server', selector='servers')",
            "        make_server(elem, detailed=True)",
            "        return xmlutil.MasterTemplate(root, 1, nsmap=server_nsmap)",
            "",
            "",
            "class ServerAdminPassTemplate(xmlutil.TemplateBuilder):",
            "    def construct(self):",
            "        root = xmlutil.TemplateElement('server')",
            "        root.set('adminPass')",
            "        return xmlutil.SlaveTemplate(root, 1, nsmap=server_nsmap)",
            "",
            "",
            "class ServerMultipleCreateTemplate(xmlutil.TemplateBuilder):",
            "    def construct(self):",
            "        root = xmlutil.TemplateElement('server')",
            "        root.set('reservation_id')",
            "        return xmlutil.MasterTemplate(root, 1, nsmap=server_nsmap)",
            "",
            "",
            "def FullServerTemplate():",
            "    master = ServerTemplate()",
            "    master.attach(ServerAdminPassTemplate())",
            "    return master",
            "",
            "",
            "class CommonDeserializer(wsgi.MetadataXMLDeserializer):",
            "    \"\"\"Common deserializer to handle xml-formatted server create requests.",
            "",
            "    Handles standard server attributes as well as optional metadata",
            "    and personality attributes",
            "    \"\"\"",
            "",
            "    metadata_deserializer = common.MetadataXMLDeserializer()",
            "",
            "    def _extract_personality(self, server_node):",
            "        \"\"\"Marshal the personality attribute of a parsed request.\"\"\"",
            "        node = self.find_first_child_named(server_node, \"personality\")",
            "        if node is not None:",
            "            personality = []",
            "            for file_node in self.find_children_named(node, \"file\"):",
            "                item = {}",
            "                if file_node.hasAttribute(\"path\"):",
            "                    item[\"path\"] = file_node.getAttribute(\"path\")",
            "                item[\"contents\"] = self.extract_text(file_node)",
            "                personality.append(item)",
            "            return personality",
            "        else:",
            "            return None",
            "",
            "    def _extract_server(self, node):",
            "        \"\"\"Marshal the server attribute of a parsed request.\"\"\"",
            "        server = {}",
            "        server_node = self.find_first_child_named(node, 'server')",
            "",
            "        attributes = [\"name\", \"imageRef\", \"flavorRef\", \"adminPass\",",
            "                      \"accessIPv4\", \"accessIPv6\", \"key_name\",",
            "                      \"availability_zone\", \"min_count\", \"max_count\"]",
            "        for attr in attributes:",
            "            if server_node.getAttribute(attr):",
            "                server[attr] = server_node.getAttribute(attr)",
            "",
            "        res_id = server_node.getAttribute('return_reservation_id')",
            "        if res_id:",
            "            server['return_reservation_id'] = \\",
            "                    strutils.bool_from_string(res_id)",
            "",
            "        scheduler_hints = self._extract_scheduler_hints(server_node)",
            "        if scheduler_hints:",
            "            server['OS-SCH-HNT:scheduler_hints'] = scheduler_hints",
            "",
            "        metadata_node = self.find_first_child_named(server_node, \"metadata\")",
            "        if metadata_node is not None:",
            "            server[\"metadata\"] = self.extract_metadata(metadata_node)",
            "",
            "        user_data_node = self.find_first_child_named(server_node, \"user_data\")",
            "        if user_data_node is not None:",
            "            server[\"user_data\"] = self.extract_text(user_data_node)",
            "",
            "        personality = self._extract_personality(server_node)",
            "        if personality is not None:",
            "            server[\"personality\"] = personality",
            "",
            "        networks = self._extract_networks(server_node)",
            "        if networks is not None:",
            "            server[\"networks\"] = networks",
            "",
            "        security_groups = self._extract_security_groups(server_node)",
            "        if security_groups is not None:",
            "            server[\"security_groups\"] = security_groups",
            "",
            "        # NOTE(vish): this is not namespaced in json, so leave it without a",
            "        #             namespace for now",
            "        block_device_mapping = self._extract_block_device_mapping(server_node)",
            "        if block_device_mapping is not None:",
            "            server[\"block_device_mapping\"] = block_device_mapping",
            "",
            "        block_device_mapping_v2 = self._extract_block_device_mapping_v2(",
            "            server_node)",
            "        if block_device_mapping_v2 is not None:",
            "            server[\"block_device_mapping_v2\"] = block_device_mapping_v2",
            "",
            "        # NOTE(vish): Support this incorrect version because it was in the code",
            "        #             base for a while and we don't want to accidentally break",
            "        #             anyone that might be using it.",
            "        auto_disk_config = server_node.getAttribute('auto_disk_config')",
            "        if auto_disk_config:",
            "            server['OS-DCF:diskConfig'] = auto_disk_config",
            "",
            "        auto_disk_config = server_node.getAttribute('OS-DCF:diskConfig')",
            "        if auto_disk_config:",
            "            server['OS-DCF:diskConfig'] = auto_disk_config",
            "",
            "        config_drive = server_node.getAttribute('config_drive')",
            "        if config_drive:",
            "            server['config_drive'] = config_drive",
            "",
            "        return server",
            "",
            "    def _extract_block_device_mapping(self, server_node):",
            "        \"\"\"Marshal the block_device_mapping node of a parsed request.\"\"\"",
            "        node = self.find_first_child_named(server_node, \"block_device_mapping\")",
            "        if node:",
            "            block_device_mapping = []",
            "            for child in self.extract_elements(node):",
            "                if child.nodeName != \"mapping\":",
            "                    continue",
            "                mapping = {}",
            "                attributes = [\"volume_id\", \"snapshot_id\", \"device_name\",",
            "                              \"virtual_name\", \"volume_size\"]",
            "                for attr in attributes:",
            "                    value = child.getAttribute(attr)",
            "                    if value:",
            "                        mapping[attr] = value",
            "                attributes = [\"delete_on_termination\", \"no_device\"]",
            "                for attr in attributes:",
            "                    value = child.getAttribute(attr)",
            "                    if value:",
            "                        mapping[attr] = strutils.bool_from_string(value)",
            "                block_device_mapping.append(mapping)",
            "            return block_device_mapping",
            "        else:",
            "            return None",
            "",
            "    def _extract_block_device_mapping_v2(self, server_node):",
            "        \"\"\"Marshal the new block_device_mappings.\"\"\"",
            "        node = self.find_first_child_named(server_node,",
            "                                           \"block_device_mapping_v2\")",
            "        if node:",
            "            block_device_mapping = []",
            "            for child in self.extract_elements(node):",
            "                if child.nodeName != \"mapping\":",
            "                    continue",
            "                block_device_mapping.append(",
            "                    dict((attr, child.getAttribute(attr))",
            "                        for attr in block_device.bdm_new_api_fields",
            "                        if child.getAttribute(attr)))",
            "            return block_device_mapping",
            "",
            "    def _extract_scheduler_hints(self, server_node):",
            "        \"\"\"Marshal the scheduler hints attribute of a parsed request.\"\"\"",
            "        node = self.find_first_child_named_in_namespace(server_node,",
            "            \"http://docs.openstack.org/compute/ext/scheduler-hints/api/v2\",",
            "            \"scheduler_hints\")",
            "        if node:",
            "            scheduler_hints = {}",
            "            for child in self.extract_elements(node):",
            "                scheduler_hints.setdefault(child.nodeName, [])",
            "                value = self.extract_text(child).strip()",
            "                scheduler_hints[child.nodeName].append(value)",
            "            return scheduler_hints",
            "        else:",
            "            return None",
            "",
            "    def _extract_networks(self, server_node):",
            "        \"\"\"Marshal the networks attribute of a parsed request.\"\"\"",
            "        node = self.find_first_child_named(server_node, \"networks\")",
            "        if node is not None:",
            "            networks = []",
            "            for network_node in self.find_children_named(node,",
            "                                                         \"network\"):",
            "                item = {}",
            "                if network_node.hasAttribute(\"uuid\"):",
            "                    item[\"uuid\"] = network_node.getAttribute(\"uuid\")",
            "                if network_node.hasAttribute(\"fixed_ip\"):",
            "                    item[\"fixed_ip\"] = network_node.getAttribute(\"fixed_ip\")",
            "                if network_node.hasAttribute(\"port\"):",
            "                    item[\"port\"] = network_node.getAttribute(\"port\")",
            "                networks.append(item)",
            "            return networks",
            "        else:",
            "            return None",
            "",
            "    def _extract_security_groups(self, server_node):",
            "        \"\"\"Marshal the security_groups attribute of a parsed request.\"\"\"",
            "        node = self.find_first_child_named(server_node, \"security_groups\")",
            "        if node is not None:",
            "            security_groups = []",
            "            for sg_node in self.find_children_named(node, \"security_group\"):",
            "                item = {}",
            "                name = self.find_attribute_or_element(sg_node, 'name')",
            "                if name:",
            "                    item[\"name\"] = name",
            "                    security_groups.append(item)",
            "            return security_groups",
            "        else:",
            "            return None",
            "",
            "",
            "class ActionDeserializer(CommonDeserializer):",
            "    \"\"\"Deserializer to handle xml-formatted server action requests.",
            "",
            "    Handles standard server attributes as well as optional metadata",
            "    and personality attributes",
            "    \"\"\"",
            "",
            "    def default(self, string):",
            "        dom = xmlutil.safe_minidom_parse_string(string)",
            "        action_node = dom.childNodes[0]",
            "        action_name = action_node.tagName",
            "",
            "        action_deserializer = {",
            "            'createImage': self._action_create_image,",
            "            'changePassword': self._action_change_password,",
            "            'reboot': self._action_reboot,",
            "            'rebuild': self._action_rebuild,",
            "            'resize': self._action_resize,",
            "            'confirmResize': self._action_confirm_resize,",
            "            'revertResize': self._action_revert_resize,",
            "        }.get(action_name, super(ActionDeserializer, self).default)",
            "",
            "        action_data = action_deserializer(action_node)",
            "",
            "        return {'body': {action_name: action_data}}",
            "",
            "    def _action_create_image(self, node):",
            "        return self._deserialize_image_action(node, ('name',))",
            "",
            "    def _action_change_password(self, node):",
            "        if not node.hasAttribute(\"adminPass\"):",
            "            raise AttributeError(\"No adminPass was specified in request\")",
            "        return {\"adminPass\": node.getAttribute(\"adminPass\")}",
            "",
            "    def _action_reboot(self, node):",
            "        if not node.hasAttribute(\"type\"):",
            "            raise AttributeError(\"No reboot type was specified in request\")",
            "        return {\"type\": node.getAttribute(\"type\")}",
            "",
            "    def _action_rebuild(self, node):",
            "        rebuild = {}",
            "        if node.hasAttribute(\"name\"):",
            "            name = node.getAttribute(\"name\")",
            "            if not name:",
            "                raise AttributeError(\"Name cannot be blank\")",
            "            rebuild['name'] = name",
            "",
            "        if node.hasAttribute(\"auto_disk_config\"):",
            "            rebuild['OS-DCF:diskConfig'] = node.getAttribute(",
            "                \"auto_disk_config\")",
            "",
            "        if node.hasAttribute(\"OS-DCF:diskConfig\"):",
            "            rebuild['OS-DCF:diskConfig'] = node.getAttribute(",
            "                \"OS-DCF:diskConfig\")",
            "",
            "        metadata_node = self.find_first_child_named(node, \"metadata\")",
            "        if metadata_node is not None:",
            "            rebuild[\"metadata\"] = self.extract_metadata(metadata_node)",
            "",
            "        personality = self._extract_personality(node)",
            "        if personality is not None:",
            "            rebuild[\"personality\"] = personality",
            "",
            "        if not node.hasAttribute(\"imageRef\"):",
            "            raise AttributeError(\"No imageRef was specified in request\")",
            "        rebuild[\"imageRef\"] = node.getAttribute(\"imageRef\")",
            "",
            "        if node.hasAttribute(\"adminPass\"):",
            "            rebuild[\"adminPass\"] = node.getAttribute(\"adminPass\")",
            "",
            "        if node.hasAttribute(\"accessIPv4\"):",
            "            rebuild[\"accessIPv4\"] = node.getAttribute(\"accessIPv4\")",
            "",
            "        if node.hasAttribute(\"accessIPv6\"):",
            "            rebuild[\"accessIPv6\"] = node.getAttribute(\"accessIPv6\")",
            "",
            "        return rebuild",
            "",
            "    def _action_resize(self, node):",
            "        resize = {}",
            "",
            "        if node.hasAttribute(\"flavorRef\"):",
            "            resize[\"flavorRef\"] = node.getAttribute(\"flavorRef\")",
            "        else:",
            "            raise AttributeError(\"No flavorRef was specified in request\")",
            "",
            "        if node.hasAttribute(\"auto_disk_config\"):",
            "            resize['OS-DCF:diskConfig'] = node.getAttribute(\"auto_disk_config\")",
            "",
            "        if node.hasAttribute(\"OS-DCF:diskConfig\"):",
            "            resize['OS-DCF:diskConfig'] = node.getAttribute(",
            "                \"OS-DCF:diskConfig\")",
            "",
            "        return resize",
            "",
            "    def _action_confirm_resize(self, node):",
            "        return None",
            "",
            "    def _action_revert_resize(self, node):",
            "        return None",
            "",
            "    def _deserialize_image_action(self, node, allowed_attributes):",
            "        data = {}",
            "        for attribute in allowed_attributes:",
            "            value = node.getAttribute(attribute)",
            "            if value:",
            "                data[attribute] = value",
            "        metadata_node = self.find_first_child_named(node, 'metadata')",
            "        if metadata_node is not None:",
            "            metadata = self.metadata_deserializer.extract_metadata(",
            "                                                        metadata_node)",
            "            data['metadata'] = metadata",
            "        return data",
            "",
            "",
            "class CreateDeserializer(CommonDeserializer):",
            "    \"\"\"Deserializer to handle xml-formatted server create requests.",
            "",
            "    Handles standard server attributes as well as optional metadata",
            "    and personality attributes",
            "    \"\"\"",
            "",
            "    def default(self, string):",
            "        \"\"\"Deserialize an xml-formatted server create request.\"\"\"",
            "        dom = xmlutil.safe_minidom_parse_string(string)",
            "        server = self._extract_server(dom)",
            "        return {'body': {'server': server}}",
            "",
            "",
            "class Controller(wsgi.Controller):",
            "    \"\"\"The Server API base controller class for the OpenStack API.\"\"\"",
            "",
            "    _view_builder_class = views_servers.ViewBuilder",
            "",
            "    @staticmethod",
            "    def _add_location(robj):",
            "        # Just in case...",
            "        if 'server' not in robj.obj:",
            "            return robj",
            "",
            "        link = filter(lambda l: l['rel'] == 'self',",
            "                      robj.obj['server']['links'])",
            "        if link:",
            "            robj['Location'] = link[0]['href'].encode('utf-8')",
            "",
            "        # Convenience return",
            "        return robj",
            "",
            "    def __init__(self, ext_mgr=None, **kwargs):",
            "        super(Controller, self).__init__(**kwargs)",
            "        self.compute_api = compute.API()",
            "        self.ext_mgr = ext_mgr",
            "        self.neutron_attempted = False",
            "",
            "    @wsgi.serializers(xml=MinimalServersTemplate)",
            "    def index(self, req):",
            "        \"\"\"Returns a list of server names and ids for a given user.\"\"\"",
            "        try:",
            "            servers = self._get_servers(req, is_detail=False)",
            "        except exception.Invalid as err:",
            "            raise exc.HTTPBadRequest(explanation=err.format_message())",
            "        return servers",
            "",
            "    @wsgi.serializers(xml=ServersTemplate)",
            "    def detail(self, req):",
            "        \"\"\"Returns a list of server details for a given user.\"\"\"",
            "        try:",
            "            servers = self._get_servers(req, is_detail=True)",
            "        except exception.Invalid as err:",
            "            raise exc.HTTPBadRequest(explanation=err.format_message())",
            "        return servers",
            "",
            "    def _get_servers(self, req, is_detail):",
            "        \"\"\"Returns a list of servers, based on any search options specified.\"\"\"",
            "",
            "        search_opts = {}",
            "        search_opts.update(req.GET)",
            "",
            "        context = req.environ['nova.context']",
            "        remove_invalid_options(context, search_opts,",
            "                self._get_server_search_options())",
            "",
            "        # Verify search by 'status' contains a valid status.",
            "        # Convert it to filter by vm_state for compute_api.",
            "        status = search_opts.pop('status', None)",
            "        if status is not None:",
            "            state = common.vm_state_from_status(status)",
            "            if state is None:",
            "                return {'servers': []}",
            "            search_opts['vm_state'] = state",
            "",
            "        if 'changes-since' in search_opts:",
            "            try:",
            "                parsed = timeutils.parse_isotime(search_opts['changes-since'])",
            "            except ValueError:",
            "                msg = _('Invalid changes-since value')",
            "                raise exc.HTTPBadRequest(explanation=msg)",
            "            search_opts['changes-since'] = parsed",
            "",
            "        # By default, compute's get_all() will return deleted instances.",
            "        # If an admin hasn't specified a 'deleted' search option, we need",
            "        # to filter out deleted instances by setting the filter ourselves.",
            "        # ... Unless 'changes-since' is specified, because 'changes-since'",
            "        # should return recently deleted images according to the API spec.",
            "",
            "        if 'deleted' not in search_opts:",
            "            if 'changes-since' not in search_opts:",
            "                # No 'changes-since', so we only want non-deleted servers",
            "                search_opts['deleted'] = False",
            "",
            "        if search_opts.get(\"vm_state\") == \"deleted\":",
            "            if context.is_admin:",
            "                search_opts['deleted'] = True",
            "            else:",
            "                msg = _(\"Only administrators may list deleted instances\")",
            "                raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        if 'all_tenants' not in search_opts:",
            "            if context.project_id:",
            "                search_opts['project_id'] = context.project_id",
            "            else:",
            "                search_opts['user_id'] = context.user_id",
            "",
            "        limit, marker = common.get_limit_and_marker(req)",
            "        try:",
            "            instance_list = self.compute_api.get_all(context,",
            "                                                     search_opts=search_opts,",
            "                                                     limit=limit,",
            "                                                     marker=marker,",
            "                                                     want_objects=True)",
            "        except exception.MarkerNotFound:",
            "            msg = _('marker [%s] not found') % marker",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.FlavorNotFound:",
            "            log_msg = _(\"Flavor '%s' could not be found \")",
            "            LOG.debug(log_msg, search_opts['flavor'])",
            "            instance_list = []",
            "",
            "        if is_detail:",
            "            instance_list.fill_faults()",
            "            response = self._view_builder.detail(req, instance_list)",
            "        else:",
            "            response = self._view_builder.index(req, instance_list)",
            "        req.cache_db_instances(instance_list)",
            "        return response",
            "",
            "    def _get_server(self, context, req, instance_uuid):",
            "        \"\"\"Utility function for looking up an instance by uuid.\"\"\"",
            "        try:",
            "            instance = self.compute_api.get(context, instance_uuid,",
            "                                            want_objects=True)",
            "        except exception.NotFound:",
            "            msg = _(\"Instance could not be found\")",
            "            raise exc.HTTPNotFound(explanation=msg)",
            "        req.cache_db_instance(instance)",
            "        return instance",
            "",
            "    def _check_string_length(self, value, name, max_length=None):",
            "        try:",
            "            if isinstance(value, basestring):",
            "                value = value.strip()",
            "            utils.check_string_length(value, name, min_length=1,",
            "                                      max_length=max_length)",
            "        except exception.InvalidInput as e:",
            "            raise exc.HTTPBadRequest(explanation=e.format_message())",
            "",
            "    def _validate_server_name(self, value):",
            "        self._check_string_length(value, 'Server name', max_length=255)",
            "",
            "    def _get_injected_files(self, personality):",
            "        \"\"\"Create a list of injected files from the personality attribute.",
            "",
            "        At this time, injected_files must be formatted as a list of",
            "        (file_path, file_content) pairs for compatibility with the",
            "        underlying compute service.",
            "        \"\"\"",
            "        injected_files = []",
            "",
            "        for item in personality:",
            "            try:",
            "                path = item['path']",
            "                contents = item['contents']",
            "            except KeyError as key:",
            "                expl = _('Bad personality format: missing %s') % key",
            "                raise exc.HTTPBadRequest(explanation=expl)",
            "            except TypeError:",
            "                expl = _('Bad personality format')",
            "                raise exc.HTTPBadRequest(explanation=expl)",
            "            if self._decode_base64(contents) is None:",
            "                expl = _('Personality content for %s cannot be decoded') % path",
            "                raise exc.HTTPBadRequest(explanation=expl)",
            "            injected_files.append((path, contents))",
            "        return injected_files",
            "",
            "    def _is_neutron_v2(self):",
            "        # NOTE(dprince): neutronclient is not a requirement",
            "        if self.neutron_attempted:",
            "            return self.have_neutron",
            "",
            "        try:",
            "            # compatibility with Folsom/Grizzly configs",
            "            cls_name = CONF.network_api_class",
            "            if cls_name == 'nova.network.quantumv2.api.API':",
            "                cls_name = 'nova.network.neutronv2.api.API'",
            "            self.neutron_attempted = True",
            "",
            "            from nova.network.neutronv2 import api as neutron_api",
            "            self.have_neutron = issubclass(",
            "                importutils.import_class(cls_name),",
            "                neutron_api.API)",
            "        except ImportError:",
            "            self.have_neutron = False",
            "",
            "        return self.have_neutron",
            "",
            "    def _get_requested_networks(self, requested_networks):",
            "        \"\"\"Create a list of requested networks from the networks attribute.\"\"\"",
            "        networks = []",
            "        for network in requested_networks:",
            "            try:",
            "                port_id = network.get('port', None)",
            "                if port_id:",
            "                    network_uuid = None",
            "                    if not self._is_neutron_v2():",
            "                        # port parameter is only for neutron v2.0",
            "                        msg = _(\"Unknown argment : port\")",
            "                        raise exc.HTTPBadRequest(explanation=msg)",
            "                    if not uuidutils.is_uuid_like(port_id):",
            "                        msg = _(\"Bad port format: port uuid is \"",
            "                                \"not in proper format \"",
            "                                \"(%s)\") % port_id",
            "                        raise exc.HTTPBadRequest(explanation=msg)",
            "                else:",
            "                    network_uuid = network['uuid']",
            "",
            "                if not port_id and not uuidutils.is_uuid_like(network_uuid):",
            "                    br_uuid = network_uuid.split('-', 1)[-1]",
            "                    if not uuidutils.is_uuid_like(br_uuid):",
            "                        msg = _(\"Bad networks format: network uuid is \"",
            "                                \"not in proper format \"",
            "                                \"(%s)\") % network_uuid",
            "                        raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "                #fixed IP address is optional",
            "                #if the fixed IP address is not provided then",
            "                #it will use one of the available IP address from the network",
            "                address = network.get('fixed_ip', None)",
            "                if address is not None and not utils.is_valid_ipv4(address):",
            "                    msg = _(\"Invalid fixed IP address (%s)\") % address",
            "                    raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "                # For neutronv2, requestd_networks",
            "                # should be tuple of (network_uuid, fixed_ip, port_id)",
            "                if self._is_neutron_v2():",
            "                    networks.append((network_uuid, address, port_id))",
            "                else:",
            "                    # check if the network id is already present in the list,",
            "                    # we don't want duplicate networks to be passed",
            "                    # at the boot time",
            "                    for id, ip in networks:",
            "                        if id == network_uuid:",
            "                            expl = (_(\"Duplicate networks\"",
            "                                      \" (%s) are not allowed\") %",
            "                                    network_uuid)",
            "                            raise exc.HTTPBadRequest(explanation=expl)",
            "                    networks.append((network_uuid, address))",
            "            except KeyError as key:",
            "                expl = _('Bad network format: missing %s') % key",
            "                raise exc.HTTPBadRequest(explanation=expl)",
            "            except TypeError:",
            "                expl = _('Bad networks format')",
            "                raise exc.HTTPBadRequest(explanation=expl)",
            "",
            "        return networks",
            "",
            "    # NOTE(vish): Without this regex, b64decode will happily",
            "    #             ignore illegal bytes in the base64 encoded",
            "    #             data.",
            "    B64_REGEX = re.compile('^(?:[A-Za-z0-9+\\/]{4})*'",
            "                           '(?:[A-Za-z0-9+\\/]{2}=='",
            "                           '|[A-Za-z0-9+\\/]{3}=)?$')",
            "",
            "    def _decode_base64(self, data):",
            "        data = re.sub(r'\\s', '', data)",
            "        if not self.B64_REGEX.match(data):",
            "            return None",
            "        try:",
            "            return base64.b64decode(data)",
            "        except TypeError:",
            "            return None",
            "",
            "    def _validate_user_data(self, user_data):",
            "        \"\"\"Check if the user_data is encoded properly.\"\"\"",
            "        if not user_data:",
            "            return",
            "        if self._decode_base64(user_data) is None:",
            "            expl = _('Userdata content cannot be decoded')",
            "            raise exc.HTTPBadRequest(explanation=expl)",
            "",
            "    def _validate_access_ipv4(self, address):",
            "        if not utils.is_valid_ipv4(address):",
            "            expl = _('accessIPv4 is not proper IPv4 format')",
            "            raise exc.HTTPBadRequest(explanation=expl)",
            "",
            "    def _validate_access_ipv6(self, address):",
            "        if not utils.is_valid_ipv6(address):",
            "            expl = _('accessIPv6 is not proper IPv6 format')",
            "            raise exc.HTTPBadRequest(explanation=expl)",
            "",
            "    @wsgi.serializers(xml=ServerTemplate)",
            "    def show(self, req, id):",
            "        \"\"\"Returns server details by server id.\"\"\"",
            "        try:",
            "            context = req.environ['nova.context']",
            "            instance = self.compute_api.get(context, id,",
            "                                            want_objects=True)",
            "            req.cache_db_instance(instance)",
            "            return self._view_builder.show(req, instance)",
            "        except exception.NotFound:",
            "            msg = _(\"Instance could not be found\")",
            "            raise exc.HTTPNotFound(explanation=msg)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=CreateDeserializer)",
            "    def create(self, req, body):",
            "        \"\"\"Creates a new server for a given user.\"\"\"",
            "        if not self.is_valid_body(body, 'server'):",
            "            raise exc.HTTPUnprocessableEntity()",
            "",
            "        context = req.environ['nova.context']",
            "        server_dict = body['server']",
            "        password = self._get_server_admin_password(server_dict)",
            "",
            "        if 'name' not in server_dict:",
            "            msg = _(\"Server name is not defined\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        name = server_dict['name']",
            "        self._validate_server_name(name)",
            "        name = name.strip()",
            "",
            "        image_uuid = self._image_from_req_data(body)",
            "",
            "        personality = server_dict.get('personality')",
            "        config_drive = None",
            "        if self.ext_mgr.is_loaded('os-config-drive'):",
            "            config_drive = server_dict.get('config_drive')",
            "",
            "        injected_files = []",
            "        if personality:",
            "            injected_files = self._get_injected_files(personality)",
            "",
            "        sg_names = []",
            "        if self.ext_mgr.is_loaded('os-security-groups'):",
            "            security_groups = server_dict.get('security_groups')",
            "            if security_groups is not None:",
            "                sg_names = [sg['name'] for sg in security_groups",
            "                            if sg.get('name')]",
            "        if not sg_names:",
            "            sg_names.append('default')",
            "",
            "        sg_names = list(set(sg_names))",
            "",
            "        requested_networks = None",
            "        if (self.ext_mgr.is_loaded('os-networks')",
            "                or self._is_neutron_v2()):",
            "            requested_networks = server_dict.get('networks')",
            "",
            "        if requested_networks is not None:",
            "            if not isinstance(requested_networks, list):",
            "                expl = _('Bad networks format')",
            "                raise exc.HTTPBadRequest(explanation=expl)",
            "            requested_networks = self._get_requested_networks(",
            "                requested_networks)",
            "",
            "        (access_ip_v4, ) = server_dict.get('accessIPv4'),",
            "        if access_ip_v4 is not None:",
            "            self._validate_access_ipv4(access_ip_v4)",
            "",
            "        (access_ip_v6, ) = server_dict.get('accessIPv6'),",
            "        if access_ip_v6 is not None:",
            "            self._validate_access_ipv6(access_ip_v6)",
            "",
            "        try:",
            "            flavor_id = self._flavor_id_from_req_data(body)",
            "        except ValueError as error:",
            "            msg = _(\"Invalid flavorRef provided.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        # optional openstack extensions:",
            "        key_name = None",
            "        if self.ext_mgr.is_loaded('os-keypairs'):",
            "            key_name = server_dict.get('key_name')",
            "",
            "        user_data = None",
            "        if self.ext_mgr.is_loaded('os-user-data'):",
            "            user_data = server_dict.get('user_data')",
            "        self._validate_user_data(user_data)",
            "",
            "        availability_zone = None",
            "        if self.ext_mgr.is_loaded('os-availability-zone'):",
            "            availability_zone = server_dict.get('availability_zone')",
            "",
            "        block_device_mapping = None",
            "        block_device_mapping_v2 = None",
            "        legacy_bdm = True",
            "        if self.ext_mgr.is_loaded('os-volumes'):",
            "            block_device_mapping = server_dict.get('block_device_mapping', [])",
            "            for bdm in block_device_mapping:",
            "                try:",
            "                    block_device.validate_device_name(bdm.get(\"device_name\"))",
            "                    block_device.validate_and_default_volume_size(bdm)",
            "                except exception.InvalidBDMFormat as e:",
            "                    raise exc.HTTPBadRequest(explanation=e.format_message())",
            "",
            "                if 'delete_on_termination' in bdm:",
            "                    bdm['delete_on_termination'] = strutils.bool_from_string(",
            "                        bdm['delete_on_termination'])",
            "",
            "            if self.ext_mgr.is_loaded('os-block-device-mapping-v2-boot'):",
            "                # Consider the new data format for block device mapping",
            "                block_device_mapping_v2 = server_dict.get(",
            "                    'block_device_mapping_v2', [])",
            "                # NOTE (ndipanov):  Disable usage of both legacy and new",
            "                #                   block device format in the same request",
            "                if block_device_mapping and block_device_mapping_v2:",
            "                    expl = _('Using different block_device_mapping syntaxes '",
            "                             'is not allowed in the same request.')",
            "                    raise exc.HTTPBadRequest(explanation=expl)",
            "",
            "                # Assume legacy format",
            "                legacy_bdm = not bool(block_device_mapping_v2)",
            "",
            "                # NOTE (ndipanov) Don't allow empty device_name values",
            "                #                 for now until we can handle it on the",
            "                #                 compute side.",
            "                if any('device_name' not in bdm",
            "                       for bdm in block_device_mapping_v2):",
            "                    expl = _('Missing device_name in some block devices.')",
            "                    raise exc.HTTPBadRequest(explanation=expl)",
            "",
            "                try:",
            "                    block_device_mapping_v2 = [",
            "                        block_device.BlockDeviceDict.from_api(bdm_dict)",
            "                        for bdm_dict in block_device_mapping_v2]",
            "                except exception.InvalidBDMFormat as e:",
            "                    raise exc.HTTPBadRequest(explanation=e.format_message())",
            "",
            "        block_device_mapping = (block_device_mapping or",
            "                                block_device_mapping_v2)",
            "",
            "        ret_resv_id = False",
            "        # min_count and max_count are optional.  If they exist, they may come",
            "        # in as strings.  Verify that they are valid integers and > 0.",
            "        # Also, we want to default 'min_count' to 1, and default",
            "        # 'max_count' to be 'min_count'.",
            "        min_count = 1",
            "        max_count = 1",
            "        if self.ext_mgr.is_loaded('os-multiple-create'):",
            "            ret_resv_id = server_dict.get('return_reservation_id', False)",
            "            min_count = server_dict.get('min_count', 1)",
            "            max_count = server_dict.get('max_count', min_count)",
            "",
            "        try:",
            "            min_count = utils.validate_integer(",
            "                min_count, \"min_count\", min_value=1)",
            "            max_count = utils.validate_integer(",
            "                max_count, \"max_count\", min_value=1)",
            "        except exception.InvalidInput as e:",
            "            raise exc.HTTPBadRequest(explanation=e.format_message())",
            "",
            "        if min_count > max_count:",
            "            msg = _('min_count must be <= max_count')",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        auto_disk_config = False",
            "        if self.ext_mgr.is_loaded('OS-DCF'):",
            "            auto_disk_config = server_dict.get('auto_disk_config')",
            "",
            "        scheduler_hints = {}",
            "        if self.ext_mgr.is_loaded('OS-SCH-HNT'):",
            "            scheduler_hints = server_dict.get('scheduler_hints', {})",
            "",
            "        try:",
            "            _get_inst_type = flavors.get_flavor_by_flavor_id",
            "            inst_type = _get_inst_type(flavor_id, ctxt=context,",
            "                                       read_deleted=\"no\")",
            "",
            "            (instances, resv_id) = self.compute_api.create(context,",
            "                            inst_type,",
            "                            image_uuid,",
            "                            display_name=name,",
            "                            display_description=name,",
            "                            key_name=key_name,",
            "                            metadata=server_dict.get('metadata', {}),",
            "                            access_ip_v4=access_ip_v4,",
            "                            access_ip_v6=access_ip_v6,",
            "                            injected_files=injected_files,",
            "                            admin_password=password,",
            "                            min_count=min_count,",
            "                            max_count=max_count,",
            "                            requested_networks=requested_networks,",
            "                            security_group=sg_names,",
            "                            user_data=user_data,",
            "                            availability_zone=availability_zone,",
            "                            config_drive=config_drive,",
            "                            block_device_mapping=block_device_mapping,",
            "                            auto_disk_config=auto_disk_config,",
            "                            scheduler_hints=scheduler_hints,",
            "                            legacy_bdm=legacy_bdm)",
            "        except exception.QuotaError as error:",
            "            raise exc.HTTPRequestEntityTooLarge(",
            "                explanation=error.format_message(),",
            "                headers={'Retry-After': 0})",
            "        except exception.InvalidMetadataSize as error:",
            "            raise exc.HTTPRequestEntityTooLarge(",
            "                explanation=error.format_message())",
            "        except exception.ImageNotFound as error:",
            "            msg = _(\"Can not find requested image\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.FlavorNotFound as error:",
            "            msg = _(\"Invalid flavorRef provided.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.KeypairNotFound as error:",
            "            msg = _(\"Invalid key_name provided.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.ConfigDriveInvalidValue:",
            "            msg = _(\"Invalid config_drive provided.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except rpc_common.RemoteError as err:",
            "            msg = \"%(err_type)s: %(err_msg)s\" % {'err_type': err.exc_type,",
            "                                                 'err_msg': err.value}",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except UnicodeDecodeError as error:",
            "            msg = \"UnicodeError: %s\" % unicode(error)",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except (exception.ImageNotActive,",
            "                exception.InstanceTypeDiskTooSmall,",
            "                exception.InstanceTypeMemoryTooSmall,",
            "                exception.InstanceTypeNotFound,",
            "                exception.InvalidMetadata,",
            "                exception.InvalidRequest,",
            "                exception.PortNotFound,",
            "                exception.SecurityGroupNotFound) as error:",
            "            raise exc.HTTPBadRequest(explanation=error.format_message())",
            "        except exception.PortInUse as error:",
            "            raise exc.HTTPConflict(explanation=error.format_message())",
            "",
            "        # If the caller wanted a reservation_id, return it",
            "        if ret_resv_id:",
            "            return wsgi.ResponseObject({'reservation_id': resv_id},",
            "                                       xml=ServerMultipleCreateTemplate)",
            "",
            "        req.cache_db_instances(instances)",
            "        server = self._view_builder.create(req, instances[0])",
            "",
            "        if CONF.enable_instance_password:",
            "            server['server']['adminPass'] = password",
            "",
            "        robj = wsgi.ResponseObject(server)",
            "",
            "        return self._add_location(robj)",
            "",
            "    def _delete(self, context, req, instance_uuid):",
            "        instance = self._get_server(context, req, instance_uuid)",
            "        if CONF.reclaim_instance_interval:",
            "            self.compute_api.soft_delete(context, instance)",
            "        else:",
            "            self.compute_api.delete(context, instance)",
            "",
            "    @wsgi.serializers(xml=ServerTemplate)",
            "    def update(self, req, id, body):",
            "        \"\"\"Update server then pass on to version-specific controller.\"\"\"",
            "        if not self.is_valid_body(body, 'server'):",
            "            raise exc.HTTPUnprocessableEntity()",
            "",
            "        ctxt = req.environ['nova.context']",
            "        update_dict = {}",
            "",
            "        if 'name' in body['server']:",
            "            name = body['server']['name']",
            "            self._validate_server_name(name)",
            "            update_dict['display_name'] = name.strip()",
            "",
            "        if 'accessIPv4' in body['server']:",
            "            access_ipv4 = body['server']['accessIPv4']",
            "            if access_ipv4:",
            "                self._validate_access_ipv4(access_ipv4)",
            "            update_dict['access_ip_v4'] = (",
            "                access_ipv4 and access_ipv4.strip() or None)",
            "",
            "        if 'accessIPv6' in body['server']:",
            "            access_ipv6 = body['server']['accessIPv6']",
            "            if access_ipv6:",
            "                self._validate_access_ipv6(access_ipv6)",
            "            update_dict['access_ip_v6'] = (",
            "                access_ipv6 and access_ipv6.strip() or None)",
            "",
            "        if 'auto_disk_config' in body['server']:",
            "            auto_disk_config = strutils.bool_from_string(",
            "                    body['server']['auto_disk_config'])",
            "            update_dict['auto_disk_config'] = auto_disk_config",
            "",
            "        if 'hostId' in body['server']:",
            "            msg = _(\"HostId cannot be updated.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        if 'personality' in body['server']:",
            "            msg = _(\"Personality cannot be updated.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        try:",
            "            instance = self.compute_api.get(ctxt, id,",
            "                                            want_objects=True)",
            "            req.cache_db_instance(instance)",
            "            policy.enforce(ctxt, 'compute:update', instance)",
            "            instance.update(update_dict)",
            "            instance.save()",
            "        except exception.NotFound:",
            "            msg = _(\"Instance could not be found\")",
            "            raise exc.HTTPNotFound(explanation=msg)",
            "",
            "        return self._view_builder.show(req, instance)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('confirmResize')",
            "    def _action_confirm_resize(self, req, id, body):",
            "        context = req.environ['nova.context']",
            "        instance = self._get_server(context, req, id)",
            "        try:",
            "            self.compute_api.confirm_resize(context, instance)",
            "        except exception.MigrationNotFound:",
            "            msg = _(\"Instance has not been resized.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'confirmResize')",
            "        return exc.HTTPNoContent()",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('revertResize')",
            "    def _action_revert_resize(self, req, id, body):",
            "        context = req.environ['nova.context']",
            "        instance = self._get_server(context, req, id)",
            "        try:",
            "            self.compute_api.revert_resize(context, instance)",
            "        except exception.MigrationNotFound:",
            "            msg = _(\"Instance has not been resized.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.InstanceTypeNotFound:",
            "            msg = _(\"Flavor used by the instance could not be found.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'revertResize')",
            "        return webob.Response(status_int=202)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('reboot')",
            "    def _action_reboot(self, req, id, body):",
            "        if 'reboot' in body and 'type' in body['reboot']:",
            "            valid_reboot_types = ['HARD', 'SOFT']",
            "            reboot_type = body['reboot']['type'].upper()",
            "            if not valid_reboot_types.count(reboot_type):",
            "                msg = _(\"Argument 'type' for reboot is not HARD or SOFT\")",
            "                LOG.error(msg)",
            "                raise exc.HTTPBadRequest(explanation=msg)",
            "        else:",
            "            msg = _(\"Missing argument 'type' for reboot\")",
            "            LOG.error(msg)",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        context = req.environ['nova.context']",
            "        instance = self._get_server(context, req, id)",
            "",
            "        try:",
            "            self.compute_api.reboot(context, instance, reboot_type)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'reboot')",
            "        return webob.Response(status_int=202)",
            "",
            "    def _resize(self, req, instance_id, flavor_id, **kwargs):",
            "        \"\"\"Begin the resize process with given instance/flavor.\"\"\"",
            "        context = req.environ[\"nova.context\"]",
            "        instance = self._get_server(context, req, instance_id)",
            "",
            "        try:",
            "            self.compute_api.resize(context, instance, flavor_id, **kwargs)",
            "        except exception.FlavorNotFound:",
            "            msg = _(\"Unable to locate requested flavor.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.CannotResizeToSameFlavor:",
            "            msg = _(\"Resize requires a flavor change.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'resize')",
            "        except exception.ImageNotAuthorized:",
            "            msg = _(\"You are not authorized to access the image \"",
            "                    \"the instance was started with.\")",
            "            raise exc.HTTPUnauthorized(explanation=msg)",
            "        except exception.ImageNotFound:",
            "            msg = _(\"Image that the instance was started \"",
            "                    \"with could not be found.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except exception.Invalid:",
            "            msg = _(\"Invalid instance image.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        return webob.Response(status_int=202)",
            "",
            "    @wsgi.response(204)",
            "    def delete(self, req, id):",
            "        \"\"\"Destroys a server.\"\"\"",
            "        try:",
            "            self._delete(req.environ['nova.context'], req, id)",
            "        except exception.NotFound:",
            "            msg = _(\"Instance could not be found\")",
            "            raise exc.HTTPNotFound(explanation=msg)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'delete')",
            "",
            "    def _image_ref_from_req_data(self, data):",
            "        try:",
            "            return unicode(data['server']['imageRef'])",
            "        except (TypeError, KeyError):",
            "            msg = _(\"Missing imageRef attribute\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "    def _image_uuid_from_href(self, image_href):",
            "        # If the image href was generated by nova api, strip image_href",
            "        # down to an id and use the default glance connection params",
            "        image_uuid = image_href.split('/').pop()",
            "",
            "        if not uuidutils.is_uuid_like(image_uuid):",
            "            msg = _(\"Invalid imageRef provided.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        return image_uuid",
            "",
            "    def _image_from_req_data(self, data):",
            "        \"\"\"",
            "        Get image data from the request or raise appropriate",
            "        exceptions",
            "",
            "        If no image is supplied - checks to see if there is",
            "        block devices set and proper extesions loaded.",
            "        \"\"\"",
            "        image_ref = data['server'].get('imageRef')",
            "        bdm = data['server'].get('block_device_mapping')",
            "        bdm_v2 = data['server'].get('block_device_mapping_v2')",
            "",
            "        if (not image_ref and (",
            "                (bdm and self.ext_mgr.is_loaded('os-volumes')) or",
            "                (bdm_v2 and",
            "                 self.ext_mgr.is_loaded('os-block-device-mapping-v2-boot')))):",
            "            return ''",
            "        else:",
            "            image_href = self._image_ref_from_req_data(data)",
            "            image_uuid = self._image_uuid_from_href(image_href)",
            "            return image_uuid",
            "",
            "    def _flavor_id_from_req_data(self, data):",
            "        try:",
            "            flavor_ref = data['server']['flavorRef']",
            "        except (TypeError, KeyError):",
            "            msg = _(\"Missing flavorRef attribute\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        return common.get_id_from_href(flavor_ref)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('changePassword')",
            "    def _action_change_password(self, req, id, body):",
            "        context = req.environ['nova.context']",
            "        if (not 'changePassword' in body",
            "                or 'adminPass' not in body['changePassword']):",
            "            msg = _(\"No adminPass was specified\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        password = body['changePassword']['adminPass']",
            "        if not isinstance(password, basestring):",
            "            msg = _(\"Invalid adminPass\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        server = self._get_server(context, req, id)",
            "        try:",
            "            self.compute_api.set_admin_password(context, server, password)",
            "        except NotImplementedError:",
            "            msg = _(\"Unable to set password on instance\")",
            "            raise exc.HTTPNotImplemented(explanation=msg)",
            "        return webob.Response(status_int=202)",
            "",
            "    def _validate_metadata(self, metadata):",
            "        \"\"\"Ensure that we can work with the metadata given.\"\"\"",
            "        try:",
            "            metadata.iteritems()",
            "        except AttributeError:",
            "            msg = _(\"Unable to parse metadata key/value pairs.\")",
            "            LOG.debug(msg)",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('resize')",
            "    def _action_resize(self, req, id, body):",
            "        \"\"\"Resizes a given instance to the flavor size requested.\"\"\"",
            "        try:",
            "            flavor_ref = str(body[\"resize\"][\"flavorRef\"])",
            "            if not flavor_ref:",
            "                msg = _(\"Resize request has invalid 'flavorRef' attribute.\")",
            "                raise exc.HTTPBadRequest(explanation=msg)",
            "        except (KeyError, TypeError):",
            "            msg = _(\"Resize requests require 'flavorRef' attribute.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        kwargs = {}",
            "        if 'auto_disk_config' in body['resize']:",
            "            kwargs['auto_disk_config'] = body['resize']['auto_disk_config']",
            "",
            "        return self._resize(req, id, flavor_ref, **kwargs)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('rebuild')",
            "    def _action_rebuild(self, req, id, body):",
            "        \"\"\"Rebuild an instance with the given attributes.\"\"\"",
            "        try:",
            "            body = body['rebuild']",
            "        except (KeyError, TypeError):",
            "            msg = _('Invalid request body')",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        try:",
            "            image_href = body[\"imageRef\"]",
            "        except (KeyError, TypeError):",
            "            msg = _(\"Could not parse imageRef from request.\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        image_href = self._image_uuid_from_href(image_href)",
            "",
            "        try:",
            "            password = body['adminPass']",
            "        except (KeyError, TypeError):",
            "            password = utils.generate_password()",
            "",
            "        context = req.environ['nova.context']",
            "        instance = self._get_server(context, req, id)",
            "",
            "        attr_map = {",
            "            'personality': 'files_to_inject',",
            "            'name': 'display_name',",
            "            'accessIPv4': 'access_ip_v4',",
            "            'accessIPv6': 'access_ip_v6',",
            "            'metadata': 'metadata',",
            "            'auto_disk_config': 'auto_disk_config',",
            "        }",
            "",
            "        if 'accessIPv4' in body:",
            "            self._validate_access_ipv4(body['accessIPv4'])",
            "",
            "        if 'accessIPv6' in body:",
            "            self._validate_access_ipv6(body['accessIPv6'])",
            "",
            "        if 'name' in body:",
            "            self._validate_server_name(body['name'])",
            "",
            "        kwargs = {}",
            "",
            "        for request_attribute, instance_attribute in attr_map.items():",
            "            try:",
            "                kwargs[instance_attribute] = body[request_attribute]",
            "            except (KeyError, TypeError):",
            "                pass",
            "",
            "        self._validate_metadata(kwargs.get('metadata', {}))",
            "",
            "        if 'files_to_inject' in kwargs:",
            "            personality = kwargs['files_to_inject']",
            "            kwargs['files_to_inject'] = self._get_injected_files(personality)",
            "",
            "        try:",
            "            self.compute_api.rebuild(context,",
            "                                     instance,",
            "                                     image_href,",
            "                                     password,",
            "                                     **kwargs)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                    'rebuild')",
            "        except exception.InstanceNotFound:",
            "            msg = _(\"Instance could not be found\")",
            "            raise exc.HTTPNotFound(explanation=msg)",
            "        except exception.InvalidMetadataSize as error:",
            "            raise exc.HTTPRequestEntityTooLarge(",
            "                explanation=error.format_message())",
            "        except exception.ImageNotFound:",
            "            msg = _(\"Cannot find image for rebuild\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "        except (exception.ImageNotActive,",
            "                exception.InstanceTypeDiskTooSmall,",
            "                exception.InstanceTypeMemoryTooSmall,",
            "                exception.InvalidMetadata) as error:",
            "            raise exc.HTTPBadRequest(explanation=error.format_message())",
            "",
            "        instance = self._get_server(context, req, id)",
            "",
            "        view = self._view_builder.show(req, instance)",
            "",
            "        # Add on the adminPass attribute since the view doesn't do it",
            "        # unless instance passwords are disabled",
            "        if CONF.enable_instance_password:",
            "            view['server']['adminPass'] = password",
            "",
            "        robj = wsgi.ResponseObject(view)",
            "        return self._add_location(robj)",
            "",
            "    @wsgi.response(202)",
            "    @wsgi.serializers(xml=FullServerTemplate)",
            "    @wsgi.deserializers(xml=ActionDeserializer)",
            "    @wsgi.action('createImage')",
            "    @common.check_snapshots_enabled",
            "    def _action_create_image(self, req, id, body):",
            "        \"\"\"Snapshot a server instance.\"\"\"",
            "        context = req.environ['nova.context']",
            "        entity = body.get(\"createImage\", {})",
            "",
            "        image_name = entity.get(\"name\")",
            "",
            "        if not image_name:",
            "            msg = _(\"createImage entity requires name attribute\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        props = {}",
            "        metadata = entity.get('metadata', {})",
            "        common.check_img_metadata_properties_quota(context, metadata)",
            "        try:",
            "            props.update(metadata)",
            "        except ValueError:",
            "            msg = _(\"Invalid metadata\")",
            "            raise exc.HTTPBadRequest(explanation=msg)",
            "",
            "        instance = self._get_server(context, req, id)",
            "",
            "        bdms = self.compute_api.get_instance_bdms(context, instance)",
            "",
            "        try:",
            "            if self.compute_api.is_volume_backed_instance(context, instance,",
            "                                                          bdms):",
            "                img = instance['image_ref']",
            "                if not img:",
            "                    # NOTE(Vincent Hou) The private method",
            "                    # _get_volume_image_metadata only works, when boot",
            "                    # device is set to 'vda'. It needs to be fixed later,",
            "                    # but tentatively we use it here.",
            "                    image_meta = {'properties': self.compute_api.",
            "                                    _get_volume_image_metadata(context, bdms)}",
            "                else:",
            "                    src_image = self.compute_api.image_service.\\",
            "                                                show(context, img)",
            "                    image_meta = dict(src_image)",
            "",
            "                image = self.compute_api.snapshot_volume_backed(",
            "                                                       context,",
            "                                                       instance,",
            "                                                       image_meta,",
            "                                                       image_name,",
            "                                                       extra_properties=props)",
            "            else:",
            "                image = self.compute_api.snapshot(context,",
            "                                                  instance,",
            "                                                  image_name,",
            "                                                  extra_properties=props)",
            "        except exception.InstanceInvalidState as state_error:",
            "            common.raise_http_conflict_for_instance_invalid_state(state_error,",
            "                        'createImage')",
            "        except exception.Invalid as err:",
            "            raise exc.HTTPBadRequest(explanation=err.format_message())",
            "",
            "        # build location of newly-created image entity",
            "        image_id = str(image['id'])",
            "        image_ref = os.path.join(req.application_url,",
            "                                 context.project_id,",
            "                                 'images',",
            "                                 image_id)",
            "",
            "        resp = webob.Response(status_int=202)",
            "        resp.headers['Location'] = image_ref",
            "        return resp",
            "",
            "    def _get_server_admin_password(self, server):",
            "        \"\"\"Determine the admin password for a server on creation.\"\"\"",
            "        try:",
            "            password = server['adminPass']",
            "            self._validate_admin_password(password)",
            "        except KeyError:",
            "            password = utils.generate_password()",
            "        except ValueError:",
            "            raise exc.HTTPBadRequest(explanation=_(\"Invalid adminPass\"))",
            "",
            "        return password",
            "",
            "    def _validate_admin_password(self, password):",
            "        if not isinstance(password, basestring):",
            "            raise ValueError()",
            "",
            "    def _get_server_search_options(self):",
            "        \"\"\"Return server search options allowed by non-admin.\"\"\"",
            "        return ('reservation_id', 'name', 'status', 'image', 'flavor',",
            "                'ip', 'changes-since', 'all_tenants')",
            "",
            "",
            "def create_resource(ext_mgr):",
            "    return wsgi.Resource(Controller(ext_mgr))",
            "",
            "",
            "def remove_invalid_options(context, search_options, allowed_search_options):",
            "    \"\"\"Remove search options that are not valid for non-admin API/context.\"\"\"",
            "    if context.is_admin:",
            "        # Allow all options",
            "        return",
            "    # Otherwise, strip out all unknown options",
            "    unknown_options = [opt for opt in search_options",
            "                        if opt not in allowed_search_options]",
            "    LOG.debug(_(\"Removing options '%s' from query\"),",
            "              \", \".join(unknown_options))",
            "    for opt in unknown_options:",
            "        search_options.pop(opt, None)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "923": [
                "Controller",
                "create"
            ]
        },
        "addLocation": []
    },
    "nova/tests/api/openstack/compute/plugins/v3/test_servers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1800,
                "afterPatchRowNumber": 1800,
                "PatchRowcode": "         \"\"\"utility function - check server_dict for absence of admin_pass.\"\"\""
            },
            "1": {
                "beforePatchRowNumber": 1801,
                "afterPatchRowNumber": 1801,
                "PatchRowcode": "         self.assertTrue(\"admin_pass\" not in server_dict)"
            },
            "2": {
                "beforePatchRowNumber": 1802,
                "afterPatchRowNumber": 1802,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 1803,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _test_create_instance(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1803,
                "PatchRowcode": "+    def _test_create_instance(self, flavor=2):"
            },
            "5": {
                "beforePatchRowNumber": 1804,
                "afterPatchRowNumber": 1804,
                "PatchRowcode": "         image_uuid = 'c905cedb-7281-47e4-8a62-f26bc5fc4c77'"
            },
            "6": {
                "beforePatchRowNumber": 1805,
                "afterPatchRowNumber": 1805,
                "PatchRowcode": "         self.body['server']['image_ref'] = image_uuid"
            },
            "7": {
                "beforePatchRowNumber": 1806,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.body['server']['flavor_ref'] = 2"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1806,
                "PatchRowcode": "+        self.body['server']['flavor_ref'] = flavor"
            },
            "9": {
                "beforePatchRowNumber": 1807,
                "afterPatchRowNumber": 1807,
                "PatchRowcode": "         self.req.body = jsonutils.dumps(self.body)"
            },
            "10": {
                "beforePatchRowNumber": 1808,
                "afterPatchRowNumber": 1808,
                "PatchRowcode": "         server = self.controller.create(self.req, self.body).obj['server']"
            },
            "11": {
                "beforePatchRowNumber": 1809,
                "afterPatchRowNumber": 1809,
                "PatchRowcode": "         self._check_admin_pass_len(server)"
            },
            "12": {
                "beforePatchRowNumber": 1810,
                "afterPatchRowNumber": 1810,
                "PatchRowcode": "         self.assertEqual(FAKE_UUID, server['id'])"
            },
            "13": {
                "beforePatchRowNumber": 1811,
                "afterPatchRowNumber": 1811,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1812,
                "PatchRowcode": "+    def test_create_instance_private_flavor(self):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1813,
                "PatchRowcode": "+        values = {"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1814,
                "PatchRowcode": "+            'name': 'fake_name',"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1815,
                "PatchRowcode": "+            'memory_mb': 512,"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1816,
                "PatchRowcode": "+            'vcpus': 1,"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1817,
                "PatchRowcode": "+            'root_gb': 10,"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1818,
                "PatchRowcode": "+            'ephemeral_gb': 10,"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1819,
                "PatchRowcode": "+            'flavorid': '1324',"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1820,
                "PatchRowcode": "+            'swap': 0,"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1821,
                "PatchRowcode": "+            'rxtx_factor': 0.5,"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1822,
                "PatchRowcode": "+            'vcpu_weight': 1,"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1823,
                "PatchRowcode": "+            'disabled': False,"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1824,
                "PatchRowcode": "+            'is_public': False,"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1825,
                "PatchRowcode": "+        }"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1826,
                "PatchRowcode": "+        db.flavor_create(context.get_admin_context(), values)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1827,
                "PatchRowcode": "+        self.assertRaises(webob.exc.HTTPBadRequest, self._test_create_instance,"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1828,
                "PatchRowcode": "+                          flavor=1324)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1829,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": 1812,
                "afterPatchRowNumber": 1830,
                "PatchRowcode": "     def test_create_server_bad_image_href(self):"
            },
            "33": {
                "beforePatchRowNumber": 1813,
                "afterPatchRowNumber": 1831,
                "PatchRowcode": "         image_href = 1"
            },
            "34": {
                "beforePatchRowNumber": 1814,
                "afterPatchRowNumber": 1832,
                "PatchRowcode": "         self.body['server']['min_count'] = 1"
            }
        },
        "frontPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2010-2011 OpenStack Foundation",
            "# Copyright 2011 Piston Cloud Computing, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import base64",
            "import datetime",
            "import mox",
            "import testtools",
            "import urlparse",
            "import uuid",
            "",
            "import iso8601",
            "from lxml import etree",
            "from oslo.config import cfg",
            "import webob",
            "",
            "from nova.api.openstack import compute",
            "from nova.api.openstack.compute import plugins",
            "from nova.api.openstack.compute.plugins.v3 import availability_zone",
            "from nova.api.openstack.compute.plugins.v3 import ips",
            "from nova.api.openstack.compute.plugins.v3 import keypairs",
            "from nova.api.openstack.compute.plugins.v3 import servers",
            "from nova.api.openstack.compute import views",
            "from nova.api.openstack import xmlutil",
            "from nova.compute import api as compute_api",
            "from nova.compute import flavors",
            "from nova.compute import task_states",
            "from nova.compute import vm_states",
            "from nova import context",
            "from nova import db",
            "from nova.db.sqlalchemy import models",
            "from nova import exception",
            "from nova.image import glance",
            "from nova.network import manager",
            "from nova.network.neutronv2 import api as neutron_api",
            "from nova.objects import instance as instance_obj",
            "from nova.openstack.common.gettextutils import _",
            "from nova.openstack.common import jsonutils",
            "from nova.openstack.common import policy as common_policy",
            "from nova.openstack.common import rpc",
            "from nova import policy",
            "from nova import test",
            "from nova.tests.api.openstack import fakes",
            "from nova.tests import fake_instance",
            "from nova.tests import fake_network",
            "from nova.tests.image import fake",
            "from nova.tests import matchers",
            "from nova.tests import utils",
            "",
            "CONF = cfg.CONF",
            "CONF.import_opt('password_length', 'nova.utils')",
            "CONF.import_opt('scheduler_topic', 'nova.scheduler.rpcapi')",
            "",
            "FAKE_UUID = fakes.FAKE_UUID",
            "NS = \"{http://docs.openstack.org/compute/api/v1.1}\"",
            "ATOMNS = \"{http://www.w3.org/2005/Atom}\"",
            "XPATH_NS = {",
            "    'atom': 'http://www.w3.org/2005/Atom',",
            "    'ns': 'http://docs.openstack.org/compute/api/v1.1'",
            "}",
            "",
            "INSTANCE_IDS = {FAKE_UUID: 1}",
            "FIELDS = instance_obj.INSTANCE_DEFAULT_FIELDS",
            "",
            "",
            "def fake_gen_uuid():",
            "    return FAKE_UUID",
            "",
            "",
            "def return_servers_empty(context, *args, **kwargs):",
            "    return []",
            "",
            "",
            "def return_security_group(context, instance_id, security_group_id):",
            "    pass",
            "",
            "",
            "def instance_update(context, instance_uuid, values, update_cells=True):",
            "    inst = fakes.stub_instance(INSTANCE_IDS.get(instance_uuid),",
            "                               name=values.get('display_name'))",
            "    inst = dict(inst, **values)",
            "    return (inst, inst)",
            "",
            "",
            "def fake_compute_api(cls, req, id):",
            "    return True",
            "",
            "",
            "def fake_start_stop_not_ready(self, context, instance):",
            "    raise exception.InstanceNotReady(instance_id=instance[\"uuid\"])",
            "",
            "",
            "def fake_instance_get_by_uuid_not_found(context, uuid, columns_to_join):",
            "    raise exception.InstanceNotFound(instance_id=uuid)",
            "",
            "",
            "class MockSetAdminPassword(object):",
            "    def __init__(self):",
            "        self.instance_id = None",
            "        self.password = None",
            "",
            "    def __call__(self, context, instance_id, password):",
            "        self.instance_id = instance_id",
            "        self.password = password",
            "",
            "",
            "class Base64ValidationTest(test.TestCase):",
            "    def setUp(self):",
            "        super(Base64ValidationTest, self).setUp()",
            "        ext_info = plugins.LoadedExtensionInfo()",
            "        self.controller = servers.ServersController(extension_info=ext_info)",
            "",
            "    def test_decode_base64(self):",
            "        value = \"A random string\"",
            "        result = self.controller._decode_base64(base64.b64encode(value))",
            "        self.assertEqual(result, value)",
            "",
            "    def test_decode_base64_binary(self):",
            "        value = \"\\x00\\x12\\x75\\x99\"",
            "        result = self.controller._decode_base64(base64.b64encode(value))",
            "        self.assertEqual(result, value)",
            "",
            "    def test_decode_base64_whitespace(self):",
            "        value = \"A random string\"",
            "        encoded = base64.b64encode(value)",
            "        white = \"\\n \\n%s\\t%s\\n\" % (encoded[:2], encoded[2:])",
            "        result = self.controller._decode_base64(white)",
            "        self.assertEqual(result, value)",
            "",
            "    def test_decode_base64_invalid(self):",
            "        invalid = \"A random string\"",
            "        result = self.controller._decode_base64(invalid)",
            "        self.assertEqual(result, None)",
            "",
            "    def test_decode_base64_illegal_bytes(self):",
            "        value = \"A random string\"",
            "        encoded = base64.b64encode(value)",
            "        white = \">\\x01%s*%s()\" % (encoded[:2], encoded[2:])",
            "        result = self.controller._decode_base64(white)",
            "        self.assertEqual(result, None)",
            "",
            "",
            "class NeutronV2Subclass(neutron_api.API):",
            "    \"\"\"Used to ensure that API handles subclasses properly.\"\"\"",
            "    pass",
            "",
            "",
            "class ControllerTest(test.TestCase):",
            "",
            "    def setUp(self):",
            "        super(ControllerTest, self).setUp()",
            "        self.flags(verbose=True, use_ipv6=False)",
            "        fakes.stub_out_rate_limiting(self.stubs)",
            "        fakes.stub_out_key_pair_funcs(self.stubs)",
            "        fake.stub_out_image_service(self.stubs)",
            "        return_server = fakes.fake_instance_get()",
            "        return_servers = fakes.fake_instance_get_all_by_filters()",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       return_servers)",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                       return_server)",
            "        self.stubs.Set(db, 'instance_add_security_group',",
            "                       return_security_group)",
            "        self.stubs.Set(db, 'instance_update_and_get_original',",
            "                       instance_update)",
            "",
            "        ext_info = plugins.LoadedExtensionInfo()",
            "        self.controller = servers.ServersController(extension_info=ext_info)",
            "        self.ips_controller = ips.IPsController()",
            "        policy.reset()",
            "        policy.init()",
            "        fake_network.stub_out_nw_api_get_instance_nw_info(self.stubs,",
            "                                                          spectacular=True)",
            "",
            "",
            "class ServersControllerTest(ControllerTest):",
            "",
            "        #    def test_can_check_loaded_extensions(self):",
            "        #self.ext_mgr.extensions = {'os-fake': None}",
            "        #self.assertTrue(self.controller.ext_mgr.is_loaded('os-fake'))",
            "        #self.assertFalse(self.controller.ext_mgr.is_loaded('os-not-loaded'))",
            "",
            "    def test_requested_networks_prefix(self):",
            "        uuid = 'br-00000000-0000-0000-0000-000000000000'",
            "        requested_networks = [{'uuid': uuid}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertTrue((uuid, None) in res)",
            "",
            "    def test_requested_networks_neutronv2_enabled_with_port(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'port': port}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertEquals(res, [(None, None, port)])",
            "",
            "    def test_requested_networks_neutronv2_enabled_with_network(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        network = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        requested_networks = [{'uuid': network}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertEquals(res, [(network, None, None)])",
            "",
            "    def test_requested_networks_neutronv2_enabled_with_network_and_port(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        network = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'uuid': network, 'port': port}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertEquals(res, [(None, None, port)])",
            "",
            "    def test_requested_networks_neutronv2_enabled_conflict_on_fixed_ip(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        network = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        addr = '10.0.0.1'",
            "        requested_networks = [{'uuid': network,",
            "                               'fixed_ip': addr,",
            "                               'port': port}]",
            "        self.assertRaises(",
            "            webob.exc.HTTPBadRequest,",
            "            self.controller._get_requested_networks,",
            "            requested_networks)",
            "",
            "    def test_requested_networks_neutronv2_disabled_with_port(self):",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'port': port}]",
            "        self.assertRaises(",
            "            webob.exc.HTTPBadRequest,",
            "            self.controller._get_requested_networks,",
            "            requested_networks)",
            "",
            "    def test_requested_networks_api_enabled_with_v2_subclass(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        network = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'uuid': network, 'port': port}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertEquals(res, [(None, None, port)])",
            "",
            "    def test_requested_networks_neutronv2_subclass_with_port(self):",
            "        cls = 'nova.tests.api.openstack.compute.test_servers.NeutronV2Subclass'",
            "        self.flags(network_api_class=cls)",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'port': port}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertEquals(res, [(None, None, port)])",
            "",
            "    def test_get_server_by_uuid(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s' % FAKE_UUID)",
            "        res_dict = self.controller.show(req, FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "",
            "    def test_unique_host_id(self):",
            "        \"\"\"Create two servers with the same host and different",
            "        project_ids and check that the host_id's are unique.",
            "        \"\"\"",
            "        def return_instance_with_host(self, *args, **kwargs):",
            "            project_id = str(uuid.uuid4())",
            "            return fakes.stub_instance(id=1, uuid=FAKE_UUID,",
            "                                       project_id=project_id,",
            "                                       host='fake_host')",
            "",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                       return_instance_with_host)",
            "        self.stubs.Set(db, 'instance_get',",
            "                       return_instance_with_host)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s' % FAKE_UUID)",
            "        server1 = self.controller.show(req, FAKE_UUID)",
            "        server2 = self.controller.show(req, FAKE_UUID)",
            "",
            "        self.assertNotEqual(server1['server']['host_id'],",
            "                            server2['server']['host_id'])",
            "",
            "    def test_get_server_by_id(self):",
            "        self.flags(use_ipv6=True)",
            "        image_bookmark = \"http://localhost/images/10\"",
            "        flavor_bookmark = \"http://localhost/flavors/1\"",
            "",
            "        uuid = FAKE_UUID",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s' % uuid)",
            "        res_dict = self.controller.show(req, uuid)",
            "",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 0,",
            "                \"name\": \"server1\",",
            "                \"status\": \"BUILD\",",
            "                \"access_ip_v4\": \"\",",
            "                \"access_ip_v6\": \"\",",
            "                \"host_id\": '',",
            "                \"image\": {",
            "                    \"id\": \"10\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                  \"links\": [",
            "                                            {",
            "                          \"rel\": \"bookmark\",",
            "                          \"href\": flavor_bookmark,",
            "                      },",
            "                  ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'}",
            "                    ]",
            "                },",
            "                \"metadata\": {",
            "                    \"seq\": \"1\",",
            "                },",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": \"http://localhost/v3/servers/%s\" % uuid,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": \"http://localhost/servers/%s\" % uuid,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        self.assertThat(res_dict, matchers.DictMatches(expected_server))",
            "",
            "    def test_get_server_with_active_status_by_id(self):",
            "        image_bookmark = \"http://localhost/images/10\"",
            "        flavor_bookmark = \"http://localhost/flavors/1\"",
            "",
            "        new_return_server = fakes.fake_instance_get(",
            "                vm_state=vm_states.ACTIVE, progress=100)",
            "        self.stubs.Set(db, 'instance_get_by_uuid', new_return_server)",
            "",
            "        uuid = FAKE_UUID",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s' % uuid)",
            "        res_dict = self.controller.show(req, uuid)",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 100,",
            "                \"name\": \"server1\",",
            "                \"status\": \"ACTIVE\",",
            "                \"access_ip_v4\": \"\",",
            "                \"access_ip_v6\": \"\",",
            "                \"host_id\": '',",
            "                \"image\": {",
            "                    \"id\": \"10\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                  \"links\": [",
            "                      {",
            "                          \"rel\": \"bookmark\",",
            "                          \"href\": flavor_bookmark,",
            "                      },",
            "                  ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                    ]",
            "                },",
            "                \"metadata\": {",
            "                    \"seq\": \"1\",",
            "                },",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": \"http://localhost/v3/servers/%s\" % uuid,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": \"http://localhost/servers/%s\" % uuid,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        self.assertThat(res_dict, matchers.DictMatches(expected_server))",
            "",
            "    def test_get_server_with_id_image_ref_by_id(self):",
            "        image_ref = \"10\"",
            "        image_bookmark = \"http://localhost/images/10\"",
            "        flavor_id = \"1\"",
            "        flavor_bookmark = \"http://localhost/flavors/1\"",
            "",
            "        new_return_server = fakes.fake_instance_get(",
            "                vm_state=vm_states.ACTIVE, image_ref=image_ref,",
            "                flavor_id=flavor_id, progress=100)",
            "        self.stubs.Set(db, 'instance_get_by_uuid', new_return_server)",
            "",
            "        uuid = FAKE_UUID",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s' % uuid)",
            "        res_dict = self.controller.show(req, uuid)",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 100,",
            "                \"name\": \"server1\",",
            "                \"status\": \"ACTIVE\",",
            "                \"access_ip_v4\": \"\",",
            "                \"access_ip_v6\": \"\",",
            "                \"host_id\": '',",
            "                \"image\": {",
            "                    \"id\": \"10\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                  \"links\": [",
            "                      {",
            "                          \"rel\": \"bookmark\",",
            "                          \"href\": flavor_bookmark,",
            "                      },",
            "                  ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                    ]",
            "                },",
            "                \"metadata\": {",
            "                    \"seq\": \"1\",",
            "                },",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": \"http://localhost/v3/servers/%s\" % uuid,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": \"http://localhost/servers/%s\" % uuid,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        self.assertThat(res_dict, matchers.DictMatches(expected_server))",
            "",
            "    def test_get_server_addresses_from_cache(self):",
            "        pub0 = ('172.19.0.1', '172.19.0.2',)",
            "        pub1 = ('1.2.3.4',)",
            "        pub2 = ('b33f::fdee:ddff:fecc:bbaa',)",
            "        priv0 = ('192.168.0.3', '192.168.0.4',)",
            "",
            "        def _ip(ip):",
            "            return {'address': ip, 'type': 'fixed'}",
            "",
            "        nw_cache = [",
            "            {'address': 'aa:aa:aa:aa:aa:aa',",
            "             'id': 1,",
            "             'network': {'bridge': 'br0',",
            "                         'id': 1,",
            "                         'label': 'public',",
            "                         'subnets': [{'cidr': '172.19.0.0/24',",
            "                                      'ips': [_ip(ip) for ip in pub0]},",
            "                                      {'cidr': '1.2.3.0/16',",
            "                                       'ips': [_ip(ip) for ip in pub1]},",
            "                                      {'cidr': 'b33f::/64',",
            "                                       'ips': [_ip(ip) for ip in pub2]}]}},",
            "            {'address': 'bb:bb:bb:bb:bb:bb',",
            "             'id': 2,",
            "             'network': {'bridge': 'br1',",
            "                         'id': 2,",
            "                         'label': 'private',",
            "                         'subnets': [{'cidr': '192.168.0.0/24',",
            "                                      'ips': [_ip(ip) for ip in priv0]}]}}]",
            "",
            "        return_server = fakes.fake_instance_get(nw_cache=nw_cache)",
            "        self.stubs.Set(db, 'instance_get_by_uuid', return_server)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s/ips' % FAKE_UUID)",
            "        res_dict = self.ips_controller.index(req, FAKE_UUID)",
            "",
            "        expected = {",
            "            'addresses': {",
            "                'private': [",
            "                    {'version': 4, 'addr': '192.168.0.3',",
            "                     'type': 'fixed', 'mac_addr': 'bb:bb:bb:bb:bb:bb'},",
            "                    {'version': 4, 'addr': '192.168.0.4',",
            "                     'type': 'fixed', 'mac_addr': 'bb:bb:bb:bb:bb:bb'},",
            "                ],",
            "                'public': [",
            "                    {'version': 4, 'addr': '172.19.0.1',",
            "                     'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                    {'version': 4, 'addr': '172.19.0.2',",
            "                     'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                    {'version': 4, 'addr': '1.2.3.4',",
            "                     'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                    {'version': 6, 'addr': 'b33f::fdee:ddff:fecc:bbaa',",
            "                     'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                ],",
            "            },",
            "        }",
            "        self.assertThat(res_dict, matchers.DictMatches(expected))",
            "",
            "    def test_get_server_addresses_nonexistent_network(self):",
            "        url = '/v3/servers/%s/ips/network_0' % FAKE_UUID",
            "        req = fakes.HTTPRequestV3.blank(url)",
            "        self.assertRaises(webob.exc.HTTPNotFound, self.ips_controller.show,",
            "                          req, FAKE_UUID, 'network_0')",
            "",
            "    def test_get_server_addresses_nonexistent_server(self):",
            "        def fake_instance_get(*args, **kwargs):",
            "            raise exception.InstanceNotFound(instance_id='fake')",
            "",
            "        self.stubs.Set(db, 'instance_get_by_uuid', fake_instance_get)",
            "",
            "        server_id = str(uuid.uuid4())",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s/ips' % server_id)",
            "        self.assertRaises(webob.exc.HTTPNotFound,",
            "                          self.ips_controller.index, req, server_id)",
            "",
            "    def test_get_server_list_empty(self):",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       return_servers_empty)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers')",
            "        res_dict = self.controller.index(req)",
            "",
            "        num_servers = len(res_dict['servers'])",
            "        self.assertEqual(0, num_servers)",
            "",
            "    def test_get_server_list_with_reservation_id(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers?reservation_id=foo')",
            "        res_dict = self.controller.index(req)",
            "",
            "        i = 0",
            "        for s in res_dict['servers']:",
            "            self.assertEqual(s.get('name'), 'server%d' % (i + 1))",
            "            i += 1",
            "",
            "    def test_get_server_list_with_reservation_id_empty(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers/detail?'",
            "                                      'reservation_id=foo')",
            "        res_dict = self.controller.detail(req)",
            "",
            "        i = 0",
            "        for s in res_dict['servers']:",
            "            self.assertEqual(s.get('name'), 'server%d' % (i + 1))",
            "            i += 1",
            "",
            "    def test_get_server_list_with_reservation_id_details(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers/detail?'",
            "                                      'reservation_id=foo')",
            "        res_dict = self.controller.detail(req)",
            "",
            "        i = 0",
            "        for s in res_dict['servers']:",
            "            self.assertEqual(s.get('name'), 'server%d' % (i + 1))",
            "            i += 1",
            "",
            "    def test_get_server_list(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers')",
            "        res_dict = self.controller.index(req)",
            "",
            "        self.assertEqual(len(res_dict['servers']), 5)",
            "        for i, s in enumerate(res_dict['servers']):",
            "            self.assertEqual(s['id'], fakes.get_fake_uuid(i))",
            "            self.assertEqual(s['name'], 'server%d' % (i + 1))",
            "            self.assertEqual(s.get('image', None), None)",
            "",
            "            expected_links = [",
            "                {",
            "                    \"rel\": \"self\",",
            "                    \"href\": \"http://localhost/v3/servers/%s\" % s['id'],",
            "                },",
            "                {",
            "                    \"rel\": \"bookmark\",",
            "                    \"href\": \"http://localhost/servers/%s\" % s['id'],",
            "                },",
            "            ]",
            "",
            "            self.assertEqual(s['links'], expected_links)",
            "",
            "    def test_get_servers_with_limit(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers?limit=3')",
            "        res_dict = self.controller.index(req)",
            "",
            "        servers = res_dict['servers']",
            "        self.assertEqual([s['id'] for s in servers],",
            "                [fakes.get_fake_uuid(i) for i in xrange(len(servers))])",
            "",
            "        servers_links = res_dict['servers_links']",
            "        self.assertEqual(servers_links[0]['rel'], 'next')",
            "        href_parts = urlparse.urlparse(servers_links[0]['href'])",
            "        self.assertEqual('/v3/servers', href_parts.path)",
            "        params = urlparse.parse_qs(href_parts.query)",
            "        expected_params = {'limit': ['3'],",
            "                           'marker': [fakes.get_fake_uuid(2)]}",
            "        self.assertThat(params, matchers.DictMatches(expected_params))",
            "",
            "    def test_get_servers_with_limit_bad_value(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers?limit=aaa')",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.index, req)",
            "",
            "    def test_get_server_details_empty(self):",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       return_servers_empty)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers/detail')",
            "        res_dict = self.controller.index(req)",
            "",
            "        num_servers = len(res_dict['servers'])",
            "        self.assertEqual(0, num_servers)",
            "",
            "    def test_get_server_details_with_limit(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers/detail?limit=3')",
            "        res = self.controller.detail(req)",
            "",
            "        servers = res['servers']",
            "        self.assertEqual([s['id'] for s in servers],",
            "                [fakes.get_fake_uuid(i) for i in xrange(len(servers))])",
            "",
            "        servers_links = res['servers_links']",
            "        self.assertEqual(servers_links[0]['rel'], 'next')",
            "",
            "        href_parts = urlparse.urlparse(servers_links[0]['href'])",
            "        self.assertEqual('/v3/servers', href_parts.path)",
            "        params = urlparse.parse_qs(href_parts.query)",
            "        expected = {'limit': ['3'], 'marker': [fakes.get_fake_uuid(2)]}",
            "        self.assertThat(params, matchers.DictMatches(expected))",
            "",
            "    def test_get_server_details_with_limit_bad_value(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers/detail?limit=aaa')",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.detail, req)",
            "",
            "    def test_get_server_details_with_limit_and_other_params(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers/detail'",
            "                                      '?limit=3&blah=2:t')",
            "        res = self.controller.detail(req)",
            "",
            "        servers = res['servers']",
            "        self.assertEqual([s['id'] for s in servers],",
            "                [fakes.get_fake_uuid(i) for i in xrange(len(servers))])",
            "",
            "        servers_links = res['servers_links']",
            "        self.assertEqual(servers_links[0]['rel'], 'next')",
            "",
            "        href_parts = urlparse.urlparse(servers_links[0]['href'])",
            "        self.assertEqual('/v3/servers', href_parts.path)",
            "        params = urlparse.parse_qs(href_parts.query)",
            "        expected = {'limit': ['3'], 'blah': ['2:t'],",
            "                    'marker': [fakes.get_fake_uuid(2)]}",
            "        self.assertThat(params, matchers.DictMatches(expected))",
            "",
            "    def test_get_servers_with_too_big_limit(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers?limit=30')",
            "        res_dict = self.controller.index(req)",
            "        self.assertTrue('servers_links' not in res_dict)",
            "",
            "    def test_get_servers_with_bad_limit(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers?limit=asdf')",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.index, req)",
            "",
            "    def test_get_servers_with_marker(self):",
            "        url = '/v3/servers?marker=%s' % fakes.get_fake_uuid(2)",
            "        req = fakes.HTTPRequestV3.blank(url)",
            "        servers = self.controller.index(req)['servers']",
            "        self.assertEqual([s['name'] for s in servers], [\"server4\", \"server5\"])",
            "",
            "    def test_get_servers_with_limit_and_marker(self):",
            "        url = '/v3/servers?limit=2&marker=%s' % fakes.get_fake_uuid(1)",
            "        req = fakes.HTTPRequestV3.blank(url)",
            "        servers = self.controller.index(req)['servers']",
            "        self.assertEqual([s['name'] for s in servers], ['server3', 'server4'])",
            "",
            "    def test_get_servers_with_bad_marker(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers?limit=2&marker=asdf')",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.index, req)",
            "",
            "    def test_get_servers_with_bad_option(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers?unknownoption=whee')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_allows_image(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('image' in search_opts)",
            "            self.assertEqual(search_opts['image'], '12345')",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers?image=12345')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_tenant_id_filter_converts_to_project_id_for_admin(self):",
            "        def fake_get_all(context, filters=None, sort_key=None,",
            "                         sort_dir='desc', limit=None, marker=None,",
            "                         columns_to_join=None):",
            "            self.assertNotEqual(filters, None)",
            "            self.assertEqual(filters['project_id'], 'fake')",
            "            self.assertFalse(filters.get('tenant_id'))",
            "            return [fakes.stub_instance(100)]",
            "",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       fake_get_all)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers?tenant_id=fake',",
            "                                      use_admin_context=True)",
            "        res = self.controller.index(req)",
            "",
            "        self.assertTrue('servers' in res)",
            "",
            "    def test_admin_restricted_tenant(self):",
            "        def fake_get_all(context, filters=None, sort_key=None,",
            "                         sort_dir='desc', limit=None, marker=None,",
            "                         columns_to_join=None):",
            "            self.assertNotEqual(filters, None)",
            "            self.assertEqual(filters['project_id'], 'fake')",
            "            return [fakes.stub_instance(100)]",
            "",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       fake_get_all)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers',",
            "                                      use_admin_context=True)",
            "        res = self.controller.index(req)",
            "",
            "        self.assertTrue('servers' in res)",
            "",
            "    def test_all_tenants_pass_policy(self):",
            "        def fake_get_all(context, filters=None, sort_key=None,",
            "                         sort_dir='desc', limit=None, marker=None,",
            "                         columns_to_join=None):",
            "            self.assertNotEqual(filters, None)",
            "            self.assertTrue('project_id' not in filters)",
            "            return [fakes.stub_instance(100)]",
            "",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       fake_get_all)",
            "",
            "        rules = {",
            "            \"compute:get_all_tenants\":",
            "                common_policy.parse_rule(\"project_id:fake\"),",
            "            \"compute:get_all\":",
            "                common_policy.parse_rule(\"project_id:fake\"),",
            "        }",
            "",
            "        common_policy.set_rules(common_policy.Rules(rules))",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers?all_tenants=1')",
            "        res = self.controller.index(req)",
            "",
            "        self.assertTrue('servers' in res)",
            "",
            "    def test_all_tenants_fail_policy(self):",
            "        def fake_get_all(context, filters=None, sort_key=None,",
            "                         sort_dir='desc', limit=None, marker=None,",
            "                         columns_to_join=None):",
            "            self.assertNotEqual(filters, None)",
            "            return [fakes.stub_instance(100)]",
            "",
            "        rules = {",
            "            \"compute:get_all_tenants\":",
            "                common_policy.parse_rule(\"project_id:non_fake\"),",
            "            \"compute:get_all\":",
            "                common_policy.parse_rule(\"project_id:fake\"),",
            "        }",
            "",
            "        common_policy.set_rules(common_policy.Rules(rules))",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       fake_get_all)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers?all_tenants=1')",
            "        self.assertRaises(exception.PolicyNotAuthorized,",
            "                          self.controller.index, req)",
            "",
            "    def test_get_servers_allows_flavor(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('flavor' in search_opts)",
            "            # flavor is an integer ID",
            "            self.assertEqual(search_opts['flavor'], '12345')",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers?flavor=12345')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_with_bad_flavor(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers?flavor=abcde')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 0)",
            "",
            "    def test_get_servers_allows_status(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('vm_state' in search_opts)",
            "            self.assertEqual(search_opts['vm_state'], vm_states.ACTIVE)",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers?status=active')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_invalid_status(self):",
            "        # Test getting servers by invalid status.",
            "        req = fakes.HTTPRequestV3.blank('/servers?status=baloney',",
            "                                      use_admin_context=False)",
            "        servers = self.controller.index(req)['servers']",
            "        self.assertEqual(len(servers), 0)",
            "",
            "    def test_get_servers_deleted_status_as_user(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers?status=deleted',",
            "                                      use_admin_context=False)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.detail, req)",
            "",
            "    def test_get_servers_deleted_status_as_admin(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertTrue('vm_state' in search_opts)",
            "            self.assertEqual(search_opts['vm_state'], 'deleted')",
            "",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers?status=deleted',",
            "                                      use_admin_context=True)",
            "",
            "        servers = self.controller.detail(req)['servers']",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_allows_name(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('name' in search_opts)",
            "            self.assertEqual(search_opts['name'], 'whee.*')",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers?name=whee.*')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_allows_changes_since(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('changes_since' in search_opts)",
            "            changes_since = datetime.datetime(2011, 1, 24, 17, 8, 1,",
            "                                              tzinfo=iso8601.iso8601.UTC)",
            "            self.assertEqual(search_opts['changes_since'], changes_since)",
            "            self.assertTrue('deleted' not in search_opts)",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        params = 'changes_since=2011-01-24T17:08:01Z'",
            "        req = fakes.HTTPRequestV3.blank('/servers?%s' % params)",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_allows_changes_since_bad_value(self):",
            "        params = 'changes_since=asdf'",
            "        req = fakes.HTTPRequestV3.blank('/servers?%s' % params)",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.index, req)",
            "",
            "    def test_get_servers_admin_filters_as_user(self):",
            "        \"\"\"Test getting servers by admin-only or unknown options when",
            "        context is not admin. Make sure the admin and unknown options",
            "        are stripped before they get to compute_api.get_all()",
            "        \"\"\"",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            # Allowed by user",
            "            self.assertTrue('name' in search_opts)",
            "            self.assertTrue('ip' in search_opts)",
            "            # OSAPI converts status to vm_state",
            "            self.assertTrue('vm_state' in search_opts)",
            "            # Allowed only by admins with admin API on",
            "            self.assertFalse('unknown_option' in search_opts)",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        query_str = \"name=foo&ip=10.*&status=active&unknown_option=meow\"",
            "        req = fakes.HTTPRequest.blank('/servers?%s' % query_str)",
            "        res = self.controller.index(req)",
            "",
            "        servers = res['servers']",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_admin_options_as_admin(self):",
            "        \"\"\"Test getting servers by admin-only or unknown options when",
            "        context is admin. All options should be passed",
            "        \"\"\"",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            # Allowed by user",
            "            self.assertTrue('name' in search_opts)",
            "            # OSAPI converts status to vm_state",
            "            self.assertTrue('vm_state' in search_opts)",
            "            # Allowed only by admins with admin API on",
            "            self.assertTrue('ip' in search_opts)",
            "            self.assertTrue('unknown_option' in search_opts)",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        query_str = \"name=foo&ip=10.*&status=active&unknown_option=meow\"",
            "        req = fakes.HTTPRequestV3.blank('/servers?%s' % query_str,",
            "                                      use_admin_context=True)",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_allows_ip(self):",
            "        \"\"\"Test getting servers by ip.\"\"\"",
            "",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('ip' in search_opts)",
            "            self.assertEqual(search_opts['ip'], '10\\..*')",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers?ip=10\\..*')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_admin_allows_ip6(self):",
            "        \"\"\"Test getting servers by ip6 with admin_api enabled and",
            "        admin context",
            "        \"\"\"",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('ip6' in search_opts)",
            "            self.assertEqual(search_opts['ip6'], 'ffff.*')",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers?ip6=ffff.*',",
            "                                      use_admin_context=True)",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_all_server_details(self):",
            "        expected_flavor = {",
            "                \"id\": \"1\",",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": 'http://localhost/flavors/1',",
            "                        },",
            "                    ],",
            "                }",
            "        expected_image = {",
            "            \"id\": \"10\",",
            "            \"links\": [",
            "                {",
            "                    \"rel\": \"bookmark\",",
            "                    \"href\": 'http://localhost/images/10',",
            "                    },",
            "                ],",
            "            }",
            "        req = fakes.HTTPRequestV3.blank('/servers/detail')",
            "        res_dict = self.controller.detail(req)",
            "",
            "        for i, s in enumerate(res_dict['servers']):",
            "            self.assertEqual(s['id'], fakes.get_fake_uuid(i))",
            "            self.assertEqual(s['host_id'], '')",
            "            self.assertEqual(s['name'], 'server%d' % (i + 1))",
            "            self.assertEqual(s['image'], expected_image)",
            "            self.assertEqual(s['flavor'], expected_flavor)",
            "            self.assertEqual(s['status'], 'BUILD')",
            "            self.assertEqual(s['metadata']['seq'], str(i + 1))",
            "",
            "    def test_get_all_server_details_with_host(self):",
            "        '''",
            "        We want to make sure that if two instances are on the same host, then",
            "        they return the same host_id. If two instances are on different hosts,",
            "        they should return different host_ids. In this test, there are 5",
            "        instances - 2 on one host and 3 on another.",
            "        '''",
            "",
            "        def return_servers_with_host(context, *args, **kwargs):",
            "            return [fakes.stub_instance(i + 1, 'fake', 'fake', host=i % 2,",
            "                                        uuid=fakes.get_fake_uuid(i))",
            "                    for i in xrange(5)]",
            "",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       return_servers_with_host)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers/detail')",
            "        res_dict = self.controller.detail(req)",
            "",
            "        server_list = res_dict['servers']",
            "        host_ids = [server_list[0]['host_id'], server_list[1]['host_id']]",
            "        self.assertTrue(host_ids[0] and host_ids[1])",
            "        self.assertNotEqual(host_ids[0], host_ids[1])",
            "",
            "        for i, s in enumerate(server_list):",
            "            self.assertEqual(s['id'], fakes.get_fake_uuid(i))",
            "            self.assertEqual(s['host_id'], host_ids[i % 2])",
            "            self.assertEqual(s['name'], 'server%d' % (i + 1))",
            "",
            "",
            "class ServersControllerDeleteTest(ControllerTest):",
            "",
            "    def setUp(self):",
            "        super(ServersControllerDeleteTest, self).setUp()",
            "        self.server_delete_called = False",
            "",
            "        def instance_destroy_mock(*args, **kwargs):",
            "            self.server_delete_called = True",
            "",
            "        self.stubs.Set(db, 'instance_destroy', instance_destroy_mock)",
            "",
            "    def _create_delete_request(self, uuid):",
            "        fakes.stub_out_instance_quota(self.stubs, 0, 10)",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s' % uuid)",
            "        req.method = 'DELETE'",
            "        return req",
            "",
            "    def _delete_server_instance(self, uuid=FAKE_UUID):",
            "        req = self._create_delete_request(uuid)",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                fakes.fake_instance_get(vm_state=vm_states.ACTIVE))",
            "        self.controller.delete(req, uuid)",
            "",
            "    def test_delete_server_instance(self):",
            "        self._delete_server_instance()",
            "        self.assertTrue(self.server_delete_called)",
            "",
            "    def test_delete_server_instance_not_found(self):",
            "        self.assertRaises(webob.exc.HTTPNotFound,",
            "                          self._delete_server_instance,",
            "                          uuid='non-existent-uuid')",
            "",
            "    def test_delete_server_instance_while_building(self):",
            "        req = self._create_delete_request(FAKE_UUID)",
            "        self.controller.delete(req, FAKE_UUID)",
            "",
            "        self.assertTrue(self.server_delete_called)",
            "",
            "    def test_delete_server_instance_while_resize(self):",
            "        req = self._create_delete_request(FAKE_UUID)",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                fakes.fake_instance_get(vm_state=vm_states.ACTIVE,",
            "                                        task_state=task_states.RESIZE_PREP))",
            "",
            "        self.controller.delete(req, FAKE_UUID)",
            "        # Delete shoud be allowed in any case, even during resizing,",
            "        # because it may get stuck.",
            "        self.assertTrue(self.server_delete_called)",
            "",
            "",
            "class ServersControllerRebuildInstanceTest(ControllerTest):",
            "",
            "    image_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    image_href = 'http://localhost/v3/fake/images/%s' % image_uuid",
            "",
            "    def setUp(self):",
            "        super(ServersControllerRebuildInstanceTest, self).setUp()",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                       fakes.fake_instance_get(vm_state=vm_states.ACTIVE))",
            "        self.body = {",
            "            'rebuild': {",
            "                'name': 'new_name',",
            "                'image_ref': self.image_href,",
            "                'metadata': {",
            "                    'open': 'stack',",
            "                },",
            "            },",
            "        }",
            "        self.req = fakes.HTTPRequest.blank('/fake/servers/a/action')",
            "        self.req.method = 'POST'",
            "        self.req.headers[\"content-type\"] = \"application/json\"",
            "",
            "    def test_rebuild_instance_with_access_ipv4_bad_format(self):",
            "        # proper local hrefs must start with 'http://localhost/v2/'",
            "        self.body['rebuild']['access_ip_v4'] = 'bad_format'",
            "        self.body['rebuild']['access_ip_v6'] = 'fead::1234'",
            "        self.body['rebuild']['metadata']['hello'] = 'world'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_with_blank_metadata_key(self):",
            "        self.body['rebuild']['access_ip_v4'] = '0.0.0.0'",
            "        self.body['rebuild']['access_ip_v6'] = 'fead::1234'",
            "        self.body['rebuild']['metadata'][''] = 'world'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_with_metadata_key_too_long(self):",
            "        self.body['rebuild']['access_ip_v4'] = '0.0.0.0'",
            "        self.body['rebuild']['access_ip_v6'] = 'fead::1234'",
            "        self.body['rebuild']['metadata'][('a' * 260)] = 'world'",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_with_metadata_value_too_long(self):",
            "        self.body['rebuild']['access_ip_v4'] = '0.0.0.0'",
            "        self.body['rebuild']['access_ip_v6'] = 'fead::1234'",
            "        self.body['rebuild']['metadata']['key1'] = ('a' * 260)",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller._action_rebuild, self.req,",
            "                          FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_fails_when_min_ram_too_small(self):",
            "        # make min_ram larger than our instance ram size",
            "        def fake_get_image(self, context, image_href):",
            "            return dict(id='76fa36fc-c930-4bf3-8c8a-ea2a2420deb6',",
            "                        name='public image', is_public=True,",
            "                        status='active', properties={'key1': 'value1'},",
            "                        min_ram=\"4096\", min_disk=\"10\")",
            "",
            "        self.stubs.Set(fake._FakeImageService, 'show', fake_get_image)",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_fails_when_min_disk_too_small(self):",
            "        # make min_disk larger than our instance disk size",
            "        def fake_get_image(self, context, image_href):",
            "            return dict(id='76fa36fc-c930-4bf3-8c8a-ea2a2420deb6',",
            "                        name='public image', is_public=True,",
            "                        status='active', properties={'key1': 'value1'},",
            "                        min_ram=\"128\", min_disk=\"100000\")",
            "",
            "        self.stubs.Set(fake._FakeImageService, 'show', fake_get_image)",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild, self.req,",
            "                          FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_image_too_large(self):",
            "        # make image size larger than our instance disk size",
            "        size = str(1000 * (1024 ** 3))",
            "",
            "        def fake_get_image(self, context, image_href):",
            "            return dict(id='76fa36fc-c930-4bf3-8c8a-ea2a2420deb6',",
            "                        name='public image', is_public=True,",
            "                        status='active', size=size)",
            "",
            "        self.stubs.Set(fake._FakeImageService, 'show', fake_get_image)",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_with_deleted_image(self):",
            "        def fake_get_image(self, context, image_href):",
            "            return dict(id='76fa36fc-c930-4bf3-8c8a-ea2a2420deb6',",
            "                        name='public image', is_public=True,",
            "                        status='DELETED')",
            "",
            "        self.stubs.Set(fake._FakeImageService, 'show', fake_get_image)",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_with_access_ipv6_bad_format(self):",
            "        self.body['rebuild']['access_ip_v4'] = '1.2.3.4'",
            "        self.body['rebuild']['access_ip_v6'] = 'bad_format'",
            "        self.body['rebuild']['metadata']['hello'] = 'world'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.req.headers[\"content-type\"] = \"application/json\"",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_start(self):",
            "        self.mox.StubOutWithMock(compute_api.API, 'start')",
            "        compute_api.API.start(mox.IgnoreArg(), mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s/action' % FAKE_UUID)",
            "        body = dict(start=\"\")",
            "        self.controller._start_server(req, FAKE_UUID, body)",
            "",
            "    def test_start_not_ready(self):",
            "        self.stubs.Set(compute_api.API, 'start', fake_start_stop_not_ready)",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s/action' % FAKE_UUID)",
            "        body = dict(start=\"\")",
            "        self.assertRaises(webob.exc.HTTPConflict,",
            "            self.controller._start_server, req, FAKE_UUID, body)",
            "",
            "    def test_stop(self):",
            "        self.mox.StubOutWithMock(compute_api.API, 'stop')",
            "        compute_api.API.stop(mox.IgnoreArg(), mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s/action' % FAKE_UUID)",
            "        body = dict(stop=\"\")",
            "        self.controller._stop_server(req, FAKE_UUID, body)",
            "",
            "    def test_stop_not_ready(self):",
            "        self.stubs.Set(compute_api.API, 'stop', fake_start_stop_not_ready)",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s/action' % FAKE_UUID)",
            "        body = dict(start=\"\")",
            "        self.assertRaises(webob.exc.HTTPConflict,",
            "            self.controller._stop_server, req, FAKE_UUID, body)",
            "",
            "    def test_start_with_bogus_id(self):",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                       fake_instance_get_by_uuid_not_found)",
            "        req = fakes.HTTPRequestV3.blank('/servers/test_inst/action')",
            "        body = dict(start=\"\")",
            "        self.assertRaises(webob.exc.HTTPNotFound,",
            "            self.controller._start_server, req, 'test_inst', body)",
            "",
            "    def test_stop_with_bogus_id(self):",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                       fake_instance_get_by_uuid_not_found)",
            "        req = fakes.HTTPRequestV3.blank('/servers/test_inst/action')",
            "        body = dict(start=\"\")",
            "        self.assertRaises(webob.exc.HTTPNotFound,",
            "            self.controller._stop_server, req, 'test_inst', body)",
            "",
            "",
            "class ServersControllerUpdateTest(ControllerTest):",
            "",
            "    def _get_request(self, body=None, options=None):",
            "        if options:",
            "            self.stubs.Set(db, 'instance_get',",
            "                           fakes.fake_instance_get(**options))",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s' % FAKE_UUID)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(body)",
            "        return req",
            "",
            "    def test_update_server_all_attributes(self):",
            "        body = {'server': {",
            "                  'name': 'server_test',",
            "                  'access_ip_v4': '0.0.0.0',",
            "                  'access_ip_v6': 'beef::0123',",
            "               }}",
            "        req = self._get_request(body, {'name': 'server_test',",
            "                                       'access_ipv4': '0.0.0.0',",
            "                                       'access_ipv6': 'beef::0123'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['name'], 'server_test')",
            "        self.assertEqual(res_dict['server']['access_ip_v4'], '0.0.0.0')",
            "        self.assertEqual(res_dict['server']['access_ip_v6'], 'beef::123')",
            "",
            "    def test_update_server_invalid_xml_raises_lookup(self):",
            "        req = webob.Request.blank('/v3/servers/%s' % FAKE_UUID)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/xml'",
            "        #xml request which raises LookupError",
            "        req.body = \"\"\"<?xml version=\"1.0\" encoding=\"TF-8\"?>",
            "            <metadata",
            "            xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "            key=\"Label\"></metadata>\"\"\"",
            "        res = req.get_response(fakes.wsgi_app_v3())",
            "        self.assertEqual(res.status_int, 400)",
            "        res_dict = jsonutils.loads(res.body)",
            "        self.assertEqual(res_dict['badRequest']['message'],",
            "                         \"Malformed request body\")",
            "",
            "    def test_update_server_invalid_xml_raises_expat(self):",
            "        req = webob.Request.blank('/v3/servers/%s' % FAKE_UUID)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/xml'",
            "        #xml request which raises ExpatError",
            "        req.body = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "            <metadata",
            "            xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "            key=\"Label\"></meta>\"\"\"",
            "        res = req.get_response(fakes.wsgi_app_v3())",
            "        self.assertEqual(res.status_int, 400)",
            "        res_dict = jsonutils.loads(res.body)",
            "        self.assertEqual(res_dict['badRequest']['message'],",
            "                         \"Malformed request body\")",
            "",
            "    def test_update_server_name(self):",
            "        body = {'server': {'name': 'server_test'}}",
            "        req = self._get_request(body, {'name': 'server_test'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['name'], 'server_test')",
            "",
            "    def test_update_server_name_too_long(self):",
            "        body = {'server': {'name': 'x' * 256}}",
            "        req = self._get_request(body, {'name': 'server_test'})",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.update,",
            "                            req, FAKE_UUID, body)",
            "",
            "    def test_update_server_access_ipv4(self):",
            "        body = {'server': {'access_ip_v4': '0.0.0.0'}}",
            "        req = self._get_request(body, {'access_ipv4': '0.0.0.0'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['access_ip_v4'], '0.0.0.0')",
            "",
            "    def test_update_server_access_ipv4_bad_format(self):",
            "        body = {'server': {'access_ip_v4': 'bad_format'}}",
            "        req = self._get_request(body, {'access_ipv4': '0.0.0.0'})",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.update,",
            "                          req, FAKE_UUID, body)",
            "",
            "    def test_update_server_access_ipv4_none(self):",
            "        body = {'server': {'access_ip_v4': None}}",
            "        req = self._get_request(body, {'access_ipv4': '0.0.0.0'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['access_ip_v4'], '')",
            "",
            "    def test_update_server_access_ipv4_blank(self):",
            "        body = {'server': {'access_ip_v4': ''}}",
            "        req = self._get_request(body, {'access_ipv4': '0.0.0.0'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['access_ip_v4'], '')",
            "",
            "    def test_update_server_access_ipv6(self):",
            "        body = {'server': {'access_ip_v6': 'beef::0123'}}",
            "        req = self._get_request(body, {'access_ipv6': 'beef::0123'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['access_ip_v6'], 'beef::123')",
            "",
            "    def test_update_server_access_ipv6_bad_format(self):",
            "        body = {'server': {'access_ip_v6': 'bad_format'}}",
            "        req = self._get_request(body, {'access_ipv6': 'beef::0123'})",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.update,",
            "                          req, FAKE_UUID, body)",
            "",
            "    def test_update_server_access_ipv6_none(self):",
            "        body = {'server': {'access_ip_v6': None}}",
            "        req = self._get_request(body, {'access_ipv6': 'beef::0123'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['access_ip_v6'], '')",
            "",
            "    def test_update_server_access_ipv6_blank(self):",
            "        body = {'server': {'access_ip_v6': ''}}",
            "        req = self._get_request(body, {'access_ipv6': 'beef::0123'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['access_ip_v6'], '')",
            "",
            "    def test_update_server_adminPass_ignored(self):",
            "        inst_dict = dict(name='server_test', adminPass='bacon')",
            "        body = dict(server=inst_dict)",
            "",
            "        def server_update(context, id, params):",
            "            filtered_dict = {",
            "                'display_name': 'server_test',",
            "            }",
            "            self.assertEqual(params, filtered_dict)",
            "            filtered_dict['uuid'] = id",
            "            return filtered_dict",
            "",
            "        self.stubs.Set(db, 'instance_update', server_update)",
            "        # FIXME (comstud)",
            "        #        self.stubs.Set(db, 'instance_get',",
            "        #                return_server_with_attributes(name='server_test'))",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers/%s' % FAKE_UUID)",
            "        req.method = 'PUT'",
            "        req.content_type = \"application/json\"",
            "        req.body = jsonutils.dumps(body)",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['name'], 'server_test')",
            "",
            "    def test_update_server_not_found(self):",
            "        def fake_get(*args, **kwargs):",
            "            raise exception.InstanceNotFound(instance_id='fake')",
            "",
            "        self.stubs.Set(compute_api.API, 'get', fake_get)",
            "        body = {'server': {'name': 'server_test'}}",
            "        req = self._get_request(body)",
            "        self.assertRaises(webob.exc.HTTPNotFound, self.controller.update,",
            "                          req, FAKE_UUID, body)",
            "",
            "    def test_update_server_not_found_on_update(self):",
            "        def fake_update(*args, **kwargs):",
            "            raise exception.InstanceNotFound(instance_id='fake')",
            "",
            "        self.stubs.Set(db, 'instance_update_and_get_original', fake_update)",
            "        body = {'server': {'name': 'server_test'}}",
            "        req = self._get_request(body)",
            "        self.assertRaises(webob.exc.HTTPNotFound, self.controller.update,",
            "                          req, FAKE_UUID, body)",
            "",
            "",
            "class ServerStatusTest(test.TestCase):",
            "",
            "    def setUp(self):",
            "        super(ServerStatusTest, self).setUp()",
            "        fakes.stub_out_nw_api(self.stubs)",
            "",
            "        ext_info = plugins.LoadedExtensionInfo()",
            "        self.controller = servers.ServersController(extension_info=ext_info)",
            "",
            "    def _get_with_state(self, vm_state, task_state=None):",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                fakes.fake_instance_get(vm_state=vm_state,",
            "                                        task_state=task_state))",
            "",
            "        request = fakes.HTTPRequestV3.blank('/servers/%s' % FAKE_UUID)",
            "        return self.controller.show(request, FAKE_UUID)",
            "",
            "    def test_active(self):",
            "        response = self._get_with_state(vm_states.ACTIVE)",
            "        self.assertEqual(response['server']['status'], 'ACTIVE')",
            "",
            "    def test_reboot(self):",
            "        response = self._get_with_state(vm_states.ACTIVE,",
            "                                        task_states.REBOOTING)",
            "        self.assertEqual(response['server']['status'], 'REBOOT')",
            "",
            "    def test_reboot_hard(self):",
            "        response = self._get_with_state(vm_states.ACTIVE,",
            "                                        task_states.REBOOTING_HARD)",
            "        self.assertEqual(response['server']['status'], 'HARD_REBOOT')",
            "",
            "    def test_reboot_resize_policy_fail(self):",
            "        def fake_get_server(context, req, id):",
            "            return fakes.stub_instance(id)",
            "",
            "        self.stubs.Set(self.controller, '_get_server', fake_get_server)",
            "",
            "        rule = {'compute:reboot':",
            "                common_policy.parse_rule('role:admin')}",
            "        common_policy.set_rules(common_policy.Rules(rule))",
            "        req = fakes.HTTPRequestV3.blank('/servers/1234/action')",
            "        self.assertRaises(exception.PolicyNotAuthorized,",
            "                self.controller._action_reboot, req, '1234',",
            "                {'reboot': {'type': 'HARD'}})",
            "",
            "    def test_rebuild(self):",
            "        response = self._get_with_state(vm_states.ACTIVE,",
            "                                        task_states.REBUILDING)",
            "        self.assertEqual(response['server']['status'], 'REBUILD')",
            "",
            "    def test_rebuild_error(self):",
            "        response = self._get_with_state(vm_states.ERROR)",
            "        self.assertEqual(response['server']['status'], 'ERROR')",
            "",
            "    def test_resize(self):",
            "        response = self._get_with_state(vm_states.ACTIVE,",
            "                                        task_states.RESIZE_PREP)",
            "        self.assertEqual(response['server']['status'], 'RESIZE')",
            "",
            "    def test_confirm_resize_policy_fail(self):",
            "        def fake_get_server(context, req, id):",
            "            return fakes.stub_instance(id)",
            "",
            "        self.stubs.Set(self.controller, '_get_server', fake_get_server)",
            "",
            "        rule = {'compute:confirm_resize':",
            "                common_policy.parse_rule('role:admin')}",
            "        common_policy.set_rules(common_policy.Rules(rule))",
            "        req = fakes.HTTPRequestV3.blank('/servers/1234/action')",
            "        self.assertRaises(exception.PolicyNotAuthorized,",
            "                self.controller._action_confirm_resize, req, '1234', {})",
            "",
            "    def test_verify_resize(self):",
            "        response = self._get_with_state(vm_states.RESIZED, None)",
            "        self.assertEqual(response['server']['status'], 'VERIFY_RESIZE')",
            "",
            "    def test_revert_resize(self):",
            "        response = self._get_with_state(vm_states.RESIZED,",
            "                                        task_states.RESIZE_REVERTING)",
            "        self.assertEqual(response['server']['status'], 'REVERT_RESIZE')",
            "",
            "    def test_revert_resize_policy_fail(self):",
            "        def fake_get_server(context, req, id):",
            "            return fakes.stub_instance(id)",
            "",
            "        self.stubs.Set(self.controller, '_get_server', fake_get_server)",
            "",
            "        rule = {'compute:revert_resize':",
            "                common_policy.parse_rule('role:admin')}",
            "        common_policy.set_rules(common_policy.Rules(rule))",
            "        req = fakes.HTTPRequestV3.blank('/servers/1234/action')",
            "        self.assertRaises(exception.PolicyNotAuthorized,",
            "                self.controller._action_revert_resize, req, '1234', {})",
            "",
            "    def test_password_update(self):",
            "        response = self._get_with_state(vm_states.ACTIVE,",
            "                                        task_states.UPDATING_PASSWORD)",
            "        self.assertEqual(response['server']['status'], 'PASSWORD')",
            "",
            "    def test_stopped(self):",
            "        response = self._get_with_state(vm_states.STOPPED)",
            "        self.assertEqual(response['server']['status'], 'SHUTOFF')",
            "",
            "",
            "class ServersControllerCreateTest(test.TestCase):",
            "    image_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    flavor_ref = 'http://localhost/123/flavors/3'",
            "",
            "    def setUp(self):",
            "        \"\"\"Shared implementation for tests below that create instance.\"\"\"",
            "        super(ServersControllerCreateTest, self).setUp()",
            "",
            "        self.flags(verbose=True,",
            "                   enable_instance_password=True)",
            "        self.instance_cache_num = 0",
            "        self.instance_cache_by_id = {}",
            "        self.instance_cache_by_uuid = {}",
            "",
            "        ext_info = plugins.LoadedExtensionInfo()",
            "        self.controller = servers.ServersController(extension_info=ext_info)",
            "",
            "        def instance_create(context, inst):",
            "            inst_type = flavors.get_flavor_by_flavor_id(3)",
            "            image_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "            def_image_ref = 'http://localhost/images/%s' % image_uuid",
            "            self.instance_cache_num += 1",
            "            instance = fake_instance.fake_db_instance(**{",
            "                'id': self.instance_cache_num,",
            "                'display_name': inst['display_name'] or 'test',",
            "                'uuid': FAKE_UUID,",
            "                'instance_type': dict(inst_type),",
            "                'access_ip_v4': '1.2.3.4',",
            "                'access_ip_v6': 'fead::1234',",
            "                'image_ref': inst.get('image_ref', def_image_ref),",
            "                'user_id': 'fake',",
            "                'project_id': 'fake',",
            "                'reservation_id': inst['reservation_id'],",
            "                \"created_at\": datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "                \"updated_at\": datetime.datetime(2010, 11, 11, 11, 0, 0),",
            "                \"config_drive\": None,",
            "                \"progress\": 0,",
            "                \"fixed_ips\": [],",
            "                \"task_state\": \"\",",
            "                \"vm_state\": \"\",",
            "                \"security_groups\": inst['security_groups'],",
            "            })",
            "",
            "            self.instance_cache_by_id[instance['id']] = instance",
            "            self.instance_cache_by_uuid[instance['uuid']] = instance",
            "            return instance",
            "",
            "        def instance_get(context, instance_id):",
            "            \"\"\"Stub for compute/api create() pulling in instance after",
            "            scheduling",
            "            \"\"\"",
            "            return self.instance_cache_by_id[instance_id]",
            "",
            "        def instance_update(context, uuid, values):",
            "            instance = self.instance_cache_by_uuid[uuid]",
            "            instance.update(values)",
            "            return instance",
            "",
            "        def rpc_call_wrapper(context, topic, msg, timeout=None):",
            "            \"\"\"Stub out the scheduler creating the instance entry.\"\"\"",
            "            if (topic == CONF.scheduler_topic and",
            "                    msg['method'] == 'run_instance'):",
            "                request_spec = msg['args']['request_spec']",
            "                num_instances = request_spec.get('num_instances', 1)",
            "                instances = []",
            "                for x in xrange(num_instances):",
            "                    instances.append(instance_create(context,",
            "                        request_spec['instance_properties']))",
            "                return instances",
            "",
            "        def server_update(context, instance_uuid, params, update_cells=True):",
            "            inst = self.instance_cache_by_uuid[instance_uuid]",
            "            inst.update(params)",
            "            return (inst, inst)",
            "",
            "        def fake_method(*args, **kwargs):",
            "            pass",
            "",
            "        def project_get_networks(context, user_id):",
            "            return dict(id='1', host='localhost')",
            "",
            "        def queue_get_for(context, *args):",
            "            return 'network_topic'",
            "",
            "        fakes.stub_out_rate_limiting(self.stubs)",
            "        fakes.stub_out_key_pair_funcs(self.stubs)",
            "        fake.stub_out_image_service(self.stubs)",
            "        fakes.stub_out_nw_api(self.stubs)",
            "        self.stubs.Set(uuid, 'uuid4', fake_gen_uuid)",
            "        self.stubs.Set(db, 'instance_add_security_group',",
            "                       return_security_group)",
            "        self.stubs.Set(db, 'project_get_networks',",
            "                       project_get_networks)",
            "        self.stubs.Set(db, 'instance_create', instance_create)",
            "        self.stubs.Set(db, 'instance_system_metadata_update',",
            "                fake_method)",
            "        self.stubs.Set(db, 'instance_get', instance_get)",
            "        self.stubs.Set(db, 'instance_update', instance_update)",
            "        self.stubs.Set(rpc, 'cast', fake_method)",
            "        self.stubs.Set(rpc, 'call', rpc_call_wrapper)",
            "        self.stubs.Set(db, 'instance_update_and_get_original',",
            "                server_update)",
            "        self.stubs.Set(rpc, 'queue_get_for', queue_get_for)",
            "        self.stubs.Set(manager.VlanManager, 'allocate_fixed_ip',",
            "                       fake_method)",
            "        self.body = {",
            "            'server': {",
            "                'min_count': 2,",
            "                'name': 'server_test',",
            "                'image_ref': self.image_uuid,",
            "                'flavor_ref': self.flavor_ref,",
            "                'metadata': {",
            "                    'hello': 'world',",
            "                    'open': 'stack',",
            "                    },",
            "                },",
            "            }",
            "        self.bdm = [{'delete_on_termination': 1,",
            "                     'device_name': 123,",
            "                     'volume_size': 1,",
            "                     'volume_id': '11111111-1111-1111-1111-111111111111'}]",
            "",
            "        self.req = fakes.HTTPRequest.blank('/fake/servers')",
            "        self.req.method = 'POST'",
            "        self.req.headers[\"content-type\"] = \"application/json\"",
            "",
            "    def _check_admin_pass_len(self, server_dict):",
            "        \"\"\"utility function - check server_dict for admin_pass length.\"\"\"",
            "        self.assertEqual(CONF.password_length,",
            "                         len(server_dict[\"admin_pass\"]))",
            "",
            "    def _check_admin_pass_missing(self, server_dict):",
            "        \"\"\"utility function - check server_dict for absence of admin_pass.\"\"\"",
            "        self.assertTrue(\"admin_pass\" not in server_dict)",
            "",
            "    def _test_create_instance(self):",
            "        image_uuid = 'c905cedb-7281-47e4-8a62-f26bc5fc4c77'",
            "        self.body['server']['image_ref'] = image_uuid",
            "        self.body['server']['flavor_ref'] = 2",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        server = self.controller.create(self.req, self.body).obj['server']",
            "        self._check_admin_pass_len(server)",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_server_bad_image_href(self):",
            "        image_href = 1",
            "        self.body['server']['min_count'] = 1",
            "        self.body['server']['image_ref'] = image_href,",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create,",
            "                          self.req, self.body)",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-networks extension tests",
            "    # def test_create_server_with_invalid_networks_parameter(self):",
            "    #     self.ext_mgr.extensions = {'os-networks': 'fake'}",
            "    #     image_href = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    #     flavor_ref = 'http://localhost/123/flavors/3'",
            "    #     body = {",
            "    #         'server': {",
            "    #         'name': 'server_test',",
            "    #         'imageRef': image_href,",
            "    #         'flavorRef': flavor_ref,",
            "    #         'networks': {'uuid': '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'},",
            "    #         }",
            "    #     }",
            "    #     req = fakes.HTTPRequest.blank('/v2/fake/servers')",
            "    #     req.method = 'POST'",
            "    #     req.body = jsonutils.dumps(body)",
            "    #     req.headers[\"content-type\"] = \"application/json\"",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self.controller.create,",
            "    #                       req,",
            "    #                       body)",
            "",
            "    def test_create_server_with_deleted_image(self):",
            "        # Get the fake image service so we can set the status to deleted",
            "        (image_service, image_id) = glance.get_remote_image_service(",
            "                context, '')",
            "        image_service.update(context, self.image_uuid, {'status': 'DELETED'})",
            "        self.addCleanup(image_service.update, context, self.image_uuid,",
            "                        {'status': 'active'})",
            "",
            "        self.body['server']['flavor_ref'] = 2",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        with testtools.ExpectedException(",
            "                webob.exc.HTTPBadRequest,",
            "                'Image 76fa36fc-c930-4bf3-8c8a-ea2a2420deb6 is not active.'):",
            "            self.controller.create(self.req, self.body)",
            "",
            "    def test_create_server_image_too_large(self):",
            "        # Get the fake image service so we can set the status to deleted",
            "        (image_service, image_id) = glance.get_remote_image_service(",
            "                                    context, self.image_uuid)",
            "",
            "        image = image_service.show(context, image_id)",
            "",
            "        orig_size = image['size']",
            "        new_size = str(1000 * (1024 ** 3))",
            "        image_service.update(context, self.image_uuid, {'size': new_size})",
            "",
            "        self.addCleanup(image_service.update, context, self.image_uuid,",
            "                        {'size': orig_size})",
            "",
            "        self.body['server']['flavor_ref'] = 2",
            "        self.req.body = jsonutils.dumps(self.body)",
            "",
            "        with testtools.ExpectedException(",
            "                webob.exc.HTTPBadRequest,",
            "                \"Instance type's disk is too small for requested image.\"):",
            "            self.controller.create(self.req, self.body)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multiple-create extension tests",
            "    # def test_create_instance_invalid_negative_min(self):",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     image_href = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    #     flavor_ref = 'http://localhost/123/flavors/3'",
            "",
            "    #     body = {",
            "    #         'server': {",
            "    #             'min_count': -1,",
            "    #             'name': 'server_test',",
            "    #             'imageRef': image_href,",
            "    #             'flavorRef': flavor_ref,",
            "    #         }",
            "    #     }",
            "    #     req = fakes.HTTPRequestV3.blank('/servers')",
            "    #     req.method = 'POST'",
            "    #     req.body = jsonutils.dumps(body)",
            "    #     req.headers[\"content-type\"] = \"application/json\"",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self.controller.create,",
            "    #                       req,",
            "    #                       body)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multiple-create extension tests",
            "    # def test_create_instance_invalid_negative_max(self):",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     image_href = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    #     flavor_ref = 'http://localhost/123/flavors/3'",
            "",
            "    #     body = {",
            "    #         'server': {",
            "    #             'max_count': -1,",
            "    #             'name': 'server_test',",
            "    #             'imageRef': image_href,",
            "    #             'flavorRef': flavor_ref,",
            "    #         }",
            "    #     }",
            "    #     req = fakes.HTTPRequestV3.blank('/servers')",
            "    #     req.method = 'POST'",
            "    #     req.body = jsonutils.dumps(body)",
            "    #     req.headers[\"content-type\"] = \"application/json\"",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self.controller.create,",
            "    #                       req,",
            "    #                       body)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multiple-create extension tests",
            "    # def test_create_instance_invalid_alpha_min(self):",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     image_href = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    #     flavor_ref = 'http://localhost/123/flavors/3'",
            "",
            "    #     body = {",
            "    #         'server': {",
            "    #             'min_count': 'abcd',",
            "    #             'name': 'server_test',",
            "    #             'imageRef': image_href,",
            "    #             'flavorRef': flavor_ref,",
            "    #         }",
            "    #     }",
            "    #     req = fakes.HTTPRequestV3.blank('/servers')",
            "    #     req.method = 'POST'",
            "    #     req.body = jsonutils.dumps(body)",
            "    #     req.headers[\"content-type\"] = \"application/json\"",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self.controller.create,",
            "    #                       req,",
            "    #                       body)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multiple-create extension tests",
            "    # def test_create_instance_invalid_alpha_max(self):",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     image_href = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    #     flavor_ref = 'http://localhost/123/flavors/3'",
            "",
            "    #     body = {",
            "    #         'server': {",
            "    #             'max_count': 'abcd',",
            "    #             'name': 'server_test',",
            "    #             'imageRef': image_href,",
            "    #             'flavorRef': flavor_ref,",
            "    #         }",
            "    #     }",
            "    #     req = fakes.HTTPRequestV3.blank('/servers')",
            "    #     req.method = 'POST'",
            "    #     req.body = jsonutils.dumps(body)",
            "    #     req.headers[\"content-type\"] = \"application/json\"",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self.controller.create,",
            "    #                       req,",
            "    #                       body)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multiple-create extension tests",
            "    # def test_create_multiple_instances(self):",
            "    #     \"\"\"Test creating multiple instances but not asking for",
            "    #     reservation_id",
            "    #     \"\"\"",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     image_href = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    #     flavor_ref = 'http://localhost/123/flavors/3'",
            "    #     body = {",
            "    #         'server': {",
            "    #             'min_count': 2,",
            "    #             'name': 'server_test',",
            "    #             'imageRef': image_href,",
            "    #             'flavorRef': flavor_ref,",
            "    #             'metadata': {'hello': 'world',",
            "    #                          'open': 'stack'},",
            "    #             'personality': []",
            "    #         }",
            "    #     }",
            "",
            "    #     req = fakes.HTTPRequestV3.blank('/servers')",
            "    #     req.method = 'POST'",
            "    #     req.body = jsonutils.dumps(body)",
            "    #     req.headers[\"content-type\"] = \"application/json\"",
            "    #     res = self.controller.create(req, body).obj",
            "",
            "    #     self.assertEqual(FAKE_UUID, res[\"server\"][\"id\"])",
            "    #     self._check_admin_pass_len(res[\"server\"])",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multiple-create extension tests",
            "    # def test_create_multiple_instances_pass_disabled(self):",
            "    #     \"\"\"Test creating multiple instances but not asking for",
            "    #     reservation_id",
            "    #     \"\"\"",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     self.flags(enable_instance_password=False)",
            "    #     image_href = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    #     flavor_ref = 'http://localhost/123/flavors/3'",
            "    #     body = {",
            "    #         'server': {",
            "    #             'min_count': 2,",
            "    #             'name': 'server_test',",
            "    #             'imageRef': image_href,",
            "    #             'flavorRef': flavor_ref,",
            "    #             'metadata': {'hello': 'world',",
            "    #                          'open': 'stack'},",
            "    #             'personality': []",
            "    #         }",
            "    #     }",
            "",
            "    #     req = fakes.HTTPRequestV3.blank('/servers')",
            "    #     req.method = 'POST'",
            "    #     req.body = jsonutils.dumps(body)",
            "    #     req.headers[\"content-type\"] = \"application/json\"",
            "    #     res = self.controller.create(req, body).obj",
            "",
            "    #     self.assertEqual(FAKE_UUID, res[\"server\"][\"id\"])",
            "    #     self._check_admin_pass_missing(res[\"server\"])",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multiple-create extension tests",
            "    # def test_create_multiple_instances_resv_id_return(self):",
            "    #     \"\"\"Test creating multiple instances with asking for",
            "    #     reservation_id",
            "    #     \"\"\"",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     image_href = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    #     flavor_ref = 'http://localhost/123/flavors/3'",
            "    #     body = {",
            "    #         'server': {",
            "    #             'min_count': 2,",
            "    #             'name': 'server_test',",
            "    #             'imageRef': image_href,",
            "    #             'flavorRef': flavor_ref,",
            "    #             'metadata': {'hello': 'world',",
            "    #                          'open': 'stack'},",
            "    #             'personality': [],",
            "    #             'return_reservation_id': True",
            "    #         }",
            "    #     }",
            "",
            "    #     req = fakes.HTTPRequestV3.blank('/servers')",
            "    #     req.method = 'POST'",
            "    #     req.body = jsonutils.dumps(body)",
            "    #     req.headers[\"content-type\"] = \"application/json\"",
            "    #     res = self.controller.create(req, body)",
            "",
            "    #     reservation_id = res.obj.get('reservation_id')",
            "    #     self.assertNotEqual(reservation_id, \"\")",
            "    #     self.assertNotEqual(reservation_id, None)",
            "    #     self.assertTrue(len(reservation_id) > 1)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multiple-create extension tests",
            "    # def test_create_multiple_instances_with_multiple_volume_bdm(self):",
            "    #     \"\"\"",
            "    #     Test that a BadRequest is raised if multiple instances",
            "    #     are requested with a list of block device mappings for volumes.",
            "    #     \"\"\"",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     min_count = 2",
            "    #     bdm = [{'device_name': 'foo1', 'volume_id': 'vol-xxxx'},",
            "    #            {'device_name': 'foo2', 'volume_id': 'vol-yyyy'}",
            "    #     ]",
            "    #     params = {",
            "    #               'block_device_mapping': bdm,",
            "    #               'min_count': min_count",
            "    #     }",
            "    #     old_create = compute_api.API.create",
            "",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['min_count'], 2)",
            "    #         self.assertEqual(len(kwargs['block_device_mapping']), 2)",
            "    #         return old_create(*args, **kwargs)",
            "",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self._test_create_extra, params, no_image=True)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multiple-create extension tests",
            "    # def test_create_multiple_instances_with_single_volume_bdm(self):",
            "    #     \"\"\"",
            "    #     Test that a BadRequest is raised if multiple instances",
            "    #     are requested to boot from a single volume.",
            "    #     \"\"\"",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     min_count = 2",
            "    #     bdm = [{'device_name': 'foo1', 'volume_id': 'vol-xxxx'}]",
            "    #     params = {",
            "    #              'block_device_mapping': bdm,",
            "    #              'min_count': min_count",
            "    #     }",
            "    #     old_create = compute_api.API.create",
            "",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['min_count'], 2)",
            "    #         self.assertEqual(kwargs['block_device_mapping']['volume_id'],",
            "    #                         'vol-xxxx')",
            "    #         return old_create(*args, **kwargs)",
            "",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self._test_create_extra, params, no_image=True)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multiple-create extension tests",
            "    # def test_create_multiple_instance_with_non_integer_max_count(self):",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     image_href = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    #     flavor_ref = 'http://localhost/123/flavors/3'",
            "    #     body = {",
            "    #         'server': {",
            "    #             'max_count': 2.5,",
            "    #             'name': 'server_test',",
            "    #             'imageRef': image_href,",
            "    #             'flavorRef': flavor_ref,",
            "    #             'metadata': {'hello': 'world',",
            "    #                          'open': 'stack'},",
            "    #             'personality': []",
            "    #         }",
            "    #     }",
            "",
            "    #     req = fakes.HTTPRequestV3.blank('/servers')",
            "    #     req.method = 'POST'",
            "    #     req.body = jsonutils.dumps(body)",
            "    #     req.headers[\"content-type\"] = \"application/json\"",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self.controller.create, req, body)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multiple-create extension tests",
            "    # def test_create_multiple_instance_with_non_integer_min_count(self):",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     image_href = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    #     flavor_ref = 'http://localhost/123/flavors/3'",
            "    #     body = {",
            "    #         'server': {",
            "    #             'min_count': 2.5,",
            "    #             'name': 'server_test',",
            "    #             'imageRef': image_href,",
            "    #             'flavorRef': flavor_ref,",
            "    #             'metadata': {'hello': 'world',",
            "    #                          'open': 'stack'},",
            "    #             'personality': []",
            "    #         }",
            "    #     }",
            "",
            "    #     req = fakes.HTTPRequestV3.blank('/servers')",
            "    #     req.method = 'POST'",
            "    #     req.body = jsonutils.dumps(body)",
            "    #     req.headers[\"content-type\"] = \"application/json\"",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self.controller.create, req, body)",
            "",
            "    def test_create_instance_image_ref_is_bookmark(self):",
            "        image_href = 'http://localhost/images/%s' % self.image_uuid",
            "        self.body['server']['image_ref'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_image_ref_is_invalid(self):",
            "        image_uuid = 'this_is_not_a_valid_uuid'",
            "        image_href = 'http://localhost/images/%s' % image_uuid",
            "        flavor_ref = 'http://localhost/flavors/3'",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['flavor_ref'] = flavor_ref",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.create,",
            "                          self.req, self.body)",
            "",
            "    def test_create_instance_no_key_pair(self):",
            "        fakes.stub_out_key_pair_funcs(self.stubs, have_key_pair=False)",
            "        self._test_create_instance()",
            "",
            "    def _test_create_extra(self, params, no_image=False):",
            "        self.body['server']['flavor_ref'] = 2",
            "        if no_image:",
            "            self.body['server'].pop('image_ref', None)",
            "        self.body['server'].update(params)",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.req.headers[\"content-type\"] = \"application/json\"",
            "        server = self.controller.create(self.req, self.body).obj['server']",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-security-groups extension tests",
            "    # def test_create_instance_with_security_group_enabled(self):",
            "    #     self.ext_mgr.extensions = {'os-security-groups': 'fake'}",
            "    #     group = 'foo'",
            "    #     old_create = compute_api.API.create",
            "",
            "    #     def sec_group_get(ctx, proj, name):",
            "    #         if name == group:",
            "    #             return True",
            "    #         else:",
            "    #             raise exception.SecurityGroupNotFoundForProject(",
            "    #                 project_id=proj, security_group_id=name)",
            "",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['security_group'], [group])",
            "    #         return old_create(*args, **kwargs)",
            "",
            "    #     self.stubs.Set(db, 'security_group_get_by_name', sec_group_get)",
            "    #     # negative test",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self._test_create_extra,",
            "    #                       {'security_groups': [{'name': 'bogus'}]})",
            "    #     # positive test - extra assert in create path",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self._test_create_extra({'security_groups': [{'name': group}]})",
            "",
            "    def test_create_instance_with_security_group_disabled(self):",
            "        group = 'foo'",
            "        params = {'security_groups': [{'name': group}]}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            # NOTE(vish): if the security groups extension is not",
            "            #             enabled, then security groups passed in",
            "            #             are ignored.",
            "            self.assertEqual(kwargs['security_group'], ['default'])",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-volumes extension tests",
            "    # def test_create_instance_with_volumes_enabled(self):",
            "    #     self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "    #     bdm = [{'device_name': 'foo'}]",
            "    #     params = {'block_device_mapping': bdm}",
            "    #     old_create = compute_api.API.create",
            "",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['block_device_mapping'], bdm)",
            "    #         return old_create(*args, **kwargs)",
            "",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self._test_create_extra(params)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-volumes extension tests",
            "    # def test_create_instance_with_volumes_enabled_no_image(self):",
            "    #     \"\"\"",
            "    #     Test that the create will fail if there is no image",
            "    #     and no bdms supplied in the request",
            "    #     \"\"\"",
            "    #     self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "    #     old_create = compute_api.API.create",
            "",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertNotIn('imageRef', kwargs)",
            "    #         return old_create(*args, **kwargs)",
            "",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self._test_create_extra, {}, no_image=True)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-volumes extension tests",
            "    # def test_create_instance_with_volumes_enabled_and_bdms_no_image(self):",
            "    #     \"\"\"",
            "    #     Test that the create works if there is no image supplied but",
            "    #     os-volumes extension is enabled and bdms are supplied",
            "    #     \"\"\"",
            "    #     self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "    #     bdm = [{'device_name': 'foo'}]",
            "    #     params = {'block_device_mapping': bdm}",
            "    #     old_create = compute_api.API.create",
            "",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['block_device_mapping'], bdm)",
            "    #         self.assertNotIn('imageRef', kwargs)",
            "    #         return old_create(*args, **kwargs)",
            "",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self._test_create_extra(params, no_image=True)",
            "",
            "    def test_create_instance_with_volumes_disabled(self):",
            "        bdm = [{'device_name': 'foo'}]",
            "        params = {'block_device_mapping': bdm}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['block_device_mapping'], None)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-volumes extension tests",
            "    # def test_create_instance_with_device_name_not_string(self):",
            "    #     self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "    #     bdm = [{'delete_on_termination': 1,",
            "    #             'device_name': 123,",
            "    #             'volume_size': 1,",
            "    #             'volume_id': '11111111-1111-1111-1111-111111111111'}]",
            "    #     params = {'block_device_mapping': bdm}",
            "    #     old_create = compute_api.API.create",
            "    #",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['block_device_mapping'], bdm)",
            "    #         return old_create(*args, **kwargs)",
            "    #",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self._test_create_extra, params)",
            "    #",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-volumes extension tests",
            "    # def test_create_instance_with_device_name_empty(self):",
            "    #     self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "    #     bdm = [{'delete_on_termination': 1,",
            "    #             'device_name': '',",
            "    #             'volume_size': 1,",
            "    #             'volume_id': '11111111-1111-1111-1111-111111111111'}]",
            "    #     params = {'block_device_mapping': bdm}",
            "    #     old_create = compute_api.API.create",
            "    #",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['block_device_mapping'], bdm)",
            "    #         return old_create(*args, **kwargs)",
            "    #",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self._test_create_extra, params)",
            "    #",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-volumes extension tests",
            "    # def test_create_instance_with_device_name_too_long(self):",
            "    #     self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "    #     bdm = [{'delete_on_termination': 1,",
            "    #             'device_name': 'a' * 256,",
            "    #             'volume_size': 1,",
            "    #             'volume_id': '11111111-1111-1111-1111-111111111111'}]",
            "    #     params = {'block_device_mapping': bdm}",
            "    #     old_create = compute_api.API.create",
            "    #",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['block_device_mapping'], bdm)",
            "    #         return old_create(*args, **kwargs)",
            "    #",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self._test_create_extra, params)",
            "    #",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-volumes extension tests",
            "    # def test_create_instance_with_space_in_device_name(self):",
            "    #     self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "    #     bdm = [{'delete_on_termination': 1,",
            "    #             'device_name': 'vd a',",
            "    #             'volume_size': 1,",
            "    #             'volume_id': '11111111-1111-1111-1111-111111111111'}]",
            "    #     params = {'block_device_mapping': bdm}",
            "    #     old_create = compute_api.API.create",
            "    #",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['block_device_mapping'], bdm)",
            "    #         return old_create(*args, **kwargs)",
            "    #",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self._test_create_extra, params)",
            "    #",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-volumes extension tests",
            "    # def test_create_instance_with_bdm_delete_on_termination(self):",
            "    #     self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "    #     bdm = [{'device_name': 'foo1', 'delete_on_termination': 1},",
            "    #            {'device_name': 'foo2', 'delete_on_termination': True},",
            "    #            {'device_name': 'foo3', 'delete_on_termination': 'invalid'},",
            "    #            {'device_name': 'foo4', 'delete_on_termination': 0},",
            "    #            {'device_name': 'foo5', 'delete_on_termination': False}]",
            "    #     expected_dbm = [",
            "    #         {'device_name': 'foo1', 'delete_on_termination': True},",
            "    #         {'device_name': 'foo2', 'delete_on_termination': True},",
            "    #         {'device_name': 'foo3', 'delete_on_termination': False},",
            "    #         {'device_name': 'foo4', 'delete_on_termination': False},",
            "    #         {'device_name': 'foo5', 'delete_on_termination': False}]",
            "    #     params = {'block_device_mapping': bdm}",
            "    #     old_create = compute_api.API.create",
            "    #",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['block_device_mapping'], expected_dbm)",
            "    #         return old_create(*args, **kwargs)",
            "    #",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self._test_create_extra(params)",
            "    #",
            "    #",
            "    #",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-keypairs extension tests",
            "    # def test_create_instance_with_keypairs_enabled(self):",
            "    #     self.ext_mgr.extensions = {'os-keypairs': 'fake'}",
            "    #     key_name = 'green'",
            "    #",
            "    #     params = {'key_name': key_name}",
            "    #     old_create = compute_api.API.create",
            "    #",
            "    #     # NOTE(sdague): key pair goes back to the database,",
            "    #     # so we need to stub it out for tests",
            "    #     def key_pair_get(context, user_id, name):",
            "    #         return {'public_key': 'FAKE_KEY',",
            "    #                 'fingerprint': 'FAKE_FINGERPRINT',",
            "    #                 'name': name}",
            "    #",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['key_name'], key_name)",
            "    #         return old_create(*args, **kwargs)",
            "    #",
            "    #     self.stubs.Set(db, 'key_pair_get', key_pair_get)",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self._test_create_extra(params)",
            "    #",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multi-create extension tests",
            "    # def test_create_instance_with_multiple_create_enabled(self):",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     min_count = 2",
            "    #     max_count = 3",
            "    #     params = {",
            "    #         'min_count': min_count,",
            "    #         'max_count': max_count,",
            "    #     }",
            "    #     old_create = compute_api.API.create",
            "",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['min_count'], 2)",
            "    #         self.assertEqual(kwargs['max_count'], 3)",
            "    #         return old_create(*args, **kwargs)",
            "",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_multiple_create_disabled(self):",
            "        ret_res_id = True",
            "        min_count = 2",
            "        max_count = 3",
            "        params = {",
            "            'min_count': min_count,",
            "            'max_count': max_count,",
            "        }",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['min_count'], 1)",
            "            self.assertEqual(kwargs['max_count'], 1)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-networks extension tests",
            "    # def test_create_instance_with_networks_enabled(self):",
            "    #     self.ext_mgr.extensions = {'os-networks': 'fake'}",
            "    #     net_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    #     requested_networks = [{'uuid': net_uuid}]",
            "    #     params = {'networks': requested_networks}",
            "    #     old_create = compute_api.API.create",
            "",
            "    #     def create(*args, **kwargs):",
            "    #         result = [('76fa36fc-c930-4bf3-8c8a-ea2a2420deb6', None)]",
            "    #         self.assertEqual(kwargs['requested_networks'], result)",
            "    #         return old_create(*args, **kwargs)",
            "",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_networks_disabled_neutronv2(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        net_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "        requested_networks = [{'uuid': net_uuid}]",
            "        params = {'networks': requested_networks}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            result = [('76fa36fc-c930-4bf3-8c8a-ea2a2420deb6', None,",
            "                       None)]",
            "            self.assertEqual(kwargs['requested_networks'], result)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_networks_disabled(self):",
            "        net_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "        requested_networks = [{'uuid': net_uuid}]",
            "        params = {'networks': requested_networks}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['requested_networks'], None)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_access_ip(self):",
            "        # proper local hrefs must start with 'http://localhost/v3/'",
            "        image_href = 'http://localhost/v2/fake/images/%s' % self.image_uuid",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['access_ip_v4'] = '1.2.3.4'",
            "        self.body['server']['access_ip_v6'] = 'fead::1234'",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "        server = res['server']",
            "        self._check_admin_pass_len(server)",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_with_access_ip_pass_disabled(self):",
            "        # test with admin passwords disabled See lp bug 921814",
            "        self.flags(enable_instance_password=False)",
            "",
            "        # proper local hrefs must start with 'http://localhost/v3/'",
            "        self.flags(enable_instance_password=False)",
            "        image_href = 'http://localhost/v2/fake/images/%s' % self.image_uuid",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['access_ip_v4'] = '1.2.3.4'",
            "        self.body['server']['access_ip_v6'] = 'fead::1234'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self._check_admin_pass_missing(server)",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_bad_format_access_ip_v4(self):",
            "        # proper local hrefs must start with 'http://localhost/v3/'",
            "        image_href = 'http://localhost/v2/fake/images/%s' % self.image_uuid",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['access_ip_v4'] = 'bad_format'",
            "        self.body['server']['access_ip_v6'] = 'fead::1234'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.create,",
            "                          self.req, self.body)",
            "",
            "    def test_create_instance_bad_format_access_ip_v6(self):",
            "        # proper local hrefs must start with 'http://localhost/v3/'",
            "        image_href = 'http://localhost/v2/fake/images/%s' % self.image_uuid",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['access_ip_v4'] = '1.2.3.4'",
            "        self.body['server']['access_ip_v6'] = 'bad_format'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.create,",
            "                          self.req, self.body)",
            "",
            "    def test_create_instance_name_too_long(self):",
            "        # proper local hrefs must start with 'http://localhost/v3/'",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['name'] = 'X' * 256",
            "        self.body['server']['image_ref'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.create,",
            "                          self.req, self.body)",
            "",
            "    def test_create_instance(self):",
            "        # proper local hrefs must start with 'http://localhost/v3/'",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['image_ref'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self._check_admin_pass_len(server)",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_extension_create_exception(self):",
            "        def fake_keypair_server_create(self, server_dict,",
            "                                       create_kwargs):",
            "            raise KeyError",
            "",
            "        self.stubs.Set(keypairs.Keypairs, 'server_create',",
            "                       fake_keypair_server_create)",
            "        # proper local hrefs must start with 'http://localhost/v3/'",
            "        image_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "        image_href = 'http://localhost/v3/images/%s' % image_uuid",
            "        flavor_ref = 'http://localhost/123/flavors/3'",
            "        body = {",
            "            'server': {",
            "                'name': 'server_test',",
            "                'image_ref': image_href,",
            "                'flavor_ref': flavor_ref,",
            "                'metadata': {",
            "                    'hello': 'world',",
            "                    'open': 'stack',",
            "                },",
            "            },",
            "        }",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers')",
            "        req.method = 'POST'",
            "        req.body = jsonutils.dumps(body)",
            "        req.headers[\"content-type\"] = \"application/json\"",
            "        self.assertRaises(KeyError, self.controller.create, req, body)",
            "",
            "    def test_create_instance_pass_disabled(self):",
            "        self.flags(enable_instance_password=False)",
            "        # proper local hrefs must start with 'http://localhost/v3/'",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['image_ref'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self._check_admin_pass_missing(server)",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_too_much_metadata(self):",
            "        self.flags(quota_metadata_items=1)",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['metadata']['vote'] = 'fiddletown'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_metadata_key_too_long(self):",
            "        self.flags(quota_metadata_items=1)",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['metadata'] = {('a' * 260): '12345'}",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_metadata_value_too_long(self):",
            "        self.flags(quota_metadata_items=1)",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['metadata'] = {'key1': ('a' * 260)}",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_metadata_key_blank(self):",
            "        self.flags(quota_metadata_items=1)",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['metadata'] = {'': 'abcd'}",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_invalid_key_name(self):",
            "        image_href = 'http://localhost/v2/images/2'",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['key_name'] = 'nonexistentkey'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_valid_key_name(self):",
            "        self.body['server']['key_name'] = 'key'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        self.assertEqual(FAKE_UUID, res[\"server\"][\"id\"])",
            "        self._check_admin_pass_len(res[\"server\"])",
            "",
            "    def test_create_instance_invalid_flavor_href(self):",
            "        image_href = 'http://localhost/v2/images/2'",
            "        flavor_ref = 'http://localhost/v2/flavors/asdf'",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['flavor_ref'] = flavor_ref",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_invalid_flavor_id_int(self):",
            "        image_href = 'http://localhost/v2/images/2'",
            "        flavor_ref = -1",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['flavor_ref'] = flavor_ref",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_bad_flavor_href(self):",
            "        image_href = 'http://localhost/v2/images/2'",
            "        flavor_ref = 'http://localhost/v2/flavors/17'",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['flavor_ref'] = flavor_ref",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_bad_href(self):",
            "        image_href = 'asdf'",
            "        self.body['server']['image_ref'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_local_href(self):",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_admin_pass(self):",
            "        self.body['server']['flavor_ref'] = 3,",
            "        self.body['server']['admin_pass'] = 'testpass'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self.assertEqual(server['admin_pass'],",
            "                         self.body['server']['admin_pass'])",
            "",
            "    def test_create_instance_admin_pass_pass_disabled(self):",
            "        self.flags(enable_instance_password=False)",
            "        self.body['server']['flavor_ref'] = 3,",
            "        self.body['server']['admin_pass'] = 'testpass'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self.assertTrue('admin_pass' in self.body['server'])",
            "",
            "    def test_create_instance_admin_pass_empty(self):",
            "        self.body['server']['flavor_ref'] = 3,",
            "        self.body['server']['admin_pass'] = ''",
            "        self.req.body = jsonutils.dumps(self.body)",
            "",
            "        # The fact that the action doesn't raise is enough validation",
            "        self.controller.create(self.req, self.body)",
            "",
            "    def test_create_location(self):",
            "        selfhref = 'http://localhost/v2/fake/servers/%s' % FAKE_UUID",
            "        bookhref = 'http://localhost/fake/servers/%s' % FAKE_UUID",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        robj = self.controller.create(self.req, self.body)",
            "",
            "        self.assertEqual(robj['Location'], selfhref)",
            "",
            "    def _do_test_create_instance_above_quota(self, resource, allowed, quota,",
            "                                             expected_msg):",
            "        fakes.stub_out_instance_quota(self.stubs, allowed, quota, resource)",
            "        self.body['server']['flavor_ref'] = 3",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        try:",
            "            server = self.controller.create(self.req, self.body).obj['server']",
            "            self.fail('expected quota to be exceeded')",
            "        except webob.exc.HTTPRequestEntityTooLarge as e:",
            "            self.assertEquals(e.explanation, expected_msg)",
            "",
            "    def test_create_instance_above_quota_instances(self):",
            "        msg = _('Quota exceeded for instances: Requested 1, but'",
            "                ' already used 10 of 10 instances')",
            "        self._do_test_create_instance_above_quota('instances', 0, 10, msg)",
            "",
            "    def test_create_instance_above_quota_ram(self):",
            "        msg = _('Quota exceeded for ram: Requested 4096, but'",
            "                ' already used 8192 of 10240 ram')",
            "        self._do_test_create_instance_above_quota('ram', 2048, 10 * 1024, msg)",
            "",
            "    def test_create_instance_above_quota_cores(self):",
            "        msg = _('Quota exceeded for cores: Requested 2, but'",
            "                ' already used 9 of 10 cores')",
            "        self._do_test_create_instance_above_quota('cores', 1, 10, msg)",
            "",
            "",
            "class TestServerCreateRequestXMLDeserializer(test.TestCase):",
            "",
            "    def setUp(self):",
            "        super(TestServerCreateRequestXMLDeserializer, self).setUp()",
            "        ext_info = plugins.LoadedExtensionInfo()",
            "        servers_controller = servers.ServersController(extension_info=ext_info)",
            "        self.deserializer = servers.CreateDeserializer(servers_controller)",
            "",
            "    def test_minimal_request(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        image_ref=\"1\"",
            "        flavor_ref=\"2\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"2\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_xml_create_exception(self):",
            "        def fake_availablity_extract_xml_deserialize(self,",
            "                                                     server_node,",
            "                                                     server_dict):",
            "            raise KeyError",
            "",
            "        self.stubs.Set(availability_zone.AvailabilityZone,",
            "                       'server_xml_extract_server_deserialize',",
            "                       fake_availablity_extract_xml_deserialize)",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        image_ref=\"1\"",
            "        flavor_ref=\"2\"/>\"\"\"",
            "        self.assertRaises(KeyError, self.deserializer.deserialize,",
            "                          serial_request)",
            "",
            "    def test_request_with_alternate_namespace_prefix(self):",
            "        serial_request = \"\"\"",
            "<ns2:server xmlns:ns2=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        image_ref=\"1\"",
            "        flavor_ref=\"2\">",
            "        <ns2:metadata><ns2:meta key=\"hello\">world</ns2:meta></ns2:metadata>",
            "        </ns2:server>",
            "        \"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"2\",",
            "                'metadata': {\"hello\": \"world\"},",
            "                },",
            "            }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_access_ipv4(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        image_ref=\"1\"",
            "        flavor_ref=\"2\"",
            "        access_ip_v4=\"1.2.3.4\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"2\",",
            "                \"access_ip_v4\": \"1.2.3.4\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_access_ipv6(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        image_ref=\"1\"",
            "        flavor_ref=\"2\"",
            "        access_ip_v6=\"fead::1234\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"2\",",
            "                \"access_ip_v6\": \"fead::1234\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_access_ip(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        image_ref=\"1\"",
            "        flavor_ref=\"2\"",
            "        access_ip_v4=\"1.2.3.4\"",
            "        access_ip_v6=\"fead::1234\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"2\",",
            "                \"access_ip_v4\": \"1.2.3.4\",",
            "                \"access_ip_v6\": \"fead::1234\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_admin_pass(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        image_ref=\"1\"",
            "        flavor_ref=\"2\"",
            "        admin_pass=\"1234\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"2\",",
            "                \"admin_pass\": \"1234\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_image_link(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        image_ref=\"http://localhost:8774/v3/images/2\"",
            "        flavor_ref=\"3\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"http://localhost:8774/v3/images/2\",",
            "                \"flavor_ref\": \"3\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_flavor_link(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        image_ref=\"1\"",
            "        flavor_ref=\"http://localhost:8774/v3/flavors/3\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"http://localhost:8774/v3/flavors/3\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_multiple_metadata_items(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        image_ref=\"1\"",
            "        flavor_ref=\"2\">",
            "    <metadata>",
            "        <meta key=\"one\">two</meta>",
            "        <meta key=\"open\">snack</meta>",
            "    </metadata>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"2\",",
            "                \"metadata\": {\"one\": \"two\", \"open\": \"snack\"},",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_spec_request(self):",
            "        image_bookmark_link = (\"http://servers.api.openstack.org/1234/\"",
            "                               \"images/52415800-8b69-11e0-9b19-734f6f006e54\")",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        image_ref=\"%s\"",
            "        flavor_ref=\"52415800-8b69-11e0-9b19-734f1195ff37\"",
            "        name=\"new-server-test\">",
            "  <metadata>",
            "    <meta key=\"My Server Name\">Apache1</meta>",
            "  </metadata>",
            "</server>\"\"\" % (image_bookmark_link)",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": (\"http://servers.api.openstack.org/1234/\"",
            "                             \"images/52415800-8b69-11e0-9b19-734f6f006e54\"),",
            "                \"flavor_ref\": \"52415800-8b69-11e0-9b19-734f1195ff37\",",
            "                \"metadata\": {\"My Server Name\": \"Apache1\"},",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_empty_networks(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" image_ref=\"1\" flavor_ref=\"1\">",
            "    <networks/>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"1\",",
            "                \"networks\": [],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_one_network(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" image_ref=\"1\" flavor_ref=\"1\">",
            "    <networks>",
            "       <network uuid=\"1\" fixed_ip=\"10.0.1.12\"/>",
            "    </networks>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\", \"fixed_ip\": \"10.0.1.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_two_networks(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" image_ref=\"1\" flavor_ref=\"1\">",
            "    <networks>",
            "       <network uuid=\"1\" fixed_ip=\"10.0.1.12\"/>",
            "       <network uuid=\"2\" fixed_ip=\"10.0.2.12\"/>",
            "    </networks>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\", \"fixed_ip\": \"10.0.1.12\"},",
            "                             {\"uuid\": \"2\", \"fixed_ip\": \"10.0.2.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_second_network_node_ignored(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" image_ref=\"1\" flavor_ref=\"1\">",
            "    <networks>",
            "       <network uuid=\"1\" fixed_ip=\"10.0.1.12\"/>",
            "    </networks>",
            "    <networks>",
            "       <network uuid=\"2\" fixed_ip=\"10.0.2.12\"/>",
            "    </networks>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\", \"fixed_ip\": \"10.0.1.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_one_network_missing_id(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" image_ref=\"1\" flavor_ref=\"1\">",
            "    <networks>",
            "       <network fixed_ip=\"10.0.1.12\"/>",
            "    </networks>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"1\",",
            "                \"networks\": [{\"fixed_ip\": \"10.0.1.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_one_network_missing_fixed_ip(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" image_ref=\"1\" flavor_ref=\"1\">",
            "    <networks>",
            "       <network uuid=\"1\"/>",
            "    </networks>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_one_network_empty_id(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\" image_ref=\"1\" flavor_ref=\"1\">",
            "        <networks>",
            "           <network uuid=\"\" fixed_ip=\"10.0.1.12\"/>",
            "        </networks>",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"1\",",
            "                \"networks\": [{\"uuid\": \"\", \"fixed_ip\": \"10.0.1.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_one_network_empty_fixed_ip(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\" image_ref=\"1\" flavor_ref=\"1\">",
            "        <networks>",
            "           <network uuid=\"1\" fixed_ip=\"\"/>",
            "        </networks>",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\", \"fixed_ip\": \"\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_networks_duplicate_ids(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\" image_ref=\"1\" flavor_ref=\"1\">",
            "        <networks>",
            "           <network uuid=\"1\" fixed_ip=\"10.0.1.12\"/>",
            "           <network uuid=\"1\" fixed_ip=\"10.0.2.12\"/>",
            "        </networks>",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\", \"fixed_ip\": \"10.0.1.12\"},",
            "                             {\"uuid\": \"1\", \"fixed_ip\": \"10.0.2.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_multiple_create_args(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\" image_ref=\"1\" flavor_ref=\"1\"",
            "     min_count=\"1\" max_count=\"3\" return_reservation_id=\"True\">",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"1\",",
            "                \"min_count\": \"1\",",
            "                \"max_count\": \"3\",",
            "                \"return_reservation_id\": True,",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the scheduler hints extension tests",
            "    # def test_request_with_scheduler_hints(self):",
            "    #     serial_request = \"\"\"",
            "    # <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "    #  xmlns:OS-SCH-HNT=",
            "    #  \"http://docs.openstack.org/compute/ext/scheduler-hints/api/v2\"",
            "    #  name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "    #    <OS-SCH-HNT:scheduler_hints>",
            "    #      <different_host>",
            "    #        7329b667-50c7-46a6-b913-cb2a09dfeee0",
            "    #      </different_host>",
            "    #      <different_host>",
            "    #        f31efb24-34d2-43e1-8b44-316052956a39",
            "    #      </different_host>",
            "    #    </OS-SCH-HNT:scheduler_hints>",
            "    # </server>\"\"\"",
            "    #     request = self.deserializer.deserialize(serial_request)",
            "    #     expected = {\"server\": {",
            "    #             \"name\": \"new-server-test\",",
            "    #             \"imageRef\": \"1\",",
            "    #             \"flavorRef\": \"1\",",
            "    #             \"OS-SCH-HNT:scheduler_hints\": {",
            "    #                 \"different_host\": [",
            "    #                     \"7329b667-50c7-46a6-b913-cb2a09dfeee0\",",
            "    #                     \"f31efb24-34d2-43e1-8b44-316052956a39\",",
            "    #                 ]",
            "    #             }",
            "    #             }}",
            "    #     self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_block_device_mapping(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\" image_ref=\"1\" flavor_ref=\"1\">",
            "       <block_device_mapping>",
            "         <mapping volume_id=\"7329b667-50c7-46a6-b913-cb2a09dfeee0\"",
            "          device_name=\"/dev/vda\" virtual_name=\"root\"",
            "          delete_on_termination=\"False\" />",
            "         <mapping snapshot_id=\"f31efb24-34d2-43e1-8b44-316052956a39\"",
            "          device_name=\"/dev/vdb\" virtual_name=\"ephemeral0\"",
            "          delete_on_termination=\"False\" />",
            "         <mapping device_name=\"/dev/vdc\" no_device=\"True\" />",
            "       </block_device_mapping>",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"1\",",
            "                \"block_device_mapping\": [",
            "                    {",
            "                        \"volume_id\": \"7329b667-50c7-46a6-b913-cb2a09dfeee0\",",
            "                        \"device_name\": \"/dev/vda\",",
            "                        \"virtual_name\": \"root\",",
            "                        \"delete_on_termination\": False,",
            "                    },",
            "                    {",
            "                        \"snapshot_id\": \"f31efb24-34d2-43e1-8b44-316052956a39\",",
            "                        \"device_name\": \"/dev/vdb\",",
            "                        \"virtual_name\": \"ephemeral0\",",
            "                        \"delete_on_termination\": False,",
            "                    },",
            "                    {",
            "                        \"device_name\": \"/dev/vdc\",",
            "                        \"no_device\": True,",
            "                    },",
            "                ]",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_corrupt_xml(self):",
            "        \"\"\"Should throw a 400 error on corrupt xml.\"\"\"",
            "        self.assertRaises(",
            "                exception.MalformedRequestBody,",
            "                self.deserializer.deserialize,",
            "                utils.killer_xml_body())",
            "",
            "",
            "class TestAddressesXMLSerialization(test.TestCase):",
            "",
            "    index_serializer = ips.AddressesTemplate()",
            "    show_serializer = ips.NetworkTemplate()",
            "",
            "    def test_xml_declaration(self):",
            "        fixture = {",
            "            'network_2': [",
            "                {'addr': '192.168.0.1', 'version': 4,",
            "                 'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                {'addr': 'fe80::beef', 'version': 6,",
            "                 'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'}",
            "            ],",
            "        }",
            "        output = self.show_serializer.serialize(fixture)",
            "        has_dec = output.startswith(\"<?xml version='1.0' encoding='UTF-8'?>\")",
            "        self.assertTrue(has_dec)",
            "",
            "    def test_show(self):",
            "        fixture = {",
            "            'network_2': [",
            "                {'addr': '192.168.0.1', 'version': 4,",
            "                 'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                {'addr': 'fe80::beef', 'version': 6,",
            "                 'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'}",
            "            ],",
            "        }",
            "        output = self.show_serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        network = fixture['network_2']",
            "        self.assertEqual(str(root.get('id')), 'network_2')",
            "        ip_elems = root.findall('{0}ip'.format(NS))",
            "        for z, ip_elem in enumerate(ip_elems):",
            "            ip = network[z]",
            "            self.assertEqual(str(ip_elem.get('version')),",
            "                             str(ip['version']))",
            "            self.assertEqual(str(ip_elem.get('addr')),",
            "                             str(ip['addr']))",
            "            self.assertEqual(str(ip_elem.get('type')),",
            "                                 str(ip['type']))",
            "            self.assertEqual(str(ip_elem.get('mac_addr')),",
            "                                 str(ip['mac_addr']))",
            "",
            "    def test_index(self):",
            "        fixture = {",
            "            'addresses': {",
            "                'network_1': [",
            "                    {'addr': '192.168.0.3', 'version': 4,",
            "                     'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                    {'addr': '192.168.0.5', 'version': 4,",
            "                     'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'}",
            "                ],",
            "                'network_2': [",
            "                    {'addr': '192.168.0.1', 'version': 4,",
            "                     'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                    {'addr': 'fe80::beef', 'version': 6,",
            "                     'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'}",
            "                ],",
            "            },",
            "        }",
            "        output = self.index_serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'addresses', version='v3')",
            "        addresses_dict = fixture['addresses']",
            "        network_elems = root.findall('{0}network'.format(NS))",
            "        self.assertEqual(len(network_elems), 2)",
            "        for i, network_elem in enumerate(network_elems):",
            "            network = addresses_dict.items()[i]",
            "            self.assertEqual(str(network_elem.get('id')), str(network[0]))",
            "            ip_elems = network_elem.findall('{0}ip'.format(NS))",
            "            for z, ip_elem in enumerate(ip_elems):",
            "                ip = network[1][z]",
            "                self.assertEqual(str(ip_elem.get('version')),",
            "                                 str(ip['version']))",
            "                self.assertEqual(str(ip_elem.get('addr')),",
            "                                 str(ip['addr']))",
            "                self.assertEqual(str(ip_elem.get('type')),",
            "                                 str(ip['type']))",
            "                self.assertEqual(str(ip_elem.get('mac_addr')),",
            "                                 str(ip['mac_addr']))",
            "",
            "",
            "class ServersViewBuilderTest(test.TestCase):",
            "",
            "    def setUp(self):",
            "        super(ServersViewBuilderTest, self).setUp()",
            "        self.flags(use_ipv6=True)",
            "        self.instance = fakes.stub_instance(",
            "            id=1,",
            "            image_ref=\"5\",",
            "            uuid=\"deadbeef-feed-edee-beef-d0ea7beefedd\",",
            "            display_name=\"test_server\",",
            "            include_fake_metadata=False)",
            "",
            "        privates = ['172.19.0.1']",
            "        publics = ['192.168.0.3']",
            "        public6s = ['b33f::fdee:ddff:fecc:bbaa']",
            "",
            "        def nw_info(*args, **kwargs):",
            "            return [(None, {'label': 'public',",
            "                            'ips': [dict(ip=ip) for ip in publics],",
            "                            'ip6s': [dict(ip=ip) for ip in public6s]}),",
            "                    (None, {'label': 'private',",
            "                            'ips': [dict(ip=ip) for ip in privates]})]",
            "",
            "        def floaters(*args, **kwargs):",
            "            return []",
            "",
            "        fakes.stub_out_nw_api_get_instance_nw_info(self.stubs, nw_info)",
            "        fakes.stub_out_nw_api_get_floating_ips_by_fixed_address(self.stubs,",
            "                                                                floaters)",
            "",
            "        self.uuid = self.instance['uuid']",
            "        self.view_builder = views.servers.ViewBuilderV3()",
            "        self.request = fakes.HTTPRequestV3.blank(\"\")",
            "",
            "    def test_get_flavor_valid_instance_type(self):",
            "        flavor_bookmark = \"http://localhost/flavors/1\"",
            "        expected = {\"id\": \"1\",",
            "                    \"links\": [{\"rel\": \"bookmark\",",
            "                               \"href\": flavor_bookmark}]}",
            "        result = self.view_builder._get_flavor(self.request, self.instance)",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_build_server(self):",
            "        self_link = \"http://localhost/v3/servers/%s\" % self.uuid",
            "        bookmark_link = \"http://localhost/servers/%s\" % self.uuid",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": self.uuid,",
            "                \"name\": \"test_server\",",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": self_link,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": bookmark_link,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        output = self.view_builder.basic(self.request, self.instance)",
            "        self.assertThat(output, matchers.DictMatches(expected_server))",
            "",
            "    def test_build_server_with_project_id(self):",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": self.uuid,",
            "                \"name\": \"test_server\",",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": \"http://localhost/v3/servers/%s\" %",
            "                                self.uuid,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": \"http://localhost/servers/%s\" % self.uuid,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        output = self.view_builder.basic(self.request, self.instance)",
            "        self.assertThat(output, matchers.DictMatches(expected_server))",
            "",
            "    def test_build_server_detail(self):",
            "        image_bookmark = \"http://localhost/images/5\"",
            "        flavor_bookmark = \"http://localhost/flavors/1\"",
            "        self_link = \"http://localhost/v3/servers/%s\" % self.uuid",
            "        bookmark_link = \"http://localhost/servers/%s\" % self.uuid",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": self.uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"access_ip_v4\": \"\",",
            "                \"access_ip_v6\": \"\",",
            "                \"host_id\": '',",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                  \"links\": [",
            "                                            {",
            "                          \"rel\": \"bookmark\",",
            "                          \"href\": flavor_bookmark,",
            "                      },",
            "                  ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'}",
            "                    ]",
            "                },",
            "                \"metadata\": {},",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": self_link,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": bookmark_link,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output, matchers.DictMatches(expected_server))",
            "",
            "    def test_build_server_no_image(self):",
            "        self.instance[\"image_ref\"] = \"\"",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertEqual(output['server']['image'], \"\")",
            "",
            "    def test_build_server_detail_with_fault(self):",
            "        self.instance['vm_state'] = vm_states.ERROR",
            "        self.instance['fault'] = {",
            "            'code': 404,",
            "            'instance_uuid': self.uuid,",
            "            'message': \"HTTPNotFound\",",
            "            'details': \"Stock details for test\",",
            "            'created_at': datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "        }",
            "",
            "        image_bookmark = \"http://localhost/images/5\"",
            "        flavor_bookmark = \"http://localhost/flavors/1\"",
            "        self_link = \"http://localhost/v3/servers/%s\" % self.uuid",
            "        bookmark_link = \"http://localhost/servers/%s\" % self.uuid",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": self.uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"name\": \"test_server\",",
            "                \"status\": \"ERROR\",",
            "                \"access_ip_v4\": \"\",",
            "                \"access_ip_v6\": \"\",",
            "                \"host_id\": '',",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                  \"links\": [",
            "                                            {",
            "                          \"rel\": \"bookmark\",",
            "                          \"href\": flavor_bookmark,",
            "                      },",
            "                  ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'}",
            "                    ]",
            "                },",
            "                \"metadata\": {},",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": self_link,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": bookmark_link,",
            "                    },",
            "                ],",
            "                \"fault\": {",
            "                    \"code\": 404,",
            "                    \"created\": \"2010-10-10T12:00:00Z\",",
            "                    \"message\": \"HTTPNotFound\",",
            "                    \"details\": \"Stock details for test\",",
            "                },",
            "            }",
            "        }",
            "",
            "        self.request.context = context.RequestContext('fake', 'fake')",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output, matchers.DictMatches(expected_server))",
            "",
            "    def test_build_server_detail_with_fault_no_details_not_admin(self):",
            "        self.instance['vm_state'] = vm_states.ERROR",
            "        self.instance['fault'] = {",
            "            'code': 500,",
            "            'instance_uuid': self.uuid,",
            "            'message': \"Error\",",
            "            'details': 'Stock details for test',",
            "            'created_at': datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "        }",
            "",
            "        expected_fault = {\"code\": 500,",
            "                          \"created\": \"2010-10-10T12:00:00Z\",",
            "                          \"message\": \"Error\"}",
            "",
            "        self.request.context = context.RequestContext('fake', 'fake')",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output['server']['fault'],",
            "                        matchers.DictMatches(expected_fault))",
            "",
            "    def test_build_server_detail_with_fault_admin(self):",
            "        self.instance['vm_state'] = vm_states.ERROR",
            "        self.instance['fault'] = {",
            "            'code': 500,",
            "            'instance_uuid': self.uuid,",
            "            'message': \"Error\",",
            "            'details': 'Stock details for test',",
            "            'created_at': datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "        }",
            "",
            "        expected_fault = {\"code\": 500,",
            "                          \"created\": \"2010-10-10T12:00:00Z\",",
            "                          \"message\": \"Error\",",
            "                          'details': 'Stock details for test'}",
            "",
            "        self.request.environ['nova.context'].is_admin = True",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output['server']['fault'],",
            "                        matchers.DictMatches(expected_fault))",
            "",
            "    def test_build_server_detail_with_fault_no_details_admin(self):",
            "        self.instance['vm_state'] = vm_states.ERROR",
            "        self.instance['fault'] = {",
            "            'code': 500,",
            "            'instance_uuid': self.uuid,",
            "            'message': \"Error\",",
            "            'details': '',",
            "            'created_at': datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "        }",
            "",
            "        expected_fault = {\"code\": 500,",
            "                          \"created\": \"2010-10-10T12:00:00Z\",",
            "                          \"message\": \"Error\"}",
            "",
            "        self.request.environ['nova.context'].is_admin = True",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output['server']['fault'],",
            "                        matchers.DictMatches(expected_fault))",
            "",
            "    def test_build_server_detail_with_fault_but_active(self):",
            "        self.instance['vm_state'] = vm_states.ACTIVE",
            "        self.instance['progress'] = 100",
            "        self.instance['fault'] = {",
            "            'code': 404,",
            "            'instance_uuid': self.uuid,",
            "            'message': \"HTTPNotFound\",",
            "            'details': \"Stock details for test\",",
            "            'created_at': datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "        }",
            "",
            "        image_bookmark = \"http://localhost/images/5\"",
            "        flavor_bookmark = \"http://localhost/flavors/1\"",
            "        self_link = \"http://localhost/v3/servers/%s\" % self.uuid",
            "        bookmark_link = \"http://localhost/servers/%s\" % self.uuid",
            "",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertFalse('fault' in output['server'])",
            "",
            "    def test_build_server_detail_active_status(self):",
            "        #set the power state of the instance to running",
            "        self.instance['vm_state'] = vm_states.ACTIVE",
            "        self.instance['progress'] = 100",
            "        image_bookmark = \"http://localhost/images/5\"",
            "        flavor_bookmark = \"http://localhost/flavors/1\"",
            "        self_link = \"http://localhost/v3/servers/%s\" % self.uuid",
            "        bookmark_link = \"http://localhost/servers/%s\" % self.uuid",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": self.uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 100,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"ACTIVE\",",
            "                \"access_ip_v4\": \"\",",
            "                \"access_ip_v6\": \"\",",
            "                \"host_id\": '',",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                  \"links\": [",
            "                                            {",
            "                          \"rel\": \"bookmark\",",
            "                          \"href\": flavor_bookmark,",
            "                      },",
            "                  ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'}",
            "                    ]",
            "                },",
            "                \"metadata\": {},",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": self_link,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": bookmark_link,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output, matchers.DictMatches(expected_server))",
            "",
            "    def test_build_server_detail_with_accessipv4(self):",
            "",
            "        self.instance['access_ip_v4'] = '1.2.3.4'",
            "",
            "        image_bookmark = \"http://localhost/images/5\"",
            "        flavor_bookmark = \"http://localhost/flavors/1\"",
            "        self_link = \"http://localhost/v3/servers/%s\" % self.uuid",
            "        bookmark_link = \"http://localhost/servers/%s\" % self.uuid",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": self.uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"host_id\": '',",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                                              {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": flavor_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                    ]",
            "                },",
            "                \"metadata\": {},",
            "                \"access_ip_v4\": \"1.2.3.4\",",
            "                \"access_ip_v6\": \"\",",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": self_link,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": bookmark_link,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output, matchers.DictMatches(expected_server))",
            "",
            "    def test_build_server_detail_with_accessipv6(self):",
            "",
            "        self.instance['access_ip_v6'] = 'fead::1234'",
            "",
            "        image_bookmark = \"http://localhost/images/5\"",
            "        flavor_bookmark = \"http://localhost/flavors/1\"",
            "        self_link = \"http://localhost/v3/servers/%s\" % self.uuid",
            "        bookmark_link = \"http://localhost/servers/%s\" % self.uuid",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": self.uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"host_id\": '',",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                                              {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": flavor_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                    ]",
            "                },",
            "                \"metadata\": {},",
            "                \"access_ip_v4\": \"\",",
            "                \"access_ip_v6\": \"fead::1234\",",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": self_link,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": bookmark_link,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output, matchers.DictMatches(expected_server))",
            "",
            "    def test_build_server_detail_with_metadata(self):",
            "",
            "        metadata = []",
            "        metadata.append(models.InstanceMetadata(key=\"Open\", value=\"Stack\"))",
            "        self.instance['metadata'] = metadata",
            "",
            "        image_bookmark = \"http://localhost/images/5\"",
            "        flavor_bookmark = \"http://localhost/flavors/1\"",
            "        self_link = \"http://localhost/v3/servers/%s\" % self.uuid",
            "        bookmark_link = \"http://localhost/servers/%s\" % self.uuid",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": self.uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"access_ip_v4\": \"\",",
            "                \"access_ip_v6\": \"\",",
            "                \"host_id\": '',",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                                              {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": flavor_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                    ]",
            "                },",
            "                \"metadata\": {\"Open\": \"Stack\"},",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": self_link,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": bookmark_link,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output, matchers.DictMatches(expected_server))",
            "",
            "",
            "class ServerXMLSerializationTest(test.TestCase):",
            "",
            "    TIMESTAMP = \"2010-10-11T10:30:22Z\"",
            "    SERVER_HREF = 'http://localhost/v3/servers/%s' % FAKE_UUID",
            "    SERVER_NEXT = 'http://localhost/v3/servers?limit=%s&marker=%s'",
            "    SERVER_BOOKMARK = 'http://localhost/servers/%s' % FAKE_UUID",
            "    IMAGE_BOOKMARK = 'http://localhost/images/5'",
            "    FLAVOR_BOOKMARK = 'http://localhost/flavors/1'",
            "",
            "    def test_xml_declaration(self):",
            "        serializer = servers.ServerTemplate()",
            "",
            "        fixture = {",
            "            \"server\": {",
            "                'id': FAKE_UUID,",
            "                'user_id': 'fake_user_id',",
            "                'tenant_id': 'fake_tenant_id',",
            "                'created': self.TIMESTAMP,",
            "                'updated': self.TIMESTAMP,",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"host_id\": 'e4d909c290d0fb1ca068ffaddf22cbd0',",
            "                \"access_ip_v4\": \"1.2.3.4\",",
            "                \"access_ip_v6\": \"fead::1234\",",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.IMAGE_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.FLAVOR_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    \"network_one\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                    ],",
            "                    \"network_two\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.139\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.139\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                    ],",
            "                },",
            "                \"metadata\": {",
            "                    \"Open\": \"Stack\",",
            "                    \"Number\": \"1\",",
            "                },",
            "                'links': [",
            "                    {",
            "                        'href': self.SERVER_HREF,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': self.SERVER_BOOKMARK,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        output = serializer.serialize(fixture)",
            "        has_dec = output.startswith(\"<?xml version='1.0' encoding='UTF-8'?>\")",
            "        self.assertTrue(has_dec)",
            "",
            "    def test_show(self):",
            "        serializer = servers.ServerTemplate()",
            "",
            "        fixture = {",
            "            \"server\": {",
            "                \"id\": FAKE_UUID,",
            "                \"user_id\": \"fake\",",
            "                \"tenant_id\": \"fake\",",
            "                'created': self.TIMESTAMP,",
            "                'updated': self.TIMESTAMP,",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"host_id\": 'e4d909c290d0fb1ca068ffaddf22cbd0',",
            "                \"access_ip_v4\": \"1.2.3.4\",",
            "                \"access_ip_v6\": \"fead::1234\",",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.IMAGE_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.FLAVOR_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    \"network_one\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                    ],",
            "                    \"network_two\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.139\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.139\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                    ],",
            "                },",
            "                \"metadata\": {",
            "                    \"Open\": \"Stack\",",
            "                    \"Number\": \"1\",",
            "                },",
            "                'links': [",
            "                    {",
            "                        'href': self.SERVER_HREF,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': self.SERVER_BOOKMARK,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        output = serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'server', version='v3')",
            "",
            "        server_dict = fixture['server']",
            "",
            "        for key in ['name', 'id', 'created', 'access_ip_v4',",
            "                    'updated', 'progress', 'status', 'host_id',",
            "                    'access_ip_v6']:",
            "            self.assertEqual(root.get(key), str(server_dict[key]))",
            "",
            "        link_nodes = root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 2)",
            "        for i, link in enumerate(server_dict['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        metadata_root = root.find('{0}metadata'.format(NS))",
            "        metadata_elems = metadata_root.findall('{0}meta'.format(NS))",
            "        self.assertEqual(len(metadata_elems), 2)",
            "        for i, metadata_elem in enumerate(metadata_elems):",
            "            (meta_key, meta_value) = server_dict['metadata'].items()[i]",
            "            self.assertEqual(str(metadata_elem.get('key')), str(meta_key))",
            "            self.assertEqual(str(metadata_elem.text).strip(), str(meta_value))",
            "",
            "        image_root = root.find('{0}image'.format(NS))",
            "        self.assertEqual(image_root.get('id'), server_dict['image']['id'])",
            "        link_nodes = image_root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 1)",
            "        for i, link in enumerate(server_dict['image']['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        flavor_root = root.find('{0}flavor'.format(NS))",
            "        self.assertEqual(flavor_root.get('id'), server_dict['flavor']['id'])",
            "        link_nodes = flavor_root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 1)",
            "        for i, link in enumerate(server_dict['flavor']['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        addresses_root = root.find('{0}addresses'.format(NS))",
            "        addresses_dict = server_dict['addresses']",
            "        network_elems = addresses_root.findall('{0}network'.format(NS))",
            "        self.assertEqual(len(network_elems), 2)",
            "        for i, network_elem in enumerate(network_elems):",
            "            network = addresses_dict.items()[i]",
            "            self.assertEqual(str(network_elem.get('id')), str(network[0]))",
            "            ip_elems = network_elem.findall('{0}ip'.format(NS))",
            "            for z, ip_elem in enumerate(ip_elems):",
            "                ip = network[1][z]",
            "                self.assertEqual(str(ip_elem.get('version')),",
            "                                 str(ip['version']))",
            "                self.assertEqual(str(ip_elem.get('addr')),",
            "                                 str(ip['addr']))",
            "                self.assertEqual(str(ip_elem.get('type')),",
            "                                 str(ip['type']))",
            "                self.assertEqual(str(ip_elem.get('mac_addr')),",
            "                                 str(ip['mac_addr']))",
            "",
            "    def test_create(self):",
            "        serializer = servers.FullServerTemplate()",
            "",
            "        fixture = {",
            "            \"server\": {",
            "                \"id\": FAKE_UUID,",
            "                \"user_id\": \"fake\",",
            "                \"tenant_id\": \"fake\",",
            "                'created': self.TIMESTAMP,",
            "                'updated': self.TIMESTAMP,",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"access_ip_v4\": \"1.2.3.4\",",
            "                \"access_ip_v6\": \"fead::1234\",",
            "                \"host_id\": \"e4d909c290d0fb1ca068ffaddf22cbd0\",",
            "                \"admin_pass\": \"test_password\",",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.IMAGE_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.FLAVOR_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    \"network_one\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                    ],",
            "                    \"network_two\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.139\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.139\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                    ],",
            "                },",
            "                \"metadata\": {",
            "                    \"Open\": \"Stack\",",
            "                    \"Number\": \"1\",",
            "                },",
            "                'links': [",
            "                    {",
            "                        'href': self.SERVER_HREF,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': self.SERVER_BOOKMARK,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        output = serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'server', version='v3')",
            "",
            "        server_dict = fixture['server']",
            "",
            "        for key in ['name', 'id', 'created', 'access_ip_v4',",
            "                    'updated', 'progress', 'status', 'host_id',",
            "                    'access_ip_v6', 'admin_pass']:",
            "            self.assertEqual(root.get(key), str(server_dict[key]))",
            "",
            "        link_nodes = root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 2)",
            "        for i, link in enumerate(server_dict['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        metadata_root = root.find('{0}metadata'.format(NS))",
            "        metadata_elems = metadata_root.findall('{0}meta'.format(NS))",
            "        self.assertEqual(len(metadata_elems), 2)",
            "        for i, metadata_elem in enumerate(metadata_elems):",
            "            (meta_key, meta_value) = server_dict['metadata'].items()[i]",
            "            self.assertEqual(str(metadata_elem.get('key')), str(meta_key))",
            "            self.assertEqual(str(metadata_elem.text).strip(), str(meta_value))",
            "",
            "        image_root = root.find('{0}image'.format(NS))",
            "        self.assertEqual(image_root.get('id'), server_dict['image']['id'])",
            "        link_nodes = image_root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 1)",
            "        for i, link in enumerate(server_dict['image']['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        flavor_root = root.find('{0}flavor'.format(NS))",
            "        self.assertEqual(flavor_root.get('id'), server_dict['flavor']['id'])",
            "        link_nodes = flavor_root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 1)",
            "        for i, link in enumerate(server_dict['flavor']['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        addresses_root = root.find('{0}addresses'.format(NS))",
            "        addresses_dict = server_dict['addresses']",
            "        network_elems = addresses_root.findall('{0}network'.format(NS))",
            "        self.assertEqual(len(network_elems), 2)",
            "        for i, network_elem in enumerate(network_elems):",
            "            network = addresses_dict.items()[i]",
            "            self.assertEqual(str(network_elem.get('id')), str(network[0]))",
            "            ip_elems = network_elem.findall('{0}ip'.format(NS))",
            "            for z, ip_elem in enumerate(ip_elems):",
            "                ip = network[1][z]",
            "                self.assertEqual(str(ip_elem.get('version')),",
            "                                 str(ip['version']))",
            "                self.assertEqual(str(ip_elem.get('addr')),",
            "                                 str(ip['addr']))",
            "                self.assertEqual(str(ip_elem.get('type')),",
            "                                 str(ip['type']))",
            "                self.assertEqual(str(ip_elem.get('mac_addr')),",
            "                                 str(ip['mac_addr']))",
            "",
            "    def test_index(self):",
            "        serializer = servers.MinimalServersTemplate()",
            "",
            "        uuid1 = fakes.get_fake_uuid(1)",
            "        uuid2 = fakes.get_fake_uuid(2)",
            "        expected_server_href = 'http://localhost/v3/servers/%s' % uuid1",
            "        expected_server_bookmark = 'http://localhost/servers/%s' % uuid1",
            "        expected_server_href_2 = 'http://localhost/v3/servers/%s' % uuid2",
            "        expected_server_bookmark_2 = 'http://localhost/servers/%s' % uuid2",
            "        fixture = {\"servers\": [",
            "            {",
            "                \"id\": fakes.get_fake_uuid(1),",
            "                \"name\": \"test_server\",",
            "                'links': [",
            "                    {",
            "                        'href': expected_server_href,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': expected_server_bookmark,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            },",
            "            {",
            "                \"id\": fakes.get_fake_uuid(2),",
            "                \"name\": \"test_server_2\",",
            "                'links': [",
            "                    {",
            "                        'href': expected_server_href_2,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': expected_server_bookmark_2,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            },",
            "        ]}",
            "",
            "        output = serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'servers_index', version='v3')",
            "        server_elems = root.findall('{0}server'.format(NS))",
            "        self.assertEqual(len(server_elems), 2)",
            "        for i, server_elem in enumerate(server_elems):",
            "            server_dict = fixture['servers'][i]",
            "            for key in ['name', 'id']:",
            "                self.assertEqual(server_elem.get(key), str(server_dict[key]))",
            "",
            "            link_nodes = server_elem.findall('{0}link'.format(ATOMNS))",
            "            self.assertEqual(len(link_nodes), 2)",
            "            for i, link in enumerate(server_dict['links']):",
            "                for key, value in link.items():",
            "                    self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "    def test_index_with_servers_links(self):",
            "        serializer = servers.MinimalServersTemplate()",
            "",
            "        uuid1 = fakes.get_fake_uuid(1)",
            "        uuid2 = fakes.get_fake_uuid(2)",
            "        expected_server_href = 'http://localhost/v3/servers/%s' % uuid1",
            "        expected_server_next = self.SERVER_NEXT % (2, 2)",
            "        expected_server_bookmark = 'http://localhost/servers/%s' % uuid1",
            "        expected_server_href_2 = 'http://localhost/v3/servers/%s' % uuid2",
            "        expected_server_bookmark_2 = 'http://localhost/servers/%s' % uuid2",
            "        fixture = {\"servers\": [",
            "            {",
            "                \"id\": fakes.get_fake_uuid(1),",
            "                \"name\": \"test_server\",",
            "                'links': [",
            "                    {",
            "                        'href': expected_server_href,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': expected_server_bookmark,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            },",
            "            {",
            "                \"id\": fakes.get_fake_uuid(2),",
            "                \"name\": \"test_server_2\",",
            "                'links': [",
            "                    {",
            "                        'href': expected_server_href_2,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': expected_server_bookmark_2,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            },",
            "        ],",
            "        \"servers_links\": [",
            "            {",
            "                'rel': 'next',",
            "                'href': expected_server_next,",
            "            },",
            "        ]}",
            "",
            "        output = serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'servers_index', version='v3')",
            "        server_elems = root.findall('{0}server'.format(NS))",
            "        self.assertEqual(len(server_elems), 2)",
            "        for i, server_elem in enumerate(server_elems):",
            "            server_dict = fixture['servers'][i]",
            "            for key in ['name', 'id']:",
            "                self.assertEqual(server_elem.get(key), str(server_dict[key]))",
            "",
            "            link_nodes = server_elem.findall('{0}link'.format(ATOMNS))",
            "            self.assertEqual(len(link_nodes), 2)",
            "            for i, link in enumerate(server_dict['links']):",
            "                for key, value in link.items():",
            "                    self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        # Check servers_links",
            "        servers_links = root.findall('{0}link'.format(ATOMNS))",
            "        for i, link in enumerate(fixture['servers_links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(servers_links[i].get(key), value)",
            "",
            "    def test_detail(self):",
            "        serializer = servers.ServersTemplate()",
            "",
            "        uuid1 = fakes.get_fake_uuid(1)",
            "        expected_server_href = 'http://localhost/v3/servers/%s' % uuid1",
            "        expected_server_bookmark = 'http://localhost/servers/%s' % uuid1",
            "        expected_image_bookmark = self.IMAGE_BOOKMARK",
            "        expected_flavor_bookmark = self.FLAVOR_BOOKMARK",
            "",
            "        uuid2 = fakes.get_fake_uuid(2)",
            "        expected_server_href_2 = 'http://localhost/v3/servers/%s' % uuid2",
            "        expected_server_bookmark_2 = 'http://localhost/servers/%s' % uuid2",
            "        fixture = {\"servers\": [",
            "            {",
            "                \"id\": fakes.get_fake_uuid(1),",
            "                \"user_id\": \"fake\",",
            "                \"tenant_id\": \"fake\",",
            "                'created': self.TIMESTAMP,",
            "                'updated': self.TIMESTAMP,",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"access_ip_v4\": \"1.2.3.4\",",
            "                \"access_ip_v6\": \"fead::1234\",",
            "                \"host_id\": 'e4d909c290d0fb1ca068ffaddf22cbd0',",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": expected_image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": expected_flavor_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    \"network_one\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "",
            "                        },",
            "                    ],",
            "                },",
            "                \"metadata\": {",
            "                    \"Number\": \"1\",",
            "                },",
            "                \"links\": [",
            "                    {",
            "                        \"href\": expected_server_href,",
            "                        \"rel\": \"self\",",
            "                    },",
            "                    {",
            "                        \"href\": expected_server_bookmark,",
            "                        \"rel\": \"bookmark\",",
            "                    },",
            "                ],",
            "            },",
            "            {",
            "                \"id\": fakes.get_fake_uuid(2),",
            "                \"user_id\": 'fake',",
            "                \"tenant_id\": 'fake',",
            "                'created': self.TIMESTAMP,",
            "                'updated': self.TIMESTAMP,",
            "                \"progress\": 100,",
            "                \"name\": \"test_server_2\",",
            "                \"status\": \"ACTIVE\",",
            "                \"access_ip_v4\": \"1.2.3.4\",",
            "                \"access_ip_v6\": \"fead::1234\",",
            "                \"host_id\": 'e4d909c290d0fb1ca068ffaddf22cbd0',",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": expected_image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": expected_flavor_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    \"network_one\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "",
            "                        },",
            "                    ],",
            "                },",
            "                \"metadata\": {",
            "                    \"Number\": \"2\",",
            "                },",
            "                \"links\": [",
            "                    {",
            "                        \"href\": expected_server_href_2,",
            "                        \"rel\": \"self\",",
            "                    },",
            "                    {",
            "                        \"href\": expected_server_bookmark_2,",
            "                        \"rel\": \"bookmark\",",
            "                    },",
            "                ],",
            "            },",
            "        ]}",
            "",
            "        output = serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'servers', version='v3')",
            "        server_elems = root.findall('{0}server'.format(NS))",
            "        self.assertEqual(len(server_elems), 2)",
            "        for i, server_elem in enumerate(server_elems):",
            "            server_dict = fixture['servers'][i]",
            "",
            "            for key in ['name', 'id', 'created', 'access_ip_v4',",
            "                        'updated', 'progress', 'status', 'host_id',",
            "                        'access_ip_v6']:",
            "                self.assertEqual(server_elem.get(key), str(server_dict[key]))",
            "",
            "            link_nodes = server_elem.findall('{0}link'.format(ATOMNS))",
            "            self.assertEqual(len(link_nodes), 2)",
            "            for i, link in enumerate(server_dict['links']):",
            "                for key, value in link.items():",
            "                    self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "            metadata_root = server_elem.find('{0}metadata'.format(NS))",
            "            metadata_elems = metadata_root.findall('{0}meta'.format(NS))",
            "            for i, metadata_elem in enumerate(metadata_elems):",
            "                (meta_key, meta_value) = server_dict['metadata'].items()[i]",
            "                self.assertEqual(str(metadata_elem.get('key')), str(meta_key))",
            "                self.assertEqual(str(metadata_elem.text).strip(),",
            "                                 str(meta_value))",
            "",
            "            image_root = server_elem.find('{0}image'.format(NS))",
            "            self.assertEqual(image_root.get('id'), server_dict['image']['id'])",
            "            link_nodes = image_root.findall('{0}link'.format(ATOMNS))",
            "            self.assertEqual(len(link_nodes), 1)",
            "            for i, link in enumerate(server_dict['image']['links']):",
            "                for key, value in link.items():",
            "                    self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "            flavor_root = server_elem.find('{0}flavor'.format(NS))",
            "            self.assertEqual(flavor_root.get('id'),",
            "                             server_dict['flavor']['id'])",
            "            link_nodes = flavor_root.findall('{0}link'.format(ATOMNS))",
            "            self.assertEqual(len(link_nodes), 1)",
            "            for i, link in enumerate(server_dict['flavor']['links']):",
            "                for key, value in link.items():",
            "                    self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "            addresses_root = server_elem.find('{0}addresses'.format(NS))",
            "            addresses_dict = server_dict['addresses']",
            "            network_elems = addresses_root.findall('{0}network'.format(NS))",
            "            for i, network_elem in enumerate(network_elems):",
            "                network = addresses_dict.items()[i]",
            "                self.assertEqual(str(network_elem.get('id')), str(network[0]))",
            "                ip_elems = network_elem.findall('{0}ip'.format(NS))",
            "                for z, ip_elem in enumerate(ip_elems):",
            "                    ip = network[1][z]",
            "                    self.assertEqual(str(ip_elem.get('version')),",
            "                                     str(ip['version']))",
            "                    self.assertEqual(str(ip_elem.get('addr')),",
            "                                     str(ip['addr']))",
            "                    self.assertEqual(str(ip_elem.get('type')),",
            "                                 str(ip['type']))",
            "                self.assertEqual(str(ip_elem.get('mac_addr')),",
            "                                 str(ip['mac_addr']))",
            "",
            "    def test_update(self):",
            "        serializer = servers.ServerTemplate()",
            "",
            "        fixture = {",
            "            \"server\": {",
            "                \"id\": FAKE_UUID,",
            "                \"user_id\": \"fake\",",
            "                \"tenant_id\": \"fake\",",
            "                'created': self.TIMESTAMP,",
            "                'updated': self.TIMESTAMP,",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"host_id\": 'e4d909c290d0fb1ca068ffaddf22cbd0',",
            "                \"access_ip_v4\": \"1.2.3.4\",",
            "                \"access_ip_v6\": \"fead::1234\",",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.IMAGE_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.FLAVOR_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    \"network_one\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                    ],",
            "                    \"network_two\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.139\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.139\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                    ],",
            "                },",
            "                \"metadata\": {",
            "                    \"Open\": \"Stack\",",
            "                    \"Number\": \"1\",",
            "                },",
            "                'links': [",
            "                    {",
            "                        'href': self.SERVER_HREF,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': self.SERVER_BOOKMARK,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "                \"fault\": {",
            "                    \"code\": 500,",
            "                    \"created\": self.TIMESTAMP,",
            "                    \"message\": \"Error Message\",",
            "                    \"details\": \"Fault details\",",
            "                }",
            "            }",
            "        }",
            "",
            "        output = serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'server', version='v3')",
            "",
            "        server_dict = fixture['server']",
            "",
            "        for key in ['name', 'id', 'created', 'access_ip_v4',",
            "                    'updated', 'progress', 'status', 'host_id',",
            "                    'access_ip_v6']:",
            "            self.assertEqual(root.get(key), str(server_dict[key]))",
            "",
            "        link_nodes = root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 2)",
            "        for i, link in enumerate(server_dict['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        metadata_root = root.find('{0}metadata'.format(NS))",
            "        metadata_elems = metadata_root.findall('{0}meta'.format(NS))",
            "        self.assertEqual(len(metadata_elems), 2)",
            "        for i, metadata_elem in enumerate(metadata_elems):",
            "            (meta_key, meta_value) = server_dict['metadata'].items()[i]",
            "            self.assertEqual(str(metadata_elem.get('key')), str(meta_key))",
            "            self.assertEqual(str(metadata_elem.text).strip(), str(meta_value))",
            "",
            "        image_root = root.find('{0}image'.format(NS))",
            "        self.assertEqual(image_root.get('id'), server_dict['image']['id'])",
            "        link_nodes = image_root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 1)",
            "        for i, link in enumerate(server_dict['image']['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        flavor_root = root.find('{0}flavor'.format(NS))",
            "        self.assertEqual(flavor_root.get('id'), server_dict['flavor']['id'])",
            "        link_nodes = flavor_root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 1)",
            "        for i, link in enumerate(server_dict['flavor']['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        addresses_root = root.find('{0}addresses'.format(NS))",
            "        addresses_dict = server_dict['addresses']",
            "        network_elems = addresses_root.findall('{0}network'.format(NS))",
            "        self.assertEqual(len(network_elems), 2)",
            "        for i, network_elem in enumerate(network_elems):",
            "            network = addresses_dict.items()[i]",
            "            self.assertEqual(str(network_elem.get('id')), str(network[0]))",
            "            ip_elems = network_elem.findall('{0}ip'.format(NS))",
            "            for z, ip_elem in enumerate(ip_elems):",
            "                ip = network[1][z]",
            "                self.assertEqual(str(ip_elem.get('version')),",
            "                                 str(ip['version']))",
            "                self.assertEqual(str(ip_elem.get('addr')),",
            "                                 str(ip['addr']))",
            "                self.assertEqual(str(ip_elem.get('type')),",
            "                                 str(ip['type']))",
            "                self.assertEqual(str(ip_elem.get('mac_addr')),",
            "                                 str(ip['mac_addr']))",
            "",
            "        fault_root = root.find('{0}fault'.format(NS))",
            "        fault_dict = server_dict['fault']",
            "        self.assertEqual(fault_root.get(\"code\"), str(fault_dict[\"code\"]))",
            "        self.assertEqual(fault_root.get(\"created\"), fault_dict[\"created\"])",
            "        msg_elem = fault_root.find('{0}message'.format(NS))",
            "        self.assertEqual(msg_elem.text, fault_dict[\"message\"])",
            "        det_elem = fault_root.find('{0}details'.format(NS))",
            "        self.assertEqual(det_elem.text, fault_dict[\"details\"])",
            "",
            "    def test_action(self):",
            "        serializer = servers.FullServerTemplate()",
            "",
            "        fixture = {",
            "            \"server\": {",
            "                \"id\": FAKE_UUID,",
            "                \"user_id\": \"fake\",",
            "                \"tenant_id\": \"fake\",",
            "                'created': self.TIMESTAMP,",
            "                'updated': self.TIMESTAMP,",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"access_ip_v4\": \"1.2.3.4\",",
            "                \"access_ip_v6\": \"fead::1234\",",
            "                \"host_id\": \"e4d909c290d0fb1ca068ffaddf22cbd0\",",
            "                \"admin_pass\": \"test_password\",",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.IMAGE_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.FLAVOR_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    \"network_one\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                    ],",
            "                    \"network_two\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.139\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.139\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                    ],",
            "                },",
            "                \"metadata\": {",
            "                    \"Open\": \"Stack\",",
            "                    \"Number\": \"1\",",
            "                },",
            "                'links': [",
            "                    {",
            "                        'href': self.SERVER_HREF,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': self.SERVER_BOOKMARK,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        output = serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'server', version='v3')",
            "",
            "        server_dict = fixture['server']",
            "",
            "        for key in ['name', 'id', 'created', 'access_ip_v4',",
            "                    'updated', 'progress', 'status', 'host_id',",
            "                    'access_ip_v6', 'admin_pass']:",
            "            self.assertEqual(root.get(key), str(server_dict[key]))",
            "",
            "        link_nodes = root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 2)",
            "        for i, link in enumerate(server_dict['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        metadata_root = root.find('{0}metadata'.format(NS))",
            "        metadata_elems = metadata_root.findall('{0}meta'.format(NS))",
            "        self.assertEqual(len(metadata_elems), 2)",
            "        for i, metadata_elem in enumerate(metadata_elems):",
            "            (meta_key, meta_value) = server_dict['metadata'].items()[i]",
            "            self.assertEqual(str(metadata_elem.get('key')), str(meta_key))",
            "            self.assertEqual(str(metadata_elem.text).strip(), str(meta_value))",
            "",
            "        image_root = root.find('{0}image'.format(NS))",
            "        self.assertEqual(image_root.get('id'), server_dict['image']['id'])",
            "        link_nodes = image_root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 1)",
            "        for i, link in enumerate(server_dict['image']['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        flavor_root = root.find('{0}flavor'.format(NS))",
            "        self.assertEqual(flavor_root.get('id'), server_dict['flavor']['id'])",
            "        link_nodes = flavor_root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 1)",
            "        for i, link in enumerate(server_dict['flavor']['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        addresses_root = root.find('{0}addresses'.format(NS))",
            "        addresses_dict = server_dict['addresses']",
            "        network_elems = addresses_root.findall('{0}network'.format(NS))",
            "        self.assertEqual(len(network_elems), 2)",
            "        for i, network_elem in enumerate(network_elems):",
            "            network = addresses_dict.items()[i]",
            "            self.assertEqual(str(network_elem.get('id')), str(network[0]))",
            "            ip_elems = network_elem.findall('{0}ip'.format(NS))",
            "            for z, ip_elem in enumerate(ip_elems):",
            "                ip = network[1][z]",
            "                self.assertEqual(str(ip_elem.get('version')),",
            "                                 str(ip['version']))",
            "                self.assertEqual(str(ip_elem.get('addr')),",
            "                                 str(ip['addr']))",
            "                self.assertEqual(str(ip_elem.get('type')),",
            "                                 str(ip['type']))",
            "                self.assertEqual(str(ip_elem.get('mac_addr')),",
            "                                 str(ip['mac_addr']))",
            "",
            "",
            "class ServersAllExtensionsTestCase(test.TestCase):",
            "    \"\"\"",
            "    Servers tests using default API router with all extensions enabled.",
            "",
            "    The intent here is to catch cases where extensions end up throwing",
            "    an exception because of a malformed request before the core API",
            "    gets a chance to validate the request and return a 422 response.",
            "",
            "    For example, ServerDiskConfigController extends servers.Controller:",
            "",
            "      @wsgi.extends",
            "      def create(self, req, body):",
            "          if 'server' in body:",
            "                self._set_disk_config(body['server'])",
            "          resp_obj = (yield)",
            "          self._show(req, resp_obj)",
            "",
            "    we want to ensure that the extension isn't barfing on an invalid",
            "    body.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        super(ServersAllExtensionsTestCase, self).setUp()",
            "        self.app = compute.APIRouterV3()",
            "",
            "    def test_create_missing_server(self):",
            "        # Test create with malformed body.",
            "",
            "        def fake_create(*args, **kwargs):",
            "            raise test.TestingException(\"Should not reach the compute API.\")",
            "",
            "        self.stubs.Set(compute_api.API, 'create', fake_create)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers')",
            "        req.method = 'POST'",
            "        req.content_type = 'application/json'",
            "        body = {'foo': {'a': 'b'}}",
            "",
            "        req.body = jsonutils.dumps(body)",
            "        res = req.get_response(self.app)",
            "        self.assertEqual(422, res.status_int)",
            "",
            "    def test_update_missing_server(self):",
            "        # Test create with malformed body.",
            "",
            "        def fake_update(*args, **kwargs):",
            "            raise test.TestingException(\"Should not reach the compute API.\")",
            "",
            "        self.stubs.Set(compute_api.API, 'create', fake_update)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers/1')",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        body = {'foo': {'a': 'b'}}",
            "",
            "        req.body = jsonutils.dumps(body)",
            "        res = req.get_response(self.app)",
            "        self.assertEqual(422, res.status_int)",
            "",
            "",
            "class ServersUnprocessableEntityTestCase(test.TestCase):",
            "    \"\"\"",
            "    Tests of places we throw 422 Unprocessable Entity from",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        super(ServersUnprocessableEntityTestCase, self).setUp()",
            "        ext_info = plugins.LoadedExtensionInfo()",
            "        self.controller = servers.ServersController(extension_info=ext_info)",
            "",
            "    def _unprocessable_server_create(self, body):",
            "        req = fakes.HTTPRequestV3.blank('/servers')",
            "        req.method = 'POST'",
            "",
            "        self.assertRaises(webob.exc.HTTPUnprocessableEntity,",
            "                          self.controller.create, req, body)",
            "",
            "    def test_create_server_no_body(self):",
            "        self._unprocessable_server_create(body=None)",
            "",
            "    def test_create_server_missing_server(self):",
            "        body = {'foo': {'a': 'b'}}",
            "        self._unprocessable_server_create(body=body)",
            "",
            "    def test_create_server_malformed_entity(self):",
            "        body = {'server': 'string'}",
            "        self._unprocessable_server_create(body=body)",
            "",
            "    def _unprocessable_server_update(self, body):",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s' % FAKE_UUID)",
            "        req.method = 'PUT'",
            "",
            "        self.assertRaises(webob.exc.HTTPUnprocessableEntity,",
            "                          self.controller.update, req, FAKE_UUID, body)",
            "",
            "    def test_update_server_no_body(self):",
            "        self._unprocessable_server_update(body=None)",
            "",
            "    def test_update_server_missing_server(self):",
            "        body = {'foo': {'a': 'b'}}",
            "        self._unprocessable_server_update(body=body)",
            "",
            "    def test_create_update_malformed_entity(self):",
            "        body = {'server': 'string'}",
            "        self._unprocessable_server_update(body=body)"
        ],
        "afterPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2010-2011 OpenStack Foundation",
            "# Copyright 2011 Piston Cloud Computing, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import base64",
            "import datetime",
            "import mox",
            "import testtools",
            "import urlparse",
            "import uuid",
            "",
            "import iso8601",
            "from lxml import etree",
            "from oslo.config import cfg",
            "import webob",
            "",
            "from nova.api.openstack import compute",
            "from nova.api.openstack.compute import plugins",
            "from nova.api.openstack.compute.plugins.v3 import availability_zone",
            "from nova.api.openstack.compute.plugins.v3 import ips",
            "from nova.api.openstack.compute.plugins.v3 import keypairs",
            "from nova.api.openstack.compute.plugins.v3 import servers",
            "from nova.api.openstack.compute import views",
            "from nova.api.openstack import xmlutil",
            "from nova.compute import api as compute_api",
            "from nova.compute import flavors",
            "from nova.compute import task_states",
            "from nova.compute import vm_states",
            "from nova import context",
            "from nova import db",
            "from nova.db.sqlalchemy import models",
            "from nova import exception",
            "from nova.image import glance",
            "from nova.network import manager",
            "from nova.network.neutronv2 import api as neutron_api",
            "from nova.objects import instance as instance_obj",
            "from nova.openstack.common.gettextutils import _",
            "from nova.openstack.common import jsonutils",
            "from nova.openstack.common import policy as common_policy",
            "from nova.openstack.common import rpc",
            "from nova import policy",
            "from nova import test",
            "from nova.tests.api.openstack import fakes",
            "from nova.tests import fake_instance",
            "from nova.tests import fake_network",
            "from nova.tests.image import fake",
            "from nova.tests import matchers",
            "from nova.tests import utils",
            "",
            "CONF = cfg.CONF",
            "CONF.import_opt('password_length', 'nova.utils')",
            "CONF.import_opt('scheduler_topic', 'nova.scheduler.rpcapi')",
            "",
            "FAKE_UUID = fakes.FAKE_UUID",
            "NS = \"{http://docs.openstack.org/compute/api/v1.1}\"",
            "ATOMNS = \"{http://www.w3.org/2005/Atom}\"",
            "XPATH_NS = {",
            "    'atom': 'http://www.w3.org/2005/Atom',",
            "    'ns': 'http://docs.openstack.org/compute/api/v1.1'",
            "}",
            "",
            "INSTANCE_IDS = {FAKE_UUID: 1}",
            "FIELDS = instance_obj.INSTANCE_DEFAULT_FIELDS",
            "",
            "",
            "def fake_gen_uuid():",
            "    return FAKE_UUID",
            "",
            "",
            "def return_servers_empty(context, *args, **kwargs):",
            "    return []",
            "",
            "",
            "def return_security_group(context, instance_id, security_group_id):",
            "    pass",
            "",
            "",
            "def instance_update(context, instance_uuid, values, update_cells=True):",
            "    inst = fakes.stub_instance(INSTANCE_IDS.get(instance_uuid),",
            "                               name=values.get('display_name'))",
            "    inst = dict(inst, **values)",
            "    return (inst, inst)",
            "",
            "",
            "def fake_compute_api(cls, req, id):",
            "    return True",
            "",
            "",
            "def fake_start_stop_not_ready(self, context, instance):",
            "    raise exception.InstanceNotReady(instance_id=instance[\"uuid\"])",
            "",
            "",
            "def fake_instance_get_by_uuid_not_found(context, uuid, columns_to_join):",
            "    raise exception.InstanceNotFound(instance_id=uuid)",
            "",
            "",
            "class MockSetAdminPassword(object):",
            "    def __init__(self):",
            "        self.instance_id = None",
            "        self.password = None",
            "",
            "    def __call__(self, context, instance_id, password):",
            "        self.instance_id = instance_id",
            "        self.password = password",
            "",
            "",
            "class Base64ValidationTest(test.TestCase):",
            "    def setUp(self):",
            "        super(Base64ValidationTest, self).setUp()",
            "        ext_info = plugins.LoadedExtensionInfo()",
            "        self.controller = servers.ServersController(extension_info=ext_info)",
            "",
            "    def test_decode_base64(self):",
            "        value = \"A random string\"",
            "        result = self.controller._decode_base64(base64.b64encode(value))",
            "        self.assertEqual(result, value)",
            "",
            "    def test_decode_base64_binary(self):",
            "        value = \"\\x00\\x12\\x75\\x99\"",
            "        result = self.controller._decode_base64(base64.b64encode(value))",
            "        self.assertEqual(result, value)",
            "",
            "    def test_decode_base64_whitespace(self):",
            "        value = \"A random string\"",
            "        encoded = base64.b64encode(value)",
            "        white = \"\\n \\n%s\\t%s\\n\" % (encoded[:2], encoded[2:])",
            "        result = self.controller._decode_base64(white)",
            "        self.assertEqual(result, value)",
            "",
            "    def test_decode_base64_invalid(self):",
            "        invalid = \"A random string\"",
            "        result = self.controller._decode_base64(invalid)",
            "        self.assertEqual(result, None)",
            "",
            "    def test_decode_base64_illegal_bytes(self):",
            "        value = \"A random string\"",
            "        encoded = base64.b64encode(value)",
            "        white = \">\\x01%s*%s()\" % (encoded[:2], encoded[2:])",
            "        result = self.controller._decode_base64(white)",
            "        self.assertEqual(result, None)",
            "",
            "",
            "class NeutronV2Subclass(neutron_api.API):",
            "    \"\"\"Used to ensure that API handles subclasses properly.\"\"\"",
            "    pass",
            "",
            "",
            "class ControllerTest(test.TestCase):",
            "",
            "    def setUp(self):",
            "        super(ControllerTest, self).setUp()",
            "        self.flags(verbose=True, use_ipv6=False)",
            "        fakes.stub_out_rate_limiting(self.stubs)",
            "        fakes.stub_out_key_pair_funcs(self.stubs)",
            "        fake.stub_out_image_service(self.stubs)",
            "        return_server = fakes.fake_instance_get()",
            "        return_servers = fakes.fake_instance_get_all_by_filters()",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       return_servers)",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                       return_server)",
            "        self.stubs.Set(db, 'instance_add_security_group',",
            "                       return_security_group)",
            "        self.stubs.Set(db, 'instance_update_and_get_original',",
            "                       instance_update)",
            "",
            "        ext_info = plugins.LoadedExtensionInfo()",
            "        self.controller = servers.ServersController(extension_info=ext_info)",
            "        self.ips_controller = ips.IPsController()",
            "        policy.reset()",
            "        policy.init()",
            "        fake_network.stub_out_nw_api_get_instance_nw_info(self.stubs,",
            "                                                          spectacular=True)",
            "",
            "",
            "class ServersControllerTest(ControllerTest):",
            "",
            "        #    def test_can_check_loaded_extensions(self):",
            "        #self.ext_mgr.extensions = {'os-fake': None}",
            "        #self.assertTrue(self.controller.ext_mgr.is_loaded('os-fake'))",
            "        #self.assertFalse(self.controller.ext_mgr.is_loaded('os-not-loaded'))",
            "",
            "    def test_requested_networks_prefix(self):",
            "        uuid = 'br-00000000-0000-0000-0000-000000000000'",
            "        requested_networks = [{'uuid': uuid}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertTrue((uuid, None) in res)",
            "",
            "    def test_requested_networks_neutronv2_enabled_with_port(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'port': port}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertEquals(res, [(None, None, port)])",
            "",
            "    def test_requested_networks_neutronv2_enabled_with_network(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        network = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        requested_networks = [{'uuid': network}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertEquals(res, [(network, None, None)])",
            "",
            "    def test_requested_networks_neutronv2_enabled_with_network_and_port(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        network = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'uuid': network, 'port': port}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertEquals(res, [(None, None, port)])",
            "",
            "    def test_requested_networks_neutronv2_enabled_conflict_on_fixed_ip(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        network = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        addr = '10.0.0.1'",
            "        requested_networks = [{'uuid': network,",
            "                               'fixed_ip': addr,",
            "                               'port': port}]",
            "        self.assertRaises(",
            "            webob.exc.HTTPBadRequest,",
            "            self.controller._get_requested_networks,",
            "            requested_networks)",
            "",
            "    def test_requested_networks_neutronv2_disabled_with_port(self):",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'port': port}]",
            "        self.assertRaises(",
            "            webob.exc.HTTPBadRequest,",
            "            self.controller._get_requested_networks,",
            "            requested_networks)",
            "",
            "    def test_requested_networks_api_enabled_with_v2_subclass(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        network = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'uuid': network, 'port': port}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertEquals(res, [(None, None, port)])",
            "",
            "    def test_requested_networks_neutronv2_subclass_with_port(self):",
            "        cls = 'nova.tests.api.openstack.compute.test_servers.NeutronV2Subclass'",
            "        self.flags(network_api_class=cls)",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'port': port}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertEquals(res, [(None, None, port)])",
            "",
            "    def test_get_server_by_uuid(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s' % FAKE_UUID)",
            "        res_dict = self.controller.show(req, FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "",
            "    def test_unique_host_id(self):",
            "        \"\"\"Create two servers with the same host and different",
            "        project_ids and check that the host_id's are unique.",
            "        \"\"\"",
            "        def return_instance_with_host(self, *args, **kwargs):",
            "            project_id = str(uuid.uuid4())",
            "            return fakes.stub_instance(id=1, uuid=FAKE_UUID,",
            "                                       project_id=project_id,",
            "                                       host='fake_host')",
            "",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                       return_instance_with_host)",
            "        self.stubs.Set(db, 'instance_get',",
            "                       return_instance_with_host)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s' % FAKE_UUID)",
            "        server1 = self.controller.show(req, FAKE_UUID)",
            "        server2 = self.controller.show(req, FAKE_UUID)",
            "",
            "        self.assertNotEqual(server1['server']['host_id'],",
            "                            server2['server']['host_id'])",
            "",
            "    def test_get_server_by_id(self):",
            "        self.flags(use_ipv6=True)",
            "        image_bookmark = \"http://localhost/images/10\"",
            "        flavor_bookmark = \"http://localhost/flavors/1\"",
            "",
            "        uuid = FAKE_UUID",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s' % uuid)",
            "        res_dict = self.controller.show(req, uuid)",
            "",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 0,",
            "                \"name\": \"server1\",",
            "                \"status\": \"BUILD\",",
            "                \"access_ip_v4\": \"\",",
            "                \"access_ip_v6\": \"\",",
            "                \"host_id\": '',",
            "                \"image\": {",
            "                    \"id\": \"10\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                  \"links\": [",
            "                                            {",
            "                          \"rel\": \"bookmark\",",
            "                          \"href\": flavor_bookmark,",
            "                      },",
            "                  ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'}",
            "                    ]",
            "                },",
            "                \"metadata\": {",
            "                    \"seq\": \"1\",",
            "                },",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": \"http://localhost/v3/servers/%s\" % uuid,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": \"http://localhost/servers/%s\" % uuid,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        self.assertThat(res_dict, matchers.DictMatches(expected_server))",
            "",
            "    def test_get_server_with_active_status_by_id(self):",
            "        image_bookmark = \"http://localhost/images/10\"",
            "        flavor_bookmark = \"http://localhost/flavors/1\"",
            "",
            "        new_return_server = fakes.fake_instance_get(",
            "                vm_state=vm_states.ACTIVE, progress=100)",
            "        self.stubs.Set(db, 'instance_get_by_uuid', new_return_server)",
            "",
            "        uuid = FAKE_UUID",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s' % uuid)",
            "        res_dict = self.controller.show(req, uuid)",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 100,",
            "                \"name\": \"server1\",",
            "                \"status\": \"ACTIVE\",",
            "                \"access_ip_v4\": \"\",",
            "                \"access_ip_v6\": \"\",",
            "                \"host_id\": '',",
            "                \"image\": {",
            "                    \"id\": \"10\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                  \"links\": [",
            "                      {",
            "                          \"rel\": \"bookmark\",",
            "                          \"href\": flavor_bookmark,",
            "                      },",
            "                  ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                    ]",
            "                },",
            "                \"metadata\": {",
            "                    \"seq\": \"1\",",
            "                },",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": \"http://localhost/v3/servers/%s\" % uuid,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": \"http://localhost/servers/%s\" % uuid,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        self.assertThat(res_dict, matchers.DictMatches(expected_server))",
            "",
            "    def test_get_server_with_id_image_ref_by_id(self):",
            "        image_ref = \"10\"",
            "        image_bookmark = \"http://localhost/images/10\"",
            "        flavor_id = \"1\"",
            "        flavor_bookmark = \"http://localhost/flavors/1\"",
            "",
            "        new_return_server = fakes.fake_instance_get(",
            "                vm_state=vm_states.ACTIVE, image_ref=image_ref,",
            "                flavor_id=flavor_id, progress=100)",
            "        self.stubs.Set(db, 'instance_get_by_uuid', new_return_server)",
            "",
            "        uuid = FAKE_UUID",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s' % uuid)",
            "        res_dict = self.controller.show(req, uuid)",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 100,",
            "                \"name\": \"server1\",",
            "                \"status\": \"ACTIVE\",",
            "                \"access_ip_v4\": \"\",",
            "                \"access_ip_v6\": \"\",",
            "                \"host_id\": '',",
            "                \"image\": {",
            "                    \"id\": \"10\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                  \"links\": [",
            "                      {",
            "                          \"rel\": \"bookmark\",",
            "                          \"href\": flavor_bookmark,",
            "                      },",
            "                  ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                    ]",
            "                },",
            "                \"metadata\": {",
            "                    \"seq\": \"1\",",
            "                },",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": \"http://localhost/v3/servers/%s\" % uuid,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": \"http://localhost/servers/%s\" % uuid,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        self.assertThat(res_dict, matchers.DictMatches(expected_server))",
            "",
            "    def test_get_server_addresses_from_cache(self):",
            "        pub0 = ('172.19.0.1', '172.19.0.2',)",
            "        pub1 = ('1.2.3.4',)",
            "        pub2 = ('b33f::fdee:ddff:fecc:bbaa',)",
            "        priv0 = ('192.168.0.3', '192.168.0.4',)",
            "",
            "        def _ip(ip):",
            "            return {'address': ip, 'type': 'fixed'}",
            "",
            "        nw_cache = [",
            "            {'address': 'aa:aa:aa:aa:aa:aa',",
            "             'id': 1,",
            "             'network': {'bridge': 'br0',",
            "                         'id': 1,",
            "                         'label': 'public',",
            "                         'subnets': [{'cidr': '172.19.0.0/24',",
            "                                      'ips': [_ip(ip) for ip in pub0]},",
            "                                      {'cidr': '1.2.3.0/16',",
            "                                       'ips': [_ip(ip) for ip in pub1]},",
            "                                      {'cidr': 'b33f::/64',",
            "                                       'ips': [_ip(ip) for ip in pub2]}]}},",
            "            {'address': 'bb:bb:bb:bb:bb:bb',",
            "             'id': 2,",
            "             'network': {'bridge': 'br1',",
            "                         'id': 2,",
            "                         'label': 'private',",
            "                         'subnets': [{'cidr': '192.168.0.0/24',",
            "                                      'ips': [_ip(ip) for ip in priv0]}]}}]",
            "",
            "        return_server = fakes.fake_instance_get(nw_cache=nw_cache)",
            "        self.stubs.Set(db, 'instance_get_by_uuid', return_server)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s/ips' % FAKE_UUID)",
            "        res_dict = self.ips_controller.index(req, FAKE_UUID)",
            "",
            "        expected = {",
            "            'addresses': {",
            "                'private': [",
            "                    {'version': 4, 'addr': '192.168.0.3',",
            "                     'type': 'fixed', 'mac_addr': 'bb:bb:bb:bb:bb:bb'},",
            "                    {'version': 4, 'addr': '192.168.0.4',",
            "                     'type': 'fixed', 'mac_addr': 'bb:bb:bb:bb:bb:bb'},",
            "                ],",
            "                'public': [",
            "                    {'version': 4, 'addr': '172.19.0.1',",
            "                     'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                    {'version': 4, 'addr': '172.19.0.2',",
            "                     'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                    {'version': 4, 'addr': '1.2.3.4',",
            "                     'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                    {'version': 6, 'addr': 'b33f::fdee:ddff:fecc:bbaa',",
            "                     'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                ],",
            "            },",
            "        }",
            "        self.assertThat(res_dict, matchers.DictMatches(expected))",
            "",
            "    def test_get_server_addresses_nonexistent_network(self):",
            "        url = '/v3/servers/%s/ips/network_0' % FAKE_UUID",
            "        req = fakes.HTTPRequestV3.blank(url)",
            "        self.assertRaises(webob.exc.HTTPNotFound, self.ips_controller.show,",
            "                          req, FAKE_UUID, 'network_0')",
            "",
            "    def test_get_server_addresses_nonexistent_server(self):",
            "        def fake_instance_get(*args, **kwargs):",
            "            raise exception.InstanceNotFound(instance_id='fake')",
            "",
            "        self.stubs.Set(db, 'instance_get_by_uuid', fake_instance_get)",
            "",
            "        server_id = str(uuid.uuid4())",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s/ips' % server_id)",
            "        self.assertRaises(webob.exc.HTTPNotFound,",
            "                          self.ips_controller.index, req, server_id)",
            "",
            "    def test_get_server_list_empty(self):",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       return_servers_empty)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers')",
            "        res_dict = self.controller.index(req)",
            "",
            "        num_servers = len(res_dict['servers'])",
            "        self.assertEqual(0, num_servers)",
            "",
            "    def test_get_server_list_with_reservation_id(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers?reservation_id=foo')",
            "        res_dict = self.controller.index(req)",
            "",
            "        i = 0",
            "        for s in res_dict['servers']:",
            "            self.assertEqual(s.get('name'), 'server%d' % (i + 1))",
            "            i += 1",
            "",
            "    def test_get_server_list_with_reservation_id_empty(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers/detail?'",
            "                                      'reservation_id=foo')",
            "        res_dict = self.controller.detail(req)",
            "",
            "        i = 0",
            "        for s in res_dict['servers']:",
            "            self.assertEqual(s.get('name'), 'server%d' % (i + 1))",
            "            i += 1",
            "",
            "    def test_get_server_list_with_reservation_id_details(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers/detail?'",
            "                                      'reservation_id=foo')",
            "        res_dict = self.controller.detail(req)",
            "",
            "        i = 0",
            "        for s in res_dict['servers']:",
            "            self.assertEqual(s.get('name'), 'server%d' % (i + 1))",
            "            i += 1",
            "",
            "    def test_get_server_list(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers')",
            "        res_dict = self.controller.index(req)",
            "",
            "        self.assertEqual(len(res_dict['servers']), 5)",
            "        for i, s in enumerate(res_dict['servers']):",
            "            self.assertEqual(s['id'], fakes.get_fake_uuid(i))",
            "            self.assertEqual(s['name'], 'server%d' % (i + 1))",
            "            self.assertEqual(s.get('image', None), None)",
            "",
            "            expected_links = [",
            "                {",
            "                    \"rel\": \"self\",",
            "                    \"href\": \"http://localhost/v3/servers/%s\" % s['id'],",
            "                },",
            "                {",
            "                    \"rel\": \"bookmark\",",
            "                    \"href\": \"http://localhost/servers/%s\" % s['id'],",
            "                },",
            "            ]",
            "",
            "            self.assertEqual(s['links'], expected_links)",
            "",
            "    def test_get_servers_with_limit(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers?limit=3')",
            "        res_dict = self.controller.index(req)",
            "",
            "        servers = res_dict['servers']",
            "        self.assertEqual([s['id'] for s in servers],",
            "                [fakes.get_fake_uuid(i) for i in xrange(len(servers))])",
            "",
            "        servers_links = res_dict['servers_links']",
            "        self.assertEqual(servers_links[0]['rel'], 'next')",
            "        href_parts = urlparse.urlparse(servers_links[0]['href'])",
            "        self.assertEqual('/v3/servers', href_parts.path)",
            "        params = urlparse.parse_qs(href_parts.query)",
            "        expected_params = {'limit': ['3'],",
            "                           'marker': [fakes.get_fake_uuid(2)]}",
            "        self.assertThat(params, matchers.DictMatches(expected_params))",
            "",
            "    def test_get_servers_with_limit_bad_value(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers?limit=aaa')",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.index, req)",
            "",
            "    def test_get_server_details_empty(self):",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       return_servers_empty)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers/detail')",
            "        res_dict = self.controller.index(req)",
            "",
            "        num_servers = len(res_dict['servers'])",
            "        self.assertEqual(0, num_servers)",
            "",
            "    def test_get_server_details_with_limit(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers/detail?limit=3')",
            "        res = self.controller.detail(req)",
            "",
            "        servers = res['servers']",
            "        self.assertEqual([s['id'] for s in servers],",
            "                [fakes.get_fake_uuid(i) for i in xrange(len(servers))])",
            "",
            "        servers_links = res['servers_links']",
            "        self.assertEqual(servers_links[0]['rel'], 'next')",
            "",
            "        href_parts = urlparse.urlparse(servers_links[0]['href'])",
            "        self.assertEqual('/v3/servers', href_parts.path)",
            "        params = urlparse.parse_qs(href_parts.query)",
            "        expected = {'limit': ['3'], 'marker': [fakes.get_fake_uuid(2)]}",
            "        self.assertThat(params, matchers.DictMatches(expected))",
            "",
            "    def test_get_server_details_with_limit_bad_value(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers/detail?limit=aaa')",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.detail, req)",
            "",
            "    def test_get_server_details_with_limit_and_other_params(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers/detail'",
            "                                      '?limit=3&blah=2:t')",
            "        res = self.controller.detail(req)",
            "",
            "        servers = res['servers']",
            "        self.assertEqual([s['id'] for s in servers],",
            "                [fakes.get_fake_uuid(i) for i in xrange(len(servers))])",
            "",
            "        servers_links = res['servers_links']",
            "        self.assertEqual(servers_links[0]['rel'], 'next')",
            "",
            "        href_parts = urlparse.urlparse(servers_links[0]['href'])",
            "        self.assertEqual('/v3/servers', href_parts.path)",
            "        params = urlparse.parse_qs(href_parts.query)",
            "        expected = {'limit': ['3'], 'blah': ['2:t'],",
            "                    'marker': [fakes.get_fake_uuid(2)]}",
            "        self.assertThat(params, matchers.DictMatches(expected))",
            "",
            "    def test_get_servers_with_too_big_limit(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers?limit=30')",
            "        res_dict = self.controller.index(req)",
            "        self.assertTrue('servers_links' not in res_dict)",
            "",
            "    def test_get_servers_with_bad_limit(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers?limit=asdf')",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.index, req)",
            "",
            "    def test_get_servers_with_marker(self):",
            "        url = '/v3/servers?marker=%s' % fakes.get_fake_uuid(2)",
            "        req = fakes.HTTPRequestV3.blank(url)",
            "        servers = self.controller.index(req)['servers']",
            "        self.assertEqual([s['name'] for s in servers], [\"server4\", \"server5\"])",
            "",
            "    def test_get_servers_with_limit_and_marker(self):",
            "        url = '/v3/servers?limit=2&marker=%s' % fakes.get_fake_uuid(1)",
            "        req = fakes.HTTPRequestV3.blank(url)",
            "        servers = self.controller.index(req)['servers']",
            "        self.assertEqual([s['name'] for s in servers], ['server3', 'server4'])",
            "",
            "    def test_get_servers_with_bad_marker(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers?limit=2&marker=asdf')",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.index, req)",
            "",
            "    def test_get_servers_with_bad_option(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers?unknownoption=whee')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_allows_image(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('image' in search_opts)",
            "            self.assertEqual(search_opts['image'], '12345')",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers?image=12345')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_tenant_id_filter_converts_to_project_id_for_admin(self):",
            "        def fake_get_all(context, filters=None, sort_key=None,",
            "                         sort_dir='desc', limit=None, marker=None,",
            "                         columns_to_join=None):",
            "            self.assertNotEqual(filters, None)",
            "            self.assertEqual(filters['project_id'], 'fake')",
            "            self.assertFalse(filters.get('tenant_id'))",
            "            return [fakes.stub_instance(100)]",
            "",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       fake_get_all)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers?tenant_id=fake',",
            "                                      use_admin_context=True)",
            "        res = self.controller.index(req)",
            "",
            "        self.assertTrue('servers' in res)",
            "",
            "    def test_admin_restricted_tenant(self):",
            "        def fake_get_all(context, filters=None, sort_key=None,",
            "                         sort_dir='desc', limit=None, marker=None,",
            "                         columns_to_join=None):",
            "            self.assertNotEqual(filters, None)",
            "            self.assertEqual(filters['project_id'], 'fake')",
            "            return [fakes.stub_instance(100)]",
            "",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       fake_get_all)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers',",
            "                                      use_admin_context=True)",
            "        res = self.controller.index(req)",
            "",
            "        self.assertTrue('servers' in res)",
            "",
            "    def test_all_tenants_pass_policy(self):",
            "        def fake_get_all(context, filters=None, sort_key=None,",
            "                         sort_dir='desc', limit=None, marker=None,",
            "                         columns_to_join=None):",
            "            self.assertNotEqual(filters, None)",
            "            self.assertTrue('project_id' not in filters)",
            "            return [fakes.stub_instance(100)]",
            "",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       fake_get_all)",
            "",
            "        rules = {",
            "            \"compute:get_all_tenants\":",
            "                common_policy.parse_rule(\"project_id:fake\"),",
            "            \"compute:get_all\":",
            "                common_policy.parse_rule(\"project_id:fake\"),",
            "        }",
            "",
            "        common_policy.set_rules(common_policy.Rules(rules))",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers?all_tenants=1')",
            "        res = self.controller.index(req)",
            "",
            "        self.assertTrue('servers' in res)",
            "",
            "    def test_all_tenants_fail_policy(self):",
            "        def fake_get_all(context, filters=None, sort_key=None,",
            "                         sort_dir='desc', limit=None, marker=None,",
            "                         columns_to_join=None):",
            "            self.assertNotEqual(filters, None)",
            "            return [fakes.stub_instance(100)]",
            "",
            "        rules = {",
            "            \"compute:get_all_tenants\":",
            "                common_policy.parse_rule(\"project_id:non_fake\"),",
            "            \"compute:get_all\":",
            "                common_policy.parse_rule(\"project_id:fake\"),",
            "        }",
            "",
            "        common_policy.set_rules(common_policy.Rules(rules))",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       fake_get_all)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers?all_tenants=1')",
            "        self.assertRaises(exception.PolicyNotAuthorized,",
            "                          self.controller.index, req)",
            "",
            "    def test_get_servers_allows_flavor(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('flavor' in search_opts)",
            "            # flavor is an integer ID",
            "            self.assertEqual(search_opts['flavor'], '12345')",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers?flavor=12345')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_with_bad_flavor(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers?flavor=abcde')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 0)",
            "",
            "    def test_get_servers_allows_status(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('vm_state' in search_opts)",
            "            self.assertEqual(search_opts['vm_state'], vm_states.ACTIVE)",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers?status=active')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_invalid_status(self):",
            "        # Test getting servers by invalid status.",
            "        req = fakes.HTTPRequestV3.blank('/servers?status=baloney',",
            "                                      use_admin_context=False)",
            "        servers = self.controller.index(req)['servers']",
            "        self.assertEqual(len(servers), 0)",
            "",
            "    def test_get_servers_deleted_status_as_user(self):",
            "        req = fakes.HTTPRequestV3.blank('/servers?status=deleted',",
            "                                      use_admin_context=False)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.detail, req)",
            "",
            "    def test_get_servers_deleted_status_as_admin(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertTrue('vm_state' in search_opts)",
            "            self.assertEqual(search_opts['vm_state'], 'deleted')",
            "",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers?status=deleted',",
            "                                      use_admin_context=True)",
            "",
            "        servers = self.controller.detail(req)['servers']",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_allows_name(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('name' in search_opts)",
            "            self.assertEqual(search_opts['name'], 'whee.*')",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers?name=whee.*')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_allows_changes_since(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('changes_since' in search_opts)",
            "            changes_since = datetime.datetime(2011, 1, 24, 17, 8, 1,",
            "                                              tzinfo=iso8601.iso8601.UTC)",
            "            self.assertEqual(search_opts['changes_since'], changes_since)",
            "            self.assertTrue('deleted' not in search_opts)",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        params = 'changes_since=2011-01-24T17:08:01Z'",
            "        req = fakes.HTTPRequestV3.blank('/servers?%s' % params)",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_allows_changes_since_bad_value(self):",
            "        params = 'changes_since=asdf'",
            "        req = fakes.HTTPRequestV3.blank('/servers?%s' % params)",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.index, req)",
            "",
            "    def test_get_servers_admin_filters_as_user(self):",
            "        \"\"\"Test getting servers by admin-only or unknown options when",
            "        context is not admin. Make sure the admin and unknown options",
            "        are stripped before they get to compute_api.get_all()",
            "        \"\"\"",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            # Allowed by user",
            "            self.assertTrue('name' in search_opts)",
            "            self.assertTrue('ip' in search_opts)",
            "            # OSAPI converts status to vm_state",
            "            self.assertTrue('vm_state' in search_opts)",
            "            # Allowed only by admins with admin API on",
            "            self.assertFalse('unknown_option' in search_opts)",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        query_str = \"name=foo&ip=10.*&status=active&unknown_option=meow\"",
            "        req = fakes.HTTPRequest.blank('/servers?%s' % query_str)",
            "        res = self.controller.index(req)",
            "",
            "        servers = res['servers']",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_admin_options_as_admin(self):",
            "        \"\"\"Test getting servers by admin-only or unknown options when",
            "        context is admin. All options should be passed",
            "        \"\"\"",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            # Allowed by user",
            "            self.assertTrue('name' in search_opts)",
            "            # OSAPI converts status to vm_state",
            "            self.assertTrue('vm_state' in search_opts)",
            "            # Allowed only by admins with admin API on",
            "            self.assertTrue('ip' in search_opts)",
            "            self.assertTrue('unknown_option' in search_opts)",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        query_str = \"name=foo&ip=10.*&status=active&unknown_option=meow\"",
            "        req = fakes.HTTPRequestV3.blank('/servers?%s' % query_str,",
            "                                      use_admin_context=True)",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_allows_ip(self):",
            "        \"\"\"Test getting servers by ip.\"\"\"",
            "",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('ip' in search_opts)",
            "            self.assertEqual(search_opts['ip'], '10\\..*')",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers?ip=10\\..*')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_admin_allows_ip6(self):",
            "        \"\"\"Test getting servers by ip6 with admin_api enabled and",
            "        admin context",
            "        \"\"\"",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('ip6' in search_opts)",
            "            self.assertEqual(search_opts['ip6'], 'ffff.*')",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers?ip6=ffff.*',",
            "                                      use_admin_context=True)",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_all_server_details(self):",
            "        expected_flavor = {",
            "                \"id\": \"1\",",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": 'http://localhost/flavors/1',",
            "                        },",
            "                    ],",
            "                }",
            "        expected_image = {",
            "            \"id\": \"10\",",
            "            \"links\": [",
            "                {",
            "                    \"rel\": \"bookmark\",",
            "                    \"href\": 'http://localhost/images/10',",
            "                    },",
            "                ],",
            "            }",
            "        req = fakes.HTTPRequestV3.blank('/servers/detail')",
            "        res_dict = self.controller.detail(req)",
            "",
            "        for i, s in enumerate(res_dict['servers']):",
            "            self.assertEqual(s['id'], fakes.get_fake_uuid(i))",
            "            self.assertEqual(s['host_id'], '')",
            "            self.assertEqual(s['name'], 'server%d' % (i + 1))",
            "            self.assertEqual(s['image'], expected_image)",
            "            self.assertEqual(s['flavor'], expected_flavor)",
            "            self.assertEqual(s['status'], 'BUILD')",
            "            self.assertEqual(s['metadata']['seq'], str(i + 1))",
            "",
            "    def test_get_all_server_details_with_host(self):",
            "        '''",
            "        We want to make sure that if two instances are on the same host, then",
            "        they return the same host_id. If two instances are on different hosts,",
            "        they should return different host_ids. In this test, there are 5",
            "        instances - 2 on one host and 3 on another.",
            "        '''",
            "",
            "        def return_servers_with_host(context, *args, **kwargs):",
            "            return [fakes.stub_instance(i + 1, 'fake', 'fake', host=i % 2,",
            "                                        uuid=fakes.get_fake_uuid(i))",
            "                    for i in xrange(5)]",
            "",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       return_servers_with_host)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers/detail')",
            "        res_dict = self.controller.detail(req)",
            "",
            "        server_list = res_dict['servers']",
            "        host_ids = [server_list[0]['host_id'], server_list[1]['host_id']]",
            "        self.assertTrue(host_ids[0] and host_ids[1])",
            "        self.assertNotEqual(host_ids[0], host_ids[1])",
            "",
            "        for i, s in enumerate(server_list):",
            "            self.assertEqual(s['id'], fakes.get_fake_uuid(i))",
            "            self.assertEqual(s['host_id'], host_ids[i % 2])",
            "            self.assertEqual(s['name'], 'server%d' % (i + 1))",
            "",
            "",
            "class ServersControllerDeleteTest(ControllerTest):",
            "",
            "    def setUp(self):",
            "        super(ServersControllerDeleteTest, self).setUp()",
            "        self.server_delete_called = False",
            "",
            "        def instance_destroy_mock(*args, **kwargs):",
            "            self.server_delete_called = True",
            "",
            "        self.stubs.Set(db, 'instance_destroy', instance_destroy_mock)",
            "",
            "    def _create_delete_request(self, uuid):",
            "        fakes.stub_out_instance_quota(self.stubs, 0, 10)",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s' % uuid)",
            "        req.method = 'DELETE'",
            "        return req",
            "",
            "    def _delete_server_instance(self, uuid=FAKE_UUID):",
            "        req = self._create_delete_request(uuid)",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                fakes.fake_instance_get(vm_state=vm_states.ACTIVE))",
            "        self.controller.delete(req, uuid)",
            "",
            "    def test_delete_server_instance(self):",
            "        self._delete_server_instance()",
            "        self.assertTrue(self.server_delete_called)",
            "",
            "    def test_delete_server_instance_not_found(self):",
            "        self.assertRaises(webob.exc.HTTPNotFound,",
            "                          self._delete_server_instance,",
            "                          uuid='non-existent-uuid')",
            "",
            "    def test_delete_server_instance_while_building(self):",
            "        req = self._create_delete_request(FAKE_UUID)",
            "        self.controller.delete(req, FAKE_UUID)",
            "",
            "        self.assertTrue(self.server_delete_called)",
            "",
            "    def test_delete_server_instance_while_resize(self):",
            "        req = self._create_delete_request(FAKE_UUID)",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                fakes.fake_instance_get(vm_state=vm_states.ACTIVE,",
            "                                        task_state=task_states.RESIZE_PREP))",
            "",
            "        self.controller.delete(req, FAKE_UUID)",
            "        # Delete shoud be allowed in any case, even during resizing,",
            "        # because it may get stuck.",
            "        self.assertTrue(self.server_delete_called)",
            "",
            "",
            "class ServersControllerRebuildInstanceTest(ControllerTest):",
            "",
            "    image_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    image_href = 'http://localhost/v3/fake/images/%s' % image_uuid",
            "",
            "    def setUp(self):",
            "        super(ServersControllerRebuildInstanceTest, self).setUp()",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                       fakes.fake_instance_get(vm_state=vm_states.ACTIVE))",
            "        self.body = {",
            "            'rebuild': {",
            "                'name': 'new_name',",
            "                'image_ref': self.image_href,",
            "                'metadata': {",
            "                    'open': 'stack',",
            "                },",
            "            },",
            "        }",
            "        self.req = fakes.HTTPRequest.blank('/fake/servers/a/action')",
            "        self.req.method = 'POST'",
            "        self.req.headers[\"content-type\"] = \"application/json\"",
            "",
            "    def test_rebuild_instance_with_access_ipv4_bad_format(self):",
            "        # proper local hrefs must start with 'http://localhost/v2/'",
            "        self.body['rebuild']['access_ip_v4'] = 'bad_format'",
            "        self.body['rebuild']['access_ip_v6'] = 'fead::1234'",
            "        self.body['rebuild']['metadata']['hello'] = 'world'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_with_blank_metadata_key(self):",
            "        self.body['rebuild']['access_ip_v4'] = '0.0.0.0'",
            "        self.body['rebuild']['access_ip_v6'] = 'fead::1234'",
            "        self.body['rebuild']['metadata'][''] = 'world'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_with_metadata_key_too_long(self):",
            "        self.body['rebuild']['access_ip_v4'] = '0.0.0.0'",
            "        self.body['rebuild']['access_ip_v6'] = 'fead::1234'",
            "        self.body['rebuild']['metadata'][('a' * 260)] = 'world'",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_with_metadata_value_too_long(self):",
            "        self.body['rebuild']['access_ip_v4'] = '0.0.0.0'",
            "        self.body['rebuild']['access_ip_v6'] = 'fead::1234'",
            "        self.body['rebuild']['metadata']['key1'] = ('a' * 260)",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller._action_rebuild, self.req,",
            "                          FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_fails_when_min_ram_too_small(self):",
            "        # make min_ram larger than our instance ram size",
            "        def fake_get_image(self, context, image_href):",
            "            return dict(id='76fa36fc-c930-4bf3-8c8a-ea2a2420deb6',",
            "                        name='public image', is_public=True,",
            "                        status='active', properties={'key1': 'value1'},",
            "                        min_ram=\"4096\", min_disk=\"10\")",
            "",
            "        self.stubs.Set(fake._FakeImageService, 'show', fake_get_image)",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_fails_when_min_disk_too_small(self):",
            "        # make min_disk larger than our instance disk size",
            "        def fake_get_image(self, context, image_href):",
            "            return dict(id='76fa36fc-c930-4bf3-8c8a-ea2a2420deb6',",
            "                        name='public image', is_public=True,",
            "                        status='active', properties={'key1': 'value1'},",
            "                        min_ram=\"128\", min_disk=\"100000\")",
            "",
            "        self.stubs.Set(fake._FakeImageService, 'show', fake_get_image)",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild, self.req,",
            "                          FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_image_too_large(self):",
            "        # make image size larger than our instance disk size",
            "        size = str(1000 * (1024 ** 3))",
            "",
            "        def fake_get_image(self, context, image_href):",
            "            return dict(id='76fa36fc-c930-4bf3-8c8a-ea2a2420deb6',",
            "                        name='public image', is_public=True,",
            "                        status='active', size=size)",
            "",
            "        self.stubs.Set(fake._FakeImageService, 'show', fake_get_image)",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_with_deleted_image(self):",
            "        def fake_get_image(self, context, image_href):",
            "            return dict(id='76fa36fc-c930-4bf3-8c8a-ea2a2420deb6',",
            "                        name='public image', is_public=True,",
            "                        status='DELETED')",
            "",
            "        self.stubs.Set(fake._FakeImageService, 'show', fake_get_image)",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_with_access_ipv6_bad_format(self):",
            "        self.body['rebuild']['access_ip_v4'] = '1.2.3.4'",
            "        self.body['rebuild']['access_ip_v6'] = 'bad_format'",
            "        self.body['rebuild']['metadata']['hello'] = 'world'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.req.headers[\"content-type\"] = \"application/json\"",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_start(self):",
            "        self.mox.StubOutWithMock(compute_api.API, 'start')",
            "        compute_api.API.start(mox.IgnoreArg(), mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s/action' % FAKE_UUID)",
            "        body = dict(start=\"\")",
            "        self.controller._start_server(req, FAKE_UUID, body)",
            "",
            "    def test_start_not_ready(self):",
            "        self.stubs.Set(compute_api.API, 'start', fake_start_stop_not_ready)",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s/action' % FAKE_UUID)",
            "        body = dict(start=\"\")",
            "        self.assertRaises(webob.exc.HTTPConflict,",
            "            self.controller._start_server, req, FAKE_UUID, body)",
            "",
            "    def test_stop(self):",
            "        self.mox.StubOutWithMock(compute_api.API, 'stop')",
            "        compute_api.API.stop(mox.IgnoreArg(), mox.IgnoreArg())",
            "        self.mox.ReplayAll()",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s/action' % FAKE_UUID)",
            "        body = dict(stop=\"\")",
            "        self.controller._stop_server(req, FAKE_UUID, body)",
            "",
            "    def test_stop_not_ready(self):",
            "        self.stubs.Set(compute_api.API, 'stop', fake_start_stop_not_ready)",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s/action' % FAKE_UUID)",
            "        body = dict(start=\"\")",
            "        self.assertRaises(webob.exc.HTTPConflict,",
            "            self.controller._stop_server, req, FAKE_UUID, body)",
            "",
            "    def test_start_with_bogus_id(self):",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                       fake_instance_get_by_uuid_not_found)",
            "        req = fakes.HTTPRequestV3.blank('/servers/test_inst/action')",
            "        body = dict(start=\"\")",
            "        self.assertRaises(webob.exc.HTTPNotFound,",
            "            self.controller._start_server, req, 'test_inst', body)",
            "",
            "    def test_stop_with_bogus_id(self):",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                       fake_instance_get_by_uuid_not_found)",
            "        req = fakes.HTTPRequestV3.blank('/servers/test_inst/action')",
            "        body = dict(start=\"\")",
            "        self.assertRaises(webob.exc.HTTPNotFound,",
            "            self.controller._stop_server, req, 'test_inst', body)",
            "",
            "",
            "class ServersControllerUpdateTest(ControllerTest):",
            "",
            "    def _get_request(self, body=None, options=None):",
            "        if options:",
            "            self.stubs.Set(db, 'instance_get',",
            "                           fakes.fake_instance_get(**options))",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s' % FAKE_UUID)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        req.body = jsonutils.dumps(body)",
            "        return req",
            "",
            "    def test_update_server_all_attributes(self):",
            "        body = {'server': {",
            "                  'name': 'server_test',",
            "                  'access_ip_v4': '0.0.0.0',",
            "                  'access_ip_v6': 'beef::0123',",
            "               }}",
            "        req = self._get_request(body, {'name': 'server_test',",
            "                                       'access_ipv4': '0.0.0.0',",
            "                                       'access_ipv6': 'beef::0123'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['name'], 'server_test')",
            "        self.assertEqual(res_dict['server']['access_ip_v4'], '0.0.0.0')",
            "        self.assertEqual(res_dict['server']['access_ip_v6'], 'beef::123')",
            "",
            "    def test_update_server_invalid_xml_raises_lookup(self):",
            "        req = webob.Request.blank('/v3/servers/%s' % FAKE_UUID)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/xml'",
            "        #xml request which raises LookupError",
            "        req.body = \"\"\"<?xml version=\"1.0\" encoding=\"TF-8\"?>",
            "            <metadata",
            "            xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "            key=\"Label\"></metadata>\"\"\"",
            "        res = req.get_response(fakes.wsgi_app_v3())",
            "        self.assertEqual(res.status_int, 400)",
            "        res_dict = jsonutils.loads(res.body)",
            "        self.assertEqual(res_dict['badRequest']['message'],",
            "                         \"Malformed request body\")",
            "",
            "    def test_update_server_invalid_xml_raises_expat(self):",
            "        req = webob.Request.blank('/v3/servers/%s' % FAKE_UUID)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/xml'",
            "        #xml request which raises ExpatError",
            "        req.body = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "            <metadata",
            "            xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "            key=\"Label\"></meta>\"\"\"",
            "        res = req.get_response(fakes.wsgi_app_v3())",
            "        self.assertEqual(res.status_int, 400)",
            "        res_dict = jsonutils.loads(res.body)",
            "        self.assertEqual(res_dict['badRequest']['message'],",
            "                         \"Malformed request body\")",
            "",
            "    def test_update_server_name(self):",
            "        body = {'server': {'name': 'server_test'}}",
            "        req = self._get_request(body, {'name': 'server_test'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['name'], 'server_test')",
            "",
            "    def test_update_server_name_too_long(self):",
            "        body = {'server': {'name': 'x' * 256}}",
            "        req = self._get_request(body, {'name': 'server_test'})",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.update,",
            "                            req, FAKE_UUID, body)",
            "",
            "    def test_update_server_access_ipv4(self):",
            "        body = {'server': {'access_ip_v4': '0.0.0.0'}}",
            "        req = self._get_request(body, {'access_ipv4': '0.0.0.0'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['access_ip_v4'], '0.0.0.0')",
            "",
            "    def test_update_server_access_ipv4_bad_format(self):",
            "        body = {'server': {'access_ip_v4': 'bad_format'}}",
            "        req = self._get_request(body, {'access_ipv4': '0.0.0.0'})",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.update,",
            "                          req, FAKE_UUID, body)",
            "",
            "    def test_update_server_access_ipv4_none(self):",
            "        body = {'server': {'access_ip_v4': None}}",
            "        req = self._get_request(body, {'access_ipv4': '0.0.0.0'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['access_ip_v4'], '')",
            "",
            "    def test_update_server_access_ipv4_blank(self):",
            "        body = {'server': {'access_ip_v4': ''}}",
            "        req = self._get_request(body, {'access_ipv4': '0.0.0.0'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['access_ip_v4'], '')",
            "",
            "    def test_update_server_access_ipv6(self):",
            "        body = {'server': {'access_ip_v6': 'beef::0123'}}",
            "        req = self._get_request(body, {'access_ipv6': 'beef::0123'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['access_ip_v6'], 'beef::123')",
            "",
            "    def test_update_server_access_ipv6_bad_format(self):",
            "        body = {'server': {'access_ip_v6': 'bad_format'}}",
            "        req = self._get_request(body, {'access_ipv6': 'beef::0123'})",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.update,",
            "                          req, FAKE_UUID, body)",
            "",
            "    def test_update_server_access_ipv6_none(self):",
            "        body = {'server': {'access_ip_v6': None}}",
            "        req = self._get_request(body, {'access_ipv6': 'beef::0123'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['access_ip_v6'], '')",
            "",
            "    def test_update_server_access_ipv6_blank(self):",
            "        body = {'server': {'access_ip_v6': ''}}",
            "        req = self._get_request(body, {'access_ipv6': 'beef::0123'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['access_ip_v6'], '')",
            "",
            "    def test_update_server_adminPass_ignored(self):",
            "        inst_dict = dict(name='server_test', adminPass='bacon')",
            "        body = dict(server=inst_dict)",
            "",
            "        def server_update(context, id, params):",
            "            filtered_dict = {",
            "                'display_name': 'server_test',",
            "            }",
            "            self.assertEqual(params, filtered_dict)",
            "            filtered_dict['uuid'] = id",
            "            return filtered_dict",
            "",
            "        self.stubs.Set(db, 'instance_update', server_update)",
            "        # FIXME (comstud)",
            "        #        self.stubs.Set(db, 'instance_get',",
            "        #                return_server_with_attributes(name='server_test'))",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers/%s' % FAKE_UUID)",
            "        req.method = 'PUT'",
            "        req.content_type = \"application/json\"",
            "        req.body = jsonutils.dumps(body)",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['name'], 'server_test')",
            "",
            "    def test_update_server_not_found(self):",
            "        def fake_get(*args, **kwargs):",
            "            raise exception.InstanceNotFound(instance_id='fake')",
            "",
            "        self.stubs.Set(compute_api.API, 'get', fake_get)",
            "        body = {'server': {'name': 'server_test'}}",
            "        req = self._get_request(body)",
            "        self.assertRaises(webob.exc.HTTPNotFound, self.controller.update,",
            "                          req, FAKE_UUID, body)",
            "",
            "    def test_update_server_not_found_on_update(self):",
            "        def fake_update(*args, **kwargs):",
            "            raise exception.InstanceNotFound(instance_id='fake')",
            "",
            "        self.stubs.Set(db, 'instance_update_and_get_original', fake_update)",
            "        body = {'server': {'name': 'server_test'}}",
            "        req = self._get_request(body)",
            "        self.assertRaises(webob.exc.HTTPNotFound, self.controller.update,",
            "                          req, FAKE_UUID, body)",
            "",
            "",
            "class ServerStatusTest(test.TestCase):",
            "",
            "    def setUp(self):",
            "        super(ServerStatusTest, self).setUp()",
            "        fakes.stub_out_nw_api(self.stubs)",
            "",
            "        ext_info = plugins.LoadedExtensionInfo()",
            "        self.controller = servers.ServersController(extension_info=ext_info)",
            "",
            "    def _get_with_state(self, vm_state, task_state=None):",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                fakes.fake_instance_get(vm_state=vm_state,",
            "                                        task_state=task_state))",
            "",
            "        request = fakes.HTTPRequestV3.blank('/servers/%s' % FAKE_UUID)",
            "        return self.controller.show(request, FAKE_UUID)",
            "",
            "    def test_active(self):",
            "        response = self._get_with_state(vm_states.ACTIVE)",
            "        self.assertEqual(response['server']['status'], 'ACTIVE')",
            "",
            "    def test_reboot(self):",
            "        response = self._get_with_state(vm_states.ACTIVE,",
            "                                        task_states.REBOOTING)",
            "        self.assertEqual(response['server']['status'], 'REBOOT')",
            "",
            "    def test_reboot_hard(self):",
            "        response = self._get_with_state(vm_states.ACTIVE,",
            "                                        task_states.REBOOTING_HARD)",
            "        self.assertEqual(response['server']['status'], 'HARD_REBOOT')",
            "",
            "    def test_reboot_resize_policy_fail(self):",
            "        def fake_get_server(context, req, id):",
            "            return fakes.stub_instance(id)",
            "",
            "        self.stubs.Set(self.controller, '_get_server', fake_get_server)",
            "",
            "        rule = {'compute:reboot':",
            "                common_policy.parse_rule('role:admin')}",
            "        common_policy.set_rules(common_policy.Rules(rule))",
            "        req = fakes.HTTPRequestV3.blank('/servers/1234/action')",
            "        self.assertRaises(exception.PolicyNotAuthorized,",
            "                self.controller._action_reboot, req, '1234',",
            "                {'reboot': {'type': 'HARD'}})",
            "",
            "    def test_rebuild(self):",
            "        response = self._get_with_state(vm_states.ACTIVE,",
            "                                        task_states.REBUILDING)",
            "        self.assertEqual(response['server']['status'], 'REBUILD')",
            "",
            "    def test_rebuild_error(self):",
            "        response = self._get_with_state(vm_states.ERROR)",
            "        self.assertEqual(response['server']['status'], 'ERROR')",
            "",
            "    def test_resize(self):",
            "        response = self._get_with_state(vm_states.ACTIVE,",
            "                                        task_states.RESIZE_PREP)",
            "        self.assertEqual(response['server']['status'], 'RESIZE')",
            "",
            "    def test_confirm_resize_policy_fail(self):",
            "        def fake_get_server(context, req, id):",
            "            return fakes.stub_instance(id)",
            "",
            "        self.stubs.Set(self.controller, '_get_server', fake_get_server)",
            "",
            "        rule = {'compute:confirm_resize':",
            "                common_policy.parse_rule('role:admin')}",
            "        common_policy.set_rules(common_policy.Rules(rule))",
            "        req = fakes.HTTPRequestV3.blank('/servers/1234/action')",
            "        self.assertRaises(exception.PolicyNotAuthorized,",
            "                self.controller._action_confirm_resize, req, '1234', {})",
            "",
            "    def test_verify_resize(self):",
            "        response = self._get_with_state(vm_states.RESIZED, None)",
            "        self.assertEqual(response['server']['status'], 'VERIFY_RESIZE')",
            "",
            "    def test_revert_resize(self):",
            "        response = self._get_with_state(vm_states.RESIZED,",
            "                                        task_states.RESIZE_REVERTING)",
            "        self.assertEqual(response['server']['status'], 'REVERT_RESIZE')",
            "",
            "    def test_revert_resize_policy_fail(self):",
            "        def fake_get_server(context, req, id):",
            "            return fakes.stub_instance(id)",
            "",
            "        self.stubs.Set(self.controller, '_get_server', fake_get_server)",
            "",
            "        rule = {'compute:revert_resize':",
            "                common_policy.parse_rule('role:admin')}",
            "        common_policy.set_rules(common_policy.Rules(rule))",
            "        req = fakes.HTTPRequestV3.blank('/servers/1234/action')",
            "        self.assertRaises(exception.PolicyNotAuthorized,",
            "                self.controller._action_revert_resize, req, '1234', {})",
            "",
            "    def test_password_update(self):",
            "        response = self._get_with_state(vm_states.ACTIVE,",
            "                                        task_states.UPDATING_PASSWORD)",
            "        self.assertEqual(response['server']['status'], 'PASSWORD')",
            "",
            "    def test_stopped(self):",
            "        response = self._get_with_state(vm_states.STOPPED)",
            "        self.assertEqual(response['server']['status'], 'SHUTOFF')",
            "",
            "",
            "class ServersControllerCreateTest(test.TestCase):",
            "    image_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    flavor_ref = 'http://localhost/123/flavors/3'",
            "",
            "    def setUp(self):",
            "        \"\"\"Shared implementation for tests below that create instance.\"\"\"",
            "        super(ServersControllerCreateTest, self).setUp()",
            "",
            "        self.flags(verbose=True,",
            "                   enable_instance_password=True)",
            "        self.instance_cache_num = 0",
            "        self.instance_cache_by_id = {}",
            "        self.instance_cache_by_uuid = {}",
            "",
            "        ext_info = plugins.LoadedExtensionInfo()",
            "        self.controller = servers.ServersController(extension_info=ext_info)",
            "",
            "        def instance_create(context, inst):",
            "            inst_type = flavors.get_flavor_by_flavor_id(3)",
            "            image_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "            def_image_ref = 'http://localhost/images/%s' % image_uuid",
            "            self.instance_cache_num += 1",
            "            instance = fake_instance.fake_db_instance(**{",
            "                'id': self.instance_cache_num,",
            "                'display_name': inst['display_name'] or 'test',",
            "                'uuid': FAKE_UUID,",
            "                'instance_type': dict(inst_type),",
            "                'access_ip_v4': '1.2.3.4',",
            "                'access_ip_v6': 'fead::1234',",
            "                'image_ref': inst.get('image_ref', def_image_ref),",
            "                'user_id': 'fake',",
            "                'project_id': 'fake',",
            "                'reservation_id': inst['reservation_id'],",
            "                \"created_at\": datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "                \"updated_at\": datetime.datetime(2010, 11, 11, 11, 0, 0),",
            "                \"config_drive\": None,",
            "                \"progress\": 0,",
            "                \"fixed_ips\": [],",
            "                \"task_state\": \"\",",
            "                \"vm_state\": \"\",",
            "                \"security_groups\": inst['security_groups'],",
            "            })",
            "",
            "            self.instance_cache_by_id[instance['id']] = instance",
            "            self.instance_cache_by_uuid[instance['uuid']] = instance",
            "            return instance",
            "",
            "        def instance_get(context, instance_id):",
            "            \"\"\"Stub for compute/api create() pulling in instance after",
            "            scheduling",
            "            \"\"\"",
            "            return self.instance_cache_by_id[instance_id]",
            "",
            "        def instance_update(context, uuid, values):",
            "            instance = self.instance_cache_by_uuid[uuid]",
            "            instance.update(values)",
            "            return instance",
            "",
            "        def rpc_call_wrapper(context, topic, msg, timeout=None):",
            "            \"\"\"Stub out the scheduler creating the instance entry.\"\"\"",
            "            if (topic == CONF.scheduler_topic and",
            "                    msg['method'] == 'run_instance'):",
            "                request_spec = msg['args']['request_spec']",
            "                num_instances = request_spec.get('num_instances', 1)",
            "                instances = []",
            "                for x in xrange(num_instances):",
            "                    instances.append(instance_create(context,",
            "                        request_spec['instance_properties']))",
            "                return instances",
            "",
            "        def server_update(context, instance_uuid, params, update_cells=True):",
            "            inst = self.instance_cache_by_uuid[instance_uuid]",
            "            inst.update(params)",
            "            return (inst, inst)",
            "",
            "        def fake_method(*args, **kwargs):",
            "            pass",
            "",
            "        def project_get_networks(context, user_id):",
            "            return dict(id='1', host='localhost')",
            "",
            "        def queue_get_for(context, *args):",
            "            return 'network_topic'",
            "",
            "        fakes.stub_out_rate_limiting(self.stubs)",
            "        fakes.stub_out_key_pair_funcs(self.stubs)",
            "        fake.stub_out_image_service(self.stubs)",
            "        fakes.stub_out_nw_api(self.stubs)",
            "        self.stubs.Set(uuid, 'uuid4', fake_gen_uuid)",
            "        self.stubs.Set(db, 'instance_add_security_group',",
            "                       return_security_group)",
            "        self.stubs.Set(db, 'project_get_networks',",
            "                       project_get_networks)",
            "        self.stubs.Set(db, 'instance_create', instance_create)",
            "        self.stubs.Set(db, 'instance_system_metadata_update',",
            "                fake_method)",
            "        self.stubs.Set(db, 'instance_get', instance_get)",
            "        self.stubs.Set(db, 'instance_update', instance_update)",
            "        self.stubs.Set(rpc, 'cast', fake_method)",
            "        self.stubs.Set(rpc, 'call', rpc_call_wrapper)",
            "        self.stubs.Set(db, 'instance_update_and_get_original',",
            "                server_update)",
            "        self.stubs.Set(rpc, 'queue_get_for', queue_get_for)",
            "        self.stubs.Set(manager.VlanManager, 'allocate_fixed_ip',",
            "                       fake_method)",
            "        self.body = {",
            "            'server': {",
            "                'min_count': 2,",
            "                'name': 'server_test',",
            "                'image_ref': self.image_uuid,",
            "                'flavor_ref': self.flavor_ref,",
            "                'metadata': {",
            "                    'hello': 'world',",
            "                    'open': 'stack',",
            "                    },",
            "                },",
            "            }",
            "        self.bdm = [{'delete_on_termination': 1,",
            "                     'device_name': 123,",
            "                     'volume_size': 1,",
            "                     'volume_id': '11111111-1111-1111-1111-111111111111'}]",
            "",
            "        self.req = fakes.HTTPRequest.blank('/fake/servers')",
            "        self.req.method = 'POST'",
            "        self.req.headers[\"content-type\"] = \"application/json\"",
            "",
            "    def _check_admin_pass_len(self, server_dict):",
            "        \"\"\"utility function - check server_dict for admin_pass length.\"\"\"",
            "        self.assertEqual(CONF.password_length,",
            "                         len(server_dict[\"admin_pass\"]))",
            "",
            "    def _check_admin_pass_missing(self, server_dict):",
            "        \"\"\"utility function - check server_dict for absence of admin_pass.\"\"\"",
            "        self.assertTrue(\"admin_pass\" not in server_dict)",
            "",
            "    def _test_create_instance(self, flavor=2):",
            "        image_uuid = 'c905cedb-7281-47e4-8a62-f26bc5fc4c77'",
            "        self.body['server']['image_ref'] = image_uuid",
            "        self.body['server']['flavor_ref'] = flavor",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        server = self.controller.create(self.req, self.body).obj['server']",
            "        self._check_admin_pass_len(server)",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_private_flavor(self):",
            "        values = {",
            "            'name': 'fake_name',",
            "            'memory_mb': 512,",
            "            'vcpus': 1,",
            "            'root_gb': 10,",
            "            'ephemeral_gb': 10,",
            "            'flavorid': '1324',",
            "            'swap': 0,",
            "            'rxtx_factor': 0.5,",
            "            'vcpu_weight': 1,",
            "            'disabled': False,",
            "            'is_public': False,",
            "        }",
            "        db.flavor_create(context.get_admin_context(), values)",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self._test_create_instance,",
            "                          flavor=1324)",
            "",
            "    def test_create_server_bad_image_href(self):",
            "        image_href = 1",
            "        self.body['server']['min_count'] = 1",
            "        self.body['server']['image_ref'] = image_href,",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create,",
            "                          self.req, self.body)",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-networks extension tests",
            "    # def test_create_server_with_invalid_networks_parameter(self):",
            "    #     self.ext_mgr.extensions = {'os-networks': 'fake'}",
            "    #     image_href = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    #     flavor_ref = 'http://localhost/123/flavors/3'",
            "    #     body = {",
            "    #         'server': {",
            "    #         'name': 'server_test',",
            "    #         'imageRef': image_href,",
            "    #         'flavorRef': flavor_ref,",
            "    #         'networks': {'uuid': '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'},",
            "    #         }",
            "    #     }",
            "    #     req = fakes.HTTPRequest.blank('/v2/fake/servers')",
            "    #     req.method = 'POST'",
            "    #     req.body = jsonutils.dumps(body)",
            "    #     req.headers[\"content-type\"] = \"application/json\"",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self.controller.create,",
            "    #                       req,",
            "    #                       body)",
            "",
            "    def test_create_server_with_deleted_image(self):",
            "        # Get the fake image service so we can set the status to deleted",
            "        (image_service, image_id) = glance.get_remote_image_service(",
            "                context, '')",
            "        image_service.update(context, self.image_uuid, {'status': 'DELETED'})",
            "        self.addCleanup(image_service.update, context, self.image_uuid,",
            "                        {'status': 'active'})",
            "",
            "        self.body['server']['flavor_ref'] = 2",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        with testtools.ExpectedException(",
            "                webob.exc.HTTPBadRequest,",
            "                'Image 76fa36fc-c930-4bf3-8c8a-ea2a2420deb6 is not active.'):",
            "            self.controller.create(self.req, self.body)",
            "",
            "    def test_create_server_image_too_large(self):",
            "        # Get the fake image service so we can set the status to deleted",
            "        (image_service, image_id) = glance.get_remote_image_service(",
            "                                    context, self.image_uuid)",
            "",
            "        image = image_service.show(context, image_id)",
            "",
            "        orig_size = image['size']",
            "        new_size = str(1000 * (1024 ** 3))",
            "        image_service.update(context, self.image_uuid, {'size': new_size})",
            "",
            "        self.addCleanup(image_service.update, context, self.image_uuid,",
            "                        {'size': orig_size})",
            "",
            "        self.body['server']['flavor_ref'] = 2",
            "        self.req.body = jsonutils.dumps(self.body)",
            "",
            "        with testtools.ExpectedException(",
            "                webob.exc.HTTPBadRequest,",
            "                \"Instance type's disk is too small for requested image.\"):",
            "            self.controller.create(self.req, self.body)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multiple-create extension tests",
            "    # def test_create_instance_invalid_negative_min(self):",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     image_href = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    #     flavor_ref = 'http://localhost/123/flavors/3'",
            "",
            "    #     body = {",
            "    #         'server': {",
            "    #             'min_count': -1,",
            "    #             'name': 'server_test',",
            "    #             'imageRef': image_href,",
            "    #             'flavorRef': flavor_ref,",
            "    #         }",
            "    #     }",
            "    #     req = fakes.HTTPRequestV3.blank('/servers')",
            "    #     req.method = 'POST'",
            "    #     req.body = jsonutils.dumps(body)",
            "    #     req.headers[\"content-type\"] = \"application/json\"",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self.controller.create,",
            "    #                       req,",
            "    #                       body)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multiple-create extension tests",
            "    # def test_create_instance_invalid_negative_max(self):",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     image_href = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    #     flavor_ref = 'http://localhost/123/flavors/3'",
            "",
            "    #     body = {",
            "    #         'server': {",
            "    #             'max_count': -1,",
            "    #             'name': 'server_test',",
            "    #             'imageRef': image_href,",
            "    #             'flavorRef': flavor_ref,",
            "    #         }",
            "    #     }",
            "    #     req = fakes.HTTPRequestV3.blank('/servers')",
            "    #     req.method = 'POST'",
            "    #     req.body = jsonutils.dumps(body)",
            "    #     req.headers[\"content-type\"] = \"application/json\"",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self.controller.create,",
            "    #                       req,",
            "    #                       body)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multiple-create extension tests",
            "    # def test_create_instance_invalid_alpha_min(self):",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     image_href = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    #     flavor_ref = 'http://localhost/123/flavors/3'",
            "",
            "    #     body = {",
            "    #         'server': {",
            "    #             'min_count': 'abcd',",
            "    #             'name': 'server_test',",
            "    #             'imageRef': image_href,",
            "    #             'flavorRef': flavor_ref,",
            "    #         }",
            "    #     }",
            "    #     req = fakes.HTTPRequestV3.blank('/servers')",
            "    #     req.method = 'POST'",
            "    #     req.body = jsonutils.dumps(body)",
            "    #     req.headers[\"content-type\"] = \"application/json\"",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self.controller.create,",
            "    #                       req,",
            "    #                       body)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multiple-create extension tests",
            "    # def test_create_instance_invalid_alpha_max(self):",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     image_href = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    #     flavor_ref = 'http://localhost/123/flavors/3'",
            "",
            "    #     body = {",
            "    #         'server': {",
            "    #             'max_count': 'abcd',",
            "    #             'name': 'server_test',",
            "    #             'imageRef': image_href,",
            "    #             'flavorRef': flavor_ref,",
            "    #         }",
            "    #     }",
            "    #     req = fakes.HTTPRequestV3.blank('/servers')",
            "    #     req.method = 'POST'",
            "    #     req.body = jsonutils.dumps(body)",
            "    #     req.headers[\"content-type\"] = \"application/json\"",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self.controller.create,",
            "    #                       req,",
            "    #                       body)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multiple-create extension tests",
            "    # def test_create_multiple_instances(self):",
            "    #     \"\"\"Test creating multiple instances but not asking for",
            "    #     reservation_id",
            "    #     \"\"\"",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     image_href = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    #     flavor_ref = 'http://localhost/123/flavors/3'",
            "    #     body = {",
            "    #         'server': {",
            "    #             'min_count': 2,",
            "    #             'name': 'server_test',",
            "    #             'imageRef': image_href,",
            "    #             'flavorRef': flavor_ref,",
            "    #             'metadata': {'hello': 'world',",
            "    #                          'open': 'stack'},",
            "    #             'personality': []",
            "    #         }",
            "    #     }",
            "",
            "    #     req = fakes.HTTPRequestV3.blank('/servers')",
            "    #     req.method = 'POST'",
            "    #     req.body = jsonutils.dumps(body)",
            "    #     req.headers[\"content-type\"] = \"application/json\"",
            "    #     res = self.controller.create(req, body).obj",
            "",
            "    #     self.assertEqual(FAKE_UUID, res[\"server\"][\"id\"])",
            "    #     self._check_admin_pass_len(res[\"server\"])",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multiple-create extension tests",
            "    # def test_create_multiple_instances_pass_disabled(self):",
            "    #     \"\"\"Test creating multiple instances but not asking for",
            "    #     reservation_id",
            "    #     \"\"\"",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     self.flags(enable_instance_password=False)",
            "    #     image_href = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    #     flavor_ref = 'http://localhost/123/flavors/3'",
            "    #     body = {",
            "    #         'server': {",
            "    #             'min_count': 2,",
            "    #             'name': 'server_test',",
            "    #             'imageRef': image_href,",
            "    #             'flavorRef': flavor_ref,",
            "    #             'metadata': {'hello': 'world',",
            "    #                          'open': 'stack'},",
            "    #             'personality': []",
            "    #         }",
            "    #     }",
            "",
            "    #     req = fakes.HTTPRequestV3.blank('/servers')",
            "    #     req.method = 'POST'",
            "    #     req.body = jsonutils.dumps(body)",
            "    #     req.headers[\"content-type\"] = \"application/json\"",
            "    #     res = self.controller.create(req, body).obj",
            "",
            "    #     self.assertEqual(FAKE_UUID, res[\"server\"][\"id\"])",
            "    #     self._check_admin_pass_missing(res[\"server\"])",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multiple-create extension tests",
            "    # def test_create_multiple_instances_resv_id_return(self):",
            "    #     \"\"\"Test creating multiple instances with asking for",
            "    #     reservation_id",
            "    #     \"\"\"",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     image_href = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    #     flavor_ref = 'http://localhost/123/flavors/3'",
            "    #     body = {",
            "    #         'server': {",
            "    #             'min_count': 2,",
            "    #             'name': 'server_test',",
            "    #             'imageRef': image_href,",
            "    #             'flavorRef': flavor_ref,",
            "    #             'metadata': {'hello': 'world',",
            "    #                          'open': 'stack'},",
            "    #             'personality': [],",
            "    #             'return_reservation_id': True",
            "    #         }",
            "    #     }",
            "",
            "    #     req = fakes.HTTPRequestV3.blank('/servers')",
            "    #     req.method = 'POST'",
            "    #     req.body = jsonutils.dumps(body)",
            "    #     req.headers[\"content-type\"] = \"application/json\"",
            "    #     res = self.controller.create(req, body)",
            "",
            "    #     reservation_id = res.obj.get('reservation_id')",
            "    #     self.assertNotEqual(reservation_id, \"\")",
            "    #     self.assertNotEqual(reservation_id, None)",
            "    #     self.assertTrue(len(reservation_id) > 1)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multiple-create extension tests",
            "    # def test_create_multiple_instances_with_multiple_volume_bdm(self):",
            "    #     \"\"\"",
            "    #     Test that a BadRequest is raised if multiple instances",
            "    #     are requested with a list of block device mappings for volumes.",
            "    #     \"\"\"",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     min_count = 2",
            "    #     bdm = [{'device_name': 'foo1', 'volume_id': 'vol-xxxx'},",
            "    #            {'device_name': 'foo2', 'volume_id': 'vol-yyyy'}",
            "    #     ]",
            "    #     params = {",
            "    #               'block_device_mapping': bdm,",
            "    #               'min_count': min_count",
            "    #     }",
            "    #     old_create = compute_api.API.create",
            "",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['min_count'], 2)",
            "    #         self.assertEqual(len(kwargs['block_device_mapping']), 2)",
            "    #         return old_create(*args, **kwargs)",
            "",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self._test_create_extra, params, no_image=True)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multiple-create extension tests",
            "    # def test_create_multiple_instances_with_single_volume_bdm(self):",
            "    #     \"\"\"",
            "    #     Test that a BadRequest is raised if multiple instances",
            "    #     are requested to boot from a single volume.",
            "    #     \"\"\"",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     min_count = 2",
            "    #     bdm = [{'device_name': 'foo1', 'volume_id': 'vol-xxxx'}]",
            "    #     params = {",
            "    #              'block_device_mapping': bdm,",
            "    #              'min_count': min_count",
            "    #     }",
            "    #     old_create = compute_api.API.create",
            "",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['min_count'], 2)",
            "    #         self.assertEqual(kwargs['block_device_mapping']['volume_id'],",
            "    #                         'vol-xxxx')",
            "    #         return old_create(*args, **kwargs)",
            "",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self._test_create_extra, params, no_image=True)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multiple-create extension tests",
            "    # def test_create_multiple_instance_with_non_integer_max_count(self):",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     image_href = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    #     flavor_ref = 'http://localhost/123/flavors/3'",
            "    #     body = {",
            "    #         'server': {",
            "    #             'max_count': 2.5,",
            "    #             'name': 'server_test',",
            "    #             'imageRef': image_href,",
            "    #             'flavorRef': flavor_ref,",
            "    #             'metadata': {'hello': 'world',",
            "    #                          'open': 'stack'},",
            "    #             'personality': []",
            "    #         }",
            "    #     }",
            "",
            "    #     req = fakes.HTTPRequestV3.blank('/servers')",
            "    #     req.method = 'POST'",
            "    #     req.body = jsonutils.dumps(body)",
            "    #     req.headers[\"content-type\"] = \"application/json\"",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self.controller.create, req, body)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multiple-create extension tests",
            "    # def test_create_multiple_instance_with_non_integer_min_count(self):",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     image_href = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    #     flavor_ref = 'http://localhost/123/flavors/3'",
            "    #     body = {",
            "    #         'server': {",
            "    #             'min_count': 2.5,",
            "    #             'name': 'server_test',",
            "    #             'imageRef': image_href,",
            "    #             'flavorRef': flavor_ref,",
            "    #             'metadata': {'hello': 'world',",
            "    #                          'open': 'stack'},",
            "    #             'personality': []",
            "    #         }",
            "    #     }",
            "",
            "    #     req = fakes.HTTPRequestV3.blank('/servers')",
            "    #     req.method = 'POST'",
            "    #     req.body = jsonutils.dumps(body)",
            "    #     req.headers[\"content-type\"] = \"application/json\"",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self.controller.create, req, body)",
            "",
            "    def test_create_instance_image_ref_is_bookmark(self):",
            "        image_href = 'http://localhost/images/%s' % self.image_uuid",
            "        self.body['server']['image_ref'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_image_ref_is_invalid(self):",
            "        image_uuid = 'this_is_not_a_valid_uuid'",
            "        image_href = 'http://localhost/images/%s' % image_uuid",
            "        flavor_ref = 'http://localhost/flavors/3'",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['flavor_ref'] = flavor_ref",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.create,",
            "                          self.req, self.body)",
            "",
            "    def test_create_instance_no_key_pair(self):",
            "        fakes.stub_out_key_pair_funcs(self.stubs, have_key_pair=False)",
            "        self._test_create_instance()",
            "",
            "    def _test_create_extra(self, params, no_image=False):",
            "        self.body['server']['flavor_ref'] = 2",
            "        if no_image:",
            "            self.body['server'].pop('image_ref', None)",
            "        self.body['server'].update(params)",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.req.headers[\"content-type\"] = \"application/json\"",
            "        server = self.controller.create(self.req, self.body).obj['server']",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-security-groups extension tests",
            "    # def test_create_instance_with_security_group_enabled(self):",
            "    #     self.ext_mgr.extensions = {'os-security-groups': 'fake'}",
            "    #     group = 'foo'",
            "    #     old_create = compute_api.API.create",
            "",
            "    #     def sec_group_get(ctx, proj, name):",
            "    #         if name == group:",
            "    #             return True",
            "    #         else:",
            "    #             raise exception.SecurityGroupNotFoundForProject(",
            "    #                 project_id=proj, security_group_id=name)",
            "",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['security_group'], [group])",
            "    #         return old_create(*args, **kwargs)",
            "",
            "    #     self.stubs.Set(db, 'security_group_get_by_name', sec_group_get)",
            "    #     # negative test",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self._test_create_extra,",
            "    #                       {'security_groups': [{'name': 'bogus'}]})",
            "    #     # positive test - extra assert in create path",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self._test_create_extra({'security_groups': [{'name': group}]})",
            "",
            "    def test_create_instance_with_security_group_disabled(self):",
            "        group = 'foo'",
            "        params = {'security_groups': [{'name': group}]}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            # NOTE(vish): if the security groups extension is not",
            "            #             enabled, then security groups passed in",
            "            #             are ignored.",
            "            self.assertEqual(kwargs['security_group'], ['default'])",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-volumes extension tests",
            "    # def test_create_instance_with_volumes_enabled(self):",
            "    #     self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "    #     bdm = [{'device_name': 'foo'}]",
            "    #     params = {'block_device_mapping': bdm}",
            "    #     old_create = compute_api.API.create",
            "",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['block_device_mapping'], bdm)",
            "    #         return old_create(*args, **kwargs)",
            "",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self._test_create_extra(params)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-volumes extension tests",
            "    # def test_create_instance_with_volumes_enabled_no_image(self):",
            "    #     \"\"\"",
            "    #     Test that the create will fail if there is no image",
            "    #     and no bdms supplied in the request",
            "    #     \"\"\"",
            "    #     self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "    #     old_create = compute_api.API.create",
            "",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertNotIn('imageRef', kwargs)",
            "    #         return old_create(*args, **kwargs)",
            "",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self._test_create_extra, {}, no_image=True)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-volumes extension tests",
            "    # def test_create_instance_with_volumes_enabled_and_bdms_no_image(self):",
            "    #     \"\"\"",
            "    #     Test that the create works if there is no image supplied but",
            "    #     os-volumes extension is enabled and bdms are supplied",
            "    #     \"\"\"",
            "    #     self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "    #     bdm = [{'device_name': 'foo'}]",
            "    #     params = {'block_device_mapping': bdm}",
            "    #     old_create = compute_api.API.create",
            "",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['block_device_mapping'], bdm)",
            "    #         self.assertNotIn('imageRef', kwargs)",
            "    #         return old_create(*args, **kwargs)",
            "",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self._test_create_extra(params, no_image=True)",
            "",
            "    def test_create_instance_with_volumes_disabled(self):",
            "        bdm = [{'device_name': 'foo'}]",
            "        params = {'block_device_mapping': bdm}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['block_device_mapping'], None)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-volumes extension tests",
            "    # def test_create_instance_with_device_name_not_string(self):",
            "    #     self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "    #     bdm = [{'delete_on_termination': 1,",
            "    #             'device_name': 123,",
            "    #             'volume_size': 1,",
            "    #             'volume_id': '11111111-1111-1111-1111-111111111111'}]",
            "    #     params = {'block_device_mapping': bdm}",
            "    #     old_create = compute_api.API.create",
            "    #",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['block_device_mapping'], bdm)",
            "    #         return old_create(*args, **kwargs)",
            "    #",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self._test_create_extra, params)",
            "    #",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-volumes extension tests",
            "    # def test_create_instance_with_device_name_empty(self):",
            "    #     self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "    #     bdm = [{'delete_on_termination': 1,",
            "    #             'device_name': '',",
            "    #             'volume_size': 1,",
            "    #             'volume_id': '11111111-1111-1111-1111-111111111111'}]",
            "    #     params = {'block_device_mapping': bdm}",
            "    #     old_create = compute_api.API.create",
            "    #",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['block_device_mapping'], bdm)",
            "    #         return old_create(*args, **kwargs)",
            "    #",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self._test_create_extra, params)",
            "    #",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-volumes extension tests",
            "    # def test_create_instance_with_device_name_too_long(self):",
            "    #     self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "    #     bdm = [{'delete_on_termination': 1,",
            "    #             'device_name': 'a' * 256,",
            "    #             'volume_size': 1,",
            "    #             'volume_id': '11111111-1111-1111-1111-111111111111'}]",
            "    #     params = {'block_device_mapping': bdm}",
            "    #     old_create = compute_api.API.create",
            "    #",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['block_device_mapping'], bdm)",
            "    #         return old_create(*args, **kwargs)",
            "    #",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self._test_create_extra, params)",
            "    #",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-volumes extension tests",
            "    # def test_create_instance_with_space_in_device_name(self):",
            "    #     self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "    #     bdm = [{'delete_on_termination': 1,",
            "    #             'device_name': 'vd a',",
            "    #             'volume_size': 1,",
            "    #             'volume_id': '11111111-1111-1111-1111-111111111111'}]",
            "    #     params = {'block_device_mapping': bdm}",
            "    #     old_create = compute_api.API.create",
            "    #",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['block_device_mapping'], bdm)",
            "    #         return old_create(*args, **kwargs)",
            "    #",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self.assertRaises(webob.exc.HTTPBadRequest,",
            "    #                       self._test_create_extra, params)",
            "    #",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-volumes extension tests",
            "    # def test_create_instance_with_bdm_delete_on_termination(self):",
            "    #     self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "    #     bdm = [{'device_name': 'foo1', 'delete_on_termination': 1},",
            "    #            {'device_name': 'foo2', 'delete_on_termination': True},",
            "    #            {'device_name': 'foo3', 'delete_on_termination': 'invalid'},",
            "    #            {'device_name': 'foo4', 'delete_on_termination': 0},",
            "    #            {'device_name': 'foo5', 'delete_on_termination': False}]",
            "    #     expected_dbm = [",
            "    #         {'device_name': 'foo1', 'delete_on_termination': True},",
            "    #         {'device_name': 'foo2', 'delete_on_termination': True},",
            "    #         {'device_name': 'foo3', 'delete_on_termination': False},",
            "    #         {'device_name': 'foo4', 'delete_on_termination': False},",
            "    #         {'device_name': 'foo5', 'delete_on_termination': False}]",
            "    #     params = {'block_device_mapping': bdm}",
            "    #     old_create = compute_api.API.create",
            "    #",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['block_device_mapping'], expected_dbm)",
            "    #         return old_create(*args, **kwargs)",
            "    #",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self._test_create_extra(params)",
            "    #",
            "    #",
            "    #",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-keypairs extension tests",
            "    # def test_create_instance_with_keypairs_enabled(self):",
            "    #     self.ext_mgr.extensions = {'os-keypairs': 'fake'}",
            "    #     key_name = 'green'",
            "    #",
            "    #     params = {'key_name': key_name}",
            "    #     old_create = compute_api.API.create",
            "    #",
            "    #     # NOTE(sdague): key pair goes back to the database,",
            "    #     # so we need to stub it out for tests",
            "    #     def key_pair_get(context, user_id, name):",
            "    #         return {'public_key': 'FAKE_KEY',",
            "    #                 'fingerprint': 'FAKE_FINGERPRINT',",
            "    #                 'name': name}",
            "    #",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['key_name'], key_name)",
            "    #         return old_create(*args, **kwargs)",
            "    #",
            "    #     self.stubs.Set(db, 'key_pair_get', key_pair_get)",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self._test_create_extra(params)",
            "    #",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-multi-create extension tests",
            "    # def test_create_instance_with_multiple_create_enabled(self):",
            "    #     self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "    #     min_count = 2",
            "    #     max_count = 3",
            "    #     params = {",
            "    #         'min_count': min_count,",
            "    #         'max_count': max_count,",
            "    #     }",
            "    #     old_create = compute_api.API.create",
            "",
            "    #     def create(*args, **kwargs):",
            "    #         self.assertEqual(kwargs['min_count'], 2)",
            "    #         self.assertEqual(kwargs['max_count'], 3)",
            "    #         return old_create(*args, **kwargs)",
            "",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_multiple_create_disabled(self):",
            "        ret_res_id = True",
            "        min_count = 2",
            "        max_count = 3",
            "        params = {",
            "            'min_count': min_count,",
            "            'max_count': max_count,",
            "        }",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['min_count'], 1)",
            "            self.assertEqual(kwargs['max_count'], 1)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the os-networks extension tests",
            "    # def test_create_instance_with_networks_enabled(self):",
            "    #     self.ext_mgr.extensions = {'os-networks': 'fake'}",
            "    #     net_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    #     requested_networks = [{'uuid': net_uuid}]",
            "    #     params = {'networks': requested_networks}",
            "    #     old_create = compute_api.API.create",
            "",
            "    #     def create(*args, **kwargs):",
            "    #         result = [('76fa36fc-c930-4bf3-8c8a-ea2a2420deb6', None)]",
            "    #         self.assertEqual(kwargs['requested_networks'], result)",
            "    #         return old_create(*args, **kwargs)",
            "",
            "    #     self.stubs.Set(compute_api.API, 'create', create)",
            "    #     self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_networks_disabled_neutronv2(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        net_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "        requested_networks = [{'uuid': net_uuid}]",
            "        params = {'networks': requested_networks}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            result = [('76fa36fc-c930-4bf3-8c8a-ea2a2420deb6', None,",
            "                       None)]",
            "            self.assertEqual(kwargs['requested_networks'], result)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_networks_disabled(self):",
            "        net_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "        requested_networks = [{'uuid': net_uuid}]",
            "        params = {'networks': requested_networks}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['requested_networks'], None)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_access_ip(self):",
            "        # proper local hrefs must start with 'http://localhost/v3/'",
            "        image_href = 'http://localhost/v2/fake/images/%s' % self.image_uuid",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['access_ip_v4'] = '1.2.3.4'",
            "        self.body['server']['access_ip_v6'] = 'fead::1234'",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "        server = res['server']",
            "        self._check_admin_pass_len(server)",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_with_access_ip_pass_disabled(self):",
            "        # test with admin passwords disabled See lp bug 921814",
            "        self.flags(enable_instance_password=False)",
            "",
            "        # proper local hrefs must start with 'http://localhost/v3/'",
            "        self.flags(enable_instance_password=False)",
            "        image_href = 'http://localhost/v2/fake/images/%s' % self.image_uuid",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['access_ip_v4'] = '1.2.3.4'",
            "        self.body['server']['access_ip_v6'] = 'fead::1234'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self._check_admin_pass_missing(server)",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_bad_format_access_ip_v4(self):",
            "        # proper local hrefs must start with 'http://localhost/v3/'",
            "        image_href = 'http://localhost/v2/fake/images/%s' % self.image_uuid",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['access_ip_v4'] = 'bad_format'",
            "        self.body['server']['access_ip_v6'] = 'fead::1234'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.create,",
            "                          self.req, self.body)",
            "",
            "    def test_create_instance_bad_format_access_ip_v6(self):",
            "        # proper local hrefs must start with 'http://localhost/v3/'",
            "        image_href = 'http://localhost/v2/fake/images/%s' % self.image_uuid",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['access_ip_v4'] = '1.2.3.4'",
            "        self.body['server']['access_ip_v6'] = 'bad_format'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.create,",
            "                          self.req, self.body)",
            "",
            "    def test_create_instance_name_too_long(self):",
            "        # proper local hrefs must start with 'http://localhost/v3/'",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['name'] = 'X' * 256",
            "        self.body['server']['image_ref'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.create,",
            "                          self.req, self.body)",
            "",
            "    def test_create_instance(self):",
            "        # proper local hrefs must start with 'http://localhost/v3/'",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['image_ref'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self._check_admin_pass_len(server)",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_extension_create_exception(self):",
            "        def fake_keypair_server_create(self, server_dict,",
            "                                       create_kwargs):",
            "            raise KeyError",
            "",
            "        self.stubs.Set(keypairs.Keypairs, 'server_create',",
            "                       fake_keypair_server_create)",
            "        # proper local hrefs must start with 'http://localhost/v3/'",
            "        image_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "        image_href = 'http://localhost/v3/images/%s' % image_uuid",
            "        flavor_ref = 'http://localhost/123/flavors/3'",
            "        body = {",
            "            'server': {",
            "                'name': 'server_test',",
            "                'image_ref': image_href,",
            "                'flavor_ref': flavor_ref,",
            "                'metadata': {",
            "                    'hello': 'world',",
            "                    'open': 'stack',",
            "                },",
            "            },",
            "        }",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers')",
            "        req.method = 'POST'",
            "        req.body = jsonutils.dumps(body)",
            "        req.headers[\"content-type\"] = \"application/json\"",
            "        self.assertRaises(KeyError, self.controller.create, req, body)",
            "",
            "    def test_create_instance_pass_disabled(self):",
            "        self.flags(enable_instance_password=False)",
            "        # proper local hrefs must start with 'http://localhost/v3/'",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['image_ref'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self._check_admin_pass_missing(server)",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_too_much_metadata(self):",
            "        self.flags(quota_metadata_items=1)",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['metadata']['vote'] = 'fiddletown'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_metadata_key_too_long(self):",
            "        self.flags(quota_metadata_items=1)",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['metadata'] = {('a' * 260): '12345'}",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_metadata_value_too_long(self):",
            "        self.flags(quota_metadata_items=1)",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['metadata'] = {'key1': ('a' * 260)}",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_metadata_key_blank(self):",
            "        self.flags(quota_metadata_items=1)",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['metadata'] = {'': 'abcd'}",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_invalid_key_name(self):",
            "        image_href = 'http://localhost/v2/images/2'",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['key_name'] = 'nonexistentkey'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_valid_key_name(self):",
            "        self.body['server']['key_name'] = 'key'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        self.assertEqual(FAKE_UUID, res[\"server\"][\"id\"])",
            "        self._check_admin_pass_len(res[\"server\"])",
            "",
            "    def test_create_instance_invalid_flavor_href(self):",
            "        image_href = 'http://localhost/v2/images/2'",
            "        flavor_ref = 'http://localhost/v2/flavors/asdf'",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['flavor_ref'] = flavor_ref",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_invalid_flavor_id_int(self):",
            "        image_href = 'http://localhost/v2/images/2'",
            "        flavor_ref = -1",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['flavor_ref'] = flavor_ref",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_bad_flavor_href(self):",
            "        image_href = 'http://localhost/v2/images/2'",
            "        flavor_ref = 'http://localhost/v2/flavors/17'",
            "        self.body['server']['image_ref'] = image_href",
            "        self.body['server']['flavor_ref'] = flavor_ref",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_bad_href(self):",
            "        image_href = 'asdf'",
            "        self.body['server']['image_ref'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_local_href(self):",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_admin_pass(self):",
            "        self.body['server']['flavor_ref'] = 3,",
            "        self.body['server']['admin_pass'] = 'testpass'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self.assertEqual(server['admin_pass'],",
            "                         self.body['server']['admin_pass'])",
            "",
            "    def test_create_instance_admin_pass_pass_disabled(self):",
            "        self.flags(enable_instance_password=False)",
            "        self.body['server']['flavor_ref'] = 3,",
            "        self.body['server']['admin_pass'] = 'testpass'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self.assertTrue('admin_pass' in self.body['server'])",
            "",
            "    def test_create_instance_admin_pass_empty(self):",
            "        self.body['server']['flavor_ref'] = 3,",
            "        self.body['server']['admin_pass'] = ''",
            "        self.req.body = jsonutils.dumps(self.body)",
            "",
            "        # The fact that the action doesn't raise is enough validation",
            "        self.controller.create(self.req, self.body)",
            "",
            "    def test_create_location(self):",
            "        selfhref = 'http://localhost/v2/fake/servers/%s' % FAKE_UUID",
            "        bookhref = 'http://localhost/fake/servers/%s' % FAKE_UUID",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        robj = self.controller.create(self.req, self.body)",
            "",
            "        self.assertEqual(robj['Location'], selfhref)",
            "",
            "    def _do_test_create_instance_above_quota(self, resource, allowed, quota,",
            "                                             expected_msg):",
            "        fakes.stub_out_instance_quota(self.stubs, allowed, quota, resource)",
            "        self.body['server']['flavor_ref'] = 3",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        try:",
            "            server = self.controller.create(self.req, self.body).obj['server']",
            "            self.fail('expected quota to be exceeded')",
            "        except webob.exc.HTTPRequestEntityTooLarge as e:",
            "            self.assertEquals(e.explanation, expected_msg)",
            "",
            "    def test_create_instance_above_quota_instances(self):",
            "        msg = _('Quota exceeded for instances: Requested 1, but'",
            "                ' already used 10 of 10 instances')",
            "        self._do_test_create_instance_above_quota('instances', 0, 10, msg)",
            "",
            "    def test_create_instance_above_quota_ram(self):",
            "        msg = _('Quota exceeded for ram: Requested 4096, but'",
            "                ' already used 8192 of 10240 ram')",
            "        self._do_test_create_instance_above_quota('ram', 2048, 10 * 1024, msg)",
            "",
            "    def test_create_instance_above_quota_cores(self):",
            "        msg = _('Quota exceeded for cores: Requested 2, but'",
            "                ' already used 9 of 10 cores')",
            "        self._do_test_create_instance_above_quota('cores', 1, 10, msg)",
            "",
            "",
            "class TestServerCreateRequestXMLDeserializer(test.TestCase):",
            "",
            "    def setUp(self):",
            "        super(TestServerCreateRequestXMLDeserializer, self).setUp()",
            "        ext_info = plugins.LoadedExtensionInfo()",
            "        servers_controller = servers.ServersController(extension_info=ext_info)",
            "        self.deserializer = servers.CreateDeserializer(servers_controller)",
            "",
            "    def test_minimal_request(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        image_ref=\"1\"",
            "        flavor_ref=\"2\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"2\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_xml_create_exception(self):",
            "        def fake_availablity_extract_xml_deserialize(self,",
            "                                                     server_node,",
            "                                                     server_dict):",
            "            raise KeyError",
            "",
            "        self.stubs.Set(availability_zone.AvailabilityZone,",
            "                       'server_xml_extract_server_deserialize',",
            "                       fake_availablity_extract_xml_deserialize)",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        image_ref=\"1\"",
            "        flavor_ref=\"2\"/>\"\"\"",
            "        self.assertRaises(KeyError, self.deserializer.deserialize,",
            "                          serial_request)",
            "",
            "    def test_request_with_alternate_namespace_prefix(self):",
            "        serial_request = \"\"\"",
            "<ns2:server xmlns:ns2=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        image_ref=\"1\"",
            "        flavor_ref=\"2\">",
            "        <ns2:metadata><ns2:meta key=\"hello\">world</ns2:meta></ns2:metadata>",
            "        </ns2:server>",
            "        \"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"2\",",
            "                'metadata': {\"hello\": \"world\"},",
            "                },",
            "            }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_access_ipv4(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        image_ref=\"1\"",
            "        flavor_ref=\"2\"",
            "        access_ip_v4=\"1.2.3.4\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"2\",",
            "                \"access_ip_v4\": \"1.2.3.4\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_access_ipv6(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        image_ref=\"1\"",
            "        flavor_ref=\"2\"",
            "        access_ip_v6=\"fead::1234\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"2\",",
            "                \"access_ip_v6\": \"fead::1234\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_access_ip(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        image_ref=\"1\"",
            "        flavor_ref=\"2\"",
            "        access_ip_v4=\"1.2.3.4\"",
            "        access_ip_v6=\"fead::1234\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"2\",",
            "                \"access_ip_v4\": \"1.2.3.4\",",
            "                \"access_ip_v6\": \"fead::1234\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_admin_pass(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        image_ref=\"1\"",
            "        flavor_ref=\"2\"",
            "        admin_pass=\"1234\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"2\",",
            "                \"admin_pass\": \"1234\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_image_link(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        image_ref=\"http://localhost:8774/v3/images/2\"",
            "        flavor_ref=\"3\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"http://localhost:8774/v3/images/2\",",
            "                \"flavor_ref\": \"3\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_flavor_link(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        image_ref=\"1\"",
            "        flavor_ref=\"http://localhost:8774/v3/flavors/3\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"http://localhost:8774/v3/flavors/3\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_multiple_metadata_items(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        image_ref=\"1\"",
            "        flavor_ref=\"2\">",
            "    <metadata>",
            "        <meta key=\"one\">two</meta>",
            "        <meta key=\"open\">snack</meta>",
            "    </metadata>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"2\",",
            "                \"metadata\": {\"one\": \"two\", \"open\": \"snack\"},",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_spec_request(self):",
            "        image_bookmark_link = (\"http://servers.api.openstack.org/1234/\"",
            "                               \"images/52415800-8b69-11e0-9b19-734f6f006e54\")",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        image_ref=\"%s\"",
            "        flavor_ref=\"52415800-8b69-11e0-9b19-734f1195ff37\"",
            "        name=\"new-server-test\">",
            "  <metadata>",
            "    <meta key=\"My Server Name\">Apache1</meta>",
            "  </metadata>",
            "</server>\"\"\" % (image_bookmark_link)",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": (\"http://servers.api.openstack.org/1234/\"",
            "                             \"images/52415800-8b69-11e0-9b19-734f6f006e54\"),",
            "                \"flavor_ref\": \"52415800-8b69-11e0-9b19-734f1195ff37\",",
            "                \"metadata\": {\"My Server Name\": \"Apache1\"},",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_empty_networks(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" image_ref=\"1\" flavor_ref=\"1\">",
            "    <networks/>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"1\",",
            "                \"networks\": [],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_one_network(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" image_ref=\"1\" flavor_ref=\"1\">",
            "    <networks>",
            "       <network uuid=\"1\" fixed_ip=\"10.0.1.12\"/>",
            "    </networks>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\", \"fixed_ip\": \"10.0.1.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_two_networks(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" image_ref=\"1\" flavor_ref=\"1\">",
            "    <networks>",
            "       <network uuid=\"1\" fixed_ip=\"10.0.1.12\"/>",
            "       <network uuid=\"2\" fixed_ip=\"10.0.2.12\"/>",
            "    </networks>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\", \"fixed_ip\": \"10.0.1.12\"},",
            "                             {\"uuid\": \"2\", \"fixed_ip\": \"10.0.2.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_second_network_node_ignored(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" image_ref=\"1\" flavor_ref=\"1\">",
            "    <networks>",
            "       <network uuid=\"1\" fixed_ip=\"10.0.1.12\"/>",
            "    </networks>",
            "    <networks>",
            "       <network uuid=\"2\" fixed_ip=\"10.0.2.12\"/>",
            "    </networks>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\", \"fixed_ip\": \"10.0.1.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_one_network_missing_id(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" image_ref=\"1\" flavor_ref=\"1\">",
            "    <networks>",
            "       <network fixed_ip=\"10.0.1.12\"/>",
            "    </networks>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"1\",",
            "                \"networks\": [{\"fixed_ip\": \"10.0.1.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_one_network_missing_fixed_ip(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" image_ref=\"1\" flavor_ref=\"1\">",
            "    <networks>",
            "       <network uuid=\"1\"/>",
            "    </networks>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_one_network_empty_id(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\" image_ref=\"1\" flavor_ref=\"1\">",
            "        <networks>",
            "           <network uuid=\"\" fixed_ip=\"10.0.1.12\"/>",
            "        </networks>",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"1\",",
            "                \"networks\": [{\"uuid\": \"\", \"fixed_ip\": \"10.0.1.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_one_network_empty_fixed_ip(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\" image_ref=\"1\" flavor_ref=\"1\">",
            "        <networks>",
            "           <network uuid=\"1\" fixed_ip=\"\"/>",
            "        </networks>",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\", \"fixed_ip\": \"\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_networks_duplicate_ids(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\" image_ref=\"1\" flavor_ref=\"1\">",
            "        <networks>",
            "           <network uuid=\"1\" fixed_ip=\"10.0.1.12\"/>",
            "           <network uuid=\"1\" fixed_ip=\"10.0.2.12\"/>",
            "        </networks>",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\", \"fixed_ip\": \"10.0.1.12\"},",
            "                             {\"uuid\": \"1\", \"fixed_ip\": \"10.0.2.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_multiple_create_args(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\" image_ref=\"1\" flavor_ref=\"1\"",
            "     min_count=\"1\" max_count=\"3\" return_reservation_id=\"True\">",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"1\",",
            "                \"min_count\": \"1\",",
            "                \"max_count\": \"3\",",
            "                \"return_reservation_id\": True,",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    # TODO(cyeoh): bp-v3-api-unittests",
            "    # This needs to be ported to the scheduler hints extension tests",
            "    # def test_request_with_scheduler_hints(self):",
            "    #     serial_request = \"\"\"",
            "    # <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "    #  xmlns:OS-SCH-HNT=",
            "    #  \"http://docs.openstack.org/compute/ext/scheduler-hints/api/v2\"",
            "    #  name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "    #    <OS-SCH-HNT:scheduler_hints>",
            "    #      <different_host>",
            "    #        7329b667-50c7-46a6-b913-cb2a09dfeee0",
            "    #      </different_host>",
            "    #      <different_host>",
            "    #        f31efb24-34d2-43e1-8b44-316052956a39",
            "    #      </different_host>",
            "    #    </OS-SCH-HNT:scheduler_hints>",
            "    # </server>\"\"\"",
            "    #     request = self.deserializer.deserialize(serial_request)",
            "    #     expected = {\"server\": {",
            "    #             \"name\": \"new-server-test\",",
            "    #             \"imageRef\": \"1\",",
            "    #             \"flavorRef\": \"1\",",
            "    #             \"OS-SCH-HNT:scheduler_hints\": {",
            "    #                 \"different_host\": [",
            "    #                     \"7329b667-50c7-46a6-b913-cb2a09dfeee0\",",
            "    #                     \"f31efb24-34d2-43e1-8b44-316052956a39\",",
            "    #                 ]",
            "    #             }",
            "    #             }}",
            "    #     self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_block_device_mapping(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\" image_ref=\"1\" flavor_ref=\"1\">",
            "       <block_device_mapping>",
            "         <mapping volume_id=\"7329b667-50c7-46a6-b913-cb2a09dfeee0\"",
            "          device_name=\"/dev/vda\" virtual_name=\"root\"",
            "          delete_on_termination=\"False\" />",
            "         <mapping snapshot_id=\"f31efb24-34d2-43e1-8b44-316052956a39\"",
            "          device_name=\"/dev/vdb\" virtual_name=\"ephemeral0\"",
            "          delete_on_termination=\"False\" />",
            "         <mapping device_name=\"/dev/vdc\" no_device=\"True\" />",
            "       </block_device_mapping>",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"image_ref\": \"1\",",
            "                \"flavor_ref\": \"1\",",
            "                \"block_device_mapping\": [",
            "                    {",
            "                        \"volume_id\": \"7329b667-50c7-46a6-b913-cb2a09dfeee0\",",
            "                        \"device_name\": \"/dev/vda\",",
            "                        \"virtual_name\": \"root\",",
            "                        \"delete_on_termination\": False,",
            "                    },",
            "                    {",
            "                        \"snapshot_id\": \"f31efb24-34d2-43e1-8b44-316052956a39\",",
            "                        \"device_name\": \"/dev/vdb\",",
            "                        \"virtual_name\": \"ephemeral0\",",
            "                        \"delete_on_termination\": False,",
            "                    },",
            "                    {",
            "                        \"device_name\": \"/dev/vdc\",",
            "                        \"no_device\": True,",
            "                    },",
            "                ]",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_corrupt_xml(self):",
            "        \"\"\"Should throw a 400 error on corrupt xml.\"\"\"",
            "        self.assertRaises(",
            "                exception.MalformedRequestBody,",
            "                self.deserializer.deserialize,",
            "                utils.killer_xml_body())",
            "",
            "",
            "class TestAddressesXMLSerialization(test.TestCase):",
            "",
            "    index_serializer = ips.AddressesTemplate()",
            "    show_serializer = ips.NetworkTemplate()",
            "",
            "    def test_xml_declaration(self):",
            "        fixture = {",
            "            'network_2': [",
            "                {'addr': '192.168.0.1', 'version': 4,",
            "                 'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                {'addr': 'fe80::beef', 'version': 6,",
            "                 'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'}",
            "            ],",
            "        }",
            "        output = self.show_serializer.serialize(fixture)",
            "        has_dec = output.startswith(\"<?xml version='1.0' encoding='UTF-8'?>\")",
            "        self.assertTrue(has_dec)",
            "",
            "    def test_show(self):",
            "        fixture = {",
            "            'network_2': [",
            "                {'addr': '192.168.0.1', 'version': 4,",
            "                 'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                {'addr': 'fe80::beef', 'version': 6,",
            "                 'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'}",
            "            ],",
            "        }",
            "        output = self.show_serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        network = fixture['network_2']",
            "        self.assertEqual(str(root.get('id')), 'network_2')",
            "        ip_elems = root.findall('{0}ip'.format(NS))",
            "        for z, ip_elem in enumerate(ip_elems):",
            "            ip = network[z]",
            "            self.assertEqual(str(ip_elem.get('version')),",
            "                             str(ip['version']))",
            "            self.assertEqual(str(ip_elem.get('addr')),",
            "                             str(ip['addr']))",
            "            self.assertEqual(str(ip_elem.get('type')),",
            "                                 str(ip['type']))",
            "            self.assertEqual(str(ip_elem.get('mac_addr')),",
            "                                 str(ip['mac_addr']))",
            "",
            "    def test_index(self):",
            "        fixture = {",
            "            'addresses': {",
            "                'network_1': [",
            "                    {'addr': '192.168.0.3', 'version': 4,",
            "                     'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                    {'addr': '192.168.0.5', 'version': 4,",
            "                     'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'}",
            "                ],",
            "                'network_2': [",
            "                    {'addr': '192.168.0.1', 'version': 4,",
            "                     'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                    {'addr': 'fe80::beef', 'version': 6,",
            "                     'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'}",
            "                ],",
            "            },",
            "        }",
            "        output = self.index_serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'addresses', version='v3')",
            "        addresses_dict = fixture['addresses']",
            "        network_elems = root.findall('{0}network'.format(NS))",
            "        self.assertEqual(len(network_elems), 2)",
            "        for i, network_elem in enumerate(network_elems):",
            "            network = addresses_dict.items()[i]",
            "            self.assertEqual(str(network_elem.get('id')), str(network[0]))",
            "            ip_elems = network_elem.findall('{0}ip'.format(NS))",
            "            for z, ip_elem in enumerate(ip_elems):",
            "                ip = network[1][z]",
            "                self.assertEqual(str(ip_elem.get('version')),",
            "                                 str(ip['version']))",
            "                self.assertEqual(str(ip_elem.get('addr')),",
            "                                 str(ip['addr']))",
            "                self.assertEqual(str(ip_elem.get('type')),",
            "                                 str(ip['type']))",
            "                self.assertEqual(str(ip_elem.get('mac_addr')),",
            "                                 str(ip['mac_addr']))",
            "",
            "",
            "class ServersViewBuilderTest(test.TestCase):",
            "",
            "    def setUp(self):",
            "        super(ServersViewBuilderTest, self).setUp()",
            "        self.flags(use_ipv6=True)",
            "        self.instance = fakes.stub_instance(",
            "            id=1,",
            "            image_ref=\"5\",",
            "            uuid=\"deadbeef-feed-edee-beef-d0ea7beefedd\",",
            "            display_name=\"test_server\",",
            "            include_fake_metadata=False)",
            "",
            "        privates = ['172.19.0.1']",
            "        publics = ['192.168.0.3']",
            "        public6s = ['b33f::fdee:ddff:fecc:bbaa']",
            "",
            "        def nw_info(*args, **kwargs):",
            "            return [(None, {'label': 'public',",
            "                            'ips': [dict(ip=ip) for ip in publics],",
            "                            'ip6s': [dict(ip=ip) for ip in public6s]}),",
            "                    (None, {'label': 'private',",
            "                            'ips': [dict(ip=ip) for ip in privates]})]",
            "",
            "        def floaters(*args, **kwargs):",
            "            return []",
            "",
            "        fakes.stub_out_nw_api_get_instance_nw_info(self.stubs, nw_info)",
            "        fakes.stub_out_nw_api_get_floating_ips_by_fixed_address(self.stubs,",
            "                                                                floaters)",
            "",
            "        self.uuid = self.instance['uuid']",
            "        self.view_builder = views.servers.ViewBuilderV3()",
            "        self.request = fakes.HTTPRequestV3.blank(\"\")",
            "",
            "    def test_get_flavor_valid_instance_type(self):",
            "        flavor_bookmark = \"http://localhost/flavors/1\"",
            "        expected = {\"id\": \"1\",",
            "                    \"links\": [{\"rel\": \"bookmark\",",
            "                               \"href\": flavor_bookmark}]}",
            "        result = self.view_builder._get_flavor(self.request, self.instance)",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_build_server(self):",
            "        self_link = \"http://localhost/v3/servers/%s\" % self.uuid",
            "        bookmark_link = \"http://localhost/servers/%s\" % self.uuid",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": self.uuid,",
            "                \"name\": \"test_server\",",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": self_link,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": bookmark_link,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        output = self.view_builder.basic(self.request, self.instance)",
            "        self.assertThat(output, matchers.DictMatches(expected_server))",
            "",
            "    def test_build_server_with_project_id(self):",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": self.uuid,",
            "                \"name\": \"test_server\",",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": \"http://localhost/v3/servers/%s\" %",
            "                                self.uuid,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": \"http://localhost/servers/%s\" % self.uuid,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        output = self.view_builder.basic(self.request, self.instance)",
            "        self.assertThat(output, matchers.DictMatches(expected_server))",
            "",
            "    def test_build_server_detail(self):",
            "        image_bookmark = \"http://localhost/images/5\"",
            "        flavor_bookmark = \"http://localhost/flavors/1\"",
            "        self_link = \"http://localhost/v3/servers/%s\" % self.uuid",
            "        bookmark_link = \"http://localhost/servers/%s\" % self.uuid",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": self.uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"access_ip_v4\": \"\",",
            "                \"access_ip_v6\": \"\",",
            "                \"host_id\": '',",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                  \"links\": [",
            "                                            {",
            "                          \"rel\": \"bookmark\",",
            "                          \"href\": flavor_bookmark,",
            "                      },",
            "                  ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'}",
            "                    ]",
            "                },",
            "                \"metadata\": {},",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": self_link,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": bookmark_link,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output, matchers.DictMatches(expected_server))",
            "",
            "    def test_build_server_no_image(self):",
            "        self.instance[\"image_ref\"] = \"\"",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertEqual(output['server']['image'], \"\")",
            "",
            "    def test_build_server_detail_with_fault(self):",
            "        self.instance['vm_state'] = vm_states.ERROR",
            "        self.instance['fault'] = {",
            "            'code': 404,",
            "            'instance_uuid': self.uuid,",
            "            'message': \"HTTPNotFound\",",
            "            'details': \"Stock details for test\",",
            "            'created_at': datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "        }",
            "",
            "        image_bookmark = \"http://localhost/images/5\"",
            "        flavor_bookmark = \"http://localhost/flavors/1\"",
            "        self_link = \"http://localhost/v3/servers/%s\" % self.uuid",
            "        bookmark_link = \"http://localhost/servers/%s\" % self.uuid",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": self.uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"name\": \"test_server\",",
            "                \"status\": \"ERROR\",",
            "                \"access_ip_v4\": \"\",",
            "                \"access_ip_v6\": \"\",",
            "                \"host_id\": '',",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                  \"links\": [",
            "                                            {",
            "                          \"rel\": \"bookmark\",",
            "                          \"href\": flavor_bookmark,",
            "                      },",
            "                  ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'}",
            "                    ]",
            "                },",
            "                \"metadata\": {},",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": self_link,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": bookmark_link,",
            "                    },",
            "                ],",
            "                \"fault\": {",
            "                    \"code\": 404,",
            "                    \"created\": \"2010-10-10T12:00:00Z\",",
            "                    \"message\": \"HTTPNotFound\",",
            "                    \"details\": \"Stock details for test\",",
            "                },",
            "            }",
            "        }",
            "",
            "        self.request.context = context.RequestContext('fake', 'fake')",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output, matchers.DictMatches(expected_server))",
            "",
            "    def test_build_server_detail_with_fault_no_details_not_admin(self):",
            "        self.instance['vm_state'] = vm_states.ERROR",
            "        self.instance['fault'] = {",
            "            'code': 500,",
            "            'instance_uuid': self.uuid,",
            "            'message': \"Error\",",
            "            'details': 'Stock details for test',",
            "            'created_at': datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "        }",
            "",
            "        expected_fault = {\"code\": 500,",
            "                          \"created\": \"2010-10-10T12:00:00Z\",",
            "                          \"message\": \"Error\"}",
            "",
            "        self.request.context = context.RequestContext('fake', 'fake')",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output['server']['fault'],",
            "                        matchers.DictMatches(expected_fault))",
            "",
            "    def test_build_server_detail_with_fault_admin(self):",
            "        self.instance['vm_state'] = vm_states.ERROR",
            "        self.instance['fault'] = {",
            "            'code': 500,",
            "            'instance_uuid': self.uuid,",
            "            'message': \"Error\",",
            "            'details': 'Stock details for test',",
            "            'created_at': datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "        }",
            "",
            "        expected_fault = {\"code\": 500,",
            "                          \"created\": \"2010-10-10T12:00:00Z\",",
            "                          \"message\": \"Error\",",
            "                          'details': 'Stock details for test'}",
            "",
            "        self.request.environ['nova.context'].is_admin = True",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output['server']['fault'],",
            "                        matchers.DictMatches(expected_fault))",
            "",
            "    def test_build_server_detail_with_fault_no_details_admin(self):",
            "        self.instance['vm_state'] = vm_states.ERROR",
            "        self.instance['fault'] = {",
            "            'code': 500,",
            "            'instance_uuid': self.uuid,",
            "            'message': \"Error\",",
            "            'details': '',",
            "            'created_at': datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "        }",
            "",
            "        expected_fault = {\"code\": 500,",
            "                          \"created\": \"2010-10-10T12:00:00Z\",",
            "                          \"message\": \"Error\"}",
            "",
            "        self.request.environ['nova.context'].is_admin = True",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output['server']['fault'],",
            "                        matchers.DictMatches(expected_fault))",
            "",
            "    def test_build_server_detail_with_fault_but_active(self):",
            "        self.instance['vm_state'] = vm_states.ACTIVE",
            "        self.instance['progress'] = 100",
            "        self.instance['fault'] = {",
            "            'code': 404,",
            "            'instance_uuid': self.uuid,",
            "            'message': \"HTTPNotFound\",",
            "            'details': \"Stock details for test\",",
            "            'created_at': datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "        }",
            "",
            "        image_bookmark = \"http://localhost/images/5\"",
            "        flavor_bookmark = \"http://localhost/flavors/1\"",
            "        self_link = \"http://localhost/v3/servers/%s\" % self.uuid",
            "        bookmark_link = \"http://localhost/servers/%s\" % self.uuid",
            "",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertFalse('fault' in output['server'])",
            "",
            "    def test_build_server_detail_active_status(self):",
            "        #set the power state of the instance to running",
            "        self.instance['vm_state'] = vm_states.ACTIVE",
            "        self.instance['progress'] = 100",
            "        image_bookmark = \"http://localhost/images/5\"",
            "        flavor_bookmark = \"http://localhost/flavors/1\"",
            "        self_link = \"http://localhost/v3/servers/%s\" % self.uuid",
            "        bookmark_link = \"http://localhost/servers/%s\" % self.uuid",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": self.uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 100,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"ACTIVE\",",
            "                \"access_ip_v4\": \"\",",
            "                \"access_ip_v6\": \"\",",
            "                \"host_id\": '',",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                  \"links\": [",
            "                                            {",
            "                          \"rel\": \"bookmark\",",
            "                          \"href\": flavor_bookmark,",
            "                      },",
            "                  ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'}",
            "                    ]",
            "                },",
            "                \"metadata\": {},",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": self_link,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": bookmark_link,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output, matchers.DictMatches(expected_server))",
            "",
            "    def test_build_server_detail_with_accessipv4(self):",
            "",
            "        self.instance['access_ip_v4'] = '1.2.3.4'",
            "",
            "        image_bookmark = \"http://localhost/images/5\"",
            "        flavor_bookmark = \"http://localhost/flavors/1\"",
            "        self_link = \"http://localhost/v3/servers/%s\" % self.uuid",
            "        bookmark_link = \"http://localhost/servers/%s\" % self.uuid",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": self.uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"host_id\": '',",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                                              {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": flavor_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                    ]",
            "                },",
            "                \"metadata\": {},",
            "                \"access_ip_v4\": \"1.2.3.4\",",
            "                \"access_ip_v6\": \"\",",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": self_link,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": bookmark_link,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output, matchers.DictMatches(expected_server))",
            "",
            "    def test_build_server_detail_with_accessipv6(self):",
            "",
            "        self.instance['access_ip_v6'] = 'fead::1234'",
            "",
            "        image_bookmark = \"http://localhost/images/5\"",
            "        flavor_bookmark = \"http://localhost/flavors/1\"",
            "        self_link = \"http://localhost/v3/servers/%s\" % self.uuid",
            "        bookmark_link = \"http://localhost/servers/%s\" % self.uuid",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": self.uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"host_id\": '',",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                                              {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": flavor_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                    ]",
            "                },",
            "                \"metadata\": {},",
            "                \"access_ip_v4\": \"\",",
            "                \"access_ip_v6\": \"fead::1234\",",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": self_link,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": bookmark_link,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output, matchers.DictMatches(expected_server))",
            "",
            "    def test_build_server_detail_with_metadata(self):",
            "",
            "        metadata = []",
            "        metadata.append(models.InstanceMetadata(key=\"Open\", value=\"Stack\"))",
            "        self.instance['metadata'] = metadata",
            "",
            "        image_bookmark = \"http://localhost/images/5\"",
            "        flavor_bookmark = \"http://localhost/flavors/1\"",
            "        self_link = \"http://localhost/v3/servers/%s\" % self.uuid",
            "        bookmark_link = \"http://localhost/servers/%s\" % self.uuid",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": self.uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"access_ip_v4\": \"\",",
            "                \"access_ip_v6\": \"\",",
            "                \"host_id\": '',",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                                              {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": flavor_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1',",
            "                         'type': 'fixed', 'mac_addr': 'aa:aa:aa:aa:aa:aa'},",
            "                    ]",
            "                },",
            "                \"metadata\": {\"Open\": \"Stack\"},",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": self_link,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": bookmark_link,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output, matchers.DictMatches(expected_server))",
            "",
            "",
            "class ServerXMLSerializationTest(test.TestCase):",
            "",
            "    TIMESTAMP = \"2010-10-11T10:30:22Z\"",
            "    SERVER_HREF = 'http://localhost/v3/servers/%s' % FAKE_UUID",
            "    SERVER_NEXT = 'http://localhost/v3/servers?limit=%s&marker=%s'",
            "    SERVER_BOOKMARK = 'http://localhost/servers/%s' % FAKE_UUID",
            "    IMAGE_BOOKMARK = 'http://localhost/images/5'",
            "    FLAVOR_BOOKMARK = 'http://localhost/flavors/1'",
            "",
            "    def test_xml_declaration(self):",
            "        serializer = servers.ServerTemplate()",
            "",
            "        fixture = {",
            "            \"server\": {",
            "                'id': FAKE_UUID,",
            "                'user_id': 'fake_user_id',",
            "                'tenant_id': 'fake_tenant_id',",
            "                'created': self.TIMESTAMP,",
            "                'updated': self.TIMESTAMP,",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"host_id\": 'e4d909c290d0fb1ca068ffaddf22cbd0',",
            "                \"access_ip_v4\": \"1.2.3.4\",",
            "                \"access_ip_v6\": \"fead::1234\",",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.IMAGE_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.FLAVOR_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    \"network_one\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                    ],",
            "                    \"network_two\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.139\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.139\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                    ],",
            "                },",
            "                \"metadata\": {",
            "                    \"Open\": \"Stack\",",
            "                    \"Number\": \"1\",",
            "                },",
            "                'links': [",
            "                    {",
            "                        'href': self.SERVER_HREF,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': self.SERVER_BOOKMARK,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        output = serializer.serialize(fixture)",
            "        has_dec = output.startswith(\"<?xml version='1.0' encoding='UTF-8'?>\")",
            "        self.assertTrue(has_dec)",
            "",
            "    def test_show(self):",
            "        serializer = servers.ServerTemplate()",
            "",
            "        fixture = {",
            "            \"server\": {",
            "                \"id\": FAKE_UUID,",
            "                \"user_id\": \"fake\",",
            "                \"tenant_id\": \"fake\",",
            "                'created': self.TIMESTAMP,",
            "                'updated': self.TIMESTAMP,",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"host_id\": 'e4d909c290d0fb1ca068ffaddf22cbd0',",
            "                \"access_ip_v4\": \"1.2.3.4\",",
            "                \"access_ip_v6\": \"fead::1234\",",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.IMAGE_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.FLAVOR_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    \"network_one\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                    ],",
            "                    \"network_two\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.139\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.139\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                    ],",
            "                },",
            "                \"metadata\": {",
            "                    \"Open\": \"Stack\",",
            "                    \"Number\": \"1\",",
            "                },",
            "                'links': [",
            "                    {",
            "                        'href': self.SERVER_HREF,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': self.SERVER_BOOKMARK,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        output = serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'server', version='v3')",
            "",
            "        server_dict = fixture['server']",
            "",
            "        for key in ['name', 'id', 'created', 'access_ip_v4',",
            "                    'updated', 'progress', 'status', 'host_id',",
            "                    'access_ip_v6']:",
            "            self.assertEqual(root.get(key), str(server_dict[key]))",
            "",
            "        link_nodes = root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 2)",
            "        for i, link in enumerate(server_dict['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        metadata_root = root.find('{0}metadata'.format(NS))",
            "        metadata_elems = metadata_root.findall('{0}meta'.format(NS))",
            "        self.assertEqual(len(metadata_elems), 2)",
            "        for i, metadata_elem in enumerate(metadata_elems):",
            "            (meta_key, meta_value) = server_dict['metadata'].items()[i]",
            "            self.assertEqual(str(metadata_elem.get('key')), str(meta_key))",
            "            self.assertEqual(str(metadata_elem.text).strip(), str(meta_value))",
            "",
            "        image_root = root.find('{0}image'.format(NS))",
            "        self.assertEqual(image_root.get('id'), server_dict['image']['id'])",
            "        link_nodes = image_root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 1)",
            "        for i, link in enumerate(server_dict['image']['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        flavor_root = root.find('{0}flavor'.format(NS))",
            "        self.assertEqual(flavor_root.get('id'), server_dict['flavor']['id'])",
            "        link_nodes = flavor_root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 1)",
            "        for i, link in enumerate(server_dict['flavor']['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        addresses_root = root.find('{0}addresses'.format(NS))",
            "        addresses_dict = server_dict['addresses']",
            "        network_elems = addresses_root.findall('{0}network'.format(NS))",
            "        self.assertEqual(len(network_elems), 2)",
            "        for i, network_elem in enumerate(network_elems):",
            "            network = addresses_dict.items()[i]",
            "            self.assertEqual(str(network_elem.get('id')), str(network[0]))",
            "            ip_elems = network_elem.findall('{0}ip'.format(NS))",
            "            for z, ip_elem in enumerate(ip_elems):",
            "                ip = network[1][z]",
            "                self.assertEqual(str(ip_elem.get('version')),",
            "                                 str(ip['version']))",
            "                self.assertEqual(str(ip_elem.get('addr')),",
            "                                 str(ip['addr']))",
            "                self.assertEqual(str(ip_elem.get('type')),",
            "                                 str(ip['type']))",
            "                self.assertEqual(str(ip_elem.get('mac_addr')),",
            "                                 str(ip['mac_addr']))",
            "",
            "    def test_create(self):",
            "        serializer = servers.FullServerTemplate()",
            "",
            "        fixture = {",
            "            \"server\": {",
            "                \"id\": FAKE_UUID,",
            "                \"user_id\": \"fake\",",
            "                \"tenant_id\": \"fake\",",
            "                'created': self.TIMESTAMP,",
            "                'updated': self.TIMESTAMP,",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"access_ip_v4\": \"1.2.3.4\",",
            "                \"access_ip_v6\": \"fead::1234\",",
            "                \"host_id\": \"e4d909c290d0fb1ca068ffaddf22cbd0\",",
            "                \"admin_pass\": \"test_password\",",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.IMAGE_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.FLAVOR_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    \"network_one\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                    ],",
            "                    \"network_two\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.139\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.139\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                    ],",
            "                },",
            "                \"metadata\": {",
            "                    \"Open\": \"Stack\",",
            "                    \"Number\": \"1\",",
            "                },",
            "                'links': [",
            "                    {",
            "                        'href': self.SERVER_HREF,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': self.SERVER_BOOKMARK,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        output = serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'server', version='v3')",
            "",
            "        server_dict = fixture['server']",
            "",
            "        for key in ['name', 'id', 'created', 'access_ip_v4',",
            "                    'updated', 'progress', 'status', 'host_id',",
            "                    'access_ip_v6', 'admin_pass']:",
            "            self.assertEqual(root.get(key), str(server_dict[key]))",
            "",
            "        link_nodes = root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 2)",
            "        for i, link in enumerate(server_dict['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        metadata_root = root.find('{0}metadata'.format(NS))",
            "        metadata_elems = metadata_root.findall('{0}meta'.format(NS))",
            "        self.assertEqual(len(metadata_elems), 2)",
            "        for i, metadata_elem in enumerate(metadata_elems):",
            "            (meta_key, meta_value) = server_dict['metadata'].items()[i]",
            "            self.assertEqual(str(metadata_elem.get('key')), str(meta_key))",
            "            self.assertEqual(str(metadata_elem.text).strip(), str(meta_value))",
            "",
            "        image_root = root.find('{0}image'.format(NS))",
            "        self.assertEqual(image_root.get('id'), server_dict['image']['id'])",
            "        link_nodes = image_root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 1)",
            "        for i, link in enumerate(server_dict['image']['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        flavor_root = root.find('{0}flavor'.format(NS))",
            "        self.assertEqual(flavor_root.get('id'), server_dict['flavor']['id'])",
            "        link_nodes = flavor_root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 1)",
            "        for i, link in enumerate(server_dict['flavor']['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        addresses_root = root.find('{0}addresses'.format(NS))",
            "        addresses_dict = server_dict['addresses']",
            "        network_elems = addresses_root.findall('{0}network'.format(NS))",
            "        self.assertEqual(len(network_elems), 2)",
            "        for i, network_elem in enumerate(network_elems):",
            "            network = addresses_dict.items()[i]",
            "            self.assertEqual(str(network_elem.get('id')), str(network[0]))",
            "            ip_elems = network_elem.findall('{0}ip'.format(NS))",
            "            for z, ip_elem in enumerate(ip_elems):",
            "                ip = network[1][z]",
            "                self.assertEqual(str(ip_elem.get('version')),",
            "                                 str(ip['version']))",
            "                self.assertEqual(str(ip_elem.get('addr')),",
            "                                 str(ip['addr']))",
            "                self.assertEqual(str(ip_elem.get('type')),",
            "                                 str(ip['type']))",
            "                self.assertEqual(str(ip_elem.get('mac_addr')),",
            "                                 str(ip['mac_addr']))",
            "",
            "    def test_index(self):",
            "        serializer = servers.MinimalServersTemplate()",
            "",
            "        uuid1 = fakes.get_fake_uuid(1)",
            "        uuid2 = fakes.get_fake_uuid(2)",
            "        expected_server_href = 'http://localhost/v3/servers/%s' % uuid1",
            "        expected_server_bookmark = 'http://localhost/servers/%s' % uuid1",
            "        expected_server_href_2 = 'http://localhost/v3/servers/%s' % uuid2",
            "        expected_server_bookmark_2 = 'http://localhost/servers/%s' % uuid2",
            "        fixture = {\"servers\": [",
            "            {",
            "                \"id\": fakes.get_fake_uuid(1),",
            "                \"name\": \"test_server\",",
            "                'links': [",
            "                    {",
            "                        'href': expected_server_href,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': expected_server_bookmark,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            },",
            "            {",
            "                \"id\": fakes.get_fake_uuid(2),",
            "                \"name\": \"test_server_2\",",
            "                'links': [",
            "                    {",
            "                        'href': expected_server_href_2,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': expected_server_bookmark_2,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            },",
            "        ]}",
            "",
            "        output = serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'servers_index', version='v3')",
            "        server_elems = root.findall('{0}server'.format(NS))",
            "        self.assertEqual(len(server_elems), 2)",
            "        for i, server_elem in enumerate(server_elems):",
            "            server_dict = fixture['servers'][i]",
            "            for key in ['name', 'id']:",
            "                self.assertEqual(server_elem.get(key), str(server_dict[key]))",
            "",
            "            link_nodes = server_elem.findall('{0}link'.format(ATOMNS))",
            "            self.assertEqual(len(link_nodes), 2)",
            "            for i, link in enumerate(server_dict['links']):",
            "                for key, value in link.items():",
            "                    self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "    def test_index_with_servers_links(self):",
            "        serializer = servers.MinimalServersTemplate()",
            "",
            "        uuid1 = fakes.get_fake_uuid(1)",
            "        uuid2 = fakes.get_fake_uuid(2)",
            "        expected_server_href = 'http://localhost/v3/servers/%s' % uuid1",
            "        expected_server_next = self.SERVER_NEXT % (2, 2)",
            "        expected_server_bookmark = 'http://localhost/servers/%s' % uuid1",
            "        expected_server_href_2 = 'http://localhost/v3/servers/%s' % uuid2",
            "        expected_server_bookmark_2 = 'http://localhost/servers/%s' % uuid2",
            "        fixture = {\"servers\": [",
            "            {",
            "                \"id\": fakes.get_fake_uuid(1),",
            "                \"name\": \"test_server\",",
            "                'links': [",
            "                    {",
            "                        'href': expected_server_href,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': expected_server_bookmark,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            },",
            "            {",
            "                \"id\": fakes.get_fake_uuid(2),",
            "                \"name\": \"test_server_2\",",
            "                'links': [",
            "                    {",
            "                        'href': expected_server_href_2,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': expected_server_bookmark_2,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            },",
            "        ],",
            "        \"servers_links\": [",
            "            {",
            "                'rel': 'next',",
            "                'href': expected_server_next,",
            "            },",
            "        ]}",
            "",
            "        output = serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'servers_index', version='v3')",
            "        server_elems = root.findall('{0}server'.format(NS))",
            "        self.assertEqual(len(server_elems), 2)",
            "        for i, server_elem in enumerate(server_elems):",
            "            server_dict = fixture['servers'][i]",
            "            for key in ['name', 'id']:",
            "                self.assertEqual(server_elem.get(key), str(server_dict[key]))",
            "",
            "            link_nodes = server_elem.findall('{0}link'.format(ATOMNS))",
            "            self.assertEqual(len(link_nodes), 2)",
            "            for i, link in enumerate(server_dict['links']):",
            "                for key, value in link.items():",
            "                    self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        # Check servers_links",
            "        servers_links = root.findall('{0}link'.format(ATOMNS))",
            "        for i, link in enumerate(fixture['servers_links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(servers_links[i].get(key), value)",
            "",
            "    def test_detail(self):",
            "        serializer = servers.ServersTemplate()",
            "",
            "        uuid1 = fakes.get_fake_uuid(1)",
            "        expected_server_href = 'http://localhost/v3/servers/%s' % uuid1",
            "        expected_server_bookmark = 'http://localhost/servers/%s' % uuid1",
            "        expected_image_bookmark = self.IMAGE_BOOKMARK",
            "        expected_flavor_bookmark = self.FLAVOR_BOOKMARK",
            "",
            "        uuid2 = fakes.get_fake_uuid(2)",
            "        expected_server_href_2 = 'http://localhost/v3/servers/%s' % uuid2",
            "        expected_server_bookmark_2 = 'http://localhost/servers/%s' % uuid2",
            "        fixture = {\"servers\": [",
            "            {",
            "                \"id\": fakes.get_fake_uuid(1),",
            "                \"user_id\": \"fake\",",
            "                \"tenant_id\": \"fake\",",
            "                'created': self.TIMESTAMP,",
            "                'updated': self.TIMESTAMP,",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"access_ip_v4\": \"1.2.3.4\",",
            "                \"access_ip_v6\": \"fead::1234\",",
            "                \"host_id\": 'e4d909c290d0fb1ca068ffaddf22cbd0',",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": expected_image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": expected_flavor_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    \"network_one\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "",
            "                        },",
            "                    ],",
            "                },",
            "                \"metadata\": {",
            "                    \"Number\": \"1\",",
            "                },",
            "                \"links\": [",
            "                    {",
            "                        \"href\": expected_server_href,",
            "                        \"rel\": \"self\",",
            "                    },",
            "                    {",
            "                        \"href\": expected_server_bookmark,",
            "                        \"rel\": \"bookmark\",",
            "                    },",
            "                ],",
            "            },",
            "            {",
            "                \"id\": fakes.get_fake_uuid(2),",
            "                \"user_id\": 'fake',",
            "                \"tenant_id\": 'fake',",
            "                'created': self.TIMESTAMP,",
            "                'updated': self.TIMESTAMP,",
            "                \"progress\": 100,",
            "                \"name\": \"test_server_2\",",
            "                \"status\": \"ACTIVE\",",
            "                \"access_ip_v4\": \"1.2.3.4\",",
            "                \"access_ip_v6\": \"fead::1234\",",
            "                \"host_id\": 'e4d909c290d0fb1ca068ffaddf22cbd0',",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": expected_image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": expected_flavor_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    \"network_one\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "",
            "                        },",
            "                    ],",
            "                },",
            "                \"metadata\": {",
            "                    \"Number\": \"2\",",
            "                },",
            "                \"links\": [",
            "                    {",
            "                        \"href\": expected_server_href_2,",
            "                        \"rel\": \"self\",",
            "                    },",
            "                    {",
            "                        \"href\": expected_server_bookmark_2,",
            "                        \"rel\": \"bookmark\",",
            "                    },",
            "                ],",
            "            },",
            "        ]}",
            "",
            "        output = serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'servers', version='v3')",
            "        server_elems = root.findall('{0}server'.format(NS))",
            "        self.assertEqual(len(server_elems), 2)",
            "        for i, server_elem in enumerate(server_elems):",
            "            server_dict = fixture['servers'][i]",
            "",
            "            for key in ['name', 'id', 'created', 'access_ip_v4',",
            "                        'updated', 'progress', 'status', 'host_id',",
            "                        'access_ip_v6']:",
            "                self.assertEqual(server_elem.get(key), str(server_dict[key]))",
            "",
            "            link_nodes = server_elem.findall('{0}link'.format(ATOMNS))",
            "            self.assertEqual(len(link_nodes), 2)",
            "            for i, link in enumerate(server_dict['links']):",
            "                for key, value in link.items():",
            "                    self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "            metadata_root = server_elem.find('{0}metadata'.format(NS))",
            "            metadata_elems = metadata_root.findall('{0}meta'.format(NS))",
            "            for i, metadata_elem in enumerate(metadata_elems):",
            "                (meta_key, meta_value) = server_dict['metadata'].items()[i]",
            "                self.assertEqual(str(metadata_elem.get('key')), str(meta_key))",
            "                self.assertEqual(str(metadata_elem.text).strip(),",
            "                                 str(meta_value))",
            "",
            "            image_root = server_elem.find('{0}image'.format(NS))",
            "            self.assertEqual(image_root.get('id'), server_dict['image']['id'])",
            "            link_nodes = image_root.findall('{0}link'.format(ATOMNS))",
            "            self.assertEqual(len(link_nodes), 1)",
            "            for i, link in enumerate(server_dict['image']['links']):",
            "                for key, value in link.items():",
            "                    self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "            flavor_root = server_elem.find('{0}flavor'.format(NS))",
            "            self.assertEqual(flavor_root.get('id'),",
            "                             server_dict['flavor']['id'])",
            "            link_nodes = flavor_root.findall('{0}link'.format(ATOMNS))",
            "            self.assertEqual(len(link_nodes), 1)",
            "            for i, link in enumerate(server_dict['flavor']['links']):",
            "                for key, value in link.items():",
            "                    self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "            addresses_root = server_elem.find('{0}addresses'.format(NS))",
            "            addresses_dict = server_dict['addresses']",
            "            network_elems = addresses_root.findall('{0}network'.format(NS))",
            "            for i, network_elem in enumerate(network_elems):",
            "                network = addresses_dict.items()[i]",
            "                self.assertEqual(str(network_elem.get('id')), str(network[0]))",
            "                ip_elems = network_elem.findall('{0}ip'.format(NS))",
            "                for z, ip_elem in enumerate(ip_elems):",
            "                    ip = network[1][z]",
            "                    self.assertEqual(str(ip_elem.get('version')),",
            "                                     str(ip['version']))",
            "                    self.assertEqual(str(ip_elem.get('addr')),",
            "                                     str(ip['addr']))",
            "                    self.assertEqual(str(ip_elem.get('type')),",
            "                                 str(ip['type']))",
            "                self.assertEqual(str(ip_elem.get('mac_addr')),",
            "                                 str(ip['mac_addr']))",
            "",
            "    def test_update(self):",
            "        serializer = servers.ServerTemplate()",
            "",
            "        fixture = {",
            "            \"server\": {",
            "                \"id\": FAKE_UUID,",
            "                \"user_id\": \"fake\",",
            "                \"tenant_id\": \"fake\",",
            "                'created': self.TIMESTAMP,",
            "                'updated': self.TIMESTAMP,",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"host_id\": 'e4d909c290d0fb1ca068ffaddf22cbd0',",
            "                \"access_ip_v4\": \"1.2.3.4\",",
            "                \"access_ip_v6\": \"fead::1234\",",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.IMAGE_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.FLAVOR_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    \"network_one\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                    ],",
            "                    \"network_two\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.139\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.139\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                    ],",
            "                },",
            "                \"metadata\": {",
            "                    \"Open\": \"Stack\",",
            "                    \"Number\": \"1\",",
            "                },",
            "                'links': [",
            "                    {",
            "                        'href': self.SERVER_HREF,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': self.SERVER_BOOKMARK,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "                \"fault\": {",
            "                    \"code\": 500,",
            "                    \"created\": self.TIMESTAMP,",
            "                    \"message\": \"Error Message\",",
            "                    \"details\": \"Fault details\",",
            "                }",
            "            }",
            "        }",
            "",
            "        output = serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'server', version='v3')",
            "",
            "        server_dict = fixture['server']",
            "",
            "        for key in ['name', 'id', 'created', 'access_ip_v4',",
            "                    'updated', 'progress', 'status', 'host_id',",
            "                    'access_ip_v6']:",
            "            self.assertEqual(root.get(key), str(server_dict[key]))",
            "",
            "        link_nodes = root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 2)",
            "        for i, link in enumerate(server_dict['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        metadata_root = root.find('{0}metadata'.format(NS))",
            "        metadata_elems = metadata_root.findall('{0}meta'.format(NS))",
            "        self.assertEqual(len(metadata_elems), 2)",
            "        for i, metadata_elem in enumerate(metadata_elems):",
            "            (meta_key, meta_value) = server_dict['metadata'].items()[i]",
            "            self.assertEqual(str(metadata_elem.get('key')), str(meta_key))",
            "            self.assertEqual(str(metadata_elem.text).strip(), str(meta_value))",
            "",
            "        image_root = root.find('{0}image'.format(NS))",
            "        self.assertEqual(image_root.get('id'), server_dict['image']['id'])",
            "        link_nodes = image_root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 1)",
            "        for i, link in enumerate(server_dict['image']['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        flavor_root = root.find('{0}flavor'.format(NS))",
            "        self.assertEqual(flavor_root.get('id'), server_dict['flavor']['id'])",
            "        link_nodes = flavor_root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 1)",
            "        for i, link in enumerate(server_dict['flavor']['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        addresses_root = root.find('{0}addresses'.format(NS))",
            "        addresses_dict = server_dict['addresses']",
            "        network_elems = addresses_root.findall('{0}network'.format(NS))",
            "        self.assertEqual(len(network_elems), 2)",
            "        for i, network_elem in enumerate(network_elems):",
            "            network = addresses_dict.items()[i]",
            "            self.assertEqual(str(network_elem.get('id')), str(network[0]))",
            "            ip_elems = network_elem.findall('{0}ip'.format(NS))",
            "            for z, ip_elem in enumerate(ip_elems):",
            "                ip = network[1][z]",
            "                self.assertEqual(str(ip_elem.get('version')),",
            "                                 str(ip['version']))",
            "                self.assertEqual(str(ip_elem.get('addr')),",
            "                                 str(ip['addr']))",
            "                self.assertEqual(str(ip_elem.get('type')),",
            "                                 str(ip['type']))",
            "                self.assertEqual(str(ip_elem.get('mac_addr')),",
            "                                 str(ip['mac_addr']))",
            "",
            "        fault_root = root.find('{0}fault'.format(NS))",
            "        fault_dict = server_dict['fault']",
            "        self.assertEqual(fault_root.get(\"code\"), str(fault_dict[\"code\"]))",
            "        self.assertEqual(fault_root.get(\"created\"), fault_dict[\"created\"])",
            "        msg_elem = fault_root.find('{0}message'.format(NS))",
            "        self.assertEqual(msg_elem.text, fault_dict[\"message\"])",
            "        det_elem = fault_root.find('{0}details'.format(NS))",
            "        self.assertEqual(det_elem.text, fault_dict[\"details\"])",
            "",
            "    def test_action(self):",
            "        serializer = servers.FullServerTemplate()",
            "",
            "        fixture = {",
            "            \"server\": {",
            "                \"id\": FAKE_UUID,",
            "                \"user_id\": \"fake\",",
            "                \"tenant_id\": \"fake\",",
            "                'created': self.TIMESTAMP,",
            "                'updated': self.TIMESTAMP,",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"access_ip_v4\": \"1.2.3.4\",",
            "                \"access_ip_v6\": \"fead::1234\",",
            "                \"host_id\": \"e4d909c290d0fb1ca068ffaddf22cbd0\",",
            "                \"admin_pass\": \"test_password\",",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.IMAGE_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.FLAVOR_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    \"network_one\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.138\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                    ],",
            "                    \"network_two\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.139\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.139\",",
            "                            \"type\": \"fixed\",",
            "                            \"mac_addr\": \"aa:aa:aa:aa:aa:aa\"",
            "                        },",
            "                    ],",
            "                },",
            "                \"metadata\": {",
            "                    \"Open\": \"Stack\",",
            "                    \"Number\": \"1\",",
            "                },",
            "                'links': [",
            "                    {",
            "                        'href': self.SERVER_HREF,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': self.SERVER_BOOKMARK,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        output = serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'server', version='v3')",
            "",
            "        server_dict = fixture['server']",
            "",
            "        for key in ['name', 'id', 'created', 'access_ip_v4',",
            "                    'updated', 'progress', 'status', 'host_id',",
            "                    'access_ip_v6', 'admin_pass']:",
            "            self.assertEqual(root.get(key), str(server_dict[key]))",
            "",
            "        link_nodes = root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 2)",
            "        for i, link in enumerate(server_dict['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        metadata_root = root.find('{0}metadata'.format(NS))",
            "        metadata_elems = metadata_root.findall('{0}meta'.format(NS))",
            "        self.assertEqual(len(metadata_elems), 2)",
            "        for i, metadata_elem in enumerate(metadata_elems):",
            "            (meta_key, meta_value) = server_dict['metadata'].items()[i]",
            "            self.assertEqual(str(metadata_elem.get('key')), str(meta_key))",
            "            self.assertEqual(str(metadata_elem.text).strip(), str(meta_value))",
            "",
            "        image_root = root.find('{0}image'.format(NS))",
            "        self.assertEqual(image_root.get('id'), server_dict['image']['id'])",
            "        link_nodes = image_root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 1)",
            "        for i, link in enumerate(server_dict['image']['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        flavor_root = root.find('{0}flavor'.format(NS))",
            "        self.assertEqual(flavor_root.get('id'), server_dict['flavor']['id'])",
            "        link_nodes = flavor_root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 1)",
            "        for i, link in enumerate(server_dict['flavor']['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        addresses_root = root.find('{0}addresses'.format(NS))",
            "        addresses_dict = server_dict['addresses']",
            "        network_elems = addresses_root.findall('{0}network'.format(NS))",
            "        self.assertEqual(len(network_elems), 2)",
            "        for i, network_elem in enumerate(network_elems):",
            "            network = addresses_dict.items()[i]",
            "            self.assertEqual(str(network_elem.get('id')), str(network[0]))",
            "            ip_elems = network_elem.findall('{0}ip'.format(NS))",
            "            for z, ip_elem in enumerate(ip_elems):",
            "                ip = network[1][z]",
            "                self.assertEqual(str(ip_elem.get('version')),",
            "                                 str(ip['version']))",
            "                self.assertEqual(str(ip_elem.get('addr')),",
            "                                 str(ip['addr']))",
            "                self.assertEqual(str(ip_elem.get('type')),",
            "                                 str(ip['type']))",
            "                self.assertEqual(str(ip_elem.get('mac_addr')),",
            "                                 str(ip['mac_addr']))",
            "",
            "",
            "class ServersAllExtensionsTestCase(test.TestCase):",
            "    \"\"\"",
            "    Servers tests using default API router with all extensions enabled.",
            "",
            "    The intent here is to catch cases where extensions end up throwing",
            "    an exception because of a malformed request before the core API",
            "    gets a chance to validate the request and return a 422 response.",
            "",
            "    For example, ServerDiskConfigController extends servers.Controller:",
            "",
            "      @wsgi.extends",
            "      def create(self, req, body):",
            "          if 'server' in body:",
            "                self._set_disk_config(body['server'])",
            "          resp_obj = (yield)",
            "          self._show(req, resp_obj)",
            "",
            "    we want to ensure that the extension isn't barfing on an invalid",
            "    body.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        super(ServersAllExtensionsTestCase, self).setUp()",
            "        self.app = compute.APIRouterV3()",
            "",
            "    def test_create_missing_server(self):",
            "        # Test create with malformed body.",
            "",
            "        def fake_create(*args, **kwargs):",
            "            raise test.TestingException(\"Should not reach the compute API.\")",
            "",
            "        self.stubs.Set(compute_api.API, 'create', fake_create)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers')",
            "        req.method = 'POST'",
            "        req.content_type = 'application/json'",
            "        body = {'foo': {'a': 'b'}}",
            "",
            "        req.body = jsonutils.dumps(body)",
            "        res = req.get_response(self.app)",
            "        self.assertEqual(422, res.status_int)",
            "",
            "    def test_update_missing_server(self):",
            "        # Test create with malformed body.",
            "",
            "        def fake_update(*args, **kwargs):",
            "            raise test.TestingException(\"Should not reach the compute API.\")",
            "",
            "        self.stubs.Set(compute_api.API, 'create', fake_update)",
            "",
            "        req = fakes.HTTPRequestV3.blank('/servers/1')",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        body = {'foo': {'a': 'b'}}",
            "",
            "        req.body = jsonutils.dumps(body)",
            "        res = req.get_response(self.app)",
            "        self.assertEqual(422, res.status_int)",
            "",
            "",
            "class ServersUnprocessableEntityTestCase(test.TestCase):",
            "    \"\"\"",
            "    Tests of places we throw 422 Unprocessable Entity from",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        super(ServersUnprocessableEntityTestCase, self).setUp()",
            "        ext_info = plugins.LoadedExtensionInfo()",
            "        self.controller = servers.ServersController(extension_info=ext_info)",
            "",
            "    def _unprocessable_server_create(self, body):",
            "        req = fakes.HTTPRequestV3.blank('/servers')",
            "        req.method = 'POST'",
            "",
            "        self.assertRaises(webob.exc.HTTPUnprocessableEntity,",
            "                          self.controller.create, req, body)",
            "",
            "    def test_create_server_no_body(self):",
            "        self._unprocessable_server_create(body=None)",
            "",
            "    def test_create_server_missing_server(self):",
            "        body = {'foo': {'a': 'b'}}",
            "        self._unprocessable_server_create(body=body)",
            "",
            "    def test_create_server_malformed_entity(self):",
            "        body = {'server': 'string'}",
            "        self._unprocessable_server_create(body=body)",
            "",
            "    def _unprocessable_server_update(self, body):",
            "        req = fakes.HTTPRequestV3.blank('/servers/%s' % FAKE_UUID)",
            "        req.method = 'PUT'",
            "",
            "        self.assertRaises(webob.exc.HTTPUnprocessableEntity,",
            "                          self.controller.update, req, FAKE_UUID, body)",
            "",
            "    def test_update_server_no_body(self):",
            "        self._unprocessable_server_update(body=None)",
            "",
            "    def test_update_server_missing_server(self):",
            "        body = {'foo': {'a': 'b'}}",
            "        self._unprocessable_server_update(body=body)",
            "",
            "    def test_create_update_malformed_entity(self):",
            "        body = {'server': 'string'}",
            "        self._unprocessable_server_update(body=body)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1803": [
                "ServersControllerCreateTest",
                "_test_create_instance"
            ],
            "1806": [
                "ServersControllerCreateTest",
                "_test_create_instance"
            ]
        },
        "addLocation": []
    },
    "nova/tests/api/openstack/compute/test_servers.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1735,
                "afterPatchRowNumber": 1735,
                "PatchRowcode": "         \"\"\"utility function - check server_dict for absence of adminPass.\"\"\""
            },
            "1": {
                "beforePatchRowNumber": 1736,
                "afterPatchRowNumber": 1736,
                "PatchRowcode": "         self.assertTrue(\"adminPass\" not in server_dict)"
            },
            "2": {
                "beforePatchRowNumber": 1737,
                "afterPatchRowNumber": 1737,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 1738,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _test_create_instance(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1738,
                "PatchRowcode": "+    def _test_create_instance(self, flavor=2):"
            },
            "5": {
                "beforePatchRowNumber": 1739,
                "afterPatchRowNumber": 1739,
                "PatchRowcode": "         image_uuid = 'c905cedb-7281-47e4-8a62-f26bc5fc4c77'"
            },
            "6": {
                "beforePatchRowNumber": 1740,
                "afterPatchRowNumber": 1740,
                "PatchRowcode": "         self.body['server']['imageRef'] = image_uuid"
            },
            "7": {
                "beforePatchRowNumber": 1741,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.body['server']['flavorRef'] = 2"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1741,
                "PatchRowcode": "+        self.body['server']['flavorRef'] = flavor"
            },
            "9": {
                "beforePatchRowNumber": 1742,
                "afterPatchRowNumber": 1742,
                "PatchRowcode": "         self.req.body = jsonutils.dumps(self.body)"
            },
            "10": {
                "beforePatchRowNumber": 1743,
                "afterPatchRowNumber": 1743,
                "PatchRowcode": "         server = self.controller.create(self.req, self.body).obj['server']"
            },
            "11": {
                "beforePatchRowNumber": 1744,
                "afterPatchRowNumber": 1744,
                "PatchRowcode": "         self._check_admin_pass_len(server)"
            },
            "12": {
                "beforePatchRowNumber": 1745,
                "afterPatchRowNumber": 1745,
                "PatchRowcode": "         self.assertEqual(FAKE_UUID, server['id'])"
            },
            "13": {
                "beforePatchRowNumber": 1746,
                "afterPatchRowNumber": 1746,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1747,
                "PatchRowcode": "+    def test_create_instance_private_flavor(self):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1748,
                "PatchRowcode": "+        values = {"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1749,
                "PatchRowcode": "+            'name': 'fake_name',"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1750,
                "PatchRowcode": "+            'memory_mb': 512,"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1751,
                "PatchRowcode": "+            'vcpus': 1,"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1752,
                "PatchRowcode": "+            'root_gb': 10,"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1753,
                "PatchRowcode": "+            'ephemeral_gb': 10,"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1754,
                "PatchRowcode": "+            'flavorid': '1324',"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1755,
                "PatchRowcode": "+            'swap': 0,"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1756,
                "PatchRowcode": "+            'rxtx_factor': 0.5,"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1757,
                "PatchRowcode": "+            'vcpu_weight': 1,"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1758,
                "PatchRowcode": "+            'disabled': False,"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1759,
                "PatchRowcode": "+            'is_public': False,"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1760,
                "PatchRowcode": "+        }"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1761,
                "PatchRowcode": "+        db.flavor_create(context.get_admin_context(), values)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1762,
                "PatchRowcode": "+        self.assertRaises(webob.exc.HTTPBadRequest, self._test_create_instance,"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1763,
                "PatchRowcode": "+                          flavor=1324)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1764,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": 1747,
                "afterPatchRowNumber": 1765,
                "PatchRowcode": "     def test_create_server_bad_image_href(self):"
            },
            "33": {
                "beforePatchRowNumber": 1748,
                "afterPatchRowNumber": 1766,
                "PatchRowcode": "         image_href = 1"
            },
            "34": {
                "beforePatchRowNumber": 1749,
                "afterPatchRowNumber": 1767,
                "PatchRowcode": "         self.body['server']['imageRef'] = image_href,"
            }
        },
        "frontPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2010-2011 OpenStack Foundation",
            "# Copyright 2011 Piston Cloud Computing, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import base64",
            "import datetime",
            "import testtools",
            "import urlparse",
            "import uuid",
            "",
            "import iso8601",
            "from lxml import etree",
            "import mox",
            "from oslo.config import cfg",
            "import webob",
            "",
            "from nova.api.openstack import compute",
            "from nova.api.openstack.compute import ips",
            "from nova.api.openstack.compute import servers",
            "from nova.api.openstack.compute import views",
            "from nova.api.openstack import extensions",
            "from nova.api.openstack import xmlutil",
            "from nova import block_device",
            "from nova.compute import api as compute_api",
            "from nova.compute import flavors",
            "from nova.compute import task_states",
            "from nova.compute import vm_states",
            "from nova import context",
            "from nova import db",
            "from nova.db.sqlalchemy import models",
            "from nova import exception",
            "from nova.image import glance",
            "from nova.network import manager",
            "from nova.network.neutronv2 import api as neutron_api",
            "from nova.objects import instance as instance_obj",
            "from nova.openstack.common.gettextutils import _",
            "from nova.openstack.common import jsonutils",
            "from nova.openstack.common import policy as common_policy",
            "from nova.openstack.common import rpc",
            "from nova import policy",
            "from nova import test",
            "from nova.tests.api.openstack import fakes",
            "from nova.tests import fake_instance",
            "from nova.tests import fake_network",
            "from nova.tests.image import fake",
            "from nova.tests import matchers",
            "from nova.tests import utils",
            "",
            "CONF = cfg.CONF",
            "CONF.import_opt('password_length', 'nova.utils')",
            "CONF.import_opt('scheduler_topic', 'nova.scheduler.rpcapi')",
            "",
            "FAKE_UUID = fakes.FAKE_UUID",
            "NS = \"{http://docs.openstack.org/compute/api/v1.1}\"",
            "ATOMNS = \"{http://www.w3.org/2005/Atom}\"",
            "XPATH_NS = {",
            "    'atom': 'http://www.w3.org/2005/Atom',",
            "    'ns': 'http://docs.openstack.org/compute/api/v1.1'",
            "}",
            "",
            "INSTANCE_IDS = {FAKE_UUID: 1}",
            "",
            "FIELDS = instance_obj.INSTANCE_DEFAULT_FIELDS",
            "",
            "",
            "def fake_gen_uuid():",
            "    return FAKE_UUID",
            "",
            "",
            "def return_servers_empty(context, *args, **kwargs):",
            "    return []",
            "",
            "",
            "def return_security_group(context, instance_id, security_group_id):",
            "    pass",
            "",
            "",
            "def instance_update(context, instance_uuid, values, update_cells=True):",
            "    inst = fakes.stub_instance(INSTANCE_IDS.get(instance_uuid),",
            "                               name=values.get('display_name'))",
            "    inst = dict(inst, **values)",
            "    return (inst, inst)",
            "",
            "",
            "def fake_compute_api(cls, req, id):",
            "    return True",
            "",
            "",
            "class MockSetAdminPassword(object):",
            "    def __init__(self):",
            "        self.instance_id = None",
            "        self.password = None",
            "",
            "    def __call__(self, context, instance_id, password):",
            "        self.instance_id = instance_id",
            "        self.password = password",
            "",
            "",
            "class Base64ValidationTest(test.TestCase):",
            "    def setUp(self):",
            "        super(Base64ValidationTest, self).setUp()",
            "        self.ext_mgr = extensions.ExtensionManager()",
            "        self.ext_mgr.extensions = {}",
            "        self.controller = servers.Controller(self.ext_mgr)",
            "",
            "    def test_decode_base64(self):",
            "        value = \"A random string\"",
            "        result = self.controller._decode_base64(base64.b64encode(value))",
            "        self.assertEqual(result, value)",
            "",
            "    def test_decode_base64_binary(self):",
            "        value = \"\\x00\\x12\\x75\\x99\"",
            "        result = self.controller._decode_base64(base64.b64encode(value))",
            "        self.assertEqual(result, value)",
            "",
            "    def test_decode_base64_whitespace(self):",
            "        value = \"A random string\"",
            "        encoded = base64.b64encode(value)",
            "        white = \"\\n \\n%s\\t%s\\n\" % (encoded[:2], encoded[2:])",
            "        result = self.controller._decode_base64(white)",
            "        self.assertEqual(result, value)",
            "",
            "    def test_decode_base64_invalid(self):",
            "        invalid = \"A random string\"",
            "        result = self.controller._decode_base64(invalid)",
            "        self.assertEqual(result, None)",
            "",
            "    def test_decode_base64_illegal_bytes(self):",
            "        value = \"A random string\"",
            "        encoded = base64.b64encode(value)",
            "        white = \">\\x01%s*%s()\" % (encoded[:2], encoded[2:])",
            "        result = self.controller._decode_base64(white)",
            "        self.assertEqual(result, None)",
            "",
            "",
            "class NeutronV2Subclass(neutron_api.API):",
            "    \"\"\"Used to ensure that API handles subclasses properly.\"\"\"",
            "    pass",
            "",
            "",
            "class ControllerTest(test.TestCase):",
            "",
            "    def setUp(self):",
            "        super(ControllerTest, self).setUp()",
            "        self.flags(verbose=True, use_ipv6=False)",
            "        fakes.stub_out_rate_limiting(self.stubs)",
            "        fakes.stub_out_key_pair_funcs(self.stubs)",
            "        fake.stub_out_image_service(self.stubs)",
            "        return_server = fakes.fake_instance_get()",
            "        return_servers = fakes.fake_instance_get_all_by_filters()",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       return_servers)",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                       return_server)",
            "        self.stubs.Set(db, 'instance_add_security_group',",
            "                       return_security_group)",
            "        self.stubs.Set(db, 'instance_update_and_get_original',",
            "                       instance_update)",
            "",
            "        self.ext_mgr = extensions.ExtensionManager()",
            "        self.ext_mgr.extensions = {}",
            "        self.controller = servers.Controller(self.ext_mgr)",
            "        self.ips_controller = ips.Controller()",
            "        policy.reset()",
            "        policy.init()",
            "        fake_network.stub_out_nw_api_get_instance_nw_info(self.stubs,",
            "                                                          spectacular=True)",
            "",
            "",
            "class ServersControllerTest(ControllerTest):",
            "",
            "    def test_can_check_loaded_extensions(self):",
            "        self.ext_mgr.extensions = {'os-fake': None}",
            "        self.assertTrue(self.controller.ext_mgr.is_loaded('os-fake'))",
            "        self.assertFalse(self.controller.ext_mgr.is_loaded('os-not-loaded'))",
            "",
            "    def test_requested_networks_prefix(self):",
            "        uuid = 'br-00000000-0000-0000-0000-000000000000'",
            "        requested_networks = [{'uuid': uuid}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertTrue((uuid, None) in res)",
            "",
            "    def test_requested_networks_neutronv2_enabled_with_port(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'port': port}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertEquals(res, [(None, None, port)])",
            "",
            "    def test_requested_networks_neutronv2_enabled_with_network(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        network = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        requested_networks = [{'uuid': network}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertEquals(res, [(network, None, None)])",
            "",
            "    def test_requested_networks_neutronv2_enabled_with_network_and_port(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        network = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'uuid': network, 'port': port}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertEquals(res, [(None, None, port)])",
            "",
            "    def test_requested_networks_neutronv2_disabled_with_port(self):",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'port': port}]",
            "        self.assertRaises(",
            "            webob.exc.HTTPBadRequest,",
            "            self.controller._get_requested_networks,",
            "            requested_networks)",
            "",
            "    def test_requested_networks_api_enabled_with_v2_subclass(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        network = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'uuid': network, 'port': port}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertEquals(res, [(None, None, port)])",
            "",
            "    def test_requested_networks_neutronv2_subclass_with_port(self):",
            "        cls = 'nova.tests.api.openstack.compute.test_servers.NeutronV2Subclass'",
            "        self.flags(network_api_class=cls)",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'port': port}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertEquals(res, [(None, None, port)])",
            "",
            "    def test_get_server_by_uuid(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers/%s' % FAKE_UUID)",
            "        res_dict = self.controller.show(req, FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "",
            "    def test_unique_host_id(self):",
            "        \"\"\"Create two servers with the same host and different",
            "           project_ids and check that the hostId's are unique.",
            "        \"\"\"",
            "        def return_instance_with_host(self, *args, **kwargs):",
            "            project_id = str(uuid.uuid4())",
            "            return fakes.stub_instance(id=1, uuid=FAKE_UUID,",
            "                                       project_id=project_id,",
            "                                       host='fake_host')",
            "",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                       return_instance_with_host)",
            "        self.stubs.Set(db, 'instance_get',",
            "                       return_instance_with_host)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers/%s' % FAKE_UUID)",
            "        server1 = self.controller.show(req, FAKE_UUID)",
            "        server2 = self.controller.show(req, FAKE_UUID)",
            "",
            "        self.assertNotEqual(server1['server']['hostId'],",
            "                            server2['server']['hostId'])",
            "",
            "    def test_get_server_by_id(self):",
            "        self.flags(use_ipv6=True)",
            "        image_bookmark = \"http://localhost/fake/images/10\"",
            "        flavor_bookmark = \"http://localhost/fake/flavors/1\"",
            "",
            "        uuid = FAKE_UUID",
            "        req = fakes.HTTPRequest.blank('/fake/servers/%s' % uuid)",
            "        res_dict = self.controller.show(req, uuid)",
            "",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 0,",
            "                \"name\": \"server1\",",
            "                \"status\": \"BUILD\",",
            "                \"accessIPv4\": \"\",",
            "                \"accessIPv6\": \"\",",
            "                \"hostId\": '',",
            "                \"image\": {",
            "                    \"id\": \"10\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                  \"links\": [",
            "                                            {",
            "                          \"rel\": \"bookmark\",",
            "                          \"href\": flavor_bookmark,",
            "                      },",
            "                  ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1'}",
            "                    ]",
            "                },",
            "                \"metadata\": {",
            "                    \"seq\": \"1\",",
            "                },",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": \"http://localhost/v2/fake/servers/%s\" % uuid,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": \"http://localhost/fake/servers/%s\" % uuid,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        self.assertThat(res_dict, matchers.DictMatches(expected_server))",
            "",
            "    def test_get_server_with_active_status_by_id(self):",
            "        image_bookmark = \"http://localhost/fake/images/10\"",
            "        flavor_bookmark = \"http://localhost/fake/flavors/1\"",
            "",
            "        new_return_server = fakes.fake_instance_get(",
            "                vm_state=vm_states.ACTIVE, progress=100)",
            "        self.stubs.Set(db, 'instance_get_by_uuid', new_return_server)",
            "",
            "        uuid = FAKE_UUID",
            "        req = fakes.HTTPRequest.blank('/fake/servers/%s' % uuid)",
            "        res_dict = self.controller.show(req, uuid)",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 100,",
            "                \"name\": \"server1\",",
            "                \"status\": \"ACTIVE\",",
            "                \"accessIPv4\": \"\",",
            "                \"accessIPv6\": \"\",",
            "                \"hostId\": '',",
            "                \"image\": {",
            "                    \"id\": \"10\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                  \"links\": [",
            "                      {",
            "                          \"rel\": \"bookmark\",",
            "                          \"href\": flavor_bookmark,",
            "                      },",
            "                  ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1'}",
            "                    ]",
            "                },",
            "                \"metadata\": {",
            "                    \"seq\": \"1\",",
            "                },",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": \"http://localhost/v2/fake/servers/%s\" % uuid,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": \"http://localhost/fake/servers/%s\" % uuid,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        self.assertThat(res_dict, matchers.DictMatches(expected_server))",
            "",
            "    def test_get_server_with_id_image_ref_by_id(self):",
            "        image_ref = \"10\"",
            "        image_bookmark = \"http://localhost/fake/images/10\"",
            "        flavor_id = \"1\"",
            "        flavor_bookmark = \"http://localhost/fake/flavors/1\"",
            "",
            "        new_return_server = fakes.fake_instance_get(",
            "                vm_state=vm_states.ACTIVE, image_ref=image_ref,",
            "                flavor_id=flavor_id, progress=100)",
            "        self.stubs.Set(db, 'instance_get_by_uuid', new_return_server)",
            "",
            "        uuid = FAKE_UUID",
            "        req = fakes.HTTPRequest.blank('/fake/servers/%s' % uuid)",
            "        res_dict = self.controller.show(req, uuid)",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 100,",
            "                \"name\": \"server1\",",
            "                \"status\": \"ACTIVE\",",
            "                \"accessIPv4\": \"\",",
            "                \"accessIPv6\": \"\",",
            "                \"hostId\": '',",
            "                \"image\": {",
            "                    \"id\": \"10\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                  \"links\": [",
            "                      {",
            "                          \"rel\": \"bookmark\",",
            "                          \"href\": flavor_bookmark,",
            "                      },",
            "                  ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1'}",
            "                    ]",
            "                },",
            "                \"metadata\": {",
            "                    \"seq\": \"1\",",
            "                },",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": \"http://localhost/v2/fake/servers/%s\" % uuid,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": \"http://localhost/fake/servers/%s\" % uuid,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        self.assertThat(res_dict, matchers.DictMatches(expected_server))",
            "",
            "    def test_get_server_addresses_from_cache(self):",
            "        pub0 = ('172.19.0.1', '172.19.0.2',)",
            "        pub1 = ('1.2.3.4',)",
            "        pub2 = ('b33f::fdee:ddff:fecc:bbaa',)",
            "        priv0 = ('192.168.0.3', '192.168.0.4',)",
            "",
            "        def _ip(ip):",
            "            return {'address': ip, 'type': 'fixed'}",
            "",
            "        nw_cache = [",
            "            {'address': 'aa:aa:aa:aa:aa:aa',",
            "             'id': 1,",
            "             'network': {'bridge': 'br0',",
            "                         'id': 1,",
            "                         'label': 'public',",
            "                         'subnets': [{'cidr': '172.19.0.0/24',",
            "                                      'ips': [_ip(ip) for ip in pub0]},",
            "                                      {'cidr': '1.2.3.0/16',",
            "                                       'ips': [_ip(ip) for ip in pub1]},",
            "                                      {'cidr': 'b33f::/64',",
            "                                       'ips': [_ip(ip) for ip in pub2]}]}},",
            "            {'address': 'bb:bb:bb:bb:bb:bb',",
            "             'id': 2,",
            "             'network': {'bridge': 'br1',",
            "                         'id': 2,",
            "                         'label': 'private',",
            "                         'subnets': [{'cidr': '192.168.0.0/24',",
            "                                      'ips': [_ip(ip) for ip in priv0]}]}}]",
            "",
            "        return_server = fakes.fake_instance_get(nw_cache=nw_cache)",
            "        self.stubs.Set(db, 'instance_get_by_uuid', return_server)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers/%s/ips' % FAKE_UUID)",
            "        res_dict = self.ips_controller.index(req, FAKE_UUID)",
            "",
            "        expected = {",
            "            'addresses': {",
            "                'private': [",
            "                    {'version': 4, 'addr': '192.168.0.3'},",
            "                    {'version': 4, 'addr': '192.168.0.4'},",
            "                ],",
            "                'public': [",
            "                    {'version': 4, 'addr': '172.19.0.1'},",
            "                    {'version': 4, 'addr': '172.19.0.2'},",
            "                    {'version': 4, 'addr': '1.2.3.4'},",
            "                    {'version': 6, 'addr': 'b33f::fdee:ddff:fecc:bbaa'},",
            "                ],",
            "            },",
            "        }",
            "        self.assertThat(res_dict, matchers.DictMatches(expected))",
            "",
            "    def test_get_server_addresses_nonexistent_network(self):",
            "        url = '/fake/servers/%s/ips/network_0' % FAKE_UUID",
            "        req = fakes.HTTPRequest.blank(url)",
            "        self.assertRaises(webob.exc.HTTPNotFound, self.ips_controller.show,",
            "                          req, FAKE_UUID, 'network_0')",
            "",
            "    def test_get_server_addresses_nonexistent_server(self):",
            "        def fake_instance_get(*args, **kwargs):",
            "            raise exception.InstanceNotFound(instance_id='fake')",
            "",
            "        self.stubs.Set(db, 'instance_get_by_uuid', fake_instance_get)",
            "",
            "        server_id = str(uuid.uuid4())",
            "        req = fakes.HTTPRequest.blank('/fake/servers/%s/ips' % server_id)",
            "        self.assertRaises(webob.exc.HTTPNotFound,",
            "                          self.ips_controller.index, req, server_id)",
            "",
            "    def test_get_server_list_empty(self):",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       return_servers_empty)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers')",
            "        res_dict = self.controller.index(req)",
            "",
            "        num_servers = len(res_dict['servers'])",
            "        self.assertEqual(0, num_servers)",
            "",
            "    def test_get_server_list_with_reservation_id(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers?reservation_id=foo')",
            "        res_dict = self.controller.index(req)",
            "",
            "        i = 0",
            "        for s in res_dict['servers']:",
            "            self.assertEqual(s.get('name'), 'server%d' % (i + 1))",
            "            i += 1",
            "",
            "    def test_get_server_list_with_reservation_id_empty(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers/detail?'",
            "                                      'reservation_id=foo')",
            "        res_dict = self.controller.detail(req)",
            "",
            "        i = 0",
            "        for s in res_dict['servers']:",
            "            self.assertEqual(s.get('name'), 'server%d' % (i + 1))",
            "            i += 1",
            "",
            "    def test_get_server_list_with_reservation_id_details(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers/detail?'",
            "                                      'reservation_id=foo')",
            "        res_dict = self.controller.detail(req)",
            "",
            "        i = 0",
            "        for s in res_dict['servers']:",
            "            self.assertEqual(s.get('name'), 'server%d' % (i + 1))",
            "            i += 1",
            "",
            "    def test_get_server_list(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers')",
            "        res_dict = self.controller.index(req)",
            "",
            "        self.assertEqual(len(res_dict['servers']), 5)",
            "        for i, s in enumerate(res_dict['servers']):",
            "            self.assertEqual(s['id'], fakes.get_fake_uuid(i))",
            "            self.assertEqual(s['name'], 'server%d' % (i + 1))",
            "            self.assertEqual(s.get('image', None), None)",
            "",
            "            expected_links = [",
            "                {",
            "                    \"rel\": \"self\",",
            "                    \"href\": \"http://localhost/v2/fake/servers/%s\" % s['id'],",
            "                },",
            "                {",
            "                    \"rel\": \"bookmark\",",
            "                    \"href\": \"http://localhost/fake/servers/%s\" % s['id'],",
            "                },",
            "            ]",
            "",
            "            self.assertEqual(s['links'], expected_links)",
            "",
            "    def test_get_servers_with_limit(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers?limit=3')",
            "        res_dict = self.controller.index(req)",
            "",
            "        servers = res_dict['servers']",
            "        self.assertEqual([s['id'] for s in servers],",
            "                [fakes.get_fake_uuid(i) for i in xrange(len(servers))])",
            "",
            "        servers_links = res_dict['servers_links']",
            "        self.assertEqual(servers_links[0]['rel'], 'next')",
            "        href_parts = urlparse.urlparse(servers_links[0]['href'])",
            "        self.assertEqual('/v2/fake/servers', href_parts.path)",
            "        params = urlparse.parse_qs(href_parts.query)",
            "        expected_params = {'limit': ['3'],",
            "                           'marker': [fakes.get_fake_uuid(2)]}",
            "        self.assertThat(params, matchers.DictMatches(expected_params))",
            "",
            "    def test_get_servers_with_limit_bad_value(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers?limit=aaa')",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.index, req)",
            "",
            "    def test_get_server_details_empty(self):",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       return_servers_empty)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers/detail')",
            "        res_dict = self.controller.index(req)",
            "",
            "        num_servers = len(res_dict['servers'])",
            "        self.assertEqual(0, num_servers)",
            "",
            "    def test_get_server_details_with_limit(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers/detail?limit=3')",
            "        res = self.controller.detail(req)",
            "",
            "        servers = res['servers']",
            "        self.assertEqual([s['id'] for s in servers],",
            "                [fakes.get_fake_uuid(i) for i in xrange(len(servers))])",
            "",
            "        servers_links = res['servers_links']",
            "        self.assertEqual(servers_links[0]['rel'], 'next')",
            "",
            "        href_parts = urlparse.urlparse(servers_links[0]['href'])",
            "        self.assertEqual('/v2/fake/servers', href_parts.path)",
            "        params = urlparse.parse_qs(href_parts.query)",
            "        expected = {'limit': ['3'], 'marker': [fakes.get_fake_uuid(2)]}",
            "        self.assertThat(params, matchers.DictMatches(expected))",
            "",
            "    def test_get_server_details_with_limit_bad_value(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers/detail?limit=aaa')",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.detail, req)",
            "",
            "    def test_get_server_details_with_limit_and_other_params(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers/detail'",
            "                                      '?limit=3&blah=2:t')",
            "        res = self.controller.detail(req)",
            "",
            "        servers = res['servers']",
            "        self.assertEqual([s['id'] for s in servers],",
            "                [fakes.get_fake_uuid(i) for i in xrange(len(servers))])",
            "",
            "        servers_links = res['servers_links']",
            "        self.assertEqual(servers_links[0]['rel'], 'next')",
            "",
            "        href_parts = urlparse.urlparse(servers_links[0]['href'])",
            "        self.assertEqual('/v2/fake/servers', href_parts.path)",
            "        params = urlparse.parse_qs(href_parts.query)",
            "        expected = {'limit': ['3'], 'blah': ['2:t'],",
            "                    'marker': [fakes.get_fake_uuid(2)]}",
            "        self.assertThat(params, matchers.DictMatches(expected))",
            "",
            "    def test_get_servers_with_too_big_limit(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers?limit=30')",
            "        res_dict = self.controller.index(req)",
            "        self.assertTrue('servers_links' not in res_dict)",
            "",
            "    def test_get_servers_with_bad_limit(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers?limit=asdf')",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.index, req)",
            "",
            "    def test_get_servers_with_marker(self):",
            "        url = '/v2/fake/servers?marker=%s' % fakes.get_fake_uuid(2)",
            "        req = fakes.HTTPRequest.blank(url)",
            "        servers = self.controller.index(req)['servers']",
            "        self.assertEqual([s['name'] for s in servers], [\"server4\", \"server5\"])",
            "",
            "    def test_get_servers_with_limit_and_marker(self):",
            "        url = '/v2/fake/servers?limit=2&marker=%s' % fakes.get_fake_uuid(1)",
            "        req = fakes.HTTPRequest.blank(url)",
            "        servers = self.controller.index(req)['servers']",
            "        self.assertEqual([s['name'] for s in servers], ['server3', 'server4'])",
            "",
            "    def test_get_servers_with_bad_marker(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers?limit=2&marker=asdf')",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.index, req)",
            "",
            "    def test_get_servers_with_bad_option(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers?unknownoption=whee')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_allows_image(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('image' in search_opts)",
            "            self.assertEqual(search_opts['image'], '12345')",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers?image=12345')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_tenant_id_filter_converts_to_project_id_for_admin(self):",
            "        def fake_get_all(context, filters=None, sort_key=None,",
            "                         sort_dir='desc', limit=None, marker=None,",
            "                         columns_to_join=None):",
            "            self.assertNotEqual(filters, None)",
            "            self.assertEqual(filters['project_id'], 'fake')",
            "            self.assertFalse(filters.get('tenant_id'))",
            "            return [fakes.stub_instance(100)]",
            "",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       fake_get_all)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers?tenant_id=fake',",
            "                                      use_admin_context=True)",
            "        res = self.controller.index(req)",
            "",
            "        self.assertTrue('servers' in res)",
            "",
            "    def test_admin_restricted_tenant(self):",
            "        def fake_get_all(context, filters=None, sort_key=None,",
            "                         sort_dir='desc', limit=None, marker=None,",
            "                         columns_to_join=None):",
            "            self.assertNotEqual(filters, None)",
            "            self.assertEqual(filters['project_id'], 'fake')",
            "            return [fakes.stub_instance(100)]",
            "",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       fake_get_all)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers',",
            "                                      use_admin_context=True)",
            "        res = self.controller.index(req)",
            "",
            "        self.assertTrue('servers' in res)",
            "",
            "    def test_all_tenants_pass_policy(self):",
            "        def fake_get_all(context, filters=None, sort_key=None,",
            "                         sort_dir='desc', limit=None, marker=None,",
            "                         columns_to_join=None):",
            "            self.assertNotEqual(filters, None)",
            "            self.assertTrue('project_id' not in filters)",
            "            return [fakes.stub_instance(100)]",
            "",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       fake_get_all)",
            "",
            "        rules = {",
            "            \"compute:get_all_tenants\":",
            "                common_policy.parse_rule(\"project_id:fake\"),",
            "            \"compute:get_all\":",
            "                common_policy.parse_rule(\"project_id:fake\"),",
            "        }",
            "",
            "        common_policy.set_rules(common_policy.Rules(rules))",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers?all_tenants=1')",
            "        res = self.controller.index(req)",
            "",
            "        self.assertTrue('servers' in res)",
            "",
            "    def test_all_tenants_fail_policy(self):",
            "        def fake_get_all(context, filters=None, sort_key=None,",
            "                         sort_dir='desc', limit=None, marker=None,",
            "                         columns_to_join=None):",
            "            self.assertNotEqual(filters, None)",
            "            return [fakes.stub_instance(100)]",
            "",
            "        rules = {",
            "            \"compute:get_all_tenants\":",
            "                common_policy.parse_rule(\"project_id:non_fake\"),",
            "            \"compute:get_all\":",
            "                common_policy.parse_rule(\"project_id:fake\"),",
            "        }",
            "",
            "        common_policy.set_rules(common_policy.Rules(rules))",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       fake_get_all)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers?all_tenants=1')",
            "        self.assertRaises(exception.PolicyNotAuthorized,",
            "                          self.controller.index, req)",
            "",
            "    def test_get_servers_allows_flavor(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('flavor' in search_opts)",
            "            # flavor is an integer ID",
            "            self.assertEqual(search_opts['flavor'], '12345')",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers?flavor=12345')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_with_bad_flavor(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers?flavor=abcde')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 0)",
            "",
            "    def test_get_servers_allows_status(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('vm_state' in search_opts)",
            "            self.assertEqual(search_opts['vm_state'], vm_states.ACTIVE)",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers?status=active')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_invalid_status(self):",
            "        # Test getting servers by invalid status.",
            "        req = fakes.HTTPRequest.blank('/fake/servers?status=baloney',",
            "                                      use_admin_context=False)",
            "        servers = self.controller.index(req)['servers']",
            "        self.assertEqual(len(servers), 0)",
            "",
            "    def test_get_servers_deleted_status_as_user(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers?status=deleted',",
            "                                      use_admin_context=False)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.detail, req)",
            "",
            "    def test_get_servers_deleted_status_as_admin(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertTrue('vm_state' in search_opts)",
            "            self.assertEqual(search_opts['vm_state'], 'deleted')",
            "",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers?status=deleted',",
            "                                      use_admin_context=True)",
            "",
            "        servers = self.controller.detail(req)['servers']",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_allows_name(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('name' in search_opts)",
            "            self.assertEqual(search_opts['name'], 'whee.*')",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers?name=whee.*')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_allows_changes_since(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('changes-since' in search_opts)",
            "            changes_since = datetime.datetime(2011, 1, 24, 17, 8, 1,",
            "                                              tzinfo=iso8601.iso8601.UTC)",
            "            self.assertEqual(search_opts['changes-since'], changes_since)",
            "            self.assertTrue('deleted' not in search_opts)",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        params = 'changes-since=2011-01-24T17:08:01Z'",
            "        req = fakes.HTTPRequest.blank('/fake/servers?%s' % params)",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_allows_changes_since_bad_value(self):",
            "        params = 'changes-since=asdf'",
            "        req = fakes.HTTPRequest.blank('/fake/servers?%s' % params)",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.index, req)",
            "",
            "    def test_get_servers_admin_filters_as_user(self):",
            "        \"\"\"Test getting servers by admin-only or unknown options when",
            "        context is not admin. Make sure the admin and unknown options",
            "        are stripped before they get to compute_api.get_all()",
            "        \"\"\"",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            # Allowed by user",
            "            self.assertTrue('name' in search_opts)",
            "            self.assertTrue('ip' in search_opts)",
            "            # OSAPI converts status to vm_state",
            "            self.assertTrue('vm_state' in search_opts)",
            "            # Allowed only by admins with admin API on",
            "            self.assertFalse('unknown_option' in search_opts)",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        query_str = \"name=foo&ip=10.*&status=active&unknown_option=meow\"",
            "        req = fakes.HTTPRequest.blank('/fake/servers?%s' % query_str)",
            "        res = self.controller.index(req)",
            "",
            "        servers = res['servers']",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_admin_options_as_admin(self):",
            "        \"\"\"Test getting servers by admin-only or unknown options when",
            "        context is admin. All options should be passed",
            "        \"\"\"",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            # Allowed by user",
            "            self.assertTrue('name' in search_opts)",
            "            # OSAPI converts status to vm_state",
            "            self.assertTrue('vm_state' in search_opts)",
            "            # Allowed only by admins with admin API on",
            "            self.assertTrue('ip' in search_opts)",
            "            self.assertTrue('unknown_option' in search_opts)",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        query_str = \"name=foo&ip=10.*&status=active&unknown_option=meow\"",
            "        req = fakes.HTTPRequest.blank('/fake/servers?%s' % query_str,",
            "                                      use_admin_context=True)",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_allows_ip(self):",
            "        \"\"\"Test getting servers by ip.\"\"\"",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('ip' in search_opts)",
            "            self.assertEqual(search_opts['ip'], '10\\..*')",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers?ip=10\\..*')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_admin_allows_ip6(self):",
            "        \"\"\"Test getting servers by ip6 with admin_api enabled and",
            "        admin context",
            "        \"\"\"",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('ip6' in search_opts)",
            "            self.assertEqual(search_opts['ip6'], 'ffff.*')",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers?ip6=ffff.*',",
            "                                      use_admin_context=True)",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_all_server_details(self):",
            "        expected_flavor = {",
            "            \"id\": \"1\",",
            "            \"links\": [",
            "                {",
            "                    \"rel\": \"bookmark\",",
            "                    \"href\": 'http://localhost/fake/flavors/1',",
            "                },",
            "            ],",
            "        }",
            "        expected_image = {",
            "            \"id\": \"10\",",
            "            \"links\": [",
            "                {",
            "                    \"rel\": \"bookmark\",",
            "                    \"href\": 'http://localhost/fake/images/10',",
            "                },",
            "            ],",
            "        }",
            "        req = fakes.HTTPRequest.blank('/fake/servers/detail')",
            "        res_dict = self.controller.detail(req)",
            "",
            "        for i, s in enumerate(res_dict['servers']):",
            "            self.assertEqual(s['id'], fakes.get_fake_uuid(i))",
            "            self.assertEqual(s['hostId'], '')",
            "            self.assertEqual(s['name'], 'server%d' % (i + 1))",
            "            self.assertEqual(s['image'], expected_image)",
            "            self.assertEqual(s['flavor'], expected_flavor)",
            "            self.assertEqual(s['status'], 'BUILD')",
            "            self.assertEqual(s['metadata']['seq'], str(i + 1))",
            "",
            "    def test_get_all_server_details_with_host(self):",
            "        '''",
            "        We want to make sure that if two instances are on the same host, then",
            "        they return the same hostId. If two instances are on different hosts,",
            "        they should return different hostId's. In this test, there are 5",
            "        instances - 2 on one host and 3 on another.",
            "        '''",
            "",
            "        def return_servers_with_host(context, *args, **kwargs):",
            "            return [fakes.stub_instance(i + 1, 'fake', 'fake', host=i % 2,",
            "                                        uuid=fakes.get_fake_uuid(i))",
            "                    for i in xrange(5)]",
            "",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       return_servers_with_host)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers/detail')",
            "        res_dict = self.controller.detail(req)",
            "",
            "        server_list = res_dict['servers']",
            "        host_ids = [server_list[0]['hostId'], server_list[1]['hostId']]",
            "        self.assertTrue(host_ids[0] and host_ids[1])",
            "        self.assertNotEqual(host_ids[0], host_ids[1])",
            "",
            "        for i, s in enumerate(server_list):",
            "            self.assertEqual(s['id'], fakes.get_fake_uuid(i))",
            "            self.assertEqual(s['hostId'], host_ids[i % 2])",
            "            self.assertEqual(s['name'], 'server%d' % (i + 1))",
            "",
            "",
            "class ServersControllerUpdateTest(ControllerTest):",
            "",
            "    def _get_request(self, body=None, content_type='json', options=None):",
            "        if options:",
            "            self.stubs.Set(db, 'instance_get',",
            "                           fakes.fake_instance_get(**options))",
            "        req = fakes.HTTPRequest.blank('/fake/servers/%s' % FAKE_UUID)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/%s' % content_type",
            "        req.body = jsonutils.dumps(body)",
            "        return req",
            "",
            "    def test_update_server_all_attributes(self):",
            "        body = {'server': {",
            "                  'name': 'server_test',",
            "                  'accessIPv4': '0.0.0.0',",
            "                  'accessIPv6': 'beef::0123',",
            "               }}",
            "        req = self._get_request(body, {'name': 'server_test',",
            "                                       'access_ipv4': '0.0.0.0',",
            "                                       'access_ipv6': 'beef::0123'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['name'], 'server_test')",
            "        self.assertEqual(res_dict['server']['accessIPv4'], '0.0.0.0')",
            "        self.assertEqual(res_dict['server']['accessIPv6'], 'beef::123')",
            "",
            "    def test_update_server_invalid_xml_raises_lookup(self):",
            "        body = \"\"\"<?xml version=\"1.0\" encoding=\"TF-8\"?>",
            "            <metadata",
            "            xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "            key=\"Label\"></meta>\"\"\"",
            "        req = self._get_request(body, content_type='xml')",
            "        res = req.get_response(fakes.wsgi_app())",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_update_server_invalid_xml_raises_expat(self):",
            "        body = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "            <metadata",
            "            xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "            key=\"Label\"></meta>\"\"\"",
            "        req = self._get_request(body, content_type='xml')",
            "        res = req.get_response(fakes.wsgi_app())",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_update_server_name(self):",
            "        body = {'server': {'name': 'server_test'}}",
            "        req = self._get_request(body, {'name': 'server_test'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['name'], 'server_test')",
            "",
            "    def test_update_server_name_too_long(self):",
            "        body = {'server': {'name': 'x' * 256}}",
            "        req = self._get_request(body, {'name': 'server_test'})",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.update,",
            "                            req, FAKE_UUID, body)",
            "",
            "    def test_update_server_name_all_blank_spaces(self):",
            "        body = {'server': {'name': ' ' * 64}}",
            "        req = self._get_request(body, {'name': 'server_test'})",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.update,",
            "                          req, FAKE_UUID, body)",
            "",
            "    def test_update_server_access_ipv4(self):",
            "        body = {'server': {'accessIPv4': '0.0.0.0'}}",
            "        req = self._get_request(body, {'access_ipv4': '0.0.0.0'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['accessIPv4'], '0.0.0.0')",
            "",
            "    def test_update_server_access_ipv4_bad_format(self):",
            "        body = {'server': {'accessIPv4': 'bad_format'}}",
            "        req = self._get_request(body, {'access_ipv4': '0.0.0.0'})",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.update,",
            "                            req, FAKE_UUID, body)",
            "",
            "    def test_update_server_access_ipv4_none(self):",
            "        body = {'server': {'accessIPv4': None}}",
            "        req = self._get_request(body, {'access_ipv4': '0.0.0.0'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['accessIPv4'], '')",
            "",
            "    def test_update_server_access_ipv4_blank(self):",
            "        body = {'server': {'accessIPv4': ''}}",
            "        req = self._get_request(body, {'access_ipv4': '0.0.0.0'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['accessIPv4'], '')",
            "",
            "    def test_update_server_access_ipv6(self):",
            "        body = {'server': {'accessIPv6': 'beef::0123'}}",
            "        req = self._get_request(body, {'access_ipv6': 'beef::0123'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['accessIPv6'], 'beef::123')",
            "",
            "    def test_update_server_access_ipv6_bad_format(self):",
            "        body = {'server': {'accessIPv6': 'bad_format'}}",
            "        req = self._get_request(body, {'access_ipv6': 'beef::0123'})",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.update,",
            "                            req, FAKE_UUID, body)",
            "",
            "    def test_update_server_access_ipv6_none(self):",
            "        body = {'server': {'accessIPv6': None}}",
            "        req = self._get_request(body, {'access_ipv6': 'beef::0123'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['accessIPv6'], '')",
            "",
            "    def test_update_server_access_ipv6_blank(self):",
            "        body = {'server': {'accessIPv6': ''}}",
            "        req = self._get_request(body, {'access_ipv6': 'beef::0123'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['accessIPv6'], '')",
            "",
            "    def test_update_server_personality(self):",
            "        body = {",
            "            'server': {",
            "                'personality': []",
            "            }",
            "        }",
            "        req = self._get_request(body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "            self.controller.update, req, FAKE_UUID, body)",
            "",
            "    def test_update_server_adminPass_ignored(self):",
            "        inst_dict = dict(name='server_test', adminPass='bacon')",
            "        body = dict(server=inst_dict)",
            "",
            "        def server_update(context, id, params):",
            "            filtered_dict = {",
            "                'display_name': 'server_test',",
            "            }",
            "            self.assertEqual(params, filtered_dict)",
            "            filtered_dict['uuid'] = id",
            "            return filtered_dict",
            "",
            "        self.stubs.Set(db, 'instance_update', server_update)",
            "        # FIXME (comstud)",
            "        #        self.stubs.Set(db, 'instance_get',",
            "        #                return_server_with_attributes(name='server_test'))",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers/%s' % FAKE_UUID)",
            "        req.method = 'PUT'",
            "        req.content_type = \"application/json\"",
            "        req.body = jsonutils.dumps(body)",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['name'], 'server_test')",
            "",
            "    def test_update_server_not_found(self):",
            "        def fake_get(*args, **kwargs):",
            "            raise exception.InstanceNotFound(instance_id='fake')",
            "",
            "        self.stubs.Set(compute_api.API, 'get', fake_get)",
            "        body = {'server': {'name': 'server_test'}}",
            "        req = self._get_request(body)",
            "        self.assertRaises(webob.exc.HTTPNotFound, self.controller.update,",
            "                          req, FAKE_UUID, body)",
            "",
            "    def test_update_server_not_found_on_update(self):",
            "        def fake_update(*args, **kwargs):",
            "            raise exception.InstanceNotFound(instance_id='fake')",
            "",
            "        self.stubs.Set(db, 'instance_update_and_get_original', fake_update)",
            "        body = {'server': {'name': 'server_test'}}",
            "        req = self._get_request(body)",
            "        self.assertRaises(webob.exc.HTTPNotFound, self.controller.update,",
            "                          req, FAKE_UUID, body)",
            "",
            "    def test_update_server_policy_fail(self):",
            "        rule = {'compute:update': common_policy.parse_rule('role:admin')}",
            "        common_policy.set_rules(common_policy.Rules(rule))",
            "        body = {'server': {'name': 'server_test'}}",
            "        req = self._get_request(body, {'name': 'server_test'})",
            "        self.assertRaises(exception.PolicyNotAuthorized,",
            "                self.controller.update, req, FAKE_UUID, body)",
            "",
            "",
            "class ServersControllerDeleteTest(ControllerTest):",
            "",
            "    def setUp(self):",
            "        super(ServersControllerDeleteTest, self).setUp()",
            "        self.server_delete_called = False",
            "",
            "        def instance_destroy_mock(*args, **kwargs):",
            "            self.server_delete_called = True",
            "",
            "        self.stubs.Set(db, 'instance_destroy', instance_destroy_mock)",
            "",
            "    def _create_delete_request(self, uuid):",
            "        fakes.stub_out_instance_quota(self.stubs, 0, 10)",
            "        req = fakes.HTTPRequest.blank('/v2/fake/servers/%s' % uuid)",
            "        req.method = 'DELETE'",
            "        return req",
            "",
            "    def _delete_server_instance(self, uuid=FAKE_UUID):",
            "        req = self._create_delete_request(uuid)",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                fakes.fake_instance_get(vm_state=vm_states.ACTIVE))",
            "        self.controller.delete(req, uuid)",
            "",
            "    def test_delete_server_instance(self):",
            "        self._delete_server_instance()",
            "        self.assertTrue(self.server_delete_called)",
            "",
            "    def test_delete_server_instance_not_found(self):",
            "        self.assertRaises(webob.exc.HTTPNotFound,",
            "                          self._delete_server_instance,",
            "                          uuid='non-existent-uuid')",
            "",
            "    def test_delete_server_instance_while_building(self):",
            "        fakes.stub_out_instance_quota(self.stubs, 0, 10)",
            "        request = self._create_delete_request(FAKE_UUID)",
            "        self.controller.delete(request, FAKE_UUID)",
            "",
            "        self.assertTrue(self.server_delete_called)",
            "",
            "    def test_delete_server_instance_while_resize(self):",
            "        req = self._create_delete_request(FAKE_UUID)",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "            fakes.fake_instance_get(vm_state=vm_states.ACTIVE,",
            "                                    task_state=task_states.RESIZE_PREP))",
            "",
            "        self.controller.delete(req, FAKE_UUID)",
            "        # Delete shoud be allowed in any case, even during resizing,",
            "        # because it may get stuck.",
            "        self.assertTrue(self.server_delete_called)",
            "",
            "",
            "class ServersControllerRebuildInstanceTest(ControllerTest):",
            "    image_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    image_href = 'http://localhost/v2/fake/images/%s' % image_uuid",
            "",
            "    def setUp(self):",
            "        super(ServersControllerRebuildInstanceTest, self).setUp()",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                       fakes.fake_instance_get(vm_state=vm_states.ACTIVE))",
            "        self.body = {",
            "            'rebuild': {",
            "                'name': 'new_name',",
            "                'imageRef': self.image_href,",
            "                'metadata': {",
            "                    'open': 'stack',",
            "                },",
            "                'personality': [",
            "                    {",
            "                        \"path\": \"/etc/banner.txt\",",
            "                        \"contents\": \"MQ==\",",
            "                    },",
            "                ],",
            "            },",
            "        }",
            "        self.req = fakes.HTTPRequest.blank('/fake/servers/a/action')",
            "        self.req.method = 'POST'",
            "        self.req.headers[\"content-type\"] = \"application/json\"",
            "",
            "    def test_rebuild_instance_with_access_ipv4_bad_format(self):",
            "        # proper local hrefs must start with 'http://localhost/v2/'",
            "        self.body['rebuild']['accessIPv4'] = 'bad_format'",
            "        self.body['rebuild']['accessIPv6'] = 'fead::1234'",
            "        self.body['rebuild']['metadata']['hello'] = 'world'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_with_blank_metadata_key(self):",
            "        self.body['rebuild']['accessIPv4'] = '0.0.0.0'",
            "        self.body['rebuild']['accessIPv6'] = 'fead::1234'",
            "        self.body['rebuild']['metadata'][''] = 'world'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_with_metadata_key_too_long(self):",
            "        self.body['rebuild']['accessIPv4'] = '0.0.0.0'",
            "        self.body['rebuild']['accessIPv6'] = 'fead::1234'",
            "        self.body['rebuild']['metadata'][('a' * 260)] = 'world'",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_with_metadata_value_too_long(self):",
            "        self.body['rebuild']['accessIPv4'] = '0.0.0.0'",
            "        self.body['rebuild']['accessIPv6'] = 'fead::1234'",
            "        self.body['rebuild']['metadata']['key1'] = ('a' * 260)",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_fails_when_min_ram_too_small(self):",
            "        # make min_ram larger than our instance ram size",
            "        def fake_get_image(self, context, image_href):",
            "            return dict(id='76fa36fc-c930-4bf3-8c8a-ea2a2420deb6',",
            "                        name='public image', is_public=True,",
            "                        status='active', properties={'key1': 'value1'},",
            "                        min_ram=\"4096\", min_disk=\"10\")",
            "",
            "        self.stubs.Set(fake._FakeImageService, 'show', fake_get_image)",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_fails_when_min_disk_too_small(self):",
            "        # make min_disk larger than our instance disk size",
            "        def fake_get_image(self, context, image_href):",
            "            return dict(id='76fa36fc-c930-4bf3-8c8a-ea2a2420deb6',",
            "                        name='public image', is_public=True,",
            "                        status='active', properties={'key1': 'value1'},",
            "                        min_ram=\"128\", min_disk=\"100000\")",
            "",
            "        self.stubs.Set(fake._FakeImageService, 'show', fake_get_image)",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild, self.req,",
            "                          FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_image_too_large(self):",
            "        # make image size larger than our instance disk size",
            "        size = str(1000 * (1024 ** 3))",
            "",
            "        def fake_get_image(self, context, image_href):",
            "            return dict(id='76fa36fc-c930-4bf3-8c8a-ea2a2420deb6',",
            "                        name='public image', is_public=True,",
            "                        status='active', size=size)",
            "",
            "        self.stubs.Set(fake._FakeImageService, 'show', fake_get_image)",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "            self.controller._action_rebuild, self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_with_deleted_image(self):",
            "        def fake_get_image(self, context, image_href):",
            "            return dict(id='76fa36fc-c930-4bf3-8c8a-ea2a2420deb6',",
            "                        name='public image', is_public=True,",
            "                        status='DELETED')",
            "",
            "        self.stubs.Set(fake._FakeImageService, 'show', fake_get_image)",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "            self.controller._action_rebuild, self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_with_access_ipv6_bad_format(self):",
            "        # proper local hrefs must start with 'http://localhost/v2/'",
            "        self.body['rebuild']['accessIPv4'] = '1.2.3.4'",
            "        self.body['rebuild']['accessIPv6'] = 'bad_format'",
            "        self.body['rebuild']['metadata']['hello'] = 'world'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.req.headers[\"content-type\"] = \"application/json\"",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "",
            "class ServerStatusTest(test.TestCase):",
            "",
            "    def setUp(self):",
            "        super(ServerStatusTest, self).setUp()",
            "        fakes.stub_out_nw_api(self.stubs)",
            "",
            "        self.ext_mgr = extensions.ExtensionManager()",
            "        self.ext_mgr.extensions = {}",
            "        self.controller = servers.Controller(self.ext_mgr)",
            "",
            "        def _fake_get_server(context, req, id):",
            "            return fakes.stub_instance(id)",
            "",
            "        self.stubs.Set(self.controller, '_get_server', _fake_get_server)",
            "",
            "    def _get_with_state(self, vm_state, task_state=None):",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                fakes.fake_instance_get(vm_state=vm_state,",
            "                                        task_state=task_state))",
            "",
            "        request = fakes.HTTPRequest.blank('/fake/servers/%s' % FAKE_UUID)",
            "        return self.controller.show(request, FAKE_UUID)",
            "",
            "    def _req_with_policy_fail(self, policy_rule_name):",
            "        rule = {'compute:%s' % policy_rule_name:",
            "                common_policy.parse_rule('role:admin')}",
            "        common_policy.set_rules(common_policy.Rules(rule))",
            "        return fakes.HTTPRequest.blank('/fake/servers/1234/action')",
            "",
            "    def test_active(self):",
            "        response = self._get_with_state(vm_states.ACTIVE)",
            "        self.assertEqual(response['server']['status'], 'ACTIVE')",
            "",
            "    def test_reboot(self):",
            "        response = self._get_with_state(vm_states.ACTIVE,",
            "                                        task_states.REBOOTING)",
            "        self.assertEqual(response['server']['status'], 'REBOOT')",
            "",
            "    def test_reboot_hard(self):",
            "        response = self._get_with_state(vm_states.ACTIVE,",
            "                                        task_states.REBOOTING_HARD)",
            "        self.assertEqual(response['server']['status'], 'HARD_REBOOT')",
            "",
            "    def test_reboot_resize_policy_fail(self):",
            "        req = self._req_with_policy_fail('reboot')",
            "        self.assertRaises(exception.PolicyNotAuthorized,",
            "                self.controller._action_reboot, req, '1234',",
            "                {'reboot': {'type': 'HARD'}})",
            "",
            "    def test_rebuild(self):",
            "        response = self._get_with_state(vm_states.ACTIVE,",
            "                                        task_states.REBUILDING)",
            "        self.assertEqual(response['server']['status'], 'REBUILD')",
            "",
            "    def test_rebuild_error(self):",
            "        response = self._get_with_state(vm_states.ERROR)",
            "        self.assertEqual(response['server']['status'], 'ERROR')",
            "",
            "    def test_resize(self):",
            "        response = self._get_with_state(vm_states.ACTIVE,",
            "                                        task_states.RESIZE_PREP)",
            "        self.assertEqual(response['server']['status'], 'RESIZE')",
            "",
            "    def test_confirm_resize_policy_fail(self):",
            "        req = self._req_with_policy_fail('confirm_resize')",
            "        self.assertRaises(exception.PolicyNotAuthorized,",
            "                self.controller._action_confirm_resize, req, '1234', {})",
            "",
            "    def test_verify_resize(self):",
            "        response = self._get_with_state(vm_states.RESIZED, None)",
            "        self.assertEqual(response['server']['status'], 'VERIFY_RESIZE')",
            "",
            "    def test_revert_resize(self):",
            "        response = self._get_with_state(vm_states.RESIZED,",
            "                                        task_states.RESIZE_REVERTING)",
            "        self.assertEqual(response['server']['status'], 'REVERT_RESIZE')",
            "",
            "    def test_revert_resize_policy_fail(self):",
            "        req = self._req_with_policy_fail('revert_resize')",
            "        self.assertRaises(exception.PolicyNotAuthorized,",
            "                self.controller._action_revert_resize, req, '1234', {})",
            "",
            "    def test_password_update(self):",
            "        response = self._get_with_state(vm_states.ACTIVE,",
            "                                        task_states.UPDATING_PASSWORD)",
            "        self.assertEqual(response['server']['status'], 'PASSWORD')",
            "",
            "    def test_stopped(self):",
            "        response = self._get_with_state(vm_states.STOPPED)",
            "        self.assertEqual(response['server']['status'], 'SHUTOFF')",
            "",
            "",
            "class ServersControllerCreateTest(test.TestCase):",
            "    image_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    flavor_ref = 'http://localhost/123/flavors/3'",
            "",
            "    def setUp(self):",
            "        \"\"\"Shared implementation for tests below that create instance.\"\"\"",
            "        super(ServersControllerCreateTest, self).setUp()",
            "",
            "        self.flags(verbose=True,",
            "                   enable_instance_password=True)",
            "        self.instance_cache_num = 0",
            "        self.instance_cache_by_id = {}",
            "        self.instance_cache_by_uuid = {}",
            "",
            "        self.ext_mgr = extensions.ExtensionManager()",
            "        self.ext_mgr.extensions = {}",
            "        self.controller = servers.Controller(self.ext_mgr)",
            "",
            "        self.volume_id = 'fake'",
            "",
            "        def instance_create(context, inst):",
            "            inst_type = flavors.get_flavor_by_flavor_id(3)",
            "            image_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "            def_image_ref = 'http://localhost/images/%s' % image_uuid",
            "            self.instance_cache_num += 1",
            "            instance = fake_instance.fake_db_instance(**{",
            "                'id': self.instance_cache_num,",
            "                'display_name': inst['display_name'] or 'test',",
            "                'uuid': FAKE_UUID,",
            "                'instance_type': dict(inst_type),",
            "                'access_ip_v4': '1.2.3.4',",
            "                'access_ip_v6': 'fead::1234',",
            "                'image_ref': inst.get('image_ref', def_image_ref),",
            "                'user_id': 'fake',",
            "                'project_id': 'fake',",
            "                'reservation_id': inst['reservation_id'],",
            "                \"created_at\": datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "                \"updated_at\": datetime.datetime(2010, 11, 11, 11, 0, 0),",
            "                \"config_drive\": None,",
            "                \"progress\": 0,",
            "                \"fixed_ips\": [],",
            "                \"task_state\": \"\",",
            "                \"vm_state\": \"\",",
            "                \"root_device_name\": inst.get('root_device_name', 'vda'),",
            "                \"security_groups\": inst['security_groups'],",
            "            })",
            "",
            "            self.instance_cache_by_id[instance['id']] = instance",
            "            self.instance_cache_by_uuid[instance['uuid']] = instance",
            "            return instance",
            "",
            "        def instance_get(context, instance_id):",
            "            \"\"\"Stub for compute/api create() pulling in instance after",
            "            scheduling",
            "            \"\"\"",
            "            return self.instance_cache_by_id[instance_id]",
            "",
            "        def instance_update(context, uuid, values):",
            "            instance = self.instance_cache_by_uuid[uuid]",
            "            instance.update(values)",
            "            return instance",
            "",
            "        def rpc_call_wrapper(context, topic, msg, timeout=None):",
            "            \"\"\"Stub out the scheduler creating the instance entry.\"\"\"",
            "            if (topic == CONF.scheduler_topic and",
            "                    msg['method'] == 'run_instance'):",
            "                request_spec = msg['args']['request_spec']",
            "                num_instances = request_spec.get('num_instances', 1)",
            "                instances = []",
            "                for x in xrange(num_instances):",
            "                    instances.append(instance_create(context,",
            "                        request_spec['instance_properties']))",
            "                return instances",
            "",
            "        def server_update(context, instance_uuid, params, update_cells=False):",
            "            inst = self.instance_cache_by_uuid[instance_uuid]",
            "            inst.update(params)",
            "            return (inst, inst)",
            "",
            "        def fake_method(*args, **kwargs):",
            "            pass",
            "",
            "        def project_get_networks(context, user_id):",
            "            return dict(id='1', host='localhost')",
            "",
            "        def queue_get_for(context, *args):",
            "            return 'network_topic'",
            "",
            "        fakes.stub_out_rate_limiting(self.stubs)",
            "        fakes.stub_out_key_pair_funcs(self.stubs)",
            "        fake.stub_out_image_service(self.stubs)",
            "        fakes.stub_out_nw_api(self.stubs)",
            "        self.stubs.Set(uuid, 'uuid4', fake_gen_uuid)",
            "        self.stubs.Set(db, 'instance_add_security_group',",
            "                       return_security_group)",
            "        self.stubs.Set(db, 'project_get_networks',",
            "                       project_get_networks)",
            "        self.stubs.Set(db, 'instance_create', instance_create)",
            "        self.stubs.Set(db, 'instance_system_metadata_update',",
            "                       fake_method)",
            "        self.stubs.Set(db, 'instance_get', instance_get)",
            "        self.stubs.Set(db, 'instance_update', instance_update)",
            "        self.stubs.Set(rpc, 'cast', fake_method)",
            "        self.stubs.Set(rpc, 'call', rpc_call_wrapper)",
            "        self.stubs.Set(db, 'instance_update_and_get_original',",
            "                       server_update)",
            "        self.stubs.Set(rpc, 'queue_get_for', queue_get_for)",
            "        self.stubs.Set(manager.VlanManager, 'allocate_fixed_ip',",
            "                       fake_method)",
            "        self.body = {",
            "            'server': {",
            "                'min_count': 2,",
            "                'name': 'server_test',",
            "                'imageRef': self.image_uuid,",
            "                'flavorRef': self.flavor_ref,",
            "                'metadata': {",
            "                    'hello': 'world',",
            "                    'open': 'stack',",
            "                    },",
            "                'personality': [",
            "                    {",
            "                        \"path\": \"/etc/banner.txt\",",
            "                        \"contents\": \"MQ==\",",
            "                    },",
            "                ],",
            "            },",
            "        }",
            "        self.bdm = [{'delete_on_termination': 1,",
            "                     'device_name': 123,",
            "                     'volume_size': 1,",
            "                     'volume_id': '11111111-1111-1111-1111-111111111111'}]",
            "",
            "        self.req = fakes.HTTPRequest.blank('/fake/servers')",
            "        self.req.method = 'POST'",
            "        self.req.headers[\"content-type\"] = \"application/json\"",
            "",
            "    def _check_admin_pass_len(self, server_dict):",
            "        \"\"\"utility function - check server_dict for adminPass length.\"\"\"",
            "        self.assertEqual(CONF.password_length,",
            "                         len(server_dict[\"adminPass\"]))",
            "",
            "    def _check_admin_pass_missing(self, server_dict):",
            "        \"\"\"utility function - check server_dict for absence of adminPass.\"\"\"",
            "        self.assertTrue(\"adminPass\" not in server_dict)",
            "",
            "    def _test_create_instance(self):",
            "        image_uuid = 'c905cedb-7281-47e4-8a62-f26bc5fc4c77'",
            "        self.body['server']['imageRef'] = image_uuid",
            "        self.body['server']['flavorRef'] = 2",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        server = self.controller.create(self.req, self.body).obj['server']",
            "        self._check_admin_pass_len(server)",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_server_bad_image_href(self):",
            "        image_href = 1",
            "        self.body['server']['imageRef'] = image_href,",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create,",
            "                          self.req, self.body)",
            "",
            "    def test_create_server_with_invalid_networks_parameter(self):",
            "        self.ext_mgr.extensions = {'os-networks': 'fake'}",
            "        self.body['server']['networks'] = {",
            "            'uuid': '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'}",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create,",
            "                          self.req,",
            "                          self.body)",
            "",
            "    def test_create_server_with_deleted_image(self):",
            "        image_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "        # Get the fake image service so we can set the status to deleted",
            "        (image_service, image_id) = glance.get_remote_image_service(",
            "                context, '')",
            "        image_service.update(context, image_uuid, {'status': 'DELETED'})",
            "        self.addCleanup(image_service.update, context, image_uuid,",
            "                        {'status': 'active'})",
            "",
            "        self.body['server']['flavorRef'] = 2",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        with testtools.ExpectedException(",
            "                webob.exc.HTTPBadRequest,",
            "                'Image 76fa36fc-c930-4bf3-8c8a-ea2a2420deb6 is not active.'):",
            "            self.controller.create(self.req, self.body)",
            "",
            "    def test_create_server_image_too_large(self):",
            "        image_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "        # Get the fake image service so we can set the status to deleted",
            "        (image_service, image_id) = glance.get_remote_image_service(context,",
            "                                                                    image_uuid)",
            "        image = image_service.show(context, image_id)",
            "        orig_size = image['size']",
            "        new_size = str(1000 * (1024 ** 3))",
            "        image_service.update(context, image_uuid, {'size': new_size})",
            "",
            "        self.addCleanup(image_service.update, context, image_uuid,",
            "                        {'size': orig_size})",
            "",
            "        self.body['server']['flavorRef'] = 2",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        with testtools.ExpectedException(",
            "                webob.exc.HTTPBadRequest,",
            "                \"Instance type's disk is too small for requested image.\"):",
            "            self.controller.create(self.req, self.body)",
            "",
            "    def test_create_instance_invalid_negative_min(self):",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        self.body['server']['min_count'] = -1",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create,",
            "                          self.req,",
            "                          self.body)",
            "",
            "    def test_create_instance_invalid_negative_max(self):",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        self.body['server']['max_count'] = -1",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create,",
            "                          self.req,",
            "                          self.body)",
            "",
            "    def test_create_instance_invalid_alpha_min(self):",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        self.body['server']['min_count'] = 'abcd',",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create,",
            "                          self.req,",
            "                          self.body)",
            "",
            "    def test_create_instance_invalid_alpha_max(self):",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        self.body['server']['max_count'] = 'abcd',",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create,",
            "                          self.req,",
            "                          self.body)",
            "",
            "    def test_create_multiple_instances(self):",
            "        \"\"\"Test creating multiple instances but not asking for",
            "        reservation_id",
            "        \"\"\"",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "        self.assertEqual(FAKE_UUID, res[\"server\"][\"id\"])",
            "        self._check_admin_pass_len(res[\"server\"])",
            "",
            "    def test_create_multiple_instances_pass_disabled(self):",
            "        \"\"\"Test creating multiple instances but not asking for",
            "        reservation_id",
            "        \"\"\"",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        self.flags(enable_instance_password=False)",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "        self.assertEqual(FAKE_UUID, res[\"server\"][\"id\"])",
            "        self._check_admin_pass_missing(res[\"server\"])",
            "",
            "    def test_create_multiple_instances_resv_id_return(self):",
            "        \"\"\"Test creating multiple instances with asking for",
            "        reservation_id",
            "        \"\"\"",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        self.body['server']['return_reservation_id'] = True",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body)",
            "        reservation_id = res.obj.get('reservation_id')",
            "        self.assertNotEqual(reservation_id, \"\")",
            "        self.assertNotEqual(reservation_id, None)",
            "        self.assertTrue(len(reservation_id) > 1)",
            "",
            "    def test_create_multiple_instances_with_multiple_volume_bdm(self):",
            "        \"\"\"",
            "        Test that a BadRequest is raised if multiple instances",
            "        are requested with a list of block device mappings for volumes.",
            "        \"\"\"",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        min_count = 2",
            "        bdm = [{'device_name': 'foo1', 'volume_id': 'vol-xxxx'},",
            "               {'device_name': 'foo2', 'volume_id': 'vol-yyyy'}",
            "        ]",
            "        params = {",
            "                  'block_device_mapping': bdm,",
            "                  'min_count': min_count",
            "        }",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['min_count'], 2)",
            "            self.assertEqual(len(kwargs['block_device_mapping']), 2)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, params, no_image=True)",
            "",
            "    def test_create_multiple_instances_with_single_volume_bdm(self):",
            "        \"\"\"",
            "        Test that a BadRequest is raised if multiple instances",
            "        are requested to boot from a single volume.",
            "        \"\"\"",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        min_count = 2",
            "        bdm = [{'device_name': 'foo1', 'volume_id': 'vol-xxxx'}]",
            "        params = {",
            "                 'block_device_mapping': bdm,",
            "                 'min_count': min_count",
            "        }",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['min_count'], 2)",
            "            self.assertEqual(kwargs['block_device_mapping']['volume_id'],",
            "                            'vol-xxxx')",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, params, no_image=True)",
            "",
            "    def test_create_multiple_instance_with_non_integer_max_count(self):",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        self.body['server']['max_count'] = 2.5",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_multiple_instance_with_non_integer_min_count(self):",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        self.body['server']['min_count'] = 2.5",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_image_ref_is_bookmark(self):",
            "        image_href = 'http://localhost/fake/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "        server = res['server']",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_image_ref_is_invalid(self):",
            "        image_uuid = 'this_is_not_a_valid_uuid'",
            "        image_href = 'http://localhost/fake/images/%s' % image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.create,",
            "                          self.req, self.body)",
            "",
            "    def test_create_instance_no_key_pair(self):",
            "        fakes.stub_out_key_pair_funcs(self.stubs, have_key_pair=False)",
            "        self._test_create_instance()",
            "",
            "    def _test_create_extra(self, params, no_image=False):",
            "        self.body['server']['flavorRef'] = 2",
            "        if no_image:",
            "            self.body['server'].pop('imageRef', None)",
            "        self.body['server'].update(params)",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        server = self.controller.create(self.req, self.body).obj['server']",
            "",
            "    def test_create_instance_with_security_group_enabled(self):",
            "        self.ext_mgr.extensions = {'os-security-groups': 'fake'}",
            "        group = 'foo'",
            "        old_create = compute_api.API.create",
            "",
            "        def sec_group_get(ctx, proj, name):",
            "            if name == group:",
            "                return True",
            "            else:",
            "                raise exception.SecurityGroupNotFoundForProject(",
            "                    project_id=proj, security_group_id=name)",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['security_group'], [group])",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(db, 'security_group_get_by_name', sec_group_get)",
            "        # negative test",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra,",
            "                          {'security_groups': [{'name': 'bogus'}]})",
            "        # positive test - extra assert in create path",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra({'security_groups': [{'name': group}]})",
            "",
            "    def test_create_instance_with_access_ip(self):",
            "        # proper local hrefs must start with 'http://localhost/v2/'",
            "        image_href = 'http://localhost/v2/fake/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['accessIPv4'] = '1.2.3.4'",
            "        self.body['server']['accessIPv6'] = 'fead::1234'",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "        server = res['server']",
            "        self._check_admin_pass_len(server)",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_with_access_ip_pass_disabled(self):",
            "        # test with admin passwords disabled See lp bug 921814",
            "        # proper local hrefs must start with 'http://localhost/v2/'",
            "        self.flags(enable_instance_password=False)",
            "        image_href = 'http://localhost/v2/fake/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['accessIPv4'] = '1.2.3.4'",
            "        self.body['server']['accessIPv6'] = 'fead::1234'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self._check_admin_pass_missing(server)",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_bad_format_access_ip_v4(self):",
            "        # proper local hrefs must start with 'http://localhost/v2/'",
            "        image_href = 'http://localhost/v2/fake/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['accessIPv4'] = 'bad_format'",
            "        self.body['server']['accessIPv6'] = 'fead::1234'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.create,",
            "                          self.req, self.body)",
            "",
            "    def test_create_instance_bad_format_access_ip_v6(self):",
            "        # proper local hrefs must start with 'http://localhost/v2/'",
            "        image_href = 'http://localhost/v2/fake/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['accessIPv4'] = '1.2.3.4'",
            "        self.body['server']['accessIPv6'] = 'bad_format'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.create,",
            "                          self.req, self.body)",
            "",
            "    def test_create_instance_name_all_blank_spaces(self):",
            "        # proper local hrefs must start with 'http://localhost/v2/'",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['name'] = ' ' * 64",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_name_too_long(self):",
            "        # proper local hrefs must start with 'http://localhost/v2/'",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['name'] = 'X' * 256",
            "        self.body['server']['imageRef'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.create,",
            "                          self.req, self.body)",
            "",
            "    def test_create_instance(self):",
            "        # proper local hrefs must start with 'http://localhost/v2/'",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self._check_admin_pass_len(server)",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_pass_disabled(self):",
            "        # proper local hrefs must start with 'http://localhost/v2/'",
            "        self.flags(enable_instance_password=False)",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self._check_admin_pass_missing(server)",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_too_much_metadata(self):",
            "        self.flags(quota_metadata_items=1)",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['metadata']['vote'] = 'fiddletown'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_metadata_key_too_long(self):",
            "        self.flags(quota_metadata_items=1)",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['metadata'] = {('a' * 260): '12345'}",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_metadata_value_too_long(self):",
            "        self.flags(quota_metadata_items=1)",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['metadata'] = {'key1': ('a' * 260)}",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_metadata_key_blank(self):",
            "        self.flags(quota_metadata_items=1)",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['metadata'] = {'': 'abcd'}",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_invalid_key_name(self):",
            "        image_href = 'http://localhost/v2/images/2'",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['key_name'] = 'nonexistentkey'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_valid_key_name(self):",
            "        self.body['server']['key_name'] = 'key'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        self.assertEqual(FAKE_UUID, res[\"server\"][\"id\"])",
            "        self._check_admin_pass_len(res[\"server\"])",
            "",
            "    def test_create_instance_invalid_flavor_href(self):",
            "        image_href = 'http://localhost/v2/images/2'",
            "        flavor_ref = 'http://localhost/v2/flavors/asdf'",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['flavorRef'] = flavor_ref",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_invalid_flavor_id_int(self):",
            "        image_href = 'http://localhost/v2/images/2'",
            "        flavor_ref = -1",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['flavorRef'] = flavor_ref",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_bad_flavor_href(self):",
            "        image_href = 'http://localhost/v2/images/2'",
            "        flavor_ref = 'http://localhost/v2/flavors/17'",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['flavorRef'] = flavor_ref",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_with_config_drive(self):",
            "        self.ext_mgr.extensions = {'os-config-drive': 'fake'}",
            "        self.body['server']['config_drive'] = \"true\"",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "        server = res['server']",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_with_bad_config_drive(self):",
            "        self.ext_mgr.extensions = {'os-config-drive': 'fake'}",
            "        self.body['server']['config_drive'] = 'adcd'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_without_config_drive(self):",
            "        self.ext_mgr.extensions = {'os-config-drive': 'fake'}",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "        server = res['server']",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_with_config_drive_disabled(self):",
            "        config_drive = [{'config_drive': 'foo'}]",
            "        params = {'config_drive': config_drive}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['config_drive'], None)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_bad_href(self):",
            "        image_href = 'asdf'",
            "        self.body['server']['imageRef'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_local_href(self):",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_admin_pass(self):",
            "        self.body['server']['flavorRef'] = 3,",
            "        self.body['server']['adminPass'] = 'testpass'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self.assertEqual(server['adminPass'], self.body['server']['adminPass'])",
            "",
            "    def test_create_instance_admin_pass_pass_disabled(self):",
            "        self.flags(enable_instance_password=False)",
            "        self.body['server']['flavorRef'] = 3,",
            "        self.body['server']['adminPass'] = 'testpass'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self.assertTrue('adminPass' in self.body['server'])",
            "        self.assertTrue('adminPass' not in server)",
            "",
            "    def test_create_instance_admin_pass_empty(self):",
            "        self.body['server']['flavorRef'] = 3,",
            "        self.body['server']['adminPass'] = ''",
            "        self.req.body = jsonutils.dumps(self.body)",
            "",
            "        # The fact that the action doesn't raise is enough validation",
            "        self.controller.create(self.req, self.body)",
            "",
            "    def test_create_instance_invalid_personality(self):",
            "",
            "        def fake_create(*args, **kwargs):",
            "            codec = 'utf8'",
            "            content = 'b25zLiINCg0KLVJpY2hhcmQgQ$$%QQmFjaA=='",
            "            start_position = 19",
            "            end_position = 20",
            "            msg = 'invalid start byte'",
            "            raise UnicodeDecodeError(codec, content, start_position,",
            "                                     end_position, msg)",
            "",
            "        self.stubs.Set(compute_api.API,",
            "                       'create',",
            "                       fake_create)",
            "",
            "        self.body['server']['personality'][0][\"contents\"] = \\",
            "            \"b25zLiINCg0KLVJpY2hhcmQgQ$$%QQmFjaA==\"",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_location(self):",
            "        selfhref = 'http://localhost/v2/fake/servers/%s' % FAKE_UUID",
            "        bookhref = 'http://localhost/fake/servers/%s' % FAKE_UUID",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        robj = self.controller.create(self.req, self.body)",
            "",
            "        self.assertEqual(robj['Location'], selfhref)",
            "",
            "    def _do_test_create_instance_above_quota(self, resource, allowed, quota,",
            "                                             expected_msg):",
            "        fakes.stub_out_instance_quota(self.stubs, allowed, quota, resource)",
            "        self.body['server']['flavorRef'] = 3",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        try:",
            "            server = self.controller.create(self.req, self.body).obj['server']",
            "            self.fail('expected quota to be exceeded')",
            "        except webob.exc.HTTPRequestEntityTooLarge as e:",
            "            self.assertEquals(e.explanation, expected_msg)",
            "",
            "    def test_create_instance_with_security_group_enabled(self):",
            "        self.ext_mgr.extensions = {'os-security-groups': 'fake'}",
            "        group = 'foo'",
            "        old_create = compute_api.API.create",
            "",
            "        def sec_group_get(ctx, proj, name):",
            "            if name == group:",
            "                return True",
            "            else:",
            "                raise exception.SecurityGroupNotFoundForProject(",
            "                    project_id=proj, security_group_id=name)",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['security_group'], [group])",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(db, 'security_group_get_by_name', sec_group_get)",
            "        # negative test",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra,",
            "                          {'security_groups': [{'name': 'bogus'}]})",
            "        # positive test - extra assert in create path",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra({'security_groups': [{'name': group}]})",
            "",
            "    def test_create_instance_with_security_group_disabled(self):",
            "        group = 'foo'",
            "        params = {'security_groups': [{'name': group}]}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            # NOTE(vish): if the security groups extension is not",
            "            #             enabled, then security groups passed in",
            "            #             are ignored.",
            "            self.assertEqual(kwargs['security_group'], ['default'])",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_disk_config_enabled(self):",
            "        self.ext_mgr.extensions = {'OS-DCF': 'fake'}",
            "        # NOTE(vish): the extension converts OS-DCF:disk_config into",
            "        #             auto_disk_config, so we are testing with",
            "        #             the_internal_value",
            "        params = {'auto_disk_config': 'AUTO'}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['auto_disk_config'], 'AUTO')",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_disk_config_disabled(self):",
            "        params = {'auto_disk_config': True}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['auto_disk_config'], False)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_scheduler_hints_enabled(self):",
            "        self.ext_mgr.extensions = {'OS-SCH-HNT': 'fake'}",
            "        hints = {'a': 'b'}",
            "        params = {'scheduler_hints': hints}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['scheduler_hints'], hints)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_scheduler_hints_disabled(self):",
            "        hints = {'a': 'b'}",
            "        params = {'scheduler_hints': hints}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['scheduler_hints'], {})",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_volumes_enabled(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "        bdm = [{'device_name': 'foo', 'volume_id': 'fake_vol'}]",
            "        params = {'block_device_mapping': bdm}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['block_device_mapping'], bdm)",
            "            return old_create(*args, **kwargs)",
            "",
            "        def _validate_bdm(*args, **kwargs):",
            "            pass",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.stubs.Set(compute_api.API, '_validate_bdm', _validate_bdm)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_volumes_enabled_no_image(self):",
            "        \"\"\"",
            "        Test that the create will fail if there is no image",
            "        and no bdms supplied in the request",
            "        \"\"\"",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertNotIn('imageRef', kwargs)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, {}, no_image=True)",
            "",
            "    def test_create_instance_with_bdm_v2_enabled_no_image(self):",
            "        self.ext_mgr.extensions = {'os-block-device-mapping-v2-boot': 'fake'}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertNotIn('imageRef', kwargs)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, {}, no_image=True)",
            "",
            "    def test_create_instance_with_volumes_enabled_and_bdms_no_image(self):",
            "        \"\"\"",
            "        Test that the create works if there is no image supplied but",
            "        os-volumes extension is enabled and bdms are supplied",
            "        \"\"\"",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "        self.mox.StubOutWithMock(compute_api.API, '_validate_bdm')",
            "        self.mox.StubOutWithMock(compute_api.API, '_get_volume_image_metadata')",
            "        bdm = [{",
            "            'id': 1,",
            "            'no_device': None,",
            "            'virtual_name': None,",
            "            'snapshot_id': None,",
            "            'volume_id': self.volume_id,",
            "            'status': 'active',",
            "            'device_name': 'vda',",
            "            'delete_on_termination': False,",
            "            'volume_image_metadata':",
            "                {'test_key': 'test_value'}",
            "        }]",
            "        volume = bdm[0]",
            "        compute_api.API._validate_bdm(mox.IgnoreArg(),",
            "                                      mox.IgnoreArg()).AndReturn(True)",
            "        compute_api.API._get_volume_image_metadata(mox.IgnoreArg(),",
            "                                                   bdm).AndReturn(volume)",
            "        params = {'block_device_mapping': bdm}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['block_device_mapping'], bdm)",
            "            self.assertNotIn('imageRef', kwargs)",
            "            return old_create(*args, **kwargs)",
            "",
            "        def _validate_bdm(*args, **kwargs):",
            "            pass",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.mox.ReplayAll()",
            "        self._test_create_extra(params, no_image=True)",
            "",
            "    def test_create_instance_with_bdm_v2_enabled_and_bdms_no_image(self):",
            "        self.ext_mgr.extensions = {",
            "            'os-volumes': 'fake',",
            "            'os-block-device-mapping-v2-boot': 'fake'}",
            "        bdm_v2 = [{",
            "            'no_device': None,",
            "            'source_type': 'volume',",
            "            'destination_type': 'volume',",
            "            'uuid': self.volume_id,",
            "            'device_name': 'vda',",
            "            'delete_on_termination': False,",
            "        }]",
            "        params = {'block_device_mapping_v2': bdm_v2}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertThat(block_device.BlockDeviceDict(bdm_v2[0]),",
            "                            matchers.DictMatches(",
            "                                kwargs['block_device_mapping'][0]))",
            "            self.assertNotIn('imageRef', kwargs)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.mox.StubOutWithMock(compute_api.API, '_validate_bdm')",
            "        self.mox.StubOutWithMock(compute_api.API, '_get_volume_image_metadata')",
            "",
            "        compute_api.API._validate_bdm(mox.IgnoreArg(),",
            "                                      mox.IgnoreArg()).AndReturn(True)",
            "        compute_api.API._get_volume_image_metadata(",
            "            mox.IgnoreArg(), mox.IgnoreArg()).AndReturn({})",
            "        self.mox.ReplayAll()",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "",
            "        self._test_create_extra(params, no_image=True)",
            "",
            "    def test_create_instance_with_volumes_disabled(self):",
            "        bdm = [{'device_name': 'foo'}]",
            "        params = {'block_device_mapping': bdm}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['block_device_mapping'], None)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_device_name_not_string(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "        old_create = compute_api.API.create",
            "        self.params = {'block_device_mapping': self.bdm}",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['block_device_mapping'], self.bdm)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, self.params)",
            "",
            "    def test_create_instance_with_device_name_empty(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "        self.bdm[0]['device_name'] = ''",
            "        params = {'block_device_mapping': self.bdm}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['block_device_mapping'], self.bdm)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, params)",
            "",
            "    def test_create_instance_with_device_name_too_long(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "        self.bdm[0]['device_name'] = 'a' * 256,",
            "        params = {'block_device_mapping': self.bdm}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['block_device_mapping'], self.bdm)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, params)",
            "",
            "    def test_create_instance_with_space_in_device_name(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "        self.bdm[0]['device_name'] = 'vd a',",
            "        params = {'block_device_mapping': self.bdm}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertTrue(kwargs['legacy_bdm'])",
            "            self.assertEqual(kwargs['block_device_mapping'], self.bdm)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, params)",
            "",
            "    def test_create_instance_with_invalid_size(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "        bdm = [{'delete_on_termination': 1,",
            "                'device_name': 'vda',",
            "                'volume_size': \"hello world\",",
            "                'volume_id': '11111111-1111-1111-1111-111111111111'}]",
            "        params = {'block_device_mapping': bdm}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['block_device_mapping'], bdm)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, params)",
            "",
            "    def test_create_instance_with_bdm_delete_on_termination(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "        bdm = [{'device_name': 'foo1', 'volume_id': 'fake_vol',",
            "                'delete_on_termination': 1},",
            "               {'device_name': 'foo2', 'volume_id': 'fake_vol',",
            "                'delete_on_termination': True},",
            "               {'device_name': 'foo3', 'volume_id': 'fake_vol',",
            "                'delete_on_termination': 'invalid'},",
            "               {'device_name': 'foo4', 'volume_id': 'fake_vol',",
            "                'delete_on_termination': 0},",
            "               {'device_name': 'foo5', 'volume_id': 'fake_vol',",
            "                'delete_on_termination': False}]",
            "        expected_bdm = [",
            "            {'device_name': 'foo1', 'volume_id': 'fake_vol',",
            "             'delete_on_termination': True},",
            "            {'device_name': 'foo2', 'volume_id': 'fake_vol',",
            "             'delete_on_termination': True},",
            "            {'device_name': 'foo3', 'volume_id': 'fake_vol',",
            "             'delete_on_termination': False},",
            "            {'device_name': 'foo4', 'volume_id': 'fake_vol',",
            "             'delete_on_termination': False},",
            "            {'device_name': 'foo5', 'volume_id': 'fake_vol',",
            "             'delete_on_termination': False}]",
            "        params = {'block_device_mapping': bdm}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(expected_bdm, kwargs['block_device_mapping'])",
            "            return old_create(*args, **kwargs)",
            "",
            "        def _validate_bdm(*args, **kwargs):",
            "            pass",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.stubs.Set(compute_api.API, '_validate_bdm', _validate_bdm)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_bdm_v2(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake',",
            "                                   'os-block-device-mapping-v2-boot': 'fake'}",
            "        bdm_v2 = [{'source_type': 'volume',",
            "                   'device_name': 'fake_dev',",
            "                   'uuid': 'fake_vol'}]",
            "        bdm_v2_expected = [{'source_type': 'volume',",
            "                            'device_name': 'fake_dev',",
            "                            'volume_id': 'fake_vol'}]",
            "        params = {'block_device_mapping_v2': bdm_v2}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertFalse(kwargs['legacy_bdm'])",
            "            for expected, received in zip(bdm_v2_expected,",
            "                                          kwargs['block_device_mapping']):",
            "                self.assertThat(block_device.BlockDeviceDict(expected),",
            "                                matchers.DictMatches(received))",
            "            return old_create(*args, **kwargs)",
            "",
            "        def _validate_bdm(*args, **kwargs):",
            "            pass",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.stubs.Set(compute_api.API, '_validate_bdm', _validate_bdm)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_decide_format_legacy(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake',",
            "                                   'os-block-device-mapping-v2-boot': 'fake'}",
            "        bdm = [{'device_name': 'foo1',",
            "                'volume_id': 'fake_vol',",
            "                'delete_on_termination': 1}]",
            "",
            "        expected_legacy_flag = True",
            "",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['legacy_bdm'], expected_legacy_flag)",
            "            return old_create(*args, **kwargs)",
            "",
            "        def _validate_bdm(*args, **kwargs):",
            "            pass",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.stubs.Set(compute_api.API, '_validate_bdm',",
            "                       _validate_bdm)",
            "",
            "        self._test_create_extra({})",
            "",
            "        params = {'block_device_mapping': bdm}",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_decide_format_new(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake',",
            "                                   'os-block-device-mapping-v2-boot': 'fake'}",
            "",
            "        bdm_v2 = [{'source_type': 'volume',",
            "                   'device_name': 'fake_dev',",
            "                   'uuid': 'fake_vol'}]",
            "",
            "        old_create = compute_api.API.create",
            "",
            "        expected_legacy_flag = False",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['legacy_bdm'], expected_legacy_flag)",
            "            return old_create(*args, **kwargs)",
            "",
            "        def _validate_bdm(*args, **kwargs):",
            "            pass",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.stubs.Set(compute_api.API, '_validate_bdm',",
            "                       _validate_bdm)",
            "",
            "        params = {'block_device_mapping_v2': bdm_v2}",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_both_bdm_formats(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake',",
            "                                   'os-block-device-mapping-v2-boot': 'fake'}",
            "        bdm = [{'device_name': 'foo'}]",
            "        bdm_v2 = [{'source_type': 'volume',",
            "                   'uuid': 'fake_vol'}]",
            "        params = {'block_device_mapping': bdm,",
            "                  'block_device_mapping_v2': bdm_v2}",
            "",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, params)",
            "",
            "    def test_create_instance_bdm_v2_missing_device_name(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake',",
            "                                   'os-block-device-mapping-v2-boot': 'fake'}",
            "        bdm_v2 = [{'source_type': 'volume',",
            "                   'uuid': 'fake_vol'}]",
            "        params = {'block_device_mapping_v2': bdm_v2}",
            "",
            "        def _validate(*args, **kwargs):",
            "            pass",
            "",
            "        def _validate_bdm(*args, **kwargs):",
            "            pass",
            "",
            "        self.stubs.Set(block_device.BlockDeviceDict,",
            "                      '_validate', _validate)",
            "        self.stubs.Set(compute_api.API, '_validate_bdm',",
            "                       _validate_bdm)",
            "",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, params)",
            "",
            "    def test_create_instance_bdm_v2_validation_error(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake',",
            "                                   'os-block-device-mapping-v2-boot': 'fake'}",
            "        bdm_v2 = [{'device_name': 'bogus device'}]",
            "        params = {'block_device_mapping_v2': bdm_v2}",
            "",
            "        def _validate(*args, **kwargs):",
            "            raise exception.InvalidBDMFormat()",
            "",
            "        self.stubs.Set(block_device.BlockDeviceDict,",
            "                      '_validate', _validate)",
            "",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, params)",
            "",
            "    def test_create_instance_with_user_data_enabled(self):",
            "        self.ext_mgr.extensions = {'os-user-data': 'fake'}",
            "        user_data = 'fake'",
            "        params = {'user_data': user_data}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['user_data'], user_data)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_user_data_disabled(self):",
            "        user_data = 'fake'",
            "        params = {'user_data': user_data}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['user_data'], None)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_keypairs_enabled(self):",
            "        self.ext_mgr.extensions = {'os-keypairs': 'fake'}",
            "        key_name = 'green'",
            "",
            "        params = {'key_name': key_name}",
            "        old_create = compute_api.API.create",
            "",
            "        # NOTE(sdague): key pair goes back to the database,",
            "        # so we need to stub it out for tests",
            "        def key_pair_get(context, user_id, name):",
            "            return {'public_key': 'FAKE_KEY',",
            "                    'fingerprint': 'FAKE_FINGERPRINT',",
            "                    'name': name}",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['key_name'], key_name)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(db, 'key_pair_get', key_pair_get)",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_keypairs_disabled(self):",
            "        key_name = 'green'",
            "",
            "        params = {'key_name': key_name}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['key_name'], None)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_availability_zone_enabled(self):",
            "        self.ext_mgr.extensions = {'os-availability-zone': 'fake'}",
            "        availability_zone = 'fake'",
            "        params = {'availability_zone': availability_zone}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['availability_zone'], availability_zone)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "",
            "        try:",
            "            self._test_create_extra(params)",
            "        except webob.exc.HTTPBadRequest as e:",
            "            expected = 'The requested availability zone is not available'",
            "            self.assertEquals(e.explanation, expected)",
            "        admin_context = context.get_admin_context()",
            "        service1 = db.service_create(admin_context, {'host': 'host1_zones',",
            "                                         'binary': \"nova-compute\",",
            "                                         'topic': 'compute',",
            "                                         'report_count': 0})",
            "        agg = db.aggregate_create(admin_context,",
            "                {'name': 'agg1'}, {'availability_zone': availability_zone})",
            "        db.aggregate_host_add(admin_context, agg['id'], 'host1_zones')",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_availability_zone_disabled(self):",
            "        availability_zone = 'fake'",
            "        params = {'availability_zone': availability_zone}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['availability_zone'], None)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_multiple_create_enabled(self):",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        min_count = 2",
            "        max_count = 3",
            "        params = {",
            "            'min_count': min_count,",
            "            'max_count': max_count,",
            "        }",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['min_count'], 2)",
            "            self.assertEqual(kwargs['max_count'], 3)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_multiple_create_disabled(self):",
            "        ret_res_id = True",
            "        min_count = 2",
            "        max_count = 3",
            "        params = {",
            "            'min_count': min_count,",
            "            'max_count': max_count,",
            "        }",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['min_count'], 1)",
            "            self.assertEqual(kwargs['max_count'], 1)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_networks_enabled(self):",
            "        self.ext_mgr.extensions = {'os-networks': 'fake'}",
            "        net_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "        requested_networks = [{'uuid': net_uuid}]",
            "        params = {'networks': requested_networks}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            result = [('76fa36fc-c930-4bf3-8c8a-ea2a2420deb6', None)]",
            "            self.assertEqual(kwargs['requested_networks'], result)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_neutronv2_port_in_use(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        network = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'uuid': network, 'port': port}]",
            "        params = {'networks': requested_networks}",
            "",
            "        def fake_create(*args, **kwargs):",
            "            raise exception.PortInUse(port_id=port)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', fake_create)",
            "        self.assertRaises(webob.exc.HTTPConflict,",
            "                                          self._test_create_extra, params)",
            "",
            "    def test_create_instance_with_neutronv2_port_not_found(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        network = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'uuid': network, 'port': port}]",
            "        params = {'networks': requested_networks}",
            "",
            "        def fake_create(*args, **kwargs):",
            "            raise exception.PortNotFound(port_id=port)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', fake_create)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                                        self._test_create_extra, params)",
            "",
            "    def test_create_instance_with_networks_disabled_neutronv2(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        net_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "        requested_networks = [{'uuid': net_uuid}]",
            "        params = {'networks': requested_networks}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            result = [('76fa36fc-c930-4bf3-8c8a-ea2a2420deb6', None,",
            "                       None)]",
            "            self.assertEqual(kwargs['requested_networks'], result)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_networks_disabled(self):",
            "        self.ext_mgr.extensions = {}",
            "        net_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "        requested_networks = [{'uuid': net_uuid}]",
            "        params = {'networks': requested_networks}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['requested_networks'], None)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_config_drive_disabled(self):",
            "        config_drive = [{'config_drive': 'foo'}]",
            "        params = {'config_drive': config_drive}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['config_drive'], None)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_local_href(self):",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "        server = res['server']",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_admin_pass_empty(self):",
            "        self.body['server']['flavorRef'] = 3",
            "        self.body['server']['adminPass'] = ''",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        # The fact that the action doesn't raise is enough validation",
            "        self.controller.create(self.req, self.body)",
            "",
            "    def test_create_instance_invalid_personality(self):",
            "",
            "        def fake_create(*args, **kwargs):",
            "            codec = 'utf8'",
            "            content = 'b25zLiINCg0KLVJpY2hhcmQgQ$$%QQmFjaA=='",
            "            start_position = 19",
            "            end_position = 20",
            "            msg = 'invalid start byte'",
            "            raise UnicodeDecodeError(codec, content, start_position,",
            "                                     end_position, msg)",
            "        self.stubs.Set(compute_api.API, 'create', fake_create)",
            "        self.body['server']['personality'] = [",
            "            {",
            "                \"path\": \"/etc/banner.txt\",",
            "                \"contents\": \"b25zLiINCg0KLVJpY2hhcmQgQ$$%QQmFjaA==\",",
            "            },",
            "        ]",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_location(self):",
            "        selfhref = 'http://localhost/v2/fake/servers/%s' % FAKE_UUID",
            "        bookhref = 'http://localhost/fake/servers/%s' % FAKE_UUID",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        robj = self.controller.create(self.req, self.body)",
            "        self.assertEqual(robj['Location'], selfhref)",
            "",
            "    def _do_test_create_instance_above_quota(self, resource, allowed, quota,",
            "                                             expected_msg):",
            "        fakes.stub_out_instance_quota(self.stubs, allowed, quota, resource)",
            "        self.body['server']['flavorRef'] = 3",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        try:",
            "            server = self.controller.create(self.req, self.body).obj['server']",
            "            self.fail('expected quota to be exceeded')",
            "        except webob.exc.HTTPRequestEntityTooLarge as e:",
            "            self.assertEquals(e.explanation, expected_msg)",
            "",
            "    def test_create_instance_above_quota_instances(self):",
            "        msg = _('Quota exceeded for instances: Requested 1, but'",
            "                ' already used 10 of 10 instances')",
            "        self._do_test_create_instance_above_quota('instances', 0, 10, msg)",
            "",
            "    def test_create_instance_above_quota_ram(self):",
            "        msg = _('Quota exceeded for ram: Requested 4096, but'",
            "                ' already used 8192 of 10240 ram')",
            "        self._do_test_create_instance_above_quota('ram', 2048, 10 * 1024, msg)",
            "",
            "    def test_create_instance_above_quota_cores(self):",
            "        msg = _('Quota exceeded for cores: Requested 2, but'",
            "                ' already used 9 of 10 cores')",
            "        self._do_test_create_instance_above_quota('cores', 1, 10, msg)",
            "",
            "",
            "class TestServerCreateRequestXMLDeserializer(test.TestCase):",
            "",
            "    def setUp(self):",
            "        super(TestServerCreateRequestXMLDeserializer, self).setUp()",
            "        self.deserializer = servers.CreateDeserializer()",
            "",
            "    def test_minimal_request(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        imageRef=\"1\"",
            "        flavorRef=\"2\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"2\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_alternate_namespace_prefix(self):",
            "        serial_request = \"\"\"",
            "<ns2:server xmlns:ns2=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        imageRef=\"1\"",
            "        flavorRef=\"2\">",
            "        <ns2:metadata><ns2:meta key=\"hello\">world</ns2:meta></ns2:metadata>",
            "        </ns2:server>",
            "        \"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"2\",",
            "                'metadata': {\"hello\": \"world\"},",
            "                },",
            "            }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_scheduler_hints_and_alternate_namespace_prefix(self):",
            "        serial_request = \"\"\"",
            "<ns2:server xmlns:ns2=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\"",
            "     imageRef=\"1\"",
            "     flavorRef=\"2\">",
            "     <ns2:metadata><ns2:meta key=\"hello\">world</ns2:meta></ns2:metadata>",
            "     <os:scheduler_hints",
            "     xmlns:os=\"http://docs.openstack.org/compute/ext/scheduler-hints/api/v2\">",
            "             <hypervisor>xen</hypervisor>",
            "             <near>eb999657-dd6b-464e-8713-95c532ac3b18</near>",
            "     </os:scheduler_hints>",
            "     </ns2:server>",
            "        \"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                'OS-SCH-HNT:scheduler_hints': {",
            "                    'hypervisor': ['xen'],",
            "                    'near': ['eb999657-dd6b-464e-8713-95c532ac3b18']",
            "                },",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"2\",",
            "                \"metadata\": {",
            "                    \"hello\": \"world\"",
            "                }",
            "            }",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_access_ipv4(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        imageRef=\"1\"",
            "        flavorRef=\"2\"",
            "        accessIPv4=\"1.2.3.4\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"2\",",
            "                \"accessIPv4\": \"1.2.3.4\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_access_ipv6(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        imageRef=\"1\"",
            "        flavorRef=\"2\"",
            "        accessIPv6=\"fead::1234\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"2\",",
            "                \"accessIPv6\": \"fead::1234\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_access_ip(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        imageRef=\"1\"",
            "        flavorRef=\"2\"",
            "        accessIPv4=\"1.2.3.4\"",
            "        accessIPv6=\"fead::1234\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"2\",",
            "                \"accessIPv4\": \"1.2.3.4\",",
            "                \"accessIPv6\": \"fead::1234\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_admin_pass(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        imageRef=\"1\"",
            "        flavorRef=\"2\"",
            "        adminPass=\"1234\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"2\",",
            "                \"adminPass\": \"1234\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_image_link(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        imageRef=\"http://localhost:8774/v2/images/2\"",
            "        flavorRef=\"3\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"http://localhost:8774/v2/images/2\",",
            "                \"flavorRef\": \"3\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_flavor_link(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        imageRef=\"1\"",
            "        flavorRef=\"http://localhost:8774/v2/flavors/3\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"http://localhost:8774/v2/flavors/3\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_empty_metadata_personality(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        imageRef=\"1\"",
            "        flavorRef=\"2\">",
            "    <metadata/>",
            "    <personality/>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"2\",",
            "                \"metadata\": {},",
            "                \"personality\": [],",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_multiple_metadata_items(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        imageRef=\"1\"",
            "        flavorRef=\"2\">",
            "    <metadata>",
            "        <meta key=\"one\">two</meta>",
            "        <meta key=\"open\">snack</meta>",
            "    </metadata>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"2\",",
            "                \"metadata\": {\"one\": \"two\", \"open\": \"snack\"},",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_multiple_personality_files(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        imageRef=\"1\"",
            "        flavorRef=\"2\">",
            "    <personality>",
            "        <file path=\"/etc/banner.txt\">MQ==</file>",
            "        <file path=\"/etc/hosts\">Mg==</file>",
            "    </personality>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"2\",",
            "                \"personality\": [",
            "                    {\"path\": \"/etc/banner.txt\", \"contents\": \"MQ==\"},",
            "                    {\"path\": \"/etc/hosts\", \"contents\": \"Mg==\"},",
            "                ],",
            "            },",
            "        }",
            "        self.assertThat(request['body'], matchers.DictMatches(expected))",
            "",
            "    def test_spec_request(self):",
            "        image_bookmark_link = (\"http://servers.api.openstack.org/1234/\"",
            "                               \"images/52415800-8b69-11e0-9b19-734f6f006e54\")",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        imageRef=\"%s\"",
            "        flavorRef=\"52415800-8b69-11e0-9b19-734f1195ff37\"",
            "        name=\"new-server-test\">",
            "  <metadata>",
            "    <meta key=\"My Server Name\">Apache1</meta>",
            "  </metadata>",
            "  <personality>",
            "    <file path=\"/etc/banner.txt\">Mg==</file>",
            "  </personality>",
            "</server>\"\"\" % (image_bookmark_link)",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": (\"http://servers.api.openstack.org/1234/\"",
            "                             \"images/52415800-8b69-11e0-9b19-734f6f006e54\"),",
            "                \"flavorRef\": \"52415800-8b69-11e0-9b19-734f1195ff37\",",
            "                \"metadata\": {\"My Server Name\": \"Apache1\"},",
            "                \"personality\": [",
            "                    {",
            "                        \"path\": \"/etc/banner.txt\",",
            "                        \"contents\": \"Mg==\",",
            "                    },",
            "                ],",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_empty_networks(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "    <networks/>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"networks\": [],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_one_network(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "    <networks>",
            "       <network uuid=\"1\" fixed_ip=\"10.0.1.12\"/>",
            "    </networks>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\", \"fixed_ip\": \"10.0.1.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_two_networks(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "    <networks>",
            "       <network uuid=\"1\" fixed_ip=\"10.0.1.12\"/>",
            "       <network uuid=\"2\" fixed_ip=\"10.0.2.12\"/>",
            "    </networks>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\", \"fixed_ip\": \"10.0.1.12\"},",
            "                             {\"uuid\": \"2\", \"fixed_ip\": \"10.0.2.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_second_network_node_ignored(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "    <networks>",
            "       <network uuid=\"1\" fixed_ip=\"10.0.1.12\"/>",
            "    </networks>",
            "    <networks>",
            "       <network uuid=\"2\" fixed_ip=\"10.0.2.12\"/>",
            "    </networks>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\", \"fixed_ip\": \"10.0.1.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_one_network_missing_id(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "    <networks>",
            "       <network fixed_ip=\"10.0.1.12\"/>",
            "    </networks>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"networks\": [{\"fixed_ip\": \"10.0.1.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_one_network_missing_fixed_ip(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "    <networks>",
            "       <network uuid=\"1\"/>",
            "    </networks>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_one_network_empty_id(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "        <networks>",
            "           <network uuid=\"\" fixed_ip=\"10.0.1.12\"/>",
            "        </networks>",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"networks\": [{\"uuid\": \"\", \"fixed_ip\": \"10.0.1.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_one_network_empty_fixed_ip(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "        <networks>",
            "           <network uuid=\"1\" fixed_ip=\"\"/>",
            "        </networks>",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\", \"fixed_ip\": \"\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_networks_duplicate_ids(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "        <networks>",
            "           <network uuid=\"1\" fixed_ip=\"10.0.1.12\"/>",
            "           <network uuid=\"1\" fixed_ip=\"10.0.2.12\"/>",
            "        </networks>",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\", \"fixed_ip\": \"10.0.1.12\"},",
            "                             {\"uuid\": \"1\", \"fixed_ip\": \"10.0.2.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_availability_zone(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\"",
            "     availability_zone=\"some_zone:some_host\">",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"availability_zone\": \"some_zone:some_host\",",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_multiple_create_args(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\"",
            "     min_count=\"1\" max_count=\"3\" return_reservation_id=\"True\">",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"min_count\": \"1\",",
            "                \"max_count\": \"3\",",
            "                \"return_reservation_id\": True,",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_disk_config(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     xmlns:OS-DCF=\"http://docs.openstack.org/compute/ext/disk_config/api/v1.1\"",
            "     name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\"",
            "     OS-DCF:diskConfig=\"AUTO\">",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"OS-DCF:diskConfig\": \"AUTO\",",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_scheduler_hints(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     xmlns:OS-SCH-HNT=",
            "     \"http://docs.openstack.org/compute/ext/scheduler-hints/api/v2\"",
            "     name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "       <OS-SCH-HNT:scheduler_hints>",
            "         <different_host>",
            "           7329b667-50c7-46a6-b913-cb2a09dfeee0",
            "         </different_host>",
            "         <different_host>",
            "           f31efb24-34d2-43e1-8b44-316052956a39",
            "         </different_host>",
            "       </OS-SCH-HNT:scheduler_hints>",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"OS-SCH-HNT:scheduler_hints\": {",
            "                    \"different_host\": [",
            "                        \"7329b667-50c7-46a6-b913-cb2a09dfeee0\",",
            "                        \"f31efb24-34d2-43e1-8b44-316052956a39\",",
            "                    ]",
            "                }",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_block_device_mapping(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "       <block_device_mapping>",
            "         <mapping volume_id=\"7329b667-50c7-46a6-b913-cb2a09dfeee0\"",
            "          device_name=\"/dev/vda\" virtual_name=\"root\"",
            "          delete_on_termination=\"False\" />",
            "         <mapping snapshot_id=\"f31efb24-34d2-43e1-8b44-316052956a39\"",
            "          device_name=\"/dev/vdb\" virtual_name=\"ephemeral0\"",
            "          delete_on_termination=\"False\" />",
            "         <mapping device_name=\"/dev/vdc\" no_device=\"True\" />",
            "       </block_device_mapping>",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"block_device_mapping\": [",
            "                    {",
            "                        \"volume_id\": \"7329b667-50c7-46a6-b913-cb2a09dfeee0\",",
            "                        \"device_name\": \"/dev/vda\",",
            "                        \"virtual_name\": \"root\",",
            "                        \"delete_on_termination\": False,",
            "                    },",
            "                    {",
            "                        \"snapshot_id\": \"f31efb24-34d2-43e1-8b44-316052956a39\",",
            "                        \"device_name\": \"/dev/vdb\",",
            "                        \"virtual_name\": \"ephemeral0\",",
            "                        \"delete_on_termination\": False,",
            "                    },",
            "                    {",
            "                        \"device_name\": \"/dev/vdc\",",
            "                        \"no_device\": True,",
            "                    },",
            "                ]",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_config_drive(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"config_drive_test\"",
            "        imageRef=\"1\"",
            "        flavorRef=\"1\"",
            "        config_drive=\"true\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"config_drive_test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"config_drive\": \"true\"",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_corrupt_xml(self):",
            "        \"\"\"Should throw a 400 error on corrupt xml.\"\"\"",
            "        self.assertRaises(",
            "                exception.MalformedRequestBody,",
            "                self.deserializer.deserialize,",
            "                utils.killer_xml_body())",
            "",
            "",
            "class TestServerActionRequestXMLDeserializer(test.TestCase):",
            "",
            "    def setUp(self):",
            "        super(TestServerActionRequestXMLDeserializer, self).setUp()",
            "        self.deserializer = servers.ActionDeserializer()",
            "",
            "    def _generate_request(self, action, disk_cfg, ref):",
            "        return \"\"\"",
            "<%(action)s xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "   xmlns:OS-DCF=\"http://docs.openstack.org/compute/ext/disk_config/api/v1.1\"",
            "   %(disk_config)s=\"MANUAL\" %(ref)s=\"1\"/>\"\"\" % (",
            "               {'action': action, 'disk_config': disk_cfg, 'ref': ref})",
            "",
            "    def _generate_expected(self, action, ref):",
            "        return {",
            "            \"%s\" % action: {",
            "                \"%s\" % ref: \"1\",",
            "                \"OS-DCF:diskConfig\": \"MANUAL\",",
            "            },",
            "        }",
            "",
            "    def test_rebuild_request(self):",
            "        serial_request = self._generate_request(\"rebuild\", \"OS-DCF:diskConfig\",",
            "                                                \"imageRef\")",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = self._generate_expected(\"rebuild\", \"imageRef\")",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_rebuild_request_auto_disk_config_compat(self):",
            "        serial_request = self._generate_request(\"rebuild\", \"auto_disk_config\",",
            "                                                \"imageRef\")",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = self._generate_expected(\"rebuild\", \"imageRef\")",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_resize_request(self):",
            "        serial_request = self._generate_request(\"resize\", \"OS-DCF:diskConfig\",",
            "                                                \"flavorRef\")",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = self._generate_expected(\"resize\", \"flavorRef\")",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_resize_request_auto_disk_config_compat(self):",
            "        serial_request = self._generate_request(\"resize\", \"auto_disk_config\",",
            "                                                \"flavorRef\")",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = self._generate_expected(\"resize\", \"flavorRef\")",
            "        self.assertEquals(request['body'], expected)",
            "",
            "",
            "class TestAddressesXMLSerialization(test.TestCase):",
            "",
            "    index_serializer = ips.AddressesTemplate()",
            "    show_serializer = ips.NetworkTemplate()",
            "",
            "    def _serializer_test_data(self):",
            "        return {",
            "            'network_2': [",
            "                {'addr': '192.168.0.1', 'version': 4},",
            "                {'addr': 'fe80::beef', 'version': 6},",
            "            ],",
            "        }",
            "",
            "    def test_xml_declaration(self):",
            "        output = self.show_serializer.serialize(self._serializer_test_data())",
            "        has_dec = output.startswith(\"<?xml version='1.0' encoding='UTF-8'?>\")",
            "        self.assertTrue(has_dec)",
            "",
            "    def test_show(self):",
            "        output = self.show_serializer.serialize(self._serializer_test_data())",
            "        root = etree.XML(output)",
            "        network = self._serializer_test_data()['network_2']",
            "        self.assertEqual(str(root.get('id')), 'network_2')",
            "        ip_elems = root.findall('{0}ip'.format(NS))",
            "        for z, ip_elem in enumerate(ip_elems):",
            "            ip = network[z]",
            "            self.assertEqual(str(ip_elem.get('version')),",
            "                             str(ip['version']))",
            "            self.assertEqual(str(ip_elem.get('addr')),",
            "                             str(ip['addr']))",
            "",
            "    def test_index(self):",
            "        fixture = {",
            "            'addresses': {",
            "                'network_1': [",
            "                    {'addr': '192.168.0.3', 'version': 4},",
            "                    {'addr': '192.168.0.5', 'version': 4},",
            "                ],",
            "                'network_2': [",
            "                    {'addr': '192.168.0.1', 'version': 4},",
            "                    {'addr': 'fe80::beef', 'version': 6},",
            "                ],",
            "            },",
            "        }",
            "        output = self.index_serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'addresses')",
            "        addresses_dict = fixture['addresses']",
            "        network_elems = root.findall('{0}network'.format(NS))",
            "        self.assertEqual(len(network_elems), 2)",
            "        for i, network_elem in enumerate(network_elems):",
            "            network = addresses_dict.items()[i]",
            "            self.assertEqual(str(network_elem.get('id')), str(network[0]))",
            "            ip_elems = network_elem.findall('{0}ip'.format(NS))",
            "            for z, ip_elem in enumerate(ip_elems):",
            "                ip = network[1][z]",
            "                self.assertEqual(str(ip_elem.get('version')),",
            "                                 str(ip['version']))",
            "                self.assertEqual(str(ip_elem.get('addr')),",
            "                                 str(ip['addr']))",
            "",
            "",
            "class ServersViewBuilderTest(test.TestCase):",
            "",
            "    image_bookmark = \"http://localhost/fake/images/5\"",
            "    flavor_bookmark = \"http://localhost/fake/flavors/1\"",
            "",
            "    def setUp(self):",
            "        super(ServersViewBuilderTest, self).setUp()",
            "        self.flags(use_ipv6=True)",
            "        self.instance = fakes.stub_instance(",
            "            id=1,",
            "            image_ref=\"5\",",
            "            uuid=\"deadbeef-feed-edee-beef-d0ea7beefedd\",",
            "            display_name=\"test_server\",",
            "            include_fake_metadata=False)",
            "",
            "        privates = ['172.19.0.1']",
            "        publics = ['192.168.0.3']",
            "        public6s = ['b33f::fdee:ddff:fecc:bbaa']",
            "",
            "        def nw_info(*args, **kwargs):",
            "            return [(None, {'label': 'public',",
            "                            'ips': [dict(ip=ip) for ip in publics],",
            "                            'ip6s': [dict(ip=ip) for ip in public6s]}),",
            "                    (None, {'label': 'private',",
            "                            'ips': [dict(ip=ip) for ip in privates]})]",
            "",
            "        def floaters(*args, **kwargs):",
            "            return []",
            "",
            "        fakes.stub_out_nw_api_get_instance_nw_info(self.stubs, nw_info)",
            "        fakes.stub_out_nw_api_get_floating_ips_by_fixed_address(self.stubs,",
            "                                                                floaters)",
            "",
            "        self.uuid = self.instance['uuid']",
            "        self.view_builder = views.servers.ViewBuilder()",
            "        self.request = fakes.HTTPRequest.blank(\"/v2/fake\")",
            "        self.self_link = \"http://localhost/v2/fake/servers/%s\" % self.uuid",
            "        self.bookmark_link = \"http://localhost/fake/servers/%s\" % self.uuid",
            "        self.expected_detailed_server = {",
            "            \"server\": {",
            "                \"id\": self.uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"accessIPv4\": \"\",",
            "                \"accessIPv6\": \"\",",
            "                \"hostId\": '',",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                  \"links\": [",
            "                                            {",
            "                          \"rel\": \"bookmark\",",
            "                          \"href\": self.flavor_bookmark,",
            "                      },",
            "                  ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1'}",
            "                    ]",
            "                },",
            "                \"metadata\": {},",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": self.self_link,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": self.bookmark_link,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        self.expected_server = {",
            "            \"server\": {",
            "                \"id\": self.uuid,",
            "                \"name\": \"test_server\",",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": self.self_link,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": self.bookmark_link,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "    def test_get_flavor_valid_flavor(self):",
            "        expected = {\"id\": \"1\",",
            "                    \"links\": [{\"rel\": \"bookmark\",",
            "                               \"href\": self.flavor_bookmark}]}",
            "        result = self.view_builder._get_flavor(self.request, self.instance)",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_build_server(self):",
            "        output = self.view_builder.basic(self.request, self.instance)",
            "        self.assertThat(output,",
            "                matchers.DictMatches(self.expected_server))",
            "",
            "    def test_build_server_with_project_id(self):",
            "",
            "        output = self.view_builder.basic(self.request, self.instance)",
            "        self.assertThat(output,",
            "                matchers.DictMatches(self.expected_server))",
            "",
            "    def test_build_server_detail(self):",
            "",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output,",
            "                matchers.DictMatches(self.expected_detailed_server))",
            "",
            "    def test_build_server_no_image(self):",
            "        self.instance[\"image_ref\"] = \"\"",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertEqual(output['server']['image'], \"\")",
            "",
            "    def test_build_server_detail_with_fault(self):",
            "        self.instance['vm_state'] = vm_states.ERROR",
            "        self.instance['fault'] = {",
            "            'code': 404,",
            "            'instance_uuid': self.uuid,",
            "            'message': \"HTTPNotFound\",",
            "            'details': \"Stock details for test\",",
            "            'created_at': datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "        }",
            "",
            "        self.expected_detailed_server[\"server\"][\"status\"] = \"ERROR\"",
            "        self.expected_detailed_server[\"server\"][\"fault\"] = {",
            "                    \"code\": 404,",
            "                    \"created\": \"2010-10-10T12:00:00Z\",",
            "                    \"message\": \"HTTPNotFound\",",
            "                    \"details\": \"Stock details for test\",",
            "                }",
            "        del self.expected_detailed_server[\"server\"][\"progress\"]",
            "",
            "        self.request.context = context.RequestContext('fake', 'fake')",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output,",
            "                matchers.DictMatches(self.expected_detailed_server))",
            "",
            "    def test_build_server_detail_with_fault_no_details_not_admin(self):",
            "        self.instance['vm_state'] = vm_states.ERROR",
            "        self.instance['fault'] = {",
            "            'code': 500,",
            "            'instance_uuid': self.uuid,",
            "            'message': \"Error\",",
            "            'details': 'Stock details for test',",
            "            'created_at': datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "        }",
            "",
            "        expected_fault = {\"code\": 500,",
            "                          \"created\": \"2010-10-10T12:00:00Z\",",
            "                          \"message\": \"Error\"}",
            "",
            "        self.request.context = context.RequestContext('fake', 'fake')",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output['server']['fault'],",
            "                        matchers.DictMatches(expected_fault))",
            "",
            "    def test_build_server_detail_with_fault_admin(self):",
            "        self.instance['vm_state'] = vm_states.ERROR",
            "        self.instance['fault'] = {",
            "            'code': 500,",
            "            'instance_uuid': self.uuid,",
            "            'message': \"Error\",",
            "            'details': 'Stock details for test',",
            "            'created_at': datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "        }",
            "",
            "        expected_fault = {\"code\": 500,",
            "                          \"created\": \"2010-10-10T12:00:00Z\",",
            "                          \"message\": \"Error\",",
            "                          'details': 'Stock details for test'}",
            "",
            "        self.request.environ['nova.context'].is_admin = True",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output['server']['fault'],",
            "                        matchers.DictMatches(expected_fault))",
            "",
            "    def test_build_server_detail_with_fault_no_details_admin(self):",
            "        self.instance['vm_state'] = vm_states.ERROR",
            "        self.instance['fault'] = {",
            "            'code': 500,",
            "            'instance_uuid': self.uuid,",
            "            'message': \"Error\",",
            "            'details': '',",
            "            'created_at': datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "        }",
            "",
            "        expected_fault = {\"code\": 500,",
            "                          \"created\": \"2010-10-10T12:00:00Z\",",
            "                          \"message\": \"Error\"}",
            "",
            "        self.request.environ['nova.context'].is_admin = True",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output['server']['fault'],",
            "                        matchers.DictMatches(expected_fault))",
            "",
            "    def test_build_server_detail_with_fault_but_active(self):",
            "        self.instance['vm_state'] = vm_states.ACTIVE",
            "        self.instance['progress'] = 100",
            "        self.instance['fault'] = {",
            "            'code': 404,",
            "            'instance_uuid': self.uuid,",
            "            'message': \"HTTPNotFound\",",
            "            'details': \"Stock details for test\",",
            "            'created_at': datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "        }",
            "",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertFalse('fault' in output['server'])",
            "",
            "    def test_build_server_detail_active_status(self):",
            "        #set the power state of the instance to running",
            "        self.instance['vm_state'] = vm_states.ACTIVE",
            "        self.instance['progress'] = 100",
            "",
            "        self.expected_detailed_server[\"server\"][\"status\"] = \"ACTIVE\"",
            "        self.expected_detailed_server[\"server\"][\"progress\"] = 100",
            "",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output,",
            "                matchers.DictMatches(self.expected_detailed_server))",
            "",
            "    def test_build_server_detail_with_accessipv4(self):",
            "",
            "        access_ip_v4 = '1.2.3.4'",
            "        self.instance['access_ip_v4'] = access_ip_v4",
            "",
            "        self.expected_detailed_server[\"server\"][\"accessIPv4\"] = access_ip_v4",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output,",
            "                matchers.DictMatches(self.expected_detailed_server))",
            "",
            "    def test_build_server_detail_with_accessipv6(self):",
            "",
            "        access_ip_v6 = 'fead::1234'",
            "        self.instance['access_ip_v6'] = access_ip_v6",
            "",
            "        self.expected_detailed_server[\"server\"][\"accessIPv6\"] = access_ip_v6",
            "",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output,",
            "                matchers.DictMatches(self.expected_detailed_server))",
            "",
            "    def test_build_server_detail_with_metadata(self):",
            "",
            "        metadata = []",
            "        metadata.append(models.InstanceMetadata(key=\"Open\", value=\"Stack\"))",
            "        self.instance['metadata'] = metadata",
            "",
            "        self.expected_detailed_server[\"server\"][\"metadata\"] = {\"Open\": \"Stack\"}",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output,",
            "                matchers.DictMatches(self.expected_detailed_server))",
            "",
            "",
            "class ServerXMLSerializationTest(test.TestCase):",
            "",
            "    TIMESTAMP = \"2010-10-11T10:30:22Z\"",
            "    SERVER_HREF = 'http://localhost/v2/servers/%s' % FAKE_UUID",
            "    SERVER_NEXT = 'http://localhost/v2/servers?limit=%s&marker=%s'",
            "    SERVER_BOOKMARK = 'http://localhost/servers/%s' % FAKE_UUID",
            "    IMAGE_BOOKMARK = 'http://localhost/images/5'",
            "    FLAVOR_BOOKMARK = 'http://localhost/flavors/1'",
            "    USERS_ATTRIBUTES = ['name', 'id', 'created', 'accessIPv4',",
            "                    'updated', 'progress', 'status', 'hostId',",
            "                    'accessIPv6']",
            "    ADMINS_ATTRIBUTES = USERS_ATTRIBUTES + ['adminPass']",
            "",
            "    def setUp(self):",
            "        super(ServerXMLSerializationTest, self).setUp()",
            "        self.body = {",
            "            \"server\": {",
            "                'id': FAKE_UUID,",
            "                'user_id': 'fake_user_id',",
            "                'tenant_id': 'fake_tenant_id',",
            "                'created': self.TIMESTAMP,",
            "                'updated': self.TIMESTAMP,",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"hostId\": 'e4d909c290d0fb1ca068ffaddf22cbd0',",
            "                \"accessIPv4\": \"1.2.3.4\",",
            "                \"accessIPv6\": \"fead::1234\",",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.IMAGE_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.FLAVOR_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    \"network_one\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.138\",",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.138\",",
            "                        },",
            "                    ],",
            "                    \"network_two\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.139\",",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.139\",",
            "                        },",
            "                    ],",
            "                },",
            "                \"metadata\": {",
            "                    \"Open\": \"Stack\",",
            "                    \"Number\": \"1\",",
            "                },",
            "                'links': [",
            "                    {",
            "                        'href': self.SERVER_HREF,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': self.SERVER_BOOKMARK,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "    def _validate_xml(self, root, server_dict):",
            "",
            "        link_nodes = root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 2)",
            "        for i, link in enumerate(server_dict['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        metadata_root = root.find('{0}metadata'.format(NS))",
            "        metadata_elems = metadata_root.findall('{0}meta'.format(NS))",
            "        self.assertEqual(len(metadata_elems), 2)",
            "        for i, metadata_elem in enumerate(metadata_elems):",
            "            (meta_key, meta_value) = server_dict['metadata'].items()[i]",
            "            self.assertEqual(str(metadata_elem.get('key')), str(meta_key))",
            "            self.assertEqual(str(metadata_elem.text).strip(), str(meta_value))",
            "",
            "        image_root = root.find('{0}image'.format(NS))",
            "        self.assertEqual(image_root.get('id'), server_dict['image']['id'])",
            "        link_nodes = image_root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 1)",
            "        for i, link in enumerate(server_dict['image']['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        flavor_root = root.find('{0}flavor'.format(NS))",
            "        self.assertEqual(flavor_root.get('id'), server_dict['flavor']['id'])",
            "        link_nodes = flavor_root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 1)",
            "        for i, link in enumerate(server_dict['flavor']['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        addresses_root = root.find('{0}addresses'.format(NS))",
            "        addresses_dict = server_dict['addresses']",
            "        network_elems = addresses_root.findall('{0}network'.format(NS))",
            "        self.assertEqual(len(network_elems), 2)",
            "        for i, network_elem in enumerate(network_elems):",
            "            network = addresses_dict.items()[i]",
            "            self.assertEqual(str(network_elem.get('id')), str(network[0]))",
            "            ip_elems = network_elem.findall('{0}ip'.format(NS))",
            "            for z, ip_elem in enumerate(ip_elems):",
            "                ip = network[1][z]",
            "                self.assertEqual(str(ip_elem.get('version')),",
            "                                 str(ip['version']))",
            "                self.assertEqual(str(ip_elem.get('addr')),",
            "                                 str(ip['addr']))",
            "",
            "    def _validate_required_attributes(self, root, server_dict, attributes):",
            "        for key in attributes:",
            "            self.assertEqual(root.get(key), str(server_dict[key]))",
            "",
            "    def test_xml_declaration(self):",
            "        serializer = servers.ServerTemplate()",
            "",
            "        output = serializer.serialize(self.body)",
            "        has_dec = output.startswith(\"<?xml version='1.0' encoding='UTF-8'?>\")",
            "        self.assertTrue(has_dec)",
            "",
            "    def test_show(self):",
            "        serializer = servers.ServerTemplate()",
            "",
            "        output = serializer.serialize(self.body)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'server')",
            "",
            "        server_dict = self.body['server']",
            "",
            "        self._validate_required_attributes(root, server_dict,",
            "                self.USERS_ATTRIBUTES)",
            "        self._validate_xml(root, server_dict)",
            "",
            "    def test_create(self):",
            "        serializer = servers.FullServerTemplate()",
            "",
            "        self.body[\"server\"][\"adminPass\"] = \"test_password\"",
            "",
            "        output = serializer.serialize(self.body)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'server')",
            "",
            "        server_dict = self.body['server']",
            "",
            "        self._validate_required_attributes(root, server_dict,",
            "                self.ADMINS_ATTRIBUTES)",
            "        self._validate_xml(root, server_dict)",
            "",
            "    def test_index(self):",
            "        serializer = servers.MinimalServersTemplate()",
            "",
            "        uuid1 = fakes.get_fake_uuid(1)",
            "        uuid2 = fakes.get_fake_uuid(2)",
            "        expected_server_href = 'http://localhost/v2/servers/%s' % uuid1",
            "        expected_server_bookmark = 'http://localhost/servers/%s' % uuid1",
            "        expected_server_href_2 = 'http://localhost/v2/servers/%s' % uuid2",
            "        expected_server_bookmark_2 = 'http://localhost/servers/%s' % uuid2",
            "        fixture = {\"servers\": [",
            "            {",
            "                \"id\": fakes.get_fake_uuid(1),",
            "                \"name\": \"test_server\",",
            "                'links': [",
            "                    {",
            "                        'href': expected_server_href,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': expected_server_bookmark,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            },",
            "            {",
            "                \"id\": fakes.get_fake_uuid(2),",
            "                \"name\": \"test_server_2\",",
            "                'links': [",
            "                    {",
            "                        'href': expected_server_href_2,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': expected_server_bookmark_2,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            },",
            "        ]}",
            "",
            "        output = serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'servers_index')",
            "        server_elems = root.findall('{0}server'.format(NS))",
            "        self.assertEqual(len(server_elems), 2)",
            "        for i, server_elem in enumerate(server_elems):",
            "            server_dict = fixture['servers'][i]",
            "            for key in ['name', 'id']:",
            "                self.assertEqual(server_elem.get(key), str(server_dict[key]))",
            "",
            "            link_nodes = server_elem.findall('{0}link'.format(ATOMNS))",
            "            self.assertEqual(len(link_nodes), 2)",
            "            for i, link in enumerate(server_dict['links']):",
            "                for key, value in link.items():",
            "                    self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "    def test_index_with_servers_links(self):",
            "        serializer = servers.MinimalServersTemplate()",
            "",
            "        uuid1 = fakes.get_fake_uuid(1)",
            "        uuid2 = fakes.get_fake_uuid(2)",
            "        expected_server_href = 'http://localhost/v2/servers/%s' % uuid1",
            "        expected_server_next = self.SERVER_NEXT % (2, 2)",
            "        expected_server_bookmark = 'http://localhost/servers/%s' % uuid1",
            "        expected_server_href_2 = 'http://localhost/v2/servers/%s' % uuid2",
            "        expected_server_bookmark_2 = 'http://localhost/servers/%s' % uuid2",
            "        fixture = {\"servers\": [",
            "            {",
            "                \"id\": fakes.get_fake_uuid(1),",
            "                \"name\": \"test_server\",",
            "                'links': [",
            "                    {",
            "                        'href': expected_server_href,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': expected_server_bookmark,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            },",
            "            {",
            "                \"id\": fakes.get_fake_uuid(2),",
            "                \"name\": \"test_server_2\",",
            "                'links': [",
            "                    {",
            "                        'href': expected_server_href_2,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': expected_server_bookmark_2,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            },",
            "        ],",
            "        \"servers_links\": [",
            "            {",
            "                'rel': 'next',",
            "                'href': expected_server_next,",
            "            },",
            "        ]}",
            "",
            "        output = serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'servers_index')",
            "        server_elems = root.findall('{0}server'.format(NS))",
            "        self.assertEqual(len(server_elems), 2)",
            "        for i, server_elem in enumerate(server_elems):",
            "            server_dict = fixture['servers'][i]",
            "            for key in ['name', 'id']:",
            "                self.assertEqual(server_elem.get(key), str(server_dict[key]))",
            "",
            "            link_nodes = server_elem.findall('{0}link'.format(ATOMNS))",
            "            self.assertEqual(len(link_nodes), 2)",
            "            for i, link in enumerate(server_dict['links']):",
            "                for key, value in link.items():",
            "                    self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        # Check servers_links",
            "        servers_links = root.findall('{0}link'.format(ATOMNS))",
            "        for i, link in enumerate(fixture['servers_links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(servers_links[i].get(key), value)",
            "",
            "    def test_detail(self):",
            "        serializer = servers.ServersTemplate()",
            "",
            "        uuid1 = fakes.get_fake_uuid(1)",
            "        expected_server_href = 'http://localhost/v2/servers/%s' % uuid1",
            "        expected_server_bookmark = 'http://localhost/servers/%s' % uuid1",
            "        expected_image_bookmark = self.IMAGE_BOOKMARK",
            "        expected_flavor_bookmark = self.FLAVOR_BOOKMARK",
            "",
            "        uuid2 = fakes.get_fake_uuid(2)",
            "        expected_server_href_2 = 'http://localhost/v2/servers/%s' % uuid2",
            "        expected_server_bookmark_2 = 'http://localhost/servers/%s' % uuid2",
            "        fixture = {\"servers\": [",
            "            {",
            "                \"id\": fakes.get_fake_uuid(1),",
            "                \"user_id\": \"fake\",",
            "                \"tenant_id\": \"fake\",",
            "                'created': self.TIMESTAMP,",
            "                'updated': self.TIMESTAMP,",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"accessIPv4\": \"1.2.3.4\",",
            "                \"accessIPv6\": \"fead::1234\",",
            "                \"hostId\": 'e4d909c290d0fb1ca068ffaddf22cbd0',",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": expected_image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": expected_flavor_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    \"network_one\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.138\",",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.138\",",
            "                        },",
            "                    ],",
            "                    \"network_two\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.139\",",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.139\",",
            "                        },",
            "                    ],",
            "                },",
            "                \"metadata\": {",
            "                    \"Open\": \"Stack\",",
            "                    \"Number\": \"1\",",
            "                },",
            "                \"links\": [",
            "                    {",
            "                        \"href\": expected_server_href,",
            "                        \"rel\": \"self\",",
            "                    },",
            "                    {",
            "                        \"href\": expected_server_bookmark,",
            "                        \"rel\": \"bookmark\",",
            "                    },",
            "                ],",
            "            },",
            "            {",
            "                \"id\": fakes.get_fake_uuid(2),",
            "                \"user_id\": 'fake',",
            "                \"tenant_id\": 'fake',",
            "                'created': self.TIMESTAMP,",
            "                'updated': self.TIMESTAMP,",
            "                \"progress\": 100,",
            "                \"name\": \"test_server_2\",",
            "                \"status\": \"ACTIVE\",",
            "                \"accessIPv4\": \"1.2.3.4\",",
            "                \"accessIPv6\": \"fead::1234\",",
            "                \"hostId\": 'e4d909c290d0fb1ca068ffaddf22cbd0',",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": expected_image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": expected_flavor_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    \"network_one\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.138\",",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.138\",",
            "                        },",
            "                    ],",
            "                    \"network_two\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.139\",",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.139\",",
            "                        },",
            "                    ],",
            "                },",
            "                \"metadata\": {",
            "                    \"Open\": \"Stack\",",
            "                    \"Number\": \"2\",",
            "                },",
            "                \"links\": [",
            "                    {",
            "                        \"href\": expected_server_href_2,",
            "                        \"rel\": \"self\",",
            "                    },",
            "                    {",
            "                        \"href\": expected_server_bookmark_2,",
            "                        \"rel\": \"bookmark\",",
            "                    },",
            "                ],",
            "            },",
            "        ]}",
            "",
            "        output = serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'servers')",
            "        server_elems = root.findall('{0}server'.format(NS))",
            "        self.assertEqual(len(server_elems), 2)",
            "        for i, server_elem in enumerate(server_elems):",
            "            server_dict = fixture['servers'][i]",
            "            self._validate_required_attributes(server_elem, server_dict,",
            "                    self.USERS_ATTRIBUTES)",
            "            self._validate_xml(server_elem, server_dict)",
            "",
            "    def test_update(self):",
            "        serializer = servers.ServerTemplate()",
            "",
            "        self.body[\"server\"][\"fault\"] = {",
            "                    \"code\": 500,",
            "                    \"created\": self.TIMESTAMP,",
            "                    \"message\": \"Error Message\",",
            "                    \"details\": \"Fault details\",",
            "                }",
            "        output = serializer.serialize(self.body)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'server')",
            "",
            "        server_dict = self.body['server']",
            "",
            "        self._validate_required_attributes(root, server_dict,",
            "                self.USERS_ATTRIBUTES)",
            "",
            "        self._validate_xml(root, server_dict)",
            "        fault_root = root.find('{0}fault'.format(NS))",
            "        fault_dict = server_dict['fault']",
            "        self.assertEqual(fault_root.get(\"code\"), str(fault_dict[\"code\"]))",
            "        self.assertEqual(fault_root.get(\"created\"), fault_dict[\"created\"])",
            "        msg_elem = fault_root.find('{0}message'.format(NS))",
            "        self.assertEqual(msg_elem.text, fault_dict[\"message\"])",
            "        det_elem = fault_root.find('{0}details'.format(NS))",
            "        self.assertEqual(det_elem.text, fault_dict[\"details\"])",
            "",
            "    def test_action(self):",
            "        serializer = servers.FullServerTemplate()",
            "",
            "        self.body[\"server\"][\"adminPass\"] = \"test_password\"",
            "        output = serializer.serialize(self.body)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'server')",
            "",
            "        server_dict = self.body['server']",
            "",
            "        self._validate_required_attributes(root, server_dict,",
            "                self.ADMINS_ATTRIBUTES)",
            "",
            "        self._validate_xml(root, server_dict)",
            "",
            "",
            "class ServersAllExtensionsTestCase(test.TestCase):",
            "    \"\"\"",
            "    Servers tests using default API router with all extensions enabled.",
            "",
            "    The intent here is to catch cases where extensions end up throwing",
            "    an exception because of a malformed request before the core API",
            "    gets a chance to validate the request and return a 422 response.",
            "",
            "    For example, ServerDiskConfigController extends servers.Controller:",
            "",
            "      @wsgi.extends",
            "      def create(self, req, body):",
            "          if 'server' in body:",
            "                self._set_disk_config(body['server'])",
            "          resp_obj = (yield)",
            "          self._show(req, resp_obj)",
            "",
            "    we want to ensure that the extension isn't barfing on an invalid",
            "    body.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        super(ServersAllExtensionsTestCase, self).setUp()",
            "        self.app = compute.APIRouter()",
            "",
            "    def test_create_missing_server(self):",
            "        # Test create with malformed body.",
            "",
            "        def fake_create(*args, **kwargs):",
            "            raise test.TestingException(\"Should not reach the compute API.\")",
            "",
            "        self.stubs.Set(compute_api.API, 'create', fake_create)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers')",
            "        req.method = 'POST'",
            "        req.content_type = 'application/json'",
            "        body = {'foo': {'a': 'b'}}",
            "",
            "        req.body = jsonutils.dumps(body)",
            "        res = req.get_response(self.app)",
            "        self.assertEqual(422, res.status_int)",
            "",
            "    def test_update_missing_server(self):",
            "        # Test create with malformed body.",
            "",
            "        def fake_update(*args, **kwargs):",
            "            raise test.TestingException(\"Should not reach the compute API.\")",
            "",
            "        self.stubs.Set(compute_api.API, 'create', fake_update)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers/1')",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        body = {'foo': {'a': 'b'}}",
            "",
            "        req.body = jsonutils.dumps(body)",
            "        res = req.get_response(self.app)",
            "        self.assertEqual(422, res.status_int)",
            "",
            "",
            "class ServersUnprocessableEntityTestCase(test.TestCase):",
            "    \"\"\"",
            "    Tests of places we throw 422 Unprocessable Entity from",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        super(ServersUnprocessableEntityTestCase, self).setUp()",
            "        self.ext_mgr = extensions.ExtensionManager()",
            "        self.ext_mgr.extensions = {}",
            "        self.controller = servers.Controller(self.ext_mgr)",
            "",
            "    def _unprocessable_server_create(self, body):",
            "        req = fakes.HTTPRequest.blank('/fake/servers')",
            "        req.method = 'POST'",
            "",
            "        self.assertRaises(webob.exc.HTTPUnprocessableEntity,",
            "                          self.controller.create, req, body)",
            "",
            "    def test_create_server_no_body(self):",
            "        self._unprocessable_server_create(body=None)",
            "",
            "    def test_create_server_missing_server(self):",
            "        body = {'foo': {'a': 'b'}}",
            "        self._unprocessable_server_create(body=body)",
            "",
            "    def test_create_server_malformed_entity(self):",
            "        body = {'server': 'string'}",
            "        self._unprocessable_server_create(body=body)",
            "",
            "    def _unprocessable_server_update(self, body):",
            "        req = fakes.HTTPRequest.blank('/fake/servers/%s' % FAKE_UUID)",
            "        req.method = 'PUT'",
            "",
            "        self.assertRaises(webob.exc.HTTPUnprocessableEntity,",
            "                          self.controller.update, req, FAKE_UUID, body)",
            "",
            "    def test_update_server_no_body(self):",
            "        self._unprocessable_server_update(body=None)",
            "",
            "    def test_update_server_missing_server(self):",
            "        body = {'foo': {'a': 'b'}}",
            "        self._unprocessable_server_update(body=body)",
            "",
            "    def test_create_update_malformed_entity(self):",
            "        body = {'server': 'string'}",
            "        self._unprocessable_server_update(body=body)"
        ],
        "afterPatchFile": [
            "# vim: tabstop=4 shiftwidth=4 softtabstop=4",
            "",
            "# Copyright 2010-2011 OpenStack Foundation",
            "# Copyright 2011 Piston Cloud Computing, Inc.",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "import base64",
            "import datetime",
            "import testtools",
            "import urlparse",
            "import uuid",
            "",
            "import iso8601",
            "from lxml import etree",
            "import mox",
            "from oslo.config import cfg",
            "import webob",
            "",
            "from nova.api.openstack import compute",
            "from nova.api.openstack.compute import ips",
            "from nova.api.openstack.compute import servers",
            "from nova.api.openstack.compute import views",
            "from nova.api.openstack import extensions",
            "from nova.api.openstack import xmlutil",
            "from nova import block_device",
            "from nova.compute import api as compute_api",
            "from nova.compute import flavors",
            "from nova.compute import task_states",
            "from nova.compute import vm_states",
            "from nova import context",
            "from nova import db",
            "from nova.db.sqlalchemy import models",
            "from nova import exception",
            "from nova.image import glance",
            "from nova.network import manager",
            "from nova.network.neutronv2 import api as neutron_api",
            "from nova.objects import instance as instance_obj",
            "from nova.openstack.common.gettextutils import _",
            "from nova.openstack.common import jsonutils",
            "from nova.openstack.common import policy as common_policy",
            "from nova.openstack.common import rpc",
            "from nova import policy",
            "from nova import test",
            "from nova.tests.api.openstack import fakes",
            "from nova.tests import fake_instance",
            "from nova.tests import fake_network",
            "from nova.tests.image import fake",
            "from nova.tests import matchers",
            "from nova.tests import utils",
            "",
            "CONF = cfg.CONF",
            "CONF.import_opt('password_length', 'nova.utils')",
            "CONF.import_opt('scheduler_topic', 'nova.scheduler.rpcapi')",
            "",
            "FAKE_UUID = fakes.FAKE_UUID",
            "NS = \"{http://docs.openstack.org/compute/api/v1.1}\"",
            "ATOMNS = \"{http://www.w3.org/2005/Atom}\"",
            "XPATH_NS = {",
            "    'atom': 'http://www.w3.org/2005/Atom',",
            "    'ns': 'http://docs.openstack.org/compute/api/v1.1'",
            "}",
            "",
            "INSTANCE_IDS = {FAKE_UUID: 1}",
            "",
            "FIELDS = instance_obj.INSTANCE_DEFAULT_FIELDS",
            "",
            "",
            "def fake_gen_uuid():",
            "    return FAKE_UUID",
            "",
            "",
            "def return_servers_empty(context, *args, **kwargs):",
            "    return []",
            "",
            "",
            "def return_security_group(context, instance_id, security_group_id):",
            "    pass",
            "",
            "",
            "def instance_update(context, instance_uuid, values, update_cells=True):",
            "    inst = fakes.stub_instance(INSTANCE_IDS.get(instance_uuid),",
            "                               name=values.get('display_name'))",
            "    inst = dict(inst, **values)",
            "    return (inst, inst)",
            "",
            "",
            "def fake_compute_api(cls, req, id):",
            "    return True",
            "",
            "",
            "class MockSetAdminPassword(object):",
            "    def __init__(self):",
            "        self.instance_id = None",
            "        self.password = None",
            "",
            "    def __call__(self, context, instance_id, password):",
            "        self.instance_id = instance_id",
            "        self.password = password",
            "",
            "",
            "class Base64ValidationTest(test.TestCase):",
            "    def setUp(self):",
            "        super(Base64ValidationTest, self).setUp()",
            "        self.ext_mgr = extensions.ExtensionManager()",
            "        self.ext_mgr.extensions = {}",
            "        self.controller = servers.Controller(self.ext_mgr)",
            "",
            "    def test_decode_base64(self):",
            "        value = \"A random string\"",
            "        result = self.controller._decode_base64(base64.b64encode(value))",
            "        self.assertEqual(result, value)",
            "",
            "    def test_decode_base64_binary(self):",
            "        value = \"\\x00\\x12\\x75\\x99\"",
            "        result = self.controller._decode_base64(base64.b64encode(value))",
            "        self.assertEqual(result, value)",
            "",
            "    def test_decode_base64_whitespace(self):",
            "        value = \"A random string\"",
            "        encoded = base64.b64encode(value)",
            "        white = \"\\n \\n%s\\t%s\\n\" % (encoded[:2], encoded[2:])",
            "        result = self.controller._decode_base64(white)",
            "        self.assertEqual(result, value)",
            "",
            "    def test_decode_base64_invalid(self):",
            "        invalid = \"A random string\"",
            "        result = self.controller._decode_base64(invalid)",
            "        self.assertEqual(result, None)",
            "",
            "    def test_decode_base64_illegal_bytes(self):",
            "        value = \"A random string\"",
            "        encoded = base64.b64encode(value)",
            "        white = \">\\x01%s*%s()\" % (encoded[:2], encoded[2:])",
            "        result = self.controller._decode_base64(white)",
            "        self.assertEqual(result, None)",
            "",
            "",
            "class NeutronV2Subclass(neutron_api.API):",
            "    \"\"\"Used to ensure that API handles subclasses properly.\"\"\"",
            "    pass",
            "",
            "",
            "class ControllerTest(test.TestCase):",
            "",
            "    def setUp(self):",
            "        super(ControllerTest, self).setUp()",
            "        self.flags(verbose=True, use_ipv6=False)",
            "        fakes.stub_out_rate_limiting(self.stubs)",
            "        fakes.stub_out_key_pair_funcs(self.stubs)",
            "        fake.stub_out_image_service(self.stubs)",
            "        return_server = fakes.fake_instance_get()",
            "        return_servers = fakes.fake_instance_get_all_by_filters()",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       return_servers)",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                       return_server)",
            "        self.stubs.Set(db, 'instance_add_security_group',",
            "                       return_security_group)",
            "        self.stubs.Set(db, 'instance_update_and_get_original',",
            "                       instance_update)",
            "",
            "        self.ext_mgr = extensions.ExtensionManager()",
            "        self.ext_mgr.extensions = {}",
            "        self.controller = servers.Controller(self.ext_mgr)",
            "        self.ips_controller = ips.Controller()",
            "        policy.reset()",
            "        policy.init()",
            "        fake_network.stub_out_nw_api_get_instance_nw_info(self.stubs,",
            "                                                          spectacular=True)",
            "",
            "",
            "class ServersControllerTest(ControllerTest):",
            "",
            "    def test_can_check_loaded_extensions(self):",
            "        self.ext_mgr.extensions = {'os-fake': None}",
            "        self.assertTrue(self.controller.ext_mgr.is_loaded('os-fake'))",
            "        self.assertFalse(self.controller.ext_mgr.is_loaded('os-not-loaded'))",
            "",
            "    def test_requested_networks_prefix(self):",
            "        uuid = 'br-00000000-0000-0000-0000-000000000000'",
            "        requested_networks = [{'uuid': uuid}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertTrue((uuid, None) in res)",
            "",
            "    def test_requested_networks_neutronv2_enabled_with_port(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'port': port}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertEquals(res, [(None, None, port)])",
            "",
            "    def test_requested_networks_neutronv2_enabled_with_network(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        network = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        requested_networks = [{'uuid': network}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertEquals(res, [(network, None, None)])",
            "",
            "    def test_requested_networks_neutronv2_enabled_with_network_and_port(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        network = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'uuid': network, 'port': port}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertEquals(res, [(None, None, port)])",
            "",
            "    def test_requested_networks_neutronv2_disabled_with_port(self):",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'port': port}]",
            "        self.assertRaises(",
            "            webob.exc.HTTPBadRequest,",
            "            self.controller._get_requested_networks,",
            "            requested_networks)",
            "",
            "    def test_requested_networks_api_enabled_with_v2_subclass(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        network = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'uuid': network, 'port': port}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertEquals(res, [(None, None, port)])",
            "",
            "    def test_requested_networks_neutronv2_subclass_with_port(self):",
            "        cls = 'nova.tests.api.openstack.compute.test_servers.NeutronV2Subclass'",
            "        self.flags(network_api_class=cls)",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'port': port}]",
            "        res = self.controller._get_requested_networks(requested_networks)",
            "        self.assertEquals(res, [(None, None, port)])",
            "",
            "    def test_get_server_by_uuid(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers/%s' % FAKE_UUID)",
            "        res_dict = self.controller.show(req, FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "",
            "    def test_unique_host_id(self):",
            "        \"\"\"Create two servers with the same host and different",
            "           project_ids and check that the hostId's are unique.",
            "        \"\"\"",
            "        def return_instance_with_host(self, *args, **kwargs):",
            "            project_id = str(uuid.uuid4())",
            "            return fakes.stub_instance(id=1, uuid=FAKE_UUID,",
            "                                       project_id=project_id,",
            "                                       host='fake_host')",
            "",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                       return_instance_with_host)",
            "        self.stubs.Set(db, 'instance_get',",
            "                       return_instance_with_host)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers/%s' % FAKE_UUID)",
            "        server1 = self.controller.show(req, FAKE_UUID)",
            "        server2 = self.controller.show(req, FAKE_UUID)",
            "",
            "        self.assertNotEqual(server1['server']['hostId'],",
            "                            server2['server']['hostId'])",
            "",
            "    def test_get_server_by_id(self):",
            "        self.flags(use_ipv6=True)",
            "        image_bookmark = \"http://localhost/fake/images/10\"",
            "        flavor_bookmark = \"http://localhost/fake/flavors/1\"",
            "",
            "        uuid = FAKE_UUID",
            "        req = fakes.HTTPRequest.blank('/fake/servers/%s' % uuid)",
            "        res_dict = self.controller.show(req, uuid)",
            "",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 0,",
            "                \"name\": \"server1\",",
            "                \"status\": \"BUILD\",",
            "                \"accessIPv4\": \"\",",
            "                \"accessIPv6\": \"\",",
            "                \"hostId\": '',",
            "                \"image\": {",
            "                    \"id\": \"10\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                  \"links\": [",
            "                                            {",
            "                          \"rel\": \"bookmark\",",
            "                          \"href\": flavor_bookmark,",
            "                      },",
            "                  ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1'}",
            "                    ]",
            "                },",
            "                \"metadata\": {",
            "                    \"seq\": \"1\",",
            "                },",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": \"http://localhost/v2/fake/servers/%s\" % uuid,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": \"http://localhost/fake/servers/%s\" % uuid,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        self.assertThat(res_dict, matchers.DictMatches(expected_server))",
            "",
            "    def test_get_server_with_active_status_by_id(self):",
            "        image_bookmark = \"http://localhost/fake/images/10\"",
            "        flavor_bookmark = \"http://localhost/fake/flavors/1\"",
            "",
            "        new_return_server = fakes.fake_instance_get(",
            "                vm_state=vm_states.ACTIVE, progress=100)",
            "        self.stubs.Set(db, 'instance_get_by_uuid', new_return_server)",
            "",
            "        uuid = FAKE_UUID",
            "        req = fakes.HTTPRequest.blank('/fake/servers/%s' % uuid)",
            "        res_dict = self.controller.show(req, uuid)",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 100,",
            "                \"name\": \"server1\",",
            "                \"status\": \"ACTIVE\",",
            "                \"accessIPv4\": \"\",",
            "                \"accessIPv6\": \"\",",
            "                \"hostId\": '',",
            "                \"image\": {",
            "                    \"id\": \"10\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                  \"links\": [",
            "                      {",
            "                          \"rel\": \"bookmark\",",
            "                          \"href\": flavor_bookmark,",
            "                      },",
            "                  ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1'}",
            "                    ]",
            "                },",
            "                \"metadata\": {",
            "                    \"seq\": \"1\",",
            "                },",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": \"http://localhost/v2/fake/servers/%s\" % uuid,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": \"http://localhost/fake/servers/%s\" % uuid,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        self.assertThat(res_dict, matchers.DictMatches(expected_server))",
            "",
            "    def test_get_server_with_id_image_ref_by_id(self):",
            "        image_ref = \"10\"",
            "        image_bookmark = \"http://localhost/fake/images/10\"",
            "        flavor_id = \"1\"",
            "        flavor_bookmark = \"http://localhost/fake/flavors/1\"",
            "",
            "        new_return_server = fakes.fake_instance_get(",
            "                vm_state=vm_states.ACTIVE, image_ref=image_ref,",
            "                flavor_id=flavor_id, progress=100)",
            "        self.stubs.Set(db, 'instance_get_by_uuid', new_return_server)",
            "",
            "        uuid = FAKE_UUID",
            "        req = fakes.HTTPRequest.blank('/fake/servers/%s' % uuid)",
            "        res_dict = self.controller.show(req, uuid)",
            "        expected_server = {",
            "            \"server\": {",
            "                \"id\": uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 100,",
            "                \"name\": \"server1\",",
            "                \"status\": \"ACTIVE\",",
            "                \"accessIPv4\": \"\",",
            "                \"accessIPv6\": \"\",",
            "                \"hostId\": '',",
            "                \"image\": {",
            "                    \"id\": \"10\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                  \"links\": [",
            "                      {",
            "                          \"rel\": \"bookmark\",",
            "                          \"href\": flavor_bookmark,",
            "                      },",
            "                  ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1'}",
            "                    ]",
            "                },",
            "                \"metadata\": {",
            "                    \"seq\": \"1\",",
            "                },",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": \"http://localhost/v2/fake/servers/%s\" % uuid,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": \"http://localhost/fake/servers/%s\" % uuid,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        self.assertThat(res_dict, matchers.DictMatches(expected_server))",
            "",
            "    def test_get_server_addresses_from_cache(self):",
            "        pub0 = ('172.19.0.1', '172.19.0.2',)",
            "        pub1 = ('1.2.3.4',)",
            "        pub2 = ('b33f::fdee:ddff:fecc:bbaa',)",
            "        priv0 = ('192.168.0.3', '192.168.0.4',)",
            "",
            "        def _ip(ip):",
            "            return {'address': ip, 'type': 'fixed'}",
            "",
            "        nw_cache = [",
            "            {'address': 'aa:aa:aa:aa:aa:aa',",
            "             'id': 1,",
            "             'network': {'bridge': 'br0',",
            "                         'id': 1,",
            "                         'label': 'public',",
            "                         'subnets': [{'cidr': '172.19.0.0/24',",
            "                                      'ips': [_ip(ip) for ip in pub0]},",
            "                                      {'cidr': '1.2.3.0/16',",
            "                                       'ips': [_ip(ip) for ip in pub1]},",
            "                                      {'cidr': 'b33f::/64',",
            "                                       'ips': [_ip(ip) for ip in pub2]}]}},",
            "            {'address': 'bb:bb:bb:bb:bb:bb',",
            "             'id': 2,",
            "             'network': {'bridge': 'br1',",
            "                         'id': 2,",
            "                         'label': 'private',",
            "                         'subnets': [{'cidr': '192.168.0.0/24',",
            "                                      'ips': [_ip(ip) for ip in priv0]}]}}]",
            "",
            "        return_server = fakes.fake_instance_get(nw_cache=nw_cache)",
            "        self.stubs.Set(db, 'instance_get_by_uuid', return_server)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers/%s/ips' % FAKE_UUID)",
            "        res_dict = self.ips_controller.index(req, FAKE_UUID)",
            "",
            "        expected = {",
            "            'addresses': {",
            "                'private': [",
            "                    {'version': 4, 'addr': '192.168.0.3'},",
            "                    {'version': 4, 'addr': '192.168.0.4'},",
            "                ],",
            "                'public': [",
            "                    {'version': 4, 'addr': '172.19.0.1'},",
            "                    {'version': 4, 'addr': '172.19.0.2'},",
            "                    {'version': 4, 'addr': '1.2.3.4'},",
            "                    {'version': 6, 'addr': 'b33f::fdee:ddff:fecc:bbaa'},",
            "                ],",
            "            },",
            "        }",
            "        self.assertThat(res_dict, matchers.DictMatches(expected))",
            "",
            "    def test_get_server_addresses_nonexistent_network(self):",
            "        url = '/fake/servers/%s/ips/network_0' % FAKE_UUID",
            "        req = fakes.HTTPRequest.blank(url)",
            "        self.assertRaises(webob.exc.HTTPNotFound, self.ips_controller.show,",
            "                          req, FAKE_UUID, 'network_0')",
            "",
            "    def test_get_server_addresses_nonexistent_server(self):",
            "        def fake_instance_get(*args, **kwargs):",
            "            raise exception.InstanceNotFound(instance_id='fake')",
            "",
            "        self.stubs.Set(db, 'instance_get_by_uuid', fake_instance_get)",
            "",
            "        server_id = str(uuid.uuid4())",
            "        req = fakes.HTTPRequest.blank('/fake/servers/%s/ips' % server_id)",
            "        self.assertRaises(webob.exc.HTTPNotFound,",
            "                          self.ips_controller.index, req, server_id)",
            "",
            "    def test_get_server_list_empty(self):",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       return_servers_empty)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers')",
            "        res_dict = self.controller.index(req)",
            "",
            "        num_servers = len(res_dict['servers'])",
            "        self.assertEqual(0, num_servers)",
            "",
            "    def test_get_server_list_with_reservation_id(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers?reservation_id=foo')",
            "        res_dict = self.controller.index(req)",
            "",
            "        i = 0",
            "        for s in res_dict['servers']:",
            "            self.assertEqual(s.get('name'), 'server%d' % (i + 1))",
            "            i += 1",
            "",
            "    def test_get_server_list_with_reservation_id_empty(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers/detail?'",
            "                                      'reservation_id=foo')",
            "        res_dict = self.controller.detail(req)",
            "",
            "        i = 0",
            "        for s in res_dict['servers']:",
            "            self.assertEqual(s.get('name'), 'server%d' % (i + 1))",
            "            i += 1",
            "",
            "    def test_get_server_list_with_reservation_id_details(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers/detail?'",
            "                                      'reservation_id=foo')",
            "        res_dict = self.controller.detail(req)",
            "",
            "        i = 0",
            "        for s in res_dict['servers']:",
            "            self.assertEqual(s.get('name'), 'server%d' % (i + 1))",
            "            i += 1",
            "",
            "    def test_get_server_list(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers')",
            "        res_dict = self.controller.index(req)",
            "",
            "        self.assertEqual(len(res_dict['servers']), 5)",
            "        for i, s in enumerate(res_dict['servers']):",
            "            self.assertEqual(s['id'], fakes.get_fake_uuid(i))",
            "            self.assertEqual(s['name'], 'server%d' % (i + 1))",
            "            self.assertEqual(s.get('image', None), None)",
            "",
            "            expected_links = [",
            "                {",
            "                    \"rel\": \"self\",",
            "                    \"href\": \"http://localhost/v2/fake/servers/%s\" % s['id'],",
            "                },",
            "                {",
            "                    \"rel\": \"bookmark\",",
            "                    \"href\": \"http://localhost/fake/servers/%s\" % s['id'],",
            "                },",
            "            ]",
            "",
            "            self.assertEqual(s['links'], expected_links)",
            "",
            "    def test_get_servers_with_limit(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers?limit=3')",
            "        res_dict = self.controller.index(req)",
            "",
            "        servers = res_dict['servers']",
            "        self.assertEqual([s['id'] for s in servers],",
            "                [fakes.get_fake_uuid(i) for i in xrange(len(servers))])",
            "",
            "        servers_links = res_dict['servers_links']",
            "        self.assertEqual(servers_links[0]['rel'], 'next')",
            "        href_parts = urlparse.urlparse(servers_links[0]['href'])",
            "        self.assertEqual('/v2/fake/servers', href_parts.path)",
            "        params = urlparse.parse_qs(href_parts.query)",
            "        expected_params = {'limit': ['3'],",
            "                           'marker': [fakes.get_fake_uuid(2)]}",
            "        self.assertThat(params, matchers.DictMatches(expected_params))",
            "",
            "    def test_get_servers_with_limit_bad_value(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers?limit=aaa')",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.index, req)",
            "",
            "    def test_get_server_details_empty(self):",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       return_servers_empty)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers/detail')",
            "        res_dict = self.controller.index(req)",
            "",
            "        num_servers = len(res_dict['servers'])",
            "        self.assertEqual(0, num_servers)",
            "",
            "    def test_get_server_details_with_limit(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers/detail?limit=3')",
            "        res = self.controller.detail(req)",
            "",
            "        servers = res['servers']",
            "        self.assertEqual([s['id'] for s in servers],",
            "                [fakes.get_fake_uuid(i) for i in xrange(len(servers))])",
            "",
            "        servers_links = res['servers_links']",
            "        self.assertEqual(servers_links[0]['rel'], 'next')",
            "",
            "        href_parts = urlparse.urlparse(servers_links[0]['href'])",
            "        self.assertEqual('/v2/fake/servers', href_parts.path)",
            "        params = urlparse.parse_qs(href_parts.query)",
            "        expected = {'limit': ['3'], 'marker': [fakes.get_fake_uuid(2)]}",
            "        self.assertThat(params, matchers.DictMatches(expected))",
            "",
            "    def test_get_server_details_with_limit_bad_value(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers/detail?limit=aaa')",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.detail, req)",
            "",
            "    def test_get_server_details_with_limit_and_other_params(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers/detail'",
            "                                      '?limit=3&blah=2:t')",
            "        res = self.controller.detail(req)",
            "",
            "        servers = res['servers']",
            "        self.assertEqual([s['id'] for s in servers],",
            "                [fakes.get_fake_uuid(i) for i in xrange(len(servers))])",
            "",
            "        servers_links = res['servers_links']",
            "        self.assertEqual(servers_links[0]['rel'], 'next')",
            "",
            "        href_parts = urlparse.urlparse(servers_links[0]['href'])",
            "        self.assertEqual('/v2/fake/servers', href_parts.path)",
            "        params = urlparse.parse_qs(href_parts.query)",
            "        expected = {'limit': ['3'], 'blah': ['2:t'],",
            "                    'marker': [fakes.get_fake_uuid(2)]}",
            "        self.assertThat(params, matchers.DictMatches(expected))",
            "",
            "    def test_get_servers_with_too_big_limit(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers?limit=30')",
            "        res_dict = self.controller.index(req)",
            "        self.assertTrue('servers_links' not in res_dict)",
            "",
            "    def test_get_servers_with_bad_limit(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers?limit=asdf')",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.index, req)",
            "",
            "    def test_get_servers_with_marker(self):",
            "        url = '/v2/fake/servers?marker=%s' % fakes.get_fake_uuid(2)",
            "        req = fakes.HTTPRequest.blank(url)",
            "        servers = self.controller.index(req)['servers']",
            "        self.assertEqual([s['name'] for s in servers], [\"server4\", \"server5\"])",
            "",
            "    def test_get_servers_with_limit_and_marker(self):",
            "        url = '/v2/fake/servers?limit=2&marker=%s' % fakes.get_fake_uuid(1)",
            "        req = fakes.HTTPRequest.blank(url)",
            "        servers = self.controller.index(req)['servers']",
            "        self.assertEqual([s['name'] for s in servers], ['server3', 'server4'])",
            "",
            "    def test_get_servers_with_bad_marker(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers?limit=2&marker=asdf')",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.index, req)",
            "",
            "    def test_get_servers_with_bad_option(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers?unknownoption=whee')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_allows_image(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('image' in search_opts)",
            "            self.assertEqual(search_opts['image'], '12345')",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers?image=12345')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_tenant_id_filter_converts_to_project_id_for_admin(self):",
            "        def fake_get_all(context, filters=None, sort_key=None,",
            "                         sort_dir='desc', limit=None, marker=None,",
            "                         columns_to_join=None):",
            "            self.assertNotEqual(filters, None)",
            "            self.assertEqual(filters['project_id'], 'fake')",
            "            self.assertFalse(filters.get('tenant_id'))",
            "            return [fakes.stub_instance(100)]",
            "",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       fake_get_all)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers?tenant_id=fake',",
            "                                      use_admin_context=True)",
            "        res = self.controller.index(req)",
            "",
            "        self.assertTrue('servers' in res)",
            "",
            "    def test_admin_restricted_tenant(self):",
            "        def fake_get_all(context, filters=None, sort_key=None,",
            "                         sort_dir='desc', limit=None, marker=None,",
            "                         columns_to_join=None):",
            "            self.assertNotEqual(filters, None)",
            "            self.assertEqual(filters['project_id'], 'fake')",
            "            return [fakes.stub_instance(100)]",
            "",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       fake_get_all)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers',",
            "                                      use_admin_context=True)",
            "        res = self.controller.index(req)",
            "",
            "        self.assertTrue('servers' in res)",
            "",
            "    def test_all_tenants_pass_policy(self):",
            "        def fake_get_all(context, filters=None, sort_key=None,",
            "                         sort_dir='desc', limit=None, marker=None,",
            "                         columns_to_join=None):",
            "            self.assertNotEqual(filters, None)",
            "            self.assertTrue('project_id' not in filters)",
            "            return [fakes.stub_instance(100)]",
            "",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       fake_get_all)",
            "",
            "        rules = {",
            "            \"compute:get_all_tenants\":",
            "                common_policy.parse_rule(\"project_id:fake\"),",
            "            \"compute:get_all\":",
            "                common_policy.parse_rule(\"project_id:fake\"),",
            "        }",
            "",
            "        common_policy.set_rules(common_policy.Rules(rules))",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers?all_tenants=1')",
            "        res = self.controller.index(req)",
            "",
            "        self.assertTrue('servers' in res)",
            "",
            "    def test_all_tenants_fail_policy(self):",
            "        def fake_get_all(context, filters=None, sort_key=None,",
            "                         sort_dir='desc', limit=None, marker=None,",
            "                         columns_to_join=None):",
            "            self.assertNotEqual(filters, None)",
            "            return [fakes.stub_instance(100)]",
            "",
            "        rules = {",
            "            \"compute:get_all_tenants\":",
            "                common_policy.parse_rule(\"project_id:non_fake\"),",
            "            \"compute:get_all\":",
            "                common_policy.parse_rule(\"project_id:fake\"),",
            "        }",
            "",
            "        common_policy.set_rules(common_policy.Rules(rules))",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       fake_get_all)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers?all_tenants=1')",
            "        self.assertRaises(exception.PolicyNotAuthorized,",
            "                          self.controller.index, req)",
            "",
            "    def test_get_servers_allows_flavor(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('flavor' in search_opts)",
            "            # flavor is an integer ID",
            "            self.assertEqual(search_opts['flavor'], '12345')",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers?flavor=12345')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_with_bad_flavor(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers?flavor=abcde')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 0)",
            "",
            "    def test_get_servers_allows_status(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('vm_state' in search_opts)",
            "            self.assertEqual(search_opts['vm_state'], vm_states.ACTIVE)",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers?status=active')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_invalid_status(self):",
            "        # Test getting servers by invalid status.",
            "        req = fakes.HTTPRequest.blank('/fake/servers?status=baloney',",
            "                                      use_admin_context=False)",
            "        servers = self.controller.index(req)['servers']",
            "        self.assertEqual(len(servers), 0)",
            "",
            "    def test_get_servers_deleted_status_as_user(self):",
            "        req = fakes.HTTPRequest.blank('/fake/servers?status=deleted',",
            "                                      use_admin_context=False)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.detail, req)",
            "",
            "    def test_get_servers_deleted_status_as_admin(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertTrue('vm_state' in search_opts)",
            "            self.assertEqual(search_opts['vm_state'], 'deleted')",
            "",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers?status=deleted',",
            "                                      use_admin_context=True)",
            "",
            "        servers = self.controller.detail(req)['servers']",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_allows_name(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('name' in search_opts)",
            "            self.assertEqual(search_opts['name'], 'whee.*')",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers?name=whee.*')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_allows_changes_since(self):",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('changes-since' in search_opts)",
            "            changes_since = datetime.datetime(2011, 1, 24, 17, 8, 1,",
            "                                              tzinfo=iso8601.iso8601.UTC)",
            "            self.assertEqual(search_opts['changes-since'], changes_since)",
            "            self.assertTrue('deleted' not in search_opts)",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        params = 'changes-since=2011-01-24T17:08:01Z'",
            "        req = fakes.HTTPRequest.blank('/fake/servers?%s' % params)",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_allows_changes_since_bad_value(self):",
            "        params = 'changes-since=asdf'",
            "        req = fakes.HTTPRequest.blank('/fake/servers?%s' % params)",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.index, req)",
            "",
            "    def test_get_servers_admin_filters_as_user(self):",
            "        \"\"\"Test getting servers by admin-only or unknown options when",
            "        context is not admin. Make sure the admin and unknown options",
            "        are stripped before they get to compute_api.get_all()",
            "        \"\"\"",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            # Allowed by user",
            "            self.assertTrue('name' in search_opts)",
            "            self.assertTrue('ip' in search_opts)",
            "            # OSAPI converts status to vm_state",
            "            self.assertTrue('vm_state' in search_opts)",
            "            # Allowed only by admins with admin API on",
            "            self.assertFalse('unknown_option' in search_opts)",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        query_str = \"name=foo&ip=10.*&status=active&unknown_option=meow\"",
            "        req = fakes.HTTPRequest.blank('/fake/servers?%s' % query_str)",
            "        res = self.controller.index(req)",
            "",
            "        servers = res['servers']",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_admin_options_as_admin(self):",
            "        \"\"\"Test getting servers by admin-only or unknown options when",
            "        context is admin. All options should be passed",
            "        \"\"\"",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            # Allowed by user",
            "            self.assertTrue('name' in search_opts)",
            "            # OSAPI converts status to vm_state",
            "            self.assertTrue('vm_state' in search_opts)",
            "            # Allowed only by admins with admin API on",
            "            self.assertTrue('ip' in search_opts)",
            "            self.assertTrue('unknown_option' in search_opts)",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        query_str = \"name=foo&ip=10.*&status=active&unknown_option=meow\"",
            "        req = fakes.HTTPRequest.blank('/fake/servers?%s' % query_str,",
            "                                      use_admin_context=True)",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_allows_ip(self):",
            "        \"\"\"Test getting servers by ip.\"\"\"",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('ip' in search_opts)",
            "            self.assertEqual(search_opts['ip'], '10\\..*')",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers?ip=10\\..*')",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_servers_admin_allows_ip6(self):",
            "        \"\"\"Test getting servers by ip6 with admin_api enabled and",
            "        admin context",
            "        \"\"\"",
            "        server_uuid = str(uuid.uuid4())",
            "",
            "        def fake_get_all(compute_self, context, search_opts=None,",
            "                         sort_key=None, sort_dir='desc',",
            "                         limit=None, marker=None, want_objects=False):",
            "            self.assertNotEqual(search_opts, None)",
            "            self.assertTrue('ip6' in search_opts)",
            "            self.assertEqual(search_opts['ip6'], 'ffff.*')",
            "            db_list = [fakes.stub_instance(100, uuid=server_uuid)]",
            "            return instance_obj._make_instance_list(",
            "                context, instance_obj.InstanceList(), db_list, FIELDS)",
            "",
            "        self.stubs.Set(compute_api.API, 'get_all', fake_get_all)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers?ip6=ffff.*',",
            "                                      use_admin_context=True)",
            "        servers = self.controller.index(req)['servers']",
            "",
            "        self.assertEqual(len(servers), 1)",
            "        self.assertEqual(servers[0]['id'], server_uuid)",
            "",
            "    def test_get_all_server_details(self):",
            "        expected_flavor = {",
            "            \"id\": \"1\",",
            "            \"links\": [",
            "                {",
            "                    \"rel\": \"bookmark\",",
            "                    \"href\": 'http://localhost/fake/flavors/1',",
            "                },",
            "            ],",
            "        }",
            "        expected_image = {",
            "            \"id\": \"10\",",
            "            \"links\": [",
            "                {",
            "                    \"rel\": \"bookmark\",",
            "                    \"href\": 'http://localhost/fake/images/10',",
            "                },",
            "            ],",
            "        }",
            "        req = fakes.HTTPRequest.blank('/fake/servers/detail')",
            "        res_dict = self.controller.detail(req)",
            "",
            "        for i, s in enumerate(res_dict['servers']):",
            "            self.assertEqual(s['id'], fakes.get_fake_uuid(i))",
            "            self.assertEqual(s['hostId'], '')",
            "            self.assertEqual(s['name'], 'server%d' % (i + 1))",
            "            self.assertEqual(s['image'], expected_image)",
            "            self.assertEqual(s['flavor'], expected_flavor)",
            "            self.assertEqual(s['status'], 'BUILD')",
            "            self.assertEqual(s['metadata']['seq'], str(i + 1))",
            "",
            "    def test_get_all_server_details_with_host(self):",
            "        '''",
            "        We want to make sure that if two instances are on the same host, then",
            "        they return the same hostId. If two instances are on different hosts,",
            "        they should return different hostId's. In this test, there are 5",
            "        instances - 2 on one host and 3 on another.",
            "        '''",
            "",
            "        def return_servers_with_host(context, *args, **kwargs):",
            "            return [fakes.stub_instance(i + 1, 'fake', 'fake', host=i % 2,",
            "                                        uuid=fakes.get_fake_uuid(i))",
            "                    for i in xrange(5)]",
            "",
            "        self.stubs.Set(db, 'instance_get_all_by_filters',",
            "                       return_servers_with_host)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers/detail')",
            "        res_dict = self.controller.detail(req)",
            "",
            "        server_list = res_dict['servers']",
            "        host_ids = [server_list[0]['hostId'], server_list[1]['hostId']]",
            "        self.assertTrue(host_ids[0] and host_ids[1])",
            "        self.assertNotEqual(host_ids[0], host_ids[1])",
            "",
            "        for i, s in enumerate(server_list):",
            "            self.assertEqual(s['id'], fakes.get_fake_uuid(i))",
            "            self.assertEqual(s['hostId'], host_ids[i % 2])",
            "            self.assertEqual(s['name'], 'server%d' % (i + 1))",
            "",
            "",
            "class ServersControllerUpdateTest(ControllerTest):",
            "",
            "    def _get_request(self, body=None, content_type='json', options=None):",
            "        if options:",
            "            self.stubs.Set(db, 'instance_get',",
            "                           fakes.fake_instance_get(**options))",
            "        req = fakes.HTTPRequest.blank('/fake/servers/%s' % FAKE_UUID)",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/%s' % content_type",
            "        req.body = jsonutils.dumps(body)",
            "        return req",
            "",
            "    def test_update_server_all_attributes(self):",
            "        body = {'server': {",
            "                  'name': 'server_test',",
            "                  'accessIPv4': '0.0.0.0',",
            "                  'accessIPv6': 'beef::0123',",
            "               }}",
            "        req = self._get_request(body, {'name': 'server_test',",
            "                                       'access_ipv4': '0.0.0.0',",
            "                                       'access_ipv6': 'beef::0123'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['name'], 'server_test')",
            "        self.assertEqual(res_dict['server']['accessIPv4'], '0.0.0.0')",
            "        self.assertEqual(res_dict['server']['accessIPv6'], 'beef::123')",
            "",
            "    def test_update_server_invalid_xml_raises_lookup(self):",
            "        body = \"\"\"<?xml version=\"1.0\" encoding=\"TF-8\"?>",
            "            <metadata",
            "            xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "            key=\"Label\"></meta>\"\"\"",
            "        req = self._get_request(body, content_type='xml')",
            "        res = req.get_response(fakes.wsgi_app())",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_update_server_invalid_xml_raises_expat(self):",
            "        body = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>",
            "            <metadata",
            "            xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "            key=\"Label\"></meta>\"\"\"",
            "        req = self._get_request(body, content_type='xml')",
            "        res = req.get_response(fakes.wsgi_app())",
            "        self.assertEqual(res.status_int, 400)",
            "",
            "    def test_update_server_name(self):",
            "        body = {'server': {'name': 'server_test'}}",
            "        req = self._get_request(body, {'name': 'server_test'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['name'], 'server_test')",
            "",
            "    def test_update_server_name_too_long(self):",
            "        body = {'server': {'name': 'x' * 256}}",
            "        req = self._get_request(body, {'name': 'server_test'})",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.update,",
            "                            req, FAKE_UUID, body)",
            "",
            "    def test_update_server_name_all_blank_spaces(self):",
            "        body = {'server': {'name': ' ' * 64}}",
            "        req = self._get_request(body, {'name': 'server_test'})",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.update,",
            "                          req, FAKE_UUID, body)",
            "",
            "    def test_update_server_access_ipv4(self):",
            "        body = {'server': {'accessIPv4': '0.0.0.0'}}",
            "        req = self._get_request(body, {'access_ipv4': '0.0.0.0'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['accessIPv4'], '0.0.0.0')",
            "",
            "    def test_update_server_access_ipv4_bad_format(self):",
            "        body = {'server': {'accessIPv4': 'bad_format'}}",
            "        req = self._get_request(body, {'access_ipv4': '0.0.0.0'})",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.update,",
            "                            req, FAKE_UUID, body)",
            "",
            "    def test_update_server_access_ipv4_none(self):",
            "        body = {'server': {'accessIPv4': None}}",
            "        req = self._get_request(body, {'access_ipv4': '0.0.0.0'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['accessIPv4'], '')",
            "",
            "    def test_update_server_access_ipv4_blank(self):",
            "        body = {'server': {'accessIPv4': ''}}",
            "        req = self._get_request(body, {'access_ipv4': '0.0.0.0'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['accessIPv4'], '')",
            "",
            "    def test_update_server_access_ipv6(self):",
            "        body = {'server': {'accessIPv6': 'beef::0123'}}",
            "        req = self._get_request(body, {'access_ipv6': 'beef::0123'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['accessIPv6'], 'beef::123')",
            "",
            "    def test_update_server_access_ipv6_bad_format(self):",
            "        body = {'server': {'accessIPv6': 'bad_format'}}",
            "        req = self._get_request(body, {'access_ipv6': 'beef::0123'})",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.update,",
            "                            req, FAKE_UUID, body)",
            "",
            "    def test_update_server_access_ipv6_none(self):",
            "        body = {'server': {'accessIPv6': None}}",
            "        req = self._get_request(body, {'access_ipv6': 'beef::0123'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['accessIPv6'], '')",
            "",
            "    def test_update_server_access_ipv6_blank(self):",
            "        body = {'server': {'accessIPv6': ''}}",
            "        req = self._get_request(body, {'access_ipv6': 'beef::0123'})",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['accessIPv6'], '')",
            "",
            "    def test_update_server_personality(self):",
            "        body = {",
            "            'server': {",
            "                'personality': []",
            "            }",
            "        }",
            "        req = self._get_request(body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "            self.controller.update, req, FAKE_UUID, body)",
            "",
            "    def test_update_server_adminPass_ignored(self):",
            "        inst_dict = dict(name='server_test', adminPass='bacon')",
            "        body = dict(server=inst_dict)",
            "",
            "        def server_update(context, id, params):",
            "            filtered_dict = {",
            "                'display_name': 'server_test',",
            "            }",
            "            self.assertEqual(params, filtered_dict)",
            "            filtered_dict['uuid'] = id",
            "            return filtered_dict",
            "",
            "        self.stubs.Set(db, 'instance_update', server_update)",
            "        # FIXME (comstud)",
            "        #        self.stubs.Set(db, 'instance_get',",
            "        #                return_server_with_attributes(name='server_test'))",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers/%s' % FAKE_UUID)",
            "        req.method = 'PUT'",
            "        req.content_type = \"application/json\"",
            "        req.body = jsonutils.dumps(body)",
            "        res_dict = self.controller.update(req, FAKE_UUID, body)",
            "",
            "        self.assertEqual(res_dict['server']['id'], FAKE_UUID)",
            "        self.assertEqual(res_dict['server']['name'], 'server_test')",
            "",
            "    def test_update_server_not_found(self):",
            "        def fake_get(*args, **kwargs):",
            "            raise exception.InstanceNotFound(instance_id='fake')",
            "",
            "        self.stubs.Set(compute_api.API, 'get', fake_get)",
            "        body = {'server': {'name': 'server_test'}}",
            "        req = self._get_request(body)",
            "        self.assertRaises(webob.exc.HTTPNotFound, self.controller.update,",
            "                          req, FAKE_UUID, body)",
            "",
            "    def test_update_server_not_found_on_update(self):",
            "        def fake_update(*args, **kwargs):",
            "            raise exception.InstanceNotFound(instance_id='fake')",
            "",
            "        self.stubs.Set(db, 'instance_update_and_get_original', fake_update)",
            "        body = {'server': {'name': 'server_test'}}",
            "        req = self._get_request(body)",
            "        self.assertRaises(webob.exc.HTTPNotFound, self.controller.update,",
            "                          req, FAKE_UUID, body)",
            "",
            "    def test_update_server_policy_fail(self):",
            "        rule = {'compute:update': common_policy.parse_rule('role:admin')}",
            "        common_policy.set_rules(common_policy.Rules(rule))",
            "        body = {'server': {'name': 'server_test'}}",
            "        req = self._get_request(body, {'name': 'server_test'})",
            "        self.assertRaises(exception.PolicyNotAuthorized,",
            "                self.controller.update, req, FAKE_UUID, body)",
            "",
            "",
            "class ServersControllerDeleteTest(ControllerTest):",
            "",
            "    def setUp(self):",
            "        super(ServersControllerDeleteTest, self).setUp()",
            "        self.server_delete_called = False",
            "",
            "        def instance_destroy_mock(*args, **kwargs):",
            "            self.server_delete_called = True",
            "",
            "        self.stubs.Set(db, 'instance_destroy', instance_destroy_mock)",
            "",
            "    def _create_delete_request(self, uuid):",
            "        fakes.stub_out_instance_quota(self.stubs, 0, 10)",
            "        req = fakes.HTTPRequest.blank('/v2/fake/servers/%s' % uuid)",
            "        req.method = 'DELETE'",
            "        return req",
            "",
            "    def _delete_server_instance(self, uuid=FAKE_UUID):",
            "        req = self._create_delete_request(uuid)",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                fakes.fake_instance_get(vm_state=vm_states.ACTIVE))",
            "        self.controller.delete(req, uuid)",
            "",
            "    def test_delete_server_instance(self):",
            "        self._delete_server_instance()",
            "        self.assertTrue(self.server_delete_called)",
            "",
            "    def test_delete_server_instance_not_found(self):",
            "        self.assertRaises(webob.exc.HTTPNotFound,",
            "                          self._delete_server_instance,",
            "                          uuid='non-existent-uuid')",
            "",
            "    def test_delete_server_instance_while_building(self):",
            "        fakes.stub_out_instance_quota(self.stubs, 0, 10)",
            "        request = self._create_delete_request(FAKE_UUID)",
            "        self.controller.delete(request, FAKE_UUID)",
            "",
            "        self.assertTrue(self.server_delete_called)",
            "",
            "    def test_delete_server_instance_while_resize(self):",
            "        req = self._create_delete_request(FAKE_UUID)",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "            fakes.fake_instance_get(vm_state=vm_states.ACTIVE,",
            "                                    task_state=task_states.RESIZE_PREP))",
            "",
            "        self.controller.delete(req, FAKE_UUID)",
            "        # Delete shoud be allowed in any case, even during resizing,",
            "        # because it may get stuck.",
            "        self.assertTrue(self.server_delete_called)",
            "",
            "",
            "class ServersControllerRebuildInstanceTest(ControllerTest):",
            "    image_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    image_href = 'http://localhost/v2/fake/images/%s' % image_uuid",
            "",
            "    def setUp(self):",
            "        super(ServersControllerRebuildInstanceTest, self).setUp()",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                       fakes.fake_instance_get(vm_state=vm_states.ACTIVE))",
            "        self.body = {",
            "            'rebuild': {",
            "                'name': 'new_name',",
            "                'imageRef': self.image_href,",
            "                'metadata': {",
            "                    'open': 'stack',",
            "                },",
            "                'personality': [",
            "                    {",
            "                        \"path\": \"/etc/banner.txt\",",
            "                        \"contents\": \"MQ==\",",
            "                    },",
            "                ],",
            "            },",
            "        }",
            "        self.req = fakes.HTTPRequest.blank('/fake/servers/a/action')",
            "        self.req.method = 'POST'",
            "        self.req.headers[\"content-type\"] = \"application/json\"",
            "",
            "    def test_rebuild_instance_with_access_ipv4_bad_format(self):",
            "        # proper local hrefs must start with 'http://localhost/v2/'",
            "        self.body['rebuild']['accessIPv4'] = 'bad_format'",
            "        self.body['rebuild']['accessIPv6'] = 'fead::1234'",
            "        self.body['rebuild']['metadata']['hello'] = 'world'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_with_blank_metadata_key(self):",
            "        self.body['rebuild']['accessIPv4'] = '0.0.0.0'",
            "        self.body['rebuild']['accessIPv6'] = 'fead::1234'",
            "        self.body['rebuild']['metadata'][''] = 'world'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_with_metadata_key_too_long(self):",
            "        self.body['rebuild']['accessIPv4'] = '0.0.0.0'",
            "        self.body['rebuild']['accessIPv6'] = 'fead::1234'",
            "        self.body['rebuild']['metadata'][('a' * 260)] = 'world'",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_with_metadata_value_too_long(self):",
            "        self.body['rebuild']['accessIPv4'] = '0.0.0.0'",
            "        self.body['rebuild']['accessIPv6'] = 'fead::1234'",
            "        self.body['rebuild']['metadata']['key1'] = ('a' * 260)",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_fails_when_min_ram_too_small(self):",
            "        # make min_ram larger than our instance ram size",
            "        def fake_get_image(self, context, image_href):",
            "            return dict(id='76fa36fc-c930-4bf3-8c8a-ea2a2420deb6',",
            "                        name='public image', is_public=True,",
            "                        status='active', properties={'key1': 'value1'},",
            "                        min_ram=\"4096\", min_disk=\"10\")",
            "",
            "        self.stubs.Set(fake._FakeImageService, 'show', fake_get_image)",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_fails_when_min_disk_too_small(self):",
            "        # make min_disk larger than our instance disk size",
            "        def fake_get_image(self, context, image_href):",
            "            return dict(id='76fa36fc-c930-4bf3-8c8a-ea2a2420deb6',",
            "                        name='public image', is_public=True,",
            "                        status='active', properties={'key1': 'value1'},",
            "                        min_ram=\"128\", min_disk=\"100000\")",
            "",
            "        self.stubs.Set(fake._FakeImageService, 'show', fake_get_image)",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild, self.req,",
            "                          FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_image_too_large(self):",
            "        # make image size larger than our instance disk size",
            "        size = str(1000 * (1024 ** 3))",
            "",
            "        def fake_get_image(self, context, image_href):",
            "            return dict(id='76fa36fc-c930-4bf3-8c8a-ea2a2420deb6',",
            "                        name='public image', is_public=True,",
            "                        status='active', size=size)",
            "",
            "        self.stubs.Set(fake._FakeImageService, 'show', fake_get_image)",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "            self.controller._action_rebuild, self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_with_deleted_image(self):",
            "        def fake_get_image(self, context, image_href):",
            "            return dict(id='76fa36fc-c930-4bf3-8c8a-ea2a2420deb6',",
            "                        name='public image', is_public=True,",
            "                        status='DELETED')",
            "",
            "        self.stubs.Set(fake._FakeImageService, 'show', fake_get_image)",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "            self.controller._action_rebuild, self.req, FAKE_UUID, self.body)",
            "",
            "    def test_rebuild_instance_with_access_ipv6_bad_format(self):",
            "        # proper local hrefs must start with 'http://localhost/v2/'",
            "        self.body['rebuild']['accessIPv4'] = '1.2.3.4'",
            "        self.body['rebuild']['accessIPv6'] = 'bad_format'",
            "        self.body['rebuild']['metadata']['hello'] = 'world'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.req.headers[\"content-type\"] = \"application/json\"",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller._action_rebuild,",
            "                          self.req, FAKE_UUID, self.body)",
            "",
            "",
            "class ServerStatusTest(test.TestCase):",
            "",
            "    def setUp(self):",
            "        super(ServerStatusTest, self).setUp()",
            "        fakes.stub_out_nw_api(self.stubs)",
            "",
            "        self.ext_mgr = extensions.ExtensionManager()",
            "        self.ext_mgr.extensions = {}",
            "        self.controller = servers.Controller(self.ext_mgr)",
            "",
            "        def _fake_get_server(context, req, id):",
            "            return fakes.stub_instance(id)",
            "",
            "        self.stubs.Set(self.controller, '_get_server', _fake_get_server)",
            "",
            "    def _get_with_state(self, vm_state, task_state=None):",
            "        self.stubs.Set(db, 'instance_get_by_uuid',",
            "                fakes.fake_instance_get(vm_state=vm_state,",
            "                                        task_state=task_state))",
            "",
            "        request = fakes.HTTPRequest.blank('/fake/servers/%s' % FAKE_UUID)",
            "        return self.controller.show(request, FAKE_UUID)",
            "",
            "    def _req_with_policy_fail(self, policy_rule_name):",
            "        rule = {'compute:%s' % policy_rule_name:",
            "                common_policy.parse_rule('role:admin')}",
            "        common_policy.set_rules(common_policy.Rules(rule))",
            "        return fakes.HTTPRequest.blank('/fake/servers/1234/action')",
            "",
            "    def test_active(self):",
            "        response = self._get_with_state(vm_states.ACTIVE)",
            "        self.assertEqual(response['server']['status'], 'ACTIVE')",
            "",
            "    def test_reboot(self):",
            "        response = self._get_with_state(vm_states.ACTIVE,",
            "                                        task_states.REBOOTING)",
            "        self.assertEqual(response['server']['status'], 'REBOOT')",
            "",
            "    def test_reboot_hard(self):",
            "        response = self._get_with_state(vm_states.ACTIVE,",
            "                                        task_states.REBOOTING_HARD)",
            "        self.assertEqual(response['server']['status'], 'HARD_REBOOT')",
            "",
            "    def test_reboot_resize_policy_fail(self):",
            "        req = self._req_with_policy_fail('reboot')",
            "        self.assertRaises(exception.PolicyNotAuthorized,",
            "                self.controller._action_reboot, req, '1234',",
            "                {'reboot': {'type': 'HARD'}})",
            "",
            "    def test_rebuild(self):",
            "        response = self._get_with_state(vm_states.ACTIVE,",
            "                                        task_states.REBUILDING)",
            "        self.assertEqual(response['server']['status'], 'REBUILD')",
            "",
            "    def test_rebuild_error(self):",
            "        response = self._get_with_state(vm_states.ERROR)",
            "        self.assertEqual(response['server']['status'], 'ERROR')",
            "",
            "    def test_resize(self):",
            "        response = self._get_with_state(vm_states.ACTIVE,",
            "                                        task_states.RESIZE_PREP)",
            "        self.assertEqual(response['server']['status'], 'RESIZE')",
            "",
            "    def test_confirm_resize_policy_fail(self):",
            "        req = self._req_with_policy_fail('confirm_resize')",
            "        self.assertRaises(exception.PolicyNotAuthorized,",
            "                self.controller._action_confirm_resize, req, '1234', {})",
            "",
            "    def test_verify_resize(self):",
            "        response = self._get_with_state(vm_states.RESIZED, None)",
            "        self.assertEqual(response['server']['status'], 'VERIFY_RESIZE')",
            "",
            "    def test_revert_resize(self):",
            "        response = self._get_with_state(vm_states.RESIZED,",
            "                                        task_states.RESIZE_REVERTING)",
            "        self.assertEqual(response['server']['status'], 'REVERT_RESIZE')",
            "",
            "    def test_revert_resize_policy_fail(self):",
            "        req = self._req_with_policy_fail('revert_resize')",
            "        self.assertRaises(exception.PolicyNotAuthorized,",
            "                self.controller._action_revert_resize, req, '1234', {})",
            "",
            "    def test_password_update(self):",
            "        response = self._get_with_state(vm_states.ACTIVE,",
            "                                        task_states.UPDATING_PASSWORD)",
            "        self.assertEqual(response['server']['status'], 'PASSWORD')",
            "",
            "    def test_stopped(self):",
            "        response = self._get_with_state(vm_states.STOPPED)",
            "        self.assertEqual(response['server']['status'], 'SHUTOFF')",
            "",
            "",
            "class ServersControllerCreateTest(test.TestCase):",
            "    image_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "    flavor_ref = 'http://localhost/123/flavors/3'",
            "",
            "    def setUp(self):",
            "        \"\"\"Shared implementation for tests below that create instance.\"\"\"",
            "        super(ServersControllerCreateTest, self).setUp()",
            "",
            "        self.flags(verbose=True,",
            "                   enable_instance_password=True)",
            "        self.instance_cache_num = 0",
            "        self.instance_cache_by_id = {}",
            "        self.instance_cache_by_uuid = {}",
            "",
            "        self.ext_mgr = extensions.ExtensionManager()",
            "        self.ext_mgr.extensions = {}",
            "        self.controller = servers.Controller(self.ext_mgr)",
            "",
            "        self.volume_id = 'fake'",
            "",
            "        def instance_create(context, inst):",
            "            inst_type = flavors.get_flavor_by_flavor_id(3)",
            "            image_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "            def_image_ref = 'http://localhost/images/%s' % image_uuid",
            "            self.instance_cache_num += 1",
            "            instance = fake_instance.fake_db_instance(**{",
            "                'id': self.instance_cache_num,",
            "                'display_name': inst['display_name'] or 'test',",
            "                'uuid': FAKE_UUID,",
            "                'instance_type': dict(inst_type),",
            "                'access_ip_v4': '1.2.3.4',",
            "                'access_ip_v6': 'fead::1234',",
            "                'image_ref': inst.get('image_ref', def_image_ref),",
            "                'user_id': 'fake',",
            "                'project_id': 'fake',",
            "                'reservation_id': inst['reservation_id'],",
            "                \"created_at\": datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "                \"updated_at\": datetime.datetime(2010, 11, 11, 11, 0, 0),",
            "                \"config_drive\": None,",
            "                \"progress\": 0,",
            "                \"fixed_ips\": [],",
            "                \"task_state\": \"\",",
            "                \"vm_state\": \"\",",
            "                \"root_device_name\": inst.get('root_device_name', 'vda'),",
            "                \"security_groups\": inst['security_groups'],",
            "            })",
            "",
            "            self.instance_cache_by_id[instance['id']] = instance",
            "            self.instance_cache_by_uuid[instance['uuid']] = instance",
            "            return instance",
            "",
            "        def instance_get(context, instance_id):",
            "            \"\"\"Stub for compute/api create() pulling in instance after",
            "            scheduling",
            "            \"\"\"",
            "            return self.instance_cache_by_id[instance_id]",
            "",
            "        def instance_update(context, uuid, values):",
            "            instance = self.instance_cache_by_uuid[uuid]",
            "            instance.update(values)",
            "            return instance",
            "",
            "        def rpc_call_wrapper(context, topic, msg, timeout=None):",
            "            \"\"\"Stub out the scheduler creating the instance entry.\"\"\"",
            "            if (topic == CONF.scheduler_topic and",
            "                    msg['method'] == 'run_instance'):",
            "                request_spec = msg['args']['request_spec']",
            "                num_instances = request_spec.get('num_instances', 1)",
            "                instances = []",
            "                for x in xrange(num_instances):",
            "                    instances.append(instance_create(context,",
            "                        request_spec['instance_properties']))",
            "                return instances",
            "",
            "        def server_update(context, instance_uuid, params, update_cells=False):",
            "            inst = self.instance_cache_by_uuid[instance_uuid]",
            "            inst.update(params)",
            "            return (inst, inst)",
            "",
            "        def fake_method(*args, **kwargs):",
            "            pass",
            "",
            "        def project_get_networks(context, user_id):",
            "            return dict(id='1', host='localhost')",
            "",
            "        def queue_get_for(context, *args):",
            "            return 'network_topic'",
            "",
            "        fakes.stub_out_rate_limiting(self.stubs)",
            "        fakes.stub_out_key_pair_funcs(self.stubs)",
            "        fake.stub_out_image_service(self.stubs)",
            "        fakes.stub_out_nw_api(self.stubs)",
            "        self.stubs.Set(uuid, 'uuid4', fake_gen_uuid)",
            "        self.stubs.Set(db, 'instance_add_security_group',",
            "                       return_security_group)",
            "        self.stubs.Set(db, 'project_get_networks',",
            "                       project_get_networks)",
            "        self.stubs.Set(db, 'instance_create', instance_create)",
            "        self.stubs.Set(db, 'instance_system_metadata_update',",
            "                       fake_method)",
            "        self.stubs.Set(db, 'instance_get', instance_get)",
            "        self.stubs.Set(db, 'instance_update', instance_update)",
            "        self.stubs.Set(rpc, 'cast', fake_method)",
            "        self.stubs.Set(rpc, 'call', rpc_call_wrapper)",
            "        self.stubs.Set(db, 'instance_update_and_get_original',",
            "                       server_update)",
            "        self.stubs.Set(rpc, 'queue_get_for', queue_get_for)",
            "        self.stubs.Set(manager.VlanManager, 'allocate_fixed_ip',",
            "                       fake_method)",
            "        self.body = {",
            "            'server': {",
            "                'min_count': 2,",
            "                'name': 'server_test',",
            "                'imageRef': self.image_uuid,",
            "                'flavorRef': self.flavor_ref,",
            "                'metadata': {",
            "                    'hello': 'world',",
            "                    'open': 'stack',",
            "                    },",
            "                'personality': [",
            "                    {",
            "                        \"path\": \"/etc/banner.txt\",",
            "                        \"contents\": \"MQ==\",",
            "                    },",
            "                ],",
            "            },",
            "        }",
            "        self.bdm = [{'delete_on_termination': 1,",
            "                     'device_name': 123,",
            "                     'volume_size': 1,",
            "                     'volume_id': '11111111-1111-1111-1111-111111111111'}]",
            "",
            "        self.req = fakes.HTTPRequest.blank('/fake/servers')",
            "        self.req.method = 'POST'",
            "        self.req.headers[\"content-type\"] = \"application/json\"",
            "",
            "    def _check_admin_pass_len(self, server_dict):",
            "        \"\"\"utility function - check server_dict for adminPass length.\"\"\"",
            "        self.assertEqual(CONF.password_length,",
            "                         len(server_dict[\"adminPass\"]))",
            "",
            "    def _check_admin_pass_missing(self, server_dict):",
            "        \"\"\"utility function - check server_dict for absence of adminPass.\"\"\"",
            "        self.assertTrue(\"adminPass\" not in server_dict)",
            "",
            "    def _test_create_instance(self, flavor=2):",
            "        image_uuid = 'c905cedb-7281-47e4-8a62-f26bc5fc4c77'",
            "        self.body['server']['imageRef'] = image_uuid",
            "        self.body['server']['flavorRef'] = flavor",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        server = self.controller.create(self.req, self.body).obj['server']",
            "        self._check_admin_pass_len(server)",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_private_flavor(self):",
            "        values = {",
            "            'name': 'fake_name',",
            "            'memory_mb': 512,",
            "            'vcpus': 1,",
            "            'root_gb': 10,",
            "            'ephemeral_gb': 10,",
            "            'flavorid': '1324',",
            "            'swap': 0,",
            "            'rxtx_factor': 0.5,",
            "            'vcpu_weight': 1,",
            "            'disabled': False,",
            "            'is_public': False,",
            "        }",
            "        db.flavor_create(context.get_admin_context(), values)",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self._test_create_instance,",
            "                          flavor=1324)",
            "",
            "    def test_create_server_bad_image_href(self):",
            "        image_href = 1",
            "        self.body['server']['imageRef'] = image_href,",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create,",
            "                          self.req, self.body)",
            "",
            "    def test_create_server_with_invalid_networks_parameter(self):",
            "        self.ext_mgr.extensions = {'os-networks': 'fake'}",
            "        self.body['server']['networks'] = {",
            "            'uuid': '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'}",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create,",
            "                          self.req,",
            "                          self.body)",
            "",
            "    def test_create_server_with_deleted_image(self):",
            "        image_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "        # Get the fake image service so we can set the status to deleted",
            "        (image_service, image_id) = glance.get_remote_image_service(",
            "                context, '')",
            "        image_service.update(context, image_uuid, {'status': 'DELETED'})",
            "        self.addCleanup(image_service.update, context, image_uuid,",
            "                        {'status': 'active'})",
            "",
            "        self.body['server']['flavorRef'] = 2",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        with testtools.ExpectedException(",
            "                webob.exc.HTTPBadRequest,",
            "                'Image 76fa36fc-c930-4bf3-8c8a-ea2a2420deb6 is not active.'):",
            "            self.controller.create(self.req, self.body)",
            "",
            "    def test_create_server_image_too_large(self):",
            "        image_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "        # Get the fake image service so we can set the status to deleted",
            "        (image_service, image_id) = glance.get_remote_image_service(context,",
            "                                                                    image_uuid)",
            "        image = image_service.show(context, image_id)",
            "        orig_size = image['size']",
            "        new_size = str(1000 * (1024 ** 3))",
            "        image_service.update(context, image_uuid, {'size': new_size})",
            "",
            "        self.addCleanup(image_service.update, context, image_uuid,",
            "                        {'size': orig_size})",
            "",
            "        self.body['server']['flavorRef'] = 2",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        with testtools.ExpectedException(",
            "                webob.exc.HTTPBadRequest,",
            "                \"Instance type's disk is too small for requested image.\"):",
            "            self.controller.create(self.req, self.body)",
            "",
            "    def test_create_instance_invalid_negative_min(self):",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        self.body['server']['min_count'] = -1",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create,",
            "                          self.req,",
            "                          self.body)",
            "",
            "    def test_create_instance_invalid_negative_max(self):",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        self.body['server']['max_count'] = -1",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create,",
            "                          self.req,",
            "                          self.body)",
            "",
            "    def test_create_instance_invalid_alpha_min(self):",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        self.body['server']['min_count'] = 'abcd',",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create,",
            "                          self.req,",
            "                          self.body)",
            "",
            "    def test_create_instance_invalid_alpha_max(self):",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        self.body['server']['max_count'] = 'abcd',",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create,",
            "                          self.req,",
            "                          self.body)",
            "",
            "    def test_create_multiple_instances(self):",
            "        \"\"\"Test creating multiple instances but not asking for",
            "        reservation_id",
            "        \"\"\"",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "        self.assertEqual(FAKE_UUID, res[\"server\"][\"id\"])",
            "        self._check_admin_pass_len(res[\"server\"])",
            "",
            "    def test_create_multiple_instances_pass_disabled(self):",
            "        \"\"\"Test creating multiple instances but not asking for",
            "        reservation_id",
            "        \"\"\"",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        self.flags(enable_instance_password=False)",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "        self.assertEqual(FAKE_UUID, res[\"server\"][\"id\"])",
            "        self._check_admin_pass_missing(res[\"server\"])",
            "",
            "    def test_create_multiple_instances_resv_id_return(self):",
            "        \"\"\"Test creating multiple instances with asking for",
            "        reservation_id",
            "        \"\"\"",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        self.body['server']['return_reservation_id'] = True",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body)",
            "        reservation_id = res.obj.get('reservation_id')",
            "        self.assertNotEqual(reservation_id, \"\")",
            "        self.assertNotEqual(reservation_id, None)",
            "        self.assertTrue(len(reservation_id) > 1)",
            "",
            "    def test_create_multiple_instances_with_multiple_volume_bdm(self):",
            "        \"\"\"",
            "        Test that a BadRequest is raised if multiple instances",
            "        are requested with a list of block device mappings for volumes.",
            "        \"\"\"",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        min_count = 2",
            "        bdm = [{'device_name': 'foo1', 'volume_id': 'vol-xxxx'},",
            "               {'device_name': 'foo2', 'volume_id': 'vol-yyyy'}",
            "        ]",
            "        params = {",
            "                  'block_device_mapping': bdm,",
            "                  'min_count': min_count",
            "        }",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['min_count'], 2)",
            "            self.assertEqual(len(kwargs['block_device_mapping']), 2)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, params, no_image=True)",
            "",
            "    def test_create_multiple_instances_with_single_volume_bdm(self):",
            "        \"\"\"",
            "        Test that a BadRequest is raised if multiple instances",
            "        are requested to boot from a single volume.",
            "        \"\"\"",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        min_count = 2",
            "        bdm = [{'device_name': 'foo1', 'volume_id': 'vol-xxxx'}]",
            "        params = {",
            "                 'block_device_mapping': bdm,",
            "                 'min_count': min_count",
            "        }",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['min_count'], 2)",
            "            self.assertEqual(kwargs['block_device_mapping']['volume_id'],",
            "                            'vol-xxxx')",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, params, no_image=True)",
            "",
            "    def test_create_multiple_instance_with_non_integer_max_count(self):",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        self.body['server']['max_count'] = 2.5",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_multiple_instance_with_non_integer_min_count(self):",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        self.body['server']['min_count'] = 2.5",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_image_ref_is_bookmark(self):",
            "        image_href = 'http://localhost/fake/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "        server = res['server']",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_image_ref_is_invalid(self):",
            "        image_uuid = 'this_is_not_a_valid_uuid'",
            "        image_href = 'http://localhost/fake/images/%s' % image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.create,",
            "                          self.req, self.body)",
            "",
            "    def test_create_instance_no_key_pair(self):",
            "        fakes.stub_out_key_pair_funcs(self.stubs, have_key_pair=False)",
            "        self._test_create_instance()",
            "",
            "    def _test_create_extra(self, params, no_image=False):",
            "        self.body['server']['flavorRef'] = 2",
            "        if no_image:",
            "            self.body['server'].pop('imageRef', None)",
            "        self.body['server'].update(params)",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        server = self.controller.create(self.req, self.body).obj['server']",
            "",
            "    def test_create_instance_with_security_group_enabled(self):",
            "        self.ext_mgr.extensions = {'os-security-groups': 'fake'}",
            "        group = 'foo'",
            "        old_create = compute_api.API.create",
            "",
            "        def sec_group_get(ctx, proj, name):",
            "            if name == group:",
            "                return True",
            "            else:",
            "                raise exception.SecurityGroupNotFoundForProject(",
            "                    project_id=proj, security_group_id=name)",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['security_group'], [group])",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(db, 'security_group_get_by_name', sec_group_get)",
            "        # negative test",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra,",
            "                          {'security_groups': [{'name': 'bogus'}]})",
            "        # positive test - extra assert in create path",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra({'security_groups': [{'name': group}]})",
            "",
            "    def test_create_instance_with_access_ip(self):",
            "        # proper local hrefs must start with 'http://localhost/v2/'",
            "        image_href = 'http://localhost/v2/fake/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['accessIPv4'] = '1.2.3.4'",
            "        self.body['server']['accessIPv6'] = 'fead::1234'",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "        server = res['server']",
            "        self._check_admin_pass_len(server)",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_with_access_ip_pass_disabled(self):",
            "        # test with admin passwords disabled See lp bug 921814",
            "        # proper local hrefs must start with 'http://localhost/v2/'",
            "        self.flags(enable_instance_password=False)",
            "        image_href = 'http://localhost/v2/fake/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['accessIPv4'] = '1.2.3.4'",
            "        self.body['server']['accessIPv6'] = 'fead::1234'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self._check_admin_pass_missing(server)",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_bad_format_access_ip_v4(self):",
            "        # proper local hrefs must start with 'http://localhost/v2/'",
            "        image_href = 'http://localhost/v2/fake/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['accessIPv4'] = 'bad_format'",
            "        self.body['server']['accessIPv6'] = 'fead::1234'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.create,",
            "                          self.req, self.body)",
            "",
            "    def test_create_instance_bad_format_access_ip_v6(self):",
            "        # proper local hrefs must start with 'http://localhost/v2/'",
            "        image_href = 'http://localhost/v2/fake/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['accessIPv4'] = '1.2.3.4'",
            "        self.body['server']['accessIPv6'] = 'bad_format'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.create,",
            "                          self.req, self.body)",
            "",
            "    def test_create_instance_name_all_blank_spaces(self):",
            "        # proper local hrefs must start with 'http://localhost/v2/'",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['name'] = ' ' * 64",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_name_too_long(self):",
            "        # proper local hrefs must start with 'http://localhost/v2/'",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['name'] = 'X' * 256",
            "        self.body['server']['imageRef'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest, self.controller.create,",
            "                          self.req, self.body)",
            "",
            "    def test_create_instance(self):",
            "        # proper local hrefs must start with 'http://localhost/v2/'",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self._check_admin_pass_len(server)",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_pass_disabled(self):",
            "        # proper local hrefs must start with 'http://localhost/v2/'",
            "        self.flags(enable_instance_password=False)",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self._check_admin_pass_missing(server)",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_too_much_metadata(self):",
            "        self.flags(quota_metadata_items=1)",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['metadata']['vote'] = 'fiddletown'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_metadata_key_too_long(self):",
            "        self.flags(quota_metadata_items=1)",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['metadata'] = {('a' * 260): '12345'}",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_metadata_value_too_long(self):",
            "        self.flags(quota_metadata_items=1)",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['metadata'] = {'key1': ('a' * 260)}",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPRequestEntityTooLarge,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_metadata_key_blank(self):",
            "        self.flags(quota_metadata_items=1)",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['metadata'] = {'': 'abcd'}",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_invalid_key_name(self):",
            "        image_href = 'http://localhost/v2/images/2'",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['key_name'] = 'nonexistentkey'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_valid_key_name(self):",
            "        self.body['server']['key_name'] = 'key'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        self.assertEqual(FAKE_UUID, res[\"server\"][\"id\"])",
            "        self._check_admin_pass_len(res[\"server\"])",
            "",
            "    def test_create_instance_invalid_flavor_href(self):",
            "        image_href = 'http://localhost/v2/images/2'",
            "        flavor_ref = 'http://localhost/v2/flavors/asdf'",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['flavorRef'] = flavor_ref",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_invalid_flavor_id_int(self):",
            "        image_href = 'http://localhost/v2/images/2'",
            "        flavor_ref = -1",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['flavorRef'] = flavor_ref",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_bad_flavor_href(self):",
            "        image_href = 'http://localhost/v2/images/2'",
            "        flavor_ref = 'http://localhost/v2/flavors/17'",
            "        self.body['server']['imageRef'] = image_href",
            "        self.body['server']['flavorRef'] = flavor_ref",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_with_config_drive(self):",
            "        self.ext_mgr.extensions = {'os-config-drive': 'fake'}",
            "        self.body['server']['config_drive'] = \"true\"",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "        server = res['server']",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_with_bad_config_drive(self):",
            "        self.ext_mgr.extensions = {'os-config-drive': 'fake'}",
            "        self.body['server']['config_drive'] = 'adcd'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_without_config_drive(self):",
            "        self.ext_mgr.extensions = {'os-config-drive': 'fake'}",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "        server = res['server']",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_with_config_drive_disabled(self):",
            "        config_drive = [{'config_drive': 'foo'}]",
            "        params = {'config_drive': config_drive}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['config_drive'], None)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_bad_href(self):",
            "        image_href = 'asdf'",
            "        self.body['server']['imageRef'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_instance_local_href(self):",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_admin_pass(self):",
            "        self.body['server']['flavorRef'] = 3,",
            "        self.body['server']['adminPass'] = 'testpass'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self.assertEqual(server['adminPass'], self.body['server']['adminPass'])",
            "",
            "    def test_create_instance_admin_pass_pass_disabled(self):",
            "        self.flags(enable_instance_password=False)",
            "        self.body['server']['flavorRef'] = 3,",
            "        self.body['server']['adminPass'] = 'testpass'",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "",
            "        server = res['server']",
            "        self.assertTrue('adminPass' in self.body['server'])",
            "        self.assertTrue('adminPass' not in server)",
            "",
            "    def test_create_instance_admin_pass_empty(self):",
            "        self.body['server']['flavorRef'] = 3,",
            "        self.body['server']['adminPass'] = ''",
            "        self.req.body = jsonutils.dumps(self.body)",
            "",
            "        # The fact that the action doesn't raise is enough validation",
            "        self.controller.create(self.req, self.body)",
            "",
            "    def test_create_instance_invalid_personality(self):",
            "",
            "        def fake_create(*args, **kwargs):",
            "            codec = 'utf8'",
            "            content = 'b25zLiINCg0KLVJpY2hhcmQgQ$$%QQmFjaA=='",
            "            start_position = 19",
            "            end_position = 20",
            "            msg = 'invalid start byte'",
            "            raise UnicodeDecodeError(codec, content, start_position,",
            "                                     end_position, msg)",
            "",
            "        self.stubs.Set(compute_api.API,",
            "                       'create',",
            "                       fake_create)",
            "",
            "        self.body['server']['personality'][0][\"contents\"] = \\",
            "            \"b25zLiINCg0KLVJpY2hhcmQgQ$$%QQmFjaA==\"",
            "",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_location(self):",
            "        selfhref = 'http://localhost/v2/fake/servers/%s' % FAKE_UUID",
            "        bookhref = 'http://localhost/fake/servers/%s' % FAKE_UUID",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        robj = self.controller.create(self.req, self.body)",
            "",
            "        self.assertEqual(robj['Location'], selfhref)",
            "",
            "    def _do_test_create_instance_above_quota(self, resource, allowed, quota,",
            "                                             expected_msg):",
            "        fakes.stub_out_instance_quota(self.stubs, allowed, quota, resource)",
            "        self.body['server']['flavorRef'] = 3",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        try:",
            "            server = self.controller.create(self.req, self.body).obj['server']",
            "            self.fail('expected quota to be exceeded')",
            "        except webob.exc.HTTPRequestEntityTooLarge as e:",
            "            self.assertEquals(e.explanation, expected_msg)",
            "",
            "    def test_create_instance_with_security_group_enabled(self):",
            "        self.ext_mgr.extensions = {'os-security-groups': 'fake'}",
            "        group = 'foo'",
            "        old_create = compute_api.API.create",
            "",
            "        def sec_group_get(ctx, proj, name):",
            "            if name == group:",
            "                return True",
            "            else:",
            "                raise exception.SecurityGroupNotFoundForProject(",
            "                    project_id=proj, security_group_id=name)",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['security_group'], [group])",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(db, 'security_group_get_by_name', sec_group_get)",
            "        # negative test",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra,",
            "                          {'security_groups': [{'name': 'bogus'}]})",
            "        # positive test - extra assert in create path",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra({'security_groups': [{'name': group}]})",
            "",
            "    def test_create_instance_with_security_group_disabled(self):",
            "        group = 'foo'",
            "        params = {'security_groups': [{'name': group}]}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            # NOTE(vish): if the security groups extension is not",
            "            #             enabled, then security groups passed in",
            "            #             are ignored.",
            "            self.assertEqual(kwargs['security_group'], ['default'])",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_disk_config_enabled(self):",
            "        self.ext_mgr.extensions = {'OS-DCF': 'fake'}",
            "        # NOTE(vish): the extension converts OS-DCF:disk_config into",
            "        #             auto_disk_config, so we are testing with",
            "        #             the_internal_value",
            "        params = {'auto_disk_config': 'AUTO'}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['auto_disk_config'], 'AUTO')",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_disk_config_disabled(self):",
            "        params = {'auto_disk_config': True}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['auto_disk_config'], False)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_scheduler_hints_enabled(self):",
            "        self.ext_mgr.extensions = {'OS-SCH-HNT': 'fake'}",
            "        hints = {'a': 'b'}",
            "        params = {'scheduler_hints': hints}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['scheduler_hints'], hints)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_scheduler_hints_disabled(self):",
            "        hints = {'a': 'b'}",
            "        params = {'scheduler_hints': hints}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['scheduler_hints'], {})",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_volumes_enabled(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "        bdm = [{'device_name': 'foo', 'volume_id': 'fake_vol'}]",
            "        params = {'block_device_mapping': bdm}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['block_device_mapping'], bdm)",
            "            return old_create(*args, **kwargs)",
            "",
            "        def _validate_bdm(*args, **kwargs):",
            "            pass",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.stubs.Set(compute_api.API, '_validate_bdm', _validate_bdm)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_volumes_enabled_no_image(self):",
            "        \"\"\"",
            "        Test that the create will fail if there is no image",
            "        and no bdms supplied in the request",
            "        \"\"\"",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertNotIn('imageRef', kwargs)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, {}, no_image=True)",
            "",
            "    def test_create_instance_with_bdm_v2_enabled_no_image(self):",
            "        self.ext_mgr.extensions = {'os-block-device-mapping-v2-boot': 'fake'}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertNotIn('imageRef', kwargs)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, {}, no_image=True)",
            "",
            "    def test_create_instance_with_volumes_enabled_and_bdms_no_image(self):",
            "        \"\"\"",
            "        Test that the create works if there is no image supplied but",
            "        os-volumes extension is enabled and bdms are supplied",
            "        \"\"\"",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "        self.mox.StubOutWithMock(compute_api.API, '_validate_bdm')",
            "        self.mox.StubOutWithMock(compute_api.API, '_get_volume_image_metadata')",
            "        bdm = [{",
            "            'id': 1,",
            "            'no_device': None,",
            "            'virtual_name': None,",
            "            'snapshot_id': None,",
            "            'volume_id': self.volume_id,",
            "            'status': 'active',",
            "            'device_name': 'vda',",
            "            'delete_on_termination': False,",
            "            'volume_image_metadata':",
            "                {'test_key': 'test_value'}",
            "        }]",
            "        volume = bdm[0]",
            "        compute_api.API._validate_bdm(mox.IgnoreArg(),",
            "                                      mox.IgnoreArg()).AndReturn(True)",
            "        compute_api.API._get_volume_image_metadata(mox.IgnoreArg(),",
            "                                                   bdm).AndReturn(volume)",
            "        params = {'block_device_mapping': bdm}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['block_device_mapping'], bdm)",
            "            self.assertNotIn('imageRef', kwargs)",
            "            return old_create(*args, **kwargs)",
            "",
            "        def _validate_bdm(*args, **kwargs):",
            "            pass",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.mox.ReplayAll()",
            "        self._test_create_extra(params, no_image=True)",
            "",
            "    def test_create_instance_with_bdm_v2_enabled_and_bdms_no_image(self):",
            "        self.ext_mgr.extensions = {",
            "            'os-volumes': 'fake',",
            "            'os-block-device-mapping-v2-boot': 'fake'}",
            "        bdm_v2 = [{",
            "            'no_device': None,",
            "            'source_type': 'volume',",
            "            'destination_type': 'volume',",
            "            'uuid': self.volume_id,",
            "            'device_name': 'vda',",
            "            'delete_on_termination': False,",
            "        }]",
            "        params = {'block_device_mapping_v2': bdm_v2}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertThat(block_device.BlockDeviceDict(bdm_v2[0]),",
            "                            matchers.DictMatches(",
            "                                kwargs['block_device_mapping'][0]))",
            "            self.assertNotIn('imageRef', kwargs)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.mox.StubOutWithMock(compute_api.API, '_validate_bdm')",
            "        self.mox.StubOutWithMock(compute_api.API, '_get_volume_image_metadata')",
            "",
            "        compute_api.API._validate_bdm(mox.IgnoreArg(),",
            "                                      mox.IgnoreArg()).AndReturn(True)",
            "        compute_api.API._get_volume_image_metadata(",
            "            mox.IgnoreArg(), mox.IgnoreArg()).AndReturn({})",
            "        self.mox.ReplayAll()",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "",
            "        self._test_create_extra(params, no_image=True)",
            "",
            "    def test_create_instance_with_volumes_disabled(self):",
            "        bdm = [{'device_name': 'foo'}]",
            "        params = {'block_device_mapping': bdm}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['block_device_mapping'], None)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_device_name_not_string(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "        old_create = compute_api.API.create",
            "        self.params = {'block_device_mapping': self.bdm}",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['block_device_mapping'], self.bdm)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, self.params)",
            "",
            "    def test_create_instance_with_device_name_empty(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "        self.bdm[0]['device_name'] = ''",
            "        params = {'block_device_mapping': self.bdm}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['block_device_mapping'], self.bdm)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, params)",
            "",
            "    def test_create_instance_with_device_name_too_long(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "        self.bdm[0]['device_name'] = 'a' * 256,",
            "        params = {'block_device_mapping': self.bdm}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['block_device_mapping'], self.bdm)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, params)",
            "",
            "    def test_create_instance_with_space_in_device_name(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "        self.bdm[0]['device_name'] = 'vd a',",
            "        params = {'block_device_mapping': self.bdm}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertTrue(kwargs['legacy_bdm'])",
            "            self.assertEqual(kwargs['block_device_mapping'], self.bdm)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, params)",
            "",
            "    def test_create_instance_with_invalid_size(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "        bdm = [{'delete_on_termination': 1,",
            "                'device_name': 'vda',",
            "                'volume_size': \"hello world\",",
            "                'volume_id': '11111111-1111-1111-1111-111111111111'}]",
            "        params = {'block_device_mapping': bdm}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['block_device_mapping'], bdm)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, params)",
            "",
            "    def test_create_instance_with_bdm_delete_on_termination(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake'}",
            "        bdm = [{'device_name': 'foo1', 'volume_id': 'fake_vol',",
            "                'delete_on_termination': 1},",
            "               {'device_name': 'foo2', 'volume_id': 'fake_vol',",
            "                'delete_on_termination': True},",
            "               {'device_name': 'foo3', 'volume_id': 'fake_vol',",
            "                'delete_on_termination': 'invalid'},",
            "               {'device_name': 'foo4', 'volume_id': 'fake_vol',",
            "                'delete_on_termination': 0},",
            "               {'device_name': 'foo5', 'volume_id': 'fake_vol',",
            "                'delete_on_termination': False}]",
            "        expected_bdm = [",
            "            {'device_name': 'foo1', 'volume_id': 'fake_vol',",
            "             'delete_on_termination': True},",
            "            {'device_name': 'foo2', 'volume_id': 'fake_vol',",
            "             'delete_on_termination': True},",
            "            {'device_name': 'foo3', 'volume_id': 'fake_vol',",
            "             'delete_on_termination': False},",
            "            {'device_name': 'foo4', 'volume_id': 'fake_vol',",
            "             'delete_on_termination': False},",
            "            {'device_name': 'foo5', 'volume_id': 'fake_vol',",
            "             'delete_on_termination': False}]",
            "        params = {'block_device_mapping': bdm}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(expected_bdm, kwargs['block_device_mapping'])",
            "            return old_create(*args, **kwargs)",
            "",
            "        def _validate_bdm(*args, **kwargs):",
            "            pass",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.stubs.Set(compute_api.API, '_validate_bdm', _validate_bdm)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_bdm_v2(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake',",
            "                                   'os-block-device-mapping-v2-boot': 'fake'}",
            "        bdm_v2 = [{'source_type': 'volume',",
            "                   'device_name': 'fake_dev',",
            "                   'uuid': 'fake_vol'}]",
            "        bdm_v2_expected = [{'source_type': 'volume',",
            "                            'device_name': 'fake_dev',",
            "                            'volume_id': 'fake_vol'}]",
            "        params = {'block_device_mapping_v2': bdm_v2}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertFalse(kwargs['legacy_bdm'])",
            "            for expected, received in zip(bdm_v2_expected,",
            "                                          kwargs['block_device_mapping']):",
            "                self.assertThat(block_device.BlockDeviceDict(expected),",
            "                                matchers.DictMatches(received))",
            "            return old_create(*args, **kwargs)",
            "",
            "        def _validate_bdm(*args, **kwargs):",
            "            pass",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.stubs.Set(compute_api.API, '_validate_bdm', _validate_bdm)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_decide_format_legacy(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake',",
            "                                   'os-block-device-mapping-v2-boot': 'fake'}",
            "        bdm = [{'device_name': 'foo1',",
            "                'volume_id': 'fake_vol',",
            "                'delete_on_termination': 1}]",
            "",
            "        expected_legacy_flag = True",
            "",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['legacy_bdm'], expected_legacy_flag)",
            "            return old_create(*args, **kwargs)",
            "",
            "        def _validate_bdm(*args, **kwargs):",
            "            pass",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.stubs.Set(compute_api.API, '_validate_bdm',",
            "                       _validate_bdm)",
            "",
            "        self._test_create_extra({})",
            "",
            "        params = {'block_device_mapping': bdm}",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_decide_format_new(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake',",
            "                                   'os-block-device-mapping-v2-boot': 'fake'}",
            "",
            "        bdm_v2 = [{'source_type': 'volume',",
            "                   'device_name': 'fake_dev',",
            "                   'uuid': 'fake_vol'}]",
            "",
            "        old_create = compute_api.API.create",
            "",
            "        expected_legacy_flag = False",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['legacy_bdm'], expected_legacy_flag)",
            "            return old_create(*args, **kwargs)",
            "",
            "        def _validate_bdm(*args, **kwargs):",
            "            pass",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self.stubs.Set(compute_api.API, '_validate_bdm',",
            "                       _validate_bdm)",
            "",
            "        params = {'block_device_mapping_v2': bdm_v2}",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_both_bdm_formats(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake',",
            "                                   'os-block-device-mapping-v2-boot': 'fake'}",
            "        bdm = [{'device_name': 'foo'}]",
            "        bdm_v2 = [{'source_type': 'volume',",
            "                   'uuid': 'fake_vol'}]",
            "        params = {'block_device_mapping': bdm,",
            "                  'block_device_mapping_v2': bdm_v2}",
            "",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, params)",
            "",
            "    def test_create_instance_bdm_v2_missing_device_name(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake',",
            "                                   'os-block-device-mapping-v2-boot': 'fake'}",
            "        bdm_v2 = [{'source_type': 'volume',",
            "                   'uuid': 'fake_vol'}]",
            "        params = {'block_device_mapping_v2': bdm_v2}",
            "",
            "        def _validate(*args, **kwargs):",
            "            pass",
            "",
            "        def _validate_bdm(*args, **kwargs):",
            "            pass",
            "",
            "        self.stubs.Set(block_device.BlockDeviceDict,",
            "                      '_validate', _validate)",
            "        self.stubs.Set(compute_api.API, '_validate_bdm',",
            "                       _validate_bdm)",
            "",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, params)",
            "",
            "    def test_create_instance_bdm_v2_validation_error(self):",
            "        self.ext_mgr.extensions = {'os-volumes': 'fake',",
            "                                   'os-block-device-mapping-v2-boot': 'fake'}",
            "        bdm_v2 = [{'device_name': 'bogus device'}]",
            "        params = {'block_device_mapping_v2': bdm_v2}",
            "",
            "        def _validate(*args, **kwargs):",
            "            raise exception.InvalidBDMFormat()",
            "",
            "        self.stubs.Set(block_device.BlockDeviceDict,",
            "                      '_validate', _validate)",
            "",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self._test_create_extra, params)",
            "",
            "    def test_create_instance_with_user_data_enabled(self):",
            "        self.ext_mgr.extensions = {'os-user-data': 'fake'}",
            "        user_data = 'fake'",
            "        params = {'user_data': user_data}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['user_data'], user_data)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_user_data_disabled(self):",
            "        user_data = 'fake'",
            "        params = {'user_data': user_data}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['user_data'], None)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_keypairs_enabled(self):",
            "        self.ext_mgr.extensions = {'os-keypairs': 'fake'}",
            "        key_name = 'green'",
            "",
            "        params = {'key_name': key_name}",
            "        old_create = compute_api.API.create",
            "",
            "        # NOTE(sdague): key pair goes back to the database,",
            "        # so we need to stub it out for tests",
            "        def key_pair_get(context, user_id, name):",
            "            return {'public_key': 'FAKE_KEY',",
            "                    'fingerprint': 'FAKE_FINGERPRINT',",
            "                    'name': name}",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['key_name'], key_name)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(db, 'key_pair_get', key_pair_get)",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_keypairs_disabled(self):",
            "        key_name = 'green'",
            "",
            "        params = {'key_name': key_name}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['key_name'], None)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_availability_zone_enabled(self):",
            "        self.ext_mgr.extensions = {'os-availability-zone': 'fake'}",
            "        availability_zone = 'fake'",
            "        params = {'availability_zone': availability_zone}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['availability_zone'], availability_zone)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "",
            "        try:",
            "            self._test_create_extra(params)",
            "        except webob.exc.HTTPBadRequest as e:",
            "            expected = 'The requested availability zone is not available'",
            "            self.assertEquals(e.explanation, expected)",
            "        admin_context = context.get_admin_context()",
            "        service1 = db.service_create(admin_context, {'host': 'host1_zones',",
            "                                         'binary': \"nova-compute\",",
            "                                         'topic': 'compute',",
            "                                         'report_count': 0})",
            "        agg = db.aggregate_create(admin_context,",
            "                {'name': 'agg1'}, {'availability_zone': availability_zone})",
            "        db.aggregate_host_add(admin_context, agg['id'], 'host1_zones')",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_availability_zone_disabled(self):",
            "        availability_zone = 'fake'",
            "        params = {'availability_zone': availability_zone}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['availability_zone'], None)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_multiple_create_enabled(self):",
            "        self.ext_mgr.extensions = {'os-multiple-create': 'fake'}",
            "        min_count = 2",
            "        max_count = 3",
            "        params = {",
            "            'min_count': min_count,",
            "            'max_count': max_count,",
            "        }",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['min_count'], 2)",
            "            self.assertEqual(kwargs['max_count'], 3)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_multiple_create_disabled(self):",
            "        ret_res_id = True",
            "        min_count = 2",
            "        max_count = 3",
            "        params = {",
            "            'min_count': min_count,",
            "            'max_count': max_count,",
            "        }",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['min_count'], 1)",
            "            self.assertEqual(kwargs['max_count'], 1)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_networks_enabled(self):",
            "        self.ext_mgr.extensions = {'os-networks': 'fake'}",
            "        net_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "        requested_networks = [{'uuid': net_uuid}]",
            "        params = {'networks': requested_networks}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            result = [('76fa36fc-c930-4bf3-8c8a-ea2a2420deb6', None)]",
            "            self.assertEqual(kwargs['requested_networks'], result)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_neutronv2_port_in_use(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        network = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'uuid': network, 'port': port}]",
            "        params = {'networks': requested_networks}",
            "",
            "        def fake_create(*args, **kwargs):",
            "            raise exception.PortInUse(port_id=port)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', fake_create)",
            "        self.assertRaises(webob.exc.HTTPConflict,",
            "                                          self._test_create_extra, params)",
            "",
            "    def test_create_instance_with_neutronv2_port_not_found(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        network = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa'",
            "        port = 'eeeeeeee-eeee-eeee-eeee-eeeeeeeeeeee'",
            "        requested_networks = [{'uuid': network, 'port': port}]",
            "        params = {'networks': requested_networks}",
            "",
            "        def fake_create(*args, **kwargs):",
            "            raise exception.PortNotFound(port_id=port)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', fake_create)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                                        self._test_create_extra, params)",
            "",
            "    def test_create_instance_with_networks_disabled_neutronv2(self):",
            "        self.flags(network_api_class='nova.network.neutronv2.api.API')",
            "        net_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "        requested_networks = [{'uuid': net_uuid}]",
            "        params = {'networks': requested_networks}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            result = [('76fa36fc-c930-4bf3-8c8a-ea2a2420deb6', None,",
            "                       None)]",
            "            self.assertEqual(kwargs['requested_networks'], result)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_networks_disabled(self):",
            "        self.ext_mgr.extensions = {}",
            "        net_uuid = '76fa36fc-c930-4bf3-8c8a-ea2a2420deb6'",
            "        requested_networks = [{'uuid': net_uuid}]",
            "        params = {'networks': requested_networks}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['requested_networks'], None)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_with_config_drive_disabled(self):",
            "        config_drive = [{'config_drive': 'foo'}]",
            "        params = {'config_drive': config_drive}",
            "        old_create = compute_api.API.create",
            "",
            "        def create(*args, **kwargs):",
            "            self.assertEqual(kwargs['config_drive'], None)",
            "            return old_create(*args, **kwargs)",
            "",
            "        self.stubs.Set(compute_api.API, 'create', create)",
            "        self._test_create_extra(params)",
            "",
            "    def test_create_instance_local_href(self):",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        res = self.controller.create(self.req, self.body).obj",
            "        server = res['server']",
            "        self.assertEqual(FAKE_UUID, server['id'])",
            "",
            "    def test_create_instance_admin_pass_empty(self):",
            "        self.body['server']['flavorRef'] = 3",
            "        self.body['server']['adminPass'] = ''",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        # The fact that the action doesn't raise is enough validation",
            "        self.controller.create(self.req, self.body)",
            "",
            "    def test_create_instance_invalid_personality(self):",
            "",
            "        def fake_create(*args, **kwargs):",
            "            codec = 'utf8'",
            "            content = 'b25zLiINCg0KLVJpY2hhcmQgQ$$%QQmFjaA=='",
            "            start_position = 19",
            "            end_position = 20",
            "            msg = 'invalid start byte'",
            "            raise UnicodeDecodeError(codec, content, start_position,",
            "                                     end_position, msg)",
            "        self.stubs.Set(compute_api.API, 'create', fake_create)",
            "        self.body['server']['personality'] = [",
            "            {",
            "                \"path\": \"/etc/banner.txt\",",
            "                \"contents\": \"b25zLiINCg0KLVJpY2hhcmQgQ$$%QQmFjaA==\",",
            "            },",
            "        ]",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        self.assertRaises(webob.exc.HTTPBadRequest,",
            "                          self.controller.create, self.req, self.body)",
            "",
            "    def test_create_location(self):",
            "        selfhref = 'http://localhost/v2/fake/servers/%s' % FAKE_UUID",
            "        bookhref = 'http://localhost/fake/servers/%s' % FAKE_UUID",
            "        image_href = 'http://localhost/v2/images/%s' % self.image_uuid",
            "        self.body['server']['imageRef'] = image_href",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        robj = self.controller.create(self.req, self.body)",
            "        self.assertEqual(robj['Location'], selfhref)",
            "",
            "    def _do_test_create_instance_above_quota(self, resource, allowed, quota,",
            "                                             expected_msg):",
            "        fakes.stub_out_instance_quota(self.stubs, allowed, quota, resource)",
            "        self.body['server']['flavorRef'] = 3",
            "        self.req.body = jsonutils.dumps(self.body)",
            "        try:",
            "            server = self.controller.create(self.req, self.body).obj['server']",
            "            self.fail('expected quota to be exceeded')",
            "        except webob.exc.HTTPRequestEntityTooLarge as e:",
            "            self.assertEquals(e.explanation, expected_msg)",
            "",
            "    def test_create_instance_above_quota_instances(self):",
            "        msg = _('Quota exceeded for instances: Requested 1, but'",
            "                ' already used 10 of 10 instances')",
            "        self._do_test_create_instance_above_quota('instances', 0, 10, msg)",
            "",
            "    def test_create_instance_above_quota_ram(self):",
            "        msg = _('Quota exceeded for ram: Requested 4096, but'",
            "                ' already used 8192 of 10240 ram')",
            "        self._do_test_create_instance_above_quota('ram', 2048, 10 * 1024, msg)",
            "",
            "    def test_create_instance_above_quota_cores(self):",
            "        msg = _('Quota exceeded for cores: Requested 2, but'",
            "                ' already used 9 of 10 cores')",
            "        self._do_test_create_instance_above_quota('cores', 1, 10, msg)",
            "",
            "",
            "class TestServerCreateRequestXMLDeserializer(test.TestCase):",
            "",
            "    def setUp(self):",
            "        super(TestServerCreateRequestXMLDeserializer, self).setUp()",
            "        self.deserializer = servers.CreateDeserializer()",
            "",
            "    def test_minimal_request(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        imageRef=\"1\"",
            "        flavorRef=\"2\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"2\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_alternate_namespace_prefix(self):",
            "        serial_request = \"\"\"",
            "<ns2:server xmlns:ns2=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        imageRef=\"1\"",
            "        flavorRef=\"2\">",
            "        <ns2:metadata><ns2:meta key=\"hello\">world</ns2:meta></ns2:metadata>",
            "        </ns2:server>",
            "        \"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"2\",",
            "                'metadata': {\"hello\": \"world\"},",
            "                },",
            "            }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_scheduler_hints_and_alternate_namespace_prefix(self):",
            "        serial_request = \"\"\"",
            "<ns2:server xmlns:ns2=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\"",
            "     imageRef=\"1\"",
            "     flavorRef=\"2\">",
            "     <ns2:metadata><ns2:meta key=\"hello\">world</ns2:meta></ns2:metadata>",
            "     <os:scheduler_hints",
            "     xmlns:os=\"http://docs.openstack.org/compute/ext/scheduler-hints/api/v2\">",
            "             <hypervisor>xen</hypervisor>",
            "             <near>eb999657-dd6b-464e-8713-95c532ac3b18</near>",
            "     </os:scheduler_hints>",
            "     </ns2:server>",
            "        \"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                'OS-SCH-HNT:scheduler_hints': {",
            "                    'hypervisor': ['xen'],",
            "                    'near': ['eb999657-dd6b-464e-8713-95c532ac3b18']",
            "                },",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"2\",",
            "                \"metadata\": {",
            "                    \"hello\": \"world\"",
            "                }",
            "            }",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_access_ipv4(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        imageRef=\"1\"",
            "        flavorRef=\"2\"",
            "        accessIPv4=\"1.2.3.4\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"2\",",
            "                \"accessIPv4\": \"1.2.3.4\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_access_ipv6(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        imageRef=\"1\"",
            "        flavorRef=\"2\"",
            "        accessIPv6=\"fead::1234\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"2\",",
            "                \"accessIPv6\": \"fead::1234\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_access_ip(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        imageRef=\"1\"",
            "        flavorRef=\"2\"",
            "        accessIPv4=\"1.2.3.4\"",
            "        accessIPv6=\"fead::1234\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"2\",",
            "                \"accessIPv4\": \"1.2.3.4\",",
            "                \"accessIPv6\": \"fead::1234\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_admin_pass(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        imageRef=\"1\"",
            "        flavorRef=\"2\"",
            "        adminPass=\"1234\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"2\",",
            "                \"adminPass\": \"1234\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_image_link(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        imageRef=\"http://localhost:8774/v2/images/2\"",
            "        flavorRef=\"3\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"http://localhost:8774/v2/images/2\",",
            "                \"flavorRef\": \"3\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_flavor_link(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        imageRef=\"1\"",
            "        flavorRef=\"http://localhost:8774/v2/flavors/3\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"http://localhost:8774/v2/flavors/3\",",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_empty_metadata_personality(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        imageRef=\"1\"",
            "        flavorRef=\"2\">",
            "    <metadata/>",
            "    <personality/>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"2\",",
            "                \"metadata\": {},",
            "                \"personality\": [],",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_multiple_metadata_items(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        imageRef=\"1\"",
            "        flavorRef=\"2\">",
            "    <metadata>",
            "        <meta key=\"one\">two</meta>",
            "        <meta key=\"open\">snack</meta>",
            "    </metadata>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"2\",",
            "                \"metadata\": {\"one\": \"two\", \"open\": \"snack\"},",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_multiple_personality_files(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"new-server-test\"",
            "        imageRef=\"1\"",
            "        flavorRef=\"2\">",
            "    <personality>",
            "        <file path=\"/etc/banner.txt\">MQ==</file>",
            "        <file path=\"/etc/hosts\">Mg==</file>",
            "    </personality>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"2\",",
            "                \"personality\": [",
            "                    {\"path\": \"/etc/banner.txt\", \"contents\": \"MQ==\"},",
            "                    {\"path\": \"/etc/hosts\", \"contents\": \"Mg==\"},",
            "                ],",
            "            },",
            "        }",
            "        self.assertThat(request['body'], matchers.DictMatches(expected))",
            "",
            "    def test_spec_request(self):",
            "        image_bookmark_link = (\"http://servers.api.openstack.org/1234/\"",
            "                               \"images/52415800-8b69-11e0-9b19-734f6f006e54\")",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        imageRef=\"%s\"",
            "        flavorRef=\"52415800-8b69-11e0-9b19-734f1195ff37\"",
            "        name=\"new-server-test\">",
            "  <metadata>",
            "    <meta key=\"My Server Name\">Apache1</meta>",
            "  </metadata>",
            "  <personality>",
            "    <file path=\"/etc/banner.txt\">Mg==</file>",
            "  </personality>",
            "</server>\"\"\" % (image_bookmark_link)",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": (\"http://servers.api.openstack.org/1234/\"",
            "                             \"images/52415800-8b69-11e0-9b19-734f6f006e54\"),",
            "                \"flavorRef\": \"52415800-8b69-11e0-9b19-734f1195ff37\",",
            "                \"metadata\": {\"My Server Name\": \"Apache1\"},",
            "                \"personality\": [",
            "                    {",
            "                        \"path\": \"/etc/banner.txt\",",
            "                        \"contents\": \"Mg==\",",
            "                    },",
            "                ],",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_empty_networks(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "    <networks/>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"networks\": [],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_one_network(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "    <networks>",
            "       <network uuid=\"1\" fixed_ip=\"10.0.1.12\"/>",
            "    </networks>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\", \"fixed_ip\": \"10.0.1.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_two_networks(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "    <networks>",
            "       <network uuid=\"1\" fixed_ip=\"10.0.1.12\"/>",
            "       <network uuid=\"2\" fixed_ip=\"10.0.2.12\"/>",
            "    </networks>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\", \"fixed_ip\": \"10.0.1.12\"},",
            "                             {\"uuid\": \"2\", \"fixed_ip\": \"10.0.2.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_second_network_node_ignored(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "    <networks>",
            "       <network uuid=\"1\" fixed_ip=\"10.0.1.12\"/>",
            "    </networks>",
            "    <networks>",
            "       <network uuid=\"2\" fixed_ip=\"10.0.2.12\"/>",
            "    </networks>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\", \"fixed_ip\": \"10.0.1.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_one_network_missing_id(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "    <networks>",
            "       <network fixed_ip=\"10.0.1.12\"/>",
            "    </networks>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"networks\": [{\"fixed_ip\": \"10.0.1.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_one_network_missing_fixed_ip(self):",
            "        serial_request = \"\"\"",
            "<server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            " name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "    <networks>",
            "       <network uuid=\"1\"/>",
            "    </networks>",
            "</server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_one_network_empty_id(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "        <networks>",
            "           <network uuid=\"\" fixed_ip=\"10.0.1.12\"/>",
            "        </networks>",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"networks\": [{\"uuid\": \"\", \"fixed_ip\": \"10.0.1.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_one_network_empty_fixed_ip(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "        <networks>",
            "           <network uuid=\"1\" fixed_ip=\"\"/>",
            "        </networks>",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\", \"fixed_ip\": \"\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_networks_duplicate_ids(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "        <networks>",
            "           <network uuid=\"1\" fixed_ip=\"10.0.1.12\"/>",
            "           <network uuid=\"1\" fixed_ip=\"10.0.2.12\"/>",
            "        </networks>",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"networks\": [{\"uuid\": \"1\", \"fixed_ip\": \"10.0.1.12\"},",
            "                             {\"uuid\": \"1\", \"fixed_ip\": \"10.0.2.12\"}],",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_availability_zone(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\"",
            "     availability_zone=\"some_zone:some_host\">",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"availability_zone\": \"some_zone:some_host\",",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_multiple_create_args(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\"",
            "     min_count=\"1\" max_count=\"3\" return_reservation_id=\"True\">",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"min_count\": \"1\",",
            "                \"max_count\": \"3\",",
            "                \"return_reservation_id\": True,",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_disk_config(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     xmlns:OS-DCF=\"http://docs.openstack.org/compute/ext/disk_config/api/v1.1\"",
            "     name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\"",
            "     OS-DCF:diskConfig=\"AUTO\">",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"OS-DCF:diskConfig\": \"AUTO\",",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_scheduler_hints(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     xmlns:OS-SCH-HNT=",
            "     \"http://docs.openstack.org/compute/ext/scheduler-hints/api/v2\"",
            "     name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "       <OS-SCH-HNT:scheduler_hints>",
            "         <different_host>",
            "           7329b667-50c7-46a6-b913-cb2a09dfeee0",
            "         </different_host>",
            "         <different_host>",
            "           f31efb24-34d2-43e1-8b44-316052956a39",
            "         </different_host>",
            "       </OS-SCH-HNT:scheduler_hints>",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"OS-SCH-HNT:scheduler_hints\": {",
            "                    \"different_host\": [",
            "                        \"7329b667-50c7-46a6-b913-cb2a09dfeee0\",",
            "                        \"f31efb24-34d2-43e1-8b44-316052956a39\",",
            "                    ]",
            "                }",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_block_device_mapping(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "     name=\"new-server-test\" imageRef=\"1\" flavorRef=\"1\">",
            "       <block_device_mapping>",
            "         <mapping volume_id=\"7329b667-50c7-46a6-b913-cb2a09dfeee0\"",
            "          device_name=\"/dev/vda\" virtual_name=\"root\"",
            "          delete_on_termination=\"False\" />",
            "         <mapping snapshot_id=\"f31efb24-34d2-43e1-8b44-316052956a39\"",
            "          device_name=\"/dev/vdb\" virtual_name=\"ephemeral0\"",
            "          delete_on_termination=\"False\" />",
            "         <mapping device_name=\"/dev/vdc\" no_device=\"True\" />",
            "       </block_device_mapping>",
            "    </server>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {\"server\": {",
            "                \"name\": \"new-server-test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"block_device_mapping\": [",
            "                    {",
            "                        \"volume_id\": \"7329b667-50c7-46a6-b913-cb2a09dfeee0\",",
            "                        \"device_name\": \"/dev/vda\",",
            "                        \"virtual_name\": \"root\",",
            "                        \"delete_on_termination\": False,",
            "                    },",
            "                    {",
            "                        \"snapshot_id\": \"f31efb24-34d2-43e1-8b44-316052956a39\",",
            "                        \"device_name\": \"/dev/vdb\",",
            "                        \"virtual_name\": \"ephemeral0\",",
            "                        \"delete_on_termination\": False,",
            "                    },",
            "                    {",
            "                        \"device_name\": \"/dev/vdc\",",
            "                        \"no_device\": True,",
            "                    },",
            "                ]",
            "                }}",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_request_with_config_drive(self):",
            "        serial_request = \"\"\"",
            "    <server xmlns=\"http://docs.openstack.org/compute/api/v2\"",
            "        name=\"config_drive_test\"",
            "        imageRef=\"1\"",
            "        flavorRef=\"1\"",
            "        config_drive=\"true\"/>\"\"\"",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = {",
            "            \"server\": {",
            "                \"name\": \"config_drive_test\",",
            "                \"imageRef\": \"1\",",
            "                \"flavorRef\": \"1\",",
            "                \"config_drive\": \"true\"",
            "            },",
            "        }",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_corrupt_xml(self):",
            "        \"\"\"Should throw a 400 error on corrupt xml.\"\"\"",
            "        self.assertRaises(",
            "                exception.MalformedRequestBody,",
            "                self.deserializer.deserialize,",
            "                utils.killer_xml_body())",
            "",
            "",
            "class TestServerActionRequestXMLDeserializer(test.TestCase):",
            "",
            "    def setUp(self):",
            "        super(TestServerActionRequestXMLDeserializer, self).setUp()",
            "        self.deserializer = servers.ActionDeserializer()",
            "",
            "    def _generate_request(self, action, disk_cfg, ref):",
            "        return \"\"\"",
            "<%(action)s xmlns=\"http://docs.openstack.org/compute/api/v1.1\"",
            "   xmlns:OS-DCF=\"http://docs.openstack.org/compute/ext/disk_config/api/v1.1\"",
            "   %(disk_config)s=\"MANUAL\" %(ref)s=\"1\"/>\"\"\" % (",
            "               {'action': action, 'disk_config': disk_cfg, 'ref': ref})",
            "",
            "    def _generate_expected(self, action, ref):",
            "        return {",
            "            \"%s\" % action: {",
            "                \"%s\" % ref: \"1\",",
            "                \"OS-DCF:diskConfig\": \"MANUAL\",",
            "            },",
            "        }",
            "",
            "    def test_rebuild_request(self):",
            "        serial_request = self._generate_request(\"rebuild\", \"OS-DCF:diskConfig\",",
            "                                                \"imageRef\")",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = self._generate_expected(\"rebuild\", \"imageRef\")",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_rebuild_request_auto_disk_config_compat(self):",
            "        serial_request = self._generate_request(\"rebuild\", \"auto_disk_config\",",
            "                                                \"imageRef\")",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = self._generate_expected(\"rebuild\", \"imageRef\")",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_resize_request(self):",
            "        serial_request = self._generate_request(\"resize\", \"OS-DCF:diskConfig\",",
            "                                                \"flavorRef\")",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = self._generate_expected(\"resize\", \"flavorRef\")",
            "        self.assertEquals(request['body'], expected)",
            "",
            "    def test_resize_request_auto_disk_config_compat(self):",
            "        serial_request = self._generate_request(\"resize\", \"auto_disk_config\",",
            "                                                \"flavorRef\")",
            "        request = self.deserializer.deserialize(serial_request)",
            "        expected = self._generate_expected(\"resize\", \"flavorRef\")",
            "        self.assertEquals(request['body'], expected)",
            "",
            "",
            "class TestAddressesXMLSerialization(test.TestCase):",
            "",
            "    index_serializer = ips.AddressesTemplate()",
            "    show_serializer = ips.NetworkTemplate()",
            "",
            "    def _serializer_test_data(self):",
            "        return {",
            "            'network_2': [",
            "                {'addr': '192.168.0.1', 'version': 4},",
            "                {'addr': 'fe80::beef', 'version': 6},",
            "            ],",
            "        }",
            "",
            "    def test_xml_declaration(self):",
            "        output = self.show_serializer.serialize(self._serializer_test_data())",
            "        has_dec = output.startswith(\"<?xml version='1.0' encoding='UTF-8'?>\")",
            "        self.assertTrue(has_dec)",
            "",
            "    def test_show(self):",
            "        output = self.show_serializer.serialize(self._serializer_test_data())",
            "        root = etree.XML(output)",
            "        network = self._serializer_test_data()['network_2']",
            "        self.assertEqual(str(root.get('id')), 'network_2')",
            "        ip_elems = root.findall('{0}ip'.format(NS))",
            "        for z, ip_elem in enumerate(ip_elems):",
            "            ip = network[z]",
            "            self.assertEqual(str(ip_elem.get('version')),",
            "                             str(ip['version']))",
            "            self.assertEqual(str(ip_elem.get('addr')),",
            "                             str(ip['addr']))",
            "",
            "    def test_index(self):",
            "        fixture = {",
            "            'addresses': {",
            "                'network_1': [",
            "                    {'addr': '192.168.0.3', 'version': 4},",
            "                    {'addr': '192.168.0.5', 'version': 4},",
            "                ],",
            "                'network_2': [",
            "                    {'addr': '192.168.0.1', 'version': 4},",
            "                    {'addr': 'fe80::beef', 'version': 6},",
            "                ],",
            "            },",
            "        }",
            "        output = self.index_serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'addresses')",
            "        addresses_dict = fixture['addresses']",
            "        network_elems = root.findall('{0}network'.format(NS))",
            "        self.assertEqual(len(network_elems), 2)",
            "        for i, network_elem in enumerate(network_elems):",
            "            network = addresses_dict.items()[i]",
            "            self.assertEqual(str(network_elem.get('id')), str(network[0]))",
            "            ip_elems = network_elem.findall('{0}ip'.format(NS))",
            "            for z, ip_elem in enumerate(ip_elems):",
            "                ip = network[1][z]",
            "                self.assertEqual(str(ip_elem.get('version')),",
            "                                 str(ip['version']))",
            "                self.assertEqual(str(ip_elem.get('addr')),",
            "                                 str(ip['addr']))",
            "",
            "",
            "class ServersViewBuilderTest(test.TestCase):",
            "",
            "    image_bookmark = \"http://localhost/fake/images/5\"",
            "    flavor_bookmark = \"http://localhost/fake/flavors/1\"",
            "",
            "    def setUp(self):",
            "        super(ServersViewBuilderTest, self).setUp()",
            "        self.flags(use_ipv6=True)",
            "        self.instance = fakes.stub_instance(",
            "            id=1,",
            "            image_ref=\"5\",",
            "            uuid=\"deadbeef-feed-edee-beef-d0ea7beefedd\",",
            "            display_name=\"test_server\",",
            "            include_fake_metadata=False)",
            "",
            "        privates = ['172.19.0.1']",
            "        publics = ['192.168.0.3']",
            "        public6s = ['b33f::fdee:ddff:fecc:bbaa']",
            "",
            "        def nw_info(*args, **kwargs):",
            "            return [(None, {'label': 'public',",
            "                            'ips': [dict(ip=ip) for ip in publics],",
            "                            'ip6s': [dict(ip=ip) for ip in public6s]}),",
            "                    (None, {'label': 'private',",
            "                            'ips': [dict(ip=ip) for ip in privates]})]",
            "",
            "        def floaters(*args, **kwargs):",
            "            return []",
            "",
            "        fakes.stub_out_nw_api_get_instance_nw_info(self.stubs, nw_info)",
            "        fakes.stub_out_nw_api_get_floating_ips_by_fixed_address(self.stubs,",
            "                                                                floaters)",
            "",
            "        self.uuid = self.instance['uuid']",
            "        self.view_builder = views.servers.ViewBuilder()",
            "        self.request = fakes.HTTPRequest.blank(\"/v2/fake\")",
            "        self.self_link = \"http://localhost/v2/fake/servers/%s\" % self.uuid",
            "        self.bookmark_link = \"http://localhost/fake/servers/%s\" % self.uuid",
            "        self.expected_detailed_server = {",
            "            \"server\": {",
            "                \"id\": self.uuid,",
            "                \"user_id\": \"fake_user\",",
            "                \"tenant_id\": \"fake_project\",",
            "                \"updated\": \"2010-11-11T11:00:00Z\",",
            "                \"created\": \"2010-10-10T12:00:00Z\",",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"accessIPv4\": \"\",",
            "                \"accessIPv6\": \"\",",
            "                \"hostId\": '',",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                  \"links\": [",
            "                                            {",
            "                          \"rel\": \"bookmark\",",
            "                          \"href\": self.flavor_bookmark,",
            "                      },",
            "                  ],",
            "                },",
            "                \"addresses\": {",
            "                    'test1': [",
            "                        {'version': 4, 'addr': '192.168.1.100'},",
            "                        {'version': 6, 'addr': '2001:db8:0:1::1'}",
            "                    ]",
            "                },",
            "                \"metadata\": {},",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": self.self_link,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": self.bookmark_link,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "        self.expected_server = {",
            "            \"server\": {",
            "                \"id\": self.uuid,",
            "                \"name\": \"test_server\",",
            "                \"links\": [",
            "                    {",
            "                        \"rel\": \"self\",",
            "                        \"href\": self.self_link,",
            "                    },",
            "                    {",
            "                        \"rel\": \"bookmark\",",
            "                        \"href\": self.bookmark_link,",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "    def test_get_flavor_valid_flavor(self):",
            "        expected = {\"id\": \"1\",",
            "                    \"links\": [{\"rel\": \"bookmark\",",
            "                               \"href\": self.flavor_bookmark}]}",
            "        result = self.view_builder._get_flavor(self.request, self.instance)",
            "        self.assertEqual(result, expected)",
            "",
            "    def test_build_server(self):",
            "        output = self.view_builder.basic(self.request, self.instance)",
            "        self.assertThat(output,",
            "                matchers.DictMatches(self.expected_server))",
            "",
            "    def test_build_server_with_project_id(self):",
            "",
            "        output = self.view_builder.basic(self.request, self.instance)",
            "        self.assertThat(output,",
            "                matchers.DictMatches(self.expected_server))",
            "",
            "    def test_build_server_detail(self):",
            "",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output,",
            "                matchers.DictMatches(self.expected_detailed_server))",
            "",
            "    def test_build_server_no_image(self):",
            "        self.instance[\"image_ref\"] = \"\"",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertEqual(output['server']['image'], \"\")",
            "",
            "    def test_build_server_detail_with_fault(self):",
            "        self.instance['vm_state'] = vm_states.ERROR",
            "        self.instance['fault'] = {",
            "            'code': 404,",
            "            'instance_uuid': self.uuid,",
            "            'message': \"HTTPNotFound\",",
            "            'details': \"Stock details for test\",",
            "            'created_at': datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "        }",
            "",
            "        self.expected_detailed_server[\"server\"][\"status\"] = \"ERROR\"",
            "        self.expected_detailed_server[\"server\"][\"fault\"] = {",
            "                    \"code\": 404,",
            "                    \"created\": \"2010-10-10T12:00:00Z\",",
            "                    \"message\": \"HTTPNotFound\",",
            "                    \"details\": \"Stock details for test\",",
            "                }",
            "        del self.expected_detailed_server[\"server\"][\"progress\"]",
            "",
            "        self.request.context = context.RequestContext('fake', 'fake')",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output,",
            "                matchers.DictMatches(self.expected_detailed_server))",
            "",
            "    def test_build_server_detail_with_fault_no_details_not_admin(self):",
            "        self.instance['vm_state'] = vm_states.ERROR",
            "        self.instance['fault'] = {",
            "            'code': 500,",
            "            'instance_uuid': self.uuid,",
            "            'message': \"Error\",",
            "            'details': 'Stock details for test',",
            "            'created_at': datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "        }",
            "",
            "        expected_fault = {\"code\": 500,",
            "                          \"created\": \"2010-10-10T12:00:00Z\",",
            "                          \"message\": \"Error\"}",
            "",
            "        self.request.context = context.RequestContext('fake', 'fake')",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output['server']['fault'],",
            "                        matchers.DictMatches(expected_fault))",
            "",
            "    def test_build_server_detail_with_fault_admin(self):",
            "        self.instance['vm_state'] = vm_states.ERROR",
            "        self.instance['fault'] = {",
            "            'code': 500,",
            "            'instance_uuid': self.uuid,",
            "            'message': \"Error\",",
            "            'details': 'Stock details for test',",
            "            'created_at': datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "        }",
            "",
            "        expected_fault = {\"code\": 500,",
            "                          \"created\": \"2010-10-10T12:00:00Z\",",
            "                          \"message\": \"Error\",",
            "                          'details': 'Stock details for test'}",
            "",
            "        self.request.environ['nova.context'].is_admin = True",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output['server']['fault'],",
            "                        matchers.DictMatches(expected_fault))",
            "",
            "    def test_build_server_detail_with_fault_no_details_admin(self):",
            "        self.instance['vm_state'] = vm_states.ERROR",
            "        self.instance['fault'] = {",
            "            'code': 500,",
            "            'instance_uuid': self.uuid,",
            "            'message': \"Error\",",
            "            'details': '',",
            "            'created_at': datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "        }",
            "",
            "        expected_fault = {\"code\": 500,",
            "                          \"created\": \"2010-10-10T12:00:00Z\",",
            "                          \"message\": \"Error\"}",
            "",
            "        self.request.environ['nova.context'].is_admin = True",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output['server']['fault'],",
            "                        matchers.DictMatches(expected_fault))",
            "",
            "    def test_build_server_detail_with_fault_but_active(self):",
            "        self.instance['vm_state'] = vm_states.ACTIVE",
            "        self.instance['progress'] = 100",
            "        self.instance['fault'] = {",
            "            'code': 404,",
            "            'instance_uuid': self.uuid,",
            "            'message': \"HTTPNotFound\",",
            "            'details': \"Stock details for test\",",
            "            'created_at': datetime.datetime(2010, 10, 10, 12, 0, 0),",
            "        }",
            "",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertFalse('fault' in output['server'])",
            "",
            "    def test_build_server_detail_active_status(self):",
            "        #set the power state of the instance to running",
            "        self.instance['vm_state'] = vm_states.ACTIVE",
            "        self.instance['progress'] = 100",
            "",
            "        self.expected_detailed_server[\"server\"][\"status\"] = \"ACTIVE\"",
            "        self.expected_detailed_server[\"server\"][\"progress\"] = 100",
            "",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output,",
            "                matchers.DictMatches(self.expected_detailed_server))",
            "",
            "    def test_build_server_detail_with_accessipv4(self):",
            "",
            "        access_ip_v4 = '1.2.3.4'",
            "        self.instance['access_ip_v4'] = access_ip_v4",
            "",
            "        self.expected_detailed_server[\"server\"][\"accessIPv4\"] = access_ip_v4",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output,",
            "                matchers.DictMatches(self.expected_detailed_server))",
            "",
            "    def test_build_server_detail_with_accessipv6(self):",
            "",
            "        access_ip_v6 = 'fead::1234'",
            "        self.instance['access_ip_v6'] = access_ip_v6",
            "",
            "        self.expected_detailed_server[\"server\"][\"accessIPv6\"] = access_ip_v6",
            "",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output,",
            "                matchers.DictMatches(self.expected_detailed_server))",
            "",
            "    def test_build_server_detail_with_metadata(self):",
            "",
            "        metadata = []",
            "        metadata.append(models.InstanceMetadata(key=\"Open\", value=\"Stack\"))",
            "        self.instance['metadata'] = metadata",
            "",
            "        self.expected_detailed_server[\"server\"][\"metadata\"] = {\"Open\": \"Stack\"}",
            "        output = self.view_builder.show(self.request, self.instance)",
            "        self.assertThat(output,",
            "                matchers.DictMatches(self.expected_detailed_server))",
            "",
            "",
            "class ServerXMLSerializationTest(test.TestCase):",
            "",
            "    TIMESTAMP = \"2010-10-11T10:30:22Z\"",
            "    SERVER_HREF = 'http://localhost/v2/servers/%s' % FAKE_UUID",
            "    SERVER_NEXT = 'http://localhost/v2/servers?limit=%s&marker=%s'",
            "    SERVER_BOOKMARK = 'http://localhost/servers/%s' % FAKE_UUID",
            "    IMAGE_BOOKMARK = 'http://localhost/images/5'",
            "    FLAVOR_BOOKMARK = 'http://localhost/flavors/1'",
            "    USERS_ATTRIBUTES = ['name', 'id', 'created', 'accessIPv4',",
            "                    'updated', 'progress', 'status', 'hostId',",
            "                    'accessIPv6']",
            "    ADMINS_ATTRIBUTES = USERS_ATTRIBUTES + ['adminPass']",
            "",
            "    def setUp(self):",
            "        super(ServerXMLSerializationTest, self).setUp()",
            "        self.body = {",
            "            \"server\": {",
            "                'id': FAKE_UUID,",
            "                'user_id': 'fake_user_id',",
            "                'tenant_id': 'fake_tenant_id',",
            "                'created': self.TIMESTAMP,",
            "                'updated': self.TIMESTAMP,",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"hostId\": 'e4d909c290d0fb1ca068ffaddf22cbd0',",
            "                \"accessIPv4\": \"1.2.3.4\",",
            "                \"accessIPv6\": \"fead::1234\",",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.IMAGE_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": self.FLAVOR_BOOKMARK,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    \"network_one\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.138\",",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.138\",",
            "                        },",
            "                    ],",
            "                    \"network_two\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.139\",",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.139\",",
            "                        },",
            "                    ],",
            "                },",
            "                \"metadata\": {",
            "                    \"Open\": \"Stack\",",
            "                    \"Number\": \"1\",",
            "                },",
            "                'links': [",
            "                    {",
            "                        'href': self.SERVER_HREF,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': self.SERVER_BOOKMARK,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            }",
            "        }",
            "",
            "    def _validate_xml(self, root, server_dict):",
            "",
            "        link_nodes = root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 2)",
            "        for i, link in enumerate(server_dict['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        metadata_root = root.find('{0}metadata'.format(NS))",
            "        metadata_elems = metadata_root.findall('{0}meta'.format(NS))",
            "        self.assertEqual(len(metadata_elems), 2)",
            "        for i, metadata_elem in enumerate(metadata_elems):",
            "            (meta_key, meta_value) = server_dict['metadata'].items()[i]",
            "            self.assertEqual(str(metadata_elem.get('key')), str(meta_key))",
            "            self.assertEqual(str(metadata_elem.text).strip(), str(meta_value))",
            "",
            "        image_root = root.find('{0}image'.format(NS))",
            "        self.assertEqual(image_root.get('id'), server_dict['image']['id'])",
            "        link_nodes = image_root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 1)",
            "        for i, link in enumerate(server_dict['image']['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        flavor_root = root.find('{0}flavor'.format(NS))",
            "        self.assertEqual(flavor_root.get('id'), server_dict['flavor']['id'])",
            "        link_nodes = flavor_root.findall('{0}link'.format(ATOMNS))",
            "        self.assertEqual(len(link_nodes), 1)",
            "        for i, link in enumerate(server_dict['flavor']['links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        addresses_root = root.find('{0}addresses'.format(NS))",
            "        addresses_dict = server_dict['addresses']",
            "        network_elems = addresses_root.findall('{0}network'.format(NS))",
            "        self.assertEqual(len(network_elems), 2)",
            "        for i, network_elem in enumerate(network_elems):",
            "            network = addresses_dict.items()[i]",
            "            self.assertEqual(str(network_elem.get('id')), str(network[0]))",
            "            ip_elems = network_elem.findall('{0}ip'.format(NS))",
            "            for z, ip_elem in enumerate(ip_elems):",
            "                ip = network[1][z]",
            "                self.assertEqual(str(ip_elem.get('version')),",
            "                                 str(ip['version']))",
            "                self.assertEqual(str(ip_elem.get('addr')),",
            "                                 str(ip['addr']))",
            "",
            "    def _validate_required_attributes(self, root, server_dict, attributes):",
            "        for key in attributes:",
            "            self.assertEqual(root.get(key), str(server_dict[key]))",
            "",
            "    def test_xml_declaration(self):",
            "        serializer = servers.ServerTemplate()",
            "",
            "        output = serializer.serialize(self.body)",
            "        has_dec = output.startswith(\"<?xml version='1.0' encoding='UTF-8'?>\")",
            "        self.assertTrue(has_dec)",
            "",
            "    def test_show(self):",
            "        serializer = servers.ServerTemplate()",
            "",
            "        output = serializer.serialize(self.body)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'server')",
            "",
            "        server_dict = self.body['server']",
            "",
            "        self._validate_required_attributes(root, server_dict,",
            "                self.USERS_ATTRIBUTES)",
            "        self._validate_xml(root, server_dict)",
            "",
            "    def test_create(self):",
            "        serializer = servers.FullServerTemplate()",
            "",
            "        self.body[\"server\"][\"adminPass\"] = \"test_password\"",
            "",
            "        output = serializer.serialize(self.body)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'server')",
            "",
            "        server_dict = self.body['server']",
            "",
            "        self._validate_required_attributes(root, server_dict,",
            "                self.ADMINS_ATTRIBUTES)",
            "        self._validate_xml(root, server_dict)",
            "",
            "    def test_index(self):",
            "        serializer = servers.MinimalServersTemplate()",
            "",
            "        uuid1 = fakes.get_fake_uuid(1)",
            "        uuid2 = fakes.get_fake_uuid(2)",
            "        expected_server_href = 'http://localhost/v2/servers/%s' % uuid1",
            "        expected_server_bookmark = 'http://localhost/servers/%s' % uuid1",
            "        expected_server_href_2 = 'http://localhost/v2/servers/%s' % uuid2",
            "        expected_server_bookmark_2 = 'http://localhost/servers/%s' % uuid2",
            "        fixture = {\"servers\": [",
            "            {",
            "                \"id\": fakes.get_fake_uuid(1),",
            "                \"name\": \"test_server\",",
            "                'links': [",
            "                    {",
            "                        'href': expected_server_href,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': expected_server_bookmark,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            },",
            "            {",
            "                \"id\": fakes.get_fake_uuid(2),",
            "                \"name\": \"test_server_2\",",
            "                'links': [",
            "                    {",
            "                        'href': expected_server_href_2,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': expected_server_bookmark_2,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            },",
            "        ]}",
            "",
            "        output = serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'servers_index')",
            "        server_elems = root.findall('{0}server'.format(NS))",
            "        self.assertEqual(len(server_elems), 2)",
            "        for i, server_elem in enumerate(server_elems):",
            "            server_dict = fixture['servers'][i]",
            "            for key in ['name', 'id']:",
            "                self.assertEqual(server_elem.get(key), str(server_dict[key]))",
            "",
            "            link_nodes = server_elem.findall('{0}link'.format(ATOMNS))",
            "            self.assertEqual(len(link_nodes), 2)",
            "            for i, link in enumerate(server_dict['links']):",
            "                for key, value in link.items():",
            "                    self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "    def test_index_with_servers_links(self):",
            "        serializer = servers.MinimalServersTemplate()",
            "",
            "        uuid1 = fakes.get_fake_uuid(1)",
            "        uuid2 = fakes.get_fake_uuid(2)",
            "        expected_server_href = 'http://localhost/v2/servers/%s' % uuid1",
            "        expected_server_next = self.SERVER_NEXT % (2, 2)",
            "        expected_server_bookmark = 'http://localhost/servers/%s' % uuid1",
            "        expected_server_href_2 = 'http://localhost/v2/servers/%s' % uuid2",
            "        expected_server_bookmark_2 = 'http://localhost/servers/%s' % uuid2",
            "        fixture = {\"servers\": [",
            "            {",
            "                \"id\": fakes.get_fake_uuid(1),",
            "                \"name\": \"test_server\",",
            "                'links': [",
            "                    {",
            "                        'href': expected_server_href,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': expected_server_bookmark,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            },",
            "            {",
            "                \"id\": fakes.get_fake_uuid(2),",
            "                \"name\": \"test_server_2\",",
            "                'links': [",
            "                    {",
            "                        'href': expected_server_href_2,",
            "                        'rel': 'self',",
            "                    },",
            "                    {",
            "                        'href': expected_server_bookmark_2,",
            "                        'rel': 'bookmark',",
            "                    },",
            "                ],",
            "            },",
            "        ],",
            "        \"servers_links\": [",
            "            {",
            "                'rel': 'next',",
            "                'href': expected_server_next,",
            "            },",
            "        ]}",
            "",
            "        output = serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'servers_index')",
            "        server_elems = root.findall('{0}server'.format(NS))",
            "        self.assertEqual(len(server_elems), 2)",
            "        for i, server_elem in enumerate(server_elems):",
            "            server_dict = fixture['servers'][i]",
            "            for key in ['name', 'id']:",
            "                self.assertEqual(server_elem.get(key), str(server_dict[key]))",
            "",
            "            link_nodes = server_elem.findall('{0}link'.format(ATOMNS))",
            "            self.assertEqual(len(link_nodes), 2)",
            "            for i, link in enumerate(server_dict['links']):",
            "                for key, value in link.items():",
            "                    self.assertEqual(link_nodes[i].get(key), value)",
            "",
            "        # Check servers_links",
            "        servers_links = root.findall('{0}link'.format(ATOMNS))",
            "        for i, link in enumerate(fixture['servers_links']):",
            "            for key, value in link.items():",
            "                self.assertEqual(servers_links[i].get(key), value)",
            "",
            "    def test_detail(self):",
            "        serializer = servers.ServersTemplate()",
            "",
            "        uuid1 = fakes.get_fake_uuid(1)",
            "        expected_server_href = 'http://localhost/v2/servers/%s' % uuid1",
            "        expected_server_bookmark = 'http://localhost/servers/%s' % uuid1",
            "        expected_image_bookmark = self.IMAGE_BOOKMARK",
            "        expected_flavor_bookmark = self.FLAVOR_BOOKMARK",
            "",
            "        uuid2 = fakes.get_fake_uuid(2)",
            "        expected_server_href_2 = 'http://localhost/v2/servers/%s' % uuid2",
            "        expected_server_bookmark_2 = 'http://localhost/servers/%s' % uuid2",
            "        fixture = {\"servers\": [",
            "            {",
            "                \"id\": fakes.get_fake_uuid(1),",
            "                \"user_id\": \"fake\",",
            "                \"tenant_id\": \"fake\",",
            "                'created': self.TIMESTAMP,",
            "                'updated': self.TIMESTAMP,",
            "                \"progress\": 0,",
            "                \"name\": \"test_server\",",
            "                \"status\": \"BUILD\",",
            "                \"accessIPv4\": \"1.2.3.4\",",
            "                \"accessIPv6\": \"fead::1234\",",
            "                \"hostId\": 'e4d909c290d0fb1ca068ffaddf22cbd0',",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": expected_image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": expected_flavor_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    \"network_one\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.138\",",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.138\",",
            "                        },",
            "                    ],",
            "                    \"network_two\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.139\",",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.139\",",
            "                        },",
            "                    ],",
            "                },",
            "                \"metadata\": {",
            "                    \"Open\": \"Stack\",",
            "                    \"Number\": \"1\",",
            "                },",
            "                \"links\": [",
            "                    {",
            "                        \"href\": expected_server_href,",
            "                        \"rel\": \"self\",",
            "                    },",
            "                    {",
            "                        \"href\": expected_server_bookmark,",
            "                        \"rel\": \"bookmark\",",
            "                    },",
            "                ],",
            "            },",
            "            {",
            "                \"id\": fakes.get_fake_uuid(2),",
            "                \"user_id\": 'fake',",
            "                \"tenant_id\": 'fake',",
            "                'created': self.TIMESTAMP,",
            "                'updated': self.TIMESTAMP,",
            "                \"progress\": 100,",
            "                \"name\": \"test_server_2\",",
            "                \"status\": \"ACTIVE\",",
            "                \"accessIPv4\": \"1.2.3.4\",",
            "                \"accessIPv6\": \"fead::1234\",",
            "                \"hostId\": 'e4d909c290d0fb1ca068ffaddf22cbd0',",
            "                \"image\": {",
            "                    \"id\": \"5\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": expected_image_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"flavor\": {",
            "                    \"id\": \"1\",",
            "                    \"links\": [",
            "                        {",
            "                            \"rel\": \"bookmark\",",
            "                            \"href\": expected_flavor_bookmark,",
            "                        },",
            "                    ],",
            "                },",
            "                \"addresses\": {",
            "                    \"network_one\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.138\",",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.138\",",
            "                        },",
            "                    ],",
            "                    \"network_two\": [",
            "                        {",
            "                            \"version\": 4,",
            "                            \"addr\": \"67.23.10.139\",",
            "                        },",
            "                        {",
            "                            \"version\": 6,",
            "                            \"addr\": \"::babe:67.23.10.139\",",
            "                        },",
            "                    ],",
            "                },",
            "                \"metadata\": {",
            "                    \"Open\": \"Stack\",",
            "                    \"Number\": \"2\",",
            "                },",
            "                \"links\": [",
            "                    {",
            "                        \"href\": expected_server_href_2,",
            "                        \"rel\": \"self\",",
            "                    },",
            "                    {",
            "                        \"href\": expected_server_bookmark_2,",
            "                        \"rel\": \"bookmark\",",
            "                    },",
            "                ],",
            "            },",
            "        ]}",
            "",
            "        output = serializer.serialize(fixture)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'servers')",
            "        server_elems = root.findall('{0}server'.format(NS))",
            "        self.assertEqual(len(server_elems), 2)",
            "        for i, server_elem in enumerate(server_elems):",
            "            server_dict = fixture['servers'][i]",
            "            self._validate_required_attributes(server_elem, server_dict,",
            "                    self.USERS_ATTRIBUTES)",
            "            self._validate_xml(server_elem, server_dict)",
            "",
            "    def test_update(self):",
            "        serializer = servers.ServerTemplate()",
            "",
            "        self.body[\"server\"][\"fault\"] = {",
            "                    \"code\": 500,",
            "                    \"created\": self.TIMESTAMP,",
            "                    \"message\": \"Error Message\",",
            "                    \"details\": \"Fault details\",",
            "                }",
            "        output = serializer.serialize(self.body)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'server')",
            "",
            "        server_dict = self.body['server']",
            "",
            "        self._validate_required_attributes(root, server_dict,",
            "                self.USERS_ATTRIBUTES)",
            "",
            "        self._validate_xml(root, server_dict)",
            "        fault_root = root.find('{0}fault'.format(NS))",
            "        fault_dict = server_dict['fault']",
            "        self.assertEqual(fault_root.get(\"code\"), str(fault_dict[\"code\"]))",
            "        self.assertEqual(fault_root.get(\"created\"), fault_dict[\"created\"])",
            "        msg_elem = fault_root.find('{0}message'.format(NS))",
            "        self.assertEqual(msg_elem.text, fault_dict[\"message\"])",
            "        det_elem = fault_root.find('{0}details'.format(NS))",
            "        self.assertEqual(det_elem.text, fault_dict[\"details\"])",
            "",
            "    def test_action(self):",
            "        serializer = servers.FullServerTemplate()",
            "",
            "        self.body[\"server\"][\"adminPass\"] = \"test_password\"",
            "        output = serializer.serialize(self.body)",
            "        root = etree.XML(output)",
            "        xmlutil.validate_schema(root, 'server')",
            "",
            "        server_dict = self.body['server']",
            "",
            "        self._validate_required_attributes(root, server_dict,",
            "                self.ADMINS_ATTRIBUTES)",
            "",
            "        self._validate_xml(root, server_dict)",
            "",
            "",
            "class ServersAllExtensionsTestCase(test.TestCase):",
            "    \"\"\"",
            "    Servers tests using default API router with all extensions enabled.",
            "",
            "    The intent here is to catch cases where extensions end up throwing",
            "    an exception because of a malformed request before the core API",
            "    gets a chance to validate the request and return a 422 response.",
            "",
            "    For example, ServerDiskConfigController extends servers.Controller:",
            "",
            "      @wsgi.extends",
            "      def create(self, req, body):",
            "          if 'server' in body:",
            "                self._set_disk_config(body['server'])",
            "          resp_obj = (yield)",
            "          self._show(req, resp_obj)",
            "",
            "    we want to ensure that the extension isn't barfing on an invalid",
            "    body.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        super(ServersAllExtensionsTestCase, self).setUp()",
            "        self.app = compute.APIRouter()",
            "",
            "    def test_create_missing_server(self):",
            "        # Test create with malformed body.",
            "",
            "        def fake_create(*args, **kwargs):",
            "            raise test.TestingException(\"Should not reach the compute API.\")",
            "",
            "        self.stubs.Set(compute_api.API, 'create', fake_create)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers')",
            "        req.method = 'POST'",
            "        req.content_type = 'application/json'",
            "        body = {'foo': {'a': 'b'}}",
            "",
            "        req.body = jsonutils.dumps(body)",
            "        res = req.get_response(self.app)",
            "        self.assertEqual(422, res.status_int)",
            "",
            "    def test_update_missing_server(self):",
            "        # Test create with malformed body.",
            "",
            "        def fake_update(*args, **kwargs):",
            "            raise test.TestingException(\"Should not reach the compute API.\")",
            "",
            "        self.stubs.Set(compute_api.API, 'create', fake_update)",
            "",
            "        req = fakes.HTTPRequest.blank('/fake/servers/1')",
            "        req.method = 'PUT'",
            "        req.content_type = 'application/json'",
            "        body = {'foo': {'a': 'b'}}",
            "",
            "        req.body = jsonutils.dumps(body)",
            "        res = req.get_response(self.app)",
            "        self.assertEqual(422, res.status_int)",
            "",
            "",
            "class ServersUnprocessableEntityTestCase(test.TestCase):",
            "    \"\"\"",
            "    Tests of places we throw 422 Unprocessable Entity from",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        super(ServersUnprocessableEntityTestCase, self).setUp()",
            "        self.ext_mgr = extensions.ExtensionManager()",
            "        self.ext_mgr.extensions = {}",
            "        self.controller = servers.Controller(self.ext_mgr)",
            "",
            "    def _unprocessable_server_create(self, body):",
            "        req = fakes.HTTPRequest.blank('/fake/servers')",
            "        req.method = 'POST'",
            "",
            "        self.assertRaises(webob.exc.HTTPUnprocessableEntity,",
            "                          self.controller.create, req, body)",
            "",
            "    def test_create_server_no_body(self):",
            "        self._unprocessable_server_create(body=None)",
            "",
            "    def test_create_server_missing_server(self):",
            "        body = {'foo': {'a': 'b'}}",
            "        self._unprocessable_server_create(body=body)",
            "",
            "    def test_create_server_malformed_entity(self):",
            "        body = {'server': 'string'}",
            "        self._unprocessable_server_create(body=body)",
            "",
            "    def _unprocessable_server_update(self, body):",
            "        req = fakes.HTTPRequest.blank('/fake/servers/%s' % FAKE_UUID)",
            "        req.method = 'PUT'",
            "",
            "        self.assertRaises(webob.exc.HTTPUnprocessableEntity,",
            "                          self.controller.update, req, FAKE_UUID, body)",
            "",
            "    def test_update_server_no_body(self):",
            "        self._unprocessable_server_update(body=None)",
            "",
            "    def test_update_server_missing_server(self):",
            "        body = {'foo': {'a': 'b'}}",
            "        self._unprocessable_server_update(body=body)",
            "",
            "    def test_create_update_malformed_entity(self):",
            "        body = {'server': 'string'}",
            "        self._unprocessable_server_update(body=body)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1738": [
                "ServersControllerCreateTest",
                "_test_create_instance"
            ],
            "1741": [
                "ServersControllerCreateTest",
                "_test_create_instance"
            ]
        },
        "addLocation": []
    }
}