{
    "tensorflow/python/ops/script_ops_test.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from tensorflow.python.eager import def_function"
            },
            "1": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from tensorflow.python.framework import constant_op"
            },
            "2": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from tensorflow.python.framework import dtypes"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+from tensorflow.python.framework import errors"
            },
            "4": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from tensorflow.python.framework import test_util"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+from tensorflow.python.ops import gen_script_ops"
            },
            "6": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from tensorflow.python.ops import resource_variable_ops"
            },
            "7": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from tensorflow.python.ops import script_ops"
            },
            "8": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from tensorflow.python.ops.script_ops import numpy_function"
            },
            "9": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "     expect_result = constant_op.constant(3, dtypes.int32)"
            },
            "10": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "     self.assertAllEqual(actual_result, expect_result)"
            },
            "11": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 107,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+  @test_util.run_in_graph_and_eager_modes"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+  def test_fail_on_non_utf8_token(self):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+    value = constant_op.constant(value=[1, 2])"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+    token = b\"\\xb0\""
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+    data_type = [dtypes.int32]"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+    with self.assertRaises((errors.InternalError, UnicodeDecodeError)):"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+      self.evaluate("
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+          gen_script_ops.py_func(input=[value], token=token, Tout=data_type))"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 117,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 118,
                "PatchRowcode": " if __name__ == \"__main__\":"
            },
            "23": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "   test.main()"
            }
        },
        "frontPatchFile": [
            "# Copyright 2020 The TensorFlow Authors. All Rights Reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "# ==============================================================================",
            "\"\"\"Tests for script operations.\"\"\"",
            "",
            "from tensorflow.python.eager import def_function",
            "from tensorflow.python.framework import constant_op",
            "from tensorflow.python.framework import dtypes",
            "from tensorflow.python.framework import test_util",
            "from tensorflow.python.ops import resource_variable_ops",
            "from tensorflow.python.ops import script_ops",
            "from tensorflow.python.ops.script_ops import numpy_function",
            "from tensorflow.python.platform import test",
            "",
            "",
            "class NumpyFunctionTest(test.TestCase):",
            "",
            "  @test_util.run_in_graph_and_eager_modes",
            "  def test_numpy_arguments(self):",
            "",
            "    def plus(a, b):",
            "      return a + b",
            "",
            "    actual_result = script_ops.numpy_function(plus, [1, 2], dtypes.int32)",
            "    expect_result = constant_op.constant(3, dtypes.int32)",
            "    self.assertAllEqual(actual_result, expect_result)",
            "",
            "  def test_stateless(self):",
            "    call_count = 0",
            "",
            "    def plus(a, b):",
            "      nonlocal call_count",
            "      call_count += 1",
            "      return a + b",
            "",
            "    @def_function.function",
            "    def numpy_func_stateless(a, b):",
            "      return numpy_function(plus, [a, b], dtypes.int32, stateful=False)",
            "",
            "    @def_function.function",
            "    def func_stateless(a, b):",
            "      sum1 = numpy_func_stateless(a, b)",
            "      sum2 = numpy_func_stateless(a, b)",
            "      return sum1 + sum2",
            "",
            "    self.evaluate(func_stateless(",
            "        constant_op.constant(1),",
            "        constant_op.constant(2),",
            "    ))",
            "",
            "    self.assertIn(call_count, (1, 2))  # as stateless, func may be deduplicated",
            "",
            "  def test_stateful(self):",
            "    call_count = 0",
            "",
            "    def plus(a, b):",
            "      nonlocal call_count",
            "      call_count += 1",
            "      return a + b",
            "",
            "    @def_function.function",
            "    def numpy_func_stateful(a, b):",
            "      return numpy_function(plus, [a, b], dtypes.int32, stateful=True)",
            "",
            "    @def_function.function",
            "    def func_stateful(a, b):",
            "      sum1 = numpy_func_stateful(a, b)",
            "      sum2 = numpy_func_stateful(a, b)",
            "      return sum1 + sum2",
            "",
            "    self.evaluate(func_stateful(",
            "        constant_op.constant(1),",
            "        constant_op.constant(2),",
            "    ))",
            "",
            "    self.assertEqual(call_count,",
            "                     2)  # as stateful, func is guaranteed to execute twice",
            "",
            "",
            "class PyFunctionTest(test.TestCase):",
            "",
            "  @test_util.run_in_graph_and_eager_modes",
            "  def test_variable_arguments(self):",
            "",
            "    def plus(a, b):",
            "      return a + b",
            "",
            "    v1 = resource_variable_ops.ResourceVariable(1)",
            "    self.evaluate(v1.initializer)",
            "",
            "    actual_result = script_ops.eager_py_func(plus, [v1, 2], dtypes.int32)",
            "    expect_result = constant_op.constant(3, dtypes.int32)",
            "    self.assertAllEqual(actual_result, expect_result)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "  test.main()"
        ],
        "afterPatchFile": [
            "# Copyright 2020 The TensorFlow Authors. All Rights Reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "# ==============================================================================",
            "\"\"\"Tests for script operations.\"\"\"",
            "",
            "from tensorflow.python.eager import def_function",
            "from tensorflow.python.framework import constant_op",
            "from tensorflow.python.framework import dtypes",
            "from tensorflow.python.framework import errors",
            "from tensorflow.python.framework import test_util",
            "from tensorflow.python.ops import gen_script_ops",
            "from tensorflow.python.ops import resource_variable_ops",
            "from tensorflow.python.ops import script_ops",
            "from tensorflow.python.ops.script_ops import numpy_function",
            "from tensorflow.python.platform import test",
            "",
            "",
            "class NumpyFunctionTest(test.TestCase):",
            "",
            "  @test_util.run_in_graph_and_eager_modes",
            "  def test_numpy_arguments(self):",
            "",
            "    def plus(a, b):",
            "      return a + b",
            "",
            "    actual_result = script_ops.numpy_function(plus, [1, 2], dtypes.int32)",
            "    expect_result = constant_op.constant(3, dtypes.int32)",
            "    self.assertAllEqual(actual_result, expect_result)",
            "",
            "  def test_stateless(self):",
            "    call_count = 0",
            "",
            "    def plus(a, b):",
            "      nonlocal call_count",
            "      call_count += 1",
            "      return a + b",
            "",
            "    @def_function.function",
            "    def numpy_func_stateless(a, b):",
            "      return numpy_function(plus, [a, b], dtypes.int32, stateful=False)",
            "",
            "    @def_function.function",
            "    def func_stateless(a, b):",
            "      sum1 = numpy_func_stateless(a, b)",
            "      sum2 = numpy_func_stateless(a, b)",
            "      return sum1 + sum2",
            "",
            "    self.evaluate(func_stateless(",
            "        constant_op.constant(1),",
            "        constant_op.constant(2),",
            "    ))",
            "",
            "    self.assertIn(call_count, (1, 2))  # as stateless, func may be deduplicated",
            "",
            "  def test_stateful(self):",
            "    call_count = 0",
            "",
            "    def plus(a, b):",
            "      nonlocal call_count",
            "      call_count += 1",
            "      return a + b",
            "",
            "    @def_function.function",
            "    def numpy_func_stateful(a, b):",
            "      return numpy_function(plus, [a, b], dtypes.int32, stateful=True)",
            "",
            "    @def_function.function",
            "    def func_stateful(a, b):",
            "      sum1 = numpy_func_stateful(a, b)",
            "      sum2 = numpy_func_stateful(a, b)",
            "      return sum1 + sum2",
            "",
            "    self.evaluate(func_stateful(",
            "        constant_op.constant(1),",
            "        constant_op.constant(2),",
            "    ))",
            "",
            "    self.assertEqual(call_count,",
            "                     2)  # as stateful, func is guaranteed to execute twice",
            "",
            "",
            "class PyFunctionTest(test.TestCase):",
            "",
            "  @test_util.run_in_graph_and_eager_modes",
            "  def test_variable_arguments(self):",
            "",
            "    def plus(a, b):",
            "      return a + b",
            "",
            "    v1 = resource_variable_ops.ResourceVariable(1)",
            "    self.evaluate(v1.initializer)",
            "",
            "    actual_result = script_ops.eager_py_func(plus, [v1, 2], dtypes.int32)",
            "    expect_result = constant_op.constant(3, dtypes.int32)",
            "    self.assertAllEqual(actual_result, expect_result)",
            "",
            "  @test_util.run_in_graph_and_eager_modes",
            "  def test_fail_on_non_utf8_token(self):",
            "    value = constant_op.constant(value=[1, 2])",
            "    token = b\"\\xb0\"",
            "    data_type = [dtypes.int32]",
            "    with self.assertRaises((errors.InternalError, UnicodeDecodeError)):",
            "      self.evaluate(",
            "          gen_script_ops.py_func(input=[value], token=token, Tout=data_type))",
            "",
            "",
            "if __name__ == \"__main__\":",
            "  test.main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "tensorflow.python.ops.script_ops_test.PyFunctionTest.self",
            "nltk.downloader.Downloader.download"
        ]
    }
}