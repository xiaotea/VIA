{
    "radicale/pathutils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "     return new_path + trailing_slash"
            },
            "1": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+def is_safe_path_component(path):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+    \"\"\"Checks if path is a single component of a path and is safe to join\"\"\""
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+    if not path:"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+        return False"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+    head, _ = posixpath.split(path)"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+    if head:"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+        return False"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+    if path in (\".\", \"..\"):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+        return False"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+    return True"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " def is_safe_filesystem_path_component(path):"
            },
            "16": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "     \"\"\"Checks if path is a single component of a local filesystem path"
            },
            "17": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 57,
                "PatchRowcode": "        and is safe to join\"\"\""
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "#",
            "# This file is part of Radicale Server - Calendar Server",
            "#",
            "# This library is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This library is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Radicale.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "\"\"\"",
            "Helper functions for working with paths",
            "",
            "\"\"\"",
            "",
            "import os",
            "import posixpath",
            "",
            "from . import log",
            "",
            "",
            "def sanitize_path(path):",
            "    \"\"\"Make absolute (with leading slash) to prevent access to other data.",
            "       Preserves an potential trailing slash.\"\"\"",
            "    trailing_slash = \"/\" if path.endswith(\"/\") else \"\"",
            "    path = posixpath.normpath(path)",
            "    new_path = \"/\"",
            "    for part in path.split(\"/\"):",
            "        if not part or part in (\".\", \"..\"):",
            "            continue",
            "        new_path = posixpath.join(new_path, part)",
            "    trailing_slash = \"\" if new_path.endswith(\"/\") else trailing_slash",
            "    return new_path + trailing_slash",
            "",
            "",
            "def is_safe_filesystem_path_component(path):",
            "    \"\"\"Checks if path is a single component of a local filesystem path",
            "       and is safe to join\"\"\"",
            "    if not path:",
            "        return False",
            "    drive, _ = os.path.splitdrive(path)",
            "    if drive:",
            "        return False",
            "    head, _ = os.path.split(path)",
            "    if head:",
            "        return False",
            "    if path in (os.curdir, os.pardir):",
            "        return False",
            "    return True",
            "",
            "",
            "def path_to_filesystem(path, base_folder):",
            "    \"\"\"Converts path to a local filesystem path relative to base_folder",
            "        in a secure manner or raises ValueError.\"\"\"",
            "    sane_path = sanitize_path(path).strip(\"/\")",
            "    safe_path = base_folder",
            "    if not sane_path:",
            "        return safe_path",
            "    for part in sane_path.split(\"/\"):",
            "        if not is_safe_filesystem_path_component(part):",
            "            log.LOGGER.debug(\"Can't translate path safely to filesystem: %s\",",
            "                             path)",
            "            raise ValueError(\"Unsafe path\")",
            "        safe_path = os.path.join(safe_path, part)",
            "    return safe_path"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "#",
            "# This file is part of Radicale Server - Calendar Server",
            "#",
            "# This library is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This library is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Radicale.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "\"\"\"",
            "Helper functions for working with paths",
            "",
            "\"\"\"",
            "",
            "import os",
            "import posixpath",
            "",
            "from . import log",
            "",
            "",
            "def sanitize_path(path):",
            "    \"\"\"Make absolute (with leading slash) to prevent access to other data.",
            "       Preserves an potential trailing slash.\"\"\"",
            "    trailing_slash = \"/\" if path.endswith(\"/\") else \"\"",
            "    path = posixpath.normpath(path)",
            "    new_path = \"/\"",
            "    for part in path.split(\"/\"):",
            "        if not part or part in (\".\", \"..\"):",
            "            continue",
            "        new_path = posixpath.join(new_path, part)",
            "    trailing_slash = \"\" if new_path.endswith(\"/\") else trailing_slash",
            "    return new_path + trailing_slash",
            "",
            "",
            "def is_safe_path_component(path):",
            "    \"\"\"Checks if path is a single component of a path and is safe to join\"\"\"",
            "    if not path:",
            "        return False",
            "    head, _ = posixpath.split(path)",
            "    if head:",
            "        return False",
            "    if path in (\".\", \"..\"):",
            "        return False",
            "    return True",
            "",
            "",
            "def is_safe_filesystem_path_component(path):",
            "    \"\"\"Checks if path is a single component of a local filesystem path",
            "       and is safe to join\"\"\"",
            "    if not path:",
            "        return False",
            "    drive, _ = os.path.splitdrive(path)",
            "    if drive:",
            "        return False",
            "    head, _ = os.path.split(path)",
            "    if head:",
            "        return False",
            "    if path in (os.curdir, os.pardir):",
            "        return False",
            "    return True",
            "",
            "",
            "def path_to_filesystem(path, base_folder):",
            "    \"\"\"Converts path to a local filesystem path relative to base_folder",
            "        in a secure manner or raises ValueError.\"\"\"",
            "    sane_path = sanitize_path(path).strip(\"/\")",
            "    safe_path = base_folder",
            "    if not sane_path:",
            "        return safe_path",
            "    for part in sane_path.split(\"/\"):",
            "        if not is_safe_filesystem_path_component(part):",
            "            log.LOGGER.debug(\"Can't translate path safely to filesystem: %s\",",
            "                             path)",
            "            raise ValueError(\"Unsafe path\")",
            "        safe_path = os.path.join(safe_path, part)",
            "    return safe_path"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "hpack"
        ]
    },
    "radicale/storage/filesystem.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " import sys"
            },
            "1": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " from contextlib import contextmanager"
            },
            "2": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from .. import config, ical, pathutils"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+from .. import config, ical, log, pathutils"
            },
            "5": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " FOLDER = os.path.expanduser(config.get(\"storage\", \"filesystem_folder\"))"
            },
            "8": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "         filesystem_path = pathutils.path_to_filesystem(path, FOLDER)"
            },
            "9": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "         _, directories, files = next(os.walk(filesystem_path))"
            },
            "10": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "         for filename in directories + files:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+            # make sure that the local filename can be translated"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+            # into an internal path"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+            if not pathutils.is_safe_path_component(filename):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+                log.LOGGER.debug(\"Skipping unsupported filename: %s\","
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+                                 filename)"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+                continue"
            },
            "17": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 109,
                "PatchRowcode": "             rel_filename = posixpath.join(path, filename)"
            },
            "18": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 110,
                "PatchRowcode": "             if cls.is_node(rel_filename) or cls.is_leaf(rel_filename):"
            },
            "19": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "                 yield cls(rel_filename)"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "#",
            "# This file is part of Radicale Server - Calendar Server",
            "# Copyright \u00a9 2012-2015 Guillaume Ayoub",
            "#",
            "# This library is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This library is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Radicale.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "\"\"\"",
            "Filesystem storage backend.",
            "",
            "\"\"\"",
            "",
            "import codecs",
            "import os",
            "import posixpath",
            "import json",
            "import time",
            "import sys",
            "from contextlib import contextmanager",
            "",
            "from .. import config, ical, pathutils",
            "",
            "",
            "FOLDER = os.path.expanduser(config.get(\"storage\", \"filesystem_folder\"))",
            "FILESYSTEM_ENCODING = sys.getfilesystemencoding()",
            "",
            "try:",
            "    from dulwich.repo import Repo",
            "    GIT_REPOSITORY = Repo(FOLDER)",
            "except:",
            "    GIT_REPOSITORY = None",
            "",
            "",
            "# This function overrides the builtin ``open`` function for this module",
            "# pylint: disable=W0622",
            "@contextmanager",
            "def open(path, mode=\"r\"):",
            "    \"\"\"Open a file at ``path`` with encoding set in the configuration.\"\"\"",
            "    # On enter",
            "    abs_path = os.path.join(FOLDER, path.replace(\"/\", os.sep))",
            "    with codecs.open(abs_path, mode, config.get(\"encoding\", \"stock\")) as fd:",
            "        yield fd",
            "    # On exit",
            "    if GIT_REPOSITORY and mode == \"w\":",
            "        path = os.path.relpath(abs_path, FOLDER)",
            "        GIT_REPOSITORY.stage([path])",
            "        committer = config.get(\"git\", \"committer\")",
            "        GIT_REPOSITORY.do_commit(",
            "            path.encode(\"utf-8\"), committer=committer.encode(\"utf-8\"))",
            "# pylint: enable=W0622",
            "",
            "",
            "class Collection(ical.Collection):",
            "    \"\"\"Collection stored in a flat ical file.\"\"\"",
            "    @property",
            "    def _filesystem_path(self):",
            "        \"\"\"Absolute path of the file at local ``path``.\"\"\"",
            "        return pathutils.path_to_filesystem(self.path, FOLDER)",
            "",
            "    @property",
            "    def _props_path(self):",
            "        \"\"\"Absolute path of the file storing the collection properties.\"\"\"",
            "        return self._filesystem_path + \".props\"",
            "",
            "    def _create_dirs(self):",
            "        \"\"\"Create folder storing the collection if absent.\"\"\"",
            "        if not os.path.exists(os.path.dirname(self._filesystem_path)):",
            "            os.makedirs(os.path.dirname(self._filesystem_path))",
            "",
            "    def save(self, text):",
            "        self._create_dirs()",
            "        with open(self._filesystem_path, \"w\") as fd:",
            "            fd.write(text)",
            "",
            "    def delete(self):",
            "        os.remove(self._filesystem_path)",
            "        os.remove(self._props_path)",
            "",
            "    @property",
            "    def text(self):",
            "        try:",
            "            with open(self._filesystem_path) as fd:",
            "                return fd.read()",
            "        except IOError:",
            "            return \"\"",
            "",
            "    @classmethod",
            "    def children(cls, path):",
            "        filesystem_path = pathutils.path_to_filesystem(path, FOLDER)",
            "        _, directories, files = next(os.walk(filesystem_path))",
            "        for filename in directories + files:",
            "            rel_filename = posixpath.join(path, filename)",
            "            if cls.is_node(rel_filename) or cls.is_leaf(rel_filename):",
            "                yield cls(rel_filename)",
            "",
            "    @classmethod",
            "    def is_node(cls, path):",
            "        filesystem_path = pathutils.path_to_filesystem(path, FOLDER)",
            "        return os.path.isdir(filesystem_path)",
            "",
            "    @classmethod",
            "    def is_leaf(cls, path):",
            "        filesystem_path = pathutils.path_to_filesystem(path, FOLDER)",
            "        return (os.path.isfile(filesystem_path) and not",
            "                filesystem_path.endswith(\".props\"))",
            "",
            "    @property",
            "    def last_modified(self):",
            "        modification_time = \\",
            "            time.gmtime(os.path.getmtime(self._filesystem_path))",
            "        return time.strftime(\"%a, %d %b %Y %H:%M:%S +0000\", modification_time)",
            "",
            "    @property",
            "    @contextmanager",
            "    def props(self):",
            "        # On enter",
            "        properties = {}",
            "        if os.path.exists(self._props_path):",
            "            with open(self._props_path) as prop_file:",
            "                properties.update(json.load(prop_file))",
            "        old_properties = properties.copy()",
            "        yield properties",
            "        # On exit",
            "        self._create_dirs()",
            "        if old_properties != properties:",
            "            with open(self._props_path, \"w\") as prop_file:",
            "                json.dump(properties, prop_file)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "#",
            "# This file is part of Radicale Server - Calendar Server",
            "# Copyright \u00a9 2012-2015 Guillaume Ayoub",
            "#",
            "# This library is free software: you can redistribute it and/or modify",
            "# it under the terms of the GNU General Public License as published by",
            "# the Free Software Foundation, either version 3 of the License, or",
            "# (at your option) any later version.",
            "#",
            "# This library is distributed in the hope that it will be useful,",
            "# but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "# GNU General Public License for more details.",
            "#",
            "# You should have received a copy of the GNU General Public License",
            "# along with Radicale.  If not, see <http://www.gnu.org/licenses/>.",
            "",
            "\"\"\"",
            "Filesystem storage backend.",
            "",
            "\"\"\"",
            "",
            "import codecs",
            "import os",
            "import posixpath",
            "import json",
            "import time",
            "import sys",
            "from contextlib import contextmanager",
            "",
            "from .. import config, ical, log, pathutils",
            "",
            "",
            "FOLDER = os.path.expanduser(config.get(\"storage\", \"filesystem_folder\"))",
            "FILESYSTEM_ENCODING = sys.getfilesystemencoding()",
            "",
            "try:",
            "    from dulwich.repo import Repo",
            "    GIT_REPOSITORY = Repo(FOLDER)",
            "except:",
            "    GIT_REPOSITORY = None",
            "",
            "",
            "# This function overrides the builtin ``open`` function for this module",
            "# pylint: disable=W0622",
            "@contextmanager",
            "def open(path, mode=\"r\"):",
            "    \"\"\"Open a file at ``path`` with encoding set in the configuration.\"\"\"",
            "    # On enter",
            "    abs_path = os.path.join(FOLDER, path.replace(\"/\", os.sep))",
            "    with codecs.open(abs_path, mode, config.get(\"encoding\", \"stock\")) as fd:",
            "        yield fd",
            "    # On exit",
            "    if GIT_REPOSITORY and mode == \"w\":",
            "        path = os.path.relpath(abs_path, FOLDER)",
            "        GIT_REPOSITORY.stage([path])",
            "        committer = config.get(\"git\", \"committer\")",
            "        GIT_REPOSITORY.do_commit(",
            "            path.encode(\"utf-8\"), committer=committer.encode(\"utf-8\"))",
            "# pylint: enable=W0622",
            "",
            "",
            "class Collection(ical.Collection):",
            "    \"\"\"Collection stored in a flat ical file.\"\"\"",
            "    @property",
            "    def _filesystem_path(self):",
            "        \"\"\"Absolute path of the file at local ``path``.\"\"\"",
            "        return pathutils.path_to_filesystem(self.path, FOLDER)",
            "",
            "    @property",
            "    def _props_path(self):",
            "        \"\"\"Absolute path of the file storing the collection properties.\"\"\"",
            "        return self._filesystem_path + \".props\"",
            "",
            "    def _create_dirs(self):",
            "        \"\"\"Create folder storing the collection if absent.\"\"\"",
            "        if not os.path.exists(os.path.dirname(self._filesystem_path)):",
            "            os.makedirs(os.path.dirname(self._filesystem_path))",
            "",
            "    def save(self, text):",
            "        self._create_dirs()",
            "        with open(self._filesystem_path, \"w\") as fd:",
            "            fd.write(text)",
            "",
            "    def delete(self):",
            "        os.remove(self._filesystem_path)",
            "        os.remove(self._props_path)",
            "",
            "    @property",
            "    def text(self):",
            "        try:",
            "            with open(self._filesystem_path) as fd:",
            "                return fd.read()",
            "        except IOError:",
            "            return \"\"",
            "",
            "    @classmethod",
            "    def children(cls, path):",
            "        filesystem_path = pathutils.path_to_filesystem(path, FOLDER)",
            "        _, directories, files = next(os.walk(filesystem_path))",
            "        for filename in directories + files:",
            "            # make sure that the local filename can be translated",
            "            # into an internal path",
            "            if not pathutils.is_safe_path_component(filename):",
            "                log.LOGGER.debug(\"Skipping unsupported filename: %s\",",
            "                                 filename)",
            "                continue",
            "            rel_filename = posixpath.join(path, filename)",
            "            if cls.is_node(rel_filename) or cls.is_leaf(rel_filename):",
            "                yield cls(rel_filename)",
            "",
            "    @classmethod",
            "    def is_node(cls, path):",
            "        filesystem_path = pathutils.path_to_filesystem(path, FOLDER)",
            "        return os.path.isdir(filesystem_path)",
            "",
            "    @classmethod",
            "    def is_leaf(cls, path):",
            "        filesystem_path = pathutils.path_to_filesystem(path, FOLDER)",
            "        return (os.path.isfile(filesystem_path) and not",
            "                filesystem_path.endswith(\".props\"))",
            "",
            "    @property",
            "    def last_modified(self):",
            "        modification_time = \\",
            "            time.gmtime(os.path.getmtime(self._filesystem_path))",
            "        return time.strftime(\"%a, %d %b %Y %H:%M:%S +0000\", modification_time)",
            "",
            "    @property",
            "    @contextmanager",
            "    def props(self):",
            "        # On enter",
            "        properties = {}",
            "        if os.path.exists(self._props_path):",
            "            with open(self._props_path) as prop_file:",
            "                properties.update(json.load(prop_file))",
            "        old_properties = properties.copy()",
            "        yield properties",
            "        # On exit",
            "        self._create_dirs()",
            "        if old_properties != properties:",
            "            with open(self._props_path, \"w\") as prop_file:",
            "                json.dump(properties, prop_file)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "32": []
        },
        "addLocation": []
    }
}