{
    "src/urllib3/util/url.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from ..packages import six, rfc3986"
            },
            "1": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from ..packages.rfc3986.exceptions import RFC3986Exception, ValidationError"
            },
            "2": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from ..packages.rfc3986.validators import Validator"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+from ..packages.rfc3986 import abnf_regexp, normalizers, compat, misc"
            },
            "4": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " url_attrs = ['scheme', 'auth', 'host', 'port', 'path', 'query', 'fragment']"
            },
            "7": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " # Regex for detecting URLs with schemes. RFC 3986 Section 3.1"
            },
            "8": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " SCHEME_REGEX = re.compile(r\"^(?:[a-zA-Z][a-zA-Z0-9+\\-]*:|/)\")"
            },
            "9": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+PATH_CHARS = abnf_regexp.UNRESERVED_CHARS_SET | abnf_regexp.SUB_DELIMITERS_SET | {':', '@', '/'}"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+QUERY_CHARS = FRAGMENT_CHARS = PATH_CHARS | {'?'}"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " class Url(namedtuple('Url', url_attrs)):"
            },
            "15": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     \"\"\""
            },
            "16": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 140,
                "PatchRowcode": "     return s[:min_idx], s[min_idx + 1:], min_delim"
            },
            "17": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 141,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 142,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+def _encode_invalid_chars(component, allowed_chars, encoding='utf-8'):"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+    \"\"\"Percent-encodes a URI component without reapplying"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+    onto an already percent-encoded component. Based on"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+    rfc3986.normalizers.encode_component()"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+    \"\"\""
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+    if component is None:"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+        return component"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+    # Try to see if the component we're encoding is already percent-encoded"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+    # so we can skip all '%' characters but still encode all others."
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+    percent_encodings = len(normalizers.PERCENT_MATCHER.findall("
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+                            compat.to_str(component, encoding)))"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+    uri_bytes = component.encode('utf-8', 'surrogatepass')"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+    is_percent_encoded = percent_encodings == uri_bytes.count(b'%')"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+    encoded_component = bytearray()"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+    for i in range(0, len(uri_bytes)):"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+        # Will return a single character bytestring on both Python 2 & 3"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+        byte = uri_bytes[i:i+1]"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+        byte_ord = ord(byte)"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+        if ((is_percent_encoded and byte == b'%')"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+                or (byte_ord < 128 and byte.decode() in allowed_chars)):"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+            encoded_component.extend(byte)"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+            continue"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+        encoded_component.extend('%{0:02x}'.format(byte_ord).encode().upper())"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+    return encoded_component.decode(encoding)"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+"
            },
            "50": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 174,
                "PatchRowcode": " def parse_url(url):"
            },
            "51": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 175,
                "PatchRowcode": "     \"\"\""
            },
            "52": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "     Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is"
            },
            "53": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 195,
                "PatchRowcode": "         return Url()"
            },
            "54": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 196,
                "PatchRowcode": " "
            },
            "55": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 197,
                "PatchRowcode": "     is_string = not isinstance(url, six.binary_type)"
            },
            "56": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if not is_string:"
            },
            "57": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        url = url.decode(\"utf-8\")"
            },
            "58": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 198,
                "PatchRowcode": " "
            },
            "59": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 199,
                "PatchRowcode": "     # RFC 3986 doesn't like URLs that have a host but don't start"
            },
            "60": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 200,
                "PatchRowcode": "     # with a scheme and we support URLs like that so we need to"
            },
            "61": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "     if not SCHEME_REGEX.search(url):"
            },
            "62": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 205,
                "PatchRowcode": "         url = \"//\" + url"
            },
            "63": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 206,
                "PatchRowcode": " "
            },
            "64": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    try:"
            },
            "65": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        iri_ref = rfc3986.IRIReference.from_string(url, encoding=\"utf-8\")"
            },
            "66": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    except (ValueError, RFC3986Exception):"
            },
            "67": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        six.raise_from(LocationParseError(url), None)"
            },
            "68": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "69": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 207,
                "PatchRowcode": "     def idna_encode(name):"
            },
            "70": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": 208,
                "PatchRowcode": "         if name and any([ord(x) > 128 for x in name]):"
            },
            "71": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 209,
                "PatchRowcode": "             try:"
            },
            "72": {
                "beforePatchRowNumber": 188,
                "afterPatchRowNumber": 216,
                "PatchRowcode": "                 raise LocationParseError(u\"Name '%s' is not a valid IDNA label\" % name)"
            },
            "73": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 217,
                "PatchRowcode": "         return name"
            },
            "74": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 218,
                "PatchRowcode": " "
            },
            "75": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    has_authority = iri_ref.authority is not None"
            },
            "76": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    uri_ref = iri_ref.encode(idna_encoder=idna_encode)"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+    try:"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+        split_iri = misc.IRI_MATCHER.match(compat.to_str(url)).groupdict()"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+        iri_ref = rfc3986.IRIReference("
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+            split_iri['scheme'], split_iri['authority'],"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+            _encode_invalid_chars(split_iri['path'], PATH_CHARS),"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+            _encode_invalid_chars(split_iri['query'], QUERY_CHARS),"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+            _encode_invalid_chars(split_iri['fragment'], FRAGMENT_CHARS)"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+        )"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+        has_authority = iri_ref.authority is not None"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+        uri_ref = iri_ref.encode(idna_encoder=idna_encode)"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+    except (ValueError, RFC3986Exception):"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+        return six.raise_from(LocationParseError(url), None)"
            },
            "89": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 231,
                "PatchRowcode": " "
            },
            "90": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 232,
                "PatchRowcode": "     # rfc3986 strips the authority if it's invalid"
            },
            "91": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 233,
                "PatchRowcode": "     if has_authority and uri_ref.authority is None:"
            },
            "92": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 247,
                "PatchRowcode": "             *validator.COMPONENT_NAMES"
            },
            "93": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": 248,
                "PatchRowcode": "         ).validate(uri_ref)"
            },
            "94": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "     except ValidationError:"
            },
            "95": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        six.raise_from(LocationParseError(url), None)"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+        return six.raise_from(LocationParseError(url), None)"
            },
            "97": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 251,
                "PatchRowcode": " "
            },
            "98": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "     # For the sake of backwards compatibility we put empty"
            },
            "99": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "     # string values for path if there are any defined values"
            }
        },
        "frontPatchFile": [
            "from __future__ import absolute_import",
            "import re",
            "from collections import namedtuple",
            "",
            "from ..exceptions import LocationParseError",
            "from ..packages import six, rfc3986",
            "from ..packages.rfc3986.exceptions import RFC3986Exception, ValidationError",
            "from ..packages.rfc3986.validators import Validator",
            "",
            "",
            "url_attrs = ['scheme', 'auth', 'host', 'port', 'path', 'query', 'fragment']",
            "",
            "# We only want to normalize urls with an HTTP(S) scheme.",
            "# urllib3 infers URLs without a scheme (None) to be http.",
            "NORMALIZABLE_SCHEMES = ('http', 'https', None)",
            "",
            "# Regex for detecting URLs with schemes. RFC 3986 Section 3.1",
            "SCHEME_REGEX = re.compile(r\"^(?:[a-zA-Z][a-zA-Z0-9+\\-]*:|/)\")",
            "",
            "",
            "class Url(namedtuple('Url', url_attrs)):",
            "    \"\"\"",
            "    Data structure for representing an HTTP URL. Used as a return value for",
            "    :func:`parse_url`. Both the scheme and host are normalized as they are",
            "    both case-insensitive according to RFC 3986.",
            "    \"\"\"",
            "    __slots__ = ()",
            "",
            "    def __new__(cls, scheme=None, auth=None, host=None, port=None, path=None,",
            "                query=None, fragment=None):",
            "        if path and not path.startswith('/'):",
            "            path = '/' + path",
            "        if scheme is not None:",
            "            scheme = scheme.lower()",
            "        return super(Url, cls).__new__(cls, scheme, auth, host, port, path,",
            "                                       query, fragment)",
            "",
            "    @property",
            "    def hostname(self):",
            "        \"\"\"For backwards-compatibility with urlparse. We're nice like that.\"\"\"",
            "        return self.host",
            "",
            "    @property",
            "    def request_uri(self):",
            "        \"\"\"Absolute path including the query string.\"\"\"",
            "        uri = self.path or '/'",
            "",
            "        if self.query is not None:",
            "            uri += '?' + self.query",
            "",
            "        return uri",
            "",
            "    @property",
            "    def netloc(self):",
            "        \"\"\"Network location including host and port\"\"\"",
            "        if self.port:",
            "            return '%s:%d' % (self.host, self.port)",
            "        return self.host",
            "",
            "    @property",
            "    def url(self):",
            "        \"\"\"",
            "        Convert self into a url",
            "",
            "        This function should more or less round-trip with :func:`.parse_url`. The",
            "        returned url may not be exactly the same as the url inputted to",
            "        :func:`.parse_url`, but it should be equivalent by the RFC (e.g., urls",
            "        with a blank port will have : removed).",
            "",
            "        Example: ::",
            "",
            "            >>> U = parse_url('http://google.com/mail/')",
            "            >>> U.url",
            "            'http://google.com/mail/'",
            "            >>> Url('http', 'username:password', 'host.com', 80,",
            "            ... '/path', 'query', 'fragment').url",
            "            'http://username:password@host.com:80/path?query#fragment'",
            "        \"\"\"",
            "        scheme, auth, host, port, path, query, fragment = self",
            "        url = u''",
            "",
            "        # We use \"is not None\" we want things to happen with empty strings (or 0 port)",
            "        if scheme is not None:",
            "            url += scheme + u'://'",
            "        if auth is not None:",
            "            url += auth + u'@'",
            "        if host is not None:",
            "            url += host",
            "        if port is not None:",
            "            url += u':' + str(port)",
            "        if path is not None:",
            "            url += path",
            "        if query is not None:",
            "            url += u'?' + query",
            "        if fragment is not None:",
            "            url += u'#' + fragment",
            "",
            "        return url",
            "",
            "    def __str__(self):",
            "        return self.url",
            "",
            "",
            "def split_first(s, delims):",
            "    \"\"\"",
            "    .. deprecated:: 1.25",
            "",
            "    Given a string and an iterable of delimiters, split on the first found",
            "    delimiter. Return two split parts and the matched delimiter.",
            "",
            "    If not found, then the first part is the full input string.",
            "",
            "    Example::",
            "",
            "        >>> split_first('foo/bar?baz', '?/=')",
            "        ('foo', 'bar?baz', '/')",
            "        >>> split_first('foo/bar?baz', '123')",
            "        ('foo/bar?baz', '', None)",
            "",
            "    Scales linearly with number of delims. Not ideal for large number of delims.",
            "    \"\"\"",
            "    min_idx = None",
            "    min_delim = None",
            "    for d in delims:",
            "        idx = s.find(d)",
            "        if idx < 0:",
            "            continue",
            "",
            "        if min_idx is None or idx < min_idx:",
            "            min_idx = idx",
            "            min_delim = d",
            "",
            "    if min_idx is None or min_idx < 0:",
            "        return s, '', None",
            "",
            "    return s[:min_idx], s[min_idx + 1:], min_delim",
            "",
            "",
            "def parse_url(url):",
            "    \"\"\"",
            "    Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is",
            "    performed to parse incomplete urls. Fields not provided will be None.",
            "    This parser is RFC 3986 compliant.",
            "",
            "    :param str url: URL to parse into a :class:`.Url` namedtuple.",
            "",
            "    Partly backwards-compatible with :mod:`urlparse`.",
            "",
            "    Example::",
            "",
            "        >>> parse_url('http://google.com/mail/')",
            "        Url(scheme='http', host='google.com', port=None, path='/mail/', ...)",
            "        >>> parse_url('google.com:80')",
            "        Url(scheme=None, host='google.com', port=80, path=None, ...)",
            "        >>> parse_url('/foo?bar')",
            "        Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)",
            "    \"\"\"",
            "    if not url:",
            "        # Empty",
            "        return Url()",
            "",
            "    is_string = not isinstance(url, six.binary_type)",
            "    if not is_string:",
            "        url = url.decode(\"utf-8\")",
            "",
            "    # RFC 3986 doesn't like URLs that have a host but don't start",
            "    # with a scheme and we support URLs like that so we need to",
            "    # detect that problem and add an empty scheme indication.",
            "    # We don't get hurt on path-only URLs here as it's stripped",
            "    # off and given an empty scheme anyways.",
            "    if not SCHEME_REGEX.search(url):",
            "        url = \"//\" + url",
            "",
            "    try:",
            "        iri_ref = rfc3986.IRIReference.from_string(url, encoding=\"utf-8\")",
            "    except (ValueError, RFC3986Exception):",
            "        six.raise_from(LocationParseError(url), None)",
            "",
            "    def idna_encode(name):",
            "        if name and any([ord(x) > 128 for x in name]):",
            "            try:",
            "                import idna",
            "            except ImportError:",
            "                raise LocationParseError(\"Unable to parse URL without the 'idna' module\")",
            "            try:",
            "                return idna.encode(name.lower(), strict=True, std3_rules=True)",
            "            except idna.IDNAError:",
            "                raise LocationParseError(u\"Name '%s' is not a valid IDNA label\" % name)",
            "        return name",
            "",
            "    has_authority = iri_ref.authority is not None",
            "    uri_ref = iri_ref.encode(idna_encoder=idna_encode)",
            "",
            "    # rfc3986 strips the authority if it's invalid",
            "    if has_authority and uri_ref.authority is None:",
            "        raise LocationParseError(url)",
            "",
            "    # Only normalize schemes we understand to not break http+unix",
            "    # or other schemes that don't follow RFC 3986.",
            "    if uri_ref.scheme is None or uri_ref.scheme.lower() in NORMALIZABLE_SCHEMES:",
            "        uri_ref = uri_ref.normalize()",
            "",
            "    # Validate all URIReference components and ensure that all",
            "    # components that were set before are still set after",
            "    # normalization has completed.",
            "    validator = Validator()",
            "    try:",
            "        validator.check_validity_of(",
            "            *validator.COMPONENT_NAMES",
            "        ).validate(uri_ref)",
            "    except ValidationError:",
            "        six.raise_from(LocationParseError(url), None)",
            "",
            "    # For the sake of backwards compatibility we put empty",
            "    # string values for path if there are any defined values",
            "    # beyond the path in the URL.",
            "    # TODO: Remove this when we break backwards compatibility.",
            "    path = uri_ref.path",
            "    if not path:",
            "        if (uri_ref.query is not None",
            "                or uri_ref.fragment is not None):",
            "            path = \"\"",
            "        else:",
            "            path = None",
            "",
            "    # Ensure that each part of the URL is a `str` for",
            "    # backwards compatibility.",
            "    def to_input_type(x):",
            "        if x is None:",
            "            return None",
            "        elif not is_string and not isinstance(x, six.binary_type):",
            "            return x.encode('utf-8')",
            "        return x",
            "",
            "    return Url(",
            "        scheme=to_input_type(uri_ref.scheme),",
            "        auth=to_input_type(uri_ref.userinfo),",
            "        host=to_input_type(uri_ref.host),",
            "        port=int(uri_ref.port) if uri_ref.port is not None else None,",
            "        path=to_input_type(path),",
            "        query=to_input_type(uri_ref.query),",
            "        fragment=to_input_type(uri_ref.fragment)",
            "    )",
            "",
            "",
            "def get_host(url):",
            "    \"\"\"",
            "    Deprecated. Use :func:`parse_url` instead.",
            "    \"\"\"",
            "    p = parse_url(url)",
            "    return p.scheme or 'http', p.hostname, p.port"
        ],
        "afterPatchFile": [
            "from __future__ import absolute_import",
            "import re",
            "from collections import namedtuple",
            "",
            "from ..exceptions import LocationParseError",
            "from ..packages import six, rfc3986",
            "from ..packages.rfc3986.exceptions import RFC3986Exception, ValidationError",
            "from ..packages.rfc3986.validators import Validator",
            "from ..packages.rfc3986 import abnf_regexp, normalizers, compat, misc",
            "",
            "",
            "url_attrs = ['scheme', 'auth', 'host', 'port', 'path', 'query', 'fragment']",
            "",
            "# We only want to normalize urls with an HTTP(S) scheme.",
            "# urllib3 infers URLs without a scheme (None) to be http.",
            "NORMALIZABLE_SCHEMES = ('http', 'https', None)",
            "",
            "# Regex for detecting URLs with schemes. RFC 3986 Section 3.1",
            "SCHEME_REGEX = re.compile(r\"^(?:[a-zA-Z][a-zA-Z0-9+\\-]*:|/)\")",
            "",
            "PATH_CHARS = abnf_regexp.UNRESERVED_CHARS_SET | abnf_regexp.SUB_DELIMITERS_SET | {':', '@', '/'}",
            "QUERY_CHARS = FRAGMENT_CHARS = PATH_CHARS | {'?'}",
            "",
            "",
            "class Url(namedtuple('Url', url_attrs)):",
            "    \"\"\"",
            "    Data structure for representing an HTTP URL. Used as a return value for",
            "    :func:`parse_url`. Both the scheme and host are normalized as they are",
            "    both case-insensitive according to RFC 3986.",
            "    \"\"\"",
            "    __slots__ = ()",
            "",
            "    def __new__(cls, scheme=None, auth=None, host=None, port=None, path=None,",
            "                query=None, fragment=None):",
            "        if path and not path.startswith('/'):",
            "            path = '/' + path",
            "        if scheme is not None:",
            "            scheme = scheme.lower()",
            "        return super(Url, cls).__new__(cls, scheme, auth, host, port, path,",
            "                                       query, fragment)",
            "",
            "    @property",
            "    def hostname(self):",
            "        \"\"\"For backwards-compatibility with urlparse. We're nice like that.\"\"\"",
            "        return self.host",
            "",
            "    @property",
            "    def request_uri(self):",
            "        \"\"\"Absolute path including the query string.\"\"\"",
            "        uri = self.path or '/'",
            "",
            "        if self.query is not None:",
            "            uri += '?' + self.query",
            "",
            "        return uri",
            "",
            "    @property",
            "    def netloc(self):",
            "        \"\"\"Network location including host and port\"\"\"",
            "        if self.port:",
            "            return '%s:%d' % (self.host, self.port)",
            "        return self.host",
            "",
            "    @property",
            "    def url(self):",
            "        \"\"\"",
            "        Convert self into a url",
            "",
            "        This function should more or less round-trip with :func:`.parse_url`. The",
            "        returned url may not be exactly the same as the url inputted to",
            "        :func:`.parse_url`, but it should be equivalent by the RFC (e.g., urls",
            "        with a blank port will have : removed).",
            "",
            "        Example: ::",
            "",
            "            >>> U = parse_url('http://google.com/mail/')",
            "            >>> U.url",
            "            'http://google.com/mail/'",
            "            >>> Url('http', 'username:password', 'host.com', 80,",
            "            ... '/path', 'query', 'fragment').url",
            "            'http://username:password@host.com:80/path?query#fragment'",
            "        \"\"\"",
            "        scheme, auth, host, port, path, query, fragment = self",
            "        url = u''",
            "",
            "        # We use \"is not None\" we want things to happen with empty strings (or 0 port)",
            "        if scheme is not None:",
            "            url += scheme + u'://'",
            "        if auth is not None:",
            "            url += auth + u'@'",
            "        if host is not None:",
            "            url += host",
            "        if port is not None:",
            "            url += u':' + str(port)",
            "        if path is not None:",
            "            url += path",
            "        if query is not None:",
            "            url += u'?' + query",
            "        if fragment is not None:",
            "            url += u'#' + fragment",
            "",
            "        return url",
            "",
            "    def __str__(self):",
            "        return self.url",
            "",
            "",
            "def split_first(s, delims):",
            "    \"\"\"",
            "    .. deprecated:: 1.25",
            "",
            "    Given a string and an iterable of delimiters, split on the first found",
            "    delimiter. Return two split parts and the matched delimiter.",
            "",
            "    If not found, then the first part is the full input string.",
            "",
            "    Example::",
            "",
            "        >>> split_first('foo/bar?baz', '?/=')",
            "        ('foo', 'bar?baz', '/')",
            "        >>> split_first('foo/bar?baz', '123')",
            "        ('foo/bar?baz', '', None)",
            "",
            "    Scales linearly with number of delims. Not ideal for large number of delims.",
            "    \"\"\"",
            "    min_idx = None",
            "    min_delim = None",
            "    for d in delims:",
            "        idx = s.find(d)",
            "        if idx < 0:",
            "            continue",
            "",
            "        if min_idx is None or idx < min_idx:",
            "            min_idx = idx",
            "            min_delim = d",
            "",
            "    if min_idx is None or min_idx < 0:",
            "        return s, '', None",
            "",
            "    return s[:min_idx], s[min_idx + 1:], min_delim",
            "",
            "",
            "def _encode_invalid_chars(component, allowed_chars, encoding='utf-8'):",
            "    \"\"\"Percent-encodes a URI component without reapplying",
            "    onto an already percent-encoded component. Based on",
            "    rfc3986.normalizers.encode_component()",
            "    \"\"\"",
            "    if component is None:",
            "        return component",
            "",
            "    # Try to see if the component we're encoding is already percent-encoded",
            "    # so we can skip all '%' characters but still encode all others.",
            "    percent_encodings = len(normalizers.PERCENT_MATCHER.findall(",
            "                            compat.to_str(component, encoding)))",
            "",
            "    uri_bytes = component.encode('utf-8', 'surrogatepass')",
            "    is_percent_encoded = percent_encodings == uri_bytes.count(b'%')",
            "",
            "    encoded_component = bytearray()",
            "",
            "    for i in range(0, len(uri_bytes)):",
            "        # Will return a single character bytestring on both Python 2 & 3",
            "        byte = uri_bytes[i:i+1]",
            "        byte_ord = ord(byte)",
            "        if ((is_percent_encoded and byte == b'%')",
            "                or (byte_ord < 128 and byte.decode() in allowed_chars)):",
            "            encoded_component.extend(byte)",
            "            continue",
            "        encoded_component.extend('%{0:02x}'.format(byte_ord).encode().upper())",
            "",
            "    return encoded_component.decode(encoding)",
            "",
            "",
            "def parse_url(url):",
            "    \"\"\"",
            "    Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is",
            "    performed to parse incomplete urls. Fields not provided will be None.",
            "    This parser is RFC 3986 compliant.",
            "",
            "    :param str url: URL to parse into a :class:`.Url` namedtuple.",
            "",
            "    Partly backwards-compatible with :mod:`urlparse`.",
            "",
            "    Example::",
            "",
            "        >>> parse_url('http://google.com/mail/')",
            "        Url(scheme='http', host='google.com', port=None, path='/mail/', ...)",
            "        >>> parse_url('google.com:80')",
            "        Url(scheme=None, host='google.com', port=80, path=None, ...)",
            "        >>> parse_url('/foo?bar')",
            "        Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)",
            "    \"\"\"",
            "    if not url:",
            "        # Empty",
            "        return Url()",
            "",
            "    is_string = not isinstance(url, six.binary_type)",
            "",
            "    # RFC 3986 doesn't like URLs that have a host but don't start",
            "    # with a scheme and we support URLs like that so we need to",
            "    # detect that problem and add an empty scheme indication.",
            "    # We don't get hurt on path-only URLs here as it's stripped",
            "    # off and given an empty scheme anyways.",
            "    if not SCHEME_REGEX.search(url):",
            "        url = \"//\" + url",
            "",
            "    def idna_encode(name):",
            "        if name and any([ord(x) > 128 for x in name]):",
            "            try:",
            "                import idna",
            "            except ImportError:",
            "                raise LocationParseError(\"Unable to parse URL without the 'idna' module\")",
            "            try:",
            "                return idna.encode(name.lower(), strict=True, std3_rules=True)",
            "            except idna.IDNAError:",
            "                raise LocationParseError(u\"Name '%s' is not a valid IDNA label\" % name)",
            "        return name",
            "",
            "    try:",
            "        split_iri = misc.IRI_MATCHER.match(compat.to_str(url)).groupdict()",
            "        iri_ref = rfc3986.IRIReference(",
            "            split_iri['scheme'], split_iri['authority'],",
            "            _encode_invalid_chars(split_iri['path'], PATH_CHARS),",
            "            _encode_invalid_chars(split_iri['query'], QUERY_CHARS),",
            "            _encode_invalid_chars(split_iri['fragment'], FRAGMENT_CHARS)",
            "        )",
            "        has_authority = iri_ref.authority is not None",
            "        uri_ref = iri_ref.encode(idna_encoder=idna_encode)",
            "    except (ValueError, RFC3986Exception):",
            "        return six.raise_from(LocationParseError(url), None)",
            "",
            "    # rfc3986 strips the authority if it's invalid",
            "    if has_authority and uri_ref.authority is None:",
            "        raise LocationParseError(url)",
            "",
            "    # Only normalize schemes we understand to not break http+unix",
            "    # or other schemes that don't follow RFC 3986.",
            "    if uri_ref.scheme is None or uri_ref.scheme.lower() in NORMALIZABLE_SCHEMES:",
            "        uri_ref = uri_ref.normalize()",
            "",
            "    # Validate all URIReference components and ensure that all",
            "    # components that were set before are still set after",
            "    # normalization has completed.",
            "    validator = Validator()",
            "    try:",
            "        validator.check_validity_of(",
            "            *validator.COMPONENT_NAMES",
            "        ).validate(uri_ref)",
            "    except ValidationError:",
            "        return six.raise_from(LocationParseError(url), None)",
            "",
            "    # For the sake of backwards compatibility we put empty",
            "    # string values for path if there are any defined values",
            "    # beyond the path in the URL.",
            "    # TODO: Remove this when we break backwards compatibility.",
            "    path = uri_ref.path",
            "    if not path:",
            "        if (uri_ref.query is not None",
            "                or uri_ref.fragment is not None):",
            "            path = \"\"",
            "        else:",
            "            path = None",
            "",
            "    # Ensure that each part of the URL is a `str` for",
            "    # backwards compatibility.",
            "    def to_input_type(x):",
            "        if x is None:",
            "            return None",
            "        elif not is_string and not isinstance(x, six.binary_type):",
            "            return x.encode('utf-8')",
            "        return x",
            "",
            "    return Url(",
            "        scheme=to_input_type(uri_ref.scheme),",
            "        auth=to_input_type(uri_ref.userinfo),",
            "        host=to_input_type(uri_ref.host),",
            "        port=int(uri_ref.port) if uri_ref.port is not None else None,",
            "        path=to_input_type(path),",
            "        query=to_input_type(uri_ref.query),",
            "        fragment=to_input_type(uri_ref.fragment)",
            "    )",
            "",
            "",
            "def get_host(url):",
            "    \"\"\"",
            "    Deprecated. Use :func:`parse_url` instead.",
            "    \"\"\"",
            "    p = parse_url(url)",
            "    return p.scheme or 'http', p.hostname, p.port"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "163": [
                "parse_url"
            ],
            "164": [
                "parse_url"
            ],
            "174": [
                "parse_url"
            ],
            "175": [
                "parse_url"
            ],
            "176": [
                "parse_url"
            ],
            "177": [
                "parse_url"
            ],
            "178": [
                "parse_url"
            ],
            "191": [
                "parse_url"
            ],
            "192": [
                "parse_url"
            ],
            "212": [
                "parse_url"
            ]
        },
        "addLocation": [
            "jinja2.nodes.Const.from_untrusted",
            "src.urllib3.util.url.parse_url"
        ]
    }
}