{
    "mobsfscan/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " __title__ = 'mobsfscan'"
            },
            "1": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " __authors__ = 'Ajin Abraham'"
            },
            "2": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " __copyright__ = f'Copyright {datetime.now().year} Ajin Abraham, OpenSecurity'"
            },
            "3": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-__version__ = '0.3.6'"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+__version__ = '0.3.7'"
            },
            "5": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " __version_info__ = tuple(int(i) for i in __version__.split('.'))"
            },
            "6": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " __all__ = ["
            },
            "7": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": "     '__title__',"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf_8 -*-",
            "from datetime import datetime",
            "",
            "",
            "__title__ = 'mobsfscan'",
            "__authors__ = 'Ajin Abraham'",
            "__copyright__ = f'Copyright {datetime.now().year} Ajin Abraham, OpenSecurity'",
            "__version__ = '0.3.6'",
            "__version_info__ = tuple(int(i) for i in __version__.split('.'))",
            "__all__ = [",
            "    '__title__',",
            "    '__authors__',",
            "    '__copyright__',",
            "    '__version__',",
            "    '__version_info__',",
            "]"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf_8 -*-",
            "from datetime import datetime",
            "",
            "",
            "__title__ = 'mobsfscan'",
            "__authors__ = 'Ajin Abraham'",
            "__copyright__ = f'Copyright {datetime.now().year} Ajin Abraham, OpenSecurity'",
            "__version__ = '0.3.7'",
            "__version_info__ = tuple(int(i) for i in __version__.split('.'))",
            "__all__ = [",
            "    '__title__',",
            "    '__authors__',",
            "    '__copyright__',",
            "    '__version__',",
            "    '__version_info__',",
            "]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "9": [
                "__version__"
            ]
        },
        "addLocation": []
    },
    "mobsfscan/manifest.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from mobsfscan.logger import init_logger"
            },
            "2": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " from mobsfscan.manifest_metadata import metadata"
            },
            "3": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+from mobsfscan.utils import ("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+    is_number,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+    valid_host,"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+)"
            },
            "8": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " logger = init_logger(__name__)"
            },
            "10": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " ANDROID_8_0_LEVEL = 26"
            },
            "11": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "     '32': '12L',"
            },
            "12": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "     '33': '13',"
            },
            "13": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "     '34': '14',"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+    '35': '15',"
            },
            "15": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " }"
            },
            "16": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 58,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 59,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": 353,
                "PatchRowcode": "             port = applink.get('@android:port')"
            },
            "19": {
                "beforePatchRowNumber": 350,
                "afterPatchRowNumber": 354,
                "PatchRowcode": "             scheme = applink.get('@android:scheme')"
            },
            "20": {
                "beforePatchRowNumber": 351,
                "afterPatchRowNumber": 355,
                "PatchRowcode": "             # Collect possible well-known paths"
            },
            "21": {
                "beforePatchRowNumber": 352,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if scheme and scheme in ('http', 'https') and host:"
            },
            "22": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                host = host.replace('*.', '')"
            },
            "23": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                if port:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 356,
                "PatchRowcode": "+            if (scheme"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 357,
                "PatchRowcode": "+                    and scheme in ('http', 'https')"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 358,
                "PatchRowcode": "+                    and host"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 359,
                "PatchRowcode": "+                    and host != '*'):"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 360,
                "PatchRowcode": "+                host = host.replace('*.', '').replace('#', '')"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 361,
                "PatchRowcode": "+                if not valid_host(host):"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 362,
                "PatchRowcode": "+                    continue"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 363,
                "PatchRowcode": "+                if port and is_number(port):"
            },
            "32": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": 364,
                "PatchRowcode": "                     c_url = f'{scheme}://{host}:{port}{well_known_path}'"
            },
            "33": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": 365,
                "PatchRowcode": "                 else:"
            },
            "34": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": 366,
                "PatchRowcode": "                     c_url = f'{scheme}://{host}{well_known_path}'"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf_8 -*-",
            "\"\"\"Parse Android Manifest and NSC.\"\"\"",
            "from operator import itemgetter",
            "from copy import deepcopy",
            "",
            "from xmltodict import parse",
            "",
            "import requests",
            "",
            "from concurrent.futures import ThreadPoolExecutor",
            "",
            "from mobsfscan.logger import init_logger",
            "from mobsfscan.manifest_metadata import metadata",
            "",
            "",
            "logger = init_logger(__name__)",
            "ANDROID_8_0_LEVEL = 26",
            "ANDROID_9_0_LEVEL = 28",
            "ANDROID_10_0_LEVEL = 29",
            "ANDROID_API_LEVEL_MAP = {",
            "    '1': '1.0',",
            "    '2': '1.1',",
            "    '3': '1.5',",
            "    '4': '1.6',",
            "    '5': '2.0-2.1',",
            "    '8': '2.2-2.2.3',",
            "    '9': '2.3-2.3.2',",
            "    '10': '2.3.3-2.3.7',",
            "    '11': '3.0',",
            "    '12': '3.1',",
            "    '13': '3.2-3.2.6',",
            "    '14': '4.0-4.0.2',",
            "    '15': '4.0.3-4.0.4',",
            "    '16': '4.1-4.1.2',",
            "    '17': '4.2-4.2.2',",
            "    '18': '4.3-4.3.1',",
            "    '19': '4.4-4.4.4',",
            "    '20': '4.4W-4.4W.2',",
            "    '21': '5.0-5.0.2',",
            "    '22': '5.1-5.1.1',",
            "    '23': '6.0-6.0.1',",
            "    '24': '7.0',",
            "    '25': '7.1-7.1.2',",
            "    '26': '8.0',",
            "    '27': '8.1',",
            "    '28': '9',",
            "    '29': '10',",
            "    '30': '11',",
            "    '31': '12',",
            "    '32': '12L',",
            "    '33': '13',",
            "    '34': '14',",
            "}",
            "",
            "",
            "def scan_manifest(xml_paths, validate_func):",
            "    \"\"\"Scan android manifest xml.\"\"\"",
            "    results = []",
            "    p = None",
            "    for xml_path in xml_paths:",
            "        try:",
            "            if not validate_func(xml_path):",
            "                continue",
            "            p = parse(xml_path.read_text())",
            "        except Exception:",
            "            logger.warning('Failed to parse XML: %s', xml_path)",
            "        if p:",
            "            findings = do_checks(",
            "                xml_path.resolve().as_posix(), p)",
            "            if findings:",
            "                results.extend(findings)",
            "    return mobsfscan_format(results)",
            "",
            "",
            "def mobsfscan_format(results):",
            "    \"\"\"Convert results to mobsfscan format.\"\"\"",
            "    final = {}",
            "    for res in results:",
            "        find_details = {",
            "            'file_path': res['file'],",
            "            'match_position': (1, 1),",
            "            'match_lines': (1, 1),",
            "            'match_string': res['reference'],",
            "        }",
            "        if final.get(res['id']):",
            "            # Append files",
            "            final[res['id']]['files'].append(find_details)",
            "        else:",
            "            # First occurance",
            "            meta = deepcopy(res['metadata'])",
            "            meta['description'] = res['message']",
            "            meta['severity'] = res['severity']",
            "            final[res['id']] = {",
            "                'files': [find_details],",
            "                'metadata': meta,",
            "            }",
            "    # Preserve order",
            "    for rl in final:",
            "        to_sort = final[rl]['files']",
            "        final[rl]['files'] = sorted(",
            "            to_sort,",
            "            key=itemgetter(",
            "                'file_path', 'match_string', 'match_lines'))",
            "    return final",
            "",
            "",
            "def do_checks(xml_path, p):",
            "    \"\"\"Run checks on android manifest and network security config.\"\"\"",
            "    findings = []",
            "    if p.get('manifest') and p.get('manifest').get('application'):",
            "        # Android Manifest",
            "        min_sdk = None",
            "        target_sdk = None",
            "        app = p.get('manifest').get('application')",
            "        allow_backup = app.get('@android:allowBackup')",
            "        clear_text = app.get('@android:usesCleartextTraffic')",
            "        debuggable = app.get('@android:debuggable')",
            "        test_only = app.get('@android:testOnly')",
            "        if p.get('manifest').get('uses-sdk'):",
            "            uses_sdk = p.get('manifest').get('uses-sdk')",
            "            min_sdk = uses_sdk.get('@android:minSdkVersion')",
            "            target_sdk = uses_sdk.get('@android:targetSdkVersion')",
            "            if not target_sdk:",
            "                target_sdk = min_sdk",
            "        findings = android_manifest_checks(",
            "            xml_path,",
            "            min_sdk,",
            "            allow_backup,",
            "            clear_text,",
            "            debuggable,",
            "            test_only)",
            "        al = AppLinksCheck(findings, xml_path)",
            "        al.browsable_activity_check(app)",
            "        th = TaskHijackingChecks(findings, xml_path, target_sdk)",
            "        th.strandhogg_check(app)",
            "    elif p.get('network-security-config'):",
            "        # Network Security Config",
            "        nsc = NetworkSecurityChecks(findings, xml_path)",
            "        nsc.network_security_checks(p)",
            "    return findings",
            "",
            "",
            "def add_finding(findings, xml_file, rule_id, dynamic=None):",
            "    \"\"\"Append Findings.\"\"\"",
            "    meta = deepcopy(metadata[rule_id])",
            "    meta['id'] = rule_id",
            "    meta['file'] = xml_file",
            "    if dynamic:",
            "        meta['message'] = meta['message'].format(*dynamic)",
            "    findings.append(meta)",
            "",
            "",
            "def android_manifest_checks(xml_path,",
            "                            min_sdk,",
            "                            allow_backup,",
            "                            clear_text,",
            "                            debuggable,",
            "                            test_only):",
            "    \"\"\"Android Manifest Checks.\"\"\"",
            "    findings = []",
            "    try:",
            "        if int(min_sdk) < ANDROID_8_0_LEVEL:",
            "            add_finding(",
            "                findings,",
            "                xml_path,",
            "                'android_manifest_insecure_minsdk_error',",
            "                (ANDROID_API_LEVEL_MAP.get(min_sdk), min_sdk))",
            "        elif int(min_sdk) < ANDROID_10_0_LEVEL:",
            "            add_finding(",
            "                findings,",
            "                xml_path,",
            "                'android_manifest_insecure_minsdk_warning',",
            "                (ANDROID_API_LEVEL_MAP.get(min_sdk), min_sdk))",
            "    except (ValueError, TypeError):",
            "        pass",
            "    if allow_backup and allow_backup == 'true':",
            "        add_finding(",
            "            findings,",
            "            xml_path,",
            "            'android_manifest_allow_backup')",
            "    if not allow_backup:",
            "        add_finding(",
            "            findings,",
            "            xml_path,",
            "            'android_manifest_missing_explicit_allow_backup')",
            "    if clear_text and clear_text == 'true':",
            "        add_finding(",
            "            findings,",
            "            xml_path,",
            "            'android_manifest_usescleartext')",
            "    if debuggable and debuggable == 'true':",
            "        add_finding(",
            "            findings,",
            "            xml_path,",
            "            'android_manifest_debugging_enabled')",
            "    if test_only and test_only == 'true':",
            "        add_finding(",
            "            findings,",
            "            xml_path,",
            "            'android_manifest_test_only')",
            "    return findings",
            "",
            "",
            "class NetworkSecurityChecks:",
            "",
            "    def __init__(self, findings, xml_path):",
            "        self.findings = findings",
            "        self.xml_path = xml_path",
            "",
            "    def clear_text_traffic_permitted(self, conf, typ):",
            "        \"\"\"Check for clear text traffic.\"\"\"",
            "        if typ == 'base':",
            "            r = 'android_manifest_base_config_cleartext'",
            "        elif typ == 'domain':",
            "            r = 'android_manifest_domain_config_cleartext'",
            "        else:",
            "            return",
            "        ctt = conf.get('@cleartextTrafficPermitted')",
            "        if ctt and ctt == 'true':",
            "            add_finding(self.findings, self.xml_path, r)",
            "",
            "    def trust_cert_and_cert_pinning_bypass(self, cert, typ):",
            "        \"\"\"Check for trust user certs and cert pinning bypass.\"\"\"",
            "        if typ == 'base':",
            "            trule = 'android_manifest_base_config_trust_user_certs'",
            "            prule = 'android_manifest_base_config_bypass_pinning'",
            "        elif typ == 'domain':",
            "            trule = 'android_manifest_domain_config_trust_user_certs'",
            "            prule = 'android_manifest_domain_config_bypass_pinning'",
            "        else:",
            "            return",
            "        src = cert.get('@src')",
            "        op = cert.get('@overridePins')",
            "        # Trust user certs",
            "        if src and src == 'user':",
            "            add_finding(self.findings, self.xml_path, trule)",
            "        # Bypass Pinning",
            "        if src and op and src == 'user' and op == 'true':",
            "            add_finding(self.findings, self.xml_path, prule)",
            "",
            "    def cert_instance_check(self, config, typ):",
            "        \"\"\"Check for cert instance.\"\"\"",
            "        certs = config.get('trust-anchors').get('certificates')",
            "        if isinstance(certs, dict):",
            "            # Single cert instance",
            "            self.trust_cert_and_cert_pinning_bypass(",
            "                certs, typ)",
            "        elif isinstance(certs, list):",
            "            for cert in certs:",
            "                # Multiple certs instance",
            "                self.trust_cert_and_cert_pinning_bypass(",
            "                    cert, typ)",
            "",
            "    def network_security_checks(self, parsed_xml):",
            "        \"\"\"Android Network Security Config checks.\"\"\"",
            "        # Base Config",
            "        if parsed_xml.get('network-security-config').get('base-config'):",
            "            typ = 'base'",
            "            base_conf = parsed_xml.get(",
            "                'network-security-config').get('base-config')",
            "            # Clear text traffic",
            "            self.clear_text_traffic_permitted(base_conf, typ)",
            "            if (base_conf.get('trust-anchors')",
            "                    and base_conf.get('trust-anchors').get('certificates')):",
            "                # Trust user certs",
            "                self.cert_instance_check(base_conf, typ)",
            "",
            "        # Domain config",
            "        if parsed_xml.get('network-security-config').get('domain-config'):",
            "            typ = 'domain'",
            "            domain_conf = parsed_xml.get(",
            "                'network-security-config').get('domain-config')",
            "            # Domain config clear text",
            "            self.clear_text_traffic_permitted(domain_conf, typ)",
            "            if domain_conf.get('domain-config'):",
            "                # Nested domain config clear text",
            "                self.clear_text_traffic_permitted(",
            "                    domain_conf.get('domain-config'), typ)",
            "            if (domain_conf.get('trust-anchors')",
            "                    and domain_conf.get('trust-anchors').get('certificates')):",
            "                # Trust user certs",
            "                self.cert_instance_check(domain_conf, typ)",
            "",
            "",
            "class AppLinksCheck:",
            "",
            "    def __init__(self, findings, xml_path):",
            "        self.findings = findings",
            "        self.xml_path = xml_path",
            "",
            "    def check_in_intents(self, activity):",
            "        \"\"\"Check for browsable activities in Intents.\"\"\"",
            "        if not activity:",
            "            return",
            "        intents = activity.get('intent-filter')",
            "        if isinstance(intents, dict):",
            "            self.assetlinks_check(intents)",
            "        elif isinstance(intents, list):",
            "            for intent in intents:",
            "                self.assetlinks_check(intent)",
            "",
            "    def browsable_activity_check(self, app):",
            "        \"\"\"Check in Activity intents.\"\"\"",
            "        # Activities and Alias",
            "        for item in ('activity', 'activity-alias'):",
            "            activities = app.get(item)",
            "            if isinstance(activities, dict):",
            "                self.check_in_intents(activities)",
            "            elif isinstance(activities, list):",
            "                for act in activities:",
            "                    self.check_in_intents(act)",
            "",
            "    def check_url(self, w_url):",
            "        \"\"\"Check URL.\"\"\"",
            "        rcode = 0",
            "        iden = 'sha256_cert_fingerprints'",
            "        rule = 'android_manifest_well_known_assetlinks'",
            "        status = True",
            "        try:",
            "            r = requests.get(",
            "                w_url,",
            "                allow_redirects=True,",
            "                timeout=5)",
            "            if not (str(r.status_code).startswith('2')",
            "                    and iden in str(r.json())):",
            "                status = False",
            "                rcode = r.status_code",
            "        except Exception:",
            "            status = False",
            "        if not status:",
            "            add_finding(",
            "                self.findings,",
            "                self.xml_path,",
            "                rule,",
            "                (w_url, rcode))",
            "",
            "    def assetlinks_check(self, intent):",
            "        \"\"\"Well known assetlink check.\"\"\"",
            "        well_known_path = '/.well-known/assetlinks.json'",
            "        well_knowns = set()",
            "",
            "        applink_data = intent.get('data')",
            "        if isinstance(applink_data, dict):",
            "            applink_data = [applink_data]",
            "        elif not isinstance(applink_data, list):",
            "            return",
            "        for applink in applink_data:",
            "            host = applink.get('@android:host')",
            "            port = applink.get('@android:port')",
            "            scheme = applink.get('@android:scheme')",
            "            # Collect possible well-known paths",
            "            if scheme and scheme in ('http', 'https') and host:",
            "                host = host.replace('*.', '')",
            "                if port:",
            "                    c_url = f'{scheme}://{host}:{port}{well_known_path}'",
            "                else:",
            "                    c_url = f'{scheme}://{host}{well_known_path}'",
            "                well_knowns.add(c_url)",
            "        with ThreadPoolExecutor() as executor:",
            "            futures = []",
            "            for w_url in well_knowns:",
            "                futures.append(",
            "                    executor.submit(self.check_url, w_url))",
            "            for future in futures:",
            "                future.result()",
            "",
            "",
            "class TaskHijackingChecks:",
            "",
            "    def __init__(self, findings, xml_path, target_sdk):",
            "        self.findings = findings",
            "        self.xml_path = xml_path",
            "        self.target_sdk = target_sdk",
            "",
            "    def strandhogg_check(self, app):",
            "        \"\"\"Task Hijacking check.\"\"\"",
            "        # Activities and Alias",
            "        for item in ('activity', 'activity-alias'):",
            "            activities = app.get(item)",
            "            if isinstance(activities, dict):",
            "                self.task_hijacking_checks(activities)",
            "            elif isinstance(activities, list):",
            "                for act in activities:",
            "                    self.task_hijacking_checks(act)",
            "",
            "    def task_hijacking_checks(self, activity):",
            "        \"\"\"Android Task Hijacking Checks.\"\"\"",
            "        # StrandHogg 1.0",
            "        try:",
            "            target_sdk = int(self.target_sdk)",
            "        except Exception:",
            "            target_sdk = ANDROID_8_0_LEVEL",
            "        launch_mode = activity.get('@android:launchMode')",
            "        if (target_sdk < ANDROID_9_0_LEVEL",
            "                and launch_mode == 'singleTask'):",
            "            add_finding(",
            "                self.findings,",
            "                self.xml_path,",
            "                'android_task_hijacking1',",
            "                (target_sdk,))",
            "        # StrandHogg 2.0",
            "        exported_act = activity.get('@android:exported')",
            "        if not exported_act:",
            "            exported_act = 'false'",
            "        task_affinity = activity.get('@android:taskAffinity')",
            "        if not task_affinity:",
            "            task_affinity = ''",
            "        if (target_sdk < ANDROID_10_0_LEVEL",
            "                and exported_act == 'true'",
            "                and (launch_mode != 'singleInstance' or task_affinity != '')):",
            "            add_finding(",
            "                self.findings,",
            "                self.xml_path,",
            "                'android_task_hijacking2',",
            "                (target_sdk,))"
        ],
        "afterPatchFile": [
            "# -*- coding: utf_8 -*-",
            "\"\"\"Parse Android Manifest and NSC.\"\"\"",
            "from operator import itemgetter",
            "from copy import deepcopy",
            "",
            "from xmltodict import parse",
            "",
            "import requests",
            "",
            "from concurrent.futures import ThreadPoolExecutor",
            "",
            "from mobsfscan.logger import init_logger",
            "from mobsfscan.manifest_metadata import metadata",
            "from mobsfscan.utils import (",
            "    is_number,",
            "    valid_host,",
            ")",
            "",
            "logger = init_logger(__name__)",
            "ANDROID_8_0_LEVEL = 26",
            "ANDROID_9_0_LEVEL = 28",
            "ANDROID_10_0_LEVEL = 29",
            "ANDROID_API_LEVEL_MAP = {",
            "    '1': '1.0',",
            "    '2': '1.1',",
            "    '3': '1.5',",
            "    '4': '1.6',",
            "    '5': '2.0-2.1',",
            "    '8': '2.2-2.2.3',",
            "    '9': '2.3-2.3.2',",
            "    '10': '2.3.3-2.3.7',",
            "    '11': '3.0',",
            "    '12': '3.1',",
            "    '13': '3.2-3.2.6',",
            "    '14': '4.0-4.0.2',",
            "    '15': '4.0.3-4.0.4',",
            "    '16': '4.1-4.1.2',",
            "    '17': '4.2-4.2.2',",
            "    '18': '4.3-4.3.1',",
            "    '19': '4.4-4.4.4',",
            "    '20': '4.4W-4.4W.2',",
            "    '21': '5.0-5.0.2',",
            "    '22': '5.1-5.1.1',",
            "    '23': '6.0-6.0.1',",
            "    '24': '7.0',",
            "    '25': '7.1-7.1.2',",
            "    '26': '8.0',",
            "    '27': '8.1',",
            "    '28': '9',",
            "    '29': '10',",
            "    '30': '11',",
            "    '31': '12',",
            "    '32': '12L',",
            "    '33': '13',",
            "    '34': '14',",
            "    '35': '15',",
            "}",
            "",
            "",
            "def scan_manifest(xml_paths, validate_func):",
            "    \"\"\"Scan android manifest xml.\"\"\"",
            "    results = []",
            "    p = None",
            "    for xml_path in xml_paths:",
            "        try:",
            "            if not validate_func(xml_path):",
            "                continue",
            "            p = parse(xml_path.read_text())",
            "        except Exception:",
            "            logger.warning('Failed to parse XML: %s', xml_path)",
            "        if p:",
            "            findings = do_checks(",
            "                xml_path.resolve().as_posix(), p)",
            "            if findings:",
            "                results.extend(findings)",
            "    return mobsfscan_format(results)",
            "",
            "",
            "def mobsfscan_format(results):",
            "    \"\"\"Convert results to mobsfscan format.\"\"\"",
            "    final = {}",
            "    for res in results:",
            "        find_details = {",
            "            'file_path': res['file'],",
            "            'match_position': (1, 1),",
            "            'match_lines': (1, 1),",
            "            'match_string': res['reference'],",
            "        }",
            "        if final.get(res['id']):",
            "            # Append files",
            "            final[res['id']]['files'].append(find_details)",
            "        else:",
            "            # First occurance",
            "            meta = deepcopy(res['metadata'])",
            "            meta['description'] = res['message']",
            "            meta['severity'] = res['severity']",
            "            final[res['id']] = {",
            "                'files': [find_details],",
            "                'metadata': meta,",
            "            }",
            "    # Preserve order",
            "    for rl in final:",
            "        to_sort = final[rl]['files']",
            "        final[rl]['files'] = sorted(",
            "            to_sort,",
            "            key=itemgetter(",
            "                'file_path', 'match_string', 'match_lines'))",
            "    return final",
            "",
            "",
            "def do_checks(xml_path, p):",
            "    \"\"\"Run checks on android manifest and network security config.\"\"\"",
            "    findings = []",
            "    if p.get('manifest') and p.get('manifest').get('application'):",
            "        # Android Manifest",
            "        min_sdk = None",
            "        target_sdk = None",
            "        app = p.get('manifest').get('application')",
            "        allow_backup = app.get('@android:allowBackup')",
            "        clear_text = app.get('@android:usesCleartextTraffic')",
            "        debuggable = app.get('@android:debuggable')",
            "        test_only = app.get('@android:testOnly')",
            "        if p.get('manifest').get('uses-sdk'):",
            "            uses_sdk = p.get('manifest').get('uses-sdk')",
            "            min_sdk = uses_sdk.get('@android:minSdkVersion')",
            "            target_sdk = uses_sdk.get('@android:targetSdkVersion')",
            "            if not target_sdk:",
            "                target_sdk = min_sdk",
            "        findings = android_manifest_checks(",
            "            xml_path,",
            "            min_sdk,",
            "            allow_backup,",
            "            clear_text,",
            "            debuggable,",
            "            test_only)",
            "        al = AppLinksCheck(findings, xml_path)",
            "        al.browsable_activity_check(app)",
            "        th = TaskHijackingChecks(findings, xml_path, target_sdk)",
            "        th.strandhogg_check(app)",
            "    elif p.get('network-security-config'):",
            "        # Network Security Config",
            "        nsc = NetworkSecurityChecks(findings, xml_path)",
            "        nsc.network_security_checks(p)",
            "    return findings",
            "",
            "",
            "def add_finding(findings, xml_file, rule_id, dynamic=None):",
            "    \"\"\"Append Findings.\"\"\"",
            "    meta = deepcopy(metadata[rule_id])",
            "    meta['id'] = rule_id",
            "    meta['file'] = xml_file",
            "    if dynamic:",
            "        meta['message'] = meta['message'].format(*dynamic)",
            "    findings.append(meta)",
            "",
            "",
            "def android_manifest_checks(xml_path,",
            "                            min_sdk,",
            "                            allow_backup,",
            "                            clear_text,",
            "                            debuggable,",
            "                            test_only):",
            "    \"\"\"Android Manifest Checks.\"\"\"",
            "    findings = []",
            "    try:",
            "        if int(min_sdk) < ANDROID_8_0_LEVEL:",
            "            add_finding(",
            "                findings,",
            "                xml_path,",
            "                'android_manifest_insecure_minsdk_error',",
            "                (ANDROID_API_LEVEL_MAP.get(min_sdk), min_sdk))",
            "        elif int(min_sdk) < ANDROID_10_0_LEVEL:",
            "            add_finding(",
            "                findings,",
            "                xml_path,",
            "                'android_manifest_insecure_minsdk_warning',",
            "                (ANDROID_API_LEVEL_MAP.get(min_sdk), min_sdk))",
            "    except (ValueError, TypeError):",
            "        pass",
            "    if allow_backup and allow_backup == 'true':",
            "        add_finding(",
            "            findings,",
            "            xml_path,",
            "            'android_manifest_allow_backup')",
            "    if not allow_backup:",
            "        add_finding(",
            "            findings,",
            "            xml_path,",
            "            'android_manifest_missing_explicit_allow_backup')",
            "    if clear_text and clear_text == 'true':",
            "        add_finding(",
            "            findings,",
            "            xml_path,",
            "            'android_manifest_usescleartext')",
            "    if debuggable and debuggable == 'true':",
            "        add_finding(",
            "            findings,",
            "            xml_path,",
            "            'android_manifest_debugging_enabled')",
            "    if test_only and test_only == 'true':",
            "        add_finding(",
            "            findings,",
            "            xml_path,",
            "            'android_manifest_test_only')",
            "    return findings",
            "",
            "",
            "class NetworkSecurityChecks:",
            "",
            "    def __init__(self, findings, xml_path):",
            "        self.findings = findings",
            "        self.xml_path = xml_path",
            "",
            "    def clear_text_traffic_permitted(self, conf, typ):",
            "        \"\"\"Check for clear text traffic.\"\"\"",
            "        if typ == 'base':",
            "            r = 'android_manifest_base_config_cleartext'",
            "        elif typ == 'domain':",
            "            r = 'android_manifest_domain_config_cleartext'",
            "        else:",
            "            return",
            "        ctt = conf.get('@cleartextTrafficPermitted')",
            "        if ctt and ctt == 'true':",
            "            add_finding(self.findings, self.xml_path, r)",
            "",
            "    def trust_cert_and_cert_pinning_bypass(self, cert, typ):",
            "        \"\"\"Check for trust user certs and cert pinning bypass.\"\"\"",
            "        if typ == 'base':",
            "            trule = 'android_manifest_base_config_trust_user_certs'",
            "            prule = 'android_manifest_base_config_bypass_pinning'",
            "        elif typ == 'domain':",
            "            trule = 'android_manifest_domain_config_trust_user_certs'",
            "            prule = 'android_manifest_domain_config_bypass_pinning'",
            "        else:",
            "            return",
            "        src = cert.get('@src')",
            "        op = cert.get('@overridePins')",
            "        # Trust user certs",
            "        if src and src == 'user':",
            "            add_finding(self.findings, self.xml_path, trule)",
            "        # Bypass Pinning",
            "        if src and op and src == 'user' and op == 'true':",
            "            add_finding(self.findings, self.xml_path, prule)",
            "",
            "    def cert_instance_check(self, config, typ):",
            "        \"\"\"Check for cert instance.\"\"\"",
            "        certs = config.get('trust-anchors').get('certificates')",
            "        if isinstance(certs, dict):",
            "            # Single cert instance",
            "            self.trust_cert_and_cert_pinning_bypass(",
            "                certs, typ)",
            "        elif isinstance(certs, list):",
            "            for cert in certs:",
            "                # Multiple certs instance",
            "                self.trust_cert_and_cert_pinning_bypass(",
            "                    cert, typ)",
            "",
            "    def network_security_checks(self, parsed_xml):",
            "        \"\"\"Android Network Security Config checks.\"\"\"",
            "        # Base Config",
            "        if parsed_xml.get('network-security-config').get('base-config'):",
            "            typ = 'base'",
            "            base_conf = parsed_xml.get(",
            "                'network-security-config').get('base-config')",
            "            # Clear text traffic",
            "            self.clear_text_traffic_permitted(base_conf, typ)",
            "            if (base_conf.get('trust-anchors')",
            "                    and base_conf.get('trust-anchors').get('certificates')):",
            "                # Trust user certs",
            "                self.cert_instance_check(base_conf, typ)",
            "",
            "        # Domain config",
            "        if parsed_xml.get('network-security-config').get('domain-config'):",
            "            typ = 'domain'",
            "            domain_conf = parsed_xml.get(",
            "                'network-security-config').get('domain-config')",
            "            # Domain config clear text",
            "            self.clear_text_traffic_permitted(domain_conf, typ)",
            "            if domain_conf.get('domain-config'):",
            "                # Nested domain config clear text",
            "                self.clear_text_traffic_permitted(",
            "                    domain_conf.get('domain-config'), typ)",
            "            if (domain_conf.get('trust-anchors')",
            "                    and domain_conf.get('trust-anchors').get('certificates')):",
            "                # Trust user certs",
            "                self.cert_instance_check(domain_conf, typ)",
            "",
            "",
            "class AppLinksCheck:",
            "",
            "    def __init__(self, findings, xml_path):",
            "        self.findings = findings",
            "        self.xml_path = xml_path",
            "",
            "    def check_in_intents(self, activity):",
            "        \"\"\"Check for browsable activities in Intents.\"\"\"",
            "        if not activity:",
            "            return",
            "        intents = activity.get('intent-filter')",
            "        if isinstance(intents, dict):",
            "            self.assetlinks_check(intents)",
            "        elif isinstance(intents, list):",
            "            for intent in intents:",
            "                self.assetlinks_check(intent)",
            "",
            "    def browsable_activity_check(self, app):",
            "        \"\"\"Check in Activity intents.\"\"\"",
            "        # Activities and Alias",
            "        for item in ('activity', 'activity-alias'):",
            "            activities = app.get(item)",
            "            if isinstance(activities, dict):",
            "                self.check_in_intents(activities)",
            "            elif isinstance(activities, list):",
            "                for act in activities:",
            "                    self.check_in_intents(act)",
            "",
            "    def check_url(self, w_url):",
            "        \"\"\"Check URL.\"\"\"",
            "        rcode = 0",
            "        iden = 'sha256_cert_fingerprints'",
            "        rule = 'android_manifest_well_known_assetlinks'",
            "        status = True",
            "        try:",
            "            r = requests.get(",
            "                w_url,",
            "                allow_redirects=True,",
            "                timeout=5)",
            "            if not (str(r.status_code).startswith('2')",
            "                    and iden in str(r.json())):",
            "                status = False",
            "                rcode = r.status_code",
            "        except Exception:",
            "            status = False",
            "        if not status:",
            "            add_finding(",
            "                self.findings,",
            "                self.xml_path,",
            "                rule,",
            "                (w_url, rcode))",
            "",
            "    def assetlinks_check(self, intent):",
            "        \"\"\"Well known assetlink check.\"\"\"",
            "        well_known_path = '/.well-known/assetlinks.json'",
            "        well_knowns = set()",
            "",
            "        applink_data = intent.get('data')",
            "        if isinstance(applink_data, dict):",
            "            applink_data = [applink_data]",
            "        elif not isinstance(applink_data, list):",
            "            return",
            "        for applink in applink_data:",
            "            host = applink.get('@android:host')",
            "            port = applink.get('@android:port')",
            "            scheme = applink.get('@android:scheme')",
            "            # Collect possible well-known paths",
            "            if (scheme",
            "                    and scheme in ('http', 'https')",
            "                    and host",
            "                    and host != '*'):",
            "                host = host.replace('*.', '').replace('#', '')",
            "                if not valid_host(host):",
            "                    continue",
            "                if port and is_number(port):",
            "                    c_url = f'{scheme}://{host}:{port}{well_known_path}'",
            "                else:",
            "                    c_url = f'{scheme}://{host}{well_known_path}'",
            "                well_knowns.add(c_url)",
            "        with ThreadPoolExecutor() as executor:",
            "            futures = []",
            "            for w_url in well_knowns:",
            "                futures.append(",
            "                    executor.submit(self.check_url, w_url))",
            "            for future in futures:",
            "                future.result()",
            "",
            "",
            "class TaskHijackingChecks:",
            "",
            "    def __init__(self, findings, xml_path, target_sdk):",
            "        self.findings = findings",
            "        self.xml_path = xml_path",
            "        self.target_sdk = target_sdk",
            "",
            "    def strandhogg_check(self, app):",
            "        \"\"\"Task Hijacking check.\"\"\"",
            "        # Activities and Alias",
            "        for item in ('activity', 'activity-alias'):",
            "            activities = app.get(item)",
            "            if isinstance(activities, dict):",
            "                self.task_hijacking_checks(activities)",
            "            elif isinstance(activities, list):",
            "                for act in activities:",
            "                    self.task_hijacking_checks(act)",
            "",
            "    def task_hijacking_checks(self, activity):",
            "        \"\"\"Android Task Hijacking Checks.\"\"\"",
            "        # StrandHogg 1.0",
            "        try:",
            "            target_sdk = int(self.target_sdk)",
            "        except Exception:",
            "            target_sdk = ANDROID_8_0_LEVEL",
            "        launch_mode = activity.get('@android:launchMode')",
            "        if (target_sdk < ANDROID_9_0_LEVEL",
            "                and launch_mode == 'singleTask'):",
            "            add_finding(",
            "                self.findings,",
            "                self.xml_path,",
            "                'android_task_hijacking1',",
            "                (target_sdk,))",
            "        # StrandHogg 2.0",
            "        exported_act = activity.get('@android:exported')",
            "        if not exported_act:",
            "            exported_act = 'false'",
            "        task_affinity = activity.get('@android:taskAffinity')",
            "        if not task_affinity:",
            "            task_affinity = ''",
            "        if (target_sdk < ANDROID_10_0_LEVEL",
            "                and exported_act == 'true'",
            "                and (launch_mode != 'singleInstance' or task_affinity != '')):",
            "            add_finding(",
            "                self.findings,",
            "                self.xml_path,",
            "                'android_task_hijacking2',",
            "                (target_sdk,))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "14": [],
            "352": [
                "AppLinksCheck",
                "assetlinks_check"
            ],
            "353": [
                "AppLinksCheck",
                "assetlinks_check"
            ],
            "354": [
                "AppLinksCheck",
                "assetlinks_check"
            ]
        },
        "addLocation": []
    },
    "mobsfscan/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": 1,
                "PatchRowcode": " # -*- coding: utf_8 -*-"
            },
            "1": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " \"\"\"Logger Config.\"\"\""
            },
            "2": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 3,
                "PatchRowcode": "+import socket"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 4,
                "PatchRowcode": "+import unicodedata"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+from urllib.parse import urlparse"
            },
            "5": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from pathlib import Path"
            },
            "6": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " import mobsfscan.settings as config"
            },
            "8": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "             all_rules[rule['id']] = rule"
            },
            "9": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "             ids.add(rule['id'])"
            },
            "10": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "     return ids, all_rules"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+def is_number(s):"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+    if not s:"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+        return False"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+    if s == 'NaN':"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 124,
                "PatchRowcode": "+        return False"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+    try:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+        float(s)"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 127,
                "PatchRowcode": "+        return True"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 128,
                "PatchRowcode": "+    except ValueError:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 129,
                "PatchRowcode": "+        pass"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+    try:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 131,
                "PatchRowcode": "+        unicodedata.numeric(s)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+        return True"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+    except (TypeError, ValueError):"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+        pass"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+    return False"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+def valid_host(host):"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+    \"\"\"Check if host is valid.\"\"\""
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+    try:"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+        prefixs = ('http://', 'https://')"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+        if not host.startswith(prefixs):"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+            host = f'http://{host}'"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+        parsed = urlparse(host)"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+        domain = parsed.netloc"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+        path = parsed.path"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+        if len(domain) == 0:"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+            # No valid domain"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+            return False"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+        if len(path) > 0:"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+            # Only host is allowed"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+            return False"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+        if ':' in domain:"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+            # IPv6"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+            return False"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+        # Local network"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+        invalid_prefix = ("
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+            '127.',"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+            '192.',"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+            '10.',"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+            '172.',"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+            '169',"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+            '0.',"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+            'localhost')"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+        if domain.startswith(invalid_prefix):"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+            return False"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+        ip = socket.gethostbyname(domain)"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+        if ip.startswith(invalid_prefix):"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+            # Resolve dns to get IP"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+            return False"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+        return True"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+    except Exception:"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+        return False"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf_8 -*-",
            "\"\"\"Logger Config.\"\"\"",
            "from pathlib import Path",
            "",
            "import mobsfscan.settings as config",
            "from mobsfscan.logger import init_logger",
            "",
            "import yaml",
            "",
            "",
            "logger = init_logger(__name__)",
            "",
            "",
            "def filter_none(user_list):",
            "    \"\"\"Filter and remove None values from user supplied config.\"\"\"",
            "    if not user_list:",
            "        return None",
            "    return list(filter(lambda item: item is not None, user_list))",
            "",
            "",
            "def get_config(base_path, config_file):",
            "    options = {",
            "        'ignore_filenames': config.IGNORE_FILENAMES,",
            "        'ignore_extensions': config.IGNORE_EXTENSIONS,",
            "        'ignore_paths': config.IGNORE_PATHS,",
            "        'ignore_rules': set(),",
            "        'severity_filter': config.SEVERITY_FILTER,",
            "    }",
            "    if config_file:",
            "        cfile = Path(config_file)",
            "    else:",
            "        cfile = Path(base_path[0]) / config.MOBSFSCAN_CONFIG_FILE",
            "    if cfile.is_file() and cfile.exists():",
            "        extras = read_yaml(cfile)",
            "        root = validate_config(extras, options)",
            "        if not root:",
            "            logger.warning('Invalid YAML, ignoring config from .mobsf')",
            "            return options",
            "        usr_ignore_files = filter_none(root.get('ignore-filenames'))",
            "        usr_igonre_paths = filter_none(root.get('ignore-paths'))",
            "        usr_ignore_rules = filter_none(root.get('ignore-rules'))",
            "        usr_severity_filter = filter_none(root.get('severity-filter'))",
            "        if usr_ignore_files:",
            "            options['ignore_filenames'].update(usr_ignore_files)",
            "        if usr_igonre_paths:",
            "            options['ignore_paths'].update(usr_igonre_paths)",
            "        if usr_ignore_rules:",
            "            options['ignore_rules'].update(usr_ignore_rules)",
            "        if usr_severity_filter:",
            "            options['severity_filter'] = usr_severity_filter",
            "    return options",
            "",
            "",
            "def validate_config(extras, options):",
            "    \"\"\"Validate user supplied config file.\"\"\"",
            "    if not extras:",
            "        return False",
            "    if isinstance(extras, dict):",
            "        root = extras",
            "    else:",
            "        root = extras[0]",
            "    valid = True",
            "    for key, value in root.items():",
            "        if key.replace('-', '_') not in options.keys():",
            "            valid = False",
            "            logger.warning('The config `%s` is not supported.', key)",
            "        if not isinstance(value, list):",
            "            valid = False",
            "            logger.warning('The value `%s` for the config `%s` is invalid.'",
            "                           ' Only list of value(s) are supported.', value, key)",
            "    if not valid:",
            "        return False",
            "    return root",
            "",
            "",
            "def read_yaml(file_obj, text=False):",
            "    \"\"\"Read Yaml.\"\"\"",
            "    try:",
            "        if text:",
            "            return yaml.safe_load(file_obj)",
            "        return yaml.safe_load(file_obj.read_text('utf-8', 'ignore'))",
            "    except yaml.YAMLError:",
            "        logger.error('Failed to parse YAML')",
            "    except Exception:",
            "        logger.exception('Error parsing YAML')",
            "    return None",
            "",
            "",
            "def get_best_practices(extension):",
            "    \"\"\"Get best practices of an extension.\"\"\"",
            "    ids = set()",
            "    all_rules = {}",
            "    if extension == '.java':",
            "        for yml in config.BEST_PRACTICES_DIR.rglob('*.yaml'):",
            "            rules = read_yaml(yml)",
            "            for rule in rules['rules']:",
            "                all_rules[rule['id']] = rule",
            "                ids.add(rule['id'])",
            "    elif extension in ['.kt', '.m', '.swift']:",
            "        if extension == '.kt':",
            "            os_dir = config.ANDROID_RULES_DIR",
            "            lang = 'kotlin'",
            "        elif extension == '.m':",
            "            os_dir = config.IOS_RULES_DIR",
            "            lang = 'objectivec'",
            "        elif extension == '.swift':",
            "            os_dir = config.IOS_RULES_DIR",
            "            lang = 'swift'",
            "        kt = os_dir / lang / 'best_practices.yaml'",
            "        rules = read_yaml(kt)",
            "        for rule in rules:",
            "            all_rules[rule['id']] = rule",
            "            ids.add(rule['id'])",
            "    return ids, all_rules"
        ],
        "afterPatchFile": [
            "# -*- coding: utf_8 -*-",
            "\"\"\"Logger Config.\"\"\"",
            "import socket",
            "import unicodedata",
            "from urllib.parse import urlparse",
            "from pathlib import Path",
            "",
            "import mobsfscan.settings as config",
            "from mobsfscan.logger import init_logger",
            "",
            "import yaml",
            "",
            "",
            "logger = init_logger(__name__)",
            "",
            "",
            "def filter_none(user_list):",
            "    \"\"\"Filter and remove None values from user supplied config.\"\"\"",
            "    if not user_list:",
            "        return None",
            "    return list(filter(lambda item: item is not None, user_list))",
            "",
            "",
            "def get_config(base_path, config_file):",
            "    options = {",
            "        'ignore_filenames': config.IGNORE_FILENAMES,",
            "        'ignore_extensions': config.IGNORE_EXTENSIONS,",
            "        'ignore_paths': config.IGNORE_PATHS,",
            "        'ignore_rules': set(),",
            "        'severity_filter': config.SEVERITY_FILTER,",
            "    }",
            "    if config_file:",
            "        cfile = Path(config_file)",
            "    else:",
            "        cfile = Path(base_path[0]) / config.MOBSFSCAN_CONFIG_FILE",
            "    if cfile.is_file() and cfile.exists():",
            "        extras = read_yaml(cfile)",
            "        root = validate_config(extras, options)",
            "        if not root:",
            "            logger.warning('Invalid YAML, ignoring config from .mobsf')",
            "            return options",
            "        usr_ignore_files = filter_none(root.get('ignore-filenames'))",
            "        usr_igonre_paths = filter_none(root.get('ignore-paths'))",
            "        usr_ignore_rules = filter_none(root.get('ignore-rules'))",
            "        usr_severity_filter = filter_none(root.get('severity-filter'))",
            "        if usr_ignore_files:",
            "            options['ignore_filenames'].update(usr_ignore_files)",
            "        if usr_igonre_paths:",
            "            options['ignore_paths'].update(usr_igonre_paths)",
            "        if usr_ignore_rules:",
            "            options['ignore_rules'].update(usr_ignore_rules)",
            "        if usr_severity_filter:",
            "            options['severity_filter'] = usr_severity_filter",
            "    return options",
            "",
            "",
            "def validate_config(extras, options):",
            "    \"\"\"Validate user supplied config file.\"\"\"",
            "    if not extras:",
            "        return False",
            "    if isinstance(extras, dict):",
            "        root = extras",
            "    else:",
            "        root = extras[0]",
            "    valid = True",
            "    for key, value in root.items():",
            "        if key.replace('-', '_') not in options.keys():",
            "            valid = False",
            "            logger.warning('The config `%s` is not supported.', key)",
            "        if not isinstance(value, list):",
            "            valid = False",
            "            logger.warning('The value `%s` for the config `%s` is invalid.'",
            "                           ' Only list of value(s) are supported.', value, key)",
            "    if not valid:",
            "        return False",
            "    return root",
            "",
            "",
            "def read_yaml(file_obj, text=False):",
            "    \"\"\"Read Yaml.\"\"\"",
            "    try:",
            "        if text:",
            "            return yaml.safe_load(file_obj)",
            "        return yaml.safe_load(file_obj.read_text('utf-8', 'ignore'))",
            "    except yaml.YAMLError:",
            "        logger.error('Failed to parse YAML')",
            "    except Exception:",
            "        logger.exception('Error parsing YAML')",
            "    return None",
            "",
            "",
            "def get_best_practices(extension):",
            "    \"\"\"Get best practices of an extension.\"\"\"",
            "    ids = set()",
            "    all_rules = {}",
            "    if extension == '.java':",
            "        for yml in config.BEST_PRACTICES_DIR.rglob('*.yaml'):",
            "            rules = read_yaml(yml)",
            "            for rule in rules['rules']:",
            "                all_rules[rule['id']] = rule",
            "                ids.add(rule['id'])",
            "    elif extension in ['.kt', '.m', '.swift']:",
            "        if extension == '.kt':",
            "            os_dir = config.ANDROID_RULES_DIR",
            "            lang = 'kotlin'",
            "        elif extension == '.m':",
            "            os_dir = config.IOS_RULES_DIR",
            "            lang = 'objectivec'",
            "        elif extension == '.swift':",
            "            os_dir = config.IOS_RULES_DIR",
            "            lang = 'swift'",
            "        kt = os_dir / lang / 'best_practices.yaml'",
            "        rules = read_yaml(kt)",
            "        for rule in rules:",
            "            all_rules[rule['id']] = rule",
            "            ids.add(rule['id'])",
            "    return ids, all_rules",
            "",
            "",
            "def is_number(s):",
            "    if not s:",
            "        return False",
            "    if s == 'NaN':",
            "        return False",
            "    try:",
            "        float(s)",
            "        return True",
            "    except ValueError:",
            "        pass",
            "    try:",
            "        unicodedata.numeric(s)",
            "        return True",
            "    except (TypeError, ValueError):",
            "        pass",
            "    return False",
            "",
            "",
            "def valid_host(host):",
            "    \"\"\"Check if host is valid.\"\"\"",
            "    try:",
            "        prefixs = ('http://', 'https://')",
            "        if not host.startswith(prefixs):",
            "            host = f'http://{host}'",
            "        parsed = urlparse(host)",
            "        domain = parsed.netloc",
            "        path = parsed.path",
            "        if len(domain) == 0:",
            "            # No valid domain",
            "            return False",
            "        if len(path) > 0:",
            "            # Only host is allowed",
            "            return False",
            "        if ':' in domain:",
            "            # IPv6",
            "            return False",
            "        # Local network",
            "        invalid_prefix = (",
            "            '127.',",
            "            '192.',",
            "            '10.',",
            "            '172.',",
            "            '169',",
            "            '0.',",
            "            'localhost')",
            "        if domain.startswith(invalid_prefix):",
            "            return False",
            "        ip = socket.gethostbyname(domain)",
            "        if ip.startswith(invalid_prefix):",
            "            # Resolve dns to get IP",
            "            return False",
            "        return True",
            "    except Exception:",
            "        return False"
        ],
        "action": [
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "src.pyload.core"
        ]
    }
}