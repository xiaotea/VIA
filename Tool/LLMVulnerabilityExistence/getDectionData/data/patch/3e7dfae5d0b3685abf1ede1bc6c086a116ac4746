{
    "end_to_end_tests/regen_golden_master.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from openapi_python_client.cli import app"
            },
            "1": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " if __name__ == \"__main__\":"
            },
            "3": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    from .fastapi_app import generate_openapi_json"
            },
            "4": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "5": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    generate_openapi_json()"
            },
            "6": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 10,
                "PatchRowcode": "     runner = CliRunner()"
            },
            "7": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 11,
                "PatchRowcode": "     openapi_path = Path(__file__).parent / \"fastapi_app\" / \"openapi.json\""
            },
            "8": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 12,
                "PatchRowcode": "     gm_path = Path(__file__).parent / \"golden-master\""
            }
        },
        "frontPatchFile": [
            "\"\"\" Regenerate golden-master \"\"\"",
            "import shutil",
            "from pathlib import Path",
            "",
            "from typer.testing import CliRunner",
            "",
            "from openapi_python_client.cli import app",
            "",
            "if __name__ == \"__main__\":",
            "    from .fastapi_app import generate_openapi_json",
            "",
            "    generate_openapi_json()",
            "    runner = CliRunner()",
            "    openapi_path = Path(__file__).parent / \"fastapi_app\" / \"openapi.json\"",
            "    gm_path = Path(__file__).parent / \"golden-master\"",
            "    shutil.rmtree(gm_path, ignore_errors=True)",
            "    output_path = Path.cwd() / \"my-test-api-client\"",
            "    shutil.rmtree(output_path, ignore_errors=True)",
            "    config_path = Path(__file__).parent / \"config.yml\"",
            "",
            "    result = runner.invoke(app, [f\"--config={config_path}\", \"generate\", f\"--path={openapi_path}\"])",
            "    if result.stdout:",
            "        print(result.stdout)",
            "    if result.exception:",
            "        raise result.exception",
            "    output_path.rename(gm_path)"
        ],
        "afterPatchFile": [
            "\"\"\" Regenerate golden-master \"\"\"",
            "import shutil",
            "from pathlib import Path",
            "",
            "from typer.testing import CliRunner",
            "",
            "from openapi_python_client.cli import app",
            "",
            "if __name__ == \"__main__\":",
            "    runner = CliRunner()",
            "    openapi_path = Path(__file__).parent / \"fastapi_app\" / \"openapi.json\"",
            "    gm_path = Path(__file__).parent / \"golden-master\"",
            "    shutil.rmtree(gm_path, ignore_errors=True)",
            "    output_path = Path.cwd() / \"my-test-api-client\"",
            "    shutil.rmtree(output_path, ignore_errors=True)",
            "    config_path = Path(__file__).parent / \"config.yml\"",
            "",
            "    result = runner.invoke(app, [f\"--config={config_path}\", \"generate\", f\"--path={openapi_path}\"])",
            "    if result.stdout:",
            "        print(result.stdout)",
            "    if result.exception:",
            "        raise result.exception",
            "    output_path.rename(gm_path)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "10": [],
            "11": [],
            "12": []
        },
        "addLocation": []
    },
    "openapi_python_client/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 83,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 84,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 85,
                "PatchRowcode": " class Project:"
            },
            "3": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    TEMPLATE_FILTERS = {\"snakecase\": utils.snake_case, \"spinalcase\": utils.spinal_case}"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+    TEMPLATE_FILTERS = {\"snakecase\": utils.snake_case, \"kebabcase\": utils.kebab_case}"
            },
            "5": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "     project_name_override: Optional[str] = None"
            },
            "6": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "     package_name_override: Optional[str] = None"
            },
            "7": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 89,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "     def __init__(self, *, openapi: GeneratorData) -> None:"
            },
            "9": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "         self.openapi: GeneratorData = openapi"
            },
            "10": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "         self.env: Environment = Environment(loader=PackageLoader(__package__), trim_blocks=True, lstrip_blocks=True)"
            },
            "11": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 93,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.project_name: str = self.project_name_override or f\"{openapi.title.replace(' ', '-').lower()}-client\""
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+        self.project_name: str = self.project_name_override or f\"{utils.kebab_case(openapi.title).lower()}-client\""
            },
            "14": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "         self.project_dir: Path = Path.cwd() / self.project_name"
            },
            "15": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 96,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "         self.package_name: str = self.package_name_override or self.project_name.replace(\"-\", \"_\")"
            },
            "17": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 231,
                "PatchRowcode": "         endpoint_template = self.env.get_template(\"endpoint_module.pyi\")"
            },
            "18": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 232,
                "PatchRowcode": "         async_endpoint_template = self.env.get_template(\"async_endpoint_module.pyi\")"
            },
            "19": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 233,
                "PatchRowcode": "         for tag, collection in self.openapi.endpoint_collections_by_tag.items():"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+            tag = utils.snake_case(tag)"
            },
            "21": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": 235,
                "PatchRowcode": "             module_path = api_dir / f\"{tag}.py\""
            },
            "22": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 236,
                "PatchRowcode": "             module_path.write_text(endpoint_template.render(collection=collection))"
            },
            "23": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "             async_module_path = async_api_dir / f\"{tag}.py\""
            }
        },
        "frontPatchFile": [
            "\"\"\" Generate modern Python clients from OpenAPI \"\"\"",
            "from __future__ import annotations",
            "",
            "import shutil",
            "import subprocess",
            "import sys",
            "from pathlib import Path",
            "from typing import Any, Dict, Optional, Sequence, Union",
            "",
            "import httpcore",
            "import httpx",
            "import yaml",
            "from jinja2 import Environment, PackageLoader",
            "",
            "from openapi_python_client import utils",
            "",
            "from .parser import GeneratorData, import_string_from_reference",
            "from .parser.errors import GeneratorError",
            "",
            "if sys.version_info.minor == 7:  # version did not exist in 3.7, need to use a backport",
            "    from importlib_metadata import version",
            "else:",
            "    from importlib.metadata import version  # type: ignore",
            "",
            "",
            "__version__ = version(__package__)",
            "",
            "",
            "def _get_project_for_url_or_path(url: Optional[str], path: Optional[Path]) -> Union[Project, GeneratorError]:",
            "    data_dict = _get_document(url=url, path=path)",
            "    if isinstance(data_dict, GeneratorError):",
            "        return data_dict",
            "    openapi = GeneratorData.from_dict(data_dict)",
            "    if isinstance(openapi, GeneratorError):",
            "        return openapi",
            "    return Project(openapi=openapi)",
            "",
            "",
            "def create_new_client(*, url: Optional[str], path: Optional[Path]) -> Sequence[GeneratorError]:",
            "    \"\"\"",
            "    Generate the client library",
            "",
            "    Returns:",
            "         A list containing any errors encountered when generating.",
            "    \"\"\"",
            "    project = _get_project_for_url_or_path(url=url, path=path)",
            "    if isinstance(project, GeneratorError):",
            "        return [project]",
            "    return project.build()",
            "",
            "",
            "def update_existing_client(*, url: Optional[str], path: Optional[Path]) -> Sequence[GeneratorError]:",
            "    \"\"\"",
            "    Update an existing client library",
            "",
            "    Returns:",
            "         A list containing any errors encountered when generating.",
            "    \"\"\"",
            "    project = _get_project_for_url_or_path(url=url, path=path)",
            "    if isinstance(project, GeneratorError):",
            "        return [project]",
            "    return project.update()",
            "",
            "",
            "def _get_document(*, url: Optional[str], path: Optional[Path]) -> Union[Dict[str, Any], GeneratorError]:",
            "    yaml_bytes: bytes",
            "    if url is not None and path is not None:",
            "        return GeneratorError(header=\"Provide URL or Path, not both.\")",
            "    if url is not None:",
            "        try:",
            "            response = httpx.get(url)",
            "            yaml_bytes = response.content",
            "        except (httpx.HTTPError, httpcore.NetworkError):",
            "            return GeneratorError(header=\"Could not get OpenAPI document from provided URL\")",
            "    elif path is not None:",
            "        yaml_bytes = path.read_bytes()",
            "    else:",
            "        return GeneratorError(header=\"No URL or Path provided\")",
            "    try:",
            "        return yaml.safe_load(yaml_bytes)",
            "    except yaml.YAMLError:",
            "        return GeneratorError(header=\"Invalid YAML from provided source\")",
            "",
            "",
            "class Project:",
            "    TEMPLATE_FILTERS = {\"snakecase\": utils.snake_case, \"spinalcase\": utils.spinal_case}",
            "    project_name_override: Optional[str] = None",
            "    package_name_override: Optional[str] = None",
            "",
            "    def __init__(self, *, openapi: GeneratorData) -> None:",
            "        self.openapi: GeneratorData = openapi",
            "        self.env: Environment = Environment(loader=PackageLoader(__package__), trim_blocks=True, lstrip_blocks=True)",
            "",
            "        self.project_name: str = self.project_name_override or f\"{openapi.title.replace(' ', '-').lower()}-client\"",
            "        self.project_dir: Path = Path.cwd() / self.project_name",
            "",
            "        self.package_name: str = self.package_name_override or self.project_name.replace(\"-\", \"_\")",
            "        self.package_dir: Path = self.project_dir / self.package_name",
            "        self.package_description: str = f\"A client library for accessing {self.openapi.title}\"",
            "        self.version: str = openapi.version",
            "",
            "        self.env.filters.update(self.TEMPLATE_FILTERS)",
            "",
            "    def build(self) -> Sequence[GeneratorError]:",
            "        \"\"\" Create the project from templates \"\"\"",
            "",
            "        print(f\"Generating {self.project_name}\")",
            "        try:",
            "            self.project_dir.mkdir()",
            "        except FileExistsError:",
            "            return [GeneratorError(detail=\"Directory already exists. Delete it or use the update command.\")]",
            "        self._create_package()",
            "        self._build_metadata()",
            "        self._build_models()",
            "        self._build_api()",
            "        self._reformat()",
            "        return self._get_errors()",
            "",
            "    def update(self) -> Sequence[GeneratorError]:",
            "        \"\"\" Update an existing project \"\"\"",
            "",
            "        if not self.package_dir.is_dir():",
            "            raise FileNotFoundError()",
            "        print(f\"Updating {self.project_name}\")",
            "        shutil.rmtree(self.package_dir)",
            "        self._create_package()",
            "        self._build_models()",
            "        self._build_api()",
            "        self._reformat()",
            "        return self._get_errors()",
            "",
            "    def _reformat(self) -> None:",
            "        subprocess.run(",
            "            \"isort .\", cwd=self.project_dir, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,",
            "        )",
            "        subprocess.run(\"black .\", cwd=self.project_dir, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
            "",
            "    def _get_errors(self) -> Sequence[GeneratorError]:",
            "        errors = []",
            "        for collection in self.openapi.endpoint_collections_by_tag.values():",
            "            errors.extend(collection.parse_errors)",
            "        errors.extend(self.openapi.schemas.errors)",
            "        return errors",
            "",
            "    def _create_package(self) -> None:",
            "        self.package_dir.mkdir()",
            "        # Package __init__.py",
            "        package_init = self.package_dir / \"__init__.py\"",
            "",
            "        package_init_template = self.env.get_template(\"package_init.pyi\")",
            "        package_init.write_text(package_init_template.render(description=self.package_description))",
            "",
            "        pytyped = self.package_dir / \"py.typed\"",
            "        pytyped.write_text(\"# Marker file for PEP 561\")",
            "",
            "    def _build_metadata(self) -> None:",
            "        # Create a pyproject.toml file",
            "        pyproject_template = self.env.get_template(\"pyproject.toml\")",
            "        pyproject_path = self.project_dir / \"pyproject.toml\"",
            "        pyproject_path.write_text(",
            "            pyproject_template.render(",
            "                project_name=self.project_name,",
            "                package_name=self.package_name,",
            "                version=self.version,",
            "                description=self.package_description,",
            "            )",
            "        )",
            "",
            "        # README.md",
            "        readme = self.project_dir / \"README.md\"",
            "        readme_template = self.env.get_template(\"README.md\")",
            "        readme.write_text(",
            "            readme_template.render(",
            "                project_name=self.project_name, description=self.package_description, package_name=self.package_name",
            "            )",
            "        )",
            "",
            "        # .gitignore",
            "        git_ignore_path = self.project_dir / \".gitignore\"",
            "        git_ignore_template = self.env.get_template(\".gitignore\")",
            "        git_ignore_path.write_text(git_ignore_template.render())",
            "",
            "    def _build_models(self) -> None:",
            "        # Generate models",
            "        models_dir = self.package_dir / \"models\"",
            "        models_dir.mkdir()",
            "        models_init = models_dir / \"__init__.py\"",
            "        imports = []",
            "",
            "        types_template = self.env.get_template(\"types.py\")",
            "        types_path = models_dir / \"types.py\"",
            "        types_path.write_text(types_template.render())",
            "",
            "        model_template = self.env.get_template(\"model.pyi\")",
            "        for model in self.openapi.schemas.models.values():",
            "            module_path = models_dir / f\"{model.reference.module_name}.py\"",
            "            module_path.write_text(model_template.render(model=model))",
            "            imports.append(import_string_from_reference(model.reference))",
            "",
            "        # Generate enums",
            "        enum_template = self.env.get_template(\"enum.pyi\")",
            "        for enum in self.openapi.enums.values():",
            "            module_path = models_dir / f\"{enum.reference.module_name}.py\"",
            "            module_path.write_text(enum_template.render(enum=enum))",
            "            imports.append(import_string_from_reference(enum.reference))",
            "",
            "        models_init_template = self.env.get_template(\"models_init.pyi\")",
            "        models_init.write_text(models_init_template.render(imports=imports))",
            "",
            "    def _build_api(self) -> None:",
            "        # Generate Client",
            "        client_path = self.package_dir / \"client.py\"",
            "        client_template = self.env.get_template(\"client.pyi\")",
            "        client_path.write_text(client_template.render())",
            "",
            "        # Generate endpoints",
            "        api_dir = self.package_dir / \"api\"",
            "        api_dir.mkdir()",
            "        api_init = api_dir / \"__init__.py\"",
            "        api_init.write_text('\"\"\" Contains synchronous methods for accessing the API \"\"\"')",
            "",
            "        async_api_dir = self.package_dir / \"async_api\"",
            "        async_api_dir.mkdir()",
            "        async_api_init = async_api_dir / \"__init__.py\"",
            "        async_api_init.write_text('\"\"\" Contains async methods for accessing the API \"\"\"')",
            "",
            "        api_errors = self.package_dir / \"errors.py\"",
            "        errors_template = self.env.get_template(\"errors.pyi\")",
            "        api_errors.write_text(errors_template.render())",
            "",
            "        endpoint_template = self.env.get_template(\"endpoint_module.pyi\")",
            "        async_endpoint_template = self.env.get_template(\"async_endpoint_module.pyi\")",
            "        for tag, collection in self.openapi.endpoint_collections_by_tag.items():",
            "            module_path = api_dir / f\"{tag}.py\"",
            "            module_path.write_text(endpoint_template.render(collection=collection))",
            "            async_module_path = async_api_dir / f\"{tag}.py\"",
            "            async_module_path.write_text(async_endpoint_template.render(collection=collection))"
        ],
        "afterPatchFile": [
            "\"\"\" Generate modern Python clients from OpenAPI \"\"\"",
            "from __future__ import annotations",
            "",
            "import shutil",
            "import subprocess",
            "import sys",
            "from pathlib import Path",
            "from typing import Any, Dict, Optional, Sequence, Union",
            "",
            "import httpcore",
            "import httpx",
            "import yaml",
            "from jinja2 import Environment, PackageLoader",
            "",
            "from openapi_python_client import utils",
            "",
            "from .parser import GeneratorData, import_string_from_reference",
            "from .parser.errors import GeneratorError",
            "",
            "if sys.version_info.minor == 7:  # version did not exist in 3.7, need to use a backport",
            "    from importlib_metadata import version",
            "else:",
            "    from importlib.metadata import version  # type: ignore",
            "",
            "",
            "__version__ = version(__package__)",
            "",
            "",
            "def _get_project_for_url_or_path(url: Optional[str], path: Optional[Path]) -> Union[Project, GeneratorError]:",
            "    data_dict = _get_document(url=url, path=path)",
            "    if isinstance(data_dict, GeneratorError):",
            "        return data_dict",
            "    openapi = GeneratorData.from_dict(data_dict)",
            "    if isinstance(openapi, GeneratorError):",
            "        return openapi",
            "    return Project(openapi=openapi)",
            "",
            "",
            "def create_new_client(*, url: Optional[str], path: Optional[Path]) -> Sequence[GeneratorError]:",
            "    \"\"\"",
            "    Generate the client library",
            "",
            "    Returns:",
            "         A list containing any errors encountered when generating.",
            "    \"\"\"",
            "    project = _get_project_for_url_or_path(url=url, path=path)",
            "    if isinstance(project, GeneratorError):",
            "        return [project]",
            "    return project.build()",
            "",
            "",
            "def update_existing_client(*, url: Optional[str], path: Optional[Path]) -> Sequence[GeneratorError]:",
            "    \"\"\"",
            "    Update an existing client library",
            "",
            "    Returns:",
            "         A list containing any errors encountered when generating.",
            "    \"\"\"",
            "    project = _get_project_for_url_or_path(url=url, path=path)",
            "    if isinstance(project, GeneratorError):",
            "        return [project]",
            "    return project.update()",
            "",
            "",
            "def _get_document(*, url: Optional[str], path: Optional[Path]) -> Union[Dict[str, Any], GeneratorError]:",
            "    yaml_bytes: bytes",
            "    if url is not None and path is not None:",
            "        return GeneratorError(header=\"Provide URL or Path, not both.\")",
            "    if url is not None:",
            "        try:",
            "            response = httpx.get(url)",
            "            yaml_bytes = response.content",
            "        except (httpx.HTTPError, httpcore.NetworkError):",
            "            return GeneratorError(header=\"Could not get OpenAPI document from provided URL\")",
            "    elif path is not None:",
            "        yaml_bytes = path.read_bytes()",
            "    else:",
            "        return GeneratorError(header=\"No URL or Path provided\")",
            "    try:",
            "        return yaml.safe_load(yaml_bytes)",
            "    except yaml.YAMLError:",
            "        return GeneratorError(header=\"Invalid YAML from provided source\")",
            "",
            "",
            "class Project:",
            "    TEMPLATE_FILTERS = {\"snakecase\": utils.snake_case, \"kebabcase\": utils.kebab_case}",
            "    project_name_override: Optional[str] = None",
            "    package_name_override: Optional[str] = None",
            "",
            "    def __init__(self, *, openapi: GeneratorData) -> None:",
            "        self.openapi: GeneratorData = openapi",
            "        self.env: Environment = Environment(loader=PackageLoader(__package__), trim_blocks=True, lstrip_blocks=True)",
            "",
            "        self.project_name: str = self.project_name_override or f\"{utils.kebab_case(openapi.title).lower()}-client\"",
            "        self.project_dir: Path = Path.cwd() / self.project_name",
            "",
            "        self.package_name: str = self.package_name_override or self.project_name.replace(\"-\", \"_\")",
            "        self.package_dir: Path = self.project_dir / self.package_name",
            "        self.package_description: str = f\"A client library for accessing {self.openapi.title}\"",
            "        self.version: str = openapi.version",
            "",
            "        self.env.filters.update(self.TEMPLATE_FILTERS)",
            "",
            "    def build(self) -> Sequence[GeneratorError]:",
            "        \"\"\" Create the project from templates \"\"\"",
            "",
            "        print(f\"Generating {self.project_name}\")",
            "        try:",
            "            self.project_dir.mkdir()",
            "        except FileExistsError:",
            "            return [GeneratorError(detail=\"Directory already exists. Delete it or use the update command.\")]",
            "        self._create_package()",
            "        self._build_metadata()",
            "        self._build_models()",
            "        self._build_api()",
            "        self._reformat()",
            "        return self._get_errors()",
            "",
            "    def update(self) -> Sequence[GeneratorError]:",
            "        \"\"\" Update an existing project \"\"\"",
            "",
            "        if not self.package_dir.is_dir():",
            "            raise FileNotFoundError()",
            "        print(f\"Updating {self.project_name}\")",
            "        shutil.rmtree(self.package_dir)",
            "        self._create_package()",
            "        self._build_models()",
            "        self._build_api()",
            "        self._reformat()",
            "        return self._get_errors()",
            "",
            "    def _reformat(self) -> None:",
            "        subprocess.run(",
            "            \"isort .\", cwd=self.project_dir, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,",
            "        )",
            "        subprocess.run(\"black .\", cwd=self.project_dir, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)",
            "",
            "    def _get_errors(self) -> Sequence[GeneratorError]:",
            "        errors = []",
            "        for collection in self.openapi.endpoint_collections_by_tag.values():",
            "            errors.extend(collection.parse_errors)",
            "        errors.extend(self.openapi.schemas.errors)",
            "        return errors",
            "",
            "    def _create_package(self) -> None:",
            "        self.package_dir.mkdir()",
            "        # Package __init__.py",
            "        package_init = self.package_dir / \"__init__.py\"",
            "",
            "        package_init_template = self.env.get_template(\"package_init.pyi\")",
            "        package_init.write_text(package_init_template.render(description=self.package_description))",
            "",
            "        pytyped = self.package_dir / \"py.typed\"",
            "        pytyped.write_text(\"# Marker file for PEP 561\")",
            "",
            "    def _build_metadata(self) -> None:",
            "        # Create a pyproject.toml file",
            "        pyproject_template = self.env.get_template(\"pyproject.toml\")",
            "        pyproject_path = self.project_dir / \"pyproject.toml\"",
            "        pyproject_path.write_text(",
            "            pyproject_template.render(",
            "                project_name=self.project_name,",
            "                package_name=self.package_name,",
            "                version=self.version,",
            "                description=self.package_description,",
            "            )",
            "        )",
            "",
            "        # README.md",
            "        readme = self.project_dir / \"README.md\"",
            "        readme_template = self.env.get_template(\"README.md\")",
            "        readme.write_text(",
            "            readme_template.render(",
            "                project_name=self.project_name, description=self.package_description, package_name=self.package_name",
            "            )",
            "        )",
            "",
            "        # .gitignore",
            "        git_ignore_path = self.project_dir / \".gitignore\"",
            "        git_ignore_template = self.env.get_template(\".gitignore\")",
            "        git_ignore_path.write_text(git_ignore_template.render())",
            "",
            "    def _build_models(self) -> None:",
            "        # Generate models",
            "        models_dir = self.package_dir / \"models\"",
            "        models_dir.mkdir()",
            "        models_init = models_dir / \"__init__.py\"",
            "        imports = []",
            "",
            "        types_template = self.env.get_template(\"types.py\")",
            "        types_path = models_dir / \"types.py\"",
            "        types_path.write_text(types_template.render())",
            "",
            "        model_template = self.env.get_template(\"model.pyi\")",
            "        for model in self.openapi.schemas.models.values():",
            "            module_path = models_dir / f\"{model.reference.module_name}.py\"",
            "            module_path.write_text(model_template.render(model=model))",
            "            imports.append(import_string_from_reference(model.reference))",
            "",
            "        # Generate enums",
            "        enum_template = self.env.get_template(\"enum.pyi\")",
            "        for enum in self.openapi.enums.values():",
            "            module_path = models_dir / f\"{enum.reference.module_name}.py\"",
            "            module_path.write_text(enum_template.render(enum=enum))",
            "            imports.append(import_string_from_reference(enum.reference))",
            "",
            "        models_init_template = self.env.get_template(\"models_init.pyi\")",
            "        models_init.write_text(models_init_template.render(imports=imports))",
            "",
            "    def _build_api(self) -> None:",
            "        # Generate Client",
            "        client_path = self.package_dir / \"client.py\"",
            "        client_template = self.env.get_template(\"client.pyi\")",
            "        client_path.write_text(client_template.render())",
            "",
            "        # Generate endpoints",
            "        api_dir = self.package_dir / \"api\"",
            "        api_dir.mkdir()",
            "        api_init = api_dir / \"__init__.py\"",
            "        api_init.write_text('\"\"\" Contains synchronous methods for accessing the API \"\"\"')",
            "",
            "        async_api_dir = self.package_dir / \"async_api\"",
            "        async_api_dir.mkdir()",
            "        async_api_init = async_api_dir / \"__init__.py\"",
            "        async_api_init.write_text('\"\"\" Contains async methods for accessing the API \"\"\"')",
            "",
            "        api_errors = self.package_dir / \"errors.py\"",
            "        errors_template = self.env.get_template(\"errors.pyi\")",
            "        api_errors.write_text(errors_template.render())",
            "",
            "        endpoint_template = self.env.get_template(\"endpoint_module.pyi\")",
            "        async_endpoint_template = self.env.get_template(\"async_endpoint_module.pyi\")",
            "        for tag, collection in self.openapi.endpoint_collections_by_tag.items():",
            "            tag = utils.snake_case(tag)",
            "            module_path = api_dir / f\"{tag}.py\"",
            "            module_path.write_text(endpoint_template.render(collection=collection))",
            "            async_module_path = async_api_dir / f\"{tag}.py\"",
            "            async_module_path.write_text(async_endpoint_template.render(collection=collection))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "86": [
                "Project"
            ],
            "94": [
                "Project",
                "__init__"
            ]
        },
        "addLocation": []
    },
    "openapi_python_client/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " import stringcase"
            },
            "1": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def snake_case(value: str) -> str:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+def _sanitize(value: str) -> str:"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+    return re.sub(r\"[^\\w _-]+\", \"\", value)"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+def group_title(value: str) -> str:"
            },
            "9": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 11,
                "PatchRowcode": "     value = re.sub(r\"([A-Z]{2,})([A-Z][a-z]|[ -_]|$)\", lambda m: m.group(1).title() + m.group(2), value.strip())"
            },
            "10": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 12,
                "PatchRowcode": "     value = re.sub(r\"(^|[ _-])([A-Z])\", lambda m: m.group(1) + m.group(2).lower(), value)"
            },
            "11": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return stringcase.snakecase(value)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+    return value"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+def snake_case(value: str) -> str:"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+    return stringcase.snakecase(group_title(_sanitize(value)))"
            },
            "17": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " def pascal_case(value: str) -> str:"
            },
            "20": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return stringcase.pascalcase(value)"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+    return stringcase.pascalcase(_sanitize(value))"
            },
            "22": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def spinal_case(value: str) -> str:"
            },
            "25": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return stringcase.spinalcase(value)"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+def kebab_case(value: str) -> str:"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+    return stringcase.spinalcase(group_title(_sanitize(value)))"
            }
        },
        "frontPatchFile": [
            "import re",
            "",
            "import stringcase",
            "",
            "",
            "def snake_case(value: str) -> str:",
            "    value = re.sub(r\"([A-Z]{2,})([A-Z][a-z]|[ -_]|$)\", lambda m: m.group(1).title() + m.group(2), value.strip())",
            "    value = re.sub(r\"(^|[ _-])([A-Z])\", lambda m: m.group(1) + m.group(2).lower(), value)",
            "    return stringcase.snakecase(value)",
            "",
            "",
            "def pascal_case(value: str) -> str:",
            "    return stringcase.pascalcase(value)",
            "",
            "",
            "def spinal_case(value: str) -> str:",
            "    return stringcase.spinalcase(value)"
        ],
        "afterPatchFile": [
            "import re",
            "",
            "import stringcase",
            "",
            "",
            "def _sanitize(value: str) -> str:",
            "    return re.sub(r\"[^\\w _-]+\", \"\", value)",
            "",
            "",
            "def group_title(value: str) -> str:",
            "    value = re.sub(r\"([A-Z]{2,})([A-Z][a-z]|[ -_]|$)\", lambda m: m.group(1).title() + m.group(2), value.strip())",
            "    value = re.sub(r\"(^|[ _-])([A-Z])\", lambda m: m.group(1) + m.group(2).lower(), value)",
            "    return value",
            "",
            "",
            "def snake_case(value: str) -> str:",
            "    return stringcase.snakecase(group_title(_sanitize(value)))",
            "",
            "",
            "def pascal_case(value: str) -> str:",
            "    return stringcase.pascalcase(_sanitize(value))",
            "",
            "",
            "def kebab_case(value: str) -> str:",
            "    return stringcase.spinalcase(group_title(_sanitize(value)))"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "6": [
                "snake_case"
            ],
            "9": [
                "snake_case"
            ],
            "13": [
                "pascal_case"
            ],
            "16": [
                "spinal_case"
            ],
            "17": [
                "spinal_case"
            ]
        },
        "addLocation": []
    }
}