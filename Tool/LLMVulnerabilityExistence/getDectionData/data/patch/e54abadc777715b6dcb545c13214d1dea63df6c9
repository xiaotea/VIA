{
    "weixin/msg.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 64,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "     def parse(self, content):"
            },
            "2": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "         raw = {}"
            },
            "3": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        root = etree.fromstring(content)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        root = etree.fromstring(content,"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+                                parser=etree.XMLParser(resolve_entities=False))"
            },
            "6": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "         for child in root:"
            },
            "7": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "             raw[child.tag] = child.text"
            },
            "8": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "",
            "from __future__ import unicode_literals",
            "",
            "import time",
            "import hashlib",
            "",
            "from datetime import datetime",
            "",
            "from .base import WeixinError",
            "",
            "try:",
            "    from flask import request, Response",
            "except ImportError:",
            "    request, Response = None, None",
            "",
            "try:",
            "    from django.http import HttpResponse, HttpResponseForbidden, HttpResponseNotAllowed",
            "except Exception:",
            "    HttpResponse, HttpResponseForbidden, HttpResponseNotAllowed = None, None, None",
            "",
            "try:",
            "    from lxml import etree",
            "except ImportError:",
            "    from xml.etree import cElementTree as etree",
            "except ImportError:",
            "    from xml.etree import ElementTree as etree",
            "",
            "",
            "__all__ = (\"WeixinMsgError\", \"WeixinMsg\")",
            "",
            "",
            "class WeixinMsgError(WeixinError):",
            "",
            "    def __init__(self, msg):",
            "        super(WeixinMsgError, self).__init__(msg)",
            "",
            "",
            "class WeixinMsg(object):",
            "",
            "    def __init__(self, token, sender=None, expires_in=0):",
            "        self.token = token",
            "        self.sender = sender",
            "        self.expires_in = expires_in",
            "        self._registry = dict()",
            "",
            "    def validate(self, signature, timestamp, nonce):",
            "        if not self.token:",
            "            raise WeixinMsgError(\"weixin token is missing\")",
            "",
            "        if self.expires_in:",
            "            try:",
            "                timestamp = int(timestamp)",
            "            except ValueError:",
            "                return False",
            "            delta = time.time() - timestamp",
            "            if delta < 0 or delta > self.expires_in:",
            "                return False",
            "        values = [self.token, str(timestamp), str(nonce)]",
            "        s = ''.join(sorted(values))",
            "        hsh = hashlib.sha1(s.encode(\"utf-8\")).hexdigest()",
            "        return signature == hsh",
            "",
            "    def parse(self, content):",
            "        raw = {}",
            "        root = etree.fromstring(content)",
            "        for child in root:",
            "            raw[child.tag] = child.text",
            "",
            "        formatted = self.format(raw)",
            "        msg_type = formatted['type']",
            "        msg_parser = getattr(self, 'parse_{0}'.format(msg_type), None)",
            "        if callable(msg_parser):",
            "            parsed = msg_parser(raw)",
            "        else:",
            "            parsed = self.parse_invalid_type(raw)",
            "",
            "        formatted.update(parsed)",
            "        return formatted",
            "",
            "    def format(self, kwargs):",
            "        timestamp = int(kwargs['CreateTime'])",
            "        return {",
            "            'id': kwargs.get('MsgId'),",
            "            'timestamp': timestamp,",
            "            'receiver': kwargs['ToUserName'],",
            "            'sender': kwargs['FromUserName'],",
            "            'type': kwargs['MsgType'],",
            "            'time': datetime.fromtimestamp(timestamp),",
            "        }",
            "",
            "    def parse_text(self, raw):",
            "        return {'content': raw['Content']}",
            "",
            "    def parse_image(self, raw):",
            "        return {'picurl': raw['PicUrl']}",
            "",
            "    def parse_location(self, raw):",
            "        return {",
            "            'location_x': raw['Location_X'],",
            "            'location_y': raw['Location_Y'],",
            "            'scale': int(raw.get('Scale', 0)),",
            "            'label': raw['Label'],",
            "        }",
            "",
            "    def parse_link(self, raw):",
            "        return {",
            "            'title': raw['Title'],",
            "            'description': raw['Description'],",
            "            'url': raw['url'],",
            "        }",
            "",
            "    def parse_voice(self, raw):",
            "        return {",
            "            'media_id': raw['MediaId'],",
            "            'format': raw['Format'],",
            "            'recognition': raw['Recognition'],",
            "        }",
            "",
            "    def parse_video(self, raw):",
            "        return {",
            "            'media_id': raw['MediaId'],",
            "            'thumb_media_id': raw['ThumbMediaId'],",
            "        }",
            "",
            "    def parse_shortvideo(self, raw):",
            "        return {",
            "            'media_id': raw['MediaId'],",
            "            'thumb_media_id': raw['ThumbMediaId'],",
            "        }",
            "",
            "    def parse_event(self, raw):",
            "        return {",
            "            'event': raw.get('Event'),",
            "            'event_key': raw.get('EventKey'),",
            "            'ticket': raw.get('Ticket'),",
            "            'latitude': raw.get('Latitude'),",
            "            'longitude': raw.get('Longitude'),",
            "            'precision': raw.get('Precision'),",
            "            'status': raw.get('status')",
            "        }",
            "",
            "    def parse_invalid_type(self, raw):",
            "        return {}",
            "",
            "    def reply(self, username=None, type='text', sender=None, **kwargs):",
            "        if not username:",
            "            raise RuntimeError(\"username is missing\")",
            "        sender = sender or self.sender",
            "        if not sender:",
            "            raise RuntimeError('WEIXIN_SENDER or sender argument is missing')",
            "",
            "        if type == 'text':",
            "            content = kwargs.get('content', '')",
            "            return text_reply(username, sender, content)",
            "",
            "        if type == 'music':",
            "            values = {}",
            "            for k in ('title', 'description', 'music_url', 'hq_music_url'):",
            "                values[k] = kwargs[k]",
            "            return music_reply(username, sender, **values)",
            "",
            "        if type == 'news':",
            "            items = kwargs['articles']",
            "            return news_reply(username, sender, *items)",
            "",
            "        if type == 'customer_service':",
            "            service_account = kwargs['service_account']",
            "            return transfer_customer_service_reply(username, sender,",
            "                                                   service_account)",
            "",
            "        if type == 'image':",
            "            media_id = kwargs.get('media_id')",
            "            return image_reply(username, sender, media_id)",
            "",
            "        if type == 'voice':",
            "            media_id = kwargs.get('media_id')",
            "            return voice_reply(username, sender, media_id)",
            "",
            "        if type == 'video':",
            "            values = {}",
            "            for k in ('media_id', 'title', 'description'):",
            "                values[k] = kwargs[k]",
            "            return video_reply(username, sender, **values)",
            "",
            "    def register(self, type, key=None, func=None):",
            "        if func:",
            "            key = '*' if not key else key",
            "            self._registry.setdefault(type, dict())[key] = func",
            "            return func",
            "        return self.__call__(type, key)",
            "",
            "    def __call__(self, type, key):",
            "        def wrapper(func):",
            "            self.register(type, key, func)",
            "            return func",
            "        return wrapper",
            "",
            "    @property",
            "    def all(self):",
            "        return self.register('*')",
            "",
            "    def text(self, key='*'):",
            "        return self.register('text', key)",
            "",
            "    def __getattr__(self, key):",
            "        key = key.lower()",
            "        if key in ['image', 'video', 'voice', 'shortvideo', 'location', 'link', 'event']:",
            "            return self.register(key)",
            "        if key in ['subscribe', 'unsubscribe', 'location', 'click', 'view', 'scan', \\",
            "                   'scancode_push', 'scancode_waitmsg', 'pic_sysphoto', \\",
            "                   'pic_photo_or_album', 'pic_weixin', 'location_select', \\",
            "                   'qualification_verify_success', 'qualification_verify_fail', 'naming_verify_success', \\",
            "                   'naming_verify_fail', 'annual_renew', 'verify_expired', \\",
            "                   'card_pass_check', 'user_get_card', 'user_del_card', 'user_consume_card', \\",
            "                   'user_pay_from_pay_cell', 'user_view_card', 'user_enter_session_from_card', \\",
            "                   'card_sku_remind']:",
            "            return self.register('event', key)",
            "        raise AttributeError('invalid attribute \"' + key + '\"')",
            "",
            "    def django_view_func(self):",
            "",
            "        def run(request):",
            "            if HttpResponse is None:",
            "                raise RuntimeError('django_view_func need Django be installed')",
            "            signature = request.GET.get('signature')",
            "",
            "            timestamp = request.GET.get('timestamp')",
            "            nonce = request.GET.get('nonce')",
            "            if not self.validate(signature, timestamp, nonce):",
            "                return HttpResponseForbidden('signature failed')",
            "            if request.method == 'GET':",
            "                echostr = request.args.get('echostr', '')",
            "                return HttpResponse(echostr)",
            "            elif request.method == \"POST\":",
            "                try:",
            "                    ret = self.parse(request.body)",
            "                except ValueError:",
            "                    return HttpResponseForbidden('invalid')",
            "",
            "                func = None",
            "                type = ret['type']",
            "                _registry = self._registry.get(type, dict())",
            "                if type == 'text':",
            "                    if ret['content'] in _registry:",
            "                        func = _registry[ret['content']]",
            "                elif type == 'event':",
            "                    if ret['event'].lower() in _registry:",
            "                        func = _registry[ret['event'].lower()]",
            "",
            "                if func is None and '*' in _registry:",
            "                    func = _registry['*']",
            "                if func is None and '*' in self._registry:",
            "                    func = self._registry.get('*', dict()).get('*')",
            "",
            "                text = ''",
            "                if func is None:",
            "                    text = 'failed'",
            "",
            "                if callable(func):",
            "                    text = func(**ret)",
            "",
            "                content = ''",
            "                if isinstance(text, basestring):",
            "                    if text:",
            "                        content = self.reply(",
            "                            username=ret['sender'],",
            "                            sender=ret['receiver'],",
            "                            content=text,",
            "                        )",
            "                elif isinstance(text, dict):",
            "                    text.setdefault('username', ret['sender'])",
            "                    text.setdefault('sender', ret['receiver'])",
            "                    content = self.reply(**text)",
            "",
            "                return HttpResponse(content, content_type='text/xml; charset=utf-8')",
            "            return HttpResponseNotAllowed(['GET', 'POST'])",
            "        return run",
            "",
            "    def view_func(self):",
            "        if request is None:",
            "            raise RuntimeError('view_func need Flask be installed')",
            "",
            "        signature = request.args.get('signature')",
            "        timestamp = request.args.get('timestamp')",
            "        nonce = request.args.get('nonce')",
            "        if not self.validate(signature, timestamp, nonce):",
            "            return 'signature failed', 400",
            "        if request.method == 'GET':",
            "            echostr = request.args.get('echostr', '')",
            "            return echostr",
            "",
            "        try:",
            "            ret = self.parse(request.data)",
            "        except ValueError:",
            "            return 'invalid', 400",
            "",
            "        func = None",
            "        type = ret['type']",
            "        _registry = self._registry.get(type, dict())",
            "        if type == 'text':",
            "            if ret['content'] in _registry:",
            "                func = _registry[ret['content']]",
            "        elif type == 'event':",
            "            if ret['event'].lower() in _registry:",
            "                func = _registry[ret['event'].lower()]",
            "",
            "        if func is None and '*' in _registry:",
            "            func = _registry['*']",
            "        if func is None and '*' in self._registry:",
            "            func = self._registry.get('*', dict()).get('*')",
            "",
            "        text = ''",
            "        if func is None:",
            "            text = 'failed'",
            "",
            "        if callable(func):",
            "            text = func(**ret)",
            "",
            "        content = ''",
            "        if isinstance(text, basestring):",
            "            if text:",
            "                content = self.reply(",
            "                    username=ret['sender'],",
            "                    sender=ret['receiver'],",
            "                    content=text,",
            "                )",
            "        elif isinstance(text, dict):",
            "            text.setdefault('username', ret['sender'])",
            "            text.setdefault('sender', ret['receiver'])",
            "            content = self.reply(**text)",
            "",
            "        return Response(content, content_type='text/xml; charset=utf-8')",
            "",
            "    view_func.methods = ['GET', 'POST']",
            "",
            "",
            "def text_reply(username, sender, content):",
            "    shared = _shared_reply(username, sender, 'text')",
            "    template = '<xml>%s<Content><![CDATA[%s]]></Content></xml>'",
            "    return template % (shared, content)",
            "",
            "",
            "def music_reply(username, sender, **kwargs):",
            "    kwargs['shared'] = _shared_reply(username, sender, 'music')",
            "",
            "    template = (",
            "        '<xml>'",
            "        '%(shared)s'",
            "        '<Music>'",
            "        '<Title><![CDATA[%(title)s]]></Title>'",
            "        '<Description><![CDATA[%(description)s]]></Description>'",
            "        '<MusicUrl><![CDATA[%(music_url)s]]></MusicUrl>'",
            "        '<HQMusicUrl><![CDATA[%(hq_music_url)s]]></HQMusicUrl>'",
            "        '</Music>'",
            "        '</xml>'",
            "    )",
            "    return template % kwargs",
            "",
            "",
            "def news_reply(username, sender, *items):",
            "    item_template = (",
            "        '<item>'",
            "        '<Title><![CDATA[%(title)s]]></Title>'",
            "        '<Description><![CDATA[%(description)s]]></Description>'",
            "        '<PicUrl><![CDATA[%(picurl)s]]></PicUrl>'",
            "        '<Url><![CDATA[%(url)s]]></Url>'",
            "        '</item>'",
            "    )",
            "    articles = [item_template % o for o in items]",
            "",
            "    template = (",
            "        '<xml>'",
            "        '%(shared)s'",
            "        '<ArticleCount>%(count)d</ArticleCount>'",
            "        '<Articles>%(articles)s</Articles>'",
            "        '</xml>'",
            "    )",
            "    dct = {",
            "        'shared': _shared_reply(username, sender, 'news'),",
            "        'count': len(items),",
            "        'articles': ''.join(articles)",
            "    }",
            "    return template % dct",
            "",
            "",
            "def transfer_customer_service_reply(username, sender, service_account):",
            "    template = (",
            "        '<xml>%(shared)s'",
            "        '%(transfer_info)s</xml>')",
            "    transfer_info = ''",
            "    if service_account:",
            "        transfer_info = (",
            "            '<TransInfo>'",
            "            '<KfAccount>![CDATA[%s]]</KfAccount>'",
            "            '</TransInfo>') % service_account",
            "",
            "    dct = {",
            "        'shared': _shared_reply(username, sender,",
            "                                type='transfer_customer_service'),",
            "        'transfer_info': transfer_info",
            "    }",
            "    return template % dct",
            "",
            "",
            "def image_reply(username, sender, media_id):",
            "    shared = _shared_reply(username, sender, 'image')",
            "    template = '<xml>%s<Image><MediaId><![CDATA[%s]]></MediaId></Image></xml>'",
            "    return template % (shared, media_id)",
            "",
            "",
            "def voice_reply(username, sender, media_id):",
            "    shared = _shared_reply(username, sender, 'voice')",
            "    template = '<xml>%s<Voice><MediaId><![CDATA[%s]]></MediaId></Voice></xml>'",
            "    return template % (shared, media_id)",
            "",
            "",
            "def video_reply(username, sender, **kwargs):",
            "    kwargs['shared'] = _shared_reply(username, sender, 'video')",
            "",
            "    template = (",
            "        '<xml>'",
            "        '%(shared)s'",
            "        '<Video>'",
            "        '<MediaId><![CDATA[%(media_id)s]]></MediaId>'",
            "        '<Title><![CDATA[%(title)s]]></Title>'",
            "        '<Description><![CDATA[%(description)s]]></Description>'",
            "        '</Video>'",
            "        '</xml>'",
            "    )",
            "    return template % kwargs",
            "",
            "",
            "def _shared_reply(username, sender, type):",
            "    dct = {",
            "        'username': username,",
            "        'sender': sender,",
            "        'type': type,",
            "        'timestamp': int(time.time()),",
            "    }",
            "    template = (",
            "        '<ToUserName><![CDATA[%(username)s]]></ToUserName>'",
            "        '<FromUserName><![CDATA[%(sender)s]]></FromUserName>'",
            "        '<CreateTime>%(timestamp)d</CreateTime>'",
            "        '<MsgType><![CDATA[%(type)s]]></MsgType>'",
            "    )",
            "    return template % dct"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "",
            "from __future__ import unicode_literals",
            "",
            "import time",
            "import hashlib",
            "",
            "from datetime import datetime",
            "",
            "from .base import WeixinError",
            "",
            "try:",
            "    from flask import request, Response",
            "except ImportError:",
            "    request, Response = None, None",
            "",
            "try:",
            "    from django.http import HttpResponse, HttpResponseForbidden, HttpResponseNotAllowed",
            "except Exception:",
            "    HttpResponse, HttpResponseForbidden, HttpResponseNotAllowed = None, None, None",
            "",
            "try:",
            "    from lxml import etree",
            "except ImportError:",
            "    from xml.etree import cElementTree as etree",
            "except ImportError:",
            "    from xml.etree import ElementTree as etree",
            "",
            "",
            "__all__ = (\"WeixinMsgError\", \"WeixinMsg\")",
            "",
            "",
            "class WeixinMsgError(WeixinError):",
            "",
            "    def __init__(self, msg):",
            "        super(WeixinMsgError, self).__init__(msg)",
            "",
            "",
            "class WeixinMsg(object):",
            "",
            "    def __init__(self, token, sender=None, expires_in=0):",
            "        self.token = token",
            "        self.sender = sender",
            "        self.expires_in = expires_in",
            "        self._registry = dict()",
            "",
            "    def validate(self, signature, timestamp, nonce):",
            "        if not self.token:",
            "            raise WeixinMsgError(\"weixin token is missing\")",
            "",
            "        if self.expires_in:",
            "            try:",
            "                timestamp = int(timestamp)",
            "            except ValueError:",
            "                return False",
            "            delta = time.time() - timestamp",
            "            if delta < 0 or delta > self.expires_in:",
            "                return False",
            "        values = [self.token, str(timestamp), str(nonce)]",
            "        s = ''.join(sorted(values))",
            "        hsh = hashlib.sha1(s.encode(\"utf-8\")).hexdigest()",
            "        return signature == hsh",
            "",
            "    def parse(self, content):",
            "        raw = {}",
            "        root = etree.fromstring(content,",
            "                                parser=etree.XMLParser(resolve_entities=False))",
            "        for child in root:",
            "            raw[child.tag] = child.text",
            "",
            "        formatted = self.format(raw)",
            "        msg_type = formatted['type']",
            "        msg_parser = getattr(self, 'parse_{0}'.format(msg_type), None)",
            "        if callable(msg_parser):",
            "            parsed = msg_parser(raw)",
            "        else:",
            "            parsed = self.parse_invalid_type(raw)",
            "",
            "        formatted.update(parsed)",
            "        return formatted",
            "",
            "    def format(self, kwargs):",
            "        timestamp = int(kwargs['CreateTime'])",
            "        return {",
            "            'id': kwargs.get('MsgId'),",
            "            'timestamp': timestamp,",
            "            'receiver': kwargs['ToUserName'],",
            "            'sender': kwargs['FromUserName'],",
            "            'type': kwargs['MsgType'],",
            "            'time': datetime.fromtimestamp(timestamp),",
            "        }",
            "",
            "    def parse_text(self, raw):",
            "        return {'content': raw['Content']}",
            "",
            "    def parse_image(self, raw):",
            "        return {'picurl': raw['PicUrl']}",
            "",
            "    def parse_location(self, raw):",
            "        return {",
            "            'location_x': raw['Location_X'],",
            "            'location_y': raw['Location_Y'],",
            "            'scale': int(raw.get('Scale', 0)),",
            "            'label': raw['Label'],",
            "        }",
            "",
            "    def parse_link(self, raw):",
            "        return {",
            "            'title': raw['Title'],",
            "            'description': raw['Description'],",
            "            'url': raw['url'],",
            "        }",
            "",
            "    def parse_voice(self, raw):",
            "        return {",
            "            'media_id': raw['MediaId'],",
            "            'format': raw['Format'],",
            "            'recognition': raw['Recognition'],",
            "        }",
            "",
            "    def parse_video(self, raw):",
            "        return {",
            "            'media_id': raw['MediaId'],",
            "            'thumb_media_id': raw['ThumbMediaId'],",
            "        }",
            "",
            "    def parse_shortvideo(self, raw):",
            "        return {",
            "            'media_id': raw['MediaId'],",
            "            'thumb_media_id': raw['ThumbMediaId'],",
            "        }",
            "",
            "    def parse_event(self, raw):",
            "        return {",
            "            'event': raw.get('Event'),",
            "            'event_key': raw.get('EventKey'),",
            "            'ticket': raw.get('Ticket'),",
            "            'latitude': raw.get('Latitude'),",
            "            'longitude': raw.get('Longitude'),",
            "            'precision': raw.get('Precision'),",
            "            'status': raw.get('status')",
            "        }",
            "",
            "    def parse_invalid_type(self, raw):",
            "        return {}",
            "",
            "    def reply(self, username=None, type='text', sender=None, **kwargs):",
            "        if not username:",
            "            raise RuntimeError(\"username is missing\")",
            "        sender = sender or self.sender",
            "        if not sender:",
            "            raise RuntimeError('WEIXIN_SENDER or sender argument is missing')",
            "",
            "        if type == 'text':",
            "            content = kwargs.get('content', '')",
            "            return text_reply(username, sender, content)",
            "",
            "        if type == 'music':",
            "            values = {}",
            "            for k in ('title', 'description', 'music_url', 'hq_music_url'):",
            "                values[k] = kwargs[k]",
            "            return music_reply(username, sender, **values)",
            "",
            "        if type == 'news':",
            "            items = kwargs['articles']",
            "            return news_reply(username, sender, *items)",
            "",
            "        if type == 'customer_service':",
            "            service_account = kwargs['service_account']",
            "            return transfer_customer_service_reply(username, sender,",
            "                                                   service_account)",
            "",
            "        if type == 'image':",
            "            media_id = kwargs.get('media_id')",
            "            return image_reply(username, sender, media_id)",
            "",
            "        if type == 'voice':",
            "            media_id = kwargs.get('media_id')",
            "            return voice_reply(username, sender, media_id)",
            "",
            "        if type == 'video':",
            "            values = {}",
            "            for k in ('media_id', 'title', 'description'):",
            "                values[k] = kwargs[k]",
            "            return video_reply(username, sender, **values)",
            "",
            "    def register(self, type, key=None, func=None):",
            "        if func:",
            "            key = '*' if not key else key",
            "            self._registry.setdefault(type, dict())[key] = func",
            "            return func",
            "        return self.__call__(type, key)",
            "",
            "    def __call__(self, type, key):",
            "        def wrapper(func):",
            "            self.register(type, key, func)",
            "            return func",
            "        return wrapper",
            "",
            "    @property",
            "    def all(self):",
            "        return self.register('*')",
            "",
            "    def text(self, key='*'):",
            "        return self.register('text', key)",
            "",
            "    def __getattr__(self, key):",
            "        key = key.lower()",
            "        if key in ['image', 'video', 'voice', 'shortvideo', 'location', 'link', 'event']:",
            "            return self.register(key)",
            "        if key in ['subscribe', 'unsubscribe', 'location', 'click', 'view', 'scan', \\",
            "                   'scancode_push', 'scancode_waitmsg', 'pic_sysphoto', \\",
            "                   'pic_photo_or_album', 'pic_weixin', 'location_select', \\",
            "                   'qualification_verify_success', 'qualification_verify_fail', 'naming_verify_success', \\",
            "                   'naming_verify_fail', 'annual_renew', 'verify_expired', \\",
            "                   'card_pass_check', 'user_get_card', 'user_del_card', 'user_consume_card', \\",
            "                   'user_pay_from_pay_cell', 'user_view_card', 'user_enter_session_from_card', \\",
            "                   'card_sku_remind']:",
            "            return self.register('event', key)",
            "        raise AttributeError('invalid attribute \"' + key + '\"')",
            "",
            "    def django_view_func(self):",
            "",
            "        def run(request):",
            "            if HttpResponse is None:",
            "                raise RuntimeError('django_view_func need Django be installed')",
            "            signature = request.GET.get('signature')",
            "",
            "            timestamp = request.GET.get('timestamp')",
            "            nonce = request.GET.get('nonce')",
            "            if not self.validate(signature, timestamp, nonce):",
            "                return HttpResponseForbidden('signature failed')",
            "            if request.method == 'GET':",
            "                echostr = request.args.get('echostr', '')",
            "                return HttpResponse(echostr)",
            "            elif request.method == \"POST\":",
            "                try:",
            "                    ret = self.parse(request.body)",
            "                except ValueError:",
            "                    return HttpResponseForbidden('invalid')",
            "",
            "                func = None",
            "                type = ret['type']",
            "                _registry = self._registry.get(type, dict())",
            "                if type == 'text':",
            "                    if ret['content'] in _registry:",
            "                        func = _registry[ret['content']]",
            "                elif type == 'event':",
            "                    if ret['event'].lower() in _registry:",
            "                        func = _registry[ret['event'].lower()]",
            "",
            "                if func is None and '*' in _registry:",
            "                    func = _registry['*']",
            "                if func is None and '*' in self._registry:",
            "                    func = self._registry.get('*', dict()).get('*')",
            "",
            "                text = ''",
            "                if func is None:",
            "                    text = 'failed'",
            "",
            "                if callable(func):",
            "                    text = func(**ret)",
            "",
            "                content = ''",
            "                if isinstance(text, basestring):",
            "                    if text:",
            "                        content = self.reply(",
            "                            username=ret['sender'],",
            "                            sender=ret['receiver'],",
            "                            content=text,",
            "                        )",
            "                elif isinstance(text, dict):",
            "                    text.setdefault('username', ret['sender'])",
            "                    text.setdefault('sender', ret['receiver'])",
            "                    content = self.reply(**text)",
            "",
            "                return HttpResponse(content, content_type='text/xml; charset=utf-8')",
            "            return HttpResponseNotAllowed(['GET', 'POST'])",
            "        return run",
            "",
            "    def view_func(self):",
            "        if request is None:",
            "            raise RuntimeError('view_func need Flask be installed')",
            "",
            "        signature = request.args.get('signature')",
            "        timestamp = request.args.get('timestamp')",
            "        nonce = request.args.get('nonce')",
            "        if not self.validate(signature, timestamp, nonce):",
            "            return 'signature failed', 400",
            "        if request.method == 'GET':",
            "            echostr = request.args.get('echostr', '')",
            "            return echostr",
            "",
            "        try:",
            "            ret = self.parse(request.data)",
            "        except ValueError:",
            "            return 'invalid', 400",
            "",
            "        func = None",
            "        type = ret['type']",
            "        _registry = self._registry.get(type, dict())",
            "        if type == 'text':",
            "            if ret['content'] in _registry:",
            "                func = _registry[ret['content']]",
            "        elif type == 'event':",
            "            if ret['event'].lower() in _registry:",
            "                func = _registry[ret['event'].lower()]",
            "",
            "        if func is None and '*' in _registry:",
            "            func = _registry['*']",
            "        if func is None and '*' in self._registry:",
            "            func = self._registry.get('*', dict()).get('*')",
            "",
            "        text = ''",
            "        if func is None:",
            "            text = 'failed'",
            "",
            "        if callable(func):",
            "            text = func(**ret)",
            "",
            "        content = ''",
            "        if isinstance(text, basestring):",
            "            if text:",
            "                content = self.reply(",
            "                    username=ret['sender'],",
            "                    sender=ret['receiver'],",
            "                    content=text,",
            "                )",
            "        elif isinstance(text, dict):",
            "            text.setdefault('username', ret['sender'])",
            "            text.setdefault('sender', ret['receiver'])",
            "            content = self.reply(**text)",
            "",
            "        return Response(content, content_type='text/xml; charset=utf-8')",
            "",
            "    view_func.methods = ['GET', 'POST']",
            "",
            "",
            "def text_reply(username, sender, content):",
            "    shared = _shared_reply(username, sender, 'text')",
            "    template = '<xml>%s<Content><![CDATA[%s]]></Content></xml>'",
            "    return template % (shared, content)",
            "",
            "",
            "def music_reply(username, sender, **kwargs):",
            "    kwargs['shared'] = _shared_reply(username, sender, 'music')",
            "",
            "    template = (",
            "        '<xml>'",
            "        '%(shared)s'",
            "        '<Music>'",
            "        '<Title><![CDATA[%(title)s]]></Title>'",
            "        '<Description><![CDATA[%(description)s]]></Description>'",
            "        '<MusicUrl><![CDATA[%(music_url)s]]></MusicUrl>'",
            "        '<HQMusicUrl><![CDATA[%(hq_music_url)s]]></HQMusicUrl>'",
            "        '</Music>'",
            "        '</xml>'",
            "    )",
            "    return template % kwargs",
            "",
            "",
            "def news_reply(username, sender, *items):",
            "    item_template = (",
            "        '<item>'",
            "        '<Title><![CDATA[%(title)s]]></Title>'",
            "        '<Description><![CDATA[%(description)s]]></Description>'",
            "        '<PicUrl><![CDATA[%(picurl)s]]></PicUrl>'",
            "        '<Url><![CDATA[%(url)s]]></Url>'",
            "        '</item>'",
            "    )",
            "    articles = [item_template % o for o in items]",
            "",
            "    template = (",
            "        '<xml>'",
            "        '%(shared)s'",
            "        '<ArticleCount>%(count)d</ArticleCount>'",
            "        '<Articles>%(articles)s</Articles>'",
            "        '</xml>'",
            "    )",
            "    dct = {",
            "        'shared': _shared_reply(username, sender, 'news'),",
            "        'count': len(items),",
            "        'articles': ''.join(articles)",
            "    }",
            "    return template % dct",
            "",
            "",
            "def transfer_customer_service_reply(username, sender, service_account):",
            "    template = (",
            "        '<xml>%(shared)s'",
            "        '%(transfer_info)s</xml>')",
            "    transfer_info = ''",
            "    if service_account:",
            "        transfer_info = (",
            "            '<TransInfo>'",
            "            '<KfAccount>![CDATA[%s]]</KfAccount>'",
            "            '</TransInfo>') % service_account",
            "",
            "    dct = {",
            "        'shared': _shared_reply(username, sender,",
            "                                type='transfer_customer_service'),",
            "        'transfer_info': transfer_info",
            "    }",
            "    return template % dct",
            "",
            "",
            "def image_reply(username, sender, media_id):",
            "    shared = _shared_reply(username, sender, 'image')",
            "    template = '<xml>%s<Image><MediaId><![CDATA[%s]]></MediaId></Image></xml>'",
            "    return template % (shared, media_id)",
            "",
            "",
            "def voice_reply(username, sender, media_id):",
            "    shared = _shared_reply(username, sender, 'voice')",
            "    template = '<xml>%s<Voice><MediaId><![CDATA[%s]]></MediaId></Voice></xml>'",
            "    return template % (shared, media_id)",
            "",
            "",
            "def video_reply(username, sender, **kwargs):",
            "    kwargs['shared'] = _shared_reply(username, sender, 'video')",
            "",
            "    template = (",
            "        '<xml>'",
            "        '%(shared)s'",
            "        '<Video>'",
            "        '<MediaId><![CDATA[%(media_id)s]]></MediaId>'",
            "        '<Title><![CDATA[%(title)s]]></Title>'",
            "        '<Description><![CDATA[%(description)s]]></Description>'",
            "        '</Video>'",
            "        '</xml>'",
            "    )",
            "    return template % kwargs",
            "",
            "",
            "def _shared_reply(username, sender, type):",
            "    dct = {",
            "        'username': username,",
            "        'sender': sender,",
            "        'type': type,",
            "        'timestamp': int(time.time()),",
            "    }",
            "    template = (",
            "        '<ToUserName><![CDATA[%(username)s]]></ToUserName>'",
            "        '<FromUserName><![CDATA[%(sender)s]]></FromUserName>'",
            "        '<CreateTime>%(timestamp)d</CreateTime>'",
            "        '<MsgType><![CDATA[%(type)s]]></MsgType>'",
            "    )",
            "    return template % dct"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "67": [
                "WeixinMsg",
                "parse"
            ]
        },
        "addLocation": []
    },
    "weixin/pay.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 79,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "     def to_dict(self, content):"
            },
            "2": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         raw = {}"
            },
            "3": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        root = etree.fromstring(content.encode(\"utf-8\"))"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+        root = etree.fromstring(content.encode(\"utf-8\"),"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+                                parser=etree.XMLParser(resolve_entities=False))"
            },
            "6": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         for child in root:"
            },
            "7": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "             raw[child.tag] = child.text"
            },
            "8": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "         return raw"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "",
            "from __future__ import unicode_literals",
            "",
            "import time",
            "import string",
            "import random",
            "import hashlib",
            "import requests",
            "",
            "from .base import Map, WeixinError",
            "",
            "try:",
            "    from flask import request",
            "except Exception:",
            "    request = None",
            "",
            "try:",
            "    from lxml import etree",
            "except ImportError:",
            "    from xml.etree import cElementTree as etree",
            "except ImportError:",
            "    from xml.etree import ElementTree as etree",
            "",
            "",
            "__all__ = (\"WeixinPayError\", \"WeixinPay\")",
            "",
            "",
            "FAIL = \"FAIL\"",
            "SUCCESS = \"SUCCESS\"",
            "",
            "",
            "class WeixinPayError(WeixinError):",
            "",
            "    def __init__(self, msg):",
            "        super(WeixinPayError, self).__init__(msg)",
            "",
            "",
            "class WeixinPay(object):",
            "",
            "    def __init__(self, app_id, mch_id, mch_key, notify_url, key=None, cert=None):",
            "        self.app_id = app_id",
            "        self.mch_id = mch_id",
            "        self.mch_key = mch_key",
            "        self.notify_url = notify_url",
            "        self.key = key",
            "        self.cert = cert",
            "        self.sess = requests.Session()",
            "",
            "    @property",
            "    def remote_addr(self):",
            "        if request is not None:",
            "            return request.remote_addr",
            "        return \"\"",
            "",
            "    @property",
            "    def nonce_str(self):",
            "        char = string.ascii_letters + string.digits",
            "        return \"\".join(random.choice(char) for _ in range(32))",
            "",
            "    def sign(self, raw):",
            "        raw = [(k, str(raw[k]) if isinstance(raw[k], int) else raw[k])",
            "               for k in sorted(raw.keys())]",
            "        s = \"&\".join(\"=\".join(kv) for kv in raw if kv[1])",
            "        s += \"&key={0}\".format(self.mch_key)",
            "        return hashlib.md5(s.encode(\"utf-8\")).hexdigest().upper()",
            "",
            "    def check(self, data):",
            "        sign = data.pop(\"sign\")",
            "        return sign == self.sign(data)",
            "",
            "    def to_xml(self, raw):",
            "        s = \"\"",
            "        for k, v in raw.items():",
            "            s += \"<{0}>{1}</{0}>\".format(k, v)",
            "        s = \"<xml>{0}</xml>\".format(s)",
            "        return s.encode(\"utf-8\")",
            "",
            "    def to_dict(self, content):",
            "        raw = {}",
            "        root = etree.fromstring(content.encode(\"utf-8\"))",
            "        for child in root:",
            "            raw[child.tag] = child.text",
            "        return raw",
            "",
            "    def _fetch(self, url, data, use_cert=False):",
            "        data.setdefault(\"appid\", self.app_id)",
            "        data.setdefault(\"mch_id\", self.mch_id)",
            "        data.setdefault(\"nonce_str\", self.nonce_str)",
            "        data.setdefault(\"sign\", self.sign(data))",
            "",
            "        if use_cert:",
            "            resp = self.sess.post(url, data=self.to_xml(data), cert=(self.cert, self.key))",
            "        else:",
            "            resp = self.sess.post(url, data=self.to_xml(data))",
            "        content = resp.content.decode(\"utf-8\")",
            "        if \"return_code\" in content:",
            "            data = Map(self.to_dict(content))",
            "            if data.return_code == FAIL:",
            "                raise WeixinPayError(data.return_msg)",
            "            if \"result_code\" in content and data.result_code == FAIL:",
            "                raise WeixinPayError(data.err_code_des)",
            "            return data",
            "        return content",
            "",
            "    def reply(self, msg, ok=True):",
            "        code = SUCCESS if ok else FAIL",
            "        return self.to_xml(dict(return_code=code, return_msg=msg))",
            "",
            "    def unified_order(self, **data):",
            "        \"\"\"",
            "        \u7edf\u4e00\u4e0b\u5355",
            "        out_trade_no\u3001body\u3001total_fee\u3001trade_type\u5fc5\u586b",
            "        app_id, mchid, nonce_str\u81ea\u52a8\u586b\u5199",
            "        spbill_create_ip \u5728flask\u6846\u67b6\u4e0b\u53ef\u4ee5\u81ea\u52a8\u586b\u5199, \u975eflask\u6846\u67b6\u9700\u8981\u4e3b\u52a8\u4f20\u5165\u6b64\u53c2\u6570",
            "        \"\"\"",
            "        url = \"https://api.mch.weixin.qq.com/pay/unifiedorder\"",
            "",
            "        # \u5fc5\u586b\u53c2\u6570",
            "        if \"out_trade_no\" not in data:",
            "            raise WeixinPayError(\"\u7f3a\u5c11\u7edf\u4e00\u652f\u4ed8\u63a5\u53e3\u5fc5\u586b\u53c2\u6570out_trade_no\")",
            "        if \"body\" not in data:",
            "            raise WeixinPayError(\"\u7f3a\u5c11\u7edf\u4e00\u652f\u4ed8\u63a5\u53e3\u5fc5\u586b\u53c2\u6570body\")",
            "        if \"total_fee\" not in data:",
            "            raise WeixinPayError(\"\u7f3a\u5c11\u7edf\u4e00\u652f\u4ed8\u63a5\u53e3\u5fc5\u586b\u53c2\u6570total_fee\")",
            "        if \"trade_type\" not in data:",
            "            raise WeixinPayError(\"\u7f3a\u5c11\u7edf\u4e00\u652f\u4ed8\u63a5\u53e3\u5fc5\u586b\u53c2\u6570trade_type\")",
            "",
            "        # \u5173\u8054\u53c2\u6570",
            "        if data[\"trade_type\"] == \"JSAPI\" and \"openid\" not in data:",
            "            raise WeixinPayError(\"trade_type\u4e3aJSAPI\u65f6\uff0copenid\u4e3a\u5fc5\u586b\u53c2\u6570\")",
            "        if data[\"trade_type\"] == \"NATIVE\" and \"product_id\" not in data:",
            "            raise WeixinPayError(\"trade_type\u4e3aNATIVE\u65f6\uff0cproduct_id\u4e3a\u5fc5\u586b\u53c2\u6570\")",
            "        data.setdefault(\"notify_url\", self.notify_url)",
            "        if \"spbill_create_ip\" not in data:",
            "            data.setdefault(\"spbill_create_ip\", self.remote_addr)",
            "",
            "        raw = self._fetch(url, data)",
            "        return raw",
            "",
            "    def jsapi(self, **kwargs):",
            "        \"\"\"",
            "        \u751f\u6210\u7ed9JavaScript\u8c03\u7528\u7684\u6570\u636e",
            "        \u8be6\u7ec6\u89c4\u5219\u53c2\u8003 https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_7&index=6",
            "        \"\"\"",
            "        kwargs.setdefault(\"trade_type\", \"JSAPI\")",
            "        raw = self.unified_order(**kwargs)",
            "        package = \"prepay_id={0}\".format(raw[\"prepay_id\"])",
            "        timestamp = str(int(time.time()))",
            "        nonce_str = self.nonce_str",
            "        raw = dict(appId=self.app_id, timeStamp=timestamp,",
            "                   nonceStr=nonce_str, package=package, signType=\"MD5\")",
            "        sign = self.sign(raw)",
            "        return dict(package=package, appId=self.app_id, signType=\"MD5\",",
            "                    timeStamp=timestamp, nonceStr=nonce_str, sign=sign)",
            "",
            "    def order_query(self, **data):",
            "        \"\"\"",
            "        \u8ba2\u5355\u67e5\u8be2",
            "        out_trade_no, transaction_id\u81f3\u5c11\u586b\u4e00\u4e2a",
            "        appid, mchid, nonce_str\u4e0d\u9700\u8981\u586b\u5165",
            "        \"\"\"",
            "        url = \"https://api.mch.weixin.qq.com/pay/orderquery\"",
            "",
            "        if \"out_trade_no\" not in data and \"transaction_id\" not in data:",
            "            raise WeixinPayError(\"\u8ba2\u5355\u67e5\u8be2\u63a5\u53e3\u4e2d\uff0cout_trade_no\u3001transaction_id\u81f3\u5c11\u586b\u4e00\u4e2a\")",
            "",
            "        return self._fetch(url, data)",
            "",
            "    def close_order(self, out_trade_no, **data):",
            "        \"\"\"",
            "        \u5173\u95ed\u8ba2\u5355",
            "        out_trade_no\u5fc5\u586b",
            "        appid, mchid, nonce_str\u4e0d\u9700\u8981\u586b\u5165",
            "        \"\"\"",
            "        url = \"https://api.mch.weixin.qq.com/pay/closeorder\"",
            "",
            "        data.setdefault(\"out_trade_no\", out_trade_no)",
            "",
            "        return self._fetch(url, data)",
            "",
            "    def refund(self, **data):",
            "        \"\"\"",
            "        \u7533\u8bf7\u9000\u6b3e",
            "        out_trade_no\u3001transaction_id\u81f3\u5c11\u586b\u4e00\u4e2a\u4e14",
            "        out_refund_no\u3001total_fee\u3001refund_fee\u3001op_user_id\u4e3a\u5fc5\u586b\u53c2\u6570",
            "        appid\u3001mchid\u3001nonce_str\u4e0d\u9700\u8981\u586b\u5165",
            "        \"\"\"",
            "        if not self.key or not self.cert:",
            "            raise WeixinError(\"\u9000\u6b3e\u7533\u8bf7\u63a5\u53e3\u9700\u8981\u53cc\u5411\u8bc1\u4e66\")",
            "        url = \"https://api.mch.weixin.qq.com/secapi/pay/refund\"",
            "        if \"out_trade_no\" not in data and \"transaction_id\" not in data:",
            "            raise WeixinPayError(\"\u9000\u6b3e\u7533\u8bf7\u63a5\u53e3\u4e2d\uff0cout_trade_no\u3001transaction_id\u81f3\u5c11\u586b\u4e00\u4e2a\")",
            "        if \"out_refund_no\" not in data:",
            "            raise WeixinPayError(\"\u9000\u6b3e\u7533\u8bf7\u63a5\u53e3\u4e2d\uff0c\u7f3a\u5c11\u5fc5\u586b\u53c2\u6570out_refund_no\");",
            "        if \"total_fee\" not in data:",
            "            raise WeixinPayError(\"\u9000\u6b3e\u7533\u8bf7\u63a5\u53e3\u4e2d\uff0c\u7f3a\u5c11\u5fc5\u586b\u53c2\u6570total_fee\");",
            "        if \"refund_fee\" not in data:",
            "            raise WeixinPayError(\"\u9000\u6b3e\u7533\u8bf7\u63a5\u53e3\u4e2d\uff0c\u7f3a\u5c11\u5fc5\u586b\u53c2\u6570refund_fee\");",
            "",
            "        return self._fetch(url, data, True)",
            "",
            "    def refund_query(self, **data):",
            "        \"\"\"",
            "        \u67e5\u8be2\u9000\u6b3e",
            "        \u63d0\u4ea4\u9000\u6b3e\u7533\u8bf7\u540e\uff0c\u901a\u8fc7\u8c03\u7528\u8be5\u63a5\u53e3\u67e5\u8be2\u9000\u6b3e\u72b6\u6001\u3002\u9000\u6b3e\u6709\u4e00\u5b9a\u5ef6\u65f6\uff0c",
            "        \u7528\u96f6\u94b1\u652f\u4ed8\u7684\u9000\u6b3e20\u5206\u949f\u5185\u5230\u8d26\uff0c\u94f6\u884c\u5361\u652f\u4ed8\u7684\u9000\u6b3e3\u4e2a\u5de5\u4f5c\u65e5\u540e\u91cd\u65b0\u67e5\u8be2\u9000\u6b3e\u72b6\u6001\u3002",
            "",
            "        out_refund_no\u3001out_trade_no\u3001transaction_id\u3001refund_id\u56db\u4e2a\u53c2\u6570\u5fc5\u586b\u4e00\u4e2a",
            "        appid\u3001mchid\u3001nonce_str\u4e0d\u9700\u8981\u586b\u5165",
            "        \"\"\"",
            "        url = \"https://api.mch.weixin.qq.com/pay/refundquery\"",
            "        if \"out_refund_no\" not in data and \"out_trade_no\" not in data \\",
            "                and \"transaction_id\" not in data and \"refund_id\" not in data:",
            "            raise WeixinPayError(\"\u9000\u6b3e\u67e5\u8be2\u63a5\u53e3\u4e2d\uff0cout_refund_no\u3001out_trade_no\u3001transaction_id\u3001refund_id\u56db\u4e2a\u53c2\u6570\u5fc5\u586b\u4e00\u4e2a\")",
            "",
            "        return self._fetch(url, data)",
            "",
            "    def download_bill(self, bill_date, bill_type=\"ALL\", **data):",
            "        \"\"\"",
            "        \u4e0b\u8f7d\u5bf9\u8d26\u5355",
            "        bill_date\u3001bill_type\u4e3a\u5fc5\u586b\u53c2\u6570",
            "        appid\u3001mchid\u3001nonce_str\u4e0d\u9700\u8981\u586b\u5165",
            "        \"\"\"",
            "        url = \"https://api.mch.weixin.qq.com/pay/downloadbill\"",
            "        data.setdefault(\"bill_date\", bill_date)",
            "        data.setdefault(\"bill_type\", bill_type)",
            "",
            "        if \"bill_date\" not in data:",
            "            raise WeixinPayError(\"\u5bf9\u8d26\u5355\u63a5\u53e3\u4e2d\uff0c\u7f3a\u5c11\u5fc5\u586b\u53c2\u6570bill_date\")",
            "",
            "        return self._fetch(url, data)"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "",
            "",
            "from __future__ import unicode_literals",
            "",
            "import time",
            "import string",
            "import random",
            "import hashlib",
            "import requests",
            "",
            "from .base import Map, WeixinError",
            "",
            "try:",
            "    from flask import request",
            "except Exception:",
            "    request = None",
            "",
            "try:",
            "    from lxml import etree",
            "except ImportError:",
            "    from xml.etree import cElementTree as etree",
            "except ImportError:",
            "    from xml.etree import ElementTree as etree",
            "",
            "",
            "__all__ = (\"WeixinPayError\", \"WeixinPay\")",
            "",
            "",
            "FAIL = \"FAIL\"",
            "SUCCESS = \"SUCCESS\"",
            "",
            "",
            "class WeixinPayError(WeixinError):",
            "",
            "    def __init__(self, msg):",
            "        super(WeixinPayError, self).__init__(msg)",
            "",
            "",
            "class WeixinPay(object):",
            "",
            "    def __init__(self, app_id, mch_id, mch_key, notify_url, key=None, cert=None):",
            "        self.app_id = app_id",
            "        self.mch_id = mch_id",
            "        self.mch_key = mch_key",
            "        self.notify_url = notify_url",
            "        self.key = key",
            "        self.cert = cert",
            "        self.sess = requests.Session()",
            "",
            "    @property",
            "    def remote_addr(self):",
            "        if request is not None:",
            "            return request.remote_addr",
            "        return \"\"",
            "",
            "    @property",
            "    def nonce_str(self):",
            "        char = string.ascii_letters + string.digits",
            "        return \"\".join(random.choice(char) for _ in range(32))",
            "",
            "    def sign(self, raw):",
            "        raw = [(k, str(raw[k]) if isinstance(raw[k], int) else raw[k])",
            "               for k in sorted(raw.keys())]",
            "        s = \"&\".join(\"=\".join(kv) for kv in raw if kv[1])",
            "        s += \"&key={0}\".format(self.mch_key)",
            "        return hashlib.md5(s.encode(\"utf-8\")).hexdigest().upper()",
            "",
            "    def check(self, data):",
            "        sign = data.pop(\"sign\")",
            "        return sign == self.sign(data)",
            "",
            "    def to_xml(self, raw):",
            "        s = \"\"",
            "        for k, v in raw.items():",
            "            s += \"<{0}>{1}</{0}>\".format(k, v)",
            "        s = \"<xml>{0}</xml>\".format(s)",
            "        return s.encode(\"utf-8\")",
            "",
            "    def to_dict(self, content):",
            "        raw = {}",
            "        root = etree.fromstring(content.encode(\"utf-8\"),",
            "                                parser=etree.XMLParser(resolve_entities=False))",
            "        for child in root:",
            "            raw[child.tag] = child.text",
            "        return raw",
            "",
            "    def _fetch(self, url, data, use_cert=False):",
            "        data.setdefault(\"appid\", self.app_id)",
            "        data.setdefault(\"mch_id\", self.mch_id)",
            "        data.setdefault(\"nonce_str\", self.nonce_str)",
            "        data.setdefault(\"sign\", self.sign(data))",
            "",
            "        if use_cert:",
            "            resp = self.sess.post(url, data=self.to_xml(data), cert=(self.cert, self.key))",
            "        else:",
            "            resp = self.sess.post(url, data=self.to_xml(data))",
            "        content = resp.content.decode(\"utf-8\")",
            "        if \"return_code\" in content:",
            "            data = Map(self.to_dict(content))",
            "            if data.return_code == FAIL:",
            "                raise WeixinPayError(data.return_msg)",
            "            if \"result_code\" in content and data.result_code == FAIL:",
            "                raise WeixinPayError(data.err_code_des)",
            "            return data",
            "        return content",
            "",
            "    def reply(self, msg, ok=True):",
            "        code = SUCCESS if ok else FAIL",
            "        return self.to_xml(dict(return_code=code, return_msg=msg))",
            "",
            "    def unified_order(self, **data):",
            "        \"\"\"",
            "        \u7edf\u4e00\u4e0b\u5355",
            "        out_trade_no\u3001body\u3001total_fee\u3001trade_type\u5fc5\u586b",
            "        app_id, mchid, nonce_str\u81ea\u52a8\u586b\u5199",
            "        spbill_create_ip \u5728flask\u6846\u67b6\u4e0b\u53ef\u4ee5\u81ea\u52a8\u586b\u5199, \u975eflask\u6846\u67b6\u9700\u8981\u4e3b\u52a8\u4f20\u5165\u6b64\u53c2\u6570",
            "        \"\"\"",
            "        url = \"https://api.mch.weixin.qq.com/pay/unifiedorder\"",
            "",
            "        # \u5fc5\u586b\u53c2\u6570",
            "        if \"out_trade_no\" not in data:",
            "            raise WeixinPayError(\"\u7f3a\u5c11\u7edf\u4e00\u652f\u4ed8\u63a5\u53e3\u5fc5\u586b\u53c2\u6570out_trade_no\")",
            "        if \"body\" not in data:",
            "            raise WeixinPayError(\"\u7f3a\u5c11\u7edf\u4e00\u652f\u4ed8\u63a5\u53e3\u5fc5\u586b\u53c2\u6570body\")",
            "        if \"total_fee\" not in data:",
            "            raise WeixinPayError(\"\u7f3a\u5c11\u7edf\u4e00\u652f\u4ed8\u63a5\u53e3\u5fc5\u586b\u53c2\u6570total_fee\")",
            "        if \"trade_type\" not in data:",
            "            raise WeixinPayError(\"\u7f3a\u5c11\u7edf\u4e00\u652f\u4ed8\u63a5\u53e3\u5fc5\u586b\u53c2\u6570trade_type\")",
            "",
            "        # \u5173\u8054\u53c2\u6570",
            "        if data[\"trade_type\"] == \"JSAPI\" and \"openid\" not in data:",
            "            raise WeixinPayError(\"trade_type\u4e3aJSAPI\u65f6\uff0copenid\u4e3a\u5fc5\u586b\u53c2\u6570\")",
            "        if data[\"trade_type\"] == \"NATIVE\" and \"product_id\" not in data:",
            "            raise WeixinPayError(\"trade_type\u4e3aNATIVE\u65f6\uff0cproduct_id\u4e3a\u5fc5\u586b\u53c2\u6570\")",
            "        data.setdefault(\"notify_url\", self.notify_url)",
            "        if \"spbill_create_ip\" not in data:",
            "            data.setdefault(\"spbill_create_ip\", self.remote_addr)",
            "",
            "        raw = self._fetch(url, data)",
            "        return raw",
            "",
            "    def jsapi(self, **kwargs):",
            "        \"\"\"",
            "        \u751f\u6210\u7ed9JavaScript\u8c03\u7528\u7684\u6570\u636e",
            "        \u8be6\u7ec6\u89c4\u5219\u53c2\u8003 https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_7&index=6",
            "        \"\"\"",
            "        kwargs.setdefault(\"trade_type\", \"JSAPI\")",
            "        raw = self.unified_order(**kwargs)",
            "        package = \"prepay_id={0}\".format(raw[\"prepay_id\"])",
            "        timestamp = str(int(time.time()))",
            "        nonce_str = self.nonce_str",
            "        raw = dict(appId=self.app_id, timeStamp=timestamp,",
            "                   nonceStr=nonce_str, package=package, signType=\"MD5\")",
            "        sign = self.sign(raw)",
            "        return dict(package=package, appId=self.app_id, signType=\"MD5\",",
            "                    timeStamp=timestamp, nonceStr=nonce_str, sign=sign)",
            "",
            "    def order_query(self, **data):",
            "        \"\"\"",
            "        \u8ba2\u5355\u67e5\u8be2",
            "        out_trade_no, transaction_id\u81f3\u5c11\u586b\u4e00\u4e2a",
            "        appid, mchid, nonce_str\u4e0d\u9700\u8981\u586b\u5165",
            "        \"\"\"",
            "        url = \"https://api.mch.weixin.qq.com/pay/orderquery\"",
            "",
            "        if \"out_trade_no\" not in data and \"transaction_id\" not in data:",
            "            raise WeixinPayError(\"\u8ba2\u5355\u67e5\u8be2\u63a5\u53e3\u4e2d\uff0cout_trade_no\u3001transaction_id\u81f3\u5c11\u586b\u4e00\u4e2a\")",
            "",
            "        return self._fetch(url, data)",
            "",
            "    def close_order(self, out_trade_no, **data):",
            "        \"\"\"",
            "        \u5173\u95ed\u8ba2\u5355",
            "        out_trade_no\u5fc5\u586b",
            "        appid, mchid, nonce_str\u4e0d\u9700\u8981\u586b\u5165",
            "        \"\"\"",
            "        url = \"https://api.mch.weixin.qq.com/pay/closeorder\"",
            "",
            "        data.setdefault(\"out_trade_no\", out_trade_no)",
            "",
            "        return self._fetch(url, data)",
            "",
            "    def refund(self, **data):",
            "        \"\"\"",
            "        \u7533\u8bf7\u9000\u6b3e",
            "        out_trade_no\u3001transaction_id\u81f3\u5c11\u586b\u4e00\u4e2a\u4e14",
            "        out_refund_no\u3001total_fee\u3001refund_fee\u3001op_user_id\u4e3a\u5fc5\u586b\u53c2\u6570",
            "        appid\u3001mchid\u3001nonce_str\u4e0d\u9700\u8981\u586b\u5165",
            "        \"\"\"",
            "        if not self.key or not self.cert:",
            "            raise WeixinError(\"\u9000\u6b3e\u7533\u8bf7\u63a5\u53e3\u9700\u8981\u53cc\u5411\u8bc1\u4e66\")",
            "        url = \"https://api.mch.weixin.qq.com/secapi/pay/refund\"",
            "        if \"out_trade_no\" not in data and \"transaction_id\" not in data:",
            "            raise WeixinPayError(\"\u9000\u6b3e\u7533\u8bf7\u63a5\u53e3\u4e2d\uff0cout_trade_no\u3001transaction_id\u81f3\u5c11\u586b\u4e00\u4e2a\")",
            "        if \"out_refund_no\" not in data:",
            "            raise WeixinPayError(\"\u9000\u6b3e\u7533\u8bf7\u63a5\u53e3\u4e2d\uff0c\u7f3a\u5c11\u5fc5\u586b\u53c2\u6570out_refund_no\");",
            "        if \"total_fee\" not in data:",
            "            raise WeixinPayError(\"\u9000\u6b3e\u7533\u8bf7\u63a5\u53e3\u4e2d\uff0c\u7f3a\u5c11\u5fc5\u586b\u53c2\u6570total_fee\");",
            "        if \"refund_fee\" not in data:",
            "            raise WeixinPayError(\"\u9000\u6b3e\u7533\u8bf7\u63a5\u53e3\u4e2d\uff0c\u7f3a\u5c11\u5fc5\u586b\u53c2\u6570refund_fee\");",
            "",
            "        return self._fetch(url, data, True)",
            "",
            "    def refund_query(self, **data):",
            "        \"\"\"",
            "        \u67e5\u8be2\u9000\u6b3e",
            "        \u63d0\u4ea4\u9000\u6b3e\u7533\u8bf7\u540e\uff0c\u901a\u8fc7\u8c03\u7528\u8be5\u63a5\u53e3\u67e5\u8be2\u9000\u6b3e\u72b6\u6001\u3002\u9000\u6b3e\u6709\u4e00\u5b9a\u5ef6\u65f6\uff0c",
            "        \u7528\u96f6\u94b1\u652f\u4ed8\u7684\u9000\u6b3e20\u5206\u949f\u5185\u5230\u8d26\uff0c\u94f6\u884c\u5361\u652f\u4ed8\u7684\u9000\u6b3e3\u4e2a\u5de5\u4f5c\u65e5\u540e\u91cd\u65b0\u67e5\u8be2\u9000\u6b3e\u72b6\u6001\u3002",
            "",
            "        out_refund_no\u3001out_trade_no\u3001transaction_id\u3001refund_id\u56db\u4e2a\u53c2\u6570\u5fc5\u586b\u4e00\u4e2a",
            "        appid\u3001mchid\u3001nonce_str\u4e0d\u9700\u8981\u586b\u5165",
            "        \"\"\"",
            "        url = \"https://api.mch.weixin.qq.com/pay/refundquery\"",
            "        if \"out_refund_no\" not in data and \"out_trade_no\" not in data \\",
            "                and \"transaction_id\" not in data and \"refund_id\" not in data:",
            "            raise WeixinPayError(\"\u9000\u6b3e\u67e5\u8be2\u63a5\u53e3\u4e2d\uff0cout_refund_no\u3001out_trade_no\u3001transaction_id\u3001refund_id\u56db\u4e2a\u53c2\u6570\u5fc5\u586b\u4e00\u4e2a\")",
            "",
            "        return self._fetch(url, data)",
            "",
            "    def download_bill(self, bill_date, bill_type=\"ALL\", **data):",
            "        \"\"\"",
            "        \u4e0b\u8f7d\u5bf9\u8d26\u5355",
            "        bill_date\u3001bill_type\u4e3a\u5fc5\u586b\u53c2\u6570",
            "        appid\u3001mchid\u3001nonce_str\u4e0d\u9700\u8981\u586b\u5165",
            "        \"\"\"",
            "        url = \"https://api.mch.weixin.qq.com/pay/downloadbill\"",
            "        data.setdefault(\"bill_date\", bill_date)",
            "        data.setdefault(\"bill_type\", bill_type)",
            "",
            "        if \"bill_date\" not in data:",
            "            raise WeixinPayError(\"\u5bf9\u8d26\u5355\u63a5\u53e3\u4e2d\uff0c\u7f3a\u5c11\u5fc5\u586b\u53c2\u6570bill_date\")",
            "",
            "        return self._fetch(url, data)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "82": [
                "WeixinPay",
                "to_dict"
            ]
        },
        "addLocation": []
    }
}