{
    "src/werkzeug/debug/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from .._internal import _log"
            },
            "2": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from ..exceptions import NotFound"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+from ..exceptions import SecurityError"
            },
            "4": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from ..http import parse_cookie"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+from ..sansio.utils import host_is_trusted"
            },
            "6": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from ..security import gen_salt"
            },
            "7": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from ..utils import send_file"
            },
            "8": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from ..wrappers.request import Request"
            },
            "9": {
                "beforePatchRowNumber": 298,
                "afterPatchRowNumber": 300,
                "PatchRowcode": "         else:"
            },
            "10": {
                "beforePatchRowNumber": 299,
                "afterPatchRowNumber": 301,
                "PatchRowcode": "             self.pin = None"
            },
            "11": {
                "beforePatchRowNumber": 300,
                "afterPatchRowNumber": 302,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 303,
                "PatchRowcode": "+        self.trusted_hosts: list[str] = [\".localhost\", \"127.0.0.1\"]"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 304,
                "PatchRowcode": "+        \"\"\"List of domains to allow requests to the debugger from. A leading dot"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 305,
                "PatchRowcode": "+        allows all subdomains. This only allows ``\".localhost\"`` domains by"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 306,
                "PatchRowcode": "+        default."
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 307,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 308,
                "PatchRowcode": "+        .. versionadded:: 3.0.3"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 309,
                "PatchRowcode": "+        \"\"\""
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 310,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": 301,
                "afterPatchRowNumber": 311,
                "PatchRowcode": "     @property"
            },
            "21": {
                "beforePatchRowNumber": 302,
                "afterPatchRowNumber": 312,
                "PatchRowcode": "     def pin(self) -> str | None:"
            },
            "22": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": 313,
                "PatchRowcode": "         if not hasattr(self, \"_pin\"):"
            },
            "23": {
                "beforePatchRowNumber": 344,
                "afterPatchRowNumber": 354,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": 355,
                "PatchRowcode": "             is_trusted = bool(self.check_pin_trust(environ))"
            },
            "25": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": 356,
                "PatchRowcode": "             html = tb.render_debugger_html("
            },
            "26": {
                "beforePatchRowNumber": 347,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                evalex=self.evalex,"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 357,
                "PatchRowcode": "+                evalex=self.evalex and self.check_host_trust(environ),"
            },
            "28": {
                "beforePatchRowNumber": 348,
                "afterPatchRowNumber": 358,
                "PatchRowcode": "                 secret=self.secret,"
            },
            "29": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": 359,
                "PatchRowcode": "                 evalex_trusted=is_trusted,"
            },
            "30": {
                "beforePatchRowNumber": 350,
                "afterPatchRowNumber": 360,
                "PatchRowcode": "             )"
            },
            "31": {
                "beforePatchRowNumber": 372,
                "afterPatchRowNumber": 382,
                "PatchRowcode": "         frame: DebugFrameSummary | _ConsoleFrame,"
            },
            "32": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": 383,
                "PatchRowcode": "     ) -> Response:"
            },
            "33": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": 384,
                "PatchRowcode": "         \"\"\"Execute a command in a console.\"\"\""
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 385,
                "PatchRowcode": "+        if not self.check_host_trust(request.environ):"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 386,
                "PatchRowcode": "+            return SecurityError()  # type: ignore[return-value]"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 387,
                "PatchRowcode": "+"
            },
            "37": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": 388,
                "PatchRowcode": "         contexts = self.frame_contexts.get(id(frame), [])"
            },
            "38": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": 389,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": 377,
                "afterPatchRowNumber": 390,
                "PatchRowcode": "         with ExitStack() as exit_stack:"
            },
            "40": {
                "beforePatchRowNumber": 382,
                "afterPatchRowNumber": 395,
                "PatchRowcode": " "
            },
            "41": {
                "beforePatchRowNumber": 383,
                "afterPatchRowNumber": 396,
                "PatchRowcode": "     def display_console(self, request: Request) -> Response:"
            },
            "42": {
                "beforePatchRowNumber": 384,
                "afterPatchRowNumber": 397,
                "PatchRowcode": "         \"\"\"Display a standalone shell.\"\"\""
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 398,
                "PatchRowcode": "+        if not self.check_host_trust(request.environ):"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 399,
                "PatchRowcode": "+            return SecurityError()  # type: ignore[return-value]"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 400,
                "PatchRowcode": "+"
            },
            "46": {
                "beforePatchRowNumber": 385,
                "afterPatchRowNumber": 401,
                "PatchRowcode": "         if 0 not in self.frames:"
            },
            "47": {
                "beforePatchRowNumber": 386,
                "afterPatchRowNumber": 402,
                "PatchRowcode": "             if self.console_init_func is None:"
            },
            "48": {
                "beforePatchRowNumber": 387,
                "afterPatchRowNumber": 403,
                "PatchRowcode": "                 ns = {}"
            },
            "49": {
                "beforePatchRowNumber": 434,
                "afterPatchRowNumber": 450,
                "PatchRowcode": "             return None"
            },
            "50": {
                "beforePatchRowNumber": 435,
                "afterPatchRowNumber": 451,
                "PatchRowcode": "         return (time.time() - PIN_TIME) < ts"
            },
            "51": {
                "beforePatchRowNumber": 436,
                "afterPatchRowNumber": 452,
                "PatchRowcode": " "
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 453,
                "PatchRowcode": "+    def check_host_trust(self, environ: WSGIEnvironment) -> bool:"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 454,
                "PatchRowcode": "+        return host_is_trusted(environ.get(\"HTTP_HOST\"), self.trusted_hosts)"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 455,
                "PatchRowcode": "+"
            },
            "55": {
                "beforePatchRowNumber": 437,
                "afterPatchRowNumber": 456,
                "PatchRowcode": "     def _fail_pin_auth(self) -> None:"
            },
            "56": {
                "beforePatchRowNumber": 438,
                "afterPatchRowNumber": 457,
                "PatchRowcode": "         time.sleep(5.0 if self._failed_pin_auth > 5 else 0.5)"
            },
            "57": {
                "beforePatchRowNumber": 439,
                "afterPatchRowNumber": 458,
                "PatchRowcode": "         self._failed_pin_auth += 1"
            },
            "58": {
                "beforePatchRowNumber": 440,
                "afterPatchRowNumber": 459,
                "PatchRowcode": " "
            },
            "59": {
                "beforePatchRowNumber": 441,
                "afterPatchRowNumber": 460,
                "PatchRowcode": "     def pin_auth(self, request: Request) -> Response:"
            },
            "60": {
                "beforePatchRowNumber": 442,
                "afterPatchRowNumber": 461,
                "PatchRowcode": "         \"\"\"Authenticates with the pin.\"\"\""
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 462,
                "PatchRowcode": "+        if not self.check_host_trust(request.environ):"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 463,
                "PatchRowcode": "+            return SecurityError()  # type: ignore[return-value]"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 464,
                "PatchRowcode": "+"
            },
            "64": {
                "beforePatchRowNumber": 443,
                "afterPatchRowNumber": 465,
                "PatchRowcode": "         exhausted = False"
            },
            "65": {
                "beforePatchRowNumber": 444,
                "afterPatchRowNumber": 466,
                "PatchRowcode": "         auth = False"
            },
            "66": {
                "beforePatchRowNumber": 445,
                "afterPatchRowNumber": 467,
                "PatchRowcode": "         trust = self.check_pin_trust(request.environ)"
            },
            "67": {
                "beforePatchRowNumber": 489,
                "afterPatchRowNumber": 511,
                "PatchRowcode": "             rv.delete_cookie(self.pin_cookie_name)"
            },
            "68": {
                "beforePatchRowNumber": 490,
                "afterPatchRowNumber": 512,
                "PatchRowcode": "         return rv"
            },
            "69": {
                "beforePatchRowNumber": 491,
                "afterPatchRowNumber": 513,
                "PatchRowcode": " "
            },
            "70": {
                "beforePatchRowNumber": 492,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def log_pin_request(self) -> Response:"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 514,
                "PatchRowcode": "+    def log_pin_request(self, request: Request) -> Response:"
            },
            "72": {
                "beforePatchRowNumber": 493,
                "afterPatchRowNumber": 515,
                "PatchRowcode": "         \"\"\"Log the pin if needed.\"\"\""
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 516,
                "PatchRowcode": "+        if not self.check_host_trust(request.environ):"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 517,
                "PatchRowcode": "+            return SecurityError()  # type: ignore[return-value]"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 518,
                "PatchRowcode": "+"
            },
            "76": {
                "beforePatchRowNumber": 494,
                "afterPatchRowNumber": 519,
                "PatchRowcode": "         if self.pin_logging and self.pin is not None:"
            },
            "77": {
                "beforePatchRowNumber": 495,
                "afterPatchRowNumber": 520,
                "PatchRowcode": "             _log("
            },
            "78": {
                "beforePatchRowNumber": 496,
                "afterPatchRowNumber": 521,
                "PatchRowcode": "                 \"info\", \" * To enable the debugger you need to enter the security pin:\""
            },
            "79": {
                "beforePatchRowNumber": 517,
                "afterPatchRowNumber": 542,
                "PatchRowcode": "             elif cmd == \"pinauth\" and secret == self.secret:"
            },
            "80": {
                "beforePatchRowNumber": 518,
                "afterPatchRowNumber": 543,
                "PatchRowcode": "                 response = self.pin_auth(request)  # type: ignore"
            },
            "81": {
                "beforePatchRowNumber": 519,
                "afterPatchRowNumber": 544,
                "PatchRowcode": "             elif cmd == \"printpin\" and secret == self.secret:"
            },
            "82": {
                "beforePatchRowNumber": 520,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                response = self.log_pin_request()  # type: ignore"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 545,
                "PatchRowcode": "+                response = self.log_pin_request(request)  # type: ignore"
            },
            "84": {
                "beforePatchRowNumber": 521,
                "afterPatchRowNumber": 546,
                "PatchRowcode": "             elif ("
            },
            "85": {
                "beforePatchRowNumber": 522,
                "afterPatchRowNumber": 547,
                "PatchRowcode": "                 self.evalex"
            },
            "86": {
                "beforePatchRowNumber": 523,
                "afterPatchRowNumber": 548,
                "PatchRowcode": "                 and cmd is not None"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import getpass",
            "import hashlib",
            "import json",
            "import os",
            "import pkgutil",
            "import re",
            "import sys",
            "import time",
            "import typing as t",
            "import uuid",
            "from contextlib import ExitStack",
            "from io import BytesIO",
            "from itertools import chain",
            "from os.path import basename",
            "from os.path import join",
            "from zlib import adler32",
            "",
            "from .._internal import _log",
            "from ..exceptions import NotFound",
            "from ..http import parse_cookie",
            "from ..security import gen_salt",
            "from ..utils import send_file",
            "from ..wrappers.request import Request",
            "from ..wrappers.response import Response",
            "from .console import Console",
            "from .tbtools import DebugFrameSummary",
            "from .tbtools import DebugTraceback",
            "from .tbtools import render_console_html",
            "",
            "if t.TYPE_CHECKING:",
            "    from _typeshed.wsgi import StartResponse",
            "    from _typeshed.wsgi import WSGIApplication",
            "    from _typeshed.wsgi import WSGIEnvironment",
            "",
            "# A week",
            "PIN_TIME = 60 * 60 * 24 * 7",
            "",
            "",
            "def hash_pin(pin: str) -> str:",
            "    return hashlib.sha1(f\"{pin} added salt\".encode(\"utf-8\", \"replace\")).hexdigest()[:12]",
            "",
            "",
            "_machine_id: str | bytes | None = None",
            "",
            "",
            "def get_machine_id() -> str | bytes | None:",
            "    global _machine_id",
            "",
            "    if _machine_id is not None:",
            "        return _machine_id",
            "",
            "    def _generate() -> str | bytes | None:",
            "        linux = b\"\"",
            "",
            "        # machine-id is stable across boots, boot_id is not.",
            "        for filename in \"/etc/machine-id\", \"/proc/sys/kernel/random/boot_id\":",
            "            try:",
            "                with open(filename, \"rb\") as f:",
            "                    value = f.readline().strip()",
            "            except OSError:",
            "                continue",
            "",
            "            if value:",
            "                linux += value",
            "                break",
            "",
            "        # Containers share the same machine id, add some cgroup",
            "        # information. This is used outside containers too but should be",
            "        # relatively stable across boots.",
            "        try:",
            "            with open(\"/proc/self/cgroup\", \"rb\") as f:",
            "                linux += f.readline().strip().rpartition(b\"/\")[2]",
            "        except OSError:",
            "            pass",
            "",
            "        if linux:",
            "            return linux",
            "",
            "        # On OS X, use ioreg to get the computer's serial number.",
            "        try:",
            "            # subprocess may not be available, e.g. Google App Engine",
            "            # https://github.com/pallets/werkzeug/issues/925",
            "            from subprocess import PIPE",
            "            from subprocess import Popen",
            "",
            "            dump = Popen(",
            "                [\"ioreg\", \"-c\", \"IOPlatformExpertDevice\", \"-d\", \"2\"], stdout=PIPE",
            "            ).communicate()[0]",
            "            match = re.search(b'\"serial-number\" = <([^>]+)', dump)",
            "",
            "            if match is not None:",
            "                return match.group(1)",
            "        except (OSError, ImportError):",
            "            pass",
            "",
            "        # On Windows, use winreg to get the machine guid.",
            "        if sys.platform == \"win32\":",
            "            import winreg",
            "",
            "            try:",
            "                with winreg.OpenKey(",
            "                    winreg.HKEY_LOCAL_MACHINE,",
            "                    \"SOFTWARE\\\\Microsoft\\\\Cryptography\",",
            "                    0,",
            "                    winreg.KEY_READ | winreg.KEY_WOW64_64KEY,",
            "                ) as rk:",
            "                    guid: str | bytes",
            "                    guid_type: int",
            "                    guid, guid_type = winreg.QueryValueEx(rk, \"MachineGuid\")",
            "",
            "                    if guid_type == winreg.REG_SZ:",
            "                        return guid.encode()",
            "",
            "                    return guid",
            "            except OSError:",
            "                pass",
            "",
            "        return None",
            "",
            "    _machine_id = _generate()",
            "    return _machine_id",
            "",
            "",
            "class _ConsoleFrame:",
            "    \"\"\"Helper class so that we can reuse the frame console code for the",
            "    standalone console.",
            "    \"\"\"",
            "",
            "    def __init__(self, namespace: dict[str, t.Any]):",
            "        self.console = Console(namespace)",
            "        self.id = 0",
            "",
            "    def eval(self, code: str) -> t.Any:",
            "        return self.console.eval(code)",
            "",
            "",
            "def get_pin_and_cookie_name(",
            "    app: WSGIApplication,",
            ") -> tuple[str, str] | tuple[None, None]:",
            "    \"\"\"Given an application object this returns a semi-stable 9 digit pin",
            "    code and a random key.  The hope is that this is stable between",
            "    restarts to not make debugging particularly frustrating.  If the pin",
            "    was forcefully disabled this returns `None`.",
            "",
            "    Second item in the resulting tuple is the cookie name for remembering.",
            "    \"\"\"",
            "    pin = os.environ.get(\"WERKZEUG_DEBUG_PIN\")",
            "    rv = None",
            "    num = None",
            "",
            "    # Pin was explicitly disabled",
            "    if pin == \"off\":",
            "        return None, None",
            "",
            "    # Pin was provided explicitly",
            "    if pin is not None and pin.replace(\"-\", \"\").isdecimal():",
            "        # If there are separators in the pin, return it directly",
            "        if \"-\" in pin:",
            "            rv = pin",
            "        else:",
            "            num = pin",
            "",
            "    modname = getattr(app, \"__module__\", t.cast(object, app).__class__.__module__)",
            "    username: str | None",
            "",
            "    try:",
            "        # getuser imports the pwd module, which does not exist in Google",
            "        # App Engine. It may also raise a KeyError if the UID does not",
            "        # have a username, such as in Docker.",
            "        username = getpass.getuser()",
            "    except (ImportError, KeyError):",
            "        username = None",
            "",
            "    mod = sys.modules.get(modname)",
            "",
            "    # This information only exists to make the cookie unique on the",
            "    # computer, not as a security feature.",
            "    probably_public_bits = [",
            "        username,",
            "        modname,",
            "        getattr(app, \"__name__\", type(app).__name__),",
            "        getattr(mod, \"__file__\", None),",
            "    ]",
            "",
            "    # This information is here to make it harder for an attacker to",
            "    # guess the cookie name.  They are unlikely to be contained anywhere",
            "    # within the unauthenticated debug page.",
            "    private_bits = [str(uuid.getnode()), get_machine_id()]",
            "",
            "    h = hashlib.sha1()",
            "    for bit in chain(probably_public_bits, private_bits):",
            "        if not bit:",
            "            continue",
            "        if isinstance(bit, str):",
            "            bit = bit.encode()",
            "        h.update(bit)",
            "    h.update(b\"cookiesalt\")",
            "",
            "    cookie_name = f\"__wzd{h.hexdigest()[:20]}\"",
            "",
            "    # If we need to generate a pin we salt it a bit more so that we don't",
            "    # end up with the same value and generate out 9 digits",
            "    if num is None:",
            "        h.update(b\"pinsalt\")",
            "        num = f\"{int(h.hexdigest(), 16):09d}\"[:9]",
            "",
            "    # Format the pincode in groups of digits for easier remembering if",
            "    # we don't have a result yet.",
            "    if rv is None:",
            "        for group_size in 5, 4, 3:",
            "            if len(num) % group_size == 0:",
            "                rv = \"-\".join(",
            "                    num[x : x + group_size].rjust(group_size, \"0\")",
            "                    for x in range(0, len(num), group_size)",
            "                )",
            "                break",
            "        else:",
            "            rv = num",
            "",
            "    return rv, cookie_name",
            "",
            "",
            "class DebuggedApplication:",
            "    \"\"\"Enables debugging support for a given application::",
            "",
            "        from werkzeug.debug import DebuggedApplication",
            "        from myapp import app",
            "        app = DebuggedApplication(app, evalex=True)",
            "",
            "    The ``evalex`` argument allows evaluating expressions in any frame",
            "    of a traceback. This works by preserving each frame with its local",
            "    state. Some state, such as context globals, cannot be restored with",
            "    the frame by default. When ``evalex`` is enabled,",
            "    ``environ[\"werkzeug.debug.preserve_context\"]`` will be a callable",
            "    that takes a context manager, and can be called multiple times.",
            "    Each context manager will be entered before evaluating code in the",
            "    frame, then exited again, so they can perform setup and cleanup for",
            "    each call.",
            "",
            "    :param app: the WSGI application to run debugged.",
            "    :param evalex: enable exception evaluation feature (interactive",
            "                   debugging).  This requires a non-forking server.",
            "    :param request_key: The key that points to the request object in this",
            "                        environment.  This parameter is ignored in current",
            "                        versions.",
            "    :param console_path: the URL for a general purpose console.",
            "    :param console_init_func: the function that is executed before starting",
            "                              the general purpose console.  The return value",
            "                              is used as initial namespace.",
            "    :param show_hidden_frames: by default hidden traceback frames are skipped.",
            "                               You can show them by setting this parameter",
            "                               to `True`.",
            "    :param pin_security: can be used to disable the pin based security system.",
            "    :param pin_logging: enables the logging of the pin system.",
            "",
            "    .. versionchanged:: 2.2",
            "        Added the ``werkzeug.debug.preserve_context`` environ key.",
            "    \"\"\"",
            "",
            "    _pin: str",
            "    _pin_cookie: str",
            "",
            "    def __init__(",
            "        self,",
            "        app: WSGIApplication,",
            "        evalex: bool = False,",
            "        request_key: str = \"werkzeug.request\",",
            "        console_path: str = \"/console\",",
            "        console_init_func: t.Callable[[], dict[str, t.Any]] | None = None,",
            "        show_hidden_frames: bool = False,",
            "        pin_security: bool = True,",
            "        pin_logging: bool = True,",
            "    ) -> None:",
            "        if not console_init_func:",
            "            console_init_func = None",
            "        self.app = app",
            "        self.evalex = evalex",
            "        self.frames: dict[int, DebugFrameSummary | _ConsoleFrame] = {}",
            "        self.frame_contexts: dict[int, list[t.ContextManager[None]]] = {}",
            "        self.request_key = request_key",
            "        self.console_path = console_path",
            "        self.console_init_func = console_init_func",
            "        self.show_hidden_frames = show_hidden_frames",
            "        self.secret = gen_salt(20)",
            "        self._failed_pin_auth = 0",
            "",
            "        self.pin_logging = pin_logging",
            "        if pin_security:",
            "            # Print out the pin for the debugger on standard out.",
            "            if os.environ.get(\"WERKZEUG_RUN_MAIN\") == \"true\" and pin_logging:",
            "                _log(\"warning\", \" * Debugger is active!\")",
            "                if self.pin is None:",
            "                    _log(\"warning\", \" * Debugger PIN disabled. DEBUGGER UNSECURED!\")",
            "                else:",
            "                    _log(\"info\", \" * Debugger PIN: %s\", self.pin)",
            "        else:",
            "            self.pin = None",
            "",
            "    @property",
            "    def pin(self) -> str | None:",
            "        if not hasattr(self, \"_pin\"):",
            "            pin_cookie = get_pin_and_cookie_name(self.app)",
            "            self._pin, self._pin_cookie = pin_cookie  # type: ignore",
            "        return self._pin",
            "",
            "    @pin.setter",
            "    def pin(self, value: str) -> None:",
            "        self._pin = value",
            "",
            "    @property",
            "    def pin_cookie_name(self) -> str:",
            "        \"\"\"The name of the pin cookie.\"\"\"",
            "        if not hasattr(self, \"_pin_cookie\"):",
            "            pin_cookie = get_pin_and_cookie_name(self.app)",
            "            self._pin, self._pin_cookie = pin_cookie  # type: ignore",
            "        return self._pin_cookie",
            "",
            "    def debug_application(",
            "        self, environ: WSGIEnvironment, start_response: StartResponse",
            "    ) -> t.Iterator[bytes]:",
            "        \"\"\"Run the application and conserve the traceback frames.\"\"\"",
            "        contexts: list[t.ContextManager[t.Any]] = []",
            "",
            "        if self.evalex:",
            "            environ[\"werkzeug.debug.preserve_context\"] = contexts.append",
            "",
            "        app_iter = None",
            "        try:",
            "            app_iter = self.app(environ, start_response)",
            "            yield from app_iter",
            "            if hasattr(app_iter, \"close\"):",
            "                app_iter.close()",
            "        except Exception as e:",
            "            if hasattr(app_iter, \"close\"):",
            "                app_iter.close()  # type: ignore",
            "",
            "            tb = DebugTraceback(e, skip=1, hide=not self.show_hidden_frames)",
            "",
            "            for frame in tb.all_frames:",
            "                self.frames[id(frame)] = frame",
            "                self.frame_contexts[id(frame)] = contexts",
            "",
            "            is_trusted = bool(self.check_pin_trust(environ))",
            "            html = tb.render_debugger_html(",
            "                evalex=self.evalex,",
            "                secret=self.secret,",
            "                evalex_trusted=is_trusted,",
            "            )",
            "            response = Response(html, status=500, mimetype=\"text/html\")",
            "",
            "            try:",
            "                yield from response(environ, start_response)",
            "            except Exception:",
            "                # if we end up here there has been output but an error",
            "                # occurred.  in that situation we can do nothing fancy any",
            "                # more, better log something into the error log and fall",
            "                # back gracefully.",
            "                environ[\"wsgi.errors\"].write(",
            "                    \"Debugging middleware caught exception in streamed \"",
            "                    \"response at a point where response headers were already \"",
            "                    \"sent.\\n\"",
            "                )",
            "",
            "            environ[\"wsgi.errors\"].write(\"\".join(tb.render_traceback_text()))",
            "",
            "    def execute_command(  # type: ignore[return]",
            "        self,",
            "        request: Request,",
            "        command: str,",
            "        frame: DebugFrameSummary | _ConsoleFrame,",
            "    ) -> Response:",
            "        \"\"\"Execute a command in a console.\"\"\"",
            "        contexts = self.frame_contexts.get(id(frame), [])",
            "",
            "        with ExitStack() as exit_stack:",
            "            for cm in contexts:",
            "                exit_stack.enter_context(cm)",
            "",
            "            return Response(frame.eval(command), mimetype=\"text/html\")",
            "",
            "    def display_console(self, request: Request) -> Response:",
            "        \"\"\"Display a standalone shell.\"\"\"",
            "        if 0 not in self.frames:",
            "            if self.console_init_func is None:",
            "                ns = {}",
            "            else:",
            "                ns = dict(self.console_init_func())",
            "            ns.setdefault(\"app\", self.app)",
            "            self.frames[0] = _ConsoleFrame(ns)",
            "        is_trusted = bool(self.check_pin_trust(request.environ))",
            "        return Response(",
            "            render_console_html(secret=self.secret, evalex_trusted=is_trusted),",
            "            mimetype=\"text/html\",",
            "        )",
            "",
            "    def get_resource(self, request: Request, filename: str) -> Response:",
            "        \"\"\"Return a static resource from the shared folder.\"\"\"",
            "        path = join(\"shared\", basename(filename))",
            "",
            "        try:",
            "            data = pkgutil.get_data(__package__, path)",
            "        except OSError:",
            "            return NotFound()  # type: ignore[return-value]",
            "        else:",
            "            if data is None:",
            "                return NotFound()  # type: ignore[return-value]",
            "",
            "            etag = str(adler32(data) & 0xFFFFFFFF)",
            "            return send_file(",
            "                BytesIO(data), request.environ, download_name=filename, etag=etag",
            "            )",
            "",
            "    def check_pin_trust(self, environ: WSGIEnvironment) -> bool | None:",
            "        \"\"\"Checks if the request passed the pin test.  This returns `True` if the",
            "        request is trusted on a pin/cookie basis and returns `False` if not.",
            "        Additionally if the cookie's stored pin hash is wrong it will return",
            "        `None` so that appropriate action can be taken.",
            "        \"\"\"",
            "        if self.pin is None:",
            "            return True",
            "        val = parse_cookie(environ).get(self.pin_cookie_name)",
            "        if not val or \"|\" not in val:",
            "            return False",
            "        ts_str, pin_hash = val.split(\"|\", 1)",
            "",
            "        try:",
            "            ts = int(ts_str)",
            "        except ValueError:",
            "            return False",
            "",
            "        if pin_hash != hash_pin(self.pin):",
            "            return None",
            "        return (time.time() - PIN_TIME) < ts",
            "",
            "    def _fail_pin_auth(self) -> None:",
            "        time.sleep(5.0 if self._failed_pin_auth > 5 else 0.5)",
            "        self._failed_pin_auth += 1",
            "",
            "    def pin_auth(self, request: Request) -> Response:",
            "        \"\"\"Authenticates with the pin.\"\"\"",
            "        exhausted = False",
            "        auth = False",
            "        trust = self.check_pin_trust(request.environ)",
            "        pin = t.cast(str, self.pin)",
            "",
            "        # If the trust return value is `None` it means that the cookie is",
            "        # set but the stored pin hash value is bad.  This means that the",
            "        # pin was changed.  In this case we count a bad auth and unset the",
            "        # cookie.  This way it becomes harder to guess the cookie name",
            "        # instead of the pin as we still count up failures.",
            "        bad_cookie = False",
            "        if trust is None:",
            "            self._fail_pin_auth()",
            "            bad_cookie = True",
            "",
            "        # If we're trusted, we're authenticated.",
            "        elif trust:",
            "            auth = True",
            "",
            "        # If we failed too many times, then we're locked out.",
            "        elif self._failed_pin_auth > 10:",
            "            exhausted = True",
            "",
            "        # Otherwise go through pin based authentication",
            "        else:",
            "            entered_pin = request.args[\"pin\"]",
            "",
            "            if entered_pin.strip().replace(\"-\", \"\") == pin.replace(\"-\", \"\"):",
            "                self._failed_pin_auth = 0",
            "                auth = True",
            "            else:",
            "                self._fail_pin_auth()",
            "",
            "        rv = Response(",
            "            json.dumps({\"auth\": auth, \"exhausted\": exhausted}),",
            "            mimetype=\"application/json\",",
            "        )",
            "        if auth:",
            "            rv.set_cookie(",
            "                self.pin_cookie_name,",
            "                f\"{int(time.time())}|{hash_pin(pin)}\",",
            "                httponly=True,",
            "                samesite=\"Strict\",",
            "                secure=request.is_secure,",
            "            )",
            "        elif bad_cookie:",
            "            rv.delete_cookie(self.pin_cookie_name)",
            "        return rv",
            "",
            "    def log_pin_request(self) -> Response:",
            "        \"\"\"Log the pin if needed.\"\"\"",
            "        if self.pin_logging and self.pin is not None:",
            "            _log(",
            "                \"info\", \" * To enable the debugger you need to enter the security pin:\"",
            "            )",
            "            _log(\"info\", \" * Debugger pin code: %s\", self.pin)",
            "        return Response(\"\")",
            "",
            "    def __call__(",
            "        self, environ: WSGIEnvironment, start_response: StartResponse",
            "    ) -> t.Iterable[bytes]:",
            "        \"\"\"Dispatch the requests.\"\"\"",
            "        # important: don't ever access a function here that reads the incoming",
            "        # form data!  Otherwise the application won't have access to that data",
            "        # any more!",
            "        request = Request(environ)",
            "        response = self.debug_application",
            "        if request.args.get(\"__debugger__\") == \"yes\":",
            "            cmd = request.args.get(\"cmd\")",
            "            arg = request.args.get(\"f\")",
            "            secret = request.args.get(\"s\")",
            "            frame = self.frames.get(request.args.get(\"frm\", type=int))  # type: ignore",
            "            if cmd == \"resource\" and arg:",
            "                response = self.get_resource(request, arg)  # type: ignore",
            "            elif cmd == \"pinauth\" and secret == self.secret:",
            "                response = self.pin_auth(request)  # type: ignore",
            "            elif cmd == \"printpin\" and secret == self.secret:",
            "                response = self.log_pin_request()  # type: ignore",
            "            elif (",
            "                self.evalex",
            "                and cmd is not None",
            "                and frame is not None",
            "                and self.secret == secret",
            "                and self.check_pin_trust(environ)",
            "            ):",
            "                response = self.execute_command(request, cmd, frame)  # type: ignore",
            "        elif (",
            "            self.evalex",
            "            and self.console_path is not None",
            "            and request.path == self.console_path",
            "        ):",
            "            response = self.display_console(request)  # type: ignore",
            "        return response(environ, start_response)"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import getpass",
            "import hashlib",
            "import json",
            "import os",
            "import pkgutil",
            "import re",
            "import sys",
            "import time",
            "import typing as t",
            "import uuid",
            "from contextlib import ExitStack",
            "from io import BytesIO",
            "from itertools import chain",
            "from os.path import basename",
            "from os.path import join",
            "from zlib import adler32",
            "",
            "from .._internal import _log",
            "from ..exceptions import NotFound",
            "from ..exceptions import SecurityError",
            "from ..http import parse_cookie",
            "from ..sansio.utils import host_is_trusted",
            "from ..security import gen_salt",
            "from ..utils import send_file",
            "from ..wrappers.request import Request",
            "from ..wrappers.response import Response",
            "from .console import Console",
            "from .tbtools import DebugFrameSummary",
            "from .tbtools import DebugTraceback",
            "from .tbtools import render_console_html",
            "",
            "if t.TYPE_CHECKING:",
            "    from _typeshed.wsgi import StartResponse",
            "    from _typeshed.wsgi import WSGIApplication",
            "    from _typeshed.wsgi import WSGIEnvironment",
            "",
            "# A week",
            "PIN_TIME = 60 * 60 * 24 * 7",
            "",
            "",
            "def hash_pin(pin: str) -> str:",
            "    return hashlib.sha1(f\"{pin} added salt\".encode(\"utf-8\", \"replace\")).hexdigest()[:12]",
            "",
            "",
            "_machine_id: str | bytes | None = None",
            "",
            "",
            "def get_machine_id() -> str | bytes | None:",
            "    global _machine_id",
            "",
            "    if _machine_id is not None:",
            "        return _machine_id",
            "",
            "    def _generate() -> str | bytes | None:",
            "        linux = b\"\"",
            "",
            "        # machine-id is stable across boots, boot_id is not.",
            "        for filename in \"/etc/machine-id\", \"/proc/sys/kernel/random/boot_id\":",
            "            try:",
            "                with open(filename, \"rb\") as f:",
            "                    value = f.readline().strip()",
            "            except OSError:",
            "                continue",
            "",
            "            if value:",
            "                linux += value",
            "                break",
            "",
            "        # Containers share the same machine id, add some cgroup",
            "        # information. This is used outside containers too but should be",
            "        # relatively stable across boots.",
            "        try:",
            "            with open(\"/proc/self/cgroup\", \"rb\") as f:",
            "                linux += f.readline().strip().rpartition(b\"/\")[2]",
            "        except OSError:",
            "            pass",
            "",
            "        if linux:",
            "            return linux",
            "",
            "        # On OS X, use ioreg to get the computer's serial number.",
            "        try:",
            "            # subprocess may not be available, e.g. Google App Engine",
            "            # https://github.com/pallets/werkzeug/issues/925",
            "            from subprocess import PIPE",
            "            from subprocess import Popen",
            "",
            "            dump = Popen(",
            "                [\"ioreg\", \"-c\", \"IOPlatformExpertDevice\", \"-d\", \"2\"], stdout=PIPE",
            "            ).communicate()[0]",
            "            match = re.search(b'\"serial-number\" = <([^>]+)', dump)",
            "",
            "            if match is not None:",
            "                return match.group(1)",
            "        except (OSError, ImportError):",
            "            pass",
            "",
            "        # On Windows, use winreg to get the machine guid.",
            "        if sys.platform == \"win32\":",
            "            import winreg",
            "",
            "            try:",
            "                with winreg.OpenKey(",
            "                    winreg.HKEY_LOCAL_MACHINE,",
            "                    \"SOFTWARE\\\\Microsoft\\\\Cryptography\",",
            "                    0,",
            "                    winreg.KEY_READ | winreg.KEY_WOW64_64KEY,",
            "                ) as rk:",
            "                    guid: str | bytes",
            "                    guid_type: int",
            "                    guid, guid_type = winreg.QueryValueEx(rk, \"MachineGuid\")",
            "",
            "                    if guid_type == winreg.REG_SZ:",
            "                        return guid.encode()",
            "",
            "                    return guid",
            "            except OSError:",
            "                pass",
            "",
            "        return None",
            "",
            "    _machine_id = _generate()",
            "    return _machine_id",
            "",
            "",
            "class _ConsoleFrame:",
            "    \"\"\"Helper class so that we can reuse the frame console code for the",
            "    standalone console.",
            "    \"\"\"",
            "",
            "    def __init__(self, namespace: dict[str, t.Any]):",
            "        self.console = Console(namespace)",
            "        self.id = 0",
            "",
            "    def eval(self, code: str) -> t.Any:",
            "        return self.console.eval(code)",
            "",
            "",
            "def get_pin_and_cookie_name(",
            "    app: WSGIApplication,",
            ") -> tuple[str, str] | tuple[None, None]:",
            "    \"\"\"Given an application object this returns a semi-stable 9 digit pin",
            "    code and a random key.  The hope is that this is stable between",
            "    restarts to not make debugging particularly frustrating.  If the pin",
            "    was forcefully disabled this returns `None`.",
            "",
            "    Second item in the resulting tuple is the cookie name for remembering.",
            "    \"\"\"",
            "    pin = os.environ.get(\"WERKZEUG_DEBUG_PIN\")",
            "    rv = None",
            "    num = None",
            "",
            "    # Pin was explicitly disabled",
            "    if pin == \"off\":",
            "        return None, None",
            "",
            "    # Pin was provided explicitly",
            "    if pin is not None and pin.replace(\"-\", \"\").isdecimal():",
            "        # If there are separators in the pin, return it directly",
            "        if \"-\" in pin:",
            "            rv = pin",
            "        else:",
            "            num = pin",
            "",
            "    modname = getattr(app, \"__module__\", t.cast(object, app).__class__.__module__)",
            "    username: str | None",
            "",
            "    try:",
            "        # getuser imports the pwd module, which does not exist in Google",
            "        # App Engine. It may also raise a KeyError if the UID does not",
            "        # have a username, such as in Docker.",
            "        username = getpass.getuser()",
            "    except (ImportError, KeyError):",
            "        username = None",
            "",
            "    mod = sys.modules.get(modname)",
            "",
            "    # This information only exists to make the cookie unique on the",
            "    # computer, not as a security feature.",
            "    probably_public_bits = [",
            "        username,",
            "        modname,",
            "        getattr(app, \"__name__\", type(app).__name__),",
            "        getattr(mod, \"__file__\", None),",
            "    ]",
            "",
            "    # This information is here to make it harder for an attacker to",
            "    # guess the cookie name.  They are unlikely to be contained anywhere",
            "    # within the unauthenticated debug page.",
            "    private_bits = [str(uuid.getnode()), get_machine_id()]",
            "",
            "    h = hashlib.sha1()",
            "    for bit in chain(probably_public_bits, private_bits):",
            "        if not bit:",
            "            continue",
            "        if isinstance(bit, str):",
            "            bit = bit.encode()",
            "        h.update(bit)",
            "    h.update(b\"cookiesalt\")",
            "",
            "    cookie_name = f\"__wzd{h.hexdigest()[:20]}\"",
            "",
            "    # If we need to generate a pin we salt it a bit more so that we don't",
            "    # end up with the same value and generate out 9 digits",
            "    if num is None:",
            "        h.update(b\"pinsalt\")",
            "        num = f\"{int(h.hexdigest(), 16):09d}\"[:9]",
            "",
            "    # Format the pincode in groups of digits for easier remembering if",
            "    # we don't have a result yet.",
            "    if rv is None:",
            "        for group_size in 5, 4, 3:",
            "            if len(num) % group_size == 0:",
            "                rv = \"-\".join(",
            "                    num[x : x + group_size].rjust(group_size, \"0\")",
            "                    for x in range(0, len(num), group_size)",
            "                )",
            "                break",
            "        else:",
            "            rv = num",
            "",
            "    return rv, cookie_name",
            "",
            "",
            "class DebuggedApplication:",
            "    \"\"\"Enables debugging support for a given application::",
            "",
            "        from werkzeug.debug import DebuggedApplication",
            "        from myapp import app",
            "        app = DebuggedApplication(app, evalex=True)",
            "",
            "    The ``evalex`` argument allows evaluating expressions in any frame",
            "    of a traceback. This works by preserving each frame with its local",
            "    state. Some state, such as context globals, cannot be restored with",
            "    the frame by default. When ``evalex`` is enabled,",
            "    ``environ[\"werkzeug.debug.preserve_context\"]`` will be a callable",
            "    that takes a context manager, and can be called multiple times.",
            "    Each context manager will be entered before evaluating code in the",
            "    frame, then exited again, so they can perform setup and cleanup for",
            "    each call.",
            "",
            "    :param app: the WSGI application to run debugged.",
            "    :param evalex: enable exception evaluation feature (interactive",
            "                   debugging).  This requires a non-forking server.",
            "    :param request_key: The key that points to the request object in this",
            "                        environment.  This parameter is ignored in current",
            "                        versions.",
            "    :param console_path: the URL for a general purpose console.",
            "    :param console_init_func: the function that is executed before starting",
            "                              the general purpose console.  The return value",
            "                              is used as initial namespace.",
            "    :param show_hidden_frames: by default hidden traceback frames are skipped.",
            "                               You can show them by setting this parameter",
            "                               to `True`.",
            "    :param pin_security: can be used to disable the pin based security system.",
            "    :param pin_logging: enables the logging of the pin system.",
            "",
            "    .. versionchanged:: 2.2",
            "        Added the ``werkzeug.debug.preserve_context`` environ key.",
            "    \"\"\"",
            "",
            "    _pin: str",
            "    _pin_cookie: str",
            "",
            "    def __init__(",
            "        self,",
            "        app: WSGIApplication,",
            "        evalex: bool = False,",
            "        request_key: str = \"werkzeug.request\",",
            "        console_path: str = \"/console\",",
            "        console_init_func: t.Callable[[], dict[str, t.Any]] | None = None,",
            "        show_hidden_frames: bool = False,",
            "        pin_security: bool = True,",
            "        pin_logging: bool = True,",
            "    ) -> None:",
            "        if not console_init_func:",
            "            console_init_func = None",
            "        self.app = app",
            "        self.evalex = evalex",
            "        self.frames: dict[int, DebugFrameSummary | _ConsoleFrame] = {}",
            "        self.frame_contexts: dict[int, list[t.ContextManager[None]]] = {}",
            "        self.request_key = request_key",
            "        self.console_path = console_path",
            "        self.console_init_func = console_init_func",
            "        self.show_hidden_frames = show_hidden_frames",
            "        self.secret = gen_salt(20)",
            "        self._failed_pin_auth = 0",
            "",
            "        self.pin_logging = pin_logging",
            "        if pin_security:",
            "            # Print out the pin for the debugger on standard out.",
            "            if os.environ.get(\"WERKZEUG_RUN_MAIN\") == \"true\" and pin_logging:",
            "                _log(\"warning\", \" * Debugger is active!\")",
            "                if self.pin is None:",
            "                    _log(\"warning\", \" * Debugger PIN disabled. DEBUGGER UNSECURED!\")",
            "                else:",
            "                    _log(\"info\", \" * Debugger PIN: %s\", self.pin)",
            "        else:",
            "            self.pin = None",
            "",
            "        self.trusted_hosts: list[str] = [\".localhost\", \"127.0.0.1\"]",
            "        \"\"\"List of domains to allow requests to the debugger from. A leading dot",
            "        allows all subdomains. This only allows ``\".localhost\"`` domains by",
            "        default.",
            "",
            "        .. versionadded:: 3.0.3",
            "        \"\"\"",
            "",
            "    @property",
            "    def pin(self) -> str | None:",
            "        if not hasattr(self, \"_pin\"):",
            "            pin_cookie = get_pin_and_cookie_name(self.app)",
            "            self._pin, self._pin_cookie = pin_cookie  # type: ignore",
            "        return self._pin",
            "",
            "    @pin.setter",
            "    def pin(self, value: str) -> None:",
            "        self._pin = value",
            "",
            "    @property",
            "    def pin_cookie_name(self) -> str:",
            "        \"\"\"The name of the pin cookie.\"\"\"",
            "        if not hasattr(self, \"_pin_cookie\"):",
            "            pin_cookie = get_pin_and_cookie_name(self.app)",
            "            self._pin, self._pin_cookie = pin_cookie  # type: ignore",
            "        return self._pin_cookie",
            "",
            "    def debug_application(",
            "        self, environ: WSGIEnvironment, start_response: StartResponse",
            "    ) -> t.Iterator[bytes]:",
            "        \"\"\"Run the application and conserve the traceback frames.\"\"\"",
            "        contexts: list[t.ContextManager[t.Any]] = []",
            "",
            "        if self.evalex:",
            "            environ[\"werkzeug.debug.preserve_context\"] = contexts.append",
            "",
            "        app_iter = None",
            "        try:",
            "            app_iter = self.app(environ, start_response)",
            "            yield from app_iter",
            "            if hasattr(app_iter, \"close\"):",
            "                app_iter.close()",
            "        except Exception as e:",
            "            if hasattr(app_iter, \"close\"):",
            "                app_iter.close()  # type: ignore",
            "",
            "            tb = DebugTraceback(e, skip=1, hide=not self.show_hidden_frames)",
            "",
            "            for frame in tb.all_frames:",
            "                self.frames[id(frame)] = frame",
            "                self.frame_contexts[id(frame)] = contexts",
            "",
            "            is_trusted = bool(self.check_pin_trust(environ))",
            "            html = tb.render_debugger_html(",
            "                evalex=self.evalex and self.check_host_trust(environ),",
            "                secret=self.secret,",
            "                evalex_trusted=is_trusted,",
            "            )",
            "            response = Response(html, status=500, mimetype=\"text/html\")",
            "",
            "            try:",
            "                yield from response(environ, start_response)",
            "            except Exception:",
            "                # if we end up here there has been output but an error",
            "                # occurred.  in that situation we can do nothing fancy any",
            "                # more, better log something into the error log and fall",
            "                # back gracefully.",
            "                environ[\"wsgi.errors\"].write(",
            "                    \"Debugging middleware caught exception in streamed \"",
            "                    \"response at a point where response headers were already \"",
            "                    \"sent.\\n\"",
            "                )",
            "",
            "            environ[\"wsgi.errors\"].write(\"\".join(tb.render_traceback_text()))",
            "",
            "    def execute_command(  # type: ignore[return]",
            "        self,",
            "        request: Request,",
            "        command: str,",
            "        frame: DebugFrameSummary | _ConsoleFrame,",
            "    ) -> Response:",
            "        \"\"\"Execute a command in a console.\"\"\"",
            "        if not self.check_host_trust(request.environ):",
            "            return SecurityError()  # type: ignore[return-value]",
            "",
            "        contexts = self.frame_contexts.get(id(frame), [])",
            "",
            "        with ExitStack() as exit_stack:",
            "            for cm in contexts:",
            "                exit_stack.enter_context(cm)",
            "",
            "            return Response(frame.eval(command), mimetype=\"text/html\")",
            "",
            "    def display_console(self, request: Request) -> Response:",
            "        \"\"\"Display a standalone shell.\"\"\"",
            "        if not self.check_host_trust(request.environ):",
            "            return SecurityError()  # type: ignore[return-value]",
            "",
            "        if 0 not in self.frames:",
            "            if self.console_init_func is None:",
            "                ns = {}",
            "            else:",
            "                ns = dict(self.console_init_func())",
            "            ns.setdefault(\"app\", self.app)",
            "            self.frames[0] = _ConsoleFrame(ns)",
            "        is_trusted = bool(self.check_pin_trust(request.environ))",
            "        return Response(",
            "            render_console_html(secret=self.secret, evalex_trusted=is_trusted),",
            "            mimetype=\"text/html\",",
            "        )",
            "",
            "    def get_resource(self, request: Request, filename: str) -> Response:",
            "        \"\"\"Return a static resource from the shared folder.\"\"\"",
            "        path = join(\"shared\", basename(filename))",
            "",
            "        try:",
            "            data = pkgutil.get_data(__package__, path)",
            "        except OSError:",
            "            return NotFound()  # type: ignore[return-value]",
            "        else:",
            "            if data is None:",
            "                return NotFound()  # type: ignore[return-value]",
            "",
            "            etag = str(adler32(data) & 0xFFFFFFFF)",
            "            return send_file(",
            "                BytesIO(data), request.environ, download_name=filename, etag=etag",
            "            )",
            "",
            "    def check_pin_trust(self, environ: WSGIEnvironment) -> bool | None:",
            "        \"\"\"Checks if the request passed the pin test.  This returns `True` if the",
            "        request is trusted on a pin/cookie basis and returns `False` if not.",
            "        Additionally if the cookie's stored pin hash is wrong it will return",
            "        `None` so that appropriate action can be taken.",
            "        \"\"\"",
            "        if self.pin is None:",
            "            return True",
            "        val = parse_cookie(environ).get(self.pin_cookie_name)",
            "        if not val or \"|\" not in val:",
            "            return False",
            "        ts_str, pin_hash = val.split(\"|\", 1)",
            "",
            "        try:",
            "            ts = int(ts_str)",
            "        except ValueError:",
            "            return False",
            "",
            "        if pin_hash != hash_pin(self.pin):",
            "            return None",
            "        return (time.time() - PIN_TIME) < ts",
            "",
            "    def check_host_trust(self, environ: WSGIEnvironment) -> bool:",
            "        return host_is_trusted(environ.get(\"HTTP_HOST\"), self.trusted_hosts)",
            "",
            "    def _fail_pin_auth(self) -> None:",
            "        time.sleep(5.0 if self._failed_pin_auth > 5 else 0.5)",
            "        self._failed_pin_auth += 1",
            "",
            "    def pin_auth(self, request: Request) -> Response:",
            "        \"\"\"Authenticates with the pin.\"\"\"",
            "        if not self.check_host_trust(request.environ):",
            "            return SecurityError()  # type: ignore[return-value]",
            "",
            "        exhausted = False",
            "        auth = False",
            "        trust = self.check_pin_trust(request.environ)",
            "        pin = t.cast(str, self.pin)",
            "",
            "        # If the trust return value is `None` it means that the cookie is",
            "        # set but the stored pin hash value is bad.  This means that the",
            "        # pin was changed.  In this case we count a bad auth and unset the",
            "        # cookie.  This way it becomes harder to guess the cookie name",
            "        # instead of the pin as we still count up failures.",
            "        bad_cookie = False",
            "        if trust is None:",
            "            self._fail_pin_auth()",
            "            bad_cookie = True",
            "",
            "        # If we're trusted, we're authenticated.",
            "        elif trust:",
            "            auth = True",
            "",
            "        # If we failed too many times, then we're locked out.",
            "        elif self._failed_pin_auth > 10:",
            "            exhausted = True",
            "",
            "        # Otherwise go through pin based authentication",
            "        else:",
            "            entered_pin = request.args[\"pin\"]",
            "",
            "            if entered_pin.strip().replace(\"-\", \"\") == pin.replace(\"-\", \"\"):",
            "                self._failed_pin_auth = 0",
            "                auth = True",
            "            else:",
            "                self._fail_pin_auth()",
            "",
            "        rv = Response(",
            "            json.dumps({\"auth\": auth, \"exhausted\": exhausted}),",
            "            mimetype=\"application/json\",",
            "        )",
            "        if auth:",
            "            rv.set_cookie(",
            "                self.pin_cookie_name,",
            "                f\"{int(time.time())}|{hash_pin(pin)}\",",
            "                httponly=True,",
            "                samesite=\"Strict\",",
            "                secure=request.is_secure,",
            "            )",
            "        elif bad_cookie:",
            "            rv.delete_cookie(self.pin_cookie_name)",
            "        return rv",
            "",
            "    def log_pin_request(self, request: Request) -> Response:",
            "        \"\"\"Log the pin if needed.\"\"\"",
            "        if not self.check_host_trust(request.environ):",
            "            return SecurityError()  # type: ignore[return-value]",
            "",
            "        if self.pin_logging and self.pin is not None:",
            "            _log(",
            "                \"info\", \" * To enable the debugger you need to enter the security pin:\"",
            "            )",
            "            _log(\"info\", \" * Debugger pin code: %s\", self.pin)",
            "        return Response(\"\")",
            "",
            "    def __call__(",
            "        self, environ: WSGIEnvironment, start_response: StartResponse",
            "    ) -> t.Iterable[bytes]:",
            "        \"\"\"Dispatch the requests.\"\"\"",
            "        # important: don't ever access a function here that reads the incoming",
            "        # form data!  Otherwise the application won't have access to that data",
            "        # any more!",
            "        request = Request(environ)",
            "        response = self.debug_application",
            "        if request.args.get(\"__debugger__\") == \"yes\":",
            "            cmd = request.args.get(\"cmd\")",
            "            arg = request.args.get(\"f\")",
            "            secret = request.args.get(\"s\")",
            "            frame = self.frames.get(request.args.get(\"frm\", type=int))  # type: ignore",
            "            if cmd == \"resource\" and arg:",
            "                response = self.get_resource(request, arg)  # type: ignore",
            "            elif cmd == \"pinauth\" and secret == self.secret:",
            "                response = self.pin_auth(request)  # type: ignore",
            "            elif cmd == \"printpin\" and secret == self.secret:",
            "                response = self.log_pin_request(request)  # type: ignore",
            "            elif (",
            "                self.evalex",
            "                and cmd is not None",
            "                and frame is not None",
            "                and self.secret == secret",
            "                and self.check_pin_trust(environ)",
            "            ):",
            "                response = self.execute_command(request, cmd, frame)  # type: ignore",
            "        elif (",
            "            self.evalex",
            "            and self.console_path is not None",
            "            and request.path == self.console_path",
            "        ):",
            "            response = self.display_console(request)  # type: ignore",
            "        return response(environ, start_response)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "347": [
                "DebuggedApplication",
                "debug_application"
            ],
            "492": [
                "DebuggedApplication",
                "log_pin_request"
            ],
            "520": [
                "DebuggedApplication",
                "__call__"
            ]
        },
        "addLocation": [
            "django.db.models.sql.query.Query.clear_ordering",
            "src.werkzeug.debug.DebuggedApplication",
            "src.werkzeug.debug.DebuggedApplication.self"
        ]
    },
    "src/werkzeug/sansio/utils.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from ..urls import uri_to_iri"
            },
            "1": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def host_is_trusted(hostname: str, trusted_list: t.Iterable[str]) -> bool:"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+def host_is_trusted(hostname: str | None, trusted_list: t.Iterable[str]) -> bool:"
            },
            "5": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": "     \"\"\"Check if a host matches a list of trusted names."
            },
            "6": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": "     :param hostname: The name to check."
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "import typing as t",
            "from urllib.parse import quote",
            "",
            "from .._internal import _plain_int",
            "from ..exceptions import SecurityError",
            "from ..urls import uri_to_iri",
            "",
            "",
            "def host_is_trusted(hostname: str, trusted_list: t.Iterable[str]) -> bool:",
            "    \"\"\"Check if a host matches a list of trusted names.",
            "",
            "    :param hostname: The name to check.",
            "    :param trusted_list: A list of valid names to match. If a name",
            "        starts with a dot it will match all subdomains.",
            "",
            "    .. versionadded:: 0.9",
            "    \"\"\"",
            "    if not hostname:",
            "        return False",
            "",
            "    try:",
            "        hostname = hostname.partition(\":\")[0].encode(\"idna\").decode(\"ascii\")",
            "    except UnicodeEncodeError:",
            "        return False",
            "",
            "    if isinstance(trusted_list, str):",
            "        trusted_list = [trusted_list]",
            "",
            "    for ref in trusted_list:",
            "        if ref.startswith(\".\"):",
            "            ref = ref[1:]",
            "            suffix_match = True",
            "        else:",
            "            suffix_match = False",
            "",
            "        try:",
            "            ref = ref.partition(\":\")[0].encode(\"idna\").decode(\"ascii\")",
            "        except UnicodeEncodeError:",
            "            return False",
            "",
            "        if ref == hostname or (suffix_match and hostname.endswith(f\".{ref}\")):",
            "            return True",
            "",
            "    return False",
            "",
            "",
            "def get_host(",
            "    scheme: str,",
            "    host_header: str | None,",
            "    server: tuple[str, int | None] | None = None,",
            "    trusted_hosts: t.Iterable[str] | None = None,",
            ") -> str:",
            "    \"\"\"Return the host for the given parameters.",
            "",
            "    This first checks the ``host_header``. If it's not present, then",
            "    ``server`` is used. The host will only contain the port if it is",
            "    different than the standard port for the protocol.",
            "",
            "    Optionally, verify that the host is trusted using",
            "    :func:`host_is_trusted` and raise a",
            "    :exc:`~werkzeug.exceptions.SecurityError` if it is not.",
            "",
            "    :param scheme: The protocol the request used, like ``\"https\"``.",
            "    :param host_header: The ``Host`` header value.",
            "    :param server: Address of the server. ``(host, port)``, or",
            "        ``(path, None)`` for unix sockets.",
            "    :param trusted_hosts: A list of trusted host names.",
            "",
            "    :return: Host, with port if necessary.",
            "    :raise ~werkzeug.exceptions.SecurityError: If the host is not",
            "        trusted.",
            "    \"\"\"",
            "    host = \"\"",
            "",
            "    if host_header is not None:",
            "        host = host_header",
            "    elif server is not None:",
            "        host = server[0]",
            "",
            "        if server[1] is not None:",
            "            host = f\"{host}:{server[1]}\"",
            "",
            "    if scheme in {\"http\", \"ws\"} and host.endswith(\":80\"):",
            "        host = host[:-3]",
            "    elif scheme in {\"https\", \"wss\"} and host.endswith(\":443\"):",
            "        host = host[:-4]",
            "",
            "    if trusted_hosts is not None:",
            "        if not host_is_trusted(host, trusted_hosts):",
            "            raise SecurityError(f\"Host {host!r} is not trusted.\")",
            "",
            "    return host",
            "",
            "",
            "def get_current_url(",
            "    scheme: str,",
            "    host: str,",
            "    root_path: str | None = None,",
            "    path: str | None = None,",
            "    query_string: bytes | None = None,",
            ") -> str:",
            "    \"\"\"Recreate the URL for a request. If an optional part isn't",
            "    provided, it and subsequent parts are not included in the URL.",
            "",
            "    The URL is an IRI, not a URI, so it may contain Unicode characters.",
            "    Use :func:`~werkzeug.urls.iri_to_uri` to convert it to ASCII.",
            "",
            "    :param scheme: The protocol the request used, like ``\"https\"``.",
            "    :param host: The host the request was made to. See :func:`get_host`.",
            "    :param root_path: Prefix that the application is mounted under. This",
            "        is prepended to ``path``.",
            "    :param path: The path part of the URL after ``root_path``.",
            "    :param query_string: The portion of the URL after the \"?\".",
            "    \"\"\"",
            "    url = [scheme, \"://\", host]",
            "",
            "    if root_path is None:",
            "        url.append(\"/\")",
            "        return uri_to_iri(\"\".join(url))",
            "",
            "    # safe = https://url.spec.whatwg.org/#url-path-segment-string",
            "    # as well as percent for things that are already quoted",
            "    url.append(quote(root_path.rstrip(\"/\"), safe=\"!$&'()*+,/:;=@%\"))",
            "    url.append(\"/\")",
            "",
            "    if path is None:",
            "        return uri_to_iri(\"\".join(url))",
            "",
            "    url.append(quote(path.lstrip(\"/\"), safe=\"!$&'()*+,/:;=@%\"))",
            "",
            "    if query_string:",
            "        url.append(\"?\")",
            "        url.append(quote(query_string, safe=\"!$&'()*+,/:;=?@%\"))",
            "",
            "    return uri_to_iri(\"\".join(url))",
            "",
            "",
            "def get_content_length(",
            "    http_content_length: str | None = None,",
            "    http_transfer_encoding: str | None = None,",
            ") -> int | None:",
            "    \"\"\"Return the ``Content-Length`` header value as an int. If the header is not given",
            "    or the ``Transfer-Encoding`` header is ``chunked``, ``None`` is returned to indicate",
            "    a streaming request. If the value is not an integer, or negative, 0 is returned.",
            "",
            "    :param http_content_length: The Content-Length HTTP header.",
            "    :param http_transfer_encoding: The Transfer-Encoding HTTP header.",
            "",
            "    .. versionadded:: 2.2",
            "    \"\"\"",
            "    if http_transfer_encoding == \"chunked\" or http_content_length is None:",
            "        return None",
            "",
            "    try:",
            "        return max(0, _plain_int(http_content_length))",
            "    except ValueError:",
            "        return 0"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "import typing as t",
            "from urllib.parse import quote",
            "",
            "from .._internal import _plain_int",
            "from ..exceptions import SecurityError",
            "from ..urls import uri_to_iri",
            "",
            "",
            "def host_is_trusted(hostname: str | None, trusted_list: t.Iterable[str]) -> bool:",
            "    \"\"\"Check if a host matches a list of trusted names.",
            "",
            "    :param hostname: The name to check.",
            "    :param trusted_list: A list of valid names to match. If a name",
            "        starts with a dot it will match all subdomains.",
            "",
            "    .. versionadded:: 0.9",
            "    \"\"\"",
            "    if not hostname:",
            "        return False",
            "",
            "    try:",
            "        hostname = hostname.partition(\":\")[0].encode(\"idna\").decode(\"ascii\")",
            "    except UnicodeEncodeError:",
            "        return False",
            "",
            "    if isinstance(trusted_list, str):",
            "        trusted_list = [trusted_list]",
            "",
            "    for ref in trusted_list:",
            "        if ref.startswith(\".\"):",
            "            ref = ref[1:]",
            "            suffix_match = True",
            "        else:",
            "            suffix_match = False",
            "",
            "        try:",
            "            ref = ref.partition(\":\")[0].encode(\"idna\").decode(\"ascii\")",
            "        except UnicodeEncodeError:",
            "            return False",
            "",
            "        if ref == hostname or (suffix_match and hostname.endswith(f\".{ref}\")):",
            "            return True",
            "",
            "    return False",
            "",
            "",
            "def get_host(",
            "    scheme: str,",
            "    host_header: str | None,",
            "    server: tuple[str, int | None] | None = None,",
            "    trusted_hosts: t.Iterable[str] | None = None,",
            ") -> str:",
            "    \"\"\"Return the host for the given parameters.",
            "",
            "    This first checks the ``host_header``. If it's not present, then",
            "    ``server`` is used. The host will only contain the port if it is",
            "    different than the standard port for the protocol.",
            "",
            "    Optionally, verify that the host is trusted using",
            "    :func:`host_is_trusted` and raise a",
            "    :exc:`~werkzeug.exceptions.SecurityError` if it is not.",
            "",
            "    :param scheme: The protocol the request used, like ``\"https\"``.",
            "    :param host_header: The ``Host`` header value.",
            "    :param server: Address of the server. ``(host, port)``, or",
            "        ``(path, None)`` for unix sockets.",
            "    :param trusted_hosts: A list of trusted host names.",
            "",
            "    :return: Host, with port if necessary.",
            "    :raise ~werkzeug.exceptions.SecurityError: If the host is not",
            "        trusted.",
            "    \"\"\"",
            "    host = \"\"",
            "",
            "    if host_header is not None:",
            "        host = host_header",
            "    elif server is not None:",
            "        host = server[0]",
            "",
            "        if server[1] is not None:",
            "            host = f\"{host}:{server[1]}\"",
            "",
            "    if scheme in {\"http\", \"ws\"} and host.endswith(\":80\"):",
            "        host = host[:-3]",
            "    elif scheme in {\"https\", \"wss\"} and host.endswith(\":443\"):",
            "        host = host[:-4]",
            "",
            "    if trusted_hosts is not None:",
            "        if not host_is_trusted(host, trusted_hosts):",
            "            raise SecurityError(f\"Host {host!r} is not trusted.\")",
            "",
            "    return host",
            "",
            "",
            "def get_current_url(",
            "    scheme: str,",
            "    host: str,",
            "    root_path: str | None = None,",
            "    path: str | None = None,",
            "    query_string: bytes | None = None,",
            ") -> str:",
            "    \"\"\"Recreate the URL for a request. If an optional part isn't",
            "    provided, it and subsequent parts are not included in the URL.",
            "",
            "    The URL is an IRI, not a URI, so it may contain Unicode characters.",
            "    Use :func:`~werkzeug.urls.iri_to_uri` to convert it to ASCII.",
            "",
            "    :param scheme: The protocol the request used, like ``\"https\"``.",
            "    :param host: The host the request was made to. See :func:`get_host`.",
            "    :param root_path: Prefix that the application is mounted under. This",
            "        is prepended to ``path``.",
            "    :param path: The path part of the URL after ``root_path``.",
            "    :param query_string: The portion of the URL after the \"?\".",
            "    \"\"\"",
            "    url = [scheme, \"://\", host]",
            "",
            "    if root_path is None:",
            "        url.append(\"/\")",
            "        return uri_to_iri(\"\".join(url))",
            "",
            "    # safe = https://url.spec.whatwg.org/#url-path-segment-string",
            "    # as well as percent for things that are already quoted",
            "    url.append(quote(root_path.rstrip(\"/\"), safe=\"!$&'()*+,/:;=@%\"))",
            "    url.append(\"/\")",
            "",
            "    if path is None:",
            "        return uri_to_iri(\"\".join(url))",
            "",
            "    url.append(quote(path.lstrip(\"/\"), safe=\"!$&'()*+,/:;=@%\"))",
            "",
            "    if query_string:",
            "        url.append(\"?\")",
            "        url.append(quote(query_string, safe=\"!$&'()*+,/:;=?@%\"))",
            "",
            "    return uri_to_iri(\"\".join(url))",
            "",
            "",
            "def get_content_length(",
            "    http_content_length: str | None = None,",
            "    http_transfer_encoding: str | None = None,",
            ") -> int | None:",
            "    \"\"\"Return the ``Content-Length`` header value as an int. If the header is not given",
            "    or the ``Transfer-Encoding`` header is ``chunked``, ``None`` is returned to indicate",
            "    a streaming request. If the value is not an integer, or negative, 0 is returned.",
            "",
            "    :param http_content_length: The Content-Length HTTP header.",
            "    :param http_transfer_encoding: The Transfer-Encoding HTTP header.",
            "",
            "    .. versionadded:: 2.2",
            "    \"\"\"",
            "    if http_transfer_encoding == \"chunked\" or http_content_length is None:",
            "        return None",
            "",
            "    try:",
            "        return max(0, _plain_int(http_content_length))",
            "    except ValueError:",
            "        return 0"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "11": [
                "host_is_trusted"
            ]
        },
        "addLocation": []
    },
    "src/werkzeug/serving.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1072,
                "afterPatchRowNumber": 1072,
                "PatchRowcode": "         from .debug import DebuggedApplication"
            },
            "1": {
                "beforePatchRowNumber": 1073,
                "afterPatchRowNumber": 1073,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 1074,
                "afterPatchRowNumber": 1074,
                "PatchRowcode": "         application = DebuggedApplication(application, evalex=use_evalex)"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1075,
                "PatchRowcode": "+        # Allow the specified hostname to use the debugger, in addition to"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1076,
                "PatchRowcode": "+        # localhost domains."
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1077,
                "PatchRowcode": "+        application.trusted_hosts.append(hostname)"
            },
            "6": {
                "beforePatchRowNumber": 1075,
                "afterPatchRowNumber": 1078,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 1076,
                "afterPatchRowNumber": 1079,
                "PatchRowcode": "     if not is_running_from_reloader():"
            },
            "8": {
                "beforePatchRowNumber": 1077,
                "afterPatchRowNumber": 1080,
                "PatchRowcode": "         fd = None"
            }
        },
        "frontPatchFile": [
            "\"\"\"A WSGI and HTTP server for use **during development only**. This",
            "server is convenient to use, but is not designed to be particularly",
            "stable, secure, or efficient. Use a dedicate WSGI server and HTTP",
            "server when deploying to production.",
            "",
            "It provides features like interactive debugging and code reloading. Use",
            "``run_simple`` to start the server. Put this in a ``run.py`` script:",
            "",
            ".. code-block:: python",
            "",
            "    from myapp import create_app",
            "    from werkzeug import run_simple",
            "\"\"\"",
            "",
            "from __future__ import annotations",
            "",
            "import errno",
            "import io",
            "import os",
            "import selectors",
            "import socket",
            "import socketserver",
            "import sys",
            "import typing as t",
            "from datetime import datetime as dt",
            "from datetime import timedelta",
            "from datetime import timezone",
            "from http.server import BaseHTTPRequestHandler",
            "from http.server import HTTPServer",
            "from urllib.parse import unquote",
            "from urllib.parse import urlsplit",
            "",
            "from ._internal import _log",
            "from ._internal import _wsgi_encoding_dance",
            "from .exceptions import InternalServerError",
            "from .urls import uri_to_iri",
            "",
            "try:",
            "    import ssl",
            "except ImportError:",
            "",
            "    class _SslDummy:",
            "        def __getattr__(self, name: str) -> t.Any:",
            "            raise RuntimeError(  # noqa: B904",
            "                \"SSL is unavailable because this Python runtime was not\"",
            "                \" compiled with SSL/TLS support.\"",
            "            )",
            "",
            "    ssl = _SslDummy()  # type: ignore",
            "",
            "_log_add_style = True",
            "",
            "if os.name == \"nt\":",
            "    try:",
            "        __import__(\"colorama\")",
            "    except ImportError:",
            "        _log_add_style = False",
            "",
            "can_fork = hasattr(os, \"fork\")",
            "",
            "if can_fork:",
            "    ForkingMixIn = socketserver.ForkingMixIn",
            "else:",
            "",
            "    class ForkingMixIn:  # type: ignore",
            "        pass",
            "",
            "",
            "try:",
            "    af_unix = socket.AF_UNIX",
            "except AttributeError:",
            "    af_unix = None  # type: ignore",
            "",
            "LISTEN_QUEUE = 128",
            "",
            "_TSSLContextArg = t.Optional[",
            "    t.Union[\"ssl.SSLContext\", t.Tuple[str, t.Optional[str]], t.Literal[\"adhoc\"]]",
            "]",
            "",
            "if t.TYPE_CHECKING:",
            "    from _typeshed.wsgi import WSGIApplication",
            "    from _typeshed.wsgi import WSGIEnvironment",
            "    from cryptography.hazmat.primitives.asymmetric.rsa import (",
            "        RSAPrivateKeyWithSerialization,",
            "    )",
            "    from cryptography.x509 import Certificate",
            "",
            "",
            "class DechunkedInput(io.RawIOBase):",
            "    \"\"\"An input stream that handles Transfer-Encoding 'chunked'\"\"\"",
            "",
            "    def __init__(self, rfile: t.IO[bytes]) -> None:",
            "        self._rfile = rfile",
            "        self._done = False",
            "        self._len = 0",
            "",
            "    def readable(self) -> bool:",
            "        return True",
            "",
            "    def read_chunk_len(self) -> int:",
            "        try:",
            "            line = self._rfile.readline().decode(\"latin1\")",
            "            _len = int(line.strip(), 16)",
            "        except ValueError as e:",
            "            raise OSError(\"Invalid chunk header\") from e",
            "        if _len < 0:",
            "            raise OSError(\"Negative chunk length not allowed\")",
            "        return _len",
            "",
            "    def readinto(self, buf: bytearray) -> int:  # type: ignore",
            "        read = 0",
            "        while not self._done and read < len(buf):",
            "            if self._len == 0:",
            "                # This is the first chunk or we fully consumed the previous",
            "                # one. Read the next length of the next chunk",
            "                self._len = self.read_chunk_len()",
            "",
            "            if self._len == 0:",
            "                # Found the final chunk of size 0. The stream is now exhausted,",
            "                # but there is still a final newline that should be consumed",
            "                self._done = True",
            "",
            "            if self._len > 0:",
            "                # There is data (left) in this chunk, so append it to the",
            "                # buffer. If this operation fully consumes the chunk, this will",
            "                # reset self._len to 0.",
            "                n = min(len(buf), self._len)",
            "",
            "                # If (read + chunk size) becomes more than len(buf), buf will",
            "                # grow beyond the original size and read more data than",
            "                # required. So only read as much data as can fit in buf.",
            "                if read + n > len(buf):",
            "                    buf[read:] = self._rfile.read(len(buf) - read)",
            "                    self._len -= len(buf) - read",
            "                    read = len(buf)",
            "                else:",
            "                    buf[read : read + n] = self._rfile.read(n)",
            "                    self._len -= n",
            "                    read += n",
            "",
            "            if self._len == 0:",
            "                # Skip the terminating newline of a chunk that has been fully",
            "                # consumed. This also applies to the 0-sized final chunk",
            "                terminator = self._rfile.readline()",
            "                if terminator not in (b\"\\n\", b\"\\r\\n\", b\"\\r\"):",
            "                    raise OSError(\"Missing chunk terminating newline\")",
            "",
            "        return read",
            "",
            "",
            "class WSGIRequestHandler(BaseHTTPRequestHandler):",
            "    \"\"\"A request handler that implements WSGI dispatching.\"\"\"",
            "",
            "    server: BaseWSGIServer",
            "",
            "    @property",
            "    def server_version(self) -> str:  # type: ignore",
            "        return self.server._server_version",
            "",
            "    def make_environ(self) -> WSGIEnvironment:",
            "        request_url = urlsplit(self.path)",
            "        url_scheme = \"http\" if self.server.ssl_context is None else \"https\"",
            "",
            "        if not self.client_address:",
            "            self.client_address = (\"<local>\", 0)",
            "        elif isinstance(self.client_address, str):",
            "            self.client_address = (self.client_address, 0)",
            "",
            "        # If there was no scheme but the path started with two slashes,",
            "        # the first segment may have been incorrectly parsed as the",
            "        # netloc, prepend it to the path again.",
            "        if not request_url.scheme and request_url.netloc:",
            "            path_info = f\"/{request_url.netloc}{request_url.path}\"",
            "        else:",
            "            path_info = request_url.path",
            "",
            "        path_info = unquote(path_info)",
            "",
            "        environ: WSGIEnvironment = {",
            "            \"wsgi.version\": (1, 0),",
            "            \"wsgi.url_scheme\": url_scheme,",
            "            \"wsgi.input\": self.rfile,",
            "            \"wsgi.errors\": sys.stderr,",
            "            \"wsgi.multithread\": self.server.multithread,",
            "            \"wsgi.multiprocess\": self.server.multiprocess,",
            "            \"wsgi.run_once\": False,",
            "            \"werkzeug.socket\": self.connection,",
            "            \"SERVER_SOFTWARE\": self.server_version,",
            "            \"REQUEST_METHOD\": self.command,",
            "            \"SCRIPT_NAME\": \"\",",
            "            \"PATH_INFO\": _wsgi_encoding_dance(path_info),",
            "            \"QUERY_STRING\": _wsgi_encoding_dance(request_url.query),",
            "            # Non-standard, added by mod_wsgi, uWSGI",
            "            \"REQUEST_URI\": _wsgi_encoding_dance(self.path),",
            "            # Non-standard, added by gunicorn",
            "            \"RAW_URI\": _wsgi_encoding_dance(self.path),",
            "            \"REMOTE_ADDR\": self.address_string(),",
            "            \"REMOTE_PORT\": self.port_integer(),",
            "            \"SERVER_NAME\": self.server.server_address[0],",
            "            \"SERVER_PORT\": str(self.server.server_address[1]),",
            "            \"SERVER_PROTOCOL\": self.request_version,",
            "        }",
            "",
            "        for key, value in self.headers.items():",
            "            if \"_\" in key:",
            "                continue",
            "",
            "            key = key.upper().replace(\"-\", \"_\")",
            "            value = value.replace(\"\\r\\n\", \"\")",
            "            if key not in (\"CONTENT_TYPE\", \"CONTENT_LENGTH\"):",
            "                key = f\"HTTP_{key}\"",
            "                if key in environ:",
            "                    value = f\"{environ[key]},{value}\"",
            "            environ[key] = value",
            "",
            "        if environ.get(\"HTTP_TRANSFER_ENCODING\", \"\").strip().lower() == \"chunked\":",
            "            environ[\"wsgi.input_terminated\"] = True",
            "            environ[\"wsgi.input\"] = DechunkedInput(environ[\"wsgi.input\"])",
            "",
            "        # Per RFC 2616, if the URL is absolute, use that as the host.",
            "        # We're using \"has a scheme\" to indicate an absolute URL.",
            "        if request_url.scheme and request_url.netloc:",
            "            environ[\"HTTP_HOST\"] = request_url.netloc",
            "",
            "        try:",
            "            # binary_form=False gives nicer information, but wouldn't be compatible with",
            "            # what Nginx or Apache could return.",
            "            peer_cert = self.connection.getpeercert(binary_form=True)",
            "            if peer_cert is not None:",
            "                # Nginx and Apache use PEM format.",
            "                environ[\"SSL_CLIENT_CERT\"] = ssl.DER_cert_to_PEM_cert(peer_cert)",
            "        except ValueError:",
            "            # SSL handshake hasn't finished.",
            "            self.server.log(\"error\", \"Cannot fetch SSL peer certificate info\")",
            "        except AttributeError:",
            "            # Not using TLS, the socket will not have getpeercert().",
            "            pass",
            "",
            "        return environ",
            "",
            "    def run_wsgi(self) -> None:",
            "        if self.headers.get(\"Expect\", \"\").lower().strip() == \"100-continue\":",
            "            self.wfile.write(b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\")",
            "",
            "        self.environ = environ = self.make_environ()",
            "        status_set: str | None = None",
            "        headers_set: list[tuple[str, str]] | None = None",
            "        status_sent: str | None = None",
            "        headers_sent: list[tuple[str, str]] | None = None",
            "        chunk_response: bool = False",
            "",
            "        def write(data: bytes) -> None:",
            "            nonlocal status_sent, headers_sent, chunk_response",
            "            assert status_set is not None, \"write() before start_response\"",
            "            assert headers_set is not None, \"write() before start_response\"",
            "            if status_sent is None:",
            "                status_sent = status_set",
            "                headers_sent = headers_set",
            "                try:",
            "                    code_str, msg = status_sent.split(None, 1)",
            "                except ValueError:",
            "                    code_str, msg = status_sent, \"\"",
            "                code = int(code_str)",
            "                self.send_response(code, msg)",
            "                header_keys = set()",
            "                for key, value in headers_sent:",
            "                    self.send_header(key, value)",
            "                    header_keys.add(key.lower())",
            "",
            "                # Use chunked transfer encoding if there is no content",
            "                # length. Do not use for 1xx and 204 responses. 304",
            "                # responses and HEAD requests are also excluded, which",
            "                # is the more conservative behavior and matches other",
            "                # parts of the code.",
            "                # https://httpwg.org/specs/rfc7230.html#rfc.section.3.3.1",
            "                if (",
            "                    not (",
            "                        \"content-length\" in header_keys",
            "                        or environ[\"REQUEST_METHOD\"] == \"HEAD\"",
            "                        or (100 <= code < 200)",
            "                        or code in {204, 304}",
            "                    )",
            "                    and self.protocol_version >= \"HTTP/1.1\"",
            "                ):",
            "                    chunk_response = True",
            "                    self.send_header(\"Transfer-Encoding\", \"chunked\")",
            "",
            "                # Always close the connection. This disables HTTP/1.1",
            "                # keep-alive connections. They aren't handled well by",
            "                # Python's http.server because it doesn't know how to",
            "                # drain the stream before the next request line.",
            "                self.send_header(\"Connection\", \"close\")",
            "                self.end_headers()",
            "",
            "            assert isinstance(data, bytes), \"applications must write bytes\"",
            "",
            "            if data:",
            "                if chunk_response:",
            "                    self.wfile.write(hex(len(data))[2:].encode())",
            "                    self.wfile.write(b\"\\r\\n\")",
            "",
            "                self.wfile.write(data)",
            "",
            "                if chunk_response:",
            "                    self.wfile.write(b\"\\r\\n\")",
            "",
            "            self.wfile.flush()",
            "",
            "        def start_response(status, headers, exc_info=None):  # type: ignore",
            "            nonlocal status_set, headers_set",
            "            if exc_info:",
            "                try:",
            "                    if headers_sent:",
            "                        raise exc_info[1].with_traceback(exc_info[2])",
            "                finally:",
            "                    exc_info = None",
            "            elif headers_set:",
            "                raise AssertionError(\"Headers already set\")",
            "            status_set = status",
            "            headers_set = headers",
            "            return write",
            "",
            "        def execute(app: WSGIApplication) -> None:",
            "            application_iter = app(environ, start_response)",
            "            try:",
            "                for data in application_iter:",
            "                    write(data)",
            "                if not headers_sent:",
            "                    write(b\"\")",
            "                if chunk_response:",
            "                    self.wfile.write(b\"0\\r\\n\\r\\n\")",
            "            finally:",
            "                # Check for any remaining data in the read socket, and discard it. This",
            "                # will read past request.max_content_length, but lets the client see a",
            "                # 413 response instead of a connection reset failure. If we supported",
            "                # keep-alive connections, this naive approach would break by reading the",
            "                # next request line. Since we know that write (above) closes every",
            "                # connection we can read everything.",
            "                selector = selectors.DefaultSelector()",
            "                selector.register(self.connection, selectors.EVENT_READ)",
            "                total_size = 0",
            "                total_reads = 0",
            "",
            "                # A timeout of 0 tends to fail because a client needs a small amount of",
            "                # time to continue sending its data.",
            "                while selector.select(timeout=0.01):",
            "                    # Only read 10MB into memory at a time.",
            "                    data = self.rfile.read(10_000_000)",
            "                    total_size += len(data)",
            "                    total_reads += 1",
            "",
            "                    # Stop reading on no data, >=10GB, or 1000 reads. If a client sends",
            "                    # more than that, they'll get a connection reset failure.",
            "                    if not data or total_size >= 10_000_000_000 or total_reads > 1000:",
            "                        break",
            "",
            "                selector.close()",
            "",
            "                if hasattr(application_iter, \"close\"):",
            "                    application_iter.close()",
            "",
            "        try:",
            "            execute(self.server.app)",
            "        except (ConnectionError, socket.timeout) as e:",
            "            self.connection_dropped(e, environ)",
            "        except Exception as e:",
            "            if self.server.passthrough_errors:",
            "                raise",
            "",
            "            if status_sent is not None and chunk_response:",
            "                self.close_connection = True",
            "",
            "            try:",
            "                # if we haven't yet sent the headers but they are set",
            "                # we roll back to be able to set them again.",
            "                if status_sent is None:",
            "                    status_set = None",
            "                    headers_set = None",
            "                execute(InternalServerError())",
            "            except Exception:",
            "                pass",
            "",
            "            from .debug.tbtools import DebugTraceback",
            "",
            "            msg = DebugTraceback(e).render_traceback_text()",
            "            self.server.log(\"error\", f\"Error on request:\\n{msg}\")",
            "",
            "    def handle(self) -> None:",
            "        \"\"\"Handles a request ignoring dropped connections.\"\"\"",
            "        try:",
            "            super().handle()",
            "        except (ConnectionError, socket.timeout) as e:",
            "            self.connection_dropped(e)",
            "        except Exception as e:",
            "            if self.server.ssl_context is not None and is_ssl_error(e):",
            "                self.log_error(\"SSL error occurred: %s\", e)",
            "            else:",
            "                raise",
            "",
            "    def connection_dropped(",
            "        self, error: BaseException, environ: WSGIEnvironment | None = None",
            "    ) -> None:",
            "        \"\"\"Called if the connection was closed by the client.  By default",
            "        nothing happens.",
            "        \"\"\"",
            "",
            "    def __getattr__(self, name: str) -> t.Any:",
            "        # All HTTP methods are handled by run_wsgi.",
            "        if name.startswith(\"do_\"):",
            "            return self.run_wsgi",
            "",
            "        # All other attributes are forwarded to the base class.",
            "        return getattr(super(), name)",
            "",
            "    def address_string(self) -> str:",
            "        if getattr(self, \"environ\", None):",
            "            return self.environ[\"REMOTE_ADDR\"]  # type: ignore",
            "",
            "        if not self.client_address:",
            "            return \"<local>\"",
            "",
            "        return self.client_address[0]",
            "",
            "    def port_integer(self) -> int:",
            "        return self.client_address[1]",
            "",
            "    # Escape control characters. This is defined (but private) in Python 3.12.",
            "    _control_char_table = str.maketrans(",
            "        {c: rf\"\\x{c:02x}\" for c in [*range(0x20), *range(0x7F, 0xA0)]}",
            "    )",
            "    _control_char_table[ord(\"\\\\\")] = r\"\\\\\"",
            "",
            "    def log_request(self, code: int | str = \"-\", size: int | str = \"-\") -> None:",
            "        try:",
            "            path = uri_to_iri(self.path)",
            "            msg = f\"{self.command} {path} {self.request_version}\"",
            "        except AttributeError:",
            "            # path isn't set if the requestline was bad",
            "            msg = self.requestline",
            "",
            "        # Escape control characters that may be in the decoded path.",
            "        msg = msg.translate(self._control_char_table)",
            "        code = str(code)",
            "",
            "        if code[0] == \"1\":  # 1xx - Informational",
            "            msg = _ansi_style(msg, \"bold\")",
            "        elif code == \"200\":  # 2xx - Success",
            "            pass",
            "        elif code == \"304\":  # 304 - Resource Not Modified",
            "            msg = _ansi_style(msg, \"cyan\")",
            "        elif code[0] == \"3\":  # 3xx - Redirection",
            "            msg = _ansi_style(msg, \"green\")",
            "        elif code == \"404\":  # 404 - Resource Not Found",
            "            msg = _ansi_style(msg, \"yellow\")",
            "        elif code[0] == \"4\":  # 4xx - Client Error",
            "            msg = _ansi_style(msg, \"bold\", \"red\")",
            "        else:  # 5xx, or any other response",
            "            msg = _ansi_style(msg, \"bold\", \"magenta\")",
            "",
            "        self.log(\"info\", '\"%s\" %s %s', msg, code, size)",
            "",
            "    def log_error(self, format: str, *args: t.Any) -> None:",
            "        self.log(\"error\", format, *args)",
            "",
            "    def log_message(self, format: str, *args: t.Any) -> None:",
            "        self.log(\"info\", format, *args)",
            "",
            "    def log(self, type: str, message: str, *args: t.Any) -> None:",
            "        _log(",
            "            type,",
            "            f\"{self.address_string()} - - [{self.log_date_time_string()}] {message}\\n\",",
            "            *args,",
            "        )",
            "",
            "",
            "def _ansi_style(value: str, *styles: str) -> str:",
            "    if not _log_add_style:",
            "        return value",
            "",
            "    codes = {",
            "        \"bold\": 1,",
            "        \"red\": 31,",
            "        \"green\": 32,",
            "        \"yellow\": 33,",
            "        \"magenta\": 35,",
            "        \"cyan\": 36,",
            "    }",
            "",
            "    for style in styles:",
            "        value = f\"\\x1b[{codes[style]}m{value}\"",
            "",
            "    return f\"{value}\\x1b[0m\"",
            "",
            "",
            "def generate_adhoc_ssl_pair(",
            "    cn: str | None = None,",
            ") -> tuple[Certificate, RSAPrivateKeyWithSerialization]:",
            "    try:",
            "        from cryptography import x509",
            "        from cryptography.hazmat.backends import default_backend",
            "        from cryptography.hazmat.primitives import hashes",
            "        from cryptography.hazmat.primitives.asymmetric import rsa",
            "        from cryptography.x509.oid import NameOID",
            "    except ImportError:",
            "        raise TypeError(",
            "            \"Using ad-hoc certificates requires the cryptography library.\"",
            "        ) from None",
            "",
            "    backend = default_backend()",
            "    pkey = rsa.generate_private_key(",
            "        public_exponent=65537, key_size=2048, backend=backend",
            "    )",
            "",
            "    # pretty damn sure that this is not actually accepted by anyone",
            "    if cn is None:",
            "        cn = \"*\"",
            "",
            "    subject = x509.Name(",
            "        [",
            "            x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"Dummy Certificate\"),",
            "            x509.NameAttribute(NameOID.COMMON_NAME, cn),",
            "        ]",
            "    )",
            "",
            "    backend = default_backend()",
            "    cert = (",
            "        x509.CertificateBuilder()",
            "        .subject_name(subject)",
            "        .issuer_name(subject)",
            "        .public_key(pkey.public_key())",
            "        .serial_number(x509.random_serial_number())",
            "        .not_valid_before(dt.now(timezone.utc))",
            "        .not_valid_after(dt.now(timezone.utc) + timedelta(days=365))",
            "        .add_extension(x509.ExtendedKeyUsage([x509.OID_SERVER_AUTH]), critical=False)",
            "        .add_extension(",
            "            x509.SubjectAlternativeName([x509.DNSName(cn), x509.DNSName(f\"*.{cn}\")]),",
            "            critical=False,",
            "        )",
            "        .sign(pkey, hashes.SHA256(), backend)",
            "    )",
            "    return cert, pkey",
            "",
            "",
            "def make_ssl_devcert(",
            "    base_path: str, host: str | None = None, cn: str | None = None",
            ") -> tuple[str, str]:",
            "    \"\"\"Creates an SSL key for development.  This should be used instead of",
            "    the ``'adhoc'`` key which generates a new cert on each server start.",
            "    It accepts a path for where it should store the key and cert and",
            "    either a host or CN.  If a host is given it will use the CN",
            "    ``*.host/CN=host``.",
            "",
            "    For more information see :func:`run_simple`.",
            "",
            "    .. versionadded:: 0.9",
            "",
            "    :param base_path: the path to the certificate and key.  The extension",
            "                      ``.crt`` is added for the certificate, ``.key`` is",
            "                      added for the key.",
            "    :param host: the name of the host.  This can be used as an alternative",
            "                 for the `cn`.",
            "    :param cn: the `CN` to use.",
            "    \"\"\"",
            "",
            "    if host is not None:",
            "        cn = host",
            "    cert, pkey = generate_adhoc_ssl_pair(cn=cn)",
            "",
            "    from cryptography.hazmat.primitives import serialization",
            "",
            "    cert_file = f\"{base_path}.crt\"",
            "    pkey_file = f\"{base_path}.key\"",
            "",
            "    with open(cert_file, \"wb\") as f:",
            "        f.write(cert.public_bytes(serialization.Encoding.PEM))",
            "    with open(pkey_file, \"wb\") as f:",
            "        f.write(",
            "            pkey.private_bytes(",
            "                encoding=serialization.Encoding.PEM,",
            "                format=serialization.PrivateFormat.TraditionalOpenSSL,",
            "                encryption_algorithm=serialization.NoEncryption(),",
            "            )",
            "        )",
            "",
            "    return cert_file, pkey_file",
            "",
            "",
            "def generate_adhoc_ssl_context() -> ssl.SSLContext:",
            "    \"\"\"Generates an adhoc SSL context for the development server.\"\"\"",
            "    import atexit",
            "    import tempfile",
            "",
            "    cert, pkey = generate_adhoc_ssl_pair()",
            "",
            "    from cryptography.hazmat.primitives import serialization",
            "",
            "    cert_handle, cert_file = tempfile.mkstemp()",
            "    pkey_handle, pkey_file = tempfile.mkstemp()",
            "    atexit.register(os.remove, pkey_file)",
            "    atexit.register(os.remove, cert_file)",
            "",
            "    os.write(cert_handle, cert.public_bytes(serialization.Encoding.PEM))",
            "    os.write(",
            "        pkey_handle,",
            "        pkey.private_bytes(",
            "            encoding=serialization.Encoding.PEM,",
            "            format=serialization.PrivateFormat.TraditionalOpenSSL,",
            "            encryption_algorithm=serialization.NoEncryption(),",
            "        ),",
            "    )",
            "",
            "    os.close(cert_handle)",
            "    os.close(pkey_handle)",
            "    ctx = load_ssl_context(cert_file, pkey_file)",
            "    return ctx",
            "",
            "",
            "def load_ssl_context(",
            "    cert_file: str, pkey_file: str | None = None, protocol: int | None = None",
            ") -> ssl.SSLContext:",
            "    \"\"\"Loads SSL context from cert/private key files and optional protocol.",
            "    Many parameters are directly taken from the API of",
            "    :py:class:`ssl.SSLContext`.",
            "",
            "    :param cert_file: Path of the certificate to use.",
            "    :param pkey_file: Path of the private key to use. If not given, the key",
            "                      will be obtained from the certificate file.",
            "    :param protocol: A ``PROTOCOL`` constant from the :mod:`ssl` module.",
            "        Defaults to :data:`ssl.PROTOCOL_TLS_SERVER`.",
            "    \"\"\"",
            "    if protocol is None:",
            "        protocol = ssl.PROTOCOL_TLS_SERVER",
            "",
            "    ctx = ssl.SSLContext(protocol)",
            "    ctx.load_cert_chain(cert_file, pkey_file)",
            "    return ctx",
            "",
            "",
            "def is_ssl_error(error: Exception | None = None) -> bool:",
            "    \"\"\"Checks if the given error (or the current one) is an SSL error.\"\"\"",
            "    if error is None:",
            "        error = t.cast(Exception, sys.exc_info()[1])",
            "    return isinstance(error, ssl.SSLError)",
            "",
            "",
            "def select_address_family(host: str, port: int) -> socket.AddressFamily:",
            "    \"\"\"Return ``AF_INET4``, ``AF_INET6``, or ``AF_UNIX`` depending on",
            "    the host and port.\"\"\"",
            "    if host.startswith(\"unix://\"):",
            "        return socket.AF_UNIX",
            "    elif \":\" in host and hasattr(socket, \"AF_INET6\"):",
            "        return socket.AF_INET6",
            "    return socket.AF_INET",
            "",
            "",
            "def get_sockaddr(",
            "    host: str, port: int, family: socket.AddressFamily",
            ") -> tuple[str, int] | str:",
            "    \"\"\"Return a fully qualified socket address that can be passed to",
            "    :func:`socket.bind`.\"\"\"",
            "    if family == af_unix:",
            "        # Absolute path avoids IDNA encoding error when path starts with dot.",
            "        return os.path.abspath(host.partition(\"://\")[2])",
            "    try:",
            "        res = socket.getaddrinfo(",
            "            host, port, family, socket.SOCK_STREAM, socket.IPPROTO_TCP",
            "        )",
            "    except socket.gaierror:",
            "        return host, port",
            "    return res[0][4]  # type: ignore",
            "",
            "",
            "def get_interface_ip(family: socket.AddressFamily) -> str:",
            "    \"\"\"Get the IP address of an external interface. Used when binding to",
            "    0.0.0.0 or ::1 to show a more useful URL.",
            "",
            "    :meta private:",
            "    \"\"\"",
            "    # arbitrary private address",
            "    host = \"fd31:f903:5ab5:1::1\" if family == socket.AF_INET6 else \"10.253.155.219\"",
            "",
            "    with socket.socket(family, socket.SOCK_DGRAM) as s:",
            "        try:",
            "            s.connect((host, 58162))",
            "        except OSError:",
            "            return \"::1\" if family == socket.AF_INET6 else \"127.0.0.1\"",
            "",
            "        return s.getsockname()[0]  # type: ignore",
            "",
            "",
            "class BaseWSGIServer(HTTPServer):",
            "    \"\"\"A WSGI server that that handles one request at a time.",
            "",
            "    Use :func:`make_server` to create a server instance.",
            "    \"\"\"",
            "",
            "    multithread = False",
            "    multiprocess = False",
            "    request_queue_size = LISTEN_QUEUE",
            "    allow_reuse_address = True",
            "",
            "    def __init__(",
            "        self,",
            "        host: str,",
            "        port: int,",
            "        app: WSGIApplication,",
            "        handler: type[WSGIRequestHandler] | None = None,",
            "        passthrough_errors: bool = False,",
            "        ssl_context: _TSSLContextArg | None = None,",
            "        fd: int | None = None,",
            "    ) -> None:",
            "        if handler is None:",
            "            handler = WSGIRequestHandler",
            "",
            "        # If the handler doesn't directly set a protocol version and",
            "        # thread or process workers are used, then allow chunked",
            "        # responses and keep-alive connections by enabling HTTP/1.1.",
            "        if \"protocol_version\" not in vars(handler) and (",
            "            self.multithread or self.multiprocess",
            "        ):",
            "            handler.protocol_version = \"HTTP/1.1\"",
            "",
            "        self.host = host",
            "        self.port = port",
            "        self.app = app",
            "        self.passthrough_errors = passthrough_errors",
            "",
            "        self.address_family = address_family = select_address_family(host, port)",
            "        server_address = get_sockaddr(host, int(port), address_family)",
            "",
            "        # Remove a leftover Unix socket file from a previous run. Don't",
            "        # remove a file that was set up by run_simple.",
            "        if address_family == af_unix and fd is None:",
            "            server_address = t.cast(str, server_address)",
            "",
            "            if os.path.exists(server_address):",
            "                os.unlink(server_address)",
            "",
            "        # Bind and activate will be handled manually, it should only",
            "        # happen if we're not using a socket that was already set up.",
            "        super().__init__(",
            "            server_address,  # type: ignore[arg-type]",
            "            handler,",
            "            bind_and_activate=False,",
            "        )",
            "",
            "        if fd is None:",
            "            # No existing socket descriptor, do bind_and_activate=True.",
            "            try:",
            "                self.server_bind()",
            "                self.server_activate()",
            "            except OSError as e:",
            "                # Catch connection issues and show them without the traceback. Show",
            "                # extra instructions for address not found, and for macOS.",
            "                self.server_close()",
            "                print(e.strerror, file=sys.stderr)",
            "",
            "                if e.errno == errno.EADDRINUSE:",
            "                    print(",
            "                        f\"Port {port} is in use by another program. Either identify and\"",
            "                        \" stop that program, or start the server with a different\"",
            "                        \" port.\",",
            "                        file=sys.stderr,",
            "                    )",
            "",
            "                    if sys.platform == \"darwin\" and port == 5000:",
            "                        print(",
            "                            \"On macOS, try disabling the 'AirPlay Receiver' service\"",
            "                            \" from System Preferences -> General -> AirDrop & Handoff.\",",
            "                            file=sys.stderr,",
            "                        )",
            "",
            "                sys.exit(1)",
            "            except BaseException:",
            "                self.server_close()",
            "                raise",
            "        else:",
            "            # TCPServer automatically opens a socket even if bind_and_activate is False.",
            "            # Close it to silence a ResourceWarning.",
            "            self.server_close()",
            "",
            "            # Use the passed in socket directly.",
            "            self.socket = socket.fromfd(fd, address_family, socket.SOCK_STREAM)",
            "            self.server_address = self.socket.getsockname()",
            "",
            "        if address_family != af_unix:",
            "            # If port was 0, this will record the bound port.",
            "            self.port = self.server_address[1]",
            "",
            "        if ssl_context is not None:",
            "            if isinstance(ssl_context, tuple):",
            "                ssl_context = load_ssl_context(*ssl_context)",
            "            elif ssl_context == \"adhoc\":",
            "                ssl_context = generate_adhoc_ssl_context()",
            "",
            "            self.socket = ssl_context.wrap_socket(self.socket, server_side=True)",
            "            self.ssl_context: ssl.SSLContext | None = ssl_context",
            "        else:",
            "            self.ssl_context = None",
            "",
            "        import importlib.metadata",
            "",
            "        self._server_version = f\"Werkzeug/{importlib.metadata.version('werkzeug')}\"",
            "",
            "    def log(self, type: str, message: str, *args: t.Any) -> None:",
            "        _log(type, message, *args)",
            "",
            "    def serve_forever(self, poll_interval: float = 0.5) -> None:",
            "        try:",
            "            super().serve_forever(poll_interval=poll_interval)",
            "        except KeyboardInterrupt:",
            "            pass",
            "        finally:",
            "            self.server_close()",
            "",
            "    def handle_error(",
            "        self, request: t.Any, client_address: tuple[str, int] | str",
            "    ) -> None:",
            "        if self.passthrough_errors:",
            "            raise",
            "",
            "        return super().handle_error(request, client_address)",
            "",
            "    def log_startup(self) -> None:",
            "        \"\"\"Show information about the address when starting the server.\"\"\"",
            "        dev_warning = (",
            "            \"WARNING: This is a development server. Do not use it in a production\"",
            "            \" deployment. Use a production WSGI server instead.\"",
            "        )",
            "        dev_warning = _ansi_style(dev_warning, \"bold\", \"red\")",
            "        messages = [dev_warning]",
            "",
            "        if self.address_family == af_unix:",
            "            messages.append(f\" * Running on {self.host}\")",
            "        else:",
            "            scheme = \"http\" if self.ssl_context is None else \"https\"",
            "            display_hostname = self.host",
            "",
            "            if self.host in {\"0.0.0.0\", \"::\"}:",
            "                messages.append(f\" * Running on all addresses ({self.host})\")",
            "",
            "                if self.host == \"0.0.0.0\":",
            "                    localhost = \"127.0.0.1\"",
            "                    display_hostname = get_interface_ip(socket.AF_INET)",
            "                else:",
            "                    localhost = \"[::1]\"",
            "                    display_hostname = get_interface_ip(socket.AF_INET6)",
            "",
            "                messages.append(f\" * Running on {scheme}://{localhost}:{self.port}\")",
            "",
            "            if \":\" in display_hostname:",
            "                display_hostname = f\"[{display_hostname}]\"",
            "",
            "            messages.append(f\" * Running on {scheme}://{display_hostname}:{self.port}\")",
            "",
            "        _log(\"info\", \"\\n\".join(messages))",
            "",
            "",
            "class ThreadedWSGIServer(socketserver.ThreadingMixIn, BaseWSGIServer):",
            "    \"\"\"A WSGI server that handles concurrent requests in separate",
            "    threads.",
            "",
            "    Use :func:`make_server` to create a server instance.",
            "    \"\"\"",
            "",
            "    multithread = True",
            "    daemon_threads = True",
            "",
            "",
            "class ForkingWSGIServer(ForkingMixIn, BaseWSGIServer):",
            "    \"\"\"A WSGI server that handles concurrent requests in separate forked",
            "    processes.",
            "",
            "    Use :func:`make_server` to create a server instance.",
            "    \"\"\"",
            "",
            "    multiprocess = True",
            "",
            "    def __init__(",
            "        self,",
            "        host: str,",
            "        port: int,",
            "        app: WSGIApplication,",
            "        processes: int = 40,",
            "        handler: type[WSGIRequestHandler] | None = None,",
            "        passthrough_errors: bool = False,",
            "        ssl_context: _TSSLContextArg | None = None,",
            "        fd: int | None = None,",
            "    ) -> None:",
            "        if not can_fork:",
            "            raise ValueError(\"Your platform does not support forking.\")",
            "",
            "        super().__init__(host, port, app, handler, passthrough_errors, ssl_context, fd)",
            "        self.max_children = processes",
            "",
            "",
            "def make_server(",
            "    host: str,",
            "    port: int,",
            "    app: WSGIApplication,",
            "    threaded: bool = False,",
            "    processes: int = 1,",
            "    request_handler: type[WSGIRequestHandler] | None = None,",
            "    passthrough_errors: bool = False,",
            "    ssl_context: _TSSLContextArg | None = None,",
            "    fd: int | None = None,",
            ") -> BaseWSGIServer:",
            "    \"\"\"Create an appropriate WSGI server instance based on the value of",
            "    ``threaded`` and ``processes``.",
            "",
            "    This is called from :func:`run_simple`, but can be used separately",
            "    to have access to the server object, such as to run it in a separate",
            "    thread.",
            "",
            "    See :func:`run_simple` for parameter docs.",
            "    \"\"\"",
            "    if threaded and processes > 1:",
            "        raise ValueError(\"Cannot have a multi-thread and multi-process server.\")",
            "",
            "    if threaded:",
            "        return ThreadedWSGIServer(",
            "            host, port, app, request_handler, passthrough_errors, ssl_context, fd=fd",
            "        )",
            "",
            "    if processes > 1:",
            "        return ForkingWSGIServer(",
            "            host,",
            "            port,",
            "            app,",
            "            processes,",
            "            request_handler,",
            "            passthrough_errors,",
            "            ssl_context,",
            "            fd=fd,",
            "        )",
            "",
            "    return BaseWSGIServer(",
            "        host, port, app, request_handler, passthrough_errors, ssl_context, fd=fd",
            "    )",
            "",
            "",
            "def is_running_from_reloader() -> bool:",
            "    \"\"\"Check if the server is running as a subprocess within the",
            "    Werkzeug reloader.",
            "",
            "    .. versionadded:: 0.10",
            "    \"\"\"",
            "    return os.environ.get(\"WERKZEUG_RUN_MAIN\") == \"true\"",
            "",
            "",
            "def run_simple(",
            "    hostname: str,",
            "    port: int,",
            "    application: WSGIApplication,",
            "    use_reloader: bool = False,",
            "    use_debugger: bool = False,",
            "    use_evalex: bool = True,",
            "    extra_files: t.Iterable[str] | None = None,",
            "    exclude_patterns: t.Iterable[str] | None = None,",
            "    reloader_interval: int = 1,",
            "    reloader_type: str = \"auto\",",
            "    threaded: bool = False,",
            "    processes: int = 1,",
            "    request_handler: type[WSGIRequestHandler] | None = None,",
            "    static_files: dict[str, str | tuple[str, str]] | None = None,",
            "    passthrough_errors: bool = False,",
            "    ssl_context: _TSSLContextArg | None = None,",
            ") -> None:",
            "    \"\"\"Start a development server for a WSGI application. Various",
            "    optional features can be enabled.",
            "",
            "    .. warning::",
            "",
            "        Do not use the development server when deploying to production.",
            "        It is intended for use only during local development. It is not",
            "        designed to be particularly efficient, stable, or secure.",
            "",
            "    :param hostname: The host to bind to, for example ``'localhost'``.",
            "        Can be a domain, IPv4 or IPv6 address, or file path starting",
            "        with ``unix://`` for a Unix socket.",
            "    :param port: The port to bind to, for example ``8080``. Using ``0``",
            "        tells the OS to pick a random free port.",
            "    :param application: The WSGI application to run.",
            "    :param use_reloader: Use a reloader process to restart the server",
            "        process when files are changed.",
            "    :param use_debugger: Use Werkzeug's debugger, which will show",
            "        formatted tracebacks on unhandled exceptions.",
            "    :param use_evalex: Make the debugger interactive. A Python terminal",
            "        can be opened for any frame in the traceback. Some protection is",
            "        provided by requiring a PIN, but this should never be enabled",
            "        on a publicly visible server.",
            "    :param extra_files: The reloader will watch these files for changes",
            "        in addition to Python modules. For example, watch a",
            "        configuration file.",
            "    :param exclude_patterns: The reloader will ignore changes to any",
            "        files matching these :mod:`fnmatch` patterns. For example,",
            "        ignore cache files.",
            "    :param reloader_interval: How often the reloader tries to check for",
            "        changes.",
            "    :param reloader_type: The reloader to use. The ``'stat'`` reloader",
            "        is built in, but may require significant CPU to watch files. The",
            "        ``'watchdog'`` reloader is much more efficient but requires",
            "        installing the ``watchdog`` package first.",
            "    :param threaded: Handle concurrent requests using threads. Cannot be",
            "        used with ``processes``.",
            "    :param processes: Handle concurrent requests using up to this number",
            "        of processes. Cannot be used with ``threaded``.",
            "    :param request_handler: Use a different",
            "        :class:`~BaseHTTPServer.BaseHTTPRequestHandler` subclass to",
            "        handle requests.",
            "    :param static_files: A dict mapping URL prefixes to directories to",
            "        serve static files from using",
            "        :class:`~werkzeug.middleware.SharedDataMiddleware`.",
            "    :param passthrough_errors: Don't catch unhandled exceptions at the",
            "        server level, let the server crash instead. If ``use_debugger``",
            "        is enabled, the debugger will still catch such errors.",
            "    :param ssl_context: Configure TLS to serve over HTTPS. Can be an",
            "        :class:`ssl.SSLContext` object, a ``(cert_file, key_file)``",
            "        tuple to create a typical context, or the string ``'adhoc'`` to",
            "        generate a temporary self-signed certificate.",
            "",
            "    .. versionchanged:: 2.1",
            "        Instructions are shown for dealing with an \"address already in",
            "        use\" error.",
            "",
            "    .. versionchanged:: 2.1",
            "        Running on ``0.0.0.0`` or ``::`` shows the loopback IP in",
            "        addition to a real IP.",
            "",
            "    .. versionchanged:: 2.1",
            "        The command-line interface was removed.",
            "",
            "    .. versionchanged:: 2.0",
            "        Running on ``0.0.0.0`` or ``::`` shows a real IP address that",
            "        was bound as well as a warning not to run the development server",
            "        in production.",
            "",
            "    .. versionchanged:: 2.0",
            "        The ``exclude_patterns`` parameter was added.",
            "",
            "    .. versionchanged:: 0.15",
            "        Bind to a Unix socket by passing a ``hostname`` that starts with",
            "        ``unix://``.",
            "",
            "    .. versionchanged:: 0.10",
            "        Improved the reloader and added support for changing the backend",
            "        through the ``reloader_type`` parameter.",
            "",
            "    .. versionchanged:: 0.9",
            "        A command-line interface was added.",
            "",
            "    .. versionchanged:: 0.8",
            "        ``ssl_context`` can be a tuple of paths to the certificate and",
            "        private key files.",
            "",
            "    .. versionchanged:: 0.6",
            "        The ``ssl_context`` parameter was added.",
            "",
            "    .. versionchanged:: 0.5",
            "       The ``static_files`` and ``passthrough_errors`` parameters were",
            "       added.",
            "    \"\"\"",
            "    if not isinstance(port, int):",
            "        raise TypeError(\"port must be an integer\")",
            "",
            "    if static_files:",
            "        from .middleware.shared_data import SharedDataMiddleware",
            "",
            "        application = SharedDataMiddleware(application, static_files)",
            "",
            "    if use_debugger:",
            "        from .debug import DebuggedApplication",
            "",
            "        application = DebuggedApplication(application, evalex=use_evalex)",
            "",
            "    if not is_running_from_reloader():",
            "        fd = None",
            "    else:",
            "        fd = int(os.environ[\"WERKZEUG_SERVER_FD\"])",
            "",
            "    srv = make_server(",
            "        hostname,",
            "        port,",
            "        application,",
            "        threaded,",
            "        processes,",
            "        request_handler,",
            "        passthrough_errors,",
            "        ssl_context,",
            "        fd=fd,",
            "    )",
            "    srv.socket.set_inheritable(True)",
            "    os.environ[\"WERKZEUG_SERVER_FD\"] = str(srv.fileno())",
            "",
            "    if not is_running_from_reloader():",
            "        srv.log_startup()",
            "        _log(\"info\", _ansi_style(\"Press CTRL+C to quit\", \"yellow\"))",
            "",
            "    if use_reloader:",
            "        from ._reloader import run_with_reloader",
            "",
            "        try:",
            "            run_with_reloader(",
            "                srv.serve_forever,",
            "                extra_files=extra_files,",
            "                exclude_patterns=exclude_patterns,",
            "                interval=reloader_interval,",
            "                reloader_type=reloader_type,",
            "            )",
            "        finally:",
            "            srv.server_close()",
            "    else:",
            "        srv.serve_forever()"
        ],
        "afterPatchFile": [
            "\"\"\"A WSGI and HTTP server for use **during development only**. This",
            "server is convenient to use, but is not designed to be particularly",
            "stable, secure, or efficient. Use a dedicate WSGI server and HTTP",
            "server when deploying to production.",
            "",
            "It provides features like interactive debugging and code reloading. Use",
            "``run_simple`` to start the server. Put this in a ``run.py`` script:",
            "",
            ".. code-block:: python",
            "",
            "    from myapp import create_app",
            "    from werkzeug import run_simple",
            "\"\"\"",
            "",
            "from __future__ import annotations",
            "",
            "import errno",
            "import io",
            "import os",
            "import selectors",
            "import socket",
            "import socketserver",
            "import sys",
            "import typing as t",
            "from datetime import datetime as dt",
            "from datetime import timedelta",
            "from datetime import timezone",
            "from http.server import BaseHTTPRequestHandler",
            "from http.server import HTTPServer",
            "from urllib.parse import unquote",
            "from urllib.parse import urlsplit",
            "",
            "from ._internal import _log",
            "from ._internal import _wsgi_encoding_dance",
            "from .exceptions import InternalServerError",
            "from .urls import uri_to_iri",
            "",
            "try:",
            "    import ssl",
            "except ImportError:",
            "",
            "    class _SslDummy:",
            "        def __getattr__(self, name: str) -> t.Any:",
            "            raise RuntimeError(  # noqa: B904",
            "                \"SSL is unavailable because this Python runtime was not\"",
            "                \" compiled with SSL/TLS support.\"",
            "            )",
            "",
            "    ssl = _SslDummy()  # type: ignore",
            "",
            "_log_add_style = True",
            "",
            "if os.name == \"nt\":",
            "    try:",
            "        __import__(\"colorama\")",
            "    except ImportError:",
            "        _log_add_style = False",
            "",
            "can_fork = hasattr(os, \"fork\")",
            "",
            "if can_fork:",
            "    ForkingMixIn = socketserver.ForkingMixIn",
            "else:",
            "",
            "    class ForkingMixIn:  # type: ignore",
            "        pass",
            "",
            "",
            "try:",
            "    af_unix = socket.AF_UNIX",
            "except AttributeError:",
            "    af_unix = None  # type: ignore",
            "",
            "LISTEN_QUEUE = 128",
            "",
            "_TSSLContextArg = t.Optional[",
            "    t.Union[\"ssl.SSLContext\", t.Tuple[str, t.Optional[str]], t.Literal[\"adhoc\"]]",
            "]",
            "",
            "if t.TYPE_CHECKING:",
            "    from _typeshed.wsgi import WSGIApplication",
            "    from _typeshed.wsgi import WSGIEnvironment",
            "    from cryptography.hazmat.primitives.asymmetric.rsa import (",
            "        RSAPrivateKeyWithSerialization,",
            "    )",
            "    from cryptography.x509 import Certificate",
            "",
            "",
            "class DechunkedInput(io.RawIOBase):",
            "    \"\"\"An input stream that handles Transfer-Encoding 'chunked'\"\"\"",
            "",
            "    def __init__(self, rfile: t.IO[bytes]) -> None:",
            "        self._rfile = rfile",
            "        self._done = False",
            "        self._len = 0",
            "",
            "    def readable(self) -> bool:",
            "        return True",
            "",
            "    def read_chunk_len(self) -> int:",
            "        try:",
            "            line = self._rfile.readline().decode(\"latin1\")",
            "            _len = int(line.strip(), 16)",
            "        except ValueError as e:",
            "            raise OSError(\"Invalid chunk header\") from e",
            "        if _len < 0:",
            "            raise OSError(\"Negative chunk length not allowed\")",
            "        return _len",
            "",
            "    def readinto(self, buf: bytearray) -> int:  # type: ignore",
            "        read = 0",
            "        while not self._done and read < len(buf):",
            "            if self._len == 0:",
            "                # This is the first chunk or we fully consumed the previous",
            "                # one. Read the next length of the next chunk",
            "                self._len = self.read_chunk_len()",
            "",
            "            if self._len == 0:",
            "                # Found the final chunk of size 0. The stream is now exhausted,",
            "                # but there is still a final newline that should be consumed",
            "                self._done = True",
            "",
            "            if self._len > 0:",
            "                # There is data (left) in this chunk, so append it to the",
            "                # buffer. If this operation fully consumes the chunk, this will",
            "                # reset self._len to 0.",
            "                n = min(len(buf), self._len)",
            "",
            "                # If (read + chunk size) becomes more than len(buf), buf will",
            "                # grow beyond the original size and read more data than",
            "                # required. So only read as much data as can fit in buf.",
            "                if read + n > len(buf):",
            "                    buf[read:] = self._rfile.read(len(buf) - read)",
            "                    self._len -= len(buf) - read",
            "                    read = len(buf)",
            "                else:",
            "                    buf[read : read + n] = self._rfile.read(n)",
            "                    self._len -= n",
            "                    read += n",
            "",
            "            if self._len == 0:",
            "                # Skip the terminating newline of a chunk that has been fully",
            "                # consumed. This also applies to the 0-sized final chunk",
            "                terminator = self._rfile.readline()",
            "                if terminator not in (b\"\\n\", b\"\\r\\n\", b\"\\r\"):",
            "                    raise OSError(\"Missing chunk terminating newline\")",
            "",
            "        return read",
            "",
            "",
            "class WSGIRequestHandler(BaseHTTPRequestHandler):",
            "    \"\"\"A request handler that implements WSGI dispatching.\"\"\"",
            "",
            "    server: BaseWSGIServer",
            "",
            "    @property",
            "    def server_version(self) -> str:  # type: ignore",
            "        return self.server._server_version",
            "",
            "    def make_environ(self) -> WSGIEnvironment:",
            "        request_url = urlsplit(self.path)",
            "        url_scheme = \"http\" if self.server.ssl_context is None else \"https\"",
            "",
            "        if not self.client_address:",
            "            self.client_address = (\"<local>\", 0)",
            "        elif isinstance(self.client_address, str):",
            "            self.client_address = (self.client_address, 0)",
            "",
            "        # If there was no scheme but the path started with two slashes,",
            "        # the first segment may have been incorrectly parsed as the",
            "        # netloc, prepend it to the path again.",
            "        if not request_url.scheme and request_url.netloc:",
            "            path_info = f\"/{request_url.netloc}{request_url.path}\"",
            "        else:",
            "            path_info = request_url.path",
            "",
            "        path_info = unquote(path_info)",
            "",
            "        environ: WSGIEnvironment = {",
            "            \"wsgi.version\": (1, 0),",
            "            \"wsgi.url_scheme\": url_scheme,",
            "            \"wsgi.input\": self.rfile,",
            "            \"wsgi.errors\": sys.stderr,",
            "            \"wsgi.multithread\": self.server.multithread,",
            "            \"wsgi.multiprocess\": self.server.multiprocess,",
            "            \"wsgi.run_once\": False,",
            "            \"werkzeug.socket\": self.connection,",
            "            \"SERVER_SOFTWARE\": self.server_version,",
            "            \"REQUEST_METHOD\": self.command,",
            "            \"SCRIPT_NAME\": \"\",",
            "            \"PATH_INFO\": _wsgi_encoding_dance(path_info),",
            "            \"QUERY_STRING\": _wsgi_encoding_dance(request_url.query),",
            "            # Non-standard, added by mod_wsgi, uWSGI",
            "            \"REQUEST_URI\": _wsgi_encoding_dance(self.path),",
            "            # Non-standard, added by gunicorn",
            "            \"RAW_URI\": _wsgi_encoding_dance(self.path),",
            "            \"REMOTE_ADDR\": self.address_string(),",
            "            \"REMOTE_PORT\": self.port_integer(),",
            "            \"SERVER_NAME\": self.server.server_address[0],",
            "            \"SERVER_PORT\": str(self.server.server_address[1]),",
            "            \"SERVER_PROTOCOL\": self.request_version,",
            "        }",
            "",
            "        for key, value in self.headers.items():",
            "            if \"_\" in key:",
            "                continue",
            "",
            "            key = key.upper().replace(\"-\", \"_\")",
            "            value = value.replace(\"\\r\\n\", \"\")",
            "            if key not in (\"CONTENT_TYPE\", \"CONTENT_LENGTH\"):",
            "                key = f\"HTTP_{key}\"",
            "                if key in environ:",
            "                    value = f\"{environ[key]},{value}\"",
            "            environ[key] = value",
            "",
            "        if environ.get(\"HTTP_TRANSFER_ENCODING\", \"\").strip().lower() == \"chunked\":",
            "            environ[\"wsgi.input_terminated\"] = True",
            "            environ[\"wsgi.input\"] = DechunkedInput(environ[\"wsgi.input\"])",
            "",
            "        # Per RFC 2616, if the URL is absolute, use that as the host.",
            "        # We're using \"has a scheme\" to indicate an absolute URL.",
            "        if request_url.scheme and request_url.netloc:",
            "            environ[\"HTTP_HOST\"] = request_url.netloc",
            "",
            "        try:",
            "            # binary_form=False gives nicer information, but wouldn't be compatible with",
            "            # what Nginx or Apache could return.",
            "            peer_cert = self.connection.getpeercert(binary_form=True)",
            "            if peer_cert is not None:",
            "                # Nginx and Apache use PEM format.",
            "                environ[\"SSL_CLIENT_CERT\"] = ssl.DER_cert_to_PEM_cert(peer_cert)",
            "        except ValueError:",
            "            # SSL handshake hasn't finished.",
            "            self.server.log(\"error\", \"Cannot fetch SSL peer certificate info\")",
            "        except AttributeError:",
            "            # Not using TLS, the socket will not have getpeercert().",
            "            pass",
            "",
            "        return environ",
            "",
            "    def run_wsgi(self) -> None:",
            "        if self.headers.get(\"Expect\", \"\").lower().strip() == \"100-continue\":",
            "            self.wfile.write(b\"HTTP/1.1 100 Continue\\r\\n\\r\\n\")",
            "",
            "        self.environ = environ = self.make_environ()",
            "        status_set: str | None = None",
            "        headers_set: list[tuple[str, str]] | None = None",
            "        status_sent: str | None = None",
            "        headers_sent: list[tuple[str, str]] | None = None",
            "        chunk_response: bool = False",
            "",
            "        def write(data: bytes) -> None:",
            "            nonlocal status_sent, headers_sent, chunk_response",
            "            assert status_set is not None, \"write() before start_response\"",
            "            assert headers_set is not None, \"write() before start_response\"",
            "            if status_sent is None:",
            "                status_sent = status_set",
            "                headers_sent = headers_set",
            "                try:",
            "                    code_str, msg = status_sent.split(None, 1)",
            "                except ValueError:",
            "                    code_str, msg = status_sent, \"\"",
            "                code = int(code_str)",
            "                self.send_response(code, msg)",
            "                header_keys = set()",
            "                for key, value in headers_sent:",
            "                    self.send_header(key, value)",
            "                    header_keys.add(key.lower())",
            "",
            "                # Use chunked transfer encoding if there is no content",
            "                # length. Do not use for 1xx and 204 responses. 304",
            "                # responses and HEAD requests are also excluded, which",
            "                # is the more conservative behavior and matches other",
            "                # parts of the code.",
            "                # https://httpwg.org/specs/rfc7230.html#rfc.section.3.3.1",
            "                if (",
            "                    not (",
            "                        \"content-length\" in header_keys",
            "                        or environ[\"REQUEST_METHOD\"] == \"HEAD\"",
            "                        or (100 <= code < 200)",
            "                        or code in {204, 304}",
            "                    )",
            "                    and self.protocol_version >= \"HTTP/1.1\"",
            "                ):",
            "                    chunk_response = True",
            "                    self.send_header(\"Transfer-Encoding\", \"chunked\")",
            "",
            "                # Always close the connection. This disables HTTP/1.1",
            "                # keep-alive connections. They aren't handled well by",
            "                # Python's http.server because it doesn't know how to",
            "                # drain the stream before the next request line.",
            "                self.send_header(\"Connection\", \"close\")",
            "                self.end_headers()",
            "",
            "            assert isinstance(data, bytes), \"applications must write bytes\"",
            "",
            "            if data:",
            "                if chunk_response:",
            "                    self.wfile.write(hex(len(data))[2:].encode())",
            "                    self.wfile.write(b\"\\r\\n\")",
            "",
            "                self.wfile.write(data)",
            "",
            "                if chunk_response:",
            "                    self.wfile.write(b\"\\r\\n\")",
            "",
            "            self.wfile.flush()",
            "",
            "        def start_response(status, headers, exc_info=None):  # type: ignore",
            "            nonlocal status_set, headers_set",
            "            if exc_info:",
            "                try:",
            "                    if headers_sent:",
            "                        raise exc_info[1].with_traceback(exc_info[2])",
            "                finally:",
            "                    exc_info = None",
            "            elif headers_set:",
            "                raise AssertionError(\"Headers already set\")",
            "            status_set = status",
            "            headers_set = headers",
            "            return write",
            "",
            "        def execute(app: WSGIApplication) -> None:",
            "            application_iter = app(environ, start_response)",
            "            try:",
            "                for data in application_iter:",
            "                    write(data)",
            "                if not headers_sent:",
            "                    write(b\"\")",
            "                if chunk_response:",
            "                    self.wfile.write(b\"0\\r\\n\\r\\n\")",
            "            finally:",
            "                # Check for any remaining data in the read socket, and discard it. This",
            "                # will read past request.max_content_length, but lets the client see a",
            "                # 413 response instead of a connection reset failure. If we supported",
            "                # keep-alive connections, this naive approach would break by reading the",
            "                # next request line. Since we know that write (above) closes every",
            "                # connection we can read everything.",
            "                selector = selectors.DefaultSelector()",
            "                selector.register(self.connection, selectors.EVENT_READ)",
            "                total_size = 0",
            "                total_reads = 0",
            "",
            "                # A timeout of 0 tends to fail because a client needs a small amount of",
            "                # time to continue sending its data.",
            "                while selector.select(timeout=0.01):",
            "                    # Only read 10MB into memory at a time.",
            "                    data = self.rfile.read(10_000_000)",
            "                    total_size += len(data)",
            "                    total_reads += 1",
            "",
            "                    # Stop reading on no data, >=10GB, or 1000 reads. If a client sends",
            "                    # more than that, they'll get a connection reset failure.",
            "                    if not data or total_size >= 10_000_000_000 or total_reads > 1000:",
            "                        break",
            "",
            "                selector.close()",
            "",
            "                if hasattr(application_iter, \"close\"):",
            "                    application_iter.close()",
            "",
            "        try:",
            "            execute(self.server.app)",
            "        except (ConnectionError, socket.timeout) as e:",
            "            self.connection_dropped(e, environ)",
            "        except Exception as e:",
            "            if self.server.passthrough_errors:",
            "                raise",
            "",
            "            if status_sent is not None and chunk_response:",
            "                self.close_connection = True",
            "",
            "            try:",
            "                # if we haven't yet sent the headers but they are set",
            "                # we roll back to be able to set them again.",
            "                if status_sent is None:",
            "                    status_set = None",
            "                    headers_set = None",
            "                execute(InternalServerError())",
            "            except Exception:",
            "                pass",
            "",
            "            from .debug.tbtools import DebugTraceback",
            "",
            "            msg = DebugTraceback(e).render_traceback_text()",
            "            self.server.log(\"error\", f\"Error on request:\\n{msg}\")",
            "",
            "    def handle(self) -> None:",
            "        \"\"\"Handles a request ignoring dropped connections.\"\"\"",
            "        try:",
            "            super().handle()",
            "        except (ConnectionError, socket.timeout) as e:",
            "            self.connection_dropped(e)",
            "        except Exception as e:",
            "            if self.server.ssl_context is not None and is_ssl_error(e):",
            "                self.log_error(\"SSL error occurred: %s\", e)",
            "            else:",
            "                raise",
            "",
            "    def connection_dropped(",
            "        self, error: BaseException, environ: WSGIEnvironment | None = None",
            "    ) -> None:",
            "        \"\"\"Called if the connection was closed by the client.  By default",
            "        nothing happens.",
            "        \"\"\"",
            "",
            "    def __getattr__(self, name: str) -> t.Any:",
            "        # All HTTP methods are handled by run_wsgi.",
            "        if name.startswith(\"do_\"):",
            "            return self.run_wsgi",
            "",
            "        # All other attributes are forwarded to the base class.",
            "        return getattr(super(), name)",
            "",
            "    def address_string(self) -> str:",
            "        if getattr(self, \"environ\", None):",
            "            return self.environ[\"REMOTE_ADDR\"]  # type: ignore",
            "",
            "        if not self.client_address:",
            "            return \"<local>\"",
            "",
            "        return self.client_address[0]",
            "",
            "    def port_integer(self) -> int:",
            "        return self.client_address[1]",
            "",
            "    # Escape control characters. This is defined (but private) in Python 3.12.",
            "    _control_char_table = str.maketrans(",
            "        {c: rf\"\\x{c:02x}\" for c in [*range(0x20), *range(0x7F, 0xA0)]}",
            "    )",
            "    _control_char_table[ord(\"\\\\\")] = r\"\\\\\"",
            "",
            "    def log_request(self, code: int | str = \"-\", size: int | str = \"-\") -> None:",
            "        try:",
            "            path = uri_to_iri(self.path)",
            "            msg = f\"{self.command} {path} {self.request_version}\"",
            "        except AttributeError:",
            "            # path isn't set if the requestline was bad",
            "            msg = self.requestline",
            "",
            "        # Escape control characters that may be in the decoded path.",
            "        msg = msg.translate(self._control_char_table)",
            "        code = str(code)",
            "",
            "        if code[0] == \"1\":  # 1xx - Informational",
            "            msg = _ansi_style(msg, \"bold\")",
            "        elif code == \"200\":  # 2xx - Success",
            "            pass",
            "        elif code == \"304\":  # 304 - Resource Not Modified",
            "            msg = _ansi_style(msg, \"cyan\")",
            "        elif code[0] == \"3\":  # 3xx - Redirection",
            "            msg = _ansi_style(msg, \"green\")",
            "        elif code == \"404\":  # 404 - Resource Not Found",
            "            msg = _ansi_style(msg, \"yellow\")",
            "        elif code[0] == \"4\":  # 4xx - Client Error",
            "            msg = _ansi_style(msg, \"bold\", \"red\")",
            "        else:  # 5xx, or any other response",
            "            msg = _ansi_style(msg, \"bold\", \"magenta\")",
            "",
            "        self.log(\"info\", '\"%s\" %s %s', msg, code, size)",
            "",
            "    def log_error(self, format: str, *args: t.Any) -> None:",
            "        self.log(\"error\", format, *args)",
            "",
            "    def log_message(self, format: str, *args: t.Any) -> None:",
            "        self.log(\"info\", format, *args)",
            "",
            "    def log(self, type: str, message: str, *args: t.Any) -> None:",
            "        _log(",
            "            type,",
            "            f\"{self.address_string()} - - [{self.log_date_time_string()}] {message}\\n\",",
            "            *args,",
            "        )",
            "",
            "",
            "def _ansi_style(value: str, *styles: str) -> str:",
            "    if not _log_add_style:",
            "        return value",
            "",
            "    codes = {",
            "        \"bold\": 1,",
            "        \"red\": 31,",
            "        \"green\": 32,",
            "        \"yellow\": 33,",
            "        \"magenta\": 35,",
            "        \"cyan\": 36,",
            "    }",
            "",
            "    for style in styles:",
            "        value = f\"\\x1b[{codes[style]}m{value}\"",
            "",
            "    return f\"{value}\\x1b[0m\"",
            "",
            "",
            "def generate_adhoc_ssl_pair(",
            "    cn: str | None = None,",
            ") -> tuple[Certificate, RSAPrivateKeyWithSerialization]:",
            "    try:",
            "        from cryptography import x509",
            "        from cryptography.hazmat.backends import default_backend",
            "        from cryptography.hazmat.primitives import hashes",
            "        from cryptography.hazmat.primitives.asymmetric import rsa",
            "        from cryptography.x509.oid import NameOID",
            "    except ImportError:",
            "        raise TypeError(",
            "            \"Using ad-hoc certificates requires the cryptography library.\"",
            "        ) from None",
            "",
            "    backend = default_backend()",
            "    pkey = rsa.generate_private_key(",
            "        public_exponent=65537, key_size=2048, backend=backend",
            "    )",
            "",
            "    # pretty damn sure that this is not actually accepted by anyone",
            "    if cn is None:",
            "        cn = \"*\"",
            "",
            "    subject = x509.Name(",
            "        [",
            "            x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"Dummy Certificate\"),",
            "            x509.NameAttribute(NameOID.COMMON_NAME, cn),",
            "        ]",
            "    )",
            "",
            "    backend = default_backend()",
            "    cert = (",
            "        x509.CertificateBuilder()",
            "        .subject_name(subject)",
            "        .issuer_name(subject)",
            "        .public_key(pkey.public_key())",
            "        .serial_number(x509.random_serial_number())",
            "        .not_valid_before(dt.now(timezone.utc))",
            "        .not_valid_after(dt.now(timezone.utc) + timedelta(days=365))",
            "        .add_extension(x509.ExtendedKeyUsage([x509.OID_SERVER_AUTH]), critical=False)",
            "        .add_extension(",
            "            x509.SubjectAlternativeName([x509.DNSName(cn), x509.DNSName(f\"*.{cn}\")]),",
            "            critical=False,",
            "        )",
            "        .sign(pkey, hashes.SHA256(), backend)",
            "    )",
            "    return cert, pkey",
            "",
            "",
            "def make_ssl_devcert(",
            "    base_path: str, host: str | None = None, cn: str | None = None",
            ") -> tuple[str, str]:",
            "    \"\"\"Creates an SSL key for development.  This should be used instead of",
            "    the ``'adhoc'`` key which generates a new cert on each server start.",
            "    It accepts a path for where it should store the key and cert and",
            "    either a host or CN.  If a host is given it will use the CN",
            "    ``*.host/CN=host``.",
            "",
            "    For more information see :func:`run_simple`.",
            "",
            "    .. versionadded:: 0.9",
            "",
            "    :param base_path: the path to the certificate and key.  The extension",
            "                      ``.crt`` is added for the certificate, ``.key`` is",
            "                      added for the key.",
            "    :param host: the name of the host.  This can be used as an alternative",
            "                 for the `cn`.",
            "    :param cn: the `CN` to use.",
            "    \"\"\"",
            "",
            "    if host is not None:",
            "        cn = host",
            "    cert, pkey = generate_adhoc_ssl_pair(cn=cn)",
            "",
            "    from cryptography.hazmat.primitives import serialization",
            "",
            "    cert_file = f\"{base_path}.crt\"",
            "    pkey_file = f\"{base_path}.key\"",
            "",
            "    with open(cert_file, \"wb\") as f:",
            "        f.write(cert.public_bytes(serialization.Encoding.PEM))",
            "    with open(pkey_file, \"wb\") as f:",
            "        f.write(",
            "            pkey.private_bytes(",
            "                encoding=serialization.Encoding.PEM,",
            "                format=serialization.PrivateFormat.TraditionalOpenSSL,",
            "                encryption_algorithm=serialization.NoEncryption(),",
            "            )",
            "        )",
            "",
            "    return cert_file, pkey_file",
            "",
            "",
            "def generate_adhoc_ssl_context() -> ssl.SSLContext:",
            "    \"\"\"Generates an adhoc SSL context for the development server.\"\"\"",
            "    import atexit",
            "    import tempfile",
            "",
            "    cert, pkey = generate_adhoc_ssl_pair()",
            "",
            "    from cryptography.hazmat.primitives import serialization",
            "",
            "    cert_handle, cert_file = tempfile.mkstemp()",
            "    pkey_handle, pkey_file = tempfile.mkstemp()",
            "    atexit.register(os.remove, pkey_file)",
            "    atexit.register(os.remove, cert_file)",
            "",
            "    os.write(cert_handle, cert.public_bytes(serialization.Encoding.PEM))",
            "    os.write(",
            "        pkey_handle,",
            "        pkey.private_bytes(",
            "            encoding=serialization.Encoding.PEM,",
            "            format=serialization.PrivateFormat.TraditionalOpenSSL,",
            "            encryption_algorithm=serialization.NoEncryption(),",
            "        ),",
            "    )",
            "",
            "    os.close(cert_handle)",
            "    os.close(pkey_handle)",
            "    ctx = load_ssl_context(cert_file, pkey_file)",
            "    return ctx",
            "",
            "",
            "def load_ssl_context(",
            "    cert_file: str, pkey_file: str | None = None, protocol: int | None = None",
            ") -> ssl.SSLContext:",
            "    \"\"\"Loads SSL context from cert/private key files and optional protocol.",
            "    Many parameters are directly taken from the API of",
            "    :py:class:`ssl.SSLContext`.",
            "",
            "    :param cert_file: Path of the certificate to use.",
            "    :param pkey_file: Path of the private key to use. If not given, the key",
            "                      will be obtained from the certificate file.",
            "    :param protocol: A ``PROTOCOL`` constant from the :mod:`ssl` module.",
            "        Defaults to :data:`ssl.PROTOCOL_TLS_SERVER`.",
            "    \"\"\"",
            "    if protocol is None:",
            "        protocol = ssl.PROTOCOL_TLS_SERVER",
            "",
            "    ctx = ssl.SSLContext(protocol)",
            "    ctx.load_cert_chain(cert_file, pkey_file)",
            "    return ctx",
            "",
            "",
            "def is_ssl_error(error: Exception | None = None) -> bool:",
            "    \"\"\"Checks if the given error (or the current one) is an SSL error.\"\"\"",
            "    if error is None:",
            "        error = t.cast(Exception, sys.exc_info()[1])",
            "    return isinstance(error, ssl.SSLError)",
            "",
            "",
            "def select_address_family(host: str, port: int) -> socket.AddressFamily:",
            "    \"\"\"Return ``AF_INET4``, ``AF_INET6``, or ``AF_UNIX`` depending on",
            "    the host and port.\"\"\"",
            "    if host.startswith(\"unix://\"):",
            "        return socket.AF_UNIX",
            "    elif \":\" in host and hasattr(socket, \"AF_INET6\"):",
            "        return socket.AF_INET6",
            "    return socket.AF_INET",
            "",
            "",
            "def get_sockaddr(",
            "    host: str, port: int, family: socket.AddressFamily",
            ") -> tuple[str, int] | str:",
            "    \"\"\"Return a fully qualified socket address that can be passed to",
            "    :func:`socket.bind`.\"\"\"",
            "    if family == af_unix:",
            "        # Absolute path avoids IDNA encoding error when path starts with dot.",
            "        return os.path.abspath(host.partition(\"://\")[2])",
            "    try:",
            "        res = socket.getaddrinfo(",
            "            host, port, family, socket.SOCK_STREAM, socket.IPPROTO_TCP",
            "        )",
            "    except socket.gaierror:",
            "        return host, port",
            "    return res[0][4]  # type: ignore",
            "",
            "",
            "def get_interface_ip(family: socket.AddressFamily) -> str:",
            "    \"\"\"Get the IP address of an external interface. Used when binding to",
            "    0.0.0.0 or ::1 to show a more useful URL.",
            "",
            "    :meta private:",
            "    \"\"\"",
            "    # arbitrary private address",
            "    host = \"fd31:f903:5ab5:1::1\" if family == socket.AF_INET6 else \"10.253.155.219\"",
            "",
            "    with socket.socket(family, socket.SOCK_DGRAM) as s:",
            "        try:",
            "            s.connect((host, 58162))",
            "        except OSError:",
            "            return \"::1\" if family == socket.AF_INET6 else \"127.0.0.1\"",
            "",
            "        return s.getsockname()[0]  # type: ignore",
            "",
            "",
            "class BaseWSGIServer(HTTPServer):",
            "    \"\"\"A WSGI server that that handles one request at a time.",
            "",
            "    Use :func:`make_server` to create a server instance.",
            "    \"\"\"",
            "",
            "    multithread = False",
            "    multiprocess = False",
            "    request_queue_size = LISTEN_QUEUE",
            "    allow_reuse_address = True",
            "",
            "    def __init__(",
            "        self,",
            "        host: str,",
            "        port: int,",
            "        app: WSGIApplication,",
            "        handler: type[WSGIRequestHandler] | None = None,",
            "        passthrough_errors: bool = False,",
            "        ssl_context: _TSSLContextArg | None = None,",
            "        fd: int | None = None,",
            "    ) -> None:",
            "        if handler is None:",
            "            handler = WSGIRequestHandler",
            "",
            "        # If the handler doesn't directly set a protocol version and",
            "        # thread or process workers are used, then allow chunked",
            "        # responses and keep-alive connections by enabling HTTP/1.1.",
            "        if \"protocol_version\" not in vars(handler) and (",
            "            self.multithread or self.multiprocess",
            "        ):",
            "            handler.protocol_version = \"HTTP/1.1\"",
            "",
            "        self.host = host",
            "        self.port = port",
            "        self.app = app",
            "        self.passthrough_errors = passthrough_errors",
            "",
            "        self.address_family = address_family = select_address_family(host, port)",
            "        server_address = get_sockaddr(host, int(port), address_family)",
            "",
            "        # Remove a leftover Unix socket file from a previous run. Don't",
            "        # remove a file that was set up by run_simple.",
            "        if address_family == af_unix and fd is None:",
            "            server_address = t.cast(str, server_address)",
            "",
            "            if os.path.exists(server_address):",
            "                os.unlink(server_address)",
            "",
            "        # Bind and activate will be handled manually, it should only",
            "        # happen if we're not using a socket that was already set up.",
            "        super().__init__(",
            "            server_address,  # type: ignore[arg-type]",
            "            handler,",
            "            bind_and_activate=False,",
            "        )",
            "",
            "        if fd is None:",
            "            # No existing socket descriptor, do bind_and_activate=True.",
            "            try:",
            "                self.server_bind()",
            "                self.server_activate()",
            "            except OSError as e:",
            "                # Catch connection issues and show them without the traceback. Show",
            "                # extra instructions for address not found, and for macOS.",
            "                self.server_close()",
            "                print(e.strerror, file=sys.stderr)",
            "",
            "                if e.errno == errno.EADDRINUSE:",
            "                    print(",
            "                        f\"Port {port} is in use by another program. Either identify and\"",
            "                        \" stop that program, or start the server with a different\"",
            "                        \" port.\",",
            "                        file=sys.stderr,",
            "                    )",
            "",
            "                    if sys.platform == \"darwin\" and port == 5000:",
            "                        print(",
            "                            \"On macOS, try disabling the 'AirPlay Receiver' service\"",
            "                            \" from System Preferences -> General -> AirDrop & Handoff.\",",
            "                            file=sys.stderr,",
            "                        )",
            "",
            "                sys.exit(1)",
            "            except BaseException:",
            "                self.server_close()",
            "                raise",
            "        else:",
            "            # TCPServer automatically opens a socket even if bind_and_activate is False.",
            "            # Close it to silence a ResourceWarning.",
            "            self.server_close()",
            "",
            "            # Use the passed in socket directly.",
            "            self.socket = socket.fromfd(fd, address_family, socket.SOCK_STREAM)",
            "            self.server_address = self.socket.getsockname()",
            "",
            "        if address_family != af_unix:",
            "            # If port was 0, this will record the bound port.",
            "            self.port = self.server_address[1]",
            "",
            "        if ssl_context is not None:",
            "            if isinstance(ssl_context, tuple):",
            "                ssl_context = load_ssl_context(*ssl_context)",
            "            elif ssl_context == \"adhoc\":",
            "                ssl_context = generate_adhoc_ssl_context()",
            "",
            "            self.socket = ssl_context.wrap_socket(self.socket, server_side=True)",
            "            self.ssl_context: ssl.SSLContext | None = ssl_context",
            "        else:",
            "            self.ssl_context = None",
            "",
            "        import importlib.metadata",
            "",
            "        self._server_version = f\"Werkzeug/{importlib.metadata.version('werkzeug')}\"",
            "",
            "    def log(self, type: str, message: str, *args: t.Any) -> None:",
            "        _log(type, message, *args)",
            "",
            "    def serve_forever(self, poll_interval: float = 0.5) -> None:",
            "        try:",
            "            super().serve_forever(poll_interval=poll_interval)",
            "        except KeyboardInterrupt:",
            "            pass",
            "        finally:",
            "            self.server_close()",
            "",
            "    def handle_error(",
            "        self, request: t.Any, client_address: tuple[str, int] | str",
            "    ) -> None:",
            "        if self.passthrough_errors:",
            "            raise",
            "",
            "        return super().handle_error(request, client_address)",
            "",
            "    def log_startup(self) -> None:",
            "        \"\"\"Show information about the address when starting the server.\"\"\"",
            "        dev_warning = (",
            "            \"WARNING: This is a development server. Do not use it in a production\"",
            "            \" deployment. Use a production WSGI server instead.\"",
            "        )",
            "        dev_warning = _ansi_style(dev_warning, \"bold\", \"red\")",
            "        messages = [dev_warning]",
            "",
            "        if self.address_family == af_unix:",
            "            messages.append(f\" * Running on {self.host}\")",
            "        else:",
            "            scheme = \"http\" if self.ssl_context is None else \"https\"",
            "            display_hostname = self.host",
            "",
            "            if self.host in {\"0.0.0.0\", \"::\"}:",
            "                messages.append(f\" * Running on all addresses ({self.host})\")",
            "",
            "                if self.host == \"0.0.0.0\":",
            "                    localhost = \"127.0.0.1\"",
            "                    display_hostname = get_interface_ip(socket.AF_INET)",
            "                else:",
            "                    localhost = \"[::1]\"",
            "                    display_hostname = get_interface_ip(socket.AF_INET6)",
            "",
            "                messages.append(f\" * Running on {scheme}://{localhost}:{self.port}\")",
            "",
            "            if \":\" in display_hostname:",
            "                display_hostname = f\"[{display_hostname}]\"",
            "",
            "            messages.append(f\" * Running on {scheme}://{display_hostname}:{self.port}\")",
            "",
            "        _log(\"info\", \"\\n\".join(messages))",
            "",
            "",
            "class ThreadedWSGIServer(socketserver.ThreadingMixIn, BaseWSGIServer):",
            "    \"\"\"A WSGI server that handles concurrent requests in separate",
            "    threads.",
            "",
            "    Use :func:`make_server` to create a server instance.",
            "    \"\"\"",
            "",
            "    multithread = True",
            "    daemon_threads = True",
            "",
            "",
            "class ForkingWSGIServer(ForkingMixIn, BaseWSGIServer):",
            "    \"\"\"A WSGI server that handles concurrent requests in separate forked",
            "    processes.",
            "",
            "    Use :func:`make_server` to create a server instance.",
            "    \"\"\"",
            "",
            "    multiprocess = True",
            "",
            "    def __init__(",
            "        self,",
            "        host: str,",
            "        port: int,",
            "        app: WSGIApplication,",
            "        processes: int = 40,",
            "        handler: type[WSGIRequestHandler] | None = None,",
            "        passthrough_errors: bool = False,",
            "        ssl_context: _TSSLContextArg | None = None,",
            "        fd: int | None = None,",
            "    ) -> None:",
            "        if not can_fork:",
            "            raise ValueError(\"Your platform does not support forking.\")",
            "",
            "        super().__init__(host, port, app, handler, passthrough_errors, ssl_context, fd)",
            "        self.max_children = processes",
            "",
            "",
            "def make_server(",
            "    host: str,",
            "    port: int,",
            "    app: WSGIApplication,",
            "    threaded: bool = False,",
            "    processes: int = 1,",
            "    request_handler: type[WSGIRequestHandler] | None = None,",
            "    passthrough_errors: bool = False,",
            "    ssl_context: _TSSLContextArg | None = None,",
            "    fd: int | None = None,",
            ") -> BaseWSGIServer:",
            "    \"\"\"Create an appropriate WSGI server instance based on the value of",
            "    ``threaded`` and ``processes``.",
            "",
            "    This is called from :func:`run_simple`, but can be used separately",
            "    to have access to the server object, such as to run it in a separate",
            "    thread.",
            "",
            "    See :func:`run_simple` for parameter docs.",
            "    \"\"\"",
            "    if threaded and processes > 1:",
            "        raise ValueError(\"Cannot have a multi-thread and multi-process server.\")",
            "",
            "    if threaded:",
            "        return ThreadedWSGIServer(",
            "            host, port, app, request_handler, passthrough_errors, ssl_context, fd=fd",
            "        )",
            "",
            "    if processes > 1:",
            "        return ForkingWSGIServer(",
            "            host,",
            "            port,",
            "            app,",
            "            processes,",
            "            request_handler,",
            "            passthrough_errors,",
            "            ssl_context,",
            "            fd=fd,",
            "        )",
            "",
            "    return BaseWSGIServer(",
            "        host, port, app, request_handler, passthrough_errors, ssl_context, fd=fd",
            "    )",
            "",
            "",
            "def is_running_from_reloader() -> bool:",
            "    \"\"\"Check if the server is running as a subprocess within the",
            "    Werkzeug reloader.",
            "",
            "    .. versionadded:: 0.10",
            "    \"\"\"",
            "    return os.environ.get(\"WERKZEUG_RUN_MAIN\") == \"true\"",
            "",
            "",
            "def run_simple(",
            "    hostname: str,",
            "    port: int,",
            "    application: WSGIApplication,",
            "    use_reloader: bool = False,",
            "    use_debugger: bool = False,",
            "    use_evalex: bool = True,",
            "    extra_files: t.Iterable[str] | None = None,",
            "    exclude_patterns: t.Iterable[str] | None = None,",
            "    reloader_interval: int = 1,",
            "    reloader_type: str = \"auto\",",
            "    threaded: bool = False,",
            "    processes: int = 1,",
            "    request_handler: type[WSGIRequestHandler] | None = None,",
            "    static_files: dict[str, str | tuple[str, str]] | None = None,",
            "    passthrough_errors: bool = False,",
            "    ssl_context: _TSSLContextArg | None = None,",
            ") -> None:",
            "    \"\"\"Start a development server for a WSGI application. Various",
            "    optional features can be enabled.",
            "",
            "    .. warning::",
            "",
            "        Do not use the development server when deploying to production.",
            "        It is intended for use only during local development. It is not",
            "        designed to be particularly efficient, stable, or secure.",
            "",
            "    :param hostname: The host to bind to, for example ``'localhost'``.",
            "        Can be a domain, IPv4 or IPv6 address, or file path starting",
            "        with ``unix://`` for a Unix socket.",
            "    :param port: The port to bind to, for example ``8080``. Using ``0``",
            "        tells the OS to pick a random free port.",
            "    :param application: The WSGI application to run.",
            "    :param use_reloader: Use a reloader process to restart the server",
            "        process when files are changed.",
            "    :param use_debugger: Use Werkzeug's debugger, which will show",
            "        formatted tracebacks on unhandled exceptions.",
            "    :param use_evalex: Make the debugger interactive. A Python terminal",
            "        can be opened for any frame in the traceback. Some protection is",
            "        provided by requiring a PIN, but this should never be enabled",
            "        on a publicly visible server.",
            "    :param extra_files: The reloader will watch these files for changes",
            "        in addition to Python modules. For example, watch a",
            "        configuration file.",
            "    :param exclude_patterns: The reloader will ignore changes to any",
            "        files matching these :mod:`fnmatch` patterns. For example,",
            "        ignore cache files.",
            "    :param reloader_interval: How often the reloader tries to check for",
            "        changes.",
            "    :param reloader_type: The reloader to use. The ``'stat'`` reloader",
            "        is built in, but may require significant CPU to watch files. The",
            "        ``'watchdog'`` reloader is much more efficient but requires",
            "        installing the ``watchdog`` package first.",
            "    :param threaded: Handle concurrent requests using threads. Cannot be",
            "        used with ``processes``.",
            "    :param processes: Handle concurrent requests using up to this number",
            "        of processes. Cannot be used with ``threaded``.",
            "    :param request_handler: Use a different",
            "        :class:`~BaseHTTPServer.BaseHTTPRequestHandler` subclass to",
            "        handle requests.",
            "    :param static_files: A dict mapping URL prefixes to directories to",
            "        serve static files from using",
            "        :class:`~werkzeug.middleware.SharedDataMiddleware`.",
            "    :param passthrough_errors: Don't catch unhandled exceptions at the",
            "        server level, let the server crash instead. If ``use_debugger``",
            "        is enabled, the debugger will still catch such errors.",
            "    :param ssl_context: Configure TLS to serve over HTTPS. Can be an",
            "        :class:`ssl.SSLContext` object, a ``(cert_file, key_file)``",
            "        tuple to create a typical context, or the string ``'adhoc'`` to",
            "        generate a temporary self-signed certificate.",
            "",
            "    .. versionchanged:: 2.1",
            "        Instructions are shown for dealing with an \"address already in",
            "        use\" error.",
            "",
            "    .. versionchanged:: 2.1",
            "        Running on ``0.0.0.0`` or ``::`` shows the loopback IP in",
            "        addition to a real IP.",
            "",
            "    .. versionchanged:: 2.1",
            "        The command-line interface was removed.",
            "",
            "    .. versionchanged:: 2.0",
            "        Running on ``0.0.0.0`` or ``::`` shows a real IP address that",
            "        was bound as well as a warning not to run the development server",
            "        in production.",
            "",
            "    .. versionchanged:: 2.0",
            "        The ``exclude_patterns`` parameter was added.",
            "",
            "    .. versionchanged:: 0.15",
            "        Bind to a Unix socket by passing a ``hostname`` that starts with",
            "        ``unix://``.",
            "",
            "    .. versionchanged:: 0.10",
            "        Improved the reloader and added support for changing the backend",
            "        through the ``reloader_type`` parameter.",
            "",
            "    .. versionchanged:: 0.9",
            "        A command-line interface was added.",
            "",
            "    .. versionchanged:: 0.8",
            "        ``ssl_context`` can be a tuple of paths to the certificate and",
            "        private key files.",
            "",
            "    .. versionchanged:: 0.6",
            "        The ``ssl_context`` parameter was added.",
            "",
            "    .. versionchanged:: 0.5",
            "       The ``static_files`` and ``passthrough_errors`` parameters were",
            "       added.",
            "    \"\"\"",
            "    if not isinstance(port, int):",
            "        raise TypeError(\"port must be an integer\")",
            "",
            "    if static_files:",
            "        from .middleware.shared_data import SharedDataMiddleware",
            "",
            "        application = SharedDataMiddleware(application, static_files)",
            "",
            "    if use_debugger:",
            "        from .debug import DebuggedApplication",
            "",
            "        application = DebuggedApplication(application, evalex=use_evalex)",
            "        # Allow the specified hostname to use the debugger, in addition to",
            "        # localhost domains.",
            "        application.trusted_hosts.append(hostname)",
            "",
            "    if not is_running_from_reloader():",
            "        fd = None",
            "    else:",
            "        fd = int(os.environ[\"WERKZEUG_SERVER_FD\"])",
            "",
            "    srv = make_server(",
            "        hostname,",
            "        port,",
            "        application,",
            "        threaded,",
            "        processes,",
            "        request_handler,",
            "        passthrough_errors,",
            "        ssl_context,",
            "        fd=fd,",
            "    )",
            "    srv.socket.set_inheritable(True)",
            "    os.environ[\"WERKZEUG_SERVER_FD\"] = str(srv.fileno())",
            "",
            "    if not is_running_from_reloader():",
            "        srv.log_startup()",
            "        _log(\"info\", _ansi_style(\"Press CTRL+C to quit\", \"yellow\"))",
            "",
            "    if use_reloader:",
            "        from ._reloader import run_with_reloader",
            "",
            "        try:",
            "            run_with_reloader(",
            "                srv.serve_forever,",
            "                extra_files=extra_files,",
            "                exclude_patterns=exclude_patterns,",
            "                interval=reloader_interval,",
            "                reloader_type=reloader_type,",
            "            )",
            "        finally:",
            "            srv.server_close()",
            "    else:",
            "        srv.serve_forever()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "django.db.models.sql.query.Query.clear_ordering"
        ]
    }
}