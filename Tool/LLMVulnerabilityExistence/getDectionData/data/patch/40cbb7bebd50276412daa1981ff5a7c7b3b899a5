{
    "keystone/api/_shared/EC2_S3_Resource.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "             project_id=cred.get('project_id'),"
            },
            "1": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "             access=loaded.get('access'),"
            },
            "2": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 117,
                "PatchRowcode": "             secret=loaded.get('secret'),"
            },
            "3": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            trust_id=loaded.get('trust_id')"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+            trust_id=loaded.get('trust_id'),"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+            app_cred_id=loaded.get('app_cred_id'),"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+            access_token_id=loaded.get('access_token_id')"
            },
            "7": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "         )"
            },
            "8": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 122,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 123,
                "PatchRowcode": "         # validate the signature"
            },
            "10": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "                 sys.exc_info()[2])"
            },
            "11": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": 140,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "         self._check_timestamp(credentials)"
            },
            "13": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        roles = PROVIDERS.assignment_api.get_roles_for_user_and_project("
            },
            "14": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            user_ref['id'], project_ref['id'])"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+        trustee_user_id = None"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+        auth_context = None"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+        if cred_data['trust_id']:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+            trust = PROVIDERS.trust_api.get_trust(cred_data['trust_id'])"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+            roles = [r['id'] for r in trust['roles']]"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+            # NOTE(cmurphy): if this credential was created using a"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+            # trust-scoped token with impersonation, the user_id will be for"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+            # the trustor, not the trustee. In this case, issuing a"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+            # trust-scoped token to the trustor will fail. In order to get a"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+            # trust-scoped token, use the user ID of the trustee. With"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+            # impersonation, the resulting token will still be for the trustor."
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+            # Without impersonation, the token will be for the trustee."
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+            if trust['impersonation'] is True:"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+                trustee_user_id = trust['trustee_user_id']"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+        elif cred_data['app_cred_id']:"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+            ac_client = PROVIDERS.application_credential_api"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+            app_cred = ac_client.get_application_credential("
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+                cred_data['app_cred_id'])"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+            roles = [r['id'] for r in app_cred['roles']]"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+        elif cred_data['access_token_id']:"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+            access_token = PROVIDERS.oauth_api.get_access_token("
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+                cred_data['access_token_id'])"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+            roles = jsonutils.loads(access_token['role_ids'])"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+            auth_context = {'access_token_id': cred_data['access_token_id']}"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+        else:"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+            roles = PROVIDERS.assignment_api.get_roles_for_user_and_project("
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+                user_ref['id'], project_ref['id'])"
            },
            "43": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 170,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "         if not roles:"
            },
            "45": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "             raise ks_exceptions.Unauthorized(_('User not valid for project.'))"
            },
            "46": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 177,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "         method_names = ['ec2credential']"
            },
            "48": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 179,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+        if trustee_user_id:"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+            user_id = trustee_user_id"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+        else:"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+            user_id = user_ref['id']"
            },
            "53": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "         token = PROVIDERS.token_provider_api.issue_token("
            },
            "54": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            user_id=user_ref['id'], method_names=method_names,"
            },
            "55": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            project_id=project_ref['id'])"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+            user_id=user_id, method_names=method_names,"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+            project_id=project_ref['id'],"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+            trust_id=cred_data['trust_id'],"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+            app_cred_id=cred_data['app_cred_id'],"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+            auth_context=auth_context)"
            },
            "61": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "         return token"
            }
        },
        "frontPatchFile": [
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "# Common base resource for EC2 and S3 Authentication",
            "",
            "import datetime",
            "import sys",
            "",
            "from oslo_serialization import jsonutils",
            "from oslo_utils import timeutils",
            "import six",
            "from werkzeug import exceptions",
            "",
            "from keystone.common import provider_api",
            "from keystone.common import utils",
            "import keystone.conf",
            "from keystone import exception as ks_exceptions",
            "from keystone.i18n import _",
            "from keystone.server import flask as ks_flask",
            "",
            "CONF = keystone.conf.CONF",
            "PROVIDERS = provider_api.ProviderAPIs",
            "CRED_TYPE_EC2 = 'ec2'",
            "",
            "",
            "class ResourceBase(ks_flask.ResourceBase):",
            "    def get(self):",
            "        # SPECIAL CASE: GET is not allowed, raise METHOD_NOT_ALLOWED",
            "        raise exceptions.MethodNotAllowed(valid_methods=['POST'])",
            "",
            "    @staticmethod",
            "    def _check_signature(cred_ref, credentials):",
            "        # NOTE(morgan): @staticmethod doesn't always play nice with",
            "        # the ABC module.",
            "        raise NotImplementedError()",
            "",
            "    @staticmethod",
            "    def _check_timestamp(credentials):",
            "        timestamp = (",
            "            # AWS Signature v1/v2",
            "            credentials.get('params', {}).get('Timestamp') or",
            "            # AWS Signature v4",
            "            credentials.get('headers', {}).get('X-Amz-Date') or",
            "            credentials.get('params', {}).get('X-Amz-Date')",
            "        )",
            "        if not timestamp:",
            "            # If the signed payload doesn't include a timestamp then the signer",
            "            # must have intentionally left it off",
            "            return",
            "        try:",
            "            timestamp = timeutils.parse_isotime(timestamp)",
            "            timestamp = timeutils.normalize_time(timestamp)",
            "        except Exception as e:",
            "            raise ks_exceptions.Unauthorized(",
            "                _('Credential timestamp is invalid: %s') % e)",
            "        auth_ttl = datetime.timedelta(minutes=CONF.credential.auth_ttl)",
            "        current_time = timeutils.normalize_time(timeutils.utcnow())",
            "        if current_time > timestamp + auth_ttl:",
            "            raise ks_exceptions.Unauthorized(",
            "                _('Credential is expired'))",
            "",
            "    def handle_authenticate(self):",
            "        # TODO(morgan): convert this dirty check to JSON Schema validation",
            "        # this mirrors the previous behavior of the webob system where an",
            "        # empty request body for s3 and ec2 tokens would result in a BAD",
            "        # REQUEST. Almost all other APIs use JSON Schema and therefore would",
            "        # catch this early on. S3 and EC2 did not ever get json schema",
            "        # implemented for them.",
            "        if not self.request_body_json:",
            "            msg = _('request must include a request body')",
            "            raise ks_exceptions.ValidationError(msg)",
            "",
            "        # NOTE(morgan): THIS IS SLOPPY! Apparently... keystone passed values",
            "        # as \"credential\" and \"credentials\" in into the s3/ec2 authenticate",
            "        # methods. There is no reason the multiple names should have worked",
            "        # except that we totally did something wonky in the past... so now",
            "        # there are 2 dirty \"acceptable\" body hacks for compatibility....",
            "        # Try \"credentials\" then \"credential\" and THEN ec2Credentials. Final",
            "        # default is {}",
            "        credentials = (",
            "            self.request_body_json.get('credentials') or",
            "            self.request_body_json.get('credential') or",
            "            self.request_body_json.get('ec2Credentials')",
            "        )",
            "        if not credentials:",
            "            credentials = {}",
            "",
            "        if 'access' not in credentials:",
            "            raise ks_exceptions.Unauthorized(_('EC2 Signature not supplied'))",
            "",
            "        # Load the credential from the backend",
            "        credential_id = utils.hash_access_key(credentials['access'])",
            "        cred = PROVIDERS.credential_api.get_credential(credential_id)",
            "        if not cred or cred['type'] != CRED_TYPE_EC2:",
            "            raise ks_exceptions.Unauthorized(_('EC2 access key not found.'))",
            "",
            "        # load from json if needed",
            "        try:",
            "            loaded = jsonutils.loads(cred['blob'])",
            "        except TypeError:",
            "            loaded = cred['blob']",
            "",
            "        # Convert to the legacy format",
            "        cred_data = dict(",
            "            user_id=cred.get('user_id'),",
            "            project_id=cred.get('project_id'),",
            "            access=loaded.get('access'),",
            "            secret=loaded.get('secret'),",
            "            trust_id=loaded.get('trust_id')",
            "        )",
            "",
            "        # validate the signature",
            "        self._check_signature(cred_data, credentials)",
            "        project_ref = PROVIDERS.resource_api.get_project(",
            "            cred_data['project_id'])",
            "        user_ref = PROVIDERS.identity_api.get_user(cred_data['user_id'])",
            "",
            "        # validate that the auth info is valid and nothing is disabled",
            "        try:",
            "            PROVIDERS.identity_api.assert_user_enabled(",
            "                user_id=user_ref['id'], user=user_ref)",
            "            PROVIDERS.resource_api.assert_project_enabled(",
            "                project_id=project_ref['id'], project=project_ref)",
            "        except AssertionError as e:",
            "            six.reraise(",
            "                ks_exceptions.Unauthorized,",
            "                ks_exceptions.Unauthorized(e),",
            "                sys.exc_info()[2])",
            "",
            "        self._check_timestamp(credentials)",
            "        roles = PROVIDERS.assignment_api.get_roles_for_user_and_project(",
            "            user_ref['id'], project_ref['id'])",
            "",
            "        if not roles:",
            "            raise ks_exceptions.Unauthorized(_('User not valid for project.'))",
            "",
            "        for r_id in roles:",
            "            # Assert all roles exist.",
            "            PROVIDERS.role_api.get_role(r_id)",
            "",
            "        method_names = ['ec2credential']",
            "",
            "        token = PROVIDERS.token_provider_api.issue_token(",
            "            user_id=user_ref['id'], method_names=method_names,",
            "            project_id=project_ref['id'])",
            "        return token"
        ],
        "afterPatchFile": [
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "# Common base resource for EC2 and S3 Authentication",
            "",
            "import datetime",
            "import sys",
            "",
            "from oslo_serialization import jsonutils",
            "from oslo_utils import timeutils",
            "import six",
            "from werkzeug import exceptions",
            "",
            "from keystone.common import provider_api",
            "from keystone.common import utils",
            "import keystone.conf",
            "from keystone import exception as ks_exceptions",
            "from keystone.i18n import _",
            "from keystone.server import flask as ks_flask",
            "",
            "CONF = keystone.conf.CONF",
            "PROVIDERS = provider_api.ProviderAPIs",
            "CRED_TYPE_EC2 = 'ec2'",
            "",
            "",
            "class ResourceBase(ks_flask.ResourceBase):",
            "    def get(self):",
            "        # SPECIAL CASE: GET is not allowed, raise METHOD_NOT_ALLOWED",
            "        raise exceptions.MethodNotAllowed(valid_methods=['POST'])",
            "",
            "    @staticmethod",
            "    def _check_signature(cred_ref, credentials):",
            "        # NOTE(morgan): @staticmethod doesn't always play nice with",
            "        # the ABC module.",
            "        raise NotImplementedError()",
            "",
            "    @staticmethod",
            "    def _check_timestamp(credentials):",
            "        timestamp = (",
            "            # AWS Signature v1/v2",
            "            credentials.get('params', {}).get('Timestamp') or",
            "            # AWS Signature v4",
            "            credentials.get('headers', {}).get('X-Amz-Date') or",
            "            credentials.get('params', {}).get('X-Amz-Date')",
            "        )",
            "        if not timestamp:",
            "            # If the signed payload doesn't include a timestamp then the signer",
            "            # must have intentionally left it off",
            "            return",
            "        try:",
            "            timestamp = timeutils.parse_isotime(timestamp)",
            "            timestamp = timeutils.normalize_time(timestamp)",
            "        except Exception as e:",
            "            raise ks_exceptions.Unauthorized(",
            "                _('Credential timestamp is invalid: %s') % e)",
            "        auth_ttl = datetime.timedelta(minutes=CONF.credential.auth_ttl)",
            "        current_time = timeutils.normalize_time(timeutils.utcnow())",
            "        if current_time > timestamp + auth_ttl:",
            "            raise ks_exceptions.Unauthorized(",
            "                _('Credential is expired'))",
            "",
            "    def handle_authenticate(self):",
            "        # TODO(morgan): convert this dirty check to JSON Schema validation",
            "        # this mirrors the previous behavior of the webob system where an",
            "        # empty request body for s3 and ec2 tokens would result in a BAD",
            "        # REQUEST. Almost all other APIs use JSON Schema and therefore would",
            "        # catch this early on. S3 and EC2 did not ever get json schema",
            "        # implemented for them.",
            "        if not self.request_body_json:",
            "            msg = _('request must include a request body')",
            "            raise ks_exceptions.ValidationError(msg)",
            "",
            "        # NOTE(morgan): THIS IS SLOPPY! Apparently... keystone passed values",
            "        # as \"credential\" and \"credentials\" in into the s3/ec2 authenticate",
            "        # methods. There is no reason the multiple names should have worked",
            "        # except that we totally did something wonky in the past... so now",
            "        # there are 2 dirty \"acceptable\" body hacks for compatibility....",
            "        # Try \"credentials\" then \"credential\" and THEN ec2Credentials. Final",
            "        # default is {}",
            "        credentials = (",
            "            self.request_body_json.get('credentials') or",
            "            self.request_body_json.get('credential') or",
            "            self.request_body_json.get('ec2Credentials')",
            "        )",
            "        if not credentials:",
            "            credentials = {}",
            "",
            "        if 'access' not in credentials:",
            "            raise ks_exceptions.Unauthorized(_('EC2 Signature not supplied'))",
            "",
            "        # Load the credential from the backend",
            "        credential_id = utils.hash_access_key(credentials['access'])",
            "        cred = PROVIDERS.credential_api.get_credential(credential_id)",
            "        if not cred or cred['type'] != CRED_TYPE_EC2:",
            "            raise ks_exceptions.Unauthorized(_('EC2 access key not found.'))",
            "",
            "        # load from json if needed",
            "        try:",
            "            loaded = jsonutils.loads(cred['blob'])",
            "        except TypeError:",
            "            loaded = cred['blob']",
            "",
            "        # Convert to the legacy format",
            "        cred_data = dict(",
            "            user_id=cred.get('user_id'),",
            "            project_id=cred.get('project_id'),",
            "            access=loaded.get('access'),",
            "            secret=loaded.get('secret'),",
            "            trust_id=loaded.get('trust_id'),",
            "            app_cred_id=loaded.get('app_cred_id'),",
            "            access_token_id=loaded.get('access_token_id')",
            "        )",
            "",
            "        # validate the signature",
            "        self._check_signature(cred_data, credentials)",
            "        project_ref = PROVIDERS.resource_api.get_project(",
            "            cred_data['project_id'])",
            "        user_ref = PROVIDERS.identity_api.get_user(cred_data['user_id'])",
            "",
            "        # validate that the auth info is valid and nothing is disabled",
            "        try:",
            "            PROVIDERS.identity_api.assert_user_enabled(",
            "                user_id=user_ref['id'], user=user_ref)",
            "            PROVIDERS.resource_api.assert_project_enabled(",
            "                project_id=project_ref['id'], project=project_ref)",
            "        except AssertionError as e:",
            "            six.reraise(",
            "                ks_exceptions.Unauthorized,",
            "                ks_exceptions.Unauthorized(e),",
            "                sys.exc_info()[2])",
            "",
            "        self._check_timestamp(credentials)",
            "",
            "        trustee_user_id = None",
            "        auth_context = None",
            "        if cred_data['trust_id']:",
            "            trust = PROVIDERS.trust_api.get_trust(cred_data['trust_id'])",
            "            roles = [r['id'] for r in trust['roles']]",
            "            # NOTE(cmurphy): if this credential was created using a",
            "            # trust-scoped token with impersonation, the user_id will be for",
            "            # the trustor, not the trustee. In this case, issuing a",
            "            # trust-scoped token to the trustor will fail. In order to get a",
            "            # trust-scoped token, use the user ID of the trustee. With",
            "            # impersonation, the resulting token will still be for the trustor.",
            "            # Without impersonation, the token will be for the trustee.",
            "            if trust['impersonation'] is True:",
            "                trustee_user_id = trust['trustee_user_id']",
            "        elif cred_data['app_cred_id']:",
            "            ac_client = PROVIDERS.application_credential_api",
            "            app_cred = ac_client.get_application_credential(",
            "                cred_data['app_cred_id'])",
            "            roles = [r['id'] for r in app_cred['roles']]",
            "        elif cred_data['access_token_id']:",
            "            access_token = PROVIDERS.oauth_api.get_access_token(",
            "                cred_data['access_token_id'])",
            "            roles = jsonutils.loads(access_token['role_ids'])",
            "            auth_context = {'access_token_id': cred_data['access_token_id']}",
            "        else:",
            "            roles = PROVIDERS.assignment_api.get_roles_for_user_and_project(",
            "                user_ref['id'], project_ref['id'])",
            "",
            "        if not roles:",
            "            raise ks_exceptions.Unauthorized(_('User not valid for project.'))",
            "",
            "        for r_id in roles:",
            "            # Assert all roles exist.",
            "            PROVIDERS.role_api.get_role(r_id)",
            "",
            "        method_names = ['ec2credential']",
            "",
            "        if trustee_user_id:",
            "            user_id = trustee_user_id",
            "        else:",
            "            user_id = user_ref['id']",
            "        token = PROVIDERS.token_provider_api.issue_token(",
            "            user_id=user_id, method_names=method_names,",
            "            project_id=project_ref['id'],",
            "            trust_id=cred_data['trust_id'],",
            "            app_cred_id=cred_data['app_cred_id'],",
            "            auth_context=auth_context)",
            "        return token"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0"
        ],
        "dele_reviseLocation": {
            "118": [
                "ResourceBase",
                "handle_authenticate"
            ],
            "140": [
                "ResourceBase",
                "handle_authenticate"
            ],
            "141": [
                "ResourceBase",
                "handle_authenticate"
            ],
            "153": [
                "ResourceBase",
                "handle_authenticate"
            ],
            "154": [
                "ResourceBase",
                "handle_authenticate"
            ]
        },
        "addLocation": []
    },
    "keystone/api/credentials.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " # This file handles all flask-restful resources for /v3/credentials"
            },
            "1": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " import hashlib"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+import six"
            },
            "4": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " import flask"
            },
            "6": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from oslo_serialization import jsonutils"
            },
            "7": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "             ref['blob'] = jsonutils.dumps(blob)"
            },
            "8": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         return ref"
            },
            "9": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def _assign_unique_id(self, ref, trust_id=None):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+    def _validate_blob_json(self, ref):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+        try:"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+            blob = jsonutils.loads(ref.get('blob'))"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        except (ValueError, TabError):"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+            raise exception.ValidationError("
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+                message=_('Invalid blob in credential'))"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+        if not blob or not isinstance(blob, dict):"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+            raise exception.ValidationError(attribute='blob',"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+                                            target='credential')"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+        if blob.get('access') is None:"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+            raise exception.ValidationError(attribute='access',"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+                                            target='credential')"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+        return blob"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+    def _assign_unique_id("
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+            self, ref, trust_id=None, app_cred_id=None, access_token_id=None):"
            },
            "27": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 80,
                "PatchRowcode": "         # Generates an assigns a unique identifier to a credential reference."
            },
            "28": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         if ref.get('type', '').lower() == 'ec2':"
            },
            "29": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            try:"
            },
            "30": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                blob = jsonutils.loads(ref.get('blob'))"
            },
            "31": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            except (ValueError, TabError):"
            },
            "32": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                raise exception.ValidationError("
            },
            "33": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    message=_('Invalid blob in credential'))"
            },
            "34": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if not blob or not isinstance(blob, dict):"
            },
            "35": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                raise exception.ValidationError(attribute='blob',"
            },
            "36": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                target='credential')"
            },
            "37": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if blob.get('access') is None:"
            },
            "38": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                raise exception.ValidationError(attribute='access',"
            },
            "39": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                target='credential')"
            },
            "40": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+            blob = self._validate_blob_json(ref)"
            },
            "42": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "             ref = ref.copy()"
            },
            "43": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "             ref['id'] = hashlib.sha256("
            },
            "44": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "                 blob['access'].encode('utf8')).hexdigest()"
            },
            "45": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # update the blob with the trust_id, so credentials created with"
            },
            "46": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # a trust scoped token will result in trust scoped tokens when"
            },
            "47": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # authentication via ec2tokens happens"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+            # update the blob with the trust_id or app_cred_id, so credentials"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+            # created with a trust- or app cred-scoped token will result in"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+            # trust- or app cred-scoped tokens when authentication via"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+            # ec2tokens happens"
            },
            "52": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "             if trust_id is not None:"
            },
            "53": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "                 blob['trust_id'] = trust_id"
            },
            "54": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "                 ref['blob'] = jsonutils.dumps(blob)"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+            if app_cred_id is not None:"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+                blob['app_cred_id'] = app_cred_id"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+                ref['blob'] = jsonutils.dumps(blob)"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+            if access_token_id is not None:"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+                blob['access_token_id'] = access_token_id"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+                ref['blob'] = jsonutils.dumps(blob)"
            },
            "61": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 99,
                "PatchRowcode": "             return ref"
            },
            "62": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "         else:"
            },
            "63": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "             return super(CredentialResource, self)._assign_unique_id(ref)"
            },
            "64": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "         )"
            },
            "65": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 159,
                "PatchRowcode": "         validation.lazy_validate(schema.credential_create, credential)"
            },
            "66": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "         trust_id = getattr(self.oslo_context, 'trust_id', None)"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+        app_cred_id = getattr("
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+            self.auth_context['token'], 'application_credential_id', None)"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+        access_token_id = getattr("
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+            self.auth_context['token'], 'access_token_id', None)"
            },
            "71": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "         ref = self._assign_unique_id("
            },
            "72": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self._normalize_dict(credential), trust_id=trust_id)"
            },
            "73": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ref = PROVIDERS.credential_api.create_credential(ref['id'], ref,"
            },
            "74": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                                         initiator=self.audit_initiator)"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+            self._normalize_dict(credential),"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+            trust_id=trust_id, app_cred_id=app_cred_id,"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+            access_token_id=access_token_id)"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+        ref = PROVIDERS.credential_api.create_credential("
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+            ref['id'], ref, initiator=self.audit_initiator)"
            },
            "80": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "         return self.wrap_member(ref), http_client.CREATED"
            },
            "81": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 172,
                "PatchRowcode": " "
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+    def _validate_blob_update_keys(self, credential, ref):"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+        if credential.get('type', '').lower() == 'ec2':"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+            new_blob = self._validate_blob_json(ref)"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+            old_blob = credential.get('blob')"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+            if isinstance(old_blob, six.string_types):"
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+                old_blob = jsonutils.loads(old_blob)"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+            # if there was a scope set, prevent changing it or unsetting it"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+            for key in ['trust_id', 'app_cred_id', 'access_token_id']:"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+                if old_blob.get(key) != new_blob.get(key):"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+                    message = _('%s can not be updated for credential') % key"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+                    raise exception.ValidationError(message=message)"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+"
            },
            "94": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "     def patch(self, credential_id):"
            },
            "95": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 186,
                "PatchRowcode": "         # Update Credential"
            },
            "96": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 187,
                "PatchRowcode": "         ENFORCER.enforce_call("
            },
            "97": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "             action='identity:update_credential',"
            },
            "98": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "             build_target=_build_target_enforcement"
            },
            "99": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "         )"
            },
            "100": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        PROVIDERS.credential_api.get_credential(credential_id)"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+        current = PROVIDERS.credential_api.get_credential(credential_id)"
            },
            "102": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 192,
                "PatchRowcode": " "
            },
            "103": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 193,
                "PatchRowcode": "         credential = self.request_body_json.get('credential', {})"
            },
            "104": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 194,
                "PatchRowcode": "         validation.lazy_validate(schema.credential_update, credential)"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+        self._validate_blob_update_keys(current.copy(), credential.copy())"
            },
            "106": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 196,
                "PatchRowcode": "         self._require_matching_id(credential)"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+        # Check that the user hasn't illegally modified the owner or scope"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+        target = {'credential': dict(current, **credential)}"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+        ENFORCER.enforce_call("
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+            action='identity:update_credential', target_attr=target"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+        )"
            },
            "112": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 202,
                "PatchRowcode": "         ref = PROVIDERS.credential_api.update_credential("
            },
            "113": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "             credential_id, credential)"
            },
            "114": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "         return self.wrap_member(ref)"
            }
        },
        "frontPatchFile": [
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "# This file handles all flask-restful resources for /v3/credentials",
            "",
            "import hashlib",
            "",
            "import flask",
            "from oslo_serialization import jsonutils",
            "from six.moves import http_client",
            "",
            "from keystone.common import provider_api",
            "from keystone.common import rbac_enforcer",
            "from keystone.common import validation",
            "import keystone.conf",
            "from keystone.credential import schema",
            "from keystone import exception",
            "from keystone.i18n import _",
            "from keystone.server import flask as ks_flask",
            "",
            "CONF = keystone.conf.CONF",
            "PROVIDERS = provider_api.ProviderAPIs",
            "ENFORCER = rbac_enforcer.RBACEnforcer",
            "",
            "",
            "def _build_target_enforcement():",
            "    target = {}",
            "    try:",
            "        target['credential'] = PROVIDERS.credential_api.get_credential(",
            "            flask.request.view_args.get('credential_id')",
            "        )",
            "    except exception.NotFound:  # nosec",
            "        # Defer existance in the event the credential doesn't exist, we'll",
            "        # check this later anyway.",
            "        pass",
            "",
            "    return target",
            "",
            "",
            "class CredentialResource(ks_flask.ResourceBase):",
            "    collection_key = 'credentials'",
            "    member_key = 'credential'",
            "",
            "    @staticmethod",
            "    def _blob_to_json(ref):",
            "        # credentials stored via ec2tokens before the fix for #1259584",
            "        # need json_serailzing, as that's the documented API format",
            "        blob = ref.get('blob')",
            "        if isinstance(blob, dict):",
            "            ref = ref.copy()",
            "            ref['blob'] = jsonutils.dumps(blob)",
            "        return ref",
            "",
            "    def _assign_unique_id(self, ref, trust_id=None):",
            "        # Generates an assigns a unique identifier to a credential reference.",
            "        if ref.get('type', '').lower() == 'ec2':",
            "            try:",
            "                blob = jsonutils.loads(ref.get('blob'))",
            "            except (ValueError, TabError):",
            "                raise exception.ValidationError(",
            "                    message=_('Invalid blob in credential'))",
            "            if not blob or not isinstance(blob, dict):",
            "                raise exception.ValidationError(attribute='blob',",
            "                                                target='credential')",
            "            if blob.get('access') is None:",
            "                raise exception.ValidationError(attribute='access',",
            "                                                target='credential')",
            "",
            "            ref = ref.copy()",
            "            ref['id'] = hashlib.sha256(",
            "                blob['access'].encode('utf8')).hexdigest()",
            "            # update the blob with the trust_id, so credentials created with",
            "            # a trust scoped token will result in trust scoped tokens when",
            "            # authentication via ec2tokens happens",
            "            if trust_id is not None:",
            "                blob['trust_id'] = trust_id",
            "                ref['blob'] = jsonutils.dumps(blob)",
            "            return ref",
            "        else:",
            "            return super(CredentialResource, self)._assign_unique_id(ref)",
            "",
            "    def _list_credentials(self):",
            "        filters = ['user_id', 'type']",
            "        if not self.oslo_context.system_scope:",
            "            target = {'credential': {'user_id': self.oslo_context.user_id}}",
            "        else:",
            "            target = None",
            "        ENFORCER.enforce_call(action='identity:list_credentials',",
            "                              filters=filters, target_attr=target)",
            "        hints = self.build_driver_hints(filters)",
            "        refs = PROVIDERS.credential_api.list_credentials(hints)",
            "        # If the request was filtered, make sure to return only the",
            "        # credentials specific to that user. This makes it so that users with",
            "        # roles on projects can't see credentials that aren't theirs.",
            "        filtered_refs = []",
            "        for ref in refs:",
            "            # Check each credential again to make sure the user has access to",
            "            # it, either by owning it, being a project admin with",
            "            # enforce_scope=false, being a system user, or having some other",
            "            # custom policy that allows access.",
            "            try:",
            "                cred = PROVIDERS.credential_api.get_credential(ref['id'])",
            "                ENFORCER.enforce_call(",
            "                    action='identity:get_credential',",
            "                    target_attr={'credential': cred}",
            "                )",
            "                filtered_refs.append(ref)",
            "            except exception.Forbidden:",
            "                pass",
            "        refs = filtered_refs",
            "        refs = [self._blob_to_json(r) for r in refs]",
            "        return self.wrap_collection(refs, hints=hints)",
            "",
            "    def _get_credential(self, credential_id):",
            "        ENFORCER.enforce_call(",
            "            action='identity:get_credential',",
            "            build_target=_build_target_enforcement",
            "        )",
            "        credential = PROVIDERS.credential_api.get_credential(credential_id)",
            "        return self.wrap_member(self._blob_to_json(credential))",
            "",
            "    def get(self, credential_id=None):",
            "        # Get Credential or List of credentials.",
            "        if credential_id is None:",
            "            # No Parameter passed means that we're doing a LIST action.",
            "            return self._list_credentials()",
            "        else:",
            "            return self._get_credential(credential_id)",
            "",
            "    def post(self):",
            "        # Create a new credential",
            "        credential = self.request_body_json.get('credential', {})",
            "        target = {}",
            "        target['credential'] = credential",
            "        ENFORCER.enforce_call(",
            "            action='identity:create_credential', target_attr=target",
            "        )",
            "        validation.lazy_validate(schema.credential_create, credential)",
            "        trust_id = getattr(self.oslo_context, 'trust_id', None)",
            "        ref = self._assign_unique_id(",
            "            self._normalize_dict(credential), trust_id=trust_id)",
            "        ref = PROVIDERS.credential_api.create_credential(ref['id'], ref,",
            "                                                         initiator=self.audit_initiator)",
            "        return self.wrap_member(ref), http_client.CREATED",
            "",
            "    def patch(self, credential_id):",
            "        # Update Credential",
            "        ENFORCER.enforce_call(",
            "            action='identity:update_credential',",
            "            build_target=_build_target_enforcement",
            "        )",
            "        PROVIDERS.credential_api.get_credential(credential_id)",
            "",
            "        credential = self.request_body_json.get('credential', {})",
            "        validation.lazy_validate(schema.credential_update, credential)",
            "        self._require_matching_id(credential)",
            "        ref = PROVIDERS.credential_api.update_credential(",
            "            credential_id, credential)",
            "        return self.wrap_member(ref)",
            "",
            "    def delete(self, credential_id):",
            "        # Delete credentials",
            "        ENFORCER.enforce_call(",
            "            action='identity:delete_credential',",
            "            build_target=_build_target_enforcement",
            "        )",
            "",
            "        return (PROVIDERS.credential_api.delete_credential(credential_id,",
            "                                                           initiator=self.audit_initiator),",
            "                http_client.NO_CONTENT)",
            "",
            "",
            "class CredentialAPI(ks_flask.APIBase):",
            "",
            "    _name = 'credentials'",
            "    _import_name = __name__",
            "    resource_mapping = []",
            "    resources = [CredentialResource]",
            "",
            "",
            "APIs = (CredentialAPI,)"
        ],
        "afterPatchFile": [
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "# This file handles all flask-restful resources for /v3/credentials",
            "",
            "import hashlib",
            "import six",
            "",
            "import flask",
            "from oslo_serialization import jsonutils",
            "from six.moves import http_client",
            "",
            "from keystone.common import provider_api",
            "from keystone.common import rbac_enforcer",
            "from keystone.common import validation",
            "import keystone.conf",
            "from keystone.credential import schema",
            "from keystone import exception",
            "from keystone.i18n import _",
            "from keystone.server import flask as ks_flask",
            "",
            "CONF = keystone.conf.CONF",
            "PROVIDERS = provider_api.ProviderAPIs",
            "ENFORCER = rbac_enforcer.RBACEnforcer",
            "",
            "",
            "def _build_target_enforcement():",
            "    target = {}",
            "    try:",
            "        target['credential'] = PROVIDERS.credential_api.get_credential(",
            "            flask.request.view_args.get('credential_id')",
            "        )",
            "    except exception.NotFound:  # nosec",
            "        # Defer existance in the event the credential doesn't exist, we'll",
            "        # check this later anyway.",
            "        pass",
            "",
            "    return target",
            "",
            "",
            "class CredentialResource(ks_flask.ResourceBase):",
            "    collection_key = 'credentials'",
            "    member_key = 'credential'",
            "",
            "    @staticmethod",
            "    def _blob_to_json(ref):",
            "        # credentials stored via ec2tokens before the fix for #1259584",
            "        # need json_serailzing, as that's the documented API format",
            "        blob = ref.get('blob')",
            "        if isinstance(blob, dict):",
            "            ref = ref.copy()",
            "            ref['blob'] = jsonutils.dumps(blob)",
            "        return ref",
            "",
            "    def _validate_blob_json(self, ref):",
            "        try:",
            "            blob = jsonutils.loads(ref.get('blob'))",
            "        except (ValueError, TabError):",
            "            raise exception.ValidationError(",
            "                message=_('Invalid blob in credential'))",
            "        if not blob or not isinstance(blob, dict):",
            "            raise exception.ValidationError(attribute='blob',",
            "                                            target='credential')",
            "        if blob.get('access') is None:",
            "            raise exception.ValidationError(attribute='access',",
            "                                            target='credential')",
            "        return blob",
            "",
            "    def _assign_unique_id(",
            "            self, ref, trust_id=None, app_cred_id=None, access_token_id=None):",
            "        # Generates an assigns a unique identifier to a credential reference.",
            "        if ref.get('type', '').lower() == 'ec2':",
            "            blob = self._validate_blob_json(ref)",
            "            ref = ref.copy()",
            "            ref['id'] = hashlib.sha256(",
            "                blob['access'].encode('utf8')).hexdigest()",
            "            # update the blob with the trust_id or app_cred_id, so credentials",
            "            # created with a trust- or app cred-scoped token will result in",
            "            # trust- or app cred-scoped tokens when authentication via",
            "            # ec2tokens happens",
            "            if trust_id is not None:",
            "                blob['trust_id'] = trust_id",
            "                ref['blob'] = jsonutils.dumps(blob)",
            "            if app_cred_id is not None:",
            "                blob['app_cred_id'] = app_cred_id",
            "                ref['blob'] = jsonutils.dumps(blob)",
            "            if access_token_id is not None:",
            "                blob['access_token_id'] = access_token_id",
            "                ref['blob'] = jsonutils.dumps(blob)",
            "            return ref",
            "        else:",
            "            return super(CredentialResource, self)._assign_unique_id(ref)",
            "",
            "    def _list_credentials(self):",
            "        filters = ['user_id', 'type']",
            "        if not self.oslo_context.system_scope:",
            "            target = {'credential': {'user_id': self.oslo_context.user_id}}",
            "        else:",
            "            target = None",
            "        ENFORCER.enforce_call(action='identity:list_credentials',",
            "                              filters=filters, target_attr=target)",
            "        hints = self.build_driver_hints(filters)",
            "        refs = PROVIDERS.credential_api.list_credentials(hints)",
            "        # If the request was filtered, make sure to return only the",
            "        # credentials specific to that user. This makes it so that users with",
            "        # roles on projects can't see credentials that aren't theirs.",
            "        filtered_refs = []",
            "        for ref in refs:",
            "            # Check each credential again to make sure the user has access to",
            "            # it, either by owning it, being a project admin with",
            "            # enforce_scope=false, being a system user, or having some other",
            "            # custom policy that allows access.",
            "            try:",
            "                cred = PROVIDERS.credential_api.get_credential(ref['id'])",
            "                ENFORCER.enforce_call(",
            "                    action='identity:get_credential',",
            "                    target_attr={'credential': cred}",
            "                )",
            "                filtered_refs.append(ref)",
            "            except exception.Forbidden:",
            "                pass",
            "        refs = filtered_refs",
            "        refs = [self._blob_to_json(r) for r in refs]",
            "        return self.wrap_collection(refs, hints=hints)",
            "",
            "    def _get_credential(self, credential_id):",
            "        ENFORCER.enforce_call(",
            "            action='identity:get_credential',",
            "            build_target=_build_target_enforcement",
            "        )",
            "        credential = PROVIDERS.credential_api.get_credential(credential_id)",
            "        return self.wrap_member(self._blob_to_json(credential))",
            "",
            "    def get(self, credential_id=None):",
            "        # Get Credential or List of credentials.",
            "        if credential_id is None:",
            "            # No Parameter passed means that we're doing a LIST action.",
            "            return self._list_credentials()",
            "        else:",
            "            return self._get_credential(credential_id)",
            "",
            "    def post(self):",
            "        # Create a new credential",
            "        credential = self.request_body_json.get('credential', {})",
            "        target = {}",
            "        target['credential'] = credential",
            "        ENFORCER.enforce_call(",
            "            action='identity:create_credential', target_attr=target",
            "        )",
            "        validation.lazy_validate(schema.credential_create, credential)",
            "        trust_id = getattr(self.oslo_context, 'trust_id', None)",
            "        app_cred_id = getattr(",
            "            self.auth_context['token'], 'application_credential_id', None)",
            "        access_token_id = getattr(",
            "            self.auth_context['token'], 'access_token_id', None)",
            "        ref = self._assign_unique_id(",
            "            self._normalize_dict(credential),",
            "            trust_id=trust_id, app_cred_id=app_cred_id,",
            "            access_token_id=access_token_id)",
            "        ref = PROVIDERS.credential_api.create_credential(",
            "            ref['id'], ref, initiator=self.audit_initiator)",
            "        return self.wrap_member(ref), http_client.CREATED",
            "",
            "    def _validate_blob_update_keys(self, credential, ref):",
            "        if credential.get('type', '').lower() == 'ec2':",
            "            new_blob = self._validate_blob_json(ref)",
            "            old_blob = credential.get('blob')",
            "            if isinstance(old_blob, six.string_types):",
            "                old_blob = jsonutils.loads(old_blob)",
            "            # if there was a scope set, prevent changing it or unsetting it",
            "            for key in ['trust_id', 'app_cred_id', 'access_token_id']:",
            "                if old_blob.get(key) != new_blob.get(key):",
            "                    message = _('%s can not be updated for credential') % key",
            "                    raise exception.ValidationError(message=message)",
            "",
            "    def patch(self, credential_id):",
            "        # Update Credential",
            "        ENFORCER.enforce_call(",
            "            action='identity:update_credential',",
            "            build_target=_build_target_enforcement",
            "        )",
            "        current = PROVIDERS.credential_api.get_credential(credential_id)",
            "",
            "        credential = self.request_body_json.get('credential', {})",
            "        validation.lazy_validate(schema.credential_update, credential)",
            "        self._validate_blob_update_keys(current.copy(), credential.copy())",
            "        self._require_matching_id(credential)",
            "        # Check that the user hasn't illegally modified the owner or scope",
            "        target = {'credential': dict(current, **credential)}",
            "        ENFORCER.enforce_call(",
            "            action='identity:update_credential', target_attr=target",
            "        )",
            "        ref = PROVIDERS.credential_api.update_credential(",
            "            credential_id, credential)",
            "        return self.wrap_member(ref)",
            "",
            "    def delete(self, credential_id):",
            "        # Delete credentials",
            "        ENFORCER.enforce_call(",
            "            action='identity:delete_credential',",
            "            build_target=_build_target_enforcement",
            "        )",
            "",
            "        return (PROVIDERS.credential_api.delete_credential(credential_id,",
            "                                                           initiator=self.audit_initiator),",
            "                http_client.NO_CONTENT)",
            "",
            "",
            "class CredentialAPI(ks_flask.APIBase):",
            "",
            "    _name = 'credentials'",
            "    _import_name = __name__",
            "    resource_mapping = []",
            "    resources = [CredentialResource]",
            "",
            "",
            "APIs = (CredentialAPI,)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "63": [
                "CredentialResource",
                "_assign_unique_id"
            ],
            "66": [
                "CredentialResource",
                "_assign_unique_id"
            ],
            "67": [
                "CredentialResource",
                "_assign_unique_id"
            ],
            "68": [
                "CredentialResource",
                "_assign_unique_id"
            ],
            "69": [
                "CredentialResource",
                "_assign_unique_id"
            ],
            "70": [
                "CredentialResource",
                "_assign_unique_id"
            ],
            "71": [
                "CredentialResource",
                "_assign_unique_id"
            ],
            "72": [
                "CredentialResource",
                "_assign_unique_id"
            ],
            "73": [
                "CredentialResource",
                "_assign_unique_id"
            ],
            "74": [
                "CredentialResource",
                "_assign_unique_id"
            ],
            "75": [
                "CredentialResource",
                "_assign_unique_id"
            ],
            "76": [
                "CredentialResource",
                "_assign_unique_id"
            ],
            "77": [
                "CredentialResource",
                "_assign_unique_id"
            ],
            "81": [
                "CredentialResource",
                "_assign_unique_id"
            ],
            "82": [
                "CredentialResource",
                "_assign_unique_id"
            ],
            "83": [
                "CredentialResource",
                "_assign_unique_id"
            ],
            "150": [
                "CredentialResource",
                "post"
            ],
            "151": [
                "CredentialResource",
                "post"
            ],
            "152": [
                "CredentialResource",
                "post"
            ],
            "161": [
                "CredentialResource",
                "patch"
            ]
        },
        "addLocation": []
    },
    "keystone/api/users.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 559,
                "afterPatchRowNumber": 559,
                "PatchRowcode": "                     role['name']))"
            },
            "1": {
                "beforePatchRowNumber": 560,
                "afterPatchRowNumber": 560,
                "PatchRowcode": "         return roles"
            },
            "2": {
                "beforePatchRowNumber": 561,
                "afterPatchRowNumber": 561,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 562,
                "PatchRowcode": "+    def _get_roles(self, app_cred_data, token):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 563,
                "PatchRowcode": "+        if app_cred_data.get('roles'):"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 564,
                "PatchRowcode": "+            roles = self._normalize_role_list(app_cred_data['roles'])"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 565,
                "PatchRowcode": "+            # NOTE(cmurphy): The user is not allowed to add a role that is not"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 566,
                "PatchRowcode": "+            # in their token. This is to prevent trustees or application"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 567,
                "PatchRowcode": "+            # credential users from escallating their privileges to include"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 568,
                "PatchRowcode": "+            # additional roles that the trustor or application credential"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 569,
                "PatchRowcode": "+            # creator has assigned on the project."
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 570,
                "PatchRowcode": "+            token_roles = [r['id'] for r in token.roles]"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 571,
                "PatchRowcode": "+            for role in roles:"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 572,
                "PatchRowcode": "+                if role['id'] not in token_roles:"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 573,
                "PatchRowcode": "+                    detail = _('Cannot create an application credential with '"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 574,
                "PatchRowcode": "+                               'unassigned role')"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 575,
                "PatchRowcode": "+                    raise ks_exception.ApplicationCredentialValidationError("
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 576,
                "PatchRowcode": "+                        detail=detail)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 577,
                "PatchRowcode": "+        else:"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 578,
                "PatchRowcode": "+            roles = token.roles"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 579,
                "PatchRowcode": "+        return roles"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 580,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": 562,
                "afterPatchRowNumber": 581,
                "PatchRowcode": "     def get(self, user_id):"
            },
            "23": {
                "beforePatchRowNumber": 563,
                "afterPatchRowNumber": 582,
                "PatchRowcode": "         \"\"\"List application credentials for user."
            },
            "24": {
                "beforePatchRowNumber": 564,
                "afterPatchRowNumber": 583,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 594,
                "afterPatchRowNumber": 613,
                "PatchRowcode": "             app_cred_data['secret'] = self._generate_secret()"
            },
            "26": {
                "beforePatchRowNumber": 595,
                "afterPatchRowNumber": 614,
                "PatchRowcode": "         app_cred_data['user_id'] = user_id"
            },
            "27": {
                "beforePatchRowNumber": 596,
                "afterPatchRowNumber": 615,
                "PatchRowcode": "         app_cred_data['project_id'] = project_id"
            },
            "28": {
                "beforePatchRowNumber": 597,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        app_cred_data['roles'] = self._normalize_role_list("
            },
            "29": {
                "beforePatchRowNumber": 598,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            app_cred_data.get('roles', token.roles))"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 616,
                "PatchRowcode": "+        app_cred_data['roles'] = self._get_roles(app_cred_data, token)"
            },
            "31": {
                "beforePatchRowNumber": 599,
                "afterPatchRowNumber": 617,
                "PatchRowcode": "         if app_cred_data.get('expires_at'):"
            },
            "32": {
                "beforePatchRowNumber": 600,
                "afterPatchRowNumber": 618,
                "PatchRowcode": "             app_cred_data['expires_at'] = utils.parse_expiration_date("
            },
            "33": {
                "beforePatchRowNumber": 601,
                "afterPatchRowNumber": 619,
                "PatchRowcode": "                 app_cred_data['expires_at'])"
            }
        },
        "frontPatchFile": [
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "# This file handles all flask-restful resources for /v3/users",
            "",
            "import base64",
            "import os",
            "import uuid",
            "",
            "import flask",
            "from oslo_serialization import jsonutils",
            "from six.moves import http_client",
            "from werkzeug import exceptions",
            "",
            "from keystone.api._shared import json_home_relations",
            "from keystone.application_credential import schema as app_cred_schema",
            "from keystone.common import json_home",
            "from keystone.common import provider_api",
            "from keystone.common import rbac_enforcer",
            "from keystone.common import utils",
            "from keystone.common import validation",
            "import keystone.conf",
            "from keystone import exception as ks_exception",
            "from keystone.i18n import _",
            "from keystone.identity import schema",
            "from keystone import notifications",
            "from keystone.server import flask as ks_flask",
            "",
            "",
            "CRED_TYPE_EC2 = 'ec2'",
            "CONF = keystone.conf.CONF",
            "ENFORCER = rbac_enforcer.RBACEnforcer",
            "PROVIDERS = provider_api.ProviderAPIs",
            "",
            "ACCESS_TOKEN_ID_PARAMETER_RELATION = (",
            "    json_home_relations.os_oauth1_parameter_rel_func(",
            "        parameter_name='access_token_id')",
            ")",
            "",
            "",
            "def _convert_v3_to_ec2_credential(credential):",
            "    # Prior to bug #1259584 fix, blob was stored unserialized",
            "    # but it should be stored as a json string for compatibility",
            "    # with the v3 credentials API.  Fall back to the old behavior",
            "    # for backwards compatibility with existing DB contents",
            "    try:",
            "        blob = jsonutils.loads(credential['blob'])",
            "    except TypeError:",
            "        blob = credential['blob']",
            "    return {'user_id': credential.get('user_id'),",
            "            'tenant_id': credential.get('project_id'),",
            "            'access': blob.get('access'),",
            "            'secret': blob.get('secret'),",
            "            'trust_id': blob.get('trust_id')}",
            "",
            "",
            "def _format_token_entity(entity):",
            "",
            "    formatted_entity = entity.copy()",
            "    access_token_id = formatted_entity['id']",
            "    user_id = formatted_entity.get('authorizing_user_id', '')",
            "    if 'role_ids' in entity:",
            "        formatted_entity.pop('role_ids')",
            "    if 'access_secret' in entity:",
            "        formatted_entity.pop('access_secret')",
            "",
            "    url = ('/users/%(user_id)s/OS-OAUTH1/access_tokens/%(access_token_id)s'",
            "           '/roles' % {'user_id': user_id,",
            "                       'access_token_id': access_token_id})",
            "",
            "    formatted_entity.setdefault('links', {})",
            "    formatted_entity['links']['roles'] = (ks_flask.base_url(url))",
            "",
            "    return formatted_entity",
            "",
            "",
            "def _check_unrestricted_application_credential(token):",
            "    if 'application_credential' in token.methods:",
            "        if not token.application_credential['unrestricted']:",
            "            action = _(\"Using method 'application_credential' is not \"",
            "                       \"allowed for managing additional application \"",
            "                       \"credentials.\")",
            "            raise ks_exception.ForbiddenAction(action=action)",
            "",
            "",
            "def _build_user_target_enforcement():",
            "    target = {}",
            "    try:",
            "        target['user'] = PROVIDERS.identity_api.get_user(",
            "            flask.request.view_args.get('user_id')",
            "        )",
            "        if flask.request.view_args.get('group_id'):",
            "            target['group'] = PROVIDERS.identity_api.get_group(",
            "                flask.request.view_args.get('group_id')",
            "            )",
            "    except ks_exception.NotFound:  # nosec",
            "        # Defer existence in the event the user doesn't exist, we'll",
            "        # check this later anyway.",
            "        pass",
            "",
            "    return target",
            "",
            "",
            "def _build_enforcer_target_data_owner_and_user_id_match():",
            "    ref = {}",
            "    if flask.request.view_args:",
            "        credential_id = flask.request.view_args.get('credential_id')",
            "        if credential_id is not None:",
            "            hashed_id = utils.hash_access_key(credential_id)",
            "            ref['credential'] = PROVIDERS.credential_api.get_credential(",
            "                hashed_id)",
            "    return ref",
            "",
            "",
            "def _format_role_entity(role_id):",
            "    role = PROVIDERS.role_api.get_role(role_id)",
            "    formatted_entity = role.copy()",
            "    if 'description' in role:",
            "        formatted_entity.pop('description')",
            "    if 'enabled' in role:",
            "        formatted_entity.pop('enabled')",
            "    return formatted_entity",
            "",
            "",
            "class UserResource(ks_flask.ResourceBase):",
            "    collection_key = 'users'",
            "    member_key = 'user'",
            "    get_member_from_driver = PROVIDERS.deferred_provider_lookup(",
            "        api='identity_api', method='get_user')",
            "",
            "    def get(self, user_id=None):",
            "        \"\"\"Get a user resource or list users.",
            "",
            "        GET/HEAD /v3/users",
            "        GET/HEAD /v3/users/{user_id}",
            "        \"\"\"",
            "        if user_id is not None:",
            "            return self._get_user(user_id)",
            "        return self._list_users()",
            "",
            "    def _get_user(self, user_id):",
            "        \"\"\"Get a user resource.",
            "",
            "        GET/HEAD /v3/users/{user_id}",
            "        \"\"\"",
            "        ENFORCER.enforce_call(",
            "            action='identity:get_user',",
            "            build_target=_build_user_target_enforcement",
            "        )",
            "        ref = PROVIDERS.identity_api.get_user(user_id)",
            "        return self.wrap_member(ref)",
            "",
            "    def _list_users(self):",
            "        \"\"\"List users.",
            "",
            "        GET/HEAD /v3/users",
            "        \"\"\"",
            "        filters = ('domain_id', 'enabled', 'idp_id', 'name', 'protocol_id',",
            "                   'unique_id', 'password_expires_at')",
            "        target = None",
            "        if self.oslo_context.domain_id:",
            "            target = {'domain_id': self.oslo_context.domain_id}",
            "        hints = self.build_driver_hints(filters)",
            "        ENFORCER.enforce_call(",
            "            action='identity:list_users', filters=filters, target_attr=target",
            "        )",
            "        domain = self._get_domain_id_for_list_request()",
            "        if domain is None and self.oslo_context.domain_id:",
            "            domain = self.oslo_context.domain_id",
            "        refs = PROVIDERS.identity_api.list_users(",
            "            domain_scope=domain, hints=hints)",
            "",
            "        # If the user making the request used a domain-scoped token, let's make",
            "        # sure we filter out users that are not in that domain. Otherwise, we'd",
            "        # be exposing users in other domains. This if statement is needed in",
            "        # case _get_domain_id_for_list_request() short-circuits due to",
            "        # configuration and protects against information from other domains",
            "        # leaking to people who shouldn't see it.",
            "        if self.oslo_context.domain_id:",
            "            domain_id = self.oslo_context.domain_id",
            "            users = [user for user in refs if user['domain_id'] == domain_id]",
            "        else:",
            "            users = refs",
            "",
            "        return self.wrap_collection(users, hints=hints)",
            "",
            "    def post(self):",
            "        \"\"\"Create a user.",
            "",
            "        POST /v3/users",
            "        \"\"\"",
            "        user_data = self.request_body_json.get('user', {})",
            "        target = {'user': user_data}",
            "        ENFORCER.enforce_call(",
            "            action='identity:create_user', target_attr=target",
            "        )",
            "        validation.lazy_validate(schema.user_create, user_data)",
            "        user_data = self._normalize_dict(user_data)",
            "        user_data = self._normalize_domain_id(user_data)",
            "        ref = PROVIDERS.identity_api.create_user(",
            "            user_data,",
            "            initiator=self.audit_initiator)",
            "        return self.wrap_member(ref), http_client.CREATED",
            "",
            "    def patch(self, user_id):",
            "        \"\"\"Update a user.",
            "",
            "        PATCH /v3/users/{user_id}",
            "        \"\"\"",
            "        ENFORCER.enforce_call(",
            "            action='identity:update_user',",
            "            build_target=_build_user_target_enforcement",
            "        )",
            "        PROVIDERS.identity_api.get_user(user_id)",
            "        user_data = self.request_body_json.get('user', {})",
            "        validation.lazy_validate(schema.user_update, user_data)",
            "        self._require_matching_id(user_data)",
            "        ref = PROVIDERS.identity_api.update_user(",
            "            user_id, user_data, initiator=self.audit_initiator)",
            "        return self.wrap_member(ref)",
            "",
            "    def delete(self, user_id):",
            "        \"\"\"Delete a user.",
            "",
            "        DELETE /v3/users/{user_id}",
            "        \"\"\"",
            "        ENFORCER.enforce_call(",
            "            action='identity:delete_user',",
            "            build_target=_build_user_target_enforcement",
            "        )",
            "        PROVIDERS.identity_api.delete_user(user_id)",
            "        return None, http_client.NO_CONTENT",
            "",
            "",
            "class UserChangePasswordResource(ks_flask.ResourceBase):",
            "    @ks_flask.unenforced_api",
            "    def get(self, user_id):",
            "        # Special case, GET is not allowed.",
            "        raise exceptions.MethodNotAllowed(valid_methods=['POST'])",
            "",
            "    @ks_flask.unenforced_api",
            "    def post(self, user_id):",
            "        user_data = self.request_body_json.get('user', {})",
            "        validation.lazy_validate(schema.password_change, user_data)",
            "",
            "        try:",
            "            PROVIDERS.identity_api.change_password(",
            "                user_id=user_id,",
            "                original_password=user_data['original_password'],",
            "                new_password=user_data['password'],",
            "                initiator=self.audit_initiator)",
            "        except AssertionError as e:",
            "            raise ks_exception.Unauthorized(",
            "                _('Error when changing user password: %s') % e",
            "            )",
            "        return None, http_client.NO_CONTENT",
            "",
            "",
            "class UserProjectsResource(ks_flask.ResourceBase):",
            "    collection_key = 'projects'",
            "    member_key = 'project'",
            "    get_member_from_driver = PROVIDERS.deferred_provider_lookup(",
            "        api='resource_api', method='get_project')",
            "",
            "    def get(self, user_id):",
            "        filters = ('domain_id', 'enabled', 'name')",
            "        ENFORCER.enforce_call(action='identity:list_user_projects',",
            "                              filters=filters,",
            "                              build_target=_build_user_target_enforcement)",
            "        hints = self.build_driver_hints(filters)",
            "        refs = PROVIDERS.assignment_api.list_projects_for_user(user_id)",
            "        return self.wrap_collection(refs, hints=hints)",
            "",
            "",
            "class UserGroupsResource(ks_flask.ResourceBase):",
            "    collection_key = 'groups'",
            "    member_key = 'group'",
            "    get_member_from_driver = PROVIDERS.deferred_provider_lookup(",
            "        api='identity_api', method='get_group')",
            "",
            "    def get(self, user_id):",
            "        \"\"\"Get groups for a user.",
            "",
            "        GET/HEAD /v3/users/{user_id}/groups",
            "        \"\"\"",
            "        filters = ('name',)",
            "        hints = self.build_driver_hints(filters)",
            "        ENFORCER.enforce_call(action='identity:list_groups_for_user',",
            "                              build_target=_build_user_target_enforcement,",
            "                              filters=filters)",
            "        refs = PROVIDERS.identity_api.list_groups_for_user(user_id=user_id,",
            "                                                           hints=hints)",
            "        if (self.oslo_context.domain_id):",
            "            filtered_refs = []",
            "            for ref in refs:",
            "                if ref['domain_id'] == self.oslo_context.domain_id:",
            "                    filtered_refs.append(ref)",
            "            refs = filtered_refs",
            "        return self.wrap_collection(refs, hints=hints)",
            "",
            "",
            "class _UserOSEC2CredBaseResource(ks_flask.ResourceBase):",
            "    collection_key = 'credentials'",
            "    member_key = 'credential'",
            "",
            "    @classmethod",
            "    def _add_self_referential_link(cls, ref, collection_name=None):",
            "        # NOTE(morgan): This should be refactored to have an EC2 Cred API with",
            "        # a sane prefix instead of overloading the \"_add_self_referential_link\"",
            "        # method. This was chosen as it more closely mirrors the pre-flask",
            "        # code (for transition).",
            "        path = '/users/%(user_id)s/credentials/OS-EC2/%(credential_id)s'",
            "",
            "        url = ks_flask.base_url(path) % {",
            "            'user_id': ref['user_id'],",
            "            'credential_id': ref['access']}",
            "        ref.setdefault('links', {})",
            "        ref['links']['self'] = url",
            "",
            "",
            "class UserOSEC2CredentialsResourceListCreate(_UserOSEC2CredBaseResource):",
            "    def get(self, user_id):",
            "        \"\"\"List EC2 Credentials for user.",
            "",
            "        GET/HEAD /v3/users/{user_id}/credentials/OS-EC2",
            "        \"\"\"",
            "        ENFORCER.enforce_call(action='identity:ec2_list_credentials')",
            "        PROVIDERS.identity_api.get_user(user_id)",
            "        credential_refs = PROVIDERS.credential_api.list_credentials_for_user(",
            "            user_id, type=CRED_TYPE_EC2)",
            "        collection_refs = [",
            "            _convert_v3_to_ec2_credential(cred)",
            "            for cred in credential_refs",
            "        ]",
            "        return self.wrap_collection(collection_refs)",
            "",
            "    def post(self, user_id):",
            "        \"\"\"Create EC2 Credential for user.",
            "",
            "        POST /v3/users/{user_id}/credentials/OS-EC2",
            "        \"\"\"",
            "        target = {}",
            "        target['credential'] = {'user_id': user_id}",
            "        ENFORCER.enforce_call(action='identity:ec2_create_credential',",
            "                              target_attr=target)",
            "        PROVIDERS.identity_api.get_user(user_id)",
            "        tenant_id = self.request_body_json.get('tenant_id')",
            "        PROVIDERS.resource_api.get_project(tenant_id)",
            "        blob = dict(",
            "            access=uuid.uuid4().hex,",
            "            secret=uuid.uuid4().hex,",
            "            trust_id=self.oslo_context.trust_id",
            "        )",
            "        credential_id = utils.hash_access_key(blob['access'])",
            "        cred_data = dict(",
            "            user_id=user_id,",
            "            project_id=tenant_id,",
            "            blob=jsonutils.dumps(blob),",
            "            id=credential_id,",
            "            type=CRED_TYPE_EC2",
            "        )",
            "        PROVIDERS.credential_api.create_credential(credential_id, cred_data)",
            "        ref = _convert_v3_to_ec2_credential(cred_data)",
            "        return self.wrap_member(ref), http_client.CREATED",
            "",
            "",
            "class UserOSEC2CredentialsResourceGetDelete(_UserOSEC2CredBaseResource):",
            "    @staticmethod",
            "    def _get_cred_data(credential_id):",
            "        cred = PROVIDERS.credential_api.get_credential(credential_id)",
            "        if not cred or cred['type'] != CRED_TYPE_EC2:",
            "            raise ks_exception.Unauthorized(",
            "                message=_('EC2 access key not found.'))",
            "        return _convert_v3_to_ec2_credential(cred)",
            "",
            "    def get(self, user_id, credential_id):",
            "        \"\"\"Get a specific EC2 credential.",
            "",
            "        GET/HEAD /users/{user_id}/credentials/OS-EC2/{credential_id}",
            "        \"\"\"",
            "        func = _build_enforcer_target_data_owner_and_user_id_match",
            "        ENFORCER.enforce_call(",
            "            action='identity:ec2_get_credential',",
            "            build_target=func)",
            "        PROVIDERS.identity_api.get_user(user_id)",
            "        ec2_cred_id = utils.hash_access_key(credential_id)",
            "        cred_data = self._get_cred_data(ec2_cred_id)",
            "        return self.wrap_member(cred_data)",
            "",
            "    def delete(self, user_id, credential_id):",
            "        \"\"\"Delete a specific EC2 credential.",
            "",
            "        DELETE /users/{user_id}/credentials/OS-EC2/{credential_id}",
            "        \"\"\"",
            "        func = _build_enforcer_target_data_owner_and_user_id_match",
            "        ENFORCER.enforce_call(action='identity:ec2_delete_credential',",
            "                              build_target=func)",
            "        PROVIDERS.identity_api.get_user(user_id)",
            "        ec2_cred_id = utils.hash_access_key(credential_id)",
            "        self._get_cred_data(ec2_cred_id)",
            "        PROVIDERS.credential_api.delete_credential(ec2_cred_id)",
            "        return None, http_client.NO_CONTENT",
            "",
            "",
            "class _OAuth1ResourceBase(ks_flask.ResourceBase):",
            "    collection_key = 'access_tokens'",
            "    member_key = 'access_token'",
            "",
            "    @classmethod",
            "    def _add_self_referential_link(cls, ref, collection_name=None):",
            "        # NOTE(morgan): This should be refactored to have an OAuth1 API with",
            "        # a sane prefix instead of overloading the \"_add_self_referential_link\"",
            "        # method. This was chosen as it more closely mirrors the pre-flask",
            "        # code (for transition).",
            "        ref.setdefault('links', {})",
            "        path = '/users/%(user_id)s/OS-OAUTH1/access_tokens' % {",
            "            'user_id': ref.get('authorizing_user_id', '')",
            "        }",
            "        ref['links']['self'] = ks_flask.base_url(path) + '/' + ref['id']",
            "",
            "",
            "class OAuth1ListAccessTokensResource(_OAuth1ResourceBase):",
            "    def get(self, user_id):",
            "        \"\"\"List OAuth1 Access Tokens for user.",
            "",
            "        GET /v3/users/{user_id}/OS-OAUTH1/access_tokens",
            "        \"\"\"",
            "        ENFORCER.enforce_call(action='identity:list_access_tokens')",
            "        if self.oslo_context.is_delegated_auth:",
            "            raise ks_exception.Forbidden(",
            "                _('Cannot list request tokens with a token '",
            "                  'issued via delegation.'))",
            "        refs = PROVIDERS.oauth_api.list_access_tokens(user_id)",
            "        formatted_refs = ([_format_token_entity(x) for x in refs])",
            "        return self.wrap_collection(formatted_refs)",
            "",
            "",
            "class OAuth1AccessTokenCRUDResource(_OAuth1ResourceBase):",
            "    def get(self, user_id, access_token_id):",
            "        \"\"\"Get specific access token.",
            "",
            "        GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}",
            "        \"\"\"",
            "        ENFORCER.enforce_call(action='identity:get_access_token')",
            "        access_token = PROVIDERS.oauth_api.get_access_token(access_token_id)",
            "        if access_token['authorizing_user_id'] != user_id:",
            "            raise ks_exception.NotFound()",
            "        access_token = _format_token_entity(access_token)",
            "        return self.wrap_member(access_token)",
            "",
            "    def delete(self, user_id, access_token_id):",
            "        \"\"\"Delete specific access token.",
            "",
            "        DELETE /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}",
            "        \"\"\"",
            "        ENFORCER.enforce_call(",
            "            action='identity:ec2_delete_credential',",
            "            build_target=_build_enforcer_target_data_owner_and_user_id_match)",
            "        access_token = PROVIDERS.oauth_api.get_access_token(access_token_id)",
            "        reason = (",
            "            'Invalidating the token cache because an access token for '",
            "            'consumer %(consumer_id)s has been deleted. Authorization for '",
            "            'users with OAuth tokens will be recalculated and enforced '",
            "            'accordingly the next time they authenticate or validate a '",
            "            'token.' % {'consumer_id': access_token['consumer_id']}",
            "        )",
            "        notifications.invalidate_token_cache_notification(reason)",
            "        PROVIDERS.oauth_api.delete_access_token(",
            "            user_id, access_token_id, initiator=self.audit_initiator)",
            "        return None, http_client.NO_CONTENT",
            "",
            "",
            "class OAuth1AccessTokenRoleListResource(ks_flask.ResourceBase):",
            "    collection_key = 'roles'",
            "    member_key = 'role'",
            "",
            "    def get(self, user_id, access_token_id):",
            "        \"\"\"List roles for a user access token.",
            "",
            "        GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/",
            "                 {access_token_id}/roles",
            "        \"\"\"",
            "        ENFORCER.enforce_call(action='identity:list_access_token_roles')",
            "        access_token = PROVIDERS.oauth_api.get_access_token(access_token_id)",
            "        if access_token['authorizing_user_id'] != user_id:",
            "            raise ks_exception.NotFound()",
            "        authed_role_ids = access_token['role_ids']",
            "        authed_role_ids = jsonutils.loads(authed_role_ids)",
            "        refs = ([_format_role_entity(x) for x in authed_role_ids])",
            "        return self.wrap_collection(refs)",
            "",
            "",
            "class OAuth1AccessTokenRoleResource(ks_flask.ResourceBase):",
            "    collection_key = 'roles'",
            "    member_key = 'role'",
            "",
            "    def get(self, user_id, access_token_id, role_id):",
            "        \"\"\"Get role for access token.",
            "",
            "        GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/",
            "                 {access_token_id}/roles/{role_id}",
            "        \"\"\"",
            "        ENFORCER.enforce_call(action='identity:get_access_token_role')",
            "        access_token = PROVIDERS.oauth_api.get_access_token(access_token_id)",
            "        if access_token['authorizing_user_id'] != user_id:",
            "            raise ks_exception.Unauthorized(_('User IDs do not match'))",
            "        authed_role_ids = access_token['role_ids']",
            "        authed_role_ids = jsonutils.loads(authed_role_ids)",
            "        for authed_role_id in authed_role_ids:",
            "            if authed_role_id == role_id:",
            "                role = _format_role_entity(role_id)",
            "                return self.wrap_member(role)",
            "        raise ks_exception.RoleNotFound(role_id=role_id)",
            "",
            "",
            "class UserAppCredListCreateResource(ks_flask.ResourceBase):",
            "    collection_key = 'application_credentials'",
            "    member_key = 'application_credential'",
            "    _public_parameters = frozenset([",
            "        'id',",
            "        'name',",
            "        'description',",
            "        'expires_at',",
            "        'project_id',",
            "        'roles',",
            "        # secret is only exposed after create, it is not stored",
            "        'secret',",
            "        'links',",
            "        'unrestricted',",
            "        'access_rules'",
            "    ])",
            "",
            "    @staticmethod",
            "    def _generate_secret():",
            "        length = 64",
            "        secret = os.urandom(length)",
            "        secret = base64.urlsafe_b64encode(secret)",
            "        secret = secret.rstrip(b'=')",
            "        secret = secret.decode('utf-8')",
            "        return secret",
            "",
            "    @staticmethod",
            "    def _normalize_role_list(app_cred_roles):",
            "        roles = []",
            "        for role in app_cred_roles:",
            "            if role.get('id'):",
            "                roles.append(role)",
            "            else:",
            "                roles.append(PROVIDERS.role_api.get_unique_role_by_name(",
            "                    role['name']))",
            "        return roles",
            "",
            "    def get(self, user_id):",
            "        \"\"\"List application credentials for user.",
            "",
            "        GET/HEAD /v3/users/{user_id}/application_credentials",
            "        \"\"\"",
            "        filters = ('name',)",
            "        ENFORCER.enforce_call(action='identity:list_application_credentials',",
            "                              filters=filters)",
            "        app_cred_api = PROVIDERS.application_credential_api",
            "        hints = self.build_driver_hints(filters)",
            "        refs = app_cred_api.list_application_credentials(user_id, hints=hints)",
            "        return self.wrap_collection(refs, hints=hints)",
            "",
            "    def post(self, user_id):",
            "        \"\"\"Create application credential.",
            "",
            "        POST /v3/users/{user_id}/application_credentials",
            "        \"\"\"",
            "        ENFORCER.enforce_call(action='identity:create_application_credential')",
            "        app_cred_data = self.request_body_json.get(",
            "            'application_credential', {})",
            "        validation.lazy_validate(app_cred_schema.application_credential_create,",
            "                                 app_cred_data)",
            "        token = self.auth_context['token']",
            "        _check_unrestricted_application_credential(token)",
            "        if self.oslo_context.user_id != user_id:",
            "            action = _('Cannot create an application credential for another '",
            "                       'user.')",
            "            raise ks_exception.ForbiddenAction(action=action)",
            "        project_id = self.oslo_context.project_id",
            "        app_cred_data = self._assign_unique_id(app_cred_data)",
            "        if not app_cred_data.get('secret'):",
            "            app_cred_data['secret'] = self._generate_secret()",
            "        app_cred_data['user_id'] = user_id",
            "        app_cred_data['project_id'] = project_id",
            "        app_cred_data['roles'] = self._normalize_role_list(",
            "            app_cred_data.get('roles', token.roles))",
            "        if app_cred_data.get('expires_at'):",
            "            app_cred_data['expires_at'] = utils.parse_expiration_date(",
            "                app_cred_data['expires_at'])",
            "        if app_cred_data.get('access_rules'):",
            "            for access_rule in app_cred_data['access_rules']:",
            "                # If user provides an access rule by ID, it will be looked up",
            "                # by ID. If user provides an access rule that is identical to",
            "                # an existing one, the ID generated here will be ignored and",
            "                # the pre-existing access rule will be used.",
            "                if 'id' not in access_rule:",
            "                    # Generate directly, rather than using _assign_unique_id,",
            "                    # so that there is no deep copy made",
            "                    access_rule['id'] = uuid.uuid4().hex",
            "        app_cred_data = self._normalize_dict(app_cred_data)",
            "        app_cred_api = PROVIDERS.application_credential_api",
            "",
            "        try:",
            "            ref = app_cred_api.create_application_credential(",
            "                app_cred_data, initiator=self.audit_initiator)",
            "        except ks_exception.RoleAssignmentNotFound as e:",
            "            # Raise a Bad Request, not a Not Found, in accordance with the",
            "            # API-SIG recommendations:",
            "            # https://specs.openstack.org/openstack/api-wg/guidelines/http.html#failure-code-clarifications",
            "            raise ks_exception.ApplicationCredentialValidationError(",
            "                detail=str(e))",
            "        return self.wrap_member(ref), http_client.CREATED",
            "",
            "",
            "class UserAppCredGetDeleteResource(ks_flask.ResourceBase):",
            "    collection_key = 'application_credentials'",
            "    member_key = 'application_credential'",
            "",
            "    def get(self, user_id, application_credential_id):",
            "        \"\"\"Get application credential resource.",
            "",
            "        GET/HEAD /v3/users/{user_id}/application_credentials/",
            "                 {application_credential_id}",
            "        \"\"\"",
            "        ENFORCER.enforce_call(action='identity:get_application_credential')",
            "        ref = PROVIDERS.application_credential_api.get_application_credential(",
            "            application_credential_id)",
            "        return self.wrap_member(ref)",
            "",
            "    def delete(self, user_id, application_credential_id):",
            "        \"\"\"Delete application credential resource.",
            "",
            "        DELETE /v3/users/{user_id}/application_credentials/",
            "               {application_credential_id}",
            "        \"\"\"",
            "        ENFORCER.enforce_call(action='identity:delete_application_credential')",
            "        token = self.auth_context['token']",
            "        _check_unrestricted_application_credential(token)",
            "        PROVIDERS.application_credential_api.delete_application_credential(",
            "            application_credential_id, initiator=self.audit_initiator)",
            "        return None, http_client.NO_CONTENT",
            "",
            "",
            "class UserAccessRuleListResource(ks_flask.ResourceBase):",
            "    collection_key = 'access_rules'",
            "    member_key = 'access_rule'",
            "",
            "    def get(self, user_id):",
            "        \"\"\"List access rules for user.",
            "",
            "        GET/HEAD /v3/users/{user_id}/access_rules",
            "        \"\"\"",
            "        filters = ('service', 'path', 'method',)",
            "        ENFORCER.enforce_call(action='identity:list_access_rules',",
            "                              filters=filters,",
            "                              build_target=_build_user_target_enforcement)",
            "        app_cred_api = PROVIDERS.application_credential_api",
            "        hints = self.build_driver_hints(filters)",
            "        refs = app_cred_api.list_access_rules_for_user(user_id, hints=hints)",
            "        hints = self.build_driver_hints(filters)",
            "        return self.wrap_collection(refs, hints=hints)",
            "",
            "",
            "class UserAccessRuleGetDeleteResource(ks_flask.ResourceBase):",
            "    collection_key = 'access_rules'",
            "    member_key = 'access_rule'",
            "",
            "    def get(self, user_id, access_rule_id):",
            "        \"\"\"Get access rule resource.",
            "",
            "        GET/HEAD /v3/users/{user_id}/access_rules/{access_rule_id}",
            "        \"\"\"",
            "        ENFORCER.enforce_call(",
            "            action='identity:get_access_rule',",
            "            build_target=_build_user_target_enforcement",
            "        )",
            "        ref = PROVIDERS.application_credential_api.get_access_rule(",
            "            access_rule_id)",
            "        return self.wrap_member(ref)",
            "",
            "    def delete(self, user_id, access_rule_id):",
            "        \"\"\"Delete access rule resource.",
            "",
            "        DELETE /v3/users/{user_id}/access_rules/{access_rule_id}",
            "        \"\"\"",
            "        ENFORCER.enforce_call(",
            "            action='identity:delete_access_rule',",
            "            build_target=_build_user_target_enforcement",
            "        )",
            "        PROVIDERS.application_credential_api.delete_access_rule(",
            "            access_rule_id, initiator=self.audit_initiator)",
            "        return None, http_client.NO_CONTENT",
            "",
            "",
            "class UserAPI(ks_flask.APIBase):",
            "    _name = 'users'",
            "    _import_name = __name__",
            "    resources = [UserResource]",
            "    resource_mapping = [",
            "        ks_flask.construct_resource_map(",
            "            resource=UserChangePasswordResource,",
            "            url='/users/<string:user_id>/password',",
            "            resource_kwargs={},",
            "            rel='user_change_password',",
            "            path_vars={'user_id': json_home.Parameters.USER_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=UserGroupsResource,",
            "            url='/users/<string:user_id>/groups',",
            "            resource_kwargs={},",
            "            rel='user_groups',",
            "            path_vars={'user_id': json_home.Parameters.USER_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=UserProjectsResource,",
            "            url='/users/<string:user_id>/projects',",
            "            resource_kwargs={},",
            "            rel='user_projects',",
            "            path_vars={'user_id': json_home.Parameters.USER_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=UserOSEC2CredentialsResourceListCreate,",
            "            url='/users/<string:user_id>/credentials/OS-EC2',",
            "            resource_kwargs={},",
            "            rel='user_credentials',",
            "            resource_relation_func=(",
            "                json_home_relations.os_ec2_resource_rel_func),",
            "            path_vars={'user_id': json_home.Parameters.USER_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=UserOSEC2CredentialsResourceGetDelete,",
            "            url=('/users/<string:user_id>/credentials/OS-EC2/'",
            "                 '<string:credential_id>'),",
            "            resource_kwargs={},",
            "            rel='user_credential',",
            "            resource_relation_func=(",
            "                json_home_relations.os_ec2_resource_rel_func),",
            "            path_vars={",
            "                'credential_id': json_home.build_v3_parameter_relation(",
            "                    'credential_id'),",
            "                'user_id': json_home.Parameters.USER_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=OAuth1ListAccessTokensResource,",
            "            url='/users/<string:user_id>/OS-OAUTH1/access_tokens',",
            "            resource_kwargs={},",
            "            rel='user_access_tokens',",
            "            resource_relation_func=(",
            "                json_home_relations.os_oauth1_resource_rel_func),",
            "            path_vars={'user_id': json_home.Parameters.USER_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=OAuth1AccessTokenCRUDResource,",
            "            url=('/users/<string:user_id>/OS-OAUTH1/'",
            "                 'access_tokens/<string:access_token_id>'),",
            "            resource_kwargs={},",
            "            rel='user_access_token',",
            "            resource_relation_func=(",
            "                json_home_relations.os_oauth1_resource_rel_func),",
            "            path_vars={",
            "                'access_token_id': ACCESS_TOKEN_ID_PARAMETER_RELATION,",
            "                'user_id': json_home.Parameters.USER_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=OAuth1AccessTokenRoleListResource,",
            "            url=('/users/<string:user_id>/OS-OAUTH1/access_tokens/'",
            "                 '<string:access_token_id>/roles'),",
            "            resource_kwargs={},",
            "            rel='user_access_token_roles',",
            "            resource_relation_func=(",
            "                json_home_relations.os_oauth1_resource_rel_func),",
            "            path_vars={'access_token_id': ACCESS_TOKEN_ID_PARAMETER_RELATION,",
            "                       'user_id': json_home.Parameters.USER_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=OAuth1AccessTokenRoleResource,",
            "            url=('/users/<string:user_id>/OS-OAUTH1/access_tokens/'",
            "                 '<string:access_token_id>/roles/<string:role_id>'),",
            "            resource_kwargs={},",
            "            rel='user_access_token_role',",
            "            resource_relation_func=(",
            "                json_home_relations.os_oauth1_resource_rel_func),",
            "            path_vars={'access_token_id': ACCESS_TOKEN_ID_PARAMETER_RELATION,",
            "                       'role_id': json_home.Parameters.ROLE_ID,",
            "                       'user_id': json_home.Parameters.USER_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=UserAppCredListCreateResource,",
            "            url='/users/<string:user_id>/application_credentials',",
            "            resource_kwargs={},",
            "            rel='application_credentials',",
            "            path_vars={'user_id': json_home.Parameters.USER_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=UserAppCredGetDeleteResource,",
            "            url=('/users/<string:user_id>/application_credentials/'",
            "                 '<string:application_credential_id>'),",
            "            resource_kwargs={},",
            "            rel='application_credential',",
            "            path_vars={",
            "                'user_id': json_home.Parameters.USER_ID,",
            "                'application_credential_id':",
            "                    json_home.Parameters.APPLICATION_CRED_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=UserAccessRuleListResource,",
            "            url='/users/<string:user_id>/access_rules',",
            "            resource_kwargs={},",
            "            rel='access_rules',",
            "            path_vars={'user_id': json_home.Parameters.USER_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=UserAccessRuleGetDeleteResource,",
            "            url=('/users/<string:user_id>/access_rules/'",
            "                 '<string:access_rule_id>'),",
            "            resource_kwargs={},",
            "            rel='access_rule',",
            "            path_vars={",
            "                'user_id': json_home.Parameters.USER_ID,",
            "                'access_rule_id':",
            "                    json_home.Parameters.ACCESS_RULE_ID}",
            "        )",
            "    ]",
            "",
            "",
            "APIs = (UserAPI,)"
        ],
        "afterPatchFile": [
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "# This file handles all flask-restful resources for /v3/users",
            "",
            "import base64",
            "import os",
            "import uuid",
            "",
            "import flask",
            "from oslo_serialization import jsonutils",
            "from six.moves import http_client",
            "from werkzeug import exceptions",
            "",
            "from keystone.api._shared import json_home_relations",
            "from keystone.application_credential import schema as app_cred_schema",
            "from keystone.common import json_home",
            "from keystone.common import provider_api",
            "from keystone.common import rbac_enforcer",
            "from keystone.common import utils",
            "from keystone.common import validation",
            "import keystone.conf",
            "from keystone import exception as ks_exception",
            "from keystone.i18n import _",
            "from keystone.identity import schema",
            "from keystone import notifications",
            "from keystone.server import flask as ks_flask",
            "",
            "",
            "CRED_TYPE_EC2 = 'ec2'",
            "CONF = keystone.conf.CONF",
            "ENFORCER = rbac_enforcer.RBACEnforcer",
            "PROVIDERS = provider_api.ProviderAPIs",
            "",
            "ACCESS_TOKEN_ID_PARAMETER_RELATION = (",
            "    json_home_relations.os_oauth1_parameter_rel_func(",
            "        parameter_name='access_token_id')",
            ")",
            "",
            "",
            "def _convert_v3_to_ec2_credential(credential):",
            "    # Prior to bug #1259584 fix, blob was stored unserialized",
            "    # but it should be stored as a json string for compatibility",
            "    # with the v3 credentials API.  Fall back to the old behavior",
            "    # for backwards compatibility with existing DB contents",
            "    try:",
            "        blob = jsonutils.loads(credential['blob'])",
            "    except TypeError:",
            "        blob = credential['blob']",
            "    return {'user_id': credential.get('user_id'),",
            "            'tenant_id': credential.get('project_id'),",
            "            'access': blob.get('access'),",
            "            'secret': blob.get('secret'),",
            "            'trust_id': blob.get('trust_id')}",
            "",
            "",
            "def _format_token_entity(entity):",
            "",
            "    formatted_entity = entity.copy()",
            "    access_token_id = formatted_entity['id']",
            "    user_id = formatted_entity.get('authorizing_user_id', '')",
            "    if 'role_ids' in entity:",
            "        formatted_entity.pop('role_ids')",
            "    if 'access_secret' in entity:",
            "        formatted_entity.pop('access_secret')",
            "",
            "    url = ('/users/%(user_id)s/OS-OAUTH1/access_tokens/%(access_token_id)s'",
            "           '/roles' % {'user_id': user_id,",
            "                       'access_token_id': access_token_id})",
            "",
            "    formatted_entity.setdefault('links', {})",
            "    formatted_entity['links']['roles'] = (ks_flask.base_url(url))",
            "",
            "    return formatted_entity",
            "",
            "",
            "def _check_unrestricted_application_credential(token):",
            "    if 'application_credential' in token.methods:",
            "        if not token.application_credential['unrestricted']:",
            "            action = _(\"Using method 'application_credential' is not \"",
            "                       \"allowed for managing additional application \"",
            "                       \"credentials.\")",
            "            raise ks_exception.ForbiddenAction(action=action)",
            "",
            "",
            "def _build_user_target_enforcement():",
            "    target = {}",
            "    try:",
            "        target['user'] = PROVIDERS.identity_api.get_user(",
            "            flask.request.view_args.get('user_id')",
            "        )",
            "        if flask.request.view_args.get('group_id'):",
            "            target['group'] = PROVIDERS.identity_api.get_group(",
            "                flask.request.view_args.get('group_id')",
            "            )",
            "    except ks_exception.NotFound:  # nosec",
            "        # Defer existence in the event the user doesn't exist, we'll",
            "        # check this later anyway.",
            "        pass",
            "",
            "    return target",
            "",
            "",
            "def _build_enforcer_target_data_owner_and_user_id_match():",
            "    ref = {}",
            "    if flask.request.view_args:",
            "        credential_id = flask.request.view_args.get('credential_id')",
            "        if credential_id is not None:",
            "            hashed_id = utils.hash_access_key(credential_id)",
            "            ref['credential'] = PROVIDERS.credential_api.get_credential(",
            "                hashed_id)",
            "    return ref",
            "",
            "",
            "def _format_role_entity(role_id):",
            "    role = PROVIDERS.role_api.get_role(role_id)",
            "    formatted_entity = role.copy()",
            "    if 'description' in role:",
            "        formatted_entity.pop('description')",
            "    if 'enabled' in role:",
            "        formatted_entity.pop('enabled')",
            "    return formatted_entity",
            "",
            "",
            "class UserResource(ks_flask.ResourceBase):",
            "    collection_key = 'users'",
            "    member_key = 'user'",
            "    get_member_from_driver = PROVIDERS.deferred_provider_lookup(",
            "        api='identity_api', method='get_user')",
            "",
            "    def get(self, user_id=None):",
            "        \"\"\"Get a user resource or list users.",
            "",
            "        GET/HEAD /v3/users",
            "        GET/HEAD /v3/users/{user_id}",
            "        \"\"\"",
            "        if user_id is not None:",
            "            return self._get_user(user_id)",
            "        return self._list_users()",
            "",
            "    def _get_user(self, user_id):",
            "        \"\"\"Get a user resource.",
            "",
            "        GET/HEAD /v3/users/{user_id}",
            "        \"\"\"",
            "        ENFORCER.enforce_call(",
            "            action='identity:get_user',",
            "            build_target=_build_user_target_enforcement",
            "        )",
            "        ref = PROVIDERS.identity_api.get_user(user_id)",
            "        return self.wrap_member(ref)",
            "",
            "    def _list_users(self):",
            "        \"\"\"List users.",
            "",
            "        GET/HEAD /v3/users",
            "        \"\"\"",
            "        filters = ('domain_id', 'enabled', 'idp_id', 'name', 'protocol_id',",
            "                   'unique_id', 'password_expires_at')",
            "        target = None",
            "        if self.oslo_context.domain_id:",
            "            target = {'domain_id': self.oslo_context.domain_id}",
            "        hints = self.build_driver_hints(filters)",
            "        ENFORCER.enforce_call(",
            "            action='identity:list_users', filters=filters, target_attr=target",
            "        )",
            "        domain = self._get_domain_id_for_list_request()",
            "        if domain is None and self.oslo_context.domain_id:",
            "            domain = self.oslo_context.domain_id",
            "        refs = PROVIDERS.identity_api.list_users(",
            "            domain_scope=domain, hints=hints)",
            "",
            "        # If the user making the request used a domain-scoped token, let's make",
            "        # sure we filter out users that are not in that domain. Otherwise, we'd",
            "        # be exposing users in other domains. This if statement is needed in",
            "        # case _get_domain_id_for_list_request() short-circuits due to",
            "        # configuration and protects against information from other domains",
            "        # leaking to people who shouldn't see it.",
            "        if self.oslo_context.domain_id:",
            "            domain_id = self.oslo_context.domain_id",
            "            users = [user for user in refs if user['domain_id'] == domain_id]",
            "        else:",
            "            users = refs",
            "",
            "        return self.wrap_collection(users, hints=hints)",
            "",
            "    def post(self):",
            "        \"\"\"Create a user.",
            "",
            "        POST /v3/users",
            "        \"\"\"",
            "        user_data = self.request_body_json.get('user', {})",
            "        target = {'user': user_data}",
            "        ENFORCER.enforce_call(",
            "            action='identity:create_user', target_attr=target",
            "        )",
            "        validation.lazy_validate(schema.user_create, user_data)",
            "        user_data = self._normalize_dict(user_data)",
            "        user_data = self._normalize_domain_id(user_data)",
            "        ref = PROVIDERS.identity_api.create_user(",
            "            user_data,",
            "            initiator=self.audit_initiator)",
            "        return self.wrap_member(ref), http_client.CREATED",
            "",
            "    def patch(self, user_id):",
            "        \"\"\"Update a user.",
            "",
            "        PATCH /v3/users/{user_id}",
            "        \"\"\"",
            "        ENFORCER.enforce_call(",
            "            action='identity:update_user',",
            "            build_target=_build_user_target_enforcement",
            "        )",
            "        PROVIDERS.identity_api.get_user(user_id)",
            "        user_data = self.request_body_json.get('user', {})",
            "        validation.lazy_validate(schema.user_update, user_data)",
            "        self._require_matching_id(user_data)",
            "        ref = PROVIDERS.identity_api.update_user(",
            "            user_id, user_data, initiator=self.audit_initiator)",
            "        return self.wrap_member(ref)",
            "",
            "    def delete(self, user_id):",
            "        \"\"\"Delete a user.",
            "",
            "        DELETE /v3/users/{user_id}",
            "        \"\"\"",
            "        ENFORCER.enforce_call(",
            "            action='identity:delete_user',",
            "            build_target=_build_user_target_enforcement",
            "        )",
            "        PROVIDERS.identity_api.delete_user(user_id)",
            "        return None, http_client.NO_CONTENT",
            "",
            "",
            "class UserChangePasswordResource(ks_flask.ResourceBase):",
            "    @ks_flask.unenforced_api",
            "    def get(self, user_id):",
            "        # Special case, GET is not allowed.",
            "        raise exceptions.MethodNotAllowed(valid_methods=['POST'])",
            "",
            "    @ks_flask.unenforced_api",
            "    def post(self, user_id):",
            "        user_data = self.request_body_json.get('user', {})",
            "        validation.lazy_validate(schema.password_change, user_data)",
            "",
            "        try:",
            "            PROVIDERS.identity_api.change_password(",
            "                user_id=user_id,",
            "                original_password=user_data['original_password'],",
            "                new_password=user_data['password'],",
            "                initiator=self.audit_initiator)",
            "        except AssertionError as e:",
            "            raise ks_exception.Unauthorized(",
            "                _('Error when changing user password: %s') % e",
            "            )",
            "        return None, http_client.NO_CONTENT",
            "",
            "",
            "class UserProjectsResource(ks_flask.ResourceBase):",
            "    collection_key = 'projects'",
            "    member_key = 'project'",
            "    get_member_from_driver = PROVIDERS.deferred_provider_lookup(",
            "        api='resource_api', method='get_project')",
            "",
            "    def get(self, user_id):",
            "        filters = ('domain_id', 'enabled', 'name')",
            "        ENFORCER.enforce_call(action='identity:list_user_projects',",
            "                              filters=filters,",
            "                              build_target=_build_user_target_enforcement)",
            "        hints = self.build_driver_hints(filters)",
            "        refs = PROVIDERS.assignment_api.list_projects_for_user(user_id)",
            "        return self.wrap_collection(refs, hints=hints)",
            "",
            "",
            "class UserGroupsResource(ks_flask.ResourceBase):",
            "    collection_key = 'groups'",
            "    member_key = 'group'",
            "    get_member_from_driver = PROVIDERS.deferred_provider_lookup(",
            "        api='identity_api', method='get_group')",
            "",
            "    def get(self, user_id):",
            "        \"\"\"Get groups for a user.",
            "",
            "        GET/HEAD /v3/users/{user_id}/groups",
            "        \"\"\"",
            "        filters = ('name',)",
            "        hints = self.build_driver_hints(filters)",
            "        ENFORCER.enforce_call(action='identity:list_groups_for_user',",
            "                              build_target=_build_user_target_enforcement,",
            "                              filters=filters)",
            "        refs = PROVIDERS.identity_api.list_groups_for_user(user_id=user_id,",
            "                                                           hints=hints)",
            "        if (self.oslo_context.domain_id):",
            "            filtered_refs = []",
            "            for ref in refs:",
            "                if ref['domain_id'] == self.oslo_context.domain_id:",
            "                    filtered_refs.append(ref)",
            "            refs = filtered_refs",
            "        return self.wrap_collection(refs, hints=hints)",
            "",
            "",
            "class _UserOSEC2CredBaseResource(ks_flask.ResourceBase):",
            "    collection_key = 'credentials'",
            "    member_key = 'credential'",
            "",
            "    @classmethod",
            "    def _add_self_referential_link(cls, ref, collection_name=None):",
            "        # NOTE(morgan): This should be refactored to have an EC2 Cred API with",
            "        # a sane prefix instead of overloading the \"_add_self_referential_link\"",
            "        # method. This was chosen as it more closely mirrors the pre-flask",
            "        # code (for transition).",
            "        path = '/users/%(user_id)s/credentials/OS-EC2/%(credential_id)s'",
            "",
            "        url = ks_flask.base_url(path) % {",
            "            'user_id': ref['user_id'],",
            "            'credential_id': ref['access']}",
            "        ref.setdefault('links', {})",
            "        ref['links']['self'] = url",
            "",
            "",
            "class UserOSEC2CredentialsResourceListCreate(_UserOSEC2CredBaseResource):",
            "    def get(self, user_id):",
            "        \"\"\"List EC2 Credentials for user.",
            "",
            "        GET/HEAD /v3/users/{user_id}/credentials/OS-EC2",
            "        \"\"\"",
            "        ENFORCER.enforce_call(action='identity:ec2_list_credentials')",
            "        PROVIDERS.identity_api.get_user(user_id)",
            "        credential_refs = PROVIDERS.credential_api.list_credentials_for_user(",
            "            user_id, type=CRED_TYPE_EC2)",
            "        collection_refs = [",
            "            _convert_v3_to_ec2_credential(cred)",
            "            for cred in credential_refs",
            "        ]",
            "        return self.wrap_collection(collection_refs)",
            "",
            "    def post(self, user_id):",
            "        \"\"\"Create EC2 Credential for user.",
            "",
            "        POST /v3/users/{user_id}/credentials/OS-EC2",
            "        \"\"\"",
            "        target = {}",
            "        target['credential'] = {'user_id': user_id}",
            "        ENFORCER.enforce_call(action='identity:ec2_create_credential',",
            "                              target_attr=target)",
            "        PROVIDERS.identity_api.get_user(user_id)",
            "        tenant_id = self.request_body_json.get('tenant_id')",
            "        PROVIDERS.resource_api.get_project(tenant_id)",
            "        blob = dict(",
            "            access=uuid.uuid4().hex,",
            "            secret=uuid.uuid4().hex,",
            "            trust_id=self.oslo_context.trust_id",
            "        )",
            "        credential_id = utils.hash_access_key(blob['access'])",
            "        cred_data = dict(",
            "            user_id=user_id,",
            "            project_id=tenant_id,",
            "            blob=jsonutils.dumps(blob),",
            "            id=credential_id,",
            "            type=CRED_TYPE_EC2",
            "        )",
            "        PROVIDERS.credential_api.create_credential(credential_id, cred_data)",
            "        ref = _convert_v3_to_ec2_credential(cred_data)",
            "        return self.wrap_member(ref), http_client.CREATED",
            "",
            "",
            "class UserOSEC2CredentialsResourceGetDelete(_UserOSEC2CredBaseResource):",
            "    @staticmethod",
            "    def _get_cred_data(credential_id):",
            "        cred = PROVIDERS.credential_api.get_credential(credential_id)",
            "        if not cred or cred['type'] != CRED_TYPE_EC2:",
            "            raise ks_exception.Unauthorized(",
            "                message=_('EC2 access key not found.'))",
            "        return _convert_v3_to_ec2_credential(cred)",
            "",
            "    def get(self, user_id, credential_id):",
            "        \"\"\"Get a specific EC2 credential.",
            "",
            "        GET/HEAD /users/{user_id}/credentials/OS-EC2/{credential_id}",
            "        \"\"\"",
            "        func = _build_enforcer_target_data_owner_and_user_id_match",
            "        ENFORCER.enforce_call(",
            "            action='identity:ec2_get_credential',",
            "            build_target=func)",
            "        PROVIDERS.identity_api.get_user(user_id)",
            "        ec2_cred_id = utils.hash_access_key(credential_id)",
            "        cred_data = self._get_cred_data(ec2_cred_id)",
            "        return self.wrap_member(cred_data)",
            "",
            "    def delete(self, user_id, credential_id):",
            "        \"\"\"Delete a specific EC2 credential.",
            "",
            "        DELETE /users/{user_id}/credentials/OS-EC2/{credential_id}",
            "        \"\"\"",
            "        func = _build_enforcer_target_data_owner_and_user_id_match",
            "        ENFORCER.enforce_call(action='identity:ec2_delete_credential',",
            "                              build_target=func)",
            "        PROVIDERS.identity_api.get_user(user_id)",
            "        ec2_cred_id = utils.hash_access_key(credential_id)",
            "        self._get_cred_data(ec2_cred_id)",
            "        PROVIDERS.credential_api.delete_credential(ec2_cred_id)",
            "        return None, http_client.NO_CONTENT",
            "",
            "",
            "class _OAuth1ResourceBase(ks_flask.ResourceBase):",
            "    collection_key = 'access_tokens'",
            "    member_key = 'access_token'",
            "",
            "    @classmethod",
            "    def _add_self_referential_link(cls, ref, collection_name=None):",
            "        # NOTE(morgan): This should be refactored to have an OAuth1 API with",
            "        # a sane prefix instead of overloading the \"_add_self_referential_link\"",
            "        # method. This was chosen as it more closely mirrors the pre-flask",
            "        # code (for transition).",
            "        ref.setdefault('links', {})",
            "        path = '/users/%(user_id)s/OS-OAUTH1/access_tokens' % {",
            "            'user_id': ref.get('authorizing_user_id', '')",
            "        }",
            "        ref['links']['self'] = ks_flask.base_url(path) + '/' + ref['id']",
            "",
            "",
            "class OAuth1ListAccessTokensResource(_OAuth1ResourceBase):",
            "    def get(self, user_id):",
            "        \"\"\"List OAuth1 Access Tokens for user.",
            "",
            "        GET /v3/users/{user_id}/OS-OAUTH1/access_tokens",
            "        \"\"\"",
            "        ENFORCER.enforce_call(action='identity:list_access_tokens')",
            "        if self.oslo_context.is_delegated_auth:",
            "            raise ks_exception.Forbidden(",
            "                _('Cannot list request tokens with a token '",
            "                  'issued via delegation.'))",
            "        refs = PROVIDERS.oauth_api.list_access_tokens(user_id)",
            "        formatted_refs = ([_format_token_entity(x) for x in refs])",
            "        return self.wrap_collection(formatted_refs)",
            "",
            "",
            "class OAuth1AccessTokenCRUDResource(_OAuth1ResourceBase):",
            "    def get(self, user_id, access_token_id):",
            "        \"\"\"Get specific access token.",
            "",
            "        GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}",
            "        \"\"\"",
            "        ENFORCER.enforce_call(action='identity:get_access_token')",
            "        access_token = PROVIDERS.oauth_api.get_access_token(access_token_id)",
            "        if access_token['authorizing_user_id'] != user_id:",
            "            raise ks_exception.NotFound()",
            "        access_token = _format_token_entity(access_token)",
            "        return self.wrap_member(access_token)",
            "",
            "    def delete(self, user_id, access_token_id):",
            "        \"\"\"Delete specific access token.",
            "",
            "        DELETE /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}",
            "        \"\"\"",
            "        ENFORCER.enforce_call(",
            "            action='identity:ec2_delete_credential',",
            "            build_target=_build_enforcer_target_data_owner_and_user_id_match)",
            "        access_token = PROVIDERS.oauth_api.get_access_token(access_token_id)",
            "        reason = (",
            "            'Invalidating the token cache because an access token for '",
            "            'consumer %(consumer_id)s has been deleted. Authorization for '",
            "            'users with OAuth tokens will be recalculated and enforced '",
            "            'accordingly the next time they authenticate or validate a '",
            "            'token.' % {'consumer_id': access_token['consumer_id']}",
            "        )",
            "        notifications.invalidate_token_cache_notification(reason)",
            "        PROVIDERS.oauth_api.delete_access_token(",
            "            user_id, access_token_id, initiator=self.audit_initiator)",
            "        return None, http_client.NO_CONTENT",
            "",
            "",
            "class OAuth1AccessTokenRoleListResource(ks_flask.ResourceBase):",
            "    collection_key = 'roles'",
            "    member_key = 'role'",
            "",
            "    def get(self, user_id, access_token_id):",
            "        \"\"\"List roles for a user access token.",
            "",
            "        GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/",
            "                 {access_token_id}/roles",
            "        \"\"\"",
            "        ENFORCER.enforce_call(action='identity:list_access_token_roles')",
            "        access_token = PROVIDERS.oauth_api.get_access_token(access_token_id)",
            "        if access_token['authorizing_user_id'] != user_id:",
            "            raise ks_exception.NotFound()",
            "        authed_role_ids = access_token['role_ids']",
            "        authed_role_ids = jsonutils.loads(authed_role_ids)",
            "        refs = ([_format_role_entity(x) for x in authed_role_ids])",
            "        return self.wrap_collection(refs)",
            "",
            "",
            "class OAuth1AccessTokenRoleResource(ks_flask.ResourceBase):",
            "    collection_key = 'roles'",
            "    member_key = 'role'",
            "",
            "    def get(self, user_id, access_token_id, role_id):",
            "        \"\"\"Get role for access token.",
            "",
            "        GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/",
            "                 {access_token_id}/roles/{role_id}",
            "        \"\"\"",
            "        ENFORCER.enforce_call(action='identity:get_access_token_role')",
            "        access_token = PROVIDERS.oauth_api.get_access_token(access_token_id)",
            "        if access_token['authorizing_user_id'] != user_id:",
            "            raise ks_exception.Unauthorized(_('User IDs do not match'))",
            "        authed_role_ids = access_token['role_ids']",
            "        authed_role_ids = jsonutils.loads(authed_role_ids)",
            "        for authed_role_id in authed_role_ids:",
            "            if authed_role_id == role_id:",
            "                role = _format_role_entity(role_id)",
            "                return self.wrap_member(role)",
            "        raise ks_exception.RoleNotFound(role_id=role_id)",
            "",
            "",
            "class UserAppCredListCreateResource(ks_flask.ResourceBase):",
            "    collection_key = 'application_credentials'",
            "    member_key = 'application_credential'",
            "    _public_parameters = frozenset([",
            "        'id',",
            "        'name',",
            "        'description',",
            "        'expires_at',",
            "        'project_id',",
            "        'roles',",
            "        # secret is only exposed after create, it is not stored",
            "        'secret',",
            "        'links',",
            "        'unrestricted',",
            "        'access_rules'",
            "    ])",
            "",
            "    @staticmethod",
            "    def _generate_secret():",
            "        length = 64",
            "        secret = os.urandom(length)",
            "        secret = base64.urlsafe_b64encode(secret)",
            "        secret = secret.rstrip(b'=')",
            "        secret = secret.decode('utf-8')",
            "        return secret",
            "",
            "    @staticmethod",
            "    def _normalize_role_list(app_cred_roles):",
            "        roles = []",
            "        for role in app_cred_roles:",
            "            if role.get('id'):",
            "                roles.append(role)",
            "            else:",
            "                roles.append(PROVIDERS.role_api.get_unique_role_by_name(",
            "                    role['name']))",
            "        return roles",
            "",
            "    def _get_roles(self, app_cred_data, token):",
            "        if app_cred_data.get('roles'):",
            "            roles = self._normalize_role_list(app_cred_data['roles'])",
            "            # NOTE(cmurphy): The user is not allowed to add a role that is not",
            "            # in their token. This is to prevent trustees or application",
            "            # credential users from escallating their privileges to include",
            "            # additional roles that the trustor or application credential",
            "            # creator has assigned on the project.",
            "            token_roles = [r['id'] for r in token.roles]",
            "            for role in roles:",
            "                if role['id'] not in token_roles:",
            "                    detail = _('Cannot create an application credential with '",
            "                               'unassigned role')",
            "                    raise ks_exception.ApplicationCredentialValidationError(",
            "                        detail=detail)",
            "        else:",
            "            roles = token.roles",
            "        return roles",
            "",
            "    def get(self, user_id):",
            "        \"\"\"List application credentials for user.",
            "",
            "        GET/HEAD /v3/users/{user_id}/application_credentials",
            "        \"\"\"",
            "        filters = ('name',)",
            "        ENFORCER.enforce_call(action='identity:list_application_credentials',",
            "                              filters=filters)",
            "        app_cred_api = PROVIDERS.application_credential_api",
            "        hints = self.build_driver_hints(filters)",
            "        refs = app_cred_api.list_application_credentials(user_id, hints=hints)",
            "        return self.wrap_collection(refs, hints=hints)",
            "",
            "    def post(self, user_id):",
            "        \"\"\"Create application credential.",
            "",
            "        POST /v3/users/{user_id}/application_credentials",
            "        \"\"\"",
            "        ENFORCER.enforce_call(action='identity:create_application_credential')",
            "        app_cred_data = self.request_body_json.get(",
            "            'application_credential', {})",
            "        validation.lazy_validate(app_cred_schema.application_credential_create,",
            "                                 app_cred_data)",
            "        token = self.auth_context['token']",
            "        _check_unrestricted_application_credential(token)",
            "        if self.oslo_context.user_id != user_id:",
            "            action = _('Cannot create an application credential for another '",
            "                       'user.')",
            "            raise ks_exception.ForbiddenAction(action=action)",
            "        project_id = self.oslo_context.project_id",
            "        app_cred_data = self._assign_unique_id(app_cred_data)",
            "        if not app_cred_data.get('secret'):",
            "            app_cred_data['secret'] = self._generate_secret()",
            "        app_cred_data['user_id'] = user_id",
            "        app_cred_data['project_id'] = project_id",
            "        app_cred_data['roles'] = self._get_roles(app_cred_data, token)",
            "        if app_cred_data.get('expires_at'):",
            "            app_cred_data['expires_at'] = utils.parse_expiration_date(",
            "                app_cred_data['expires_at'])",
            "        if app_cred_data.get('access_rules'):",
            "            for access_rule in app_cred_data['access_rules']:",
            "                # If user provides an access rule by ID, it will be looked up",
            "                # by ID. If user provides an access rule that is identical to",
            "                # an existing one, the ID generated here will be ignored and",
            "                # the pre-existing access rule will be used.",
            "                if 'id' not in access_rule:",
            "                    # Generate directly, rather than using _assign_unique_id,",
            "                    # so that there is no deep copy made",
            "                    access_rule['id'] = uuid.uuid4().hex",
            "        app_cred_data = self._normalize_dict(app_cred_data)",
            "        app_cred_api = PROVIDERS.application_credential_api",
            "",
            "        try:",
            "            ref = app_cred_api.create_application_credential(",
            "                app_cred_data, initiator=self.audit_initiator)",
            "        except ks_exception.RoleAssignmentNotFound as e:",
            "            # Raise a Bad Request, not a Not Found, in accordance with the",
            "            # API-SIG recommendations:",
            "            # https://specs.openstack.org/openstack/api-wg/guidelines/http.html#failure-code-clarifications",
            "            raise ks_exception.ApplicationCredentialValidationError(",
            "                detail=str(e))",
            "        return self.wrap_member(ref), http_client.CREATED",
            "",
            "",
            "class UserAppCredGetDeleteResource(ks_flask.ResourceBase):",
            "    collection_key = 'application_credentials'",
            "    member_key = 'application_credential'",
            "",
            "    def get(self, user_id, application_credential_id):",
            "        \"\"\"Get application credential resource.",
            "",
            "        GET/HEAD /v3/users/{user_id}/application_credentials/",
            "                 {application_credential_id}",
            "        \"\"\"",
            "        ENFORCER.enforce_call(action='identity:get_application_credential')",
            "        ref = PROVIDERS.application_credential_api.get_application_credential(",
            "            application_credential_id)",
            "        return self.wrap_member(ref)",
            "",
            "    def delete(self, user_id, application_credential_id):",
            "        \"\"\"Delete application credential resource.",
            "",
            "        DELETE /v3/users/{user_id}/application_credentials/",
            "               {application_credential_id}",
            "        \"\"\"",
            "        ENFORCER.enforce_call(action='identity:delete_application_credential')",
            "        token = self.auth_context['token']",
            "        _check_unrestricted_application_credential(token)",
            "        PROVIDERS.application_credential_api.delete_application_credential(",
            "            application_credential_id, initiator=self.audit_initiator)",
            "        return None, http_client.NO_CONTENT",
            "",
            "",
            "class UserAccessRuleListResource(ks_flask.ResourceBase):",
            "    collection_key = 'access_rules'",
            "    member_key = 'access_rule'",
            "",
            "    def get(self, user_id):",
            "        \"\"\"List access rules for user.",
            "",
            "        GET/HEAD /v3/users/{user_id}/access_rules",
            "        \"\"\"",
            "        filters = ('service', 'path', 'method',)",
            "        ENFORCER.enforce_call(action='identity:list_access_rules',",
            "                              filters=filters,",
            "                              build_target=_build_user_target_enforcement)",
            "        app_cred_api = PROVIDERS.application_credential_api",
            "        hints = self.build_driver_hints(filters)",
            "        refs = app_cred_api.list_access_rules_for_user(user_id, hints=hints)",
            "        hints = self.build_driver_hints(filters)",
            "        return self.wrap_collection(refs, hints=hints)",
            "",
            "",
            "class UserAccessRuleGetDeleteResource(ks_flask.ResourceBase):",
            "    collection_key = 'access_rules'",
            "    member_key = 'access_rule'",
            "",
            "    def get(self, user_id, access_rule_id):",
            "        \"\"\"Get access rule resource.",
            "",
            "        GET/HEAD /v3/users/{user_id}/access_rules/{access_rule_id}",
            "        \"\"\"",
            "        ENFORCER.enforce_call(",
            "            action='identity:get_access_rule',",
            "            build_target=_build_user_target_enforcement",
            "        )",
            "        ref = PROVIDERS.application_credential_api.get_access_rule(",
            "            access_rule_id)",
            "        return self.wrap_member(ref)",
            "",
            "    def delete(self, user_id, access_rule_id):",
            "        \"\"\"Delete access rule resource.",
            "",
            "        DELETE /v3/users/{user_id}/access_rules/{access_rule_id}",
            "        \"\"\"",
            "        ENFORCER.enforce_call(",
            "            action='identity:delete_access_rule',",
            "            build_target=_build_user_target_enforcement",
            "        )",
            "        PROVIDERS.application_credential_api.delete_access_rule(",
            "            access_rule_id, initiator=self.audit_initiator)",
            "        return None, http_client.NO_CONTENT",
            "",
            "",
            "class UserAPI(ks_flask.APIBase):",
            "    _name = 'users'",
            "    _import_name = __name__",
            "    resources = [UserResource]",
            "    resource_mapping = [",
            "        ks_flask.construct_resource_map(",
            "            resource=UserChangePasswordResource,",
            "            url='/users/<string:user_id>/password',",
            "            resource_kwargs={},",
            "            rel='user_change_password',",
            "            path_vars={'user_id': json_home.Parameters.USER_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=UserGroupsResource,",
            "            url='/users/<string:user_id>/groups',",
            "            resource_kwargs={},",
            "            rel='user_groups',",
            "            path_vars={'user_id': json_home.Parameters.USER_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=UserProjectsResource,",
            "            url='/users/<string:user_id>/projects',",
            "            resource_kwargs={},",
            "            rel='user_projects',",
            "            path_vars={'user_id': json_home.Parameters.USER_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=UserOSEC2CredentialsResourceListCreate,",
            "            url='/users/<string:user_id>/credentials/OS-EC2',",
            "            resource_kwargs={},",
            "            rel='user_credentials',",
            "            resource_relation_func=(",
            "                json_home_relations.os_ec2_resource_rel_func),",
            "            path_vars={'user_id': json_home.Parameters.USER_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=UserOSEC2CredentialsResourceGetDelete,",
            "            url=('/users/<string:user_id>/credentials/OS-EC2/'",
            "                 '<string:credential_id>'),",
            "            resource_kwargs={},",
            "            rel='user_credential',",
            "            resource_relation_func=(",
            "                json_home_relations.os_ec2_resource_rel_func),",
            "            path_vars={",
            "                'credential_id': json_home.build_v3_parameter_relation(",
            "                    'credential_id'),",
            "                'user_id': json_home.Parameters.USER_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=OAuth1ListAccessTokensResource,",
            "            url='/users/<string:user_id>/OS-OAUTH1/access_tokens',",
            "            resource_kwargs={},",
            "            rel='user_access_tokens',",
            "            resource_relation_func=(",
            "                json_home_relations.os_oauth1_resource_rel_func),",
            "            path_vars={'user_id': json_home.Parameters.USER_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=OAuth1AccessTokenCRUDResource,",
            "            url=('/users/<string:user_id>/OS-OAUTH1/'",
            "                 'access_tokens/<string:access_token_id>'),",
            "            resource_kwargs={},",
            "            rel='user_access_token',",
            "            resource_relation_func=(",
            "                json_home_relations.os_oauth1_resource_rel_func),",
            "            path_vars={",
            "                'access_token_id': ACCESS_TOKEN_ID_PARAMETER_RELATION,",
            "                'user_id': json_home.Parameters.USER_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=OAuth1AccessTokenRoleListResource,",
            "            url=('/users/<string:user_id>/OS-OAUTH1/access_tokens/'",
            "                 '<string:access_token_id>/roles'),",
            "            resource_kwargs={},",
            "            rel='user_access_token_roles',",
            "            resource_relation_func=(",
            "                json_home_relations.os_oauth1_resource_rel_func),",
            "            path_vars={'access_token_id': ACCESS_TOKEN_ID_PARAMETER_RELATION,",
            "                       'user_id': json_home.Parameters.USER_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=OAuth1AccessTokenRoleResource,",
            "            url=('/users/<string:user_id>/OS-OAUTH1/access_tokens/'",
            "                 '<string:access_token_id>/roles/<string:role_id>'),",
            "            resource_kwargs={},",
            "            rel='user_access_token_role',",
            "            resource_relation_func=(",
            "                json_home_relations.os_oauth1_resource_rel_func),",
            "            path_vars={'access_token_id': ACCESS_TOKEN_ID_PARAMETER_RELATION,",
            "                       'role_id': json_home.Parameters.ROLE_ID,",
            "                       'user_id': json_home.Parameters.USER_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=UserAppCredListCreateResource,",
            "            url='/users/<string:user_id>/application_credentials',",
            "            resource_kwargs={},",
            "            rel='application_credentials',",
            "            path_vars={'user_id': json_home.Parameters.USER_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=UserAppCredGetDeleteResource,",
            "            url=('/users/<string:user_id>/application_credentials/'",
            "                 '<string:application_credential_id>'),",
            "            resource_kwargs={},",
            "            rel='application_credential',",
            "            path_vars={",
            "                'user_id': json_home.Parameters.USER_ID,",
            "                'application_credential_id':",
            "                    json_home.Parameters.APPLICATION_CRED_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=UserAccessRuleListResource,",
            "            url='/users/<string:user_id>/access_rules',",
            "            resource_kwargs={},",
            "            rel='access_rules',",
            "            path_vars={'user_id': json_home.Parameters.USER_ID}",
            "        ),",
            "        ks_flask.construct_resource_map(",
            "            resource=UserAccessRuleGetDeleteResource,",
            "            url=('/users/<string:user_id>/access_rules/'",
            "                 '<string:access_rule_id>'),",
            "            resource_kwargs={},",
            "            rel='access_rule',",
            "            path_vars={",
            "                'user_id': json_home.Parameters.USER_ID,",
            "                'access_rule_id':",
            "                    json_home.Parameters.ACCESS_RULE_ID}",
            "        )",
            "    ]",
            "",
            "",
            "APIs = (UserAPI,)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "597": [
                "UserAppCredListCreateResource",
                "post"
            ],
            "598": [
                "UserAppCredListCreateResource",
                "post"
            ]
        },
        "addLocation": [
            "keystone.api.users.UserAppCredListCreateResource.post",
            "aiohttp",
            "keystone.api.users.UserAppCredListCreateResource.self"
        ]
    },
    "keystone/tests/unit/test_v3_application_credential.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "                    expected_status_code=http_client.FORBIDDEN,"
            },
            "1": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "                    headers={'X-Auth-Token': token})"
            },
            "2": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 171,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+    def test_create_application_credential_with_trust(self):"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+        second_role = unit.new_role_ref(name='reader')"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+        PROVIDERS.role_api.create_role(second_role['id'], second_role)"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+        PROVIDERS.assignment_api.add_role_to_user_and_project("
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+            self.user_id, self.project_id, second_role['id'])"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+        with self.test_client() as c:"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+            pw_token = self.get_scoped_token()"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+            # create a self-trust - only the roles are important for this test"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+            trust_ref = unit.new_trust_ref("
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+                trustor_user_id=self.user_id,"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+                trustee_user_id=self.user_id,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+                project_id=self.project_id,"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+                role_ids=[second_role['id']])"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+            resp = c.post('/v3/OS-TRUST/trusts',"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+                          headers={'X-Auth-Token': pw_token},"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+                          json={'trust': trust_ref})"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+            trust_id = resp.json['trust']['id']"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+            trust_auth = self.build_authentication_request("
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+                user_id=self.user_id,"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+                password=self.user['password'],"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+                trust_id=trust_id)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+            trust_token = self.v3_create_token("
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+                trust_auth).headers['X-Subject-Token']"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+            app_cred = self._app_cred_body(roles=[{'id': self.role_id}])"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+            # only the roles from the trust token should be allowed, even if"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+            # the user has the role assigned on the project"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+            c.post('/v3/users/%s/application_credentials' % self.user_id,"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+                   headers={'X-Auth-Token': trust_token},"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+                   json=app_cred,"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+                   expected_status_code=http_client.BAD_REQUEST)"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 203,
                "PatchRowcode": "     def test_create_application_credential_allow_recursion(self):"
            },
            "35": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "         with self.test_client() as c:"
            },
            "36": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 205,
                "PatchRowcode": "             roles = [{'id': self.role_id}]"
            }
        },
        "frontPatchFile": [
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import datetime",
            "from testtools import matchers",
            "import uuid",
            "",
            "from six.moves import http_client",
            "",
            "from keystone.common import provider_api",
            "import keystone.conf",
            "from keystone.tests import unit",
            "from keystone.tests.unit import test_v3",
            "",
            "",
            "CONF = keystone.conf.CONF",
            "PROVIDERS = provider_api.ProviderAPIs",
            "MEMBER_PATH_FMT = '/users/%(user_id)s/application_credentials/%(app_cred_id)s'",
            "",
            "",
            "class ApplicationCredentialTestCase(test_v3.RestfulTestCase):",
            "    \"\"\"Test CRUD operations for application credentials.\"\"\"",
            "",
            "    def config_overrides(self):",
            "        super(ApplicationCredentialTestCase, self).config_overrides()",
            "        self.config_fixture.config(group='auth',",
            "                                   methods='password,application_credential')",
            "",
            "    def _app_cred_body(self, roles=None, name=None, expires=None, secret=None,",
            "                       access_rules=None):",
            "        name = name or uuid.uuid4().hex",
            "        description = 'Credential for backups'",
            "        app_cred_data = {",
            "            'name': name,",
            "            'description': description",
            "        }",
            "        if roles:",
            "            app_cred_data['roles'] = roles",
            "        if expires:",
            "            app_cred_data['expires_at'] = expires",
            "        if secret:",
            "            app_cred_data['secret'] = secret",
            "        if access_rules is not None:",
            "            app_cred_data['access_rules'] = access_rules",
            "        return {'application_credential': app_cred_data}",
            "",
            "    def test_create_application_credential(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body = self._app_cred_body(roles=roles)",
            "            token = self.get_scoped_token()",
            "            resp = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                          json=app_cred_body,",
            "                          expected_status_code=http_client.CREATED,",
            "                          headers={'X-Auth-Token': token})",
            "        # Create operation returns the secret",
            "        self.assertIn('secret', resp.json['application_credential'])",
            "        # But not the stored hash",
            "        self.assertNotIn('secret_hash', resp.json['application_credential'])",
            "",
            "    def test_create_application_credential_with_secret(self):",
            "        with self.test_client() as c:",
            "            secret = 'supersecuresecret'",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body = self._app_cred_body(roles=roles, secret=secret)",
            "            token = self.get_scoped_token()",
            "            resp = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                          json=app_cred_body,",
            "                          expected_status_code=http_client.CREATED,",
            "                          headers={'X-Auth-Token': token})",
            "        self.assertEqual(secret, resp.json['application_credential']['secret'])",
            "",
            "    def test_create_application_credential_roles_from_token(self):",
            "        with self.test_client() as c:",
            "            app_cred_body = self._app_cred_body()",
            "            token = self.get_scoped_token()",
            "            resp = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                          json=app_cred_body,",
            "                          expected_status_code=http_client.CREATED,",
            "                          headers={'X-Auth-Token': token})",
            "            self.assertThat(resp.json['application_credential']['roles'],",
            "                            matchers.HasLength(1))",
            "            self.assertEqual(resp.json['application_credential']['roles'][0]['id'],",
            "                             self.role_id)",
            "",
            "    def test_create_application_credential_wrong_user(self):",
            "        wrong_user = unit.create_user(PROVIDERS.identity_api,",
            "                                      test_v3.DEFAULT_DOMAIN_ID)",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body = self._app_cred_body(roles=roles)",
            "            token = self.get_scoped_token()",
            "            c.post('/v3/users/%s/application_credentials' % wrong_user['id'],",
            "                   json=app_cred_body,",
            "                   expected_status_code=http_client.FORBIDDEN,",
            "                   headers={'X-Auth-Token': token})",
            "",
            "    def test_create_application_credential_bad_role(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': uuid.uuid4().hex}]",
            "            app_cred_body = self._app_cred_body(roles=roles)",
            "            token = self.get_scoped_token()",
            "            c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                   json=app_cred_body,",
            "                   expected_status_code=http_client.BAD_REQUEST,",
            "                   headers={'X-Auth-Token': token})",
            "",
            "    def test_create_application_credential_with_expiration(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            expires = datetime.datetime.utcnow() + datetime.timedelta(days=365)",
            "            expires = str(expires)",
            "            app_cred_body = self._app_cred_body(roles=roles, expires=expires)",
            "            token = self.get_scoped_token()",
            "            c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                   json=app_cred_body,",
            "                   expected_status_code=http_client.CREATED,",
            "                   headers={'X-Auth-Token': token})",
            "",
            "    def test_create_application_credential_invalid_expiration_fmt(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            expires = 'next tuesday'",
            "            app_cred_body = self._app_cred_body(roles=roles, expires=expires)",
            "            token = self.get_scoped_token()",
            "            c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                   json=app_cred_body,",
            "                   expected_status_code=http_client.BAD_REQUEST,",
            "                   headers={'X-Auth-Token': token})",
            "",
            "    def test_create_application_credential_already_expired(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            expires = datetime.datetime.utcnow() - datetime.timedelta(hours=1)",
            "            app_cred_body = self._app_cred_body(roles=roles, expires=expires)",
            "            token = self.get_scoped_token()",
            "            c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                   json=app_cred_body,",
            "                   expected_status_code=http_client.BAD_REQUEST,",
            "                   headers={'X-Auth-Token': token})",
            "",
            "    def test_create_application_credential_with_application_credential(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body_1 = self._app_cred_body(roles=roles)",
            "            token = self.get_scoped_token()",
            "            app_cred_1 = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                                json=app_cred_body_1,",
            "                                expected_status_code=http_client.CREATED,",
            "                                headers={'X-Auth-Token': token})",
            "            auth_data = self.build_authentication_request(",
            "                app_cred_id=app_cred_1.json['application_credential']['id'],",
            "                secret=app_cred_1.json['application_credential']['secret'])",
            "            token_data = self.v3_create_token(auth_data,",
            "                                              expected_status=http_client.CREATED)",
            "            app_cred_body_2 = self._app_cred_body(roles=roles)",
            "            token = token_data.headers['x-subject-token']",
            "            c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                   json=app_cred_body_2,",
            "                   expected_status_code=http_client.FORBIDDEN,",
            "                   headers={'X-Auth-Token': token})",
            "",
            "    def test_create_application_credential_allow_recursion(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body_1 = self._app_cred_body(roles=roles)",
            "            app_cred_body_1['application_credential']['unrestricted'] = True",
            "            token = self.get_scoped_token()",
            "            app_cred_1 = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                                json=app_cred_body_1,",
            "                                expected_status_code=http_client.CREATED,",
            "                                headers={'X-Auth-Token': token})",
            "            auth_data = self.build_authentication_request(",
            "                app_cred_id=app_cred_1.json['application_credential']['id'],",
            "                secret=app_cred_1.json['application_credential']['secret'])",
            "            token_data = self.v3_create_token(auth_data,",
            "                                              expected_status=http_client.CREATED)",
            "            app_cred_body_2 = self._app_cred_body(roles=roles)",
            "            c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                   json=app_cred_body_2,",
            "                   expected_status_code=http_client.CREATED,",
            "                   headers={'x-Auth-Token': token_data.headers['x-subject-token']})",
            "",
            "    def test_create_application_credential_with_access_rules(self):",
            "        roles = [{'id': self.role_id}]",
            "        access_rules = [",
            "            {",
            "                'path': '/v3/projects',",
            "                'method': 'POST',",
            "                'service': 'identity',",
            "            }",
            "        ]",
            "        app_cred_body = self._app_cred_body(roles=roles,",
            "                                            access_rules=access_rules)",
            "        with self.test_client() as c:",
            "            token = self.get_scoped_token()",
            "            resp = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                          headers={'X-Auth-Token': token},",
            "                          json=app_cred_body,",
            "                          expected_status_code=http_client.CREATED)",
            "            app_cred_id = resp.json['application_credential']['id']",
            "            resp_access_rules = resp.json['application_credential']['access_rules']",
            "            access_rule_id = resp_access_rules[0].pop('id')",
            "            self.assertEqual(access_rules[0], resp_access_rules[0])",
            "            resp = c.get('/v3/users/%s/access_rules' % self.user_id,",
            "                         headers={'X-Auth-Token': token})",
            "            resp_access_rule = resp.json['access_rules'][0]",
            "            resp_access_rule.pop('id')",
            "            resp_access_rule.pop('links')",
            "            self.assertEqual(access_rules[0], resp_access_rule)",
            "            resp = c.get('/v3/users/%s/access_rules/%s' % (",
            "                self.user_id, access_rule_id), headers={'X-Auth-Token': token})",
            "            resp_access_rule = resp.json['access_rule']",
            "            resp_access_rule.pop('id')",
            "            resp_access_rule.pop('links')",
            "            self.assertEqual(access_rules[0], resp_access_rule)",
            "            # can't delete an access rule in use",
            "            c.delete('/v3/users/%s/access_rules/%s' % (",
            "                     self.user_id, access_rule_id),",
            "                     headers={'X-Auth-Token': token},",
            "                     expected_status_code=http_client.FORBIDDEN)",
            "            c.delete('/v3/users/%s/application_credentials/%s' % (",
            "                     self.user_id, app_cred_id),",
            "                     headers={'X-Auth-Token': token})",
            "            c.delete('/v3/users/%s/access_rules/%s' % (",
            "                     self.user_id, access_rule_id),",
            "                     headers={'X-Auth-Token': token})",
            "",
            "    def test_create_application_credential_with_duplicate_access_rule(self):",
            "        roles = [{'id': self.role_id}]",
            "        access_rules = [",
            "            {",
            "                'path': '/v3/projects',",
            "                'method': 'POST',",
            "                'service': 'identity',",
            "            }",
            "        ]",
            "        app_cred_body_1 = self._app_cred_body(roles=roles,",
            "                                              access_rules=access_rules)",
            "        with self.test_client() as c:",
            "            token = self.get_scoped_token()",
            "            resp = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                          headers={'X-Auth-Token': token},",
            "                          json=app_cred_body_1,",
            "                          expected_status_code=http_client.CREATED)",
            "        resp_access_rules = resp.json['application_credential']['access_rules']",
            "        self.assertIn('id', resp_access_rules[0])",
            "        access_rule_id = resp_access_rules[0].pop('id')",
            "        self.assertEqual(access_rules[0], resp_access_rules[0])",
            "",
            "        app_cred_body_2 = self._app_cred_body(roles=roles,",
            "                                              access_rules=access_rules)",
            "        with self.test_client() as c:",
            "            token = self.get_scoped_token()",
            "            resp = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                          headers={'X-Auth-Token': token},",
            "                          json=app_cred_body_2,",
            "                          expected_status_code=http_client.CREATED)",
            "        resp_access_rules = resp.json['application_credential']['access_rules']",
            "        self.assertEqual(access_rule_id, resp_access_rules[0]['id'])",
            "",
            "    def test_create_application_credential_with_access_rule_by_id(self):",
            "        roles = [{'id': self.role_id}]",
            "        access_rules = [",
            "            {",
            "                'path': '/v3/projects',",
            "                'method': 'POST',",
            "                'service': 'identity',",
            "            }",
            "        ]",
            "        app_cred_body_1 = self._app_cred_body(roles=roles,",
            "                                              access_rules=access_rules)",
            "        with self.test_client() as c:",
            "            token = self.get_scoped_token()",
            "            resp = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                          headers={'X-Auth-Token': token},",
            "                          json=app_cred_body_1,",
            "                          expected_status_code=http_client.CREATED)",
            "        resp_access_rules = resp.json['application_credential']['access_rules']",
            "        access_rule_id = resp_access_rules",
            "        self.assertIn('id', resp_access_rules[0])",
            "        access_rule_id = resp_access_rules[0].pop('id')",
            "        self.assertEqual(access_rules[0], resp_access_rules[0])",
            "",
            "        access_rules = [{'id': access_rule_id}]",
            "        app_cred_body_2 = self._app_cred_body(roles=roles,",
            "                                              access_rules=access_rules)",
            "        with self.test_client() as c:",
            "            token = self.get_scoped_token()",
            "            resp = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                          headers={'X-Auth-Token': token},",
            "                          json=app_cred_body_2,",
            "                          expected_status_code=http_client.CREATED)",
            "        resp_access_rules = resp.json['application_credential']['access_rules']",
            "        self.assertEqual(access_rule_id, resp_access_rules[0]['id'])",
            "",
            "    def test_list_application_credentials(self):",
            "        with self.test_client() as c:",
            "            token = self.get_scoped_token()",
            "            resp = c.get('/v3/users/%s/application_credentials' % self.user_id,",
            "                         expected_status_code=http_client.OK,",
            "                         headers={'X-Auth-Token': token})",
            "            self.assertEqual([], resp.json['application_credentials'])",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body = self._app_cred_body(roles=roles)",
            "            c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                   json=app_cred_body,",
            "                   expected_status_code=http_client.CREATED,",
            "                   headers={'X-Auth-Token': token})",
            "            resp = c.get('/v3/users/%s/application_credentials' % self.user_id,",
            "                         expected_status_code=http_client.OK,",
            "                         headers={'X-Auth-Token': token})",
            "            self.assertEqual(1, len(resp.json['application_credentials']))",
            "            self.assertNotIn('secret', resp.json['application_credentials'][0])",
            "            self.assertNotIn('secret_hash',",
            "                             resp.json['application_credentials'][0])",
            "            app_cred_body['application_credential']['name'] = 'two'",
            "            c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                   json=app_cred_body,",
            "                   expected_status_code=http_client.CREATED,",
            "                   headers={'X-Auth-Token': token})",
            "            resp = c.get('/v3/users/%s/application_credentials' % self.user_id,",
            "                         expected_status_code=http_client.OK,",
            "                         headers={'X-Auth-Token': token})",
            "            self.assertEqual(2, len(resp.json['application_credentials']))",
            "            for ac in resp.json['application_credentials']:",
            "                self.assertNotIn('secret', ac)",
            "                self.assertNotIn('secret_hash', ac)",
            "",
            "    def test_list_application_credentials_by_name(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body = self._app_cred_body(roles=roles)",
            "            token = self.get_scoped_token()",
            "            name = app_cred_body['application_credential']['name']",
            "            search_path = ('/v3/users/%(user_id)s/application_credentials?'",
            "                           'name=%(name)s') % {'user_id': self.user_id,",
            "                                               'name': name}",
            "            resp = c.get(search_path,",
            "                         expected_status_code=http_client.OK,",
            "                         headers={'X-Auth-Token': token})",
            "            self.assertEqual([], resp.json['application_credentials'])",
            "            resp = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                          json=app_cred_body,",
            "                          expected_status_code=http_client.CREATED,",
            "                          headers={'X-Auth-Token': token})",
            "            resp = c.get(search_path, expected_status_code=http_client.OK,",
            "                         headers={'X-Auth-Token': token})",
            "            self.assertEqual(1, len(resp.json['application_credentials']))",
            "            self.assertNotIn('secret', resp.json['application_credentials'][0])",
            "            self.assertNotIn('secret_hash',",
            "                             resp.json['application_credentials'][0])",
            "            app_cred_body['application_credential']['name'] = 'two'",
            "            c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                   json=app_cred_body,",
            "                   expected_status_code=http_client.CREATED,",
            "                   headers={'X-Auth-Token': token})",
            "            resp = c.get(search_path, expected_status_code=http_client.OK,",
            "                         headers={'X-Auth-Token': token})",
            "            self.assertEqual(1, len(resp.json['application_credentials']))",
            "            self.assertEqual(resp.json['application_credentials'][0]['name'], name)",
            "",
            "    def test_get_head_application_credential(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body = self._app_cred_body(roles=roles)",
            "            token = self.get_scoped_token()",
            "            resp = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                          json=app_cred_body,",
            "                          expected_status_code=http_client.CREATED,",
            "                          headers={'X-Auth-Token': token})",
            "            app_cred_id = resp.json['application_credential']['id']",
            "            c.head('/v3%s' % MEMBER_PATH_FMT % {'user_id': self.user_id,",
            "                                                'app_cred_id': app_cred_id},",
            "                   expected_status_code=http_client.OK,",
            "                   headers={'X-Auth-Token': token})",
            "            expected_response = resp.json",
            "            expected_response['application_credential'].pop('secret')",
            "            resp = c.get('/v3%s' % MEMBER_PATH_FMT % {'user_id': self.user_id,",
            "                         'app_cred_id': app_cred_id},",
            "                         expected_status_code=http_client.OK,",
            "                         headers={'X-Auth-Token': token})",
            "            self.assertDictEqual(resp.json, expected_response)",
            "",
            "    def test_get_head_application_credential_not_found(self):",
            "        with self.test_client() as c:",
            "            token = self.get_scoped_token()",
            "            c.head('/v3%s' % MEMBER_PATH_FMT % {'user_id': self.user_id,",
            "                   'app_cred_id': uuid.uuid4().hex},",
            "                   expected_status_code=http_client.NOT_FOUND,",
            "                   headers={'X-Auth-Token': token})",
            "            c.get('/v3%s' % MEMBER_PATH_FMT % {'user_id': self.user_id,",
            "                  'app_cred_id': uuid.uuid4().hex},",
            "                  expected_status_code=http_client.NOT_FOUND,",
            "                  headers={'X-Auth-Token': token})",
            "",
            "    def test_delete_application_credential(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body = self._app_cred_body(roles=roles)",
            "            token = self.get_scoped_token()",
            "            resp = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                          json=app_cred_body,",
            "                          expected_status_code=http_client.CREATED,",
            "                          headers={'X-Auth-Token': token})",
            "            app_cred_id = resp.json['application_credential']['id']",
            "            c.delete('/v3%s' % MEMBER_PATH_FMT % {'user_id': self.user_id,",
            "                     'app_cred_id': app_cred_id},",
            "                     expected_status_code=http_client.NO_CONTENT,",
            "                     headers={'X-Auth-Token': token})",
            "",
            "    def test_delete_application_credential_not_found(self):",
            "        with self.test_client() as c:",
            "            token = self.get_scoped_token()",
            "            c.delete('/v3%s' % MEMBER_PATH_FMT % {'user_id': self.user_id,",
            "                     'app_cred_id': uuid.uuid4().hex},",
            "                     expected_status_code=http_client.NOT_FOUND,",
            "                     headers={'X-Auth-Token': token})",
            "",
            "    def test_delete_application_credential_with_application_credential(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body = self._app_cred_body(roles=roles)",
            "            token = self.get_scoped_token()",
            "            app_cred = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                              json=app_cred_body,",
            "                              expected_status_code=http_client.CREATED,",
            "                              headers={'X-Auth-Token': token})",
            "            auth_data = self.build_authentication_request(",
            "                app_cred_id=app_cred.json['application_credential']['id'],",
            "                secret=app_cred.json['application_credential']['secret'])",
            "            token_data = self.v3_create_token(auth_data,",
            "                                              expected_status=http_client.CREATED)",
            "            member_path = '/v3%s' % MEMBER_PATH_FMT % {",
            "                          'user_id': self.user_id,",
            "                          'app_cred_id': app_cred.json['application_credential']['id']}",
            "            token = token_data.headers['x-subject-token']",
            "            c.delete(member_path,",
            "                     json=app_cred_body,",
            "                     expected_status_code=http_client.FORBIDDEN,",
            "                     headers={'X-Auth-Token': token})",
            "",
            "    def test_delete_application_credential_allow_recursion(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body = self._app_cred_body(roles=roles)",
            "            app_cred_body['application_credential']['unrestricted'] = True",
            "            token = self.get_scoped_token()",
            "            app_cred = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                              json=app_cred_body,",
            "                              expected_status_code=http_client.CREATED,",
            "                              headers={'X-Auth-Token': token})",
            "            auth_data = self.build_authentication_request(",
            "                app_cred_id=app_cred.json['application_credential']['id'],",
            "                secret=app_cred.json['application_credential']['secret'])",
            "            token_data = self.v3_create_token(auth_data,",
            "                                              expected_status=http_client.CREATED)",
            "            member_path = '/v3%s' % MEMBER_PATH_FMT % {",
            "                          'user_id': self.user_id,",
            "                          'app_cred_id': app_cred.json['application_credential']['id']}",
            "            c.delete(member_path,",
            "                     json=app_cred_body,",
            "                     expected_status_code=http_client.NO_CONTENT,",
            "                     headers={'x-Auth-Token': token_data.headers['x-subject-token']})",
            "",
            "    def test_update_application_credential(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body = self._app_cred_body(roles=roles)",
            "            token = self.get_scoped_token()",
            "            resp = c.post(",
            "                '/v3/users/%s/application_credentials' % self.user_id,",
            "                json=app_cred_body,",
            "                expected_status_code=http_client.CREATED,",
            "                headers={'X-Auth-Token': token})",
            "            # Application credentials are immutable",
            "            app_cred_body['application_credential'][",
            "                'description'] = \"New Things\"",
            "            app_cred_id = resp.json['application_credential']['id']",
            "            # NOTE(morgan): when the whole test case is converted to using",
            "            # flask test_client, this extra v3 prefix will",
            "            # need to be rolled into the base MEMBER_PATH_FMT",
            "            member_path = '/v3%s' % MEMBER_PATH_FMT % {",
            "                'user_id': self.user_id,",
            "                'app_cred_id': app_cred_id}",
            "            c.patch(member_path,",
            "                    json=app_cred_body,",
            "                    expected_status_code=http_client.METHOD_NOT_ALLOWED,",
            "                    headers={'X-Auth-Token': token})"
        ],
        "afterPatchFile": [
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import datetime",
            "from testtools import matchers",
            "import uuid",
            "",
            "from six.moves import http_client",
            "",
            "from keystone.common import provider_api",
            "import keystone.conf",
            "from keystone.tests import unit",
            "from keystone.tests.unit import test_v3",
            "",
            "",
            "CONF = keystone.conf.CONF",
            "PROVIDERS = provider_api.ProviderAPIs",
            "MEMBER_PATH_FMT = '/users/%(user_id)s/application_credentials/%(app_cred_id)s'",
            "",
            "",
            "class ApplicationCredentialTestCase(test_v3.RestfulTestCase):",
            "    \"\"\"Test CRUD operations for application credentials.\"\"\"",
            "",
            "    def config_overrides(self):",
            "        super(ApplicationCredentialTestCase, self).config_overrides()",
            "        self.config_fixture.config(group='auth',",
            "                                   methods='password,application_credential')",
            "",
            "    def _app_cred_body(self, roles=None, name=None, expires=None, secret=None,",
            "                       access_rules=None):",
            "        name = name or uuid.uuid4().hex",
            "        description = 'Credential for backups'",
            "        app_cred_data = {",
            "            'name': name,",
            "            'description': description",
            "        }",
            "        if roles:",
            "            app_cred_data['roles'] = roles",
            "        if expires:",
            "            app_cred_data['expires_at'] = expires",
            "        if secret:",
            "            app_cred_data['secret'] = secret",
            "        if access_rules is not None:",
            "            app_cred_data['access_rules'] = access_rules",
            "        return {'application_credential': app_cred_data}",
            "",
            "    def test_create_application_credential(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body = self._app_cred_body(roles=roles)",
            "            token = self.get_scoped_token()",
            "            resp = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                          json=app_cred_body,",
            "                          expected_status_code=http_client.CREATED,",
            "                          headers={'X-Auth-Token': token})",
            "        # Create operation returns the secret",
            "        self.assertIn('secret', resp.json['application_credential'])",
            "        # But not the stored hash",
            "        self.assertNotIn('secret_hash', resp.json['application_credential'])",
            "",
            "    def test_create_application_credential_with_secret(self):",
            "        with self.test_client() as c:",
            "            secret = 'supersecuresecret'",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body = self._app_cred_body(roles=roles, secret=secret)",
            "            token = self.get_scoped_token()",
            "            resp = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                          json=app_cred_body,",
            "                          expected_status_code=http_client.CREATED,",
            "                          headers={'X-Auth-Token': token})",
            "        self.assertEqual(secret, resp.json['application_credential']['secret'])",
            "",
            "    def test_create_application_credential_roles_from_token(self):",
            "        with self.test_client() as c:",
            "            app_cred_body = self._app_cred_body()",
            "            token = self.get_scoped_token()",
            "            resp = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                          json=app_cred_body,",
            "                          expected_status_code=http_client.CREATED,",
            "                          headers={'X-Auth-Token': token})",
            "            self.assertThat(resp.json['application_credential']['roles'],",
            "                            matchers.HasLength(1))",
            "            self.assertEqual(resp.json['application_credential']['roles'][0]['id'],",
            "                             self.role_id)",
            "",
            "    def test_create_application_credential_wrong_user(self):",
            "        wrong_user = unit.create_user(PROVIDERS.identity_api,",
            "                                      test_v3.DEFAULT_DOMAIN_ID)",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body = self._app_cred_body(roles=roles)",
            "            token = self.get_scoped_token()",
            "            c.post('/v3/users/%s/application_credentials' % wrong_user['id'],",
            "                   json=app_cred_body,",
            "                   expected_status_code=http_client.FORBIDDEN,",
            "                   headers={'X-Auth-Token': token})",
            "",
            "    def test_create_application_credential_bad_role(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': uuid.uuid4().hex}]",
            "            app_cred_body = self._app_cred_body(roles=roles)",
            "            token = self.get_scoped_token()",
            "            c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                   json=app_cred_body,",
            "                   expected_status_code=http_client.BAD_REQUEST,",
            "                   headers={'X-Auth-Token': token})",
            "",
            "    def test_create_application_credential_with_expiration(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            expires = datetime.datetime.utcnow() + datetime.timedelta(days=365)",
            "            expires = str(expires)",
            "            app_cred_body = self._app_cred_body(roles=roles, expires=expires)",
            "            token = self.get_scoped_token()",
            "            c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                   json=app_cred_body,",
            "                   expected_status_code=http_client.CREATED,",
            "                   headers={'X-Auth-Token': token})",
            "",
            "    def test_create_application_credential_invalid_expiration_fmt(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            expires = 'next tuesday'",
            "            app_cred_body = self._app_cred_body(roles=roles, expires=expires)",
            "            token = self.get_scoped_token()",
            "            c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                   json=app_cred_body,",
            "                   expected_status_code=http_client.BAD_REQUEST,",
            "                   headers={'X-Auth-Token': token})",
            "",
            "    def test_create_application_credential_already_expired(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            expires = datetime.datetime.utcnow() - datetime.timedelta(hours=1)",
            "            app_cred_body = self._app_cred_body(roles=roles, expires=expires)",
            "            token = self.get_scoped_token()",
            "            c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                   json=app_cred_body,",
            "                   expected_status_code=http_client.BAD_REQUEST,",
            "                   headers={'X-Auth-Token': token})",
            "",
            "    def test_create_application_credential_with_application_credential(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body_1 = self._app_cred_body(roles=roles)",
            "            token = self.get_scoped_token()",
            "            app_cred_1 = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                                json=app_cred_body_1,",
            "                                expected_status_code=http_client.CREATED,",
            "                                headers={'X-Auth-Token': token})",
            "            auth_data = self.build_authentication_request(",
            "                app_cred_id=app_cred_1.json['application_credential']['id'],",
            "                secret=app_cred_1.json['application_credential']['secret'])",
            "            token_data = self.v3_create_token(auth_data,",
            "                                              expected_status=http_client.CREATED)",
            "            app_cred_body_2 = self._app_cred_body(roles=roles)",
            "            token = token_data.headers['x-subject-token']",
            "            c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                   json=app_cred_body_2,",
            "                   expected_status_code=http_client.FORBIDDEN,",
            "                   headers={'X-Auth-Token': token})",
            "",
            "    def test_create_application_credential_with_trust(self):",
            "        second_role = unit.new_role_ref(name='reader')",
            "        PROVIDERS.role_api.create_role(second_role['id'], second_role)",
            "        PROVIDERS.assignment_api.add_role_to_user_and_project(",
            "            self.user_id, self.project_id, second_role['id'])",
            "        with self.test_client() as c:",
            "            pw_token = self.get_scoped_token()",
            "            # create a self-trust - only the roles are important for this test",
            "            trust_ref = unit.new_trust_ref(",
            "                trustor_user_id=self.user_id,",
            "                trustee_user_id=self.user_id,",
            "                project_id=self.project_id,",
            "                role_ids=[second_role['id']])",
            "            resp = c.post('/v3/OS-TRUST/trusts',",
            "                          headers={'X-Auth-Token': pw_token},",
            "                          json={'trust': trust_ref})",
            "            trust_id = resp.json['trust']['id']",
            "            trust_auth = self.build_authentication_request(",
            "                user_id=self.user_id,",
            "                password=self.user['password'],",
            "                trust_id=trust_id)",
            "            trust_token = self.v3_create_token(",
            "                trust_auth).headers['X-Subject-Token']",
            "            app_cred = self._app_cred_body(roles=[{'id': self.role_id}])",
            "            # only the roles from the trust token should be allowed, even if",
            "            # the user has the role assigned on the project",
            "            c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                   headers={'X-Auth-Token': trust_token},",
            "                   json=app_cred,",
            "                   expected_status_code=http_client.BAD_REQUEST)",
            "",
            "    def test_create_application_credential_allow_recursion(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body_1 = self._app_cred_body(roles=roles)",
            "            app_cred_body_1['application_credential']['unrestricted'] = True",
            "            token = self.get_scoped_token()",
            "            app_cred_1 = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                                json=app_cred_body_1,",
            "                                expected_status_code=http_client.CREATED,",
            "                                headers={'X-Auth-Token': token})",
            "            auth_data = self.build_authentication_request(",
            "                app_cred_id=app_cred_1.json['application_credential']['id'],",
            "                secret=app_cred_1.json['application_credential']['secret'])",
            "            token_data = self.v3_create_token(auth_data,",
            "                                              expected_status=http_client.CREATED)",
            "            app_cred_body_2 = self._app_cred_body(roles=roles)",
            "            c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                   json=app_cred_body_2,",
            "                   expected_status_code=http_client.CREATED,",
            "                   headers={'x-Auth-Token': token_data.headers['x-subject-token']})",
            "",
            "    def test_create_application_credential_with_access_rules(self):",
            "        roles = [{'id': self.role_id}]",
            "        access_rules = [",
            "            {",
            "                'path': '/v3/projects',",
            "                'method': 'POST',",
            "                'service': 'identity',",
            "            }",
            "        ]",
            "        app_cred_body = self._app_cred_body(roles=roles,",
            "                                            access_rules=access_rules)",
            "        with self.test_client() as c:",
            "            token = self.get_scoped_token()",
            "            resp = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                          headers={'X-Auth-Token': token},",
            "                          json=app_cred_body,",
            "                          expected_status_code=http_client.CREATED)",
            "            app_cred_id = resp.json['application_credential']['id']",
            "            resp_access_rules = resp.json['application_credential']['access_rules']",
            "            access_rule_id = resp_access_rules[0].pop('id')",
            "            self.assertEqual(access_rules[0], resp_access_rules[0])",
            "            resp = c.get('/v3/users/%s/access_rules' % self.user_id,",
            "                         headers={'X-Auth-Token': token})",
            "            resp_access_rule = resp.json['access_rules'][0]",
            "            resp_access_rule.pop('id')",
            "            resp_access_rule.pop('links')",
            "            self.assertEqual(access_rules[0], resp_access_rule)",
            "            resp = c.get('/v3/users/%s/access_rules/%s' % (",
            "                self.user_id, access_rule_id), headers={'X-Auth-Token': token})",
            "            resp_access_rule = resp.json['access_rule']",
            "            resp_access_rule.pop('id')",
            "            resp_access_rule.pop('links')",
            "            self.assertEqual(access_rules[0], resp_access_rule)",
            "            # can't delete an access rule in use",
            "            c.delete('/v3/users/%s/access_rules/%s' % (",
            "                     self.user_id, access_rule_id),",
            "                     headers={'X-Auth-Token': token},",
            "                     expected_status_code=http_client.FORBIDDEN)",
            "            c.delete('/v3/users/%s/application_credentials/%s' % (",
            "                     self.user_id, app_cred_id),",
            "                     headers={'X-Auth-Token': token})",
            "            c.delete('/v3/users/%s/access_rules/%s' % (",
            "                     self.user_id, access_rule_id),",
            "                     headers={'X-Auth-Token': token})",
            "",
            "    def test_create_application_credential_with_duplicate_access_rule(self):",
            "        roles = [{'id': self.role_id}]",
            "        access_rules = [",
            "            {",
            "                'path': '/v3/projects',",
            "                'method': 'POST',",
            "                'service': 'identity',",
            "            }",
            "        ]",
            "        app_cred_body_1 = self._app_cred_body(roles=roles,",
            "                                              access_rules=access_rules)",
            "        with self.test_client() as c:",
            "            token = self.get_scoped_token()",
            "            resp = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                          headers={'X-Auth-Token': token},",
            "                          json=app_cred_body_1,",
            "                          expected_status_code=http_client.CREATED)",
            "        resp_access_rules = resp.json['application_credential']['access_rules']",
            "        self.assertIn('id', resp_access_rules[0])",
            "        access_rule_id = resp_access_rules[0].pop('id')",
            "        self.assertEqual(access_rules[0], resp_access_rules[0])",
            "",
            "        app_cred_body_2 = self._app_cred_body(roles=roles,",
            "                                              access_rules=access_rules)",
            "        with self.test_client() as c:",
            "            token = self.get_scoped_token()",
            "            resp = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                          headers={'X-Auth-Token': token},",
            "                          json=app_cred_body_2,",
            "                          expected_status_code=http_client.CREATED)",
            "        resp_access_rules = resp.json['application_credential']['access_rules']",
            "        self.assertEqual(access_rule_id, resp_access_rules[0]['id'])",
            "",
            "    def test_create_application_credential_with_access_rule_by_id(self):",
            "        roles = [{'id': self.role_id}]",
            "        access_rules = [",
            "            {",
            "                'path': '/v3/projects',",
            "                'method': 'POST',",
            "                'service': 'identity',",
            "            }",
            "        ]",
            "        app_cred_body_1 = self._app_cred_body(roles=roles,",
            "                                              access_rules=access_rules)",
            "        with self.test_client() as c:",
            "            token = self.get_scoped_token()",
            "            resp = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                          headers={'X-Auth-Token': token},",
            "                          json=app_cred_body_1,",
            "                          expected_status_code=http_client.CREATED)",
            "        resp_access_rules = resp.json['application_credential']['access_rules']",
            "        access_rule_id = resp_access_rules",
            "        self.assertIn('id', resp_access_rules[0])",
            "        access_rule_id = resp_access_rules[0].pop('id')",
            "        self.assertEqual(access_rules[0], resp_access_rules[0])",
            "",
            "        access_rules = [{'id': access_rule_id}]",
            "        app_cred_body_2 = self._app_cred_body(roles=roles,",
            "                                              access_rules=access_rules)",
            "        with self.test_client() as c:",
            "            token = self.get_scoped_token()",
            "            resp = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                          headers={'X-Auth-Token': token},",
            "                          json=app_cred_body_2,",
            "                          expected_status_code=http_client.CREATED)",
            "        resp_access_rules = resp.json['application_credential']['access_rules']",
            "        self.assertEqual(access_rule_id, resp_access_rules[0]['id'])",
            "",
            "    def test_list_application_credentials(self):",
            "        with self.test_client() as c:",
            "            token = self.get_scoped_token()",
            "            resp = c.get('/v3/users/%s/application_credentials' % self.user_id,",
            "                         expected_status_code=http_client.OK,",
            "                         headers={'X-Auth-Token': token})",
            "            self.assertEqual([], resp.json['application_credentials'])",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body = self._app_cred_body(roles=roles)",
            "            c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                   json=app_cred_body,",
            "                   expected_status_code=http_client.CREATED,",
            "                   headers={'X-Auth-Token': token})",
            "            resp = c.get('/v3/users/%s/application_credentials' % self.user_id,",
            "                         expected_status_code=http_client.OK,",
            "                         headers={'X-Auth-Token': token})",
            "            self.assertEqual(1, len(resp.json['application_credentials']))",
            "            self.assertNotIn('secret', resp.json['application_credentials'][0])",
            "            self.assertNotIn('secret_hash',",
            "                             resp.json['application_credentials'][0])",
            "            app_cred_body['application_credential']['name'] = 'two'",
            "            c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                   json=app_cred_body,",
            "                   expected_status_code=http_client.CREATED,",
            "                   headers={'X-Auth-Token': token})",
            "            resp = c.get('/v3/users/%s/application_credentials' % self.user_id,",
            "                         expected_status_code=http_client.OK,",
            "                         headers={'X-Auth-Token': token})",
            "            self.assertEqual(2, len(resp.json['application_credentials']))",
            "            for ac in resp.json['application_credentials']:",
            "                self.assertNotIn('secret', ac)",
            "                self.assertNotIn('secret_hash', ac)",
            "",
            "    def test_list_application_credentials_by_name(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body = self._app_cred_body(roles=roles)",
            "            token = self.get_scoped_token()",
            "            name = app_cred_body['application_credential']['name']",
            "            search_path = ('/v3/users/%(user_id)s/application_credentials?'",
            "                           'name=%(name)s') % {'user_id': self.user_id,",
            "                                               'name': name}",
            "            resp = c.get(search_path,",
            "                         expected_status_code=http_client.OK,",
            "                         headers={'X-Auth-Token': token})",
            "            self.assertEqual([], resp.json['application_credentials'])",
            "            resp = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                          json=app_cred_body,",
            "                          expected_status_code=http_client.CREATED,",
            "                          headers={'X-Auth-Token': token})",
            "            resp = c.get(search_path, expected_status_code=http_client.OK,",
            "                         headers={'X-Auth-Token': token})",
            "            self.assertEqual(1, len(resp.json['application_credentials']))",
            "            self.assertNotIn('secret', resp.json['application_credentials'][0])",
            "            self.assertNotIn('secret_hash',",
            "                             resp.json['application_credentials'][0])",
            "            app_cred_body['application_credential']['name'] = 'two'",
            "            c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                   json=app_cred_body,",
            "                   expected_status_code=http_client.CREATED,",
            "                   headers={'X-Auth-Token': token})",
            "            resp = c.get(search_path, expected_status_code=http_client.OK,",
            "                         headers={'X-Auth-Token': token})",
            "            self.assertEqual(1, len(resp.json['application_credentials']))",
            "            self.assertEqual(resp.json['application_credentials'][0]['name'], name)",
            "",
            "    def test_get_head_application_credential(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body = self._app_cred_body(roles=roles)",
            "            token = self.get_scoped_token()",
            "            resp = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                          json=app_cred_body,",
            "                          expected_status_code=http_client.CREATED,",
            "                          headers={'X-Auth-Token': token})",
            "            app_cred_id = resp.json['application_credential']['id']",
            "            c.head('/v3%s' % MEMBER_PATH_FMT % {'user_id': self.user_id,",
            "                                                'app_cred_id': app_cred_id},",
            "                   expected_status_code=http_client.OK,",
            "                   headers={'X-Auth-Token': token})",
            "            expected_response = resp.json",
            "            expected_response['application_credential'].pop('secret')",
            "            resp = c.get('/v3%s' % MEMBER_PATH_FMT % {'user_id': self.user_id,",
            "                         'app_cred_id': app_cred_id},",
            "                         expected_status_code=http_client.OK,",
            "                         headers={'X-Auth-Token': token})",
            "            self.assertDictEqual(resp.json, expected_response)",
            "",
            "    def test_get_head_application_credential_not_found(self):",
            "        with self.test_client() as c:",
            "            token = self.get_scoped_token()",
            "            c.head('/v3%s' % MEMBER_PATH_FMT % {'user_id': self.user_id,",
            "                   'app_cred_id': uuid.uuid4().hex},",
            "                   expected_status_code=http_client.NOT_FOUND,",
            "                   headers={'X-Auth-Token': token})",
            "            c.get('/v3%s' % MEMBER_PATH_FMT % {'user_id': self.user_id,",
            "                  'app_cred_id': uuid.uuid4().hex},",
            "                  expected_status_code=http_client.NOT_FOUND,",
            "                  headers={'X-Auth-Token': token})",
            "",
            "    def test_delete_application_credential(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body = self._app_cred_body(roles=roles)",
            "            token = self.get_scoped_token()",
            "            resp = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                          json=app_cred_body,",
            "                          expected_status_code=http_client.CREATED,",
            "                          headers={'X-Auth-Token': token})",
            "            app_cred_id = resp.json['application_credential']['id']",
            "            c.delete('/v3%s' % MEMBER_PATH_FMT % {'user_id': self.user_id,",
            "                     'app_cred_id': app_cred_id},",
            "                     expected_status_code=http_client.NO_CONTENT,",
            "                     headers={'X-Auth-Token': token})",
            "",
            "    def test_delete_application_credential_not_found(self):",
            "        with self.test_client() as c:",
            "            token = self.get_scoped_token()",
            "            c.delete('/v3%s' % MEMBER_PATH_FMT % {'user_id': self.user_id,",
            "                     'app_cred_id': uuid.uuid4().hex},",
            "                     expected_status_code=http_client.NOT_FOUND,",
            "                     headers={'X-Auth-Token': token})",
            "",
            "    def test_delete_application_credential_with_application_credential(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body = self._app_cred_body(roles=roles)",
            "            token = self.get_scoped_token()",
            "            app_cred = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                              json=app_cred_body,",
            "                              expected_status_code=http_client.CREATED,",
            "                              headers={'X-Auth-Token': token})",
            "            auth_data = self.build_authentication_request(",
            "                app_cred_id=app_cred.json['application_credential']['id'],",
            "                secret=app_cred.json['application_credential']['secret'])",
            "            token_data = self.v3_create_token(auth_data,",
            "                                              expected_status=http_client.CREATED)",
            "            member_path = '/v3%s' % MEMBER_PATH_FMT % {",
            "                          'user_id': self.user_id,",
            "                          'app_cred_id': app_cred.json['application_credential']['id']}",
            "            token = token_data.headers['x-subject-token']",
            "            c.delete(member_path,",
            "                     json=app_cred_body,",
            "                     expected_status_code=http_client.FORBIDDEN,",
            "                     headers={'X-Auth-Token': token})",
            "",
            "    def test_delete_application_credential_allow_recursion(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body = self._app_cred_body(roles=roles)",
            "            app_cred_body['application_credential']['unrestricted'] = True",
            "            token = self.get_scoped_token()",
            "            app_cred = c.post('/v3/users/%s/application_credentials' % self.user_id,",
            "                              json=app_cred_body,",
            "                              expected_status_code=http_client.CREATED,",
            "                              headers={'X-Auth-Token': token})",
            "            auth_data = self.build_authentication_request(",
            "                app_cred_id=app_cred.json['application_credential']['id'],",
            "                secret=app_cred.json['application_credential']['secret'])",
            "            token_data = self.v3_create_token(auth_data,",
            "                                              expected_status=http_client.CREATED)",
            "            member_path = '/v3%s' % MEMBER_PATH_FMT % {",
            "                          'user_id': self.user_id,",
            "                          'app_cred_id': app_cred.json['application_credential']['id']}",
            "            c.delete(member_path,",
            "                     json=app_cred_body,",
            "                     expected_status_code=http_client.NO_CONTENT,",
            "                     headers={'x-Auth-Token': token_data.headers['x-subject-token']})",
            "",
            "    def test_update_application_credential(self):",
            "        with self.test_client() as c:",
            "            roles = [{'id': self.role_id}]",
            "            app_cred_body = self._app_cred_body(roles=roles)",
            "            token = self.get_scoped_token()",
            "            resp = c.post(",
            "                '/v3/users/%s/application_credentials' % self.user_id,",
            "                json=app_cred_body,",
            "                expected_status_code=http_client.CREATED,",
            "                headers={'X-Auth-Token': token})",
            "            # Application credentials are immutable",
            "            app_cred_body['application_credential'][",
            "                'description'] = \"New Things\"",
            "            app_cred_id = resp.json['application_credential']['id']",
            "            # NOTE(morgan): when the whole test case is converted to using",
            "            # flask test_client, this extra v3 prefix will",
            "            # need to be rolled into the base MEMBER_PATH_FMT",
            "            member_path = '/v3%s' % MEMBER_PATH_FMT % {",
            "                'user_id': self.user_id,",
            "                'app_cred_id': app_cred_id}",
            "            c.patch(member_path,",
            "                    json=app_cred_body,",
            "                    expected_status_code=http_client.METHOD_NOT_ALLOWED,",
            "                    headers={'X-Auth-Token': token})"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "aiohttp",
            "keystone.tests.unit.test_v3_application_credential.ApplicationCredentialTestCase._app_cred_body.roles",
            "keystone.tests.unit.test_v3_application_credential.ApplicationCredentialTestCase.self"
        ]
    }
}