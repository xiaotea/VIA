{
    "ckan/lib/uploader.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " import logging"
            },
            "1": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " import magic"
            },
            "2": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " import mimetypes"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+from pathlib import Path"
            },
            "4": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from typing import Any, IO, Optional, Union"
            },
            "5": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " from urllib.parse import urlparse"
            },
            "6": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 160,
                "PatchRowcode": "                 self.filename = str(datetime.datetime.utcnow()) + self.filename"
            },
            "8": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 161,
                "PatchRowcode": "                 self.filename = munge.munge_filename_legacy(self.filename)"
            },
            "9": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 162,
                "PatchRowcode": "                 self.filepath = os.path.join(self.storage_path, self.filename)"
            },
            "10": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                data_dict[url_field] = self.filename"
            },
            "11": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "                 self.upload_file = _get_underlying_file("
            },
            "12": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "                     self.upload_field_storage)"
            },
            "13": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "                 self.tmp_filepath = self.filepath + '~'"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+                self.verify_type()"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+                data_dict[url_field] = self.filename"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "         # keep the file if there has been no change"
            },
            "20": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "         elif self.old_filename and not self.old_filename.startswith('http'):"
            },
            "21": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "             if not self.clear:"
            },
            "22": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 182,
                "PatchRowcode": "         anything unless the request is actually good."
            },
            "23": {
                "beforePatchRowNumber": 178,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "         max_size is size in MB maximum of the file'''"
            },
            "24": {
                "beforePatchRowNumber": 179,
                "afterPatchRowNumber": 184,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 180,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.verify_type()"
            },
            "26": {
                "beforePatchRowNumber": 181,
                "afterPatchRowNumber": 185,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 182,
                "afterPatchRowNumber": 186,
                "PatchRowcode": "         if self.filename:"
            },
            "28": {
                "beforePatchRowNumber": 183,
                "afterPatchRowNumber": 187,
                "PatchRowcode": "             assert self.upload_file and self.filepath"
            },
            "29": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 206,
                "PatchRowcode": "                 pass"
            },
            "30": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 207,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 208,
                "PatchRowcode": "     def verify_type(self):"
            },
            "32": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not self.filename or not self.upload_file:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 210,
                "PatchRowcode": "+        if not self.upload_file:"
            },
            "35": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "             return"
            },
            "36": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 212,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        mimetypes = config.get("
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 213,
                "PatchRowcode": "+        allowed_mimetypes = config.get("
            },
            "39": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 214,
                "PatchRowcode": "             f\"ckan.upload.{self.object_type}.mimetypes\")"
            },
            "40": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        types = config.get(f\"ckan.upload.{self.object_type}.types\")"
            },
            "41": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not mimetypes and not types:"
            },
            "42": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+        allowed_types = config.get(f\"ckan.upload.{self.object_type}.types\")"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+        if not allowed_mimetypes and not allowed_types:"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+            raise logic.ValidationError("
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+                {"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+                    self.file_field: [f\"No uploads allowed for object type {self.object_type}\"]"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+                }"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+            )"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+        # Check that the declared types in the request are supported"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+        declared_mimetype_from_filename = mimetypes.guess_type("
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+            self.upload_field_storage.filename"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+        )[0]"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+        declared_content_type = self.upload_field_storage.content_type"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 228,
                "PatchRowcode": "+        for declared_mimetype in ("
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 229,
                "PatchRowcode": "+            declared_mimetype_from_filename,"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 230,
                "PatchRowcode": "+            declared_content_type,"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 231,
                "PatchRowcode": "+        ):"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 232,
                "PatchRowcode": "+            if ("
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 233,
                "PatchRowcode": "+                declared_mimetype"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 234,
                "PatchRowcode": "+                and allowed_mimetypes"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 235,
                "PatchRowcode": "+                and allowed_mimetypes[0] != \"*\""
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 236,
                "PatchRowcode": "+                and declared_mimetype not in allowed_mimetypes"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 237,
                "PatchRowcode": "+            ):"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 238,
                "PatchRowcode": "+                raise logic.ValidationError("
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 239,
                "PatchRowcode": "+                    {"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+                        self.file_field: ["
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+                            f\"Unsupported upload type: {declared_mimetype}\""
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+                        ]"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+                    }"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 244,
                "PatchRowcode": "+                )"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 245,
                "PatchRowcode": "+"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 246,
                "PatchRowcode": "+        # Check that the actual type guessed from the contents is supported"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+        # (2KB required for detecting xlsx mimetype)"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 248,
                "PatchRowcode": "+        content = self.upload_file.read(2048)"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+        guessed_mimetype = magic.from_buffer(content, mime=True)"
            },
            "78": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 250,
                "PatchRowcode": " "
            },
            "79": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # 2KB required for detecting xlsx mimetype"
            },
            "80": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        actual = magic.from_buffer(self.upload_file.read(2048), mime=True)"
            },
            "81": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 251,
                "PatchRowcode": "         self.upload_file.seek(0, os.SEEK_SET)"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+"
            },
            "83": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "         err: ErrorDict = {"
            },
            "84": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            self.file_field: [f\"Unsupported upload type: {actual}\"]"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+            self.file_field: [f\"Unsupported upload type: {guessed_mimetype}\"]"
            },
            "86": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "         }"
            },
            "87": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 256,
                "PatchRowcode": " "
            },
            "88": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if mimetypes and actual not in mimetypes:"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+        if allowed_mimetypes and allowed_mimetypes[0] != \"*\" and guessed_mimetype not in allowed_mimetypes:"
            },
            "90": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 258,
                "PatchRowcode": "             raise logic.ValidationError(err)"
            },
            "91": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 259,
                "PatchRowcode": " "
            },
            "92": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        type_ = actual.split(\"/\")[0]"
            },
            "93": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if types and type_ not in types:"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 260,
                "PatchRowcode": "+        type_ = guessed_mimetype.split(\"/\")[0]"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 261,
                "PatchRowcode": "+        if allowed_types and allowed_types[0] != \"*\" and type_ not in allowed_types:"
            },
            "96": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 262,
                "PatchRowcode": "             raise logic.ValidationError(err)"
            },
            "97": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": 263,
                "PatchRowcode": " "
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 264,
                "PatchRowcode": "+        preferred_extension = mimetypes.guess_extension(guessed_mimetype)"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 265,
                "PatchRowcode": "+        if preferred_extension:"
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 266,
                "PatchRowcode": "+            self.filename = str(Path(self.filename).with_suffix(preferred_extension))"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+            self.filepath = str(Path(self.filepath).with_suffix(preferred_extension))"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 268,
                "PatchRowcode": "+"
            },
            "103": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 269,
                "PatchRowcode": " "
            },
            "104": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 270,
                "PatchRowcode": " class ResourceUpload(object):"
            },
            "105": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 271,
                "PatchRowcode": "     mimetype: Optional[str]"
            }
        },
        "frontPatchFile": [
            "# encoding: utf-8",
            "from __future__ import annotations",
            "",
            "import os",
            "import cgi",
            "import datetime",
            "import logging",
            "import magic",
            "import mimetypes",
            "from typing import Any, IO, Optional, Union",
            "from urllib.parse import urlparse",
            "",
            "from werkzeug.datastructures import FileStorage as FlaskFileStorage",
            "",
            "import ckan.lib.munge as munge",
            "import ckan.logic as logic",
            "import ckan.plugins as plugins",
            "from ckan.common import config",
            "from ckan.types import ErrorDict, PUploader, PResourceUploader",
            "",
            "ALLOWED_UPLOAD_TYPES = (cgi.FieldStorage, FlaskFileStorage)",
            "MB = 1 << 20",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "def _copy_file(input_file: IO[bytes],",
            "               output_file: IO[bytes], max_size: int) -> None:",
            "    input_file.seek(0)",
            "    current_size = 0",
            "    while True:",
            "        current_size = current_size + 1",
            "        # MB chunks",
            "        data = input_file.read(MB)",
            "",
            "        if not data:",
            "            break",
            "        output_file.write(data)",
            "        if current_size > max_size:",
            "            raise logic.ValidationError({'upload': ['File upload too large']})",
            "",
            "",
            "def _get_underlying_file(wrapper: Union[FlaskFileStorage, cgi.FieldStorage]):",
            "    if isinstance(wrapper, FlaskFileStorage):",
            "        return wrapper.stream",
            "    return wrapper.file",
            "",
            "",
            "def get_uploader(upload_to: str,",
            "                 old_filename: Optional[str] = None) -> PUploader:",
            "    '''Query IUploader plugins and return an uploader instance for general",
            "    files.'''",
            "    upload = None",
            "    for plugin in plugins.PluginImplementations(plugins.IUploader):",
            "        upload = plugin.get_uploader(upload_to, old_filename)",
            "        if upload:",
            "            break",
            "",
            "    # default uploader",
            "    if upload is None:",
            "        upload = Upload(upload_to, old_filename)",
            "",
            "    return upload",
            "",
            "",
            "def get_resource_uploader(data_dict: dict[str, Any]) -> PResourceUploader:",
            "    '''Query IUploader plugins and return a resource uploader instance.'''",
            "    upload = None",
            "    for plugin in plugins.PluginImplementations(plugins.IUploader):",
            "        upload = plugin.get_resource_uploader(data_dict)",
            "        if upload:",
            "            break",
            "",
            "    # default uploader",
            "    if upload is None:",
            "        upload = ResourceUpload(data_dict)",
            "",
            "    return upload",
            "",
            "",
            "def get_storage_path() -> str:",
            "    '''Function to get the storage path from config file.'''",
            "    storage_path = config.get('ckan.storage_path')",
            "    if not storage_path:",
            "        log.critical('''Please specify a ckan.storage_path in your config",
            "                        for your uploads''')",
            "",
            "    return storage_path",
            "",
            "",
            "def get_max_image_size() -> int:",
            "    return config.get('ckan.max_image_size')",
            "",
            "",
            "def get_max_resource_size() -> int:",
            "    return config.get('ckan.max_resource_size')",
            "",
            "",
            "class Upload(object):",
            "    storage_path: Optional[str]",
            "    filename: Optional[str]",
            "    filepath: Optional[str]",
            "    object_type: Optional[str]",
            "    old_filename: Optional[str]",
            "    old_filepath: Optional[str]",
            "    upload_file: Optional[IO[bytes]]",
            "",
            "    def __init__(self,",
            "                 object_type: str,",
            "                 old_filename: Optional[str] = None) -> None:",
            "        ''' Setup upload by creating a subdirectory of the storage directory",
            "        of name object_type. old_filename is the name of the file in the url",
            "        field last time'''",
            "",
            "        self.storage_path = None",
            "        self.filename = None",
            "        self.filepath = None",
            "        path = get_storage_path()",
            "        if not path:",
            "            return",
            "        self.storage_path = os.path.join(path, 'storage',",
            "                                         'uploads', object_type)",
            "        # check if the storage directory is already created by",
            "        # the user or third-party",
            "        if os.path.isdir(self.storage_path):",
            "            pass",
            "        else:",
            "            try:",
            "                os.makedirs(self.storage_path)",
            "            except OSError as e:",
            "                # errno 17 is file already exists",
            "                if e.errno != 17:",
            "                    raise",
            "        self.object_type = object_type",
            "        self.old_filename = old_filename",
            "        if old_filename:",
            "            self.old_filepath = os.path.join(self.storage_path, old_filename)",
            "",
            "    def update_data_dict(self, data_dict: dict[str, Any], url_field: str,",
            "                         file_field: str, clear_field: str) -> None:",
            "        ''' Manipulate data from the data_dict.  url_field is the name of the",
            "        field where the upload is going to be. file_field is name of the key",
            "        where the FieldStorage is kept (i.e the field where the file data",
            "        actually is). clear_field is the name of a boolean field which",
            "        requests the upload to be deleted.  This needs to be called before",
            "        it reaches any validators'''",
            "",
            "        self.url = data_dict.get(url_field, '')",
            "        self.clear = data_dict.pop(clear_field, None)",
            "        self.file_field = file_field",
            "        self.upload_field_storage = data_dict.pop(file_field, None)",
            "",
            "        if not self.storage_path:",
            "            return",
            "",
            "        if isinstance(self.upload_field_storage, ALLOWED_UPLOAD_TYPES):",
            "            if self.upload_field_storage.filename:",
            "                self.filename = self.upload_field_storage.filename",
            "                self.filename = str(datetime.datetime.utcnow()) + self.filename",
            "                self.filename = munge.munge_filename_legacy(self.filename)",
            "                self.filepath = os.path.join(self.storage_path, self.filename)",
            "                data_dict[url_field] = self.filename",
            "                self.upload_file = _get_underlying_file(",
            "                    self.upload_field_storage)",
            "                self.tmp_filepath = self.filepath + '~'",
            "        # keep the file if there has been no change",
            "        elif self.old_filename and not self.old_filename.startswith('http'):",
            "            if not self.clear:",
            "                data_dict[url_field] = self.old_filename",
            "            if self.clear and self.url == self.old_filename:",
            "                data_dict[url_field] = ''",
            "",
            "    def upload(self, max_size: int = 2) -> None:",
            "        ''' Actually upload the file.",
            "        This should happen just before a commit but after the data has",
            "        been validated and flushed to the db. This is so we do not store",
            "        anything unless the request is actually good.",
            "        max_size is size in MB maximum of the file'''",
            "",
            "        self.verify_type()",
            "",
            "        if self.filename:",
            "            assert self.upload_file and self.filepath",
            "",
            "            with open(self.tmp_filepath, 'wb+') as output_file:",
            "                try:",
            "                    _copy_file(self.upload_file, output_file, max_size)",
            "                except logic.ValidationError:",
            "                    os.remove(self.tmp_filepath)",
            "                    raise",
            "                finally:",
            "                    self.upload_file.close()",
            "            os.rename(self.tmp_filepath, self.filepath)",
            "            self.clear = True",
            "",
            "        if (self.clear and self.old_filename",
            "                and not self.old_filename.startswith('http')",
            "                and self.old_filepath):",
            "            try:",
            "                os.remove(self.old_filepath)",
            "            except OSError:",
            "                pass",
            "",
            "    def verify_type(self):",
            "        if not self.filename or not self.upload_file:",
            "            return",
            "",
            "        mimetypes = config.get(",
            "            f\"ckan.upload.{self.object_type}.mimetypes\")",
            "        types = config.get(f\"ckan.upload.{self.object_type}.types\")",
            "        if not mimetypes and not types:",
            "            return",
            "",
            "        # 2KB required for detecting xlsx mimetype",
            "        actual = magic.from_buffer(self.upload_file.read(2048), mime=True)",
            "        self.upload_file.seek(0, os.SEEK_SET)",
            "        err: ErrorDict = {",
            "            self.file_field: [f\"Unsupported upload type: {actual}\"]",
            "        }",
            "",
            "        if mimetypes and actual not in mimetypes:",
            "            raise logic.ValidationError(err)",
            "",
            "        type_ = actual.split(\"/\")[0]",
            "        if types and type_ not in types:",
            "            raise logic.ValidationError(err)",
            "",
            "",
            "class ResourceUpload(object):",
            "    mimetype: Optional[str]",
            "",
            "    def __init__(self, resource: dict[str, Any]) -> None:",
            "        path = get_storage_path()",
            "        config_mimetype_guess = config.get('ckan.mimetype_guess')",
            "",
            "        if not path:",
            "            self.storage_path = None",
            "            return",
            "        self.storage_path = os.path.join(path, 'resources')",
            "        try:",
            "            os.makedirs(self.storage_path)",
            "        except OSError as e:",
            "            # errno 17 is file already exists",
            "            if e.errno != 17:",
            "                raise",
            "        self.filename = None",
            "        self.mimetype = None",
            "",
            "        url = resource.get('url')",
            "",
            "        upload_field_storage = resource.pop('upload', None)",
            "        self.clear = resource.pop('clear_upload', None)",
            "",
            "        if url and config_mimetype_guess == 'file_ext' and urlparse(url).path:",
            "            self.mimetype = mimetypes.guess_type(url)[0]",
            "",
            "        if bool(upload_field_storage) and \\",
            "                isinstance(upload_field_storage, ALLOWED_UPLOAD_TYPES):",
            "            self.filesize = 0  # bytes",
            "",
            "            self.filename = upload_field_storage.filename",
            "            assert self.filename is not None",
            "            self.filename = munge.munge_filename(self.filename)",
            "            resource['url'] = self.filename",
            "            resource['url_type'] = 'upload'",
            "            resource['last_modified'] = datetime.datetime.utcnow()",
            "            self.upload_file = _get_underlying_file(upload_field_storage)",
            "            assert self.upload_file is not None",
            "            self.upload_file.seek(0, os.SEEK_END)",
            "            self.filesize = self.upload_file.tell()",
            "            # go back to the beginning of the file buffer",
            "            self.upload_file.seek(0, os.SEEK_SET)",
            "",
            "            # check if the mimetype failed from guessing with the url",
            "            if not self.mimetype and config_mimetype_guess == 'file_ext':",
            "                self.mimetype = mimetypes.guess_type(self.filename)[0]",
            "",
            "            if not self.mimetype and config_mimetype_guess == 'file_contents':",
            "                try:",
            "                    self.mimetype = magic.from_buffer(self.upload_file.read(),",
            "                                                      mime=True)",
            "                    self.upload_file.seek(0, os.SEEK_SET)",
            "                except IOError:",
            "                    # Not that important if call above fails",
            "                    self.mimetype = None",
            "",
            "        elif self.clear:",
            "            resource['url_type'] = ''",
            "",
            "    def get_directory(self, id: str) -> str:",
            "        if self.storage_path is None:",
            "            raise TypeError(\"storage_path is not defined\")",
            "",
            "        real_storage = os.path.realpath(self.storage_path)",
            "        directory = os.path.join(real_storage, id[0:3], id[3:6])",
            "        if directory != os.path.realpath(directory):",
            "            raise logic.ValidationError({",
            "                'upload': ['Invalid storage directory']",
            "            })",
            "        return directory",
            "",
            "    def get_path(self, id: str) -> str:",
            "        directory = self.get_directory(id)",
            "        filepath = os.path.join(directory, id[6:])",
            "",
            "        if filepath != os.path.realpath(filepath):",
            "            raise logic.ValidationError({'upload': ['Invalid storage path']})",
            "",
            "        return filepath",
            "",
            "    def upload(self, id: str, max_size: int = 10) -> None:",
            "        '''Actually upload the file.",
            "",
            "        :returns: ``'file uploaded'`` if a new file was successfully uploaded",
            "            (whether it overwrote a previously uploaded file or not),",
            "            ``'file deleted'`` if an existing uploaded file was deleted,",
            "            or ``None`` if nothing changed",
            "        :rtype: ``string`` or ``None``",
            "",
            "        '''",
            "        if not self.storage_path:",
            "            return",
            "",
            "        # Get directory and filepath on the system",
            "        # where the file for this resource will be stored",
            "        directory = self.get_directory(id)",
            "        filepath = self.get_path(id)",
            "",
            "        # If a filename has been provided (a file is being uploaded)",
            "        # we write it to the filepath (and overwrite it if it already",
            "        # exists). This way the uploaded file will always be stored",
            "        # in the same location",
            "        if self.filename:",
            "            try:",
            "                os.makedirs(directory)",
            "            except OSError as e:",
            "                # errno 17 is file already exists",
            "                if e.errno != 17:",
            "                    raise",
            "            tmp_filepath = filepath + '~'",
            "            with open(tmp_filepath, 'wb+') as output_file:",
            "                assert self.upload_file",
            "                try:",
            "                    _copy_file(self.upload_file, output_file, max_size)",
            "                except logic.ValidationError:",
            "                    os.remove(tmp_filepath)",
            "                    raise",
            "                finally:",
            "                    self.upload_file.close()",
            "            os.rename(tmp_filepath, filepath)",
            "            return",
            "",
            "        # The resource form only sets self.clear (via the input clear_upload)",
            "        # to True when an uploaded file is not replaced by another uploaded",
            "        # file, only if it is replaced by a link to file.",
            "        # If the uploaded file is replaced by a link, we should remove the",
            "        # previously uploaded file to clean up the file system.",
            "        if self.clear:",
            "            try:",
            "                os.remove(filepath)",
            "            except OSError:",
            "                pass"
        ],
        "afterPatchFile": [
            "# encoding: utf-8",
            "from __future__ import annotations",
            "",
            "import os",
            "import cgi",
            "import datetime",
            "import logging",
            "import magic",
            "import mimetypes",
            "from pathlib import Path",
            "from typing import Any, IO, Optional, Union",
            "from urllib.parse import urlparse",
            "",
            "from werkzeug.datastructures import FileStorage as FlaskFileStorage",
            "",
            "import ckan.lib.munge as munge",
            "import ckan.logic as logic",
            "import ckan.plugins as plugins",
            "from ckan.common import config",
            "from ckan.types import ErrorDict, PUploader, PResourceUploader",
            "",
            "ALLOWED_UPLOAD_TYPES = (cgi.FieldStorage, FlaskFileStorage)",
            "MB = 1 << 20",
            "",
            "log = logging.getLogger(__name__)",
            "",
            "",
            "def _copy_file(input_file: IO[bytes],",
            "               output_file: IO[bytes], max_size: int) -> None:",
            "    input_file.seek(0)",
            "    current_size = 0",
            "    while True:",
            "        current_size = current_size + 1",
            "        # MB chunks",
            "        data = input_file.read(MB)",
            "",
            "        if not data:",
            "            break",
            "        output_file.write(data)",
            "        if current_size > max_size:",
            "            raise logic.ValidationError({'upload': ['File upload too large']})",
            "",
            "",
            "def _get_underlying_file(wrapper: Union[FlaskFileStorage, cgi.FieldStorage]):",
            "    if isinstance(wrapper, FlaskFileStorage):",
            "        return wrapper.stream",
            "    return wrapper.file",
            "",
            "",
            "def get_uploader(upload_to: str,",
            "                 old_filename: Optional[str] = None) -> PUploader:",
            "    '''Query IUploader plugins and return an uploader instance for general",
            "    files.'''",
            "    upload = None",
            "    for plugin in plugins.PluginImplementations(plugins.IUploader):",
            "        upload = plugin.get_uploader(upload_to, old_filename)",
            "        if upload:",
            "            break",
            "",
            "    # default uploader",
            "    if upload is None:",
            "        upload = Upload(upload_to, old_filename)",
            "",
            "    return upload",
            "",
            "",
            "def get_resource_uploader(data_dict: dict[str, Any]) -> PResourceUploader:",
            "    '''Query IUploader plugins and return a resource uploader instance.'''",
            "    upload = None",
            "    for plugin in plugins.PluginImplementations(plugins.IUploader):",
            "        upload = plugin.get_resource_uploader(data_dict)",
            "        if upload:",
            "            break",
            "",
            "    # default uploader",
            "    if upload is None:",
            "        upload = ResourceUpload(data_dict)",
            "",
            "    return upload",
            "",
            "",
            "def get_storage_path() -> str:",
            "    '''Function to get the storage path from config file.'''",
            "    storage_path = config.get('ckan.storage_path')",
            "    if not storage_path:",
            "        log.critical('''Please specify a ckan.storage_path in your config",
            "                        for your uploads''')",
            "",
            "    return storage_path",
            "",
            "",
            "def get_max_image_size() -> int:",
            "    return config.get('ckan.max_image_size')",
            "",
            "",
            "def get_max_resource_size() -> int:",
            "    return config.get('ckan.max_resource_size')",
            "",
            "",
            "class Upload(object):",
            "    storage_path: Optional[str]",
            "    filename: Optional[str]",
            "    filepath: Optional[str]",
            "    object_type: Optional[str]",
            "    old_filename: Optional[str]",
            "    old_filepath: Optional[str]",
            "    upload_file: Optional[IO[bytes]]",
            "",
            "    def __init__(self,",
            "                 object_type: str,",
            "                 old_filename: Optional[str] = None) -> None:",
            "        ''' Setup upload by creating a subdirectory of the storage directory",
            "        of name object_type. old_filename is the name of the file in the url",
            "        field last time'''",
            "",
            "        self.storage_path = None",
            "        self.filename = None",
            "        self.filepath = None",
            "        path = get_storage_path()",
            "        if not path:",
            "            return",
            "        self.storage_path = os.path.join(path, 'storage',",
            "                                         'uploads', object_type)",
            "        # check if the storage directory is already created by",
            "        # the user or third-party",
            "        if os.path.isdir(self.storage_path):",
            "            pass",
            "        else:",
            "            try:",
            "                os.makedirs(self.storage_path)",
            "            except OSError as e:",
            "                # errno 17 is file already exists",
            "                if e.errno != 17:",
            "                    raise",
            "        self.object_type = object_type",
            "        self.old_filename = old_filename",
            "        if old_filename:",
            "            self.old_filepath = os.path.join(self.storage_path, old_filename)",
            "",
            "    def update_data_dict(self, data_dict: dict[str, Any], url_field: str,",
            "                         file_field: str, clear_field: str) -> None:",
            "        ''' Manipulate data from the data_dict.  url_field is the name of the",
            "        field where the upload is going to be. file_field is name of the key",
            "        where the FieldStorage is kept (i.e the field where the file data",
            "        actually is). clear_field is the name of a boolean field which",
            "        requests the upload to be deleted.  This needs to be called before",
            "        it reaches any validators'''",
            "",
            "        self.url = data_dict.get(url_field, '')",
            "        self.clear = data_dict.pop(clear_field, None)",
            "        self.file_field = file_field",
            "        self.upload_field_storage = data_dict.pop(file_field, None)",
            "",
            "        if not self.storage_path:",
            "            return",
            "",
            "        if isinstance(self.upload_field_storage, ALLOWED_UPLOAD_TYPES):",
            "            if self.upload_field_storage.filename:",
            "                self.filename = self.upload_field_storage.filename",
            "                self.filename = str(datetime.datetime.utcnow()) + self.filename",
            "                self.filename = munge.munge_filename_legacy(self.filename)",
            "                self.filepath = os.path.join(self.storage_path, self.filename)",
            "                self.upload_file = _get_underlying_file(",
            "                    self.upload_field_storage)",
            "                self.tmp_filepath = self.filepath + '~'",
            "",
            "                self.verify_type()",
            "",
            "                data_dict[url_field] = self.filename",
            "",
            "        # keep the file if there has been no change",
            "        elif self.old_filename and not self.old_filename.startswith('http'):",
            "            if not self.clear:",
            "                data_dict[url_field] = self.old_filename",
            "            if self.clear and self.url == self.old_filename:",
            "                data_dict[url_field] = ''",
            "",
            "    def upload(self, max_size: int = 2) -> None:",
            "        ''' Actually upload the file.",
            "        This should happen just before a commit but after the data has",
            "        been validated and flushed to the db. This is so we do not store",
            "        anything unless the request is actually good.",
            "        max_size is size in MB maximum of the file'''",
            "",
            "",
            "        if self.filename:",
            "            assert self.upload_file and self.filepath",
            "",
            "            with open(self.tmp_filepath, 'wb+') as output_file:",
            "                try:",
            "                    _copy_file(self.upload_file, output_file, max_size)",
            "                except logic.ValidationError:",
            "                    os.remove(self.tmp_filepath)",
            "                    raise",
            "                finally:",
            "                    self.upload_file.close()",
            "            os.rename(self.tmp_filepath, self.filepath)",
            "            self.clear = True",
            "",
            "        if (self.clear and self.old_filename",
            "                and not self.old_filename.startswith('http')",
            "                and self.old_filepath):",
            "            try:",
            "                os.remove(self.old_filepath)",
            "            except OSError:",
            "                pass",
            "",
            "    def verify_type(self):",
            "",
            "        if not self.upload_file:",
            "            return",
            "",
            "        allowed_mimetypes = config.get(",
            "            f\"ckan.upload.{self.object_type}.mimetypes\")",
            "        allowed_types = config.get(f\"ckan.upload.{self.object_type}.types\")",
            "        if not allowed_mimetypes and not allowed_types:",
            "            raise logic.ValidationError(",
            "                {",
            "                    self.file_field: [f\"No uploads allowed for object type {self.object_type}\"]",
            "                }",
            "            )",
            "",
            "        # Check that the declared types in the request are supported",
            "        declared_mimetype_from_filename = mimetypes.guess_type(",
            "            self.upload_field_storage.filename",
            "        )[0]",
            "        declared_content_type = self.upload_field_storage.content_type",
            "        for declared_mimetype in (",
            "            declared_mimetype_from_filename,",
            "            declared_content_type,",
            "        ):",
            "            if (",
            "                declared_mimetype",
            "                and allowed_mimetypes",
            "                and allowed_mimetypes[0] != \"*\"",
            "                and declared_mimetype not in allowed_mimetypes",
            "            ):",
            "                raise logic.ValidationError(",
            "                    {",
            "                        self.file_field: [",
            "                            f\"Unsupported upload type: {declared_mimetype}\"",
            "                        ]",
            "                    }",
            "                )",
            "",
            "        # Check that the actual type guessed from the contents is supported",
            "        # (2KB required for detecting xlsx mimetype)",
            "        content = self.upload_file.read(2048)",
            "        guessed_mimetype = magic.from_buffer(content, mime=True)",
            "",
            "        self.upload_file.seek(0, os.SEEK_SET)",
            "",
            "        err: ErrorDict = {",
            "            self.file_field: [f\"Unsupported upload type: {guessed_mimetype}\"]",
            "        }",
            "",
            "        if allowed_mimetypes and allowed_mimetypes[0] != \"*\" and guessed_mimetype not in allowed_mimetypes:",
            "            raise logic.ValidationError(err)",
            "",
            "        type_ = guessed_mimetype.split(\"/\")[0]",
            "        if allowed_types and allowed_types[0] != \"*\" and type_ not in allowed_types:",
            "            raise logic.ValidationError(err)",
            "",
            "        preferred_extension = mimetypes.guess_extension(guessed_mimetype)",
            "        if preferred_extension:",
            "            self.filename = str(Path(self.filename).with_suffix(preferred_extension))",
            "            self.filepath = str(Path(self.filepath).with_suffix(preferred_extension))",
            "",
            "",
            "class ResourceUpload(object):",
            "    mimetype: Optional[str]",
            "",
            "    def __init__(self, resource: dict[str, Any]) -> None:",
            "        path = get_storage_path()",
            "        config_mimetype_guess = config.get('ckan.mimetype_guess')",
            "",
            "        if not path:",
            "            self.storage_path = None",
            "            return",
            "        self.storage_path = os.path.join(path, 'resources')",
            "        try:",
            "            os.makedirs(self.storage_path)",
            "        except OSError as e:",
            "            # errno 17 is file already exists",
            "            if e.errno != 17:",
            "                raise",
            "        self.filename = None",
            "        self.mimetype = None",
            "",
            "        url = resource.get('url')",
            "",
            "        upload_field_storage = resource.pop('upload', None)",
            "        self.clear = resource.pop('clear_upload', None)",
            "",
            "        if url and config_mimetype_guess == 'file_ext' and urlparse(url).path:",
            "            self.mimetype = mimetypes.guess_type(url)[0]",
            "",
            "        if bool(upload_field_storage) and \\",
            "                isinstance(upload_field_storage, ALLOWED_UPLOAD_TYPES):",
            "            self.filesize = 0  # bytes",
            "",
            "            self.filename = upload_field_storage.filename",
            "            assert self.filename is not None",
            "            self.filename = munge.munge_filename(self.filename)",
            "            resource['url'] = self.filename",
            "            resource['url_type'] = 'upload'",
            "            resource['last_modified'] = datetime.datetime.utcnow()",
            "            self.upload_file = _get_underlying_file(upload_field_storage)",
            "            assert self.upload_file is not None",
            "            self.upload_file.seek(0, os.SEEK_END)",
            "            self.filesize = self.upload_file.tell()",
            "            # go back to the beginning of the file buffer",
            "            self.upload_file.seek(0, os.SEEK_SET)",
            "",
            "            # check if the mimetype failed from guessing with the url",
            "            if not self.mimetype and config_mimetype_guess == 'file_ext':",
            "                self.mimetype = mimetypes.guess_type(self.filename)[0]",
            "",
            "            if not self.mimetype and config_mimetype_guess == 'file_contents':",
            "                try:",
            "                    self.mimetype = magic.from_buffer(self.upload_file.read(),",
            "                                                      mime=True)",
            "                    self.upload_file.seek(0, os.SEEK_SET)",
            "                except IOError:",
            "                    # Not that important if call above fails",
            "                    self.mimetype = None",
            "",
            "        elif self.clear:",
            "            resource['url_type'] = ''",
            "",
            "    def get_directory(self, id: str) -> str:",
            "        if self.storage_path is None:",
            "            raise TypeError(\"storage_path is not defined\")",
            "",
            "        real_storage = os.path.realpath(self.storage_path)",
            "        directory = os.path.join(real_storage, id[0:3], id[3:6])",
            "        if directory != os.path.realpath(directory):",
            "            raise logic.ValidationError({",
            "                'upload': ['Invalid storage directory']",
            "            })",
            "        return directory",
            "",
            "    def get_path(self, id: str) -> str:",
            "        directory = self.get_directory(id)",
            "        filepath = os.path.join(directory, id[6:])",
            "",
            "        if filepath != os.path.realpath(filepath):",
            "            raise logic.ValidationError({'upload': ['Invalid storage path']})",
            "",
            "        return filepath",
            "",
            "    def upload(self, id: str, max_size: int = 10) -> None:",
            "        '''Actually upload the file.",
            "",
            "        :returns: ``'file uploaded'`` if a new file was successfully uploaded",
            "            (whether it overwrote a previously uploaded file or not),",
            "            ``'file deleted'`` if an existing uploaded file was deleted,",
            "            or ``None`` if nothing changed",
            "        :rtype: ``string`` or ``None``",
            "",
            "        '''",
            "        if not self.storage_path:",
            "            return",
            "",
            "        # Get directory and filepath on the system",
            "        # where the file for this resource will be stored",
            "        directory = self.get_directory(id)",
            "        filepath = self.get_path(id)",
            "",
            "        # If a filename has been provided (a file is being uploaded)",
            "        # we write it to the filepath (and overwrite it if it already",
            "        # exists). This way the uploaded file will always be stored",
            "        # in the same location",
            "        if self.filename:",
            "            try:",
            "                os.makedirs(directory)",
            "            except OSError as e:",
            "                # errno 17 is file already exists",
            "                if e.errno != 17:",
            "                    raise",
            "            tmp_filepath = filepath + '~'",
            "            with open(tmp_filepath, 'wb+') as output_file:",
            "                assert self.upload_file",
            "                try:",
            "                    _copy_file(self.upload_file, output_file, max_size)",
            "                except logic.ValidationError:",
            "                    os.remove(tmp_filepath)",
            "                    raise",
            "                finally:",
            "                    self.upload_file.close()",
            "            os.rename(tmp_filepath, filepath)",
            "            return",
            "",
            "        # The resource form only sets self.clear (via the input clear_upload)",
            "        # to True when an uploaded file is not replaced by another uploaded",
            "        # file, only if it is replaced by a link to file.",
            "        # If the uploaded file is replaced by a link, we should remove the",
            "        # previously uploaded file to clean up the file system.",
            "        if self.clear:",
            "            try:",
            "                os.remove(filepath)",
            "            except OSError:",
            "                pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "162": [
                "Upload",
                "update_data_dict"
            ],
            "180": [
                "Upload",
                "upload"
            ],
            "205": [
                "Upload",
                "verify_type"
            ],
            "208": [
                "Upload",
                "verify_type"
            ],
            "210": [
                "Upload",
                "verify_type"
            ],
            "211": [
                "Upload",
                "verify_type"
            ],
            "212": [
                "Upload",
                "verify_type"
            ],
            "214": [
                "Upload",
                "verify_type"
            ],
            "215": [
                "Upload",
                "verify_type"
            ],
            "218": [
                "Upload",
                "verify_type"
            ],
            "221": [
                "Upload",
                "verify_type"
            ],
            "224": [
                "Upload",
                "verify_type"
            ],
            "225": [
                "Upload",
                "verify_type"
            ]
        },
        "addLocation": []
    },
    "ckan/tests/cli/test_clean.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": "         result = cli.invoke(ckan, [\"clean\", \"users\"])"
            },
            "1": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": "         assert \"No users were found with invalid images.\" in result.output"
            },
            "2": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @pytest.mark.ckan_config(\"ckan.upload.user.mimetypes\", \"\")"
            },
            "4": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"\")"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+    @pytest.mark.ckan_config(\"ckan.upload.user.mimetypes\", \"*\")"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"*\")"
            },
            "7": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": "     def test_confirm_dialog_if_no_force("
            },
            "8": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": "         self, cli, monkeypatch, create_with_upload, faker, ckan_config"
            },
            "9": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": "     ):"
            },
            "10": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "         users = call_action(\"user_list\")"
            },
            "11": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "         assert len(users) == 2"
            },
            "12": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @pytest.mark.ckan_config(\"ckan.upload.user.mimetypes\", \"\")"
            },
            "14": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"\")"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+    @pytest.mark.ckan_config(\"ckan.upload.user.mimetypes\", \"*\")"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"*\")"
            },
            "17": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "     def test_correct_users_are_deleted("
            },
            "18": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "         self, cli, monkeypatch, create_with_upload, faker, ckan_config"
            },
            "19": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "     ):"
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "import pytest",
            "",
            "from ckan.cli.cli import ckan",
            "from ckan.tests.helpers import call_action",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\")",
            "class TestUserClean:",
            "    def test_output_if_there_are_not_invalid_users(self, cli):",
            "        result = cli.invoke(ckan, [\"clean\", \"users\"])",
            "        assert \"No users were found with invalid images.\" in result.output",
            "",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.mimetypes\", \"\")",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"\")",
            "    def test_confirm_dialog_if_no_force(",
            "        self, cli, monkeypatch, create_with_upload, faker, ckan_config",
            "    ):",
            "        fake_user = {",
            "            \"name\": \"fake-user\",",
            "            \"email\": \"fake-user@example.com\",",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        fake_user = create_with_upload(",
            "            \"<html><body>hello world</body></html>\", \"index.html\", **fake_user",
            "        )",
            "",
            "        user = {",
            "            \"name\": \"valid-user\",",
            "            \"email\": \"valid-user@example\",",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        user = create_with_upload(faker.image(), \"image.png\", **user)",
            "",
            "        monkeypatch.setitem(",
            "            ckan_config, \"ckan.upload.user.mimetypes\", \"image/png\"",
            "        )",
            "        result = cli.invoke(ckan, [\"clean\", \"users\"])",
            "",
            "        assert (",
            "            f\"User {fake_user['name']} has an invalid image:\"",
            "            f\" {fake_user['image_url']}\"",
            "            in result.output",
            "        )",
            "        assert (",
            "            f\"User {user['name']} has an invalid image: {user['image_url']}\"",
            "            not in result.output",
            "        )",
            "        assert \"Permanently delete users and their images?\" in result.output",
            "        users = call_action(\"user_list\")",
            "        assert len(users) == 2",
            "",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.mimetypes\", \"\")",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"\")",
            "    def test_correct_users_are_deleted(",
            "        self, cli, monkeypatch, create_with_upload, faker, ckan_config",
            "    ):",
            "        fake_user = {",
            "            \"name\": \"fake-user\",",
            "            \"email\": \"fake-user@example.com\",",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        fake_user = create_with_upload(",
            "            \"<html><body>hello world</body></html>\", \"index.html\", **fake_user",
            "        )",
            "",
            "        user = {",
            "            \"name\": \"valid-user\",",
            "            \"email\": \"valid-user@example\",",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        user = create_with_upload(faker.image(), \"image.png\", **user)",
            "",
            "        monkeypatch.setitem(",
            "            ckan_config, \"ckan.upload.user.mimetypes\", \"image/png\"",
            "        )",
            "        result = cli.invoke(ckan, [\"clean\", \"users\", \"--force\"])",
            "        users = call_action(\"user_list\")",
            "        assert f\"Deleted user: {fake_user['name']}\" in result.output",
            "        assert len(users) == 1",
            "        assert users[0][\"name\"] == \"valid-user\""
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "import pytest",
            "",
            "from ckan.cli.cli import ckan",
            "from ckan.tests.helpers import call_action",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\")",
            "class TestUserClean:",
            "    def test_output_if_there_are_not_invalid_users(self, cli):",
            "        result = cli.invoke(ckan, [\"clean\", \"users\"])",
            "        assert \"No users were found with invalid images.\" in result.output",
            "",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.mimetypes\", \"*\")",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"*\")",
            "    def test_confirm_dialog_if_no_force(",
            "        self, cli, monkeypatch, create_with_upload, faker, ckan_config",
            "    ):",
            "        fake_user = {",
            "            \"name\": \"fake-user\",",
            "            \"email\": \"fake-user@example.com\",",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        fake_user = create_with_upload(",
            "            \"<html><body>hello world</body></html>\", \"index.html\", **fake_user",
            "        )",
            "",
            "        user = {",
            "            \"name\": \"valid-user\",",
            "            \"email\": \"valid-user@example\",",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        user = create_with_upload(faker.image(), \"image.png\", **user)",
            "",
            "        monkeypatch.setitem(",
            "            ckan_config, \"ckan.upload.user.mimetypes\", \"image/png\"",
            "        )",
            "        result = cli.invoke(ckan, [\"clean\", \"users\"])",
            "",
            "        assert (",
            "            f\"User {fake_user['name']} has an invalid image:\"",
            "            f\" {fake_user['image_url']}\"",
            "            in result.output",
            "        )",
            "        assert (",
            "            f\"User {user['name']} has an invalid image: {user['image_url']}\"",
            "            not in result.output",
            "        )",
            "        assert \"Permanently delete users and their images?\" in result.output",
            "        users = call_action(\"user_list\")",
            "        assert len(users) == 2",
            "",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.mimetypes\", \"*\")",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"*\")",
            "    def test_correct_users_are_deleted(",
            "        self, cli, monkeypatch, create_with_upload, faker, ckan_config",
            "    ):",
            "        fake_user = {",
            "            \"name\": \"fake-user\",",
            "            \"email\": \"fake-user@example.com\",",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        fake_user = create_with_upload(",
            "            \"<html><body>hello world</body></html>\", \"index.html\", **fake_user",
            "        )",
            "",
            "        user = {",
            "            \"name\": \"valid-user\",",
            "            \"email\": \"valid-user@example\",",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        user = create_with_upload(faker.image(), \"image.png\", **user)",
            "",
            "        monkeypatch.setitem(",
            "            ckan_config, \"ckan.upload.user.mimetypes\", \"image/png\"",
            "        )",
            "        result = cli.invoke(ckan, [\"clean\", \"users\", \"--force\"])",
            "        users = call_action(\"user_list\")",
            "        assert f\"Deleted user: {fake_user['name']}\" in result.output",
            "        assert len(users) == 1",
            "        assert users[0][\"name\"] == \"valid-user\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "14": [
                "TestUserClean"
            ],
            "15": [
                "TestUserClean"
            ],
            "57": [
                "TestUserClean"
            ],
            "58": [
                "TestUserClean"
            ]
        },
        "addLocation": []
    },
    "ckan/tests/lib/test_uploader.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "                  u'upload': FileStorage("
            },
            "1": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "                      BytesIO(faker.image()),"
            },
            "2": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "                      filename=u'logo.png',"
            },
            "3": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                     content_type=u'PNG'"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+                     content_type=u'image/png'"
            },
            "5": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "                  ),"
            },
            "6": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "                  u'name': u'test-group-upload'}"
            },
            "7": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "         group_upload = Upload(u'group')"
            }
        },
        "frontPatchFile": [
            "# encoding: utf-8",
            "",
            "import pytest",
            "from io import BytesIO",
            "from werkzeug.datastructures import FileStorage",
            "",
            "from ckan.logic import ValidationError",
            "from ckan.lib.uploader import ResourceUpload, Upload",
            "",
            "",
            "class TestInitResourceUpload(object):",
            "    def test_resource_without_upload_with_old_werkzeug(",
            "            self, ckan_config, monkeypatch, tmpdir):",
            "        monkeypatch.setitem(ckan_config, u'ckan.storage_path', str(tmpdir))",
            "",
            "        # this test data is based on real observation using a browser",
            "        # and werkzeug 0.14.1",
            "        res = {u'clear_upload': u'true',",
            "               u'format': u'CSV',",
            "               u'url': u'https://example.com/data.csv',",
            "               u'description': u'',",
            "               u'upload': u'',",
            "               u'package_id': u'dataset1',",
            "               u'id': u'8a3a874e-5ee1-4e43-bdaf-e2569cf72344',",
            "               u'name': u'data.csv'}",
            "        res_upload = ResourceUpload(res)",
            "",
            "        assert res_upload.filename is None",
            "",
            "    def test_resource_without_upload(",
            "            self, ckan_config, monkeypatch, tmpdir):",
            "        monkeypatch.setitem(ckan_config, u'ckan.storage_path', str(tmpdir))",
            "        # this test data is based on real observation using a browser",
            "        res = {u'clear_upload': u'true',",
            "               u'format': u'PNG',",
            "               u'url': u'https://example.com/data.csv',",
            "               u'description': u'',",
            "               u'upload': FileStorage(filename=u''),",
            "               u'package_id': u'dataset1',",
            "               u'id': u'8a3a874e-5ee1-4e43-bdaf-e2569cf72344',",
            "               u'name': u'data.csv'}",
            "        res_upload = ResourceUpload(res)",
            "",
            "        assert res_upload.filename is None",
            "",
            "    def test_resource_with_upload(",
            "            self, ckan_config, monkeypatch, tmpdir):",
            "        monkeypatch.setitem(ckan_config, u'ckan.storage_path', str(tmpdir))",
            "        # this test data is based on real observation using a browser",
            "        res = {u'clear_upload': u'',",
            "               u'format': u'PNG',",
            "               u'url': u'https://example.com/data.csv',",
            "               u'description': u'',",
            "               u'upload': FileStorage(filename=u'data.csv', content_type=u'CSV'),",
            "               u'package_id': u'dataset1',",
            "               u'id': u'8a3a874e-5ee1-4e43-bdaf-e2569cf72344',",
            "               u'name': u'data.csv'}",
            "        res_upload = ResourceUpload(res)",
            "",
            "        assert res_upload.filesize == 0",
            "        assert res_upload.filename == u'data.csv'",
            "",
            "    def test_resource_with_dodgy_id(",
            "            self, ckan_config, monkeypatch, tmpdir):",
            "        monkeypatch.setitem(ckan_config, u'ckan.storage_path', str(tmpdir))",
            "",
            "        resource_id = u'aaabbb/../../../../nope.txt'",
            "        res = {u'clear_upload': u'',",
            "               u'format': u'PNG',",
            "               u'url': u'https://example.com/data.csv',",
            "               u'description': u'',",
            "               u'upload': FileStorage(filename=u'data.csv', content_type=u'CSV'),",
            "               u'package_id': u'dataset1',",
            "               u'id': resource_id,",
            "               u'name': u'data.csv'}",
            "        res_upload = ResourceUpload(res)",
            "",
            "        with pytest.raises(ValidationError):",
            "            res_upload.upload(resource_id)",
            "",
            "",
            "class TestUpload(object):",
            "    def test_group_upload(self, monkeypatch, tmpdir, make_app, ckan_config, faker):",
            "        \"\"\"Reproduce group's logo upload and check that file available through",
            "        public url.",
            "",
            "        \"\"\"",
            "        monkeypatch.setitem(ckan_config, u'ckan.storage_path', str(tmpdir))",
            "        group = {u'clear_upload': u'',",
            "                 u'upload': FileStorage(",
            "                     BytesIO(faker.image()),",
            "                     filename=u'logo.png',",
            "                     content_type=u'PNG'",
            "                 ),",
            "                 u'name': u'test-group-upload'}",
            "        group_upload = Upload(u'group')",
            "        group_upload.update_data_dict(group, u'url', u'upload', u'clear_upload')",
            "        group_upload.upload()",
            "        uploads_dir = tmpdir / u'storage' / u'uploads' / u'group'",
            "        logo = uploads_dir.listdir()[0]",
            "        assert logo.basename == group[u'url']",
            "        app = make_app()",
            "        resp = app.get(u'/uploads/group/' + group[u'url'])",
            "        assert resp.status_code == 200",
            "        # PNG signature",
            "        assert resp.data.hex()[:16].upper() == '89504E470D0A1A0A'"
        ],
        "afterPatchFile": [
            "# encoding: utf-8",
            "",
            "import pytest",
            "from io import BytesIO",
            "from werkzeug.datastructures import FileStorage",
            "",
            "from ckan.logic import ValidationError",
            "from ckan.lib.uploader import ResourceUpload, Upload",
            "",
            "",
            "class TestInitResourceUpload(object):",
            "    def test_resource_without_upload_with_old_werkzeug(",
            "            self, ckan_config, monkeypatch, tmpdir):",
            "        monkeypatch.setitem(ckan_config, u'ckan.storage_path', str(tmpdir))",
            "",
            "        # this test data is based on real observation using a browser",
            "        # and werkzeug 0.14.1",
            "        res = {u'clear_upload': u'true',",
            "               u'format': u'CSV',",
            "               u'url': u'https://example.com/data.csv',",
            "               u'description': u'',",
            "               u'upload': u'',",
            "               u'package_id': u'dataset1',",
            "               u'id': u'8a3a874e-5ee1-4e43-bdaf-e2569cf72344',",
            "               u'name': u'data.csv'}",
            "        res_upload = ResourceUpload(res)",
            "",
            "        assert res_upload.filename is None",
            "",
            "    def test_resource_without_upload(",
            "            self, ckan_config, monkeypatch, tmpdir):",
            "        monkeypatch.setitem(ckan_config, u'ckan.storage_path', str(tmpdir))",
            "        # this test data is based on real observation using a browser",
            "        res = {u'clear_upload': u'true',",
            "               u'format': u'PNG',",
            "               u'url': u'https://example.com/data.csv',",
            "               u'description': u'',",
            "               u'upload': FileStorage(filename=u''),",
            "               u'package_id': u'dataset1',",
            "               u'id': u'8a3a874e-5ee1-4e43-bdaf-e2569cf72344',",
            "               u'name': u'data.csv'}",
            "        res_upload = ResourceUpload(res)",
            "",
            "        assert res_upload.filename is None",
            "",
            "    def test_resource_with_upload(",
            "            self, ckan_config, monkeypatch, tmpdir):",
            "        monkeypatch.setitem(ckan_config, u'ckan.storage_path', str(tmpdir))",
            "        # this test data is based on real observation using a browser",
            "        res = {u'clear_upload': u'',",
            "               u'format': u'PNG',",
            "               u'url': u'https://example.com/data.csv',",
            "               u'description': u'',",
            "               u'upload': FileStorage(filename=u'data.csv', content_type=u'CSV'),",
            "               u'package_id': u'dataset1',",
            "               u'id': u'8a3a874e-5ee1-4e43-bdaf-e2569cf72344',",
            "               u'name': u'data.csv'}",
            "        res_upload = ResourceUpload(res)",
            "",
            "        assert res_upload.filesize == 0",
            "        assert res_upload.filename == u'data.csv'",
            "",
            "    def test_resource_with_dodgy_id(",
            "            self, ckan_config, monkeypatch, tmpdir):",
            "        monkeypatch.setitem(ckan_config, u'ckan.storage_path', str(tmpdir))",
            "",
            "        resource_id = u'aaabbb/../../../../nope.txt'",
            "        res = {u'clear_upload': u'',",
            "               u'format': u'PNG',",
            "               u'url': u'https://example.com/data.csv',",
            "               u'description': u'',",
            "               u'upload': FileStorage(filename=u'data.csv', content_type=u'CSV'),",
            "               u'package_id': u'dataset1',",
            "               u'id': resource_id,",
            "               u'name': u'data.csv'}",
            "        res_upload = ResourceUpload(res)",
            "",
            "        with pytest.raises(ValidationError):",
            "            res_upload.upload(resource_id)",
            "",
            "",
            "class TestUpload(object):",
            "    def test_group_upload(self, monkeypatch, tmpdir, make_app, ckan_config, faker):",
            "        \"\"\"Reproduce group's logo upload and check that file available through",
            "        public url.",
            "",
            "        \"\"\"",
            "        monkeypatch.setitem(ckan_config, u'ckan.storage_path', str(tmpdir))",
            "        group = {u'clear_upload': u'',",
            "                 u'upload': FileStorage(",
            "                     BytesIO(faker.image()),",
            "                     filename=u'logo.png',",
            "                     content_type=u'image/png'",
            "                 ),",
            "                 u'name': u'test-group-upload'}",
            "        group_upload = Upload(u'group')",
            "        group_upload.update_data_dict(group, u'url', u'upload', u'clear_upload')",
            "        group_upload.upload()",
            "        uploads_dir = tmpdir / u'storage' / u'uploads' / u'group'",
            "        logo = uploads_dir.listdir()[0]",
            "        assert logo.basename == group[u'url']",
            "        app = make_app()",
            "        resp = app.get(u'/uploads/group/' + group[u'url'])",
            "        assert resp.status_code == 200",
            "        # PNG signature",
            "        assert resp.data.hex()[:16].upper() == '89504E470D0A1A0A'"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "93": [
                "TestUpload",
                "test_group_upload"
            ]
        },
        "addLocation": []
    },
    "ckan/tests/logic/action/test_create.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2226,
                "afterPatchRowNumber": 2226,
                "PatchRowcode": "                 logic.ValidationError, match=\"Unsupported upload type\"):"
            },
            "1": {
                "beforePatchRowNumber": 2227,
                "afterPatchRowNumber": 2227,
                "PatchRowcode": "             create_with_upload(\"hello world\", \"file.png\", **params)"
            },
            "2": {
                "beforePatchRowNumber": 2228,
                "afterPatchRowNumber": 2228,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2229,
                "PatchRowcode": "+    @pytest.mark.ckan_config(\"ckan.upload.user.mimetypes\", \"\")"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2230,
                "PatchRowcode": "+    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"\")"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2231,
                "PatchRowcode": "+    def test_uploads_not_allowed_when_empty_mimetypes_and_types("
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2232,
                "PatchRowcode": "+            self, create_with_upload, faker):"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2233,
                "PatchRowcode": "+        params = {"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2234,
                "PatchRowcode": "+            \"name\": faker.user_name(),"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2235,
                "PatchRowcode": "+            \"email\": faker.email(),"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2236,
                "PatchRowcode": "+            \"password\": \"12345678\","
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2237,
                "PatchRowcode": "+            \"action\": \"user_create\","
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2238,
                "PatchRowcode": "+            \"upload_field_name\": \"image_upload\","
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2239,
                "PatchRowcode": "+        }"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2240,
                "PatchRowcode": "+        with pytest.raises("
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2241,
                "PatchRowcode": "+                logic.ValidationError, match=\"No uploads allowed for object type\"):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2242,
                "PatchRowcode": "+            create_with_upload(\"hello world\", \"file.png\", **params)"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2243,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2244,
                "PatchRowcode": "+    @pytest.mark.ckan_config(\"ckan.upload.user.mimetypes\", \"*\")"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2245,
                "PatchRowcode": "+    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"image\")"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2246,
                "PatchRowcode": "+    def test_upload_all_types_allowed_needs_both_options(self, create_with_upload, faker):"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2247,
                "PatchRowcode": "+        params = {"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2248,
                "PatchRowcode": "+            \"name\": faker.user_name(),"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2249,
                "PatchRowcode": "+            \"email\": faker.email(),"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2250,
                "PatchRowcode": "+            \"password\": \"12345678\","
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2251,
                "PatchRowcode": "+            \"action\": \"user_create\","
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2252,
                "PatchRowcode": "+            \"upload_field_name\": \"image_upload\","
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2253,
                "PatchRowcode": "+        }"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2254,
                "PatchRowcode": "+        with pytest.raises("
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2255,
                "PatchRowcode": "+                logic.ValidationError, match=\"Unsupported upload type\"):"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2256,
                "PatchRowcode": "+            assert create_with_upload(faker.json(), \"file.json\", **params)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2257,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2258,
                "PatchRowcode": "+    @pytest.mark.ckan_config(\"ckan.upload.user.mimetypes\", \"*\")"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2259,
                "PatchRowcode": "+    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"*\")"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2260,
                "PatchRowcode": "+    def test_upload_all_types_allowed(self, create_with_upload, faker):"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2261,
                "PatchRowcode": "+        params = {"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2262,
                "PatchRowcode": "+            \"name\": faker.user_name(),"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2263,
                "PatchRowcode": "+            \"email\": faker.email(),"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2264,
                "PatchRowcode": "+            \"password\": \"12345678\","
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2265,
                "PatchRowcode": "+            \"action\": \"user_create\","
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2266,
                "PatchRowcode": "+            \"upload_field_name\": \"image_upload\","
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2267,
                "PatchRowcode": "+        }"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2268,
                "PatchRowcode": "+        assert create_with_upload(faker.json(), \"file.json\", **params)"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2269,
                "PatchRowcode": "+"
            },
            "44": {
                "beforePatchRowNumber": 2229,
                "afterPatchRowNumber": 2270,
                "PatchRowcode": "     @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"image\")"
            },
            "45": {
                "beforePatchRowNumber": 2230,
                "afterPatchRowNumber": 2271,
                "PatchRowcode": "     def test_upload_picture(self, create_with_upload, faker):"
            },
            "46": {
                "beforePatchRowNumber": 2231,
                "afterPatchRowNumber": 2272,
                "PatchRowcode": "         params = {"
            },
            "47": {
                "beforePatchRowNumber": 2237,
                "afterPatchRowNumber": 2278,
                "PatchRowcode": "         }"
            },
            "48": {
                "beforePatchRowNumber": 2238,
                "afterPatchRowNumber": 2279,
                "PatchRowcode": "         assert create_with_upload(faker.image(), \"file.png\", **params)"
            },
            "49": {
                "beforePatchRowNumber": 2239,
                "afterPatchRowNumber": 2280,
                "PatchRowcode": " "
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2281,
                "PatchRowcode": "+    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"image\")"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2282,
                "PatchRowcode": "+    def test_upload_picture_extension_enforced(self, create_with_upload, faker):"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2283,
                "PatchRowcode": "+        params = {"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2284,
                "PatchRowcode": "+            \"name\": faker.user_name(),"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2285,
                "PatchRowcode": "+            \"email\": faker.email(),"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2286,
                "PatchRowcode": "+            \"password\": \"12345678\","
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2287,
                "PatchRowcode": "+            \"action\": \"user_create\","
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2288,
                "PatchRowcode": "+            \"upload_field_name\": \"image_upload\","
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2289,
                "PatchRowcode": "+        }"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2290,
                "PatchRowcode": "+        user = create_with_upload(faker.image(image_format=\"jpeg\"), \"file.png\", **params)"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2291,
                "PatchRowcode": "+"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2292,
                "PatchRowcode": "+        assert user[\"image_url\"].endswith(\".jpg\")"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2293,
                "PatchRowcode": "+        assert user[\"image_display_url\"].endswith(\".jpg\")"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 2294,
                "PatchRowcode": "+"
            },
            "64": {
                "beforePatchRowNumber": 2240,
                "afterPatchRowNumber": 2295,
                "PatchRowcode": " "
            },
            "65": {
                "beforePatchRowNumber": 2241,
                "afterPatchRowNumber": 2296,
                "PatchRowcode": " class TestVocabularyCreate(object):"
            },
            "66": {
                "beforePatchRowNumber": 2242,
                "afterPatchRowNumber": 2297,
                "PatchRowcode": "     @pytest.mark.usefixtures(\"non_clean_db\")"
            }
        },
        "frontPatchFile": [
            "# encoding: utf-8",
            "\"\"\"Unit tests for ckan/logic/action/create.py.",
            "",
            "\"\"\"",
            "import datetime",
            "import operator",
            "import unittest.mock as mock",
            "import uuid",
            "",
            "import pytest",
            "import sqlalchemy as sa",
            "",
            "import ckan.logic as logic",
            "from ckan.logic.action.get import package_show as core_package_show",
            "import ckan.model as model",
            "import ckan.tests.factories as factories",
            "import ckan.tests.helpers as helpers",
            "from ckan.common import config",
            "from ckan.lib.navl.dictization_functions import DataError",
            "",
            "from freezegun import freeze_time",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestUserInvite(object):",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_invited_user_is_created_as_pending(self, _):",
            "        invited_user = self._invite_user_to_group(factories.User.stub().email)",
            "",
            "        assert invited_user is not None",
            "        assert invited_user.is_pending()",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_creates_user_with_valid_username(self, _):",
            "        name = factories.User.stub().name",
            "        email = f\"user$%+abc@{name}.com\"",
            "        invited_user = self._invite_user_to_group(email)",
            "",
            "        assert invited_user.name.startswith(\"user---abc\"), invited_user",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_assigns_user_to_group_in_expected_role(self, _):",
            "        role = \"admin\"",
            "        invited_user = self._invite_user_to_group(",
            "            factories.User.stub().email, role=role",
            "        )",
            "",
            "        group_ids = invited_user.get_group_ids(capacity=role)",
            "        assert len(group_ids) == 1, group_ids",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_sends_invite(self, send_invite):",
            "        invited_user = self._invite_user_to_group(factories.User.stub().email)",
            "",
            "        assert send_invite.called",
            "        assert send_invite.call_args[0][0].id == invited_user.id",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    @mock.patch(\"random.SystemRandom\")",
            "    def test_works_even_if_username_already_exists(self, rand, _):",
            "        # usernames",
            "        rand.return_value.random.side_effect = [1000, 1000, 2000, 3000]",
            "        # passwords (need to set something, otherwise choice will break)",
            "        rand.return_value.choice.side_effect = \"TestPassword1\" * 3",
            "        name = factories.User.stub().name",
            "        for _ in range(3):",
            "            invited_user = self._invite_user_to_group(",
            "                email=\"same{}@{}.com\".format(_, name)",
            "            )",
            "            assert invited_user is not None, invited_user",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_requires_email(self, _):",
            "        with pytest.raises(logic.ValidationError):",
            "            self._invite_user_to_group(email=None)",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_existed_email(self, _):",
            "        factories.User(email=\"email@example.com\")",
            "        with pytest.raises(logic.ValidationError):",
            "            self._invite_user_to_group(email=\"email@example.com\")",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_requires_role(self, _):",
            "        with pytest.raises(logic.ValidationError):",
            "            self._invite_user_to_group(factories.User.stub().email, role=None)",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_raises_not_found(self, _):",
            "        user = factories.User()",
            "",
            "        context = {\"user\": user[\"name\"]}",
            "        params = {",
            "            \"email\": \"a@example.com\",",
            "            \"group_id\": \"group_not_found\",",
            "            \"role\": \"admin\",",
            "        }",
            "        with pytest.raises(logic.NotFound):",
            "            helpers.call_action(\"user_invite\", context, **params)",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_requires_group_id(self, _):",
            "        with pytest.raises(logic.ValidationError):",
            "            self._invite_user_to_group(",
            "                factories.User.stub().email, group={\"id\": None}",
            "            )",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_user_name_lowercase_when_email_is_uppercase(self, _):",
            "        name = factories.User.stub().name",
            "        invited_user = self._invite_user_to_group(email=f\"Maria@{name}.com\")",
            "",
            "        assert invited_user.name.split(\"-\")[0] == \"maria\"",
            "",
            "    @pytest.mark.ckan_config(\"smtp.server\", \"email.example.com\")",
            "    @pytest.mark.usefixtures(\"with_request_context\")",
            "    def test_smtp_error_returns_error_message(self):",
            "",
            "        sysadmin = factories.Sysadmin()",
            "        group = factories.Group()",
            "",
            "        context = {\"user\": sysadmin[\"name\"]}",
            "        params = {",
            "            \"email\": \"example-invited-user@example.com\",",
            "            \"group_id\": group[\"id\"],",
            "            \"role\": \"editor\",",
            "        }",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"user_invite\", context, **params)",
            "",
            "        # Check that the pending user was deleted",
            "        user = (",
            "            model.Session.query(model.User)",
            "            .filter(model.User.name.like(\"example-invited-user%\"))",
            "            .all()",
            "        )",
            "",
            "        assert user[0].state == \"deleted\"",
            "",
            "    def _invite_user_to_group(self, email, group=None, role=\"member\"):",
            "        user = factories.User()",
            "        group = group or factories.Group(user=user)",
            "",
            "        context = {\"user\": user[\"name\"]}",
            "        params = {\"email\": email, \"group_id\": group[\"id\"], \"role\": role}",
            "",
            "        result = helpers.call_action(\"user_invite\", context, **params)",
            "",
            "        return model.User.get(result[\"id\"])",
            "",
            "",
            "@pytest.mark.ckan_config(\"ckan.plugins\", \"image_view\")",
            "@pytest.mark.usefixtures(\"non_clean_db\", \"with_plugins\")",
            "class TestResourceViewCreate(object):",
            "    def test_resource_view_create(self):",
            "        context = {}",
            "        params = self._default_resource_view_attributes()",
            "",
            "        result = helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "        result.pop(\"id\")",
            "        result.pop(\"package_id\")",
            "",
            "        assert params == result",
            "",
            "    def test_requires_resource_id(self):",
            "        context = {}",
            "        params = self._default_resource_view_attributes()",
            "        params.pop(\"resource_id\")",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    def test_requires_title(self):",
            "        context = {}",
            "        params = self._default_resource_view_attributes()",
            "        params.pop(\"title\")",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    def test_sysadmin_can_set_id(self):",
            "        user = factories.Sysadmin()",
            "        _id = str(uuid.uuid4())",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        params = self._default_resource_view_attributes()",
            "        params[\"id\"] = _id",
            "        result = helpers.call_action(\"resource_view_create\", context=context, **params)",
            "        assert result[\"id\"] == _id",
            "",
            "    def test_normal_user_can_not_set_id(self):",
            "        user = factories.User()",
            "        _id = str(uuid.uuid4())",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        params = self._default_resource_view_attributes()",
            "        params[\"id\"] = _id",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context=context, **params)",
            "",
            "    def test_id_cant_already_exist(self):",
            "        user = factories.Sysadmin()",
            "        resource_view = factories.ResourceView()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        params = self._default_resource_view_attributes()",
            "        params[\"id\"] = resource_view.pop(\"id\")",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context=context, **params)",
            "",
            "    @mock.patch(\"ckan.lib.datapreview.get_view_plugin\")",
            "    def test_requires_view_type(self, get_view_plugin):",
            "        context = {}",
            "        params = self._default_resource_view_attributes()",
            "        params.pop(\"view_type\")",
            "",
            "        get_view_plugin.return_value = \"mock_view_plugin\"",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    def test_raises_if_couldnt_find_resource(self):",
            "        context = {}",
            "        params = self._default_resource_view_attributes(resource_id=\"unknown\")",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    def test_raises_if_couldnt_find_view_extension(self):",
            "        context = {}",
            "        params = self._default_resource_view_attributes(view_type=\"unknown\")",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    @mock.patch(\"ckan.lib.datapreview\")",
            "    def test_filterable_views_dont_require_any_extra_fields(",
            "        self, datapreview_mock",
            "    ):",
            "        self._configure_datapreview_to_return_filterable_view(datapreview_mock)",
            "        context = {}",
            "        params = self._default_resource_view_attributes()",
            "",
            "        result = helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "        result.pop(\"id\")",
            "        result.pop(\"package_id\")",
            "",
            "        assert params == result",
            "",
            "    @mock.patch(\"ckan.lib.datapreview\")",
            "    def test_filterable_views_converts_filter_fields_and_values_into_filters_dict(",
            "        self, datapreview_mock",
            "    ):",
            "        self._configure_datapreview_to_return_filterable_view(datapreview_mock)",
            "        context = {}",
            "        filters = {",
            "            \"filter_fields\": [\"country\", \"weather\", \"country\"],",
            "            \"filter_values\": [\"Brazil\", \"warm\", \"Argentina\"],",
            "        }",
            "        params = self._default_resource_view_attributes(**filters)",
            "        result = helpers.call_action(\"resource_view_create\", context, **params)",
            "        expected_filters = {",
            "            \"country\": [\"Brazil\", \"Argentina\"],",
            "            \"weather\": [\"warm\"],",
            "        }",
            "        assert result[\"filters\"] == expected_filters",
            "",
            "    @mock.patch(\"ckan.lib.datapreview\")",
            "    def test_filterable_views_converts_filter_fields_and_values_to_list(",
            "        self, datapreview_mock",
            "    ):",
            "        self._configure_datapreview_to_return_filterable_view(datapreview_mock)",
            "        context = {}",
            "        filters = {\"filter_fields\": \"country\", \"filter_values\": \"Brazil\"}",
            "        params = self._default_resource_view_attributes(**filters)",
            "        result = helpers.call_action(\"resource_view_create\", context, **params)",
            "        assert result[\"filter_fields\"] == [\"country\"]",
            "        assert result[\"filter_values\"] == [\"Brazil\"]",
            "        assert result[\"filters\"] == {\"country\": [\"Brazil\"]}",
            "",
            "    @mock.patch(\"ckan.lib.datapreview\")",
            "    def test_filterable_views_require_filter_fields_and_values_to_have_same_length(",
            "        self, datapreview_mock",
            "    ):",
            "        self._configure_datapreview_to_return_filterable_view(datapreview_mock)",
            "        context = {}",
            "        filters = {",
            "            \"filter_fields\": [\"country\", \"country\"],",
            "            \"filter_values\": \"Brazil\",",
            "        }",
            "        params = self._default_resource_view_attributes(**filters)",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    def test_non_filterable_views_dont_accept_filter_fields_and_values(self):",
            "        context = {}",
            "        filters = {\"filter_fields\": \"country\", \"filter_values\": \"Brazil\"}",
            "        params = self._default_resource_view_attributes(**filters)",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    def _default_resource_view_attributes(self, **kwargs):",
            "        default_attributes = {",
            "            \"resource_id\": factories.Resource()[\"id\"],",
            "            \"view_type\": \"image_view\",",
            "            \"title\": \"View\",",
            "            \"description\": \"A nice view\",",
            "        }",
            "",
            "        default_attributes.update(kwargs)",
            "",
            "        return default_attributes",
            "",
            "    def _configure_datapreview_to_return_filterable_view(",
            "        self, datapreview_mock",
            "    ):",
            "        filterable_view = mock.MagicMock()",
            "        filterable_view.info.return_value = {\"filterable\": True}",
            "        datapreview_mock.get_view_plugin.return_value = filterable_view",
            "",
            "",
            "@pytest.mark.ckan_config(\"ckan.views.default_views\", \"\")",
            "@pytest.mark.ckan_config(\"ckan.plugins\", \"image_view\")",
            "@pytest.mark.usefixtures(\"non_clean_db\", \"with_plugins\")",
            "class TestCreateDefaultResourceViews(object):",
            "    def test_add_default_views_to_dataset_resources(self):",
            "",
            "        # New resources have no views",
            "        dataset_dict = factories.Dataset(",
            "            resources=[",
            "                {",
            "                    \"url\": \"http://some.image.png\",",
            "                    \"format\": \"png\",",
            "                    \"name\": \"Image 1\",",
            "                },",
            "                {",
            "                    \"url\": \"http://some.image.png\",",
            "                    \"format\": \"png\",",
            "                    \"name\": \"Image 2\",",
            "                },",
            "            ]",
            "        )",
            "",
            "        # Change default views config setting",
            "        config[\"ckan.views.default_views\"] = [\"image_view\"]",
            "",
            "        context = {\"user\": helpers.call_action(\"get_site_user\")[\"name\"]}",
            "        created_views = helpers.call_action(",
            "            \"package_create_default_resource_views\",",
            "            context,",
            "            package=dataset_dict,",
            "        )",
            "",
            "        assert len(created_views) == 2",
            "",
            "        assert created_views[0][\"view_type\"] == \"image_view\"",
            "        assert created_views[1][\"view_type\"] == \"image_view\"",
            "",
            "    def test_add_default_views_to_resource(self):",
            "",
            "        # New resources have no views",
            "        dataset_dict = factories.Dataset()",
            "        resource_dict = factories.Resource(",
            "            package_id=dataset_dict[\"id\"],",
            "            url=\"http://some.image.png\",",
            "            format=\"png\",",
            "        )",
            "",
            "        # Change default views config setting",
            "        config[\"ckan.views.default_views\"] = [\"image_view\"]",
            "",
            "        context = {\"user\": helpers.call_action(\"get_site_user\")[\"name\"]}",
            "        created_views = helpers.call_action(",
            "            \"resource_create_default_resource_views\",",
            "            context,",
            "            resource=resource_dict,",
            "            package=dataset_dict,",
            "        )",
            "",
            "        assert len(created_views) == 1",
            "",
            "        assert created_views[0][\"view_type\"] == \"image_view\"",
            "",
            "    def test_add_default_views_to_resource_no_dataset_passed(self):",
            "",
            "        # New resources have no views",
            "        dataset_dict = factories.Dataset()",
            "        resource_dict = factories.Resource(",
            "            package_id=dataset_dict[\"id\"],",
            "            url=\"http://some.image.png\",",
            "            format=\"png\",",
            "        )",
            "",
            "        # Change default views config setting",
            "        config[\"ckan.views.default_views\"] = [\"image_view\"]",
            "",
            "        context = {\"user\": helpers.call_action(\"get_site_user\")[\"name\"]}",
            "        created_views = helpers.call_action(",
            "            \"resource_create_default_resource_views\",",
            "            context,",
            "            resource=resource_dict,",
            "        )",
            "",
            "        assert len(created_views) == 1",
            "",
            "        assert created_views[0][\"view_type\"] == \"image_view\"",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestResourceCreate:",
            "    def test_resource_create(self):",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://data\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        id = result.pop(\"id\")",
            "",
            "        assert id",
            "",
            "        params.pop(\"package_id\")",
            "        for key in params.keys():",
            "            assert params[key] == result[key]",
            "",
            "    def test_it_requires_package_id(self):",
            "",
            "        data_dict = {\"url\": \"http://data\"}",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_create\", **data_dict)",
            "",
            "    def test_invalid_characters_in_id(self):",
            "",
            "        data_dict = {",
            "            \"id\": \"../../nope.txt\",",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://data\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_create\", **data_dict)",
            "",
            "    def test_id_too_long(self):",
            "",
            "        data_dict = {",
            "            \"id\": \"x\" * 111,",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://data\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_create\", **data_dict)",
            "",
            "    def test_id_already_exists(self):",
            "        data_dict = {",
            "            'id': str(uuid.uuid4()),",
            "            'package_id': factories.Dataset()['id'],",
            "        }",
            "        helpers.call_action('resource_create', **data_dict)",
            "",
            "        data_dict['package_id'] = factories.Dataset()['id']",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action('resource_create', **data_dict)",
            "",
            "    def test_sysadmin_can_set_id(self):",
            "        \"\"\"",
            "        The system admin",
            "        \"\"\"",
            "        user = factories.Sysadmin()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        data_dict = {",
            "            \"id\": _id,",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://data\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "",
            "        result = helpers.call_action(\"resource_create\", context=context, **data_dict)",
            "        assert result[\"id\"] == _id",
            "",
            "    def test_normal_user_can_provide_custom_id(self):",
            "",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        data_dict = {",
            "            \"id\": _id,",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://data\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "        result = helpers.call_action(\"resource_create\", context=context, **data_dict)",
            "        assert result[\"id\"] == _id",
            "",
            "    def test_doesnt_require_url(self):",
            "        dataset = factories.Dataset()",
            "        data_dict = {\"package_id\": dataset[\"id\"]}",
            "        new_resouce = helpers.call_action(\"resource_create\", **data_dict)",
            "",
            "        data_dict = {\"id\": new_resouce[\"id\"]}",
            "        stored_resource = helpers.call_action(\"resource_show\", **data_dict)",
            "",
            "        assert not stored_resource[\"url\"]",
            "",
            "    def test_mimetype_by_url(self, monkeypatch, ckan_config, tmpdir):",
            "        \"\"\"The mimetype is guessed from the url",
            "",
            "        Real world usage would be externally linking the resource and",
            "        the mimetype would be guessed, based on the url",
            "",
            "        \"\"\"",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://localhost/data.csv\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "        monkeypatch.setitem(ckan_config, u'ckan.storage_path', str(tmpdir))",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        mimetype = result.pop(\"mimetype\")",
            "",
            "        assert mimetype",
            "        assert mimetype == \"text/csv\"",
            "",
            "    def test_mimetype_by_url_without_path(self):",
            "        \"\"\"",
            "        The mimetype should not be guessed from url if url contains only domain",
            "",
            "        \"\"\"",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://example.com\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        mimetype = result.pop(\"mimetype\")",
            "        assert mimetype is None",
            "",
            "    def test_mimetype_by_user(self):",
            "        \"\"\"",
            "        The mimetype is supplied by the user",
            "",
            "        Real world usage would be using the FileStore API or web UI form to create a resource",
            "        and the user wanted to specify the mimetype themselves",
            "        \"\"\"",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://localhost/data.csv\",",
            "            \"name\": \"A nice resource\",",
            "            \"mimetype\": \"application/csv\",",
            "        }",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        mimetype = result.pop(\"mimetype\")",
            "        assert mimetype == \"application/csv\"",
            "",
            "    def test_mimetype_by_upload_by_filename(self, create_with_upload):",
            "        \"\"\"The mimetype is guessed from an uploaded file with a filename",
            "",
            "        Real world usage would be using the FileStore API or web UI",
            "        form to upload a file, with a filename plus extension If",
            "        there's no url or the mimetype can't be guessed by the url,",
            "        mimetype will be guessed by the extension in the filename",
            "",
            "        \"\"\"",
            "        content = \"\"\"",
            "        \"info\": {",
            "            \"title\": \"BC Data Catalogue API\",",
            "            \"description\": \"This API provides information about datasets in the BC Data Catalogue.\",",
            "            \"termsOfService\": \"http://www.data.gov.bc.ca/local/dbc/docs/license/API_Terms_of_Use.pdf\",",
            "            \"contact\": {",
            "                \"name\": \"Data BC\",",
            "                \"url\": \"http://data.gov.bc.ca/\",",
            "                \"email\": \"\"",
            "            },",
            "            \"license\": {",
            "                \"name\": \"Open Government License - British Columbia\",",
            "                \"url\": \"http://www.data.gov.bc.ca/local/dbc/docs/license/OGL-vbc2.0.pdf\"",
            "            },",
            "            \"version\": \"3.0.0\"",
            "        }",
            "        \"\"\"",
            "",
            "        result = create_with_upload(",
            "            content,",
            "            \"test.json\",",
            "            url=\"http://data\",",
            "            package_id=factories.Dataset()[u\"id\"],",
            "        )",
            "        mimetype = result.pop(\"mimetype\")",
            "",
            "        assert mimetype",
            "        assert mimetype == \"application/json\"",
            "",
            "    @pytest.mark.ckan_config(\"ckan.mimetype_guess\", \"file_contents\")",
            "    def test_mimetype_by_upload_by_file(self, create_with_upload):",
            "        \"\"\"The mimetype is guessed from an uploaded file by the contents inside",
            "",
            "        Real world usage would be using the FileStore API or web UI",
            "        form to upload a file, that has no extension If the mimetype",
            "        can't be guessed by the url or filename, mimetype will be",
            "        guessed by the contents inside the file",
            "",
            "        \"\"\"",
            "",
            "        content = \"\"\"",
            "        Snow Course Name, Number, Elev. metres, Date of Survey, Snow Depth cm,\\",
            "        Water Equiv. mm, Survey Code, % of Normal, Density %, Survey Period, \\",
            "        Normal mm",
            "        SKINS LAKE,1B05,890,2015/12/30,34,53,,98,16,JAN-01,54",
            "        MCGILLIVRAY PASS,1C05,1725,2015/12/31,88,239,,87,27,JAN-01,274",
            "        NAZKO,1C08,1070,2016/01/05,20,31,,76,16,JAN-01,41",
            "        \"\"\"",
            "        result = create_with_upload(",
            "            content,",
            "            \"test.csv\",",
            "            url=\"http://data\",",
            "            package_id=factories.Dataset()[u\"id\"],",
            "        )",
            "",
            "        mimetype = result.pop(\"mimetype\")",
            "",
            "        assert mimetype",
            "        assert mimetype == \"text/plain\"",
            "",
            "    def test_size_of_resource_by_upload(self, create_with_upload):",
            "        \"\"\"",
            "        The size of the resource determined by the uploaded file",
            "        \"\"\"",
            "",
            "        content = \"\"\"",
            "        Snow Course Name, Number, Elev. metres, Date of Survey, Snow Depth cm,\\",
            "        Water Equiv. mm, Survey Code, % of Normal, Density %, Survey Period, \\",
            "        Normal mm",
            "        SKINS LAKE,1B05,890,2015/12/30,34,53,,98,16,JAN-01,54",
            "        MCGILLIVRAY PASS,1C05,1725,2015/12/31,88,239,,87,27,JAN-01,274",
            "        NAZKO,1C08,1070,2016/01/05,20,31,,76,16,JAN-01,41",
            "        \"\"\"",
            "        result = create_with_upload(",
            "            content,",
            "            \"test.csv\",",
            "            url=\"http://data\",",
            "            package_id=factories.Dataset()[u\"id\"],",
            "        )",
            "",
            "        size = result.pop(\"size\")",
            "",
            "        assert size",
            "        assert size > 0",
            "",
            "    def test_size_of_resource_by_user(self):",
            "        \"\"\"",
            "        The size of the resource is provided by the users",
            "",
            "        Real world usage would be using the FileStore API and the user provides a size for the resource",
            "        \"\"\"",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://data\",",
            "            \"name\": \"A nice resource\",",
            "            \"size\": 500,",
            "        }",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        size = int(result.pop(\"size\"))",
            "        assert size == 500",
            "",
            "    def test_extras(self):",
            "        user = factories.User()",
            "        dataset = factories.Dataset(user=user)",
            "",
            "        resource = helpers.call_action(",
            "            \"resource_create\",",
            "            package_id=dataset[\"id\"],",
            "            somekey=\"somevalue\",  # this is how to do resource extras",
            "            extras={u\"someotherkey\": u\"alt234\"},  # this isn't",
            "            subobject={u\"hello\": u\"there\"},  # JSON objects supported",
            "            sublist=[1, 2, 3],  # JSON lists supported",
            "            format=u\"plain text\",",
            "            url=u\"http://datahub.io/download/\",",
            "        )",
            "",
            "        assert resource[\"somekey\"] == \"somevalue\"",
            "        assert \"extras\" not in resource",
            "        assert \"someotherkey\" not in resource",
            "        assert resource[\"subobject\"] == {u\"hello\": u\"there\"}",
            "        assert resource[\"sublist\"] == [1, 2, 3]",
            "        resource = helpers.call_action(\"package_show\", id=dataset[\"id\"])[",
            "            \"resources\"",
            "        ][0]",
            "        assert resource[\"somekey\"] == \"somevalue\"",
            "        assert \"extras\" not in resource",
            "        assert \"someotherkey\" not in resource",
            "        assert resource[\"subobject\"] == {u\"hello\": u\"there\"}",
            "        assert resource[\"sublist\"] == [1, 2, 3]",
            "",
            "    @freeze_time(\"2020-02-25 12:00:00\")",
            "    def test_metadata_modified_is_set_to_utcnow_when_created(self):",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://data\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        assert (",
            "            result[\"metadata_modified\"]",
            "            == datetime.datetime.utcnow().isoformat()",
            "        )",
            "",
            "    @pytest.mark.ckan_config(\"ckan.auth.allow_dataset_collaborators\", True)",
            "    @pytest.mark.ckan_config(\"ckan.auth.allow_admin_collaborators\", True)",
            "    @pytest.mark.parametrize(\"role\", [\"admin\", \"editor\"])",
            "    def test_collaborators_can_create_resources(self, role):",
            "",
            "        org1 = factories.Organization()",
            "        dataset = factories.Dataset(owner_org=org1[\"id\"])",
            "",
            "        user = factories.User()",
            "",
            "        helpers.call_action(",
            "            \"package_collaborator_create\",",
            "            id=dataset[\"id\"],",
            "            user_id=user[\"id\"],",
            "            capacity=role,",
            "        )",
            "",
            "        context = {",
            "            \"user\": user[\"name\"],",
            "            \"ignore_auth\": False,",
            "        }",
            "",
            "        created_resource = helpers.call_action(",
            "            \"resource_create\",",
            "            context=context,",
            "            package_id=dataset[\"id\"],",
            "            name=\"created by collaborator\",",
            "            url=\"https://example.com\",",
            "        )",
            "",
            "        assert created_resource[\"name\"] == \"created by collaborator\"",
            "",
            "    def test_resource_create_for_update(self):",
            "",
            "        dataset = factories.Dataset()",
            "",
            "        mock_package_show = mock.MagicMock()",
            "        mock_package_show.side_effect = lambda context, data_dict: core_package_show(context, data_dict)",
            "",
            "        with mock.patch.dict('ckan.logic._actions', {'package_show': mock_package_show}):",
            "            helpers.call_action('resource_create', package_id=dataset['id'], url='http://example.com', description='hey')",
            "            assert mock_package_show.call_args_list[0][0][0].get('for_update') is True",
            "",
            "    def test_resource_create_copies_other_resources(self):",
            "        from ckan.lib.dictization import model_save",
            "        existing = factories.Resource()",
            "        params = {",
            "            \"package_id\": existing['package_id'],",
            "            \"url\": \"http://data\",",
            "            \"name\": \"A second resource\",",
            "        }",
            "        with mock.patch(",
            "                'ckan.lib.dictization.model_save.package_dict_save',",
            "                wraps=model_save.package_dict_save,",
            "                ) as m:",
            "            helpers.call_action(\"resource_create\", **params)",
            "            assert m.call_args.args[3] == {0: 0}, 'copy existing resource 0'",
            "",
            "    def test_upload_file_paths(self, create_with_upload):",
            "        from ckan.common import config",
            "        import os",
            "",
            "        storage_path = config[\"ckan.storage_path\"]",
            "",
            "        dataset = factories.Dataset()",
            "        resource1 = create_with_upload(",
            "            \"hello world\", \"file1.txt\", url=\"http://data1\",",
            "            package_id=dataset[\"id\"])",
            "",
            "        assert os.path.exists(",
            "            os.path.join(storage_path, \"resources\", resource1[\"id\"][:3])",
            "        )",
            "",
            "        resource2 = create_with_upload(",
            "            \"bye bye world\", \"file2.txt\", url=\"http://data2\",",
            "            package_id=dataset[\"id\"])",
            "",
            "        assert os.path.exists(",
            "            os.path.join(storage_path, \"resources\", resource2[\"id\"][:3])",
            "        )",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestMemberCreate(object):",
            "    def test_group_member_creation(self):",
            "        user = factories.User()",
            "        group = factories.Group()",
            "",
            "        new_membership = helpers.call_action(",
            "            \"group_member_create\",",
            "            id=group[\"id\"],",
            "            username=user[\"name\"],",
            "            role=\"member\",",
            "        )",
            "",
            "        assert new_membership[\"group_id\"] == group[\"id\"]",
            "        assert new_membership[\"table_name\"] == \"user\"",
            "        assert new_membership[\"table_id\"] == user[\"id\"]",
            "        assert new_membership[\"capacity\"] == \"member\"",
            "",
            "    def test_organization_member_creation(self):",
            "        user = factories.User()",
            "        organization = factories.Organization()",
            "",
            "        new_membership = helpers.call_action(",
            "            \"organization_member_create\",",
            "            id=organization[\"id\"],",
            "            username=user[\"name\"],",
            "            role=\"member\",",
            "        )",
            "",
            "        assert new_membership[\"group_id\"] == organization[\"id\"]",
            "        assert new_membership[\"table_name\"] == \"user\"",
            "        assert new_membership[\"table_id\"] == user[\"id\"]",
            "        assert new_membership[\"capacity\"] == \"member\"",
            "",
            "    def test_group_member_creation_raises_validation_error_if_id_missing(self):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"group_member_create\",",
            "                username=factories.User.stub().name,",
            "                role=\"member\",",
            "            )",
            "",
            "    def test_group_member_creation_raises_validation_error_if_username_missing(",
            "        self,",
            "    ):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"group_member_create\", id=\"someid\", role=\"member\"",
            "            )",
            "",
            "    def test_group_member_creation_raises_validation_error_if_role_missing(",
            "        self, faker",
            "    ):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"group_member_create\",",
            "                id=faker.uuid4(),",
            "                username=factories.User.stub().name,",
            "            )",
            "",
            "    def test_org_member_creation_raises_validation_error_if_id_missing(self):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"organization_member_create\",",
            "                username=factories.User.stub().name,",
            "                role=\"member\",",
            "            )",
            "",
            "    def test_org_member_creation_raises_validation_error_if_username_missing(",
            "        self,",
            "    ):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"organization_member_create\",",
            "                id=factories.Group.stub().name,",
            "                role=\"member\",",
            "            )",
            "",
            "    def test_org_member_creation_raises_validation_error_if_role_missing(self, faker):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"organization_member_create\",",
            "                id=faker.uuid4(),",
            "                username=factories.User.stub().name,",
            "            )",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestDatasetCreate(object):",
            "    def test_private_package(self):",
            "        org = factories.Organization()",
            "        stub = factories.Dataset.stub()",
            "        with pytest.raises(logic.ValidationError):",
            "            pkg = helpers.call_action(",
            "                \"package_create\", name=stub.name, private=True",
            "            )",
            "",
            "        pkg = helpers.call_action(",
            "            \"package_create\", owner_org=org[\"id\"], name=stub.name",
            "        )",
            "        assert not pkg[\"private\"]",
            "        pkg = helpers.call_action(",
            "            \"package_create\",",
            "            owner_org=org[\"id\"],",
            "            name=factories.Dataset.stub().name,",
            "            private=False,",
            "        )",
            "        assert not pkg[\"private\"]",
            "        pkg = helpers.call_action(",
            "            \"package_create\",",
            "            owner_org=org[\"id\"],",
            "            name=factories.Dataset.stub().name,",
            "            private=True,",
            "        )",
            "        assert pkg[\"private\"]",
            "",
            "    def test_normal_user_cant_set_id(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"package_create\",",
            "                context=context,",
            "                id=_id,",
            "                name=\"test\",",
            "            )",
            "",
            "    def test_sysadmin_can_set_id(self):",
            "        user = factories.Sysadmin()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        dataset = helpers.call_action(",
            "            \"package_create\", context=context, id=_id, name=f\"test-dataset-{_id}\"",
            "        )",
            "        assert dataset[\"id\"] == _id",
            "",
            "    def test_context_is_not_polluted(self):",
            "        user = factories.Sysadmin()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        helpers.call_action(",
            "            \"package_create\", context=context, id=_id, name=f\"test-dataset-{_id}\"",
            "        )",
            "        assert \"id\" not in context",
            "        assert \"package\" not in context",
            "",
            "    def test_id_cant_already_exist(self):",
            "        dataset = factories.Dataset()",
            "        factories.Sysadmin()",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"package_create\",",
            "                id=dataset[\"id\"],",
            "                name=factories.Dataset.stub().name,",
            "            )",
            "",
            "    def test_name_not_changed_during_deletion(self):",
            "        dataset = factories.Dataset()",
            "        helpers.call_action(\"package_delete\", id=dataset[\"id\"])",
            "        deleted_dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        assert deleted_dataset[\"name\"] == dataset[\"name\"]",
            "",
            "    def test_name_not_changed_after_restoring(self):",
            "        dataset = factories.Dataset()",
            "        context = {\"user\": factories.Sysadmin()[\"name\"]}",
            "        helpers.call_action(\"package_delete\", id=dataset[\"id\"])",
            "        deleted_dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        restored_dataset = helpers.call_action(",
            "            \"package_patch\", context=context, id=dataset[\"id\"], state=\"active\"",
            "        )",
            "        assert deleted_dataset[\"name\"] == restored_dataset[\"name\"]",
            "        assert deleted_dataset[\"id\"] == restored_dataset[\"id\"]",
            "",
            "    def test_creation_of_dataset_with_name_same_as_of_previously_removed(self):",
            "        dataset = factories.Dataset()",
            "        initial_name = dataset[\"name\"]",
            "        helpers.call_action(\"package_delete\", id=dataset[\"id\"])",
            "        new_dataset = helpers.call_action(\"package_create\", name=initial_name)",
            "        assert new_dataset[\"name\"] == initial_name",
            "        deleted_dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "",
            "        assert new_dataset[\"id\"] != deleted_dataset[\"id\"]",
            "        assert deleted_dataset[\"name\"] == deleted_dataset[\"id\"]",
            "",
            "    def test_missing_id(self):",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"package_create\")",
            "",
            "    def test_name(self):",
            "        stub = factories.Dataset.stub()",
            "        dataset = helpers.call_action(\"package_create\", name=stub.name)",
            "",
            "        assert dataset[\"name\"] == stub.name",
            "        assert (",
            "            helpers.call_action(\"package_show\", id=dataset[\"id\"])[\"name\"]",
            "            == stub.name",
            "        )",
            "",
            "    def test_title(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=factories.Dataset.stub().name,",
            "            title=\"New Title\",",
            "        )",
            "",
            "        assert dataset[\"title\"] == \"New Title\"",
            "        assert (",
            "            helpers.call_action(\"package_show\", id=dataset[\"id\"])[\"title\"]",
            "            == \"New Title\"",
            "        )",
            "",
            "    def test_extras(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=factories.Dataset.stub().name,",
            "            title=\"Test Extras\",",
            "            extras=[{\"key\": \"original media\", \"value\": '\"book\"'}],",
            "        )",
            "",
            "        assert dataset[\"extras\"][0][\"key\"] == \"original media\"",
            "        assert dataset[\"extras\"][0][\"value\"] == '\"book\"'",
            "        dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        assert dataset[\"extras\"][0][\"key\"] == \"original media\"",
            "        assert dataset[\"extras\"][0][\"value\"] == '\"book\"'",
            "",
            "    def test_sysadmin_can_set_extras_id(self):",
            "        user = factories.Sysadmin()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            context=context,",
            "            name=factories.Dataset.stub().name,",
            "            title=\"Test Extras\",",
            "            extras=[{\"id\": _id, \"key\": \"original media\", \"value\": '\"book\"'}],",
            "        )",
            "        dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        assert dataset[\"extras\"][0][\"key\"] == \"original media\"",
            "",
            "    def test_normal_user_can_not_set_extras_id(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        with pytest.raises(logic.ValidationError) as exception:",
            "            helpers.call_action(",
            "                \"package_create\",",
            "                context=context,",
            "                name=factories.Dataset.stub().name,",
            "                title=\"Test Extras\",",
            "                extras=[{\"id\": _id, \"key\": \"original media\", \"value\": '\"book\"'}],",
            "            )",
            "        assert \"The input field id was not expected\" in str(exception.value)",
            "",
            "    def test_license(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=factories.Dataset.stub().name,",
            "            title=\"Test License\",",
            "            license_id=\"other-open\",",
            "        )",
            "",
            "        assert dataset[\"license_id\"] == \"other-open\"",
            "        dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        assert dataset[\"license_id\"] == \"other-open\"",
            "",
            "    def test_notes(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=factories.Dataset.stub().name,",
            "            title=\"Test Notes\",",
            "            notes=\"some notes\",",
            "        )",
            "",
            "        assert dataset[\"notes\"] == \"some notes\"",
            "        dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        assert dataset[\"notes\"] == \"some notes\"",
            "",
            "    def test_resources(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=factories.Dataset.stub().name,",
            "            title=\"Test Resources\",",
            "            resources=[",
            "                {",
            "                    \"alt_url\": u\"alt123\",",
            "                    \"description\": u\"Full text.\",",
            "                    \"somekey\": \"somevalue\",  # this is how to do resource extras",
            "                    \"extras\": {u\"someotherkey\": u\"alt234\"},  # this isn't",
            "                    \"format\": u\"plain text\",",
            "                    \"hash\": u\"abc123\",",
            "                    \"position\": 0,",
            "                    \"url\": u\"http://datahub.io/download/\",",
            "                },",
            "                {",
            "                    \"description\": u\"Index of the novel\",",
            "                    \"format\": u\"JSON\",",
            "                    \"position\": 1,",
            "                    \"url\": u\"http://datahub.io/index.json\",",
            "                },",
            "            ],",
            "        )",
            "",
            "        resources = dataset[\"resources\"]",
            "        assert resources[0][\"alt_url\"] == \"alt123\"",
            "        assert resources[0][\"description\"] == \"Full text.\"",
            "        assert resources[0][\"somekey\"] == \"somevalue\"",
            "        assert \"extras\" not in resources[0]",
            "        assert \"someotherkey\" not in resources[0]",
            "        assert resources[0][\"format\"] == \"plain text\"",
            "        assert resources[0][\"hash\"] == \"abc123\"",
            "        assert resources[0][\"position\"] == 0",
            "        assert resources[0][\"url\"] == \"http://datahub.io/download/\"",
            "        assert resources[1][\"description\"] == \"Index of the novel\"",
            "        assert resources[1][\"format\"] == \"JSON\"",
            "        assert resources[1][\"url\"] == \"http://datahub.io/index.json\"",
            "        assert resources[1][\"position\"] == 1",
            "        resources = helpers.call_action(\"package_show\", id=dataset[\"id\"])[",
            "            \"resources\"",
            "        ]",
            "        assert resources[0][\"alt_url\"] == \"alt123\"",
            "        assert resources[0][\"description\"] == \"Full text.\"",
            "        assert resources[0][\"somekey\"] == \"somevalue\"",
            "        assert \"extras\" not in resources[0]",
            "        assert \"someotherkey\" not in resources[0]",
            "        assert resources[0][\"format\"] == \"plain text\"",
            "        assert resources[0][\"hash\"] == \"abc123\"",
            "        assert resources[0][\"position\"] == 0",
            "        assert resources[0][\"url\"] == \"http://datahub.io/download/\"",
            "        assert resources[1][\"description\"] == \"Index of the novel\"",
            "        assert resources[1][\"format\"] == \"JSON\"",
            "        assert resources[1][\"url\"] == \"http://datahub.io/index.json\"",
            "        assert resources[1][\"position\"] == 1",
            "",
            "    def test_tags(self):",
            "        tag1 = factories.Tag.stub().name",
            "        tag2 = factories.Tag.stub().name",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=factories.Dataset.stub().name,",
            "            title=\"Test Tags\",",
            "            tags=[{\"name\": tag1}, {\"name\": tag2}],",
            "        )",
            "",
            "        tag_names = sorted([tag_dict[\"name\"] for tag_dict in dataset[\"tags\"]])",
            "        assert tag_names == sorted([tag1, tag2])",
            "        dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        tag_names = sorted([tag_dict[\"name\"] for tag_dict in dataset[\"tags\"]])",
            "        assert tag_names == sorted([tag1, tag2])",
            "",
            "    def test_return_id_only(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=factories.Dataset.stub().name,",
            "            context={\"return_id_only\": True},",
            "        )",
            "",
            "        assert isinstance(dataset, str)",
            "",
            "    def test_non_string_extras(self):",
            "        data_dict = {",
            "            \"name\": \"test-non-string-extras\",",
            "            \"extras\": [",
            "                {",
            "                    \"key\": \"some_number\",",
            "                    \"value\": 1.5",
            "                }",
            "            ]",
            "        }",
            "",
            "        helpers.call_action(\"package_create\", **data_dict)",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestGroupCreate(object):",
            "    def test_create_group(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        group = helpers.call_action(",
            "            \"group_create\", context=context, name=factories.Group.stub().name",
            "        )",
            "",
            "        assert len(group[\"users\"]) == 1",
            "        assert group[\"display_name\"] == group[\"name\"]",
            "        assert group[\"package_count\"] == 0",
            "        assert not group[\"is_organization\"]",
            "        assert group[\"type\"] == \"group\"",
            "",
            "    def test_create_group_validation_fail(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"group_create\", context=context, name=\"\"",
            "            )",
            "",
            "    def test_create_group_return_id(self):",
            "        import re",
            "",
            "        user = factories.User()",
            "        context = {",
            "            \"user\": user[\"name\"],",
            "            \"ignore_auth\": True,",
            "            \"return_id_only\": True,",
            "        }",
            "",
            "        group = helpers.call_action(",
            "            \"group_create\", context=context, name=factories.Group.stub().name",
            "        )",
            "",
            "        assert isinstance(group, str)",
            "        assert re.match(r\"([a-f\\d]{8}(-[a-f\\d]{4}){3}-[a-f\\d]{12}?)\", group)",
            "",
            "    def test_create_matches_show(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        created = helpers.call_action(",
            "            \"organization_create\",",
            "            context=context,",
            "            name=factories.Organization.stub().name,",
            "        )",
            "",
            "        shown = helpers.call_action(",
            "            \"organization_show\", context=context, id=created[\"name\"]",
            "        )",
            "",
            "        assert sorted(created.keys()) == sorted(shown.keys())",
            "        for k in created.keys():",
            "            assert created[k] == shown[k], k",
            "",
            "    def test_normal_user_cant_set_id(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"group_create\",",
            "                context=context,",
            "                name=f\"test-group-{_id}\",",
            "                id=_id",
            "            )",
            "",
            "    def test_sysadmin_can_set_id(self):",
            "        user = factories.Sysadmin()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        result = helpers.call_action(",
            "            \"group_create\",",
            "            context=context,",
            "            name=f\"test-group-{_id}\",",
            "            id=_id",
            "        )",
            "        assert result.get(\"id\") == _id",
            "",
            "    def test_id_cant_already_exist(self):",
            "        user = factories.Sysadmin()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        group = helpers.call_action(",
            "            \"group_create\",",
            "            name=factories.Group.stub().name,",
            "            context=context",
            "        )",
            "        with pytest.raises(logic.ValidationError) as exception:",
            "            helpers.call_action(",
            "                \"group_create\",",
            "                id=group[\"id\"],",
            "                context=context,",
            "                name=factories.Group.stub().name,",
            "            )",
            "        assert \"Id already exists\" in str(exception.value)",
            "",
            "    def test_normal_user_cant_set_extras_id(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        with pytest.raises(logic.ValidationError) as exception:",
            "            helpers.call_action(",
            "                \"group_create\",",
            "                context=context,",
            "                name=f\"test-group-{_id}\",",
            "                extras=[{\"id\": _id, \"key\": \"area\", \"value\": '\"non profit\"'}]",
            "            )",
            "        assert \"The input field id was not expected\" in str(exception.value)",
            "",
            "    def test_sysadmin_user_cant_set_extras_id(self):",
            "        user = factories.Sysadmin()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        helpers.call_action(",
            "            \"group_create\",",
            "            context=context,",
            "            name=f\"test-group-{_id}\",",
            "            extras=[{\"id\": _id, \"key\": \"area\", \"value\": '\"non profit\"'}]",
            "        )",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestOrganizationCreate(object):",
            "    def test_create_organization(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        org = helpers.call_action(",
            "            \"organization_create\",",
            "            context=context,",
            "            name=factories.Organization.stub().name,",
            "        )",
            "",
            "        assert len(org[\"users\"]) == 1",
            "        assert org[\"display_name\"] == org[\"name\"]",
            "        assert org[\"package_count\"] == 0",
            "        assert org[\"is_organization\"]",
            "        assert org[\"type\"] == \"organization\"",
            "",
            "    def test_create_organization_validation_fail(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"organization_create\", context=context, name=\"\"",
            "            )",
            "",
            "    def test_create_organization_return_id(self):",
            "        import re",
            "",
            "        user = factories.User()",
            "        context = {",
            "            \"user\": user[\"name\"],",
            "            \"ignore_auth\": True,",
            "            \"return_id_only\": True,",
            "        }",
            "",
            "        org = helpers.call_action(",
            "            \"organization_create\",",
            "            context=context,",
            "            name=factories.Organization.stub().name,",
            "        )",
            "",
            "        assert isinstance(org, str)",
            "        assert re.match(r\"([a-f\\d]{8}(-[a-f\\d]{4}){3}-[a-f\\d]{12}?)\", org)",
            "",
            "    def test_create_matches_show(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        created = helpers.call_action(",
            "            \"organization_create\",",
            "            context=context,",
            "            name=factories.Organization.stub().name,",
            "        )",
            "",
            "        shown = helpers.call_action(",
            "            \"organization_show\", context=context, id=created[\"name\"]",
            "        )",
            "",
            "        assert sorted(created.keys()) == sorted(shown.keys())",
            "        for k in created.keys():",
            "            assert created[k] == shown[k], k",
            "",
            "    def test_create_organization_custom_type(self):",
            "        custom_org_type = \"some-custom-type\"",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        org = helpers.call_action(",
            "            \"organization_create\",",
            "            context=context,",
            "            name=factories.Organization.stub().name,",
            "            type=custom_org_type,",
            "        )",
            "",
            "        assert len(org[\"users\"]) == 1",
            "        assert org[\"display_name\"] == org[\"name\"]",
            "        assert org[\"package_count\"] == 0",
            "        assert org[\"is_organization\"]",
            "        assert org[\"type\"] == custom_org_type",
            "",
            "    def test_normal_user_cant_set_id(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"organization_create\",",
            "                context=context,",
            "                name=f\"test-org-{_id}\",",
            "                id=_id",
            "            )",
            "",
            "    def test_sysadmin_can_set_id(self):",
            "        user = factories.Sysadmin()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        result = helpers.call_action(",
            "            \"organization_create\",",
            "            context=context,",
            "            name=f\"test-org-{_id}\",",
            "            id=_id",
            "        )",
            "        assert result.get(\"id\") == _id",
            "",
            "    def test_id_cant_already_exist(self):",
            "        user = factories.Sysadmin()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        group = factories.Group()",
            "        with pytest.raises(logic.ValidationError) as exception:",
            "            helpers.call_action(",
            "                \"group_create\",",
            "                id=group.pop(\"id\"),",
            "                context=context,",
            "                name=group.pop(\"name\")",
            "            )",
            "        assert \"Id already exists\" in str(exception.value)",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestUserCreate(object):",
            "    def test_user_create_with_password_hash(self):",
            "        sysadmin = factories.Sysadmin()",
            "        context = {\"user\": sysadmin[\"name\"]}",
            "",
            "        user = helpers.call_action(",
            "            \"user_create\",",
            "            context=context,",
            "            email=factories.User.stub().email,",
            "            name=factories.User.stub().name,",
            "            password_hash=\"pretend-this-is-a-valid-hash\",",
            "        )",
            "",
            "        user_obj = model.User.get(user[\"id\"])",
            "        assert user_obj.password == \"pretend-this-is-a-valid-hash\"",
            "",
            "    @pytest.mark.ckan_config(\"ckan.auth.create_user_via_web\", True)",
            "    def test_user_create_password_hash_not_for_normal_users(self):",
            "        normal_user = factories.User()",
            "        context = {\"user\": normal_user[\"name\"], \"ignore_auth\": False}",
            "",
            "        user = helpers.call_action(",
            "            \"user_create\",",
            "            context=context,",
            "            email=factories.User.stub().email,",
            "            name=factories.User.stub().name,",
            "            password=\"required\",",
            "            password_hash=\"pretend-this-is-a-valid-hash\",",
            "        )",
            "",
            "        user_obj = model.User.get(user[\"id\"])",
            "        assert user_obj.password != \"pretend-this-is-a-valid-hash\"",
            "",
            "    def test_user_create_basic_fields(self):",
            "        email = factories.User.stub().email",
            "        name = factories.User.stub().name",
            "        user = helpers.call_action(",
            "            \"user_create\",",
            "            email=email,",
            "            name=name,",
            "            password=\"required\",",
            "        )",
            "        assert user[\"email\"] == email",
            "        assert user[\"name\"] == name",
            "        assert \"password\" not in user",
            "",
            "    def test_user_create_parameters_missing(self):",
            "        with pytest.raises(logic.ValidationError) as err:",
            "            helpers.call_action(\"user_create\")",
            "        assert err.value.error_dict == {",
            "            \"email\": [\"Missing value\"],",
            "            \"name\": [\"Missing value\"],",
            "            \"password\": [\"Missing value\"],",
            "        }",
            "",
            "    def test_user_create_wrong_password(self):",
            "        stub = factories.User.stub()",
            "        user_dict = {",
            "            \"name\": stub.name,",
            "            \"email\": stub.email,",
            "            \"password\": \"tes\",",
            "        }  # Too short",
            "",
            "        with pytest.raises(logic.ValidationError) as err:",
            "            helpers.call_action(\"user_create\", **user_dict)",
            "        assert err.value.error_dict == {",
            "            \"password\": [\"Your password must be 8 characters or longer\"]",
            "        }",
            "",
            "    def test_user_create_defer_commit(self):",
            "        stub = factories.User.stub()",
            "        user_dict = {",
            "            \"name\": stub.name,",
            "            \"email\": stub.email,",
            "            \"password\": \"test1234\",",
            "        }",
            "        context = {\"defer_commit\": True}",
            "",
            "        helpers.call_action(\"user_create\", context=context, **user_dict)",
            "",
            "        model.Session.close()",
            "",
            "        with pytest.raises(logic.NotFound):",
            "            helpers.call_action(\"user_show\", id=user_dict[\"name\"])",
            "",
            "    def test_create_user_with_apitoken(self):",
            "        stub = factories.User.stub()",
            "        context = {\"ignore_auth\": True}",
            "        user_dict = {",
            "            \"name\": stub.name,",
            "            \"email\": stub.email,",
            "            \"password\": \"test1234\",",
            "            \"with_apitoken\": True",
            "        }",
            "        user = helpers.call_action(\"user_create\", context={}, **user_dict)",
            "        assert user[\"token\"]",
            "",
            "        user_dict = {\"user_id\": user[\"name\"]}",
            "        token = helpers.call_action(",
            "            \"api_token_list\", context=context, **user_dict",
            "        )",
            "        assert len(token) == 1",
            "",
            "    def test_create_user_with_apitoken_missing_flag(self):",
            "        stub = factories.User.stub()",
            "        context = {\"ignore_auth\": True}",
            "        user_dict = {",
            "            \"name\": stub.name,",
            "            \"email\": stub.email,",
            "            \"password\": \"test1234\",",
            "        }",
            "        user = helpers.call_action(\"user_create\", context={}, **user_dict)",
            "        assert \"token\" not in user",
            "",
            "        user_dict = {\"user_id\": user[\"name\"]}",
            "        token = helpers.call_action(",
            "            \"api_token_list\", context=context, **user_dict",
            "        )",
            "        assert not token",
            "",
            "    def test_user_create_fails_with_duplicate_email_case_insensitive(self):",
            "        factories.User(email=\"some_email@example.org\")",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"user_create\",",
            "                context={},",
            "                email=\"Some_Email@example.org\",",
            "                name=\"test\",",
            "                password=\"required\",",
            "            )",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\")",
            "@pytest.mark.ckan_config(\"ckan.auth.create_user_via_web\", True)",
            "class TestUserCreateDb():",
            "",
            "    def test_anon_user_create_does_not_update(self):",
            "        user1 = factories.User(about=\"This is user 1\")",
            "        user_dict = {",
            "            \"id\": user1[\"id\"],",
            "            \"name\": \"some_name\",",
            "            \"email\": \"some_email@example.com\",",
            "            \"password\": \"test1234\",",
            "        }",
            "",
            "        context = {",
            "            \"user\": None,",
            "            \"ignore_auth\": False,",
            "        }",
            "",
            "        user2 = helpers.call_action(\"user_create\", context=context, **user_dict)",
            "        assert user2[\"id\"] != user1[\"id\"]",
            "        assert user2[\"about\"] != \"This is user 1\"",
            "",
            "    def test_normal_user_create_does_not_update(self):",
            "        user1 = factories.User(about=\"This is user 1\")",
            "        user_dict = {",
            "            \"id\": user1[\"id\"],",
            "            \"name\": \"some_name\",",
            "            \"email\": \"some_email@example.com\",",
            "            \"password\": \"test1234\",",
            "        }",
            "",
            "        context = {",
            "            \"user\": factories.User()[\"name\"],",
            "            \"ignore_auth\": False,",
            "        }",
            "",
            "        user2 = helpers.call_action(\"user_create\", context=context, **user_dict)",
            "        assert user2[\"id\"] != user1[\"id\"]",
            "        assert user2[\"about\"] != \"This is user 1\"",
            "",
            "    def test_sysadmin_user_create_does_not_update(self):",
            "        user1 = factories.User(about=\"This is user 1\")",
            "        user_dict = {",
            "            \"id\": user1[\"id\"],",
            "            \"name\": \"some_name\",",
            "            \"email\": \"some_email@example.com\",",
            "            \"password\": \"test1234\",",
            "        }",
            "",
            "        context = {",
            "            \"user\": factories.Sysadmin()[\"name\"],",
            "            \"ignore_auth\": False,",
            "        }",
            "",
            "        user2 = helpers.call_action(\"user_create\", context=context, **user_dict)",
            "        assert user2[\"id\"] != user1[\"id\"]",
            "        assert user2[\"about\"] != \"This is user 1\"",
            "",
            "    def test_anon_users_can_not_provide_custom_id(self):",
            "",
            "        user_dict = {",
            "            \"id\": \"custom_id\",",
            "            \"name\": \"some_name\",",
            "            \"email\": \"some_email@example.com\",",
            "            \"password\": \"test1234\",",
            "        }",
            "",
            "        context = {",
            "            \"user\": None,",
            "            \"ignore_auth\": False,",
            "        }",
            "",
            "        user = helpers.call_action(\"user_create\", context=context, **user_dict)",
            "        assert user[\"id\"] != \"custom_id\"",
            "",
            "    def test_normal_users_can_not_provide_custom_id(self):",
            "",
            "        user_dict = {",
            "            \"id\": \"custom_id\",",
            "            \"name\": \"some_name\",",
            "            \"email\": \"some_email@example.com\",",
            "            \"password\": \"test1234\",",
            "        }",
            "",
            "        context = {",
            "            \"user\": factories.User()[\"name\"],",
            "            \"ignore_auth\": False,",
            "        }",
            "",
            "        user = helpers.call_action(\"user_create\", context=context, **user_dict)",
            "        assert user[\"id\"] != \"custom_id\"",
            "",
            "    def test_sysadmin_can_provide_custom_id(self):",
            "        _id = str(uuid.uuid4())",
            "        user_dict = {",
            "            \"id\": _id,",
            "            \"name\": \"some_name\",",
            "            \"email\": \"some_email@example.com\",",
            "            \"password\": \"test1234\",",
            "        }",
            "        context = {",
            "            \"user\": factories.Sysadmin()[\"name\"],",
            "            \"ignore_auth\": False,",
            "        }",
            "",
            "        user = helpers.call_action(\"user_create\", context=context, **user_dict)",
            "        assert user[\"id\"] == _id",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestFollowCommon(object):",
            "    def test_validation(self):",
            "        user = factories.User()",
            "        unfollow_actions = (",
            "            \"unfollow_user\",",
            "            \"unfollow_dataset\",",
            "            \"unfollow_group\",",
            "        )",
            "        follow_actions = (\"follow_user\", \"follow_dataset\", \"follow_group\")",
            "        count_actions = (",
            "            \"user_follower_count\",",
            "            \"dataset_follower_count\",",
            "            \"group_follower_count\",",
            "        )",
            "        list_actions = (",
            "            \"user_follower_list\",",
            "            \"dataset_follower_list\",",
            "            \"group_follower_list\",",
            "        )",
            "        my_actions = (",
            "            \"am_following_dataset\",",
            "            \"am_following_user\",",
            "            \"am_following_group\",",
            "        )",
            "        for action in (",
            "            follow_actions",
            "            + unfollow_actions",
            "            + count_actions",
            "            + list_actions",
            "            + my_actions",
            "        ):",
            "            for object_id in (\"bad id\", \"     \", 3, 35.7, \"xxx\", None, \"\"):",
            "                with pytest.raises(logic.ValidationError):",
            "                    context = {\"user\": user[\"name\"]}",
            "                    helpers.call_action(action, context, id=object_id)",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestFollowDataset(object):",
            "    def test_auth(self):",
            "        user = factories.User()",
            "        dataset = factories.Dataset()",
            "        context = {\"user\": \"\", \"ignore_auth\": False}",
            "        with pytest.raises(logic.NotAuthorized):",
            "            helpers.call_action(\"follow_dataset\", context, id=dataset[\"id\"])",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        helpers.call_action(\"follow_dataset\", context, id=dataset[\"id\"])",
            "",
            "    def test_follow_dataset(self):",
            "        user = factories.User()",
            "        dataset = factories.Dataset()",
            "        context = {\"user\": user[\"name\"]}",
            "        assert (",
            "            helpers.call_action(\"dataset_follower_count\", id=dataset[\"id\"])",
            "            == 0",
            "        )",
            "        assert (",
            "            helpers.call_action(\"dataset_follower_list\", id=dataset[\"id\"])",
            "            == []",
            "        )",
            "        assert not helpers.call_action(",
            "            \"am_following_dataset\", context, id=dataset[\"id\"]",
            "        )",
            "",
            "        helpers.call_action(\"follow_dataset\", context, id=dataset[\"id\"])",
            "        assert (",
            "            helpers.call_action(\"dataset_follower_count\", id=dataset[\"id\"])",
            "            == 1",
            "        )",
            "        assert [",
            "            u[\"name\"]",
            "            for u in helpers.call_action(",
            "                \"dataset_follower_list\", id=dataset[\"id\"]",
            "            )",
            "        ] == [user[\"name\"]]",
            "        assert helpers.call_action(",
            "            \"am_following_dataset\", context, id=dataset[\"id\"]",
            "        )",
            "",
            "        helpers.call_action(\"unfollow_dataset\", context, id=dataset[\"id\"])",
            "        assert (",
            "            helpers.call_action(\"dataset_follower_count\", id=dataset[\"id\"])",
            "            == 0",
            "        )",
            "        assert (",
            "            helpers.call_action(\"dataset_follower_list\", id=dataset[\"id\"])",
            "            == []",
            "        )",
            "        assert not helpers.call_action(",
            "            \"am_following_dataset\", context, id=dataset[\"id\"]",
            "        )",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestFollowGroup(object):",
            "    def test_auth(self):",
            "        user = factories.User()",
            "        group = factories.Group()",
            "        context = {\"user\": \"\", \"ignore_auth\": False}",
            "        with pytest.raises(logic.NotAuthorized):",
            "            helpers.call_action(\"follow_group\", context, id=group[\"id\"])",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        helpers.call_action(\"follow_group\", context, id=group[\"id\"])",
            "",
            "    def test_follow_group(self):",
            "        user = factories.User()",
            "        group = factories.Group()",
            "        context = {\"user\": user[\"name\"]}",
            "        assert helpers.call_action(\"group_follower_count\", id=group[\"id\"]) == 0",
            "        assert helpers.call_action(\"group_follower_list\", id=group[\"id\"]) == []",
            "        assert not helpers.call_action(",
            "            \"am_following_group\", context, id=group[\"id\"]",
            "        )",
            "",
            "        helpers.call_action(\"follow_group\", context, id=group[\"id\"])",
            "        assert helpers.call_action(\"group_follower_count\", id=group[\"id\"]) == 1",
            "        assert [",
            "            u[\"name\"]",
            "            for u in helpers.call_action(\"group_follower_list\", id=group[\"id\"])",
            "        ] == [user[\"name\"]]",
            "        assert helpers.call_action(",
            "            \"am_following_group\", context, id=group[\"id\"]",
            "        )",
            "",
            "        helpers.call_action(\"unfollow_group\", context, id=group[\"id\"])",
            "        assert helpers.call_action(\"group_follower_count\", id=group[\"id\"]) == 0",
            "        assert helpers.call_action(\"group_follower_list\", id=group[\"id\"]) == []",
            "        assert not helpers.call_action(",
            "            \"am_following_group\", context, id=group[\"id\"]",
            "        )",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestFollowOrganization(object):",
            "    def test_auth(self):",
            "        user = factories.User()",
            "        organization = factories.Organization()",
            "        context = {\"user\": \"\", \"ignore_auth\": False}",
            "        with pytest.raises(logic.NotAuthorized):",
            "            helpers.call_action(\"follow_group\", context, id=organization[\"id\"])",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        helpers.call_action(\"follow_group\", context, id=organization[\"id\"])",
            "",
            "    def test_follow_organization(self):",
            "        user = factories.User()",
            "        group = factories.Organization()",
            "        context = {\"user\": user[\"name\"]}",
            "        assert helpers.call_action(\"group_follower_count\", id=group[\"id\"]) == 0",
            "        assert helpers.call_action(\"group_follower_list\", id=group[\"id\"]) == []",
            "        assert not helpers.call_action(",
            "            \"am_following_group\", context, id=group[\"id\"]",
            "        )",
            "",
            "        helpers.call_action(\"follow_group\", context, id=group[\"id\"])",
            "        assert helpers.call_action(\"group_follower_count\", id=group[\"id\"]) == 1",
            "        assert [",
            "            u[\"name\"]",
            "            for u in helpers.call_action(\"group_follower_list\", id=group[\"id\"])",
            "        ] == [user[\"name\"]]",
            "        assert helpers.call_action(",
            "            \"am_following_group\", context, id=group[\"id\"]",
            "        )",
            "",
            "        helpers.call_action(\"unfollow_group\", context, id=group[\"id\"])",
            "        assert helpers.call_action(\"group_follower_count\", id=group[\"id\"]) == 0",
            "        assert helpers.call_action(\"group_follower_list\", id=group[\"id\"]) == []",
            "        assert not helpers.call_action(",
            "            \"am_following_group\", context, id=group[\"id\"]",
            "        )",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestFollowUser(object):",
            "    def test_auth(self):",
            "        user = factories.User()",
            "        second_user = factories.User()",
            "",
            "        context = {\"user\": \"\", \"ignore_auth\": False}",
            "        with pytest.raises(logic.NotAuthorized):",
            "            helpers.call_action(\"follow_user\", context, id=second_user[\"id\"])",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        helpers.call_action(\"follow_user\", context, id=second_user[\"id\"])",
            "",
            "    def test_cannot_follow_myself(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"]}",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"follow_user\", context, id=user[\"id\"])",
            "",
            "    def test_follow_user(self):",
            "        user = factories.User()",
            "        another_user = factories.User()",
            "        context = {\"user\": user[\"name\"]}",
            "        assert (",
            "            helpers.call_action(\"user_follower_count\", id=another_user[\"id\"])",
            "            == 0",
            "        )",
            "        assert (",
            "            helpers.call_action(\"user_follower_list\", id=another_user[\"id\"])",
            "            == []",
            "        )",
            "        assert not helpers.call_action(",
            "            \"am_following_user\", context, id=another_user[\"id\"]",
            "        )",
            "",
            "        helpers.call_action(\"follow_user\", context, id=another_user[\"id\"])",
            "        assert (",
            "            helpers.call_action(\"user_follower_count\", id=another_user[\"id\"])",
            "            == 1",
            "        )",
            "        assert [",
            "            u[\"name\"]",
            "            for u in helpers.call_action(",
            "                \"user_follower_list\", id=another_user[\"id\"]",
            "            )",
            "        ] == [user[\"name\"]]",
            "        assert helpers.call_action(",
            "            \"am_following_user\", context, id=another_user[\"id\"]",
            "        )",
            "",
            "        helpers.call_action(\"unfollow_user\", context, id=another_user[\"id\"])",
            "        assert (",
            "            helpers.call_action(\"user_follower_count\", id=another_user[\"id\"])",
            "            == 0",
            "        )",
            "        assert (",
            "            helpers.call_action(\"user_follower_list\", id=another_user[\"id\"])",
            "            == []",
            "        )",
            "        assert not helpers.call_action(",
            "            \"am_following_user\", context, id=another_user[\"id\"]",
            "        )",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestApiToken(object):",
            "    def test_token_created(self):",
            "        from ckan.lib.api_token import decode",
            "",
            "        user = factories.User()",
            "        data = helpers.call_action(",
            "            u\"api_token_create\",",
            "            context={u\"model\": model, u\"user\": user[u\"name\"]},",
            "            user=user[u\"name\"],",
            "            name=u\"token-name\",",
            "        )",
            "        token = data[u\"token\"]",
            "        jti = decode(token)[u\"jti\"]",
            "        res = model.ApiToken.get(jti)",
            "        assert res.user_id == user[u\"id\"]",
            "        assert res.last_access is None",
            "        assert res.id == jti",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "@pytest.mark.ckan_config(\"ckan.auth.allow_dataset_collaborators\", False)",
            "def test_create_package_collaborator_when_config_disabled():",
            "",
            "    dataset = factories.Dataset()",
            "    user = factories.User()",
            "    capacity = \"editor\"",
            "",
            "    with pytest.raises(logic.ValidationError):",
            "        helpers.call_action(",
            "            \"package_collaborator_create\",",
            "            id=dataset[\"id\"],",
            "            user_id=user[\"id\"],",
            "            capacity=capacity,",
            "        )",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "@pytest.mark.ckan_config(\"ckan.auth.allow_dataset_collaborators\", True)",
            "class TestPackageMemberCreate(object):",
            "    def test_create(self):",
            "        initial = model.Session.query(model.PackageMember).count()",
            "        dataset = factories.Dataset()",
            "        user = factories.User()",
            "        capacity = \"editor\"",
            "",
            "        member = helpers.call_action(",
            "            \"package_collaborator_create\",",
            "            id=dataset[\"id\"],",
            "            user_id=user[\"id\"],",
            "            capacity=capacity,",
            "        )",
            "",
            "        assert member[\"package_id\"] == dataset[\"id\"]",
            "        assert member[\"user_id\"] == user[\"id\"]",
            "        assert member[\"capacity\"] == capacity",
            "",
            "        assert model.Session.query(model.PackageMember).count() == initial + 1",
            "",
            "    def test_update(self):",
            "        dataset = factories.Dataset()",
            "        user = factories.User()",
            "        capacity = \"editor\"",
            "",
            "        helpers.call_action(",
            "            \"package_collaborator_create\",",
            "            id=dataset[\"id\"],",
            "            user_id=user[\"id\"],",
            "            capacity=capacity,",
            "        )",
            "",
            "        helpers.call_action(",
            "            \"package_collaborator_create\",",
            "            id=dataset[\"id\"],",
            "            user_id=user[\"id\"],",
            "            capacity=\"member\",",
            "        )",
            "",
            "        assert (",
            "            model.Session.query(model.PackageMember)",
            "            .filter_by(package_id=dataset[\"id\"])",
            "            .one()",
            "            .capacity",
            "            == \"member\"",
            "        )",
            "",
            "    def test_create_wrong_capacity(self):",
            "        dataset = factories.Dataset()",
            "        user = factories.User()",
            "        capacity = \"unknown\"",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"package_collaborator_create\",",
            "                id=dataset[\"id\"],",
            "                user_id=user[\"id\"],",
            "                capacity=capacity,",
            "            )",
            "",
            "    def test_create_dataset_not_found(self):",
            "        dataset = {\"id\": \"xxx\"}",
            "        user = factories.User()",
            "        capacity = \"editor\"",
            "",
            "        with pytest.raises(logic.NotFound):",
            "            helpers.call_action(",
            "                \"package_collaborator_create\",",
            "                id=dataset[\"id\"],",
            "                user_id=user[\"id\"],",
            "                capacity=capacity,",
            "            )",
            "",
            "    def test_create_user_not_found(self):",
            "        dataset = factories.Dataset()",
            "        user = {\"id\": \"yyy\"}",
            "        capacity = \"editor\"",
            "",
            "        with pytest.raises(logic.NotFound):",
            "            helpers.call_action(",
            "                \"package_collaborator_create\",",
            "                id=dataset[\"id\"],",
            "                user_id=user[\"id\"],",
            "                capacity=capacity,",
            "            )",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "@pytest.mark.ckan_config(\"ckan.auth.create_user_via_web\", True)",
            "class TestUserPluginExtras(object):",
            "    def test_stored_on_create_if_sysadmin(self):",
            "",
            "        sysadmin = factories.Sysadmin()",
            "        stub = factories.User.stub()",
            "        user_dict = {",
            "            \"name\": stub.name,",
            "            \"email\": stub.email,",
            "            \"password\": \"12345678\",",
            "            \"plugin_extras\": {\"plugin1\": {\"key1\": \"value1\"}},",
            "        }",
            "",
            "        # helpers.call_action sets 'ignore_auth' to True by default",
            "        context = {\"user\": sysadmin[\"name\"], \"ignore_auth\": False}",
            "",
            "        created_user = helpers.call_action(",
            "            \"user_create\", context=context, **user_dict",
            "        )",
            "",
            "        assert created_user[\"plugin_extras\"] == {",
            "            \"plugin1\": {",
            "                \"key1\": \"value1\",",
            "            }",
            "        }",
            "",
            "        user_dict = helpers.call_action(",
            "            \"user_show\",",
            "            context=context,",
            "            id=created_user[\"id\"],",
            "            include_plugin_extras=True,",
            "        )",
            "",
            "        assert user_dict[\"plugin_extras\"] == {",
            "            \"plugin1\": {",
            "                \"key1\": \"value1\",",
            "            }",
            "        }",
            "",
            "        plugin_extras_from_db = (",
            "            model.Session.execute(",
            "                sa.text('SELECT plugin_extras FROM \"user\" WHERE id=:id'),",
            "                {\"id\": created_user[\"id\"]},",
            "            )",
            "            .first()[0]",
            "        )",
            "",
            "        assert plugin_extras_from_db == {",
            "            \"plugin1\": {",
            "                \"key1\": \"value1\",",
            "            }",
            "        }",
            "",
            "    def test_ignored_on_create_if_non_sysadmin(self):",
            "",
            "        author = factories.User()",
            "        sysadmin = factories.Sysadmin()",
            "        stub = factories.User.stub()",
            "        user_dict = {",
            "            \"name\": stub.name,",
            "            \"email\": stub.email,",
            "            \"password\": \"12345678\",",
            "            \"plugin_extras\": {\"plugin1\": {\"key1\": \"value1\"}},",
            "        }",
            "",
            "        # helpers.call_action sets 'ignore_auth' to True by default",
            "        context = {\"user\": author[\"name\"], \"ignore_auth\": False}",
            "",
            "        created_user = helpers.call_action(",
            "            \"user_create\", context=context, **user_dict",
            "        )",
            "",
            "        assert \"plugin_extras\" not in created_user",
            "",
            "        context = {\"user\": sysadmin[\"name\"], \"ignore_auth\": False}",
            "        user = helpers.call_action(",
            "            \"user_show\",",
            "            context=context,",
            "            id=created_user[\"id\"],",
            "            include_plugin_extras=True,",
            "        )",
            "",
            "        assert user[\"plugin_extras\"] is None",
            "",
            "    def test_extensions_can_provide_custom_id(self):",
            "",
            "        stub = factories.User.stub()",
            "        context = {\"user\": None, \"ignore_auth\": True}",
            "        _id = str(uuid.uuid4())",
            "        user_dict = {",
            "            \"id\": _id,",
            "            \"name\": stub.name,",
            "            \"email\": stub.email,",
            "            \"password\": \"12345678\",",
            "        }",
            "        created_user = helpers.call_action(\"user_create\", context=context, **user_dict)",
            "",
            "        assert created_user[\"id\"] == _id",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestUserImageUrl(object):",
            "    def test_external_picture(self):",
            "        stub = factories.User.stub()",
            "        params = {",
            "            \"name\": stub.name,",
            "            \"email\": stub.email,",
            "            \"password\": \"12345678\",",
            "            \"image_url\": \"https://example.com/mypic.png\",",
            "        }",
            "",
            "        user_dict = helpers.call_action(\"user_create\", {}, **params)",
            "",
            "        assert user_dict[\"image_url\"] == \"https://example.com/mypic.png\"",
            "        assert (",
            "            user_dict[\"image_display_url\"] == \"https://example.com/mypic.png\"",
            "        )",
            "",
            "    def test_upload_picture_works_without_extra_config(",
            "            self, create_with_upload, faker):",
            "        params = {",
            "            \"name\": faker.user_name(),",
            "            \"email\": faker.email(),",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        assert create_with_upload(faker.image(), \"image.png\", **params)",
            "",
            "    def test_upload_non_picture_fails_without_extra_config(",
            "            self, create_with_upload, faker):",
            "        params = {",
            "            \"name\": faker.user_name(),",
            "            \"email\": faker.email(),",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        with pytest.raises(",
            "                logic.ValidationError, match=\"Unsupported upload type\"):",
            "            create_with_upload(\"hello world\", \"file.txt\", **params)",
            "",
            "    def test_upload_non_picture_html_fails_without_extra_config(",
            "            self, create_with_upload, faker):",
            "        params = {",
            "            \"name\": faker.user_name(),",
            "            \"email\": faker.email(),",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        with pytest.raises(",
            "                logic.ValidationError, match=\"Unsupported upload type\"):",
            "            create_with_upload(\"<html><body>hello world</body></html>\", \"file.html\", **params)",
            "",
            "    def test_upload_svg_fails_without_extra_config(",
            "            self, create_with_upload, faker):",
            "        params = {",
            "            \"name\": faker.user_name(),",
            "            \"email\": faker.email(),",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        with pytest.raises(",
            "                logic.ValidationError, match=\"Unsupported upload type\"):",
            "            create_with_upload('<svg xmlns=\"http://www.w3.org/2000/svg\"></svg>', \"file.svg\", **params)",
            "",
            "    def test_upload_svg_wrong_extension_fails_without_extra_config(",
            "            self, create_with_upload, faker):",
            "        params = {",
            "            \"name\": faker.user_name(),",
            "            \"email\": faker.email(),",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        with pytest.raises(",
            "                logic.ValidationError, match=\"Unsupported upload type\"):",
            "            create_with_upload('<svg xmlns=\"http://www.w3.org/2000/svg\"></svg>', \"file.png\", **params)",
            "",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"image\")",
            "    def test_upload_non_picture_with_png_extension(",
            "            self, create_with_upload, faker):",
            "        params = {",
            "            \"name\": faker.user_name(),",
            "            \"email\": faker.email(),",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        with pytest.raises(",
            "                logic.ValidationError, match=\"Unsupported upload type\"):",
            "            create_with_upload(\"hello world\", \"file.png\", **params)",
            "",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"image\")",
            "    def test_upload_picture(self, create_with_upload, faker):",
            "        params = {",
            "            \"name\": faker.user_name(),",
            "            \"email\": faker.email(),",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        assert create_with_upload(faker.image(), \"file.png\", **params)",
            "",
            "",
            "class TestVocabularyCreate(object):",
            "    @pytest.mark.usefixtures(\"non_clean_db\")",
            "    def test_basic(self):",
            "        name = factories.Vocabulary.stub().name",
            "        vocab = helpers.call_action(\"vocabulary_create\", name=name)",
            "        obj = model.Vocabulary.get(name)",
            "        assert obj.id == vocab[\"id\"]",
            "",
            "    @pytest.mark.usefixtures(\"non_clean_db\")",
            "    def test_with_tags(self):",
            "        name = factories.Vocabulary.stub().name",
            "        tag1 = factories.Tag.stub().name",
            "        tag2 = factories.Tag.stub().name",
            "        tags = [{\"name\": tag1}, {\"name\": tag2}]",
            "        helpers.call_action(\"vocabulary_create\", name=name, tags=tags)",
            "        vocab = helpers.call_action(\"vocabulary_show\", id=name)",
            "        assert vocab[\"name\"] == name",
            "        assert len(vocab[\"tags\"]) == 2",
            "        for tag in vocab[\"tags\"]:",
            "            assert tag[\"vocabulary_id\"] == vocab[\"id\"]",
            "            assert tag[\"name\"] in {tag1, tag2}",
            "",
            "    @pytest.mark.usefixtures(\"non_clean_db\")",
            "    def test_with_empty_tags(self):",
            "        name = factories.Vocabulary.stub().name",
            "        resp = helpers.call_action(\"vocabulary_create\", name=name, tags=[])",
            "        assert resp[\"tags\"] == []",
            "",
            "    @pytest.mark.usefixtures(\"non_clean_db\")",
            "    def test_with_existing_name(self):",
            "        name = factories.Vocabulary.stub().name",
            "        helpers.call_action(\"vocabulary_create\", name=name, tags=[])",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"vocabulary_create\", name=name, tags=[])",
            "",
            "    @pytest.mark.parametrize(",
            "        \"tags\",",
            "        [",
            "            [{\"id\": \"xxx\"}, {\"name\": \"foo\"}],",
            "            [{\"name\": \"foo\"}, {\"name\": None}],",
            "            [{\"name\": \"foo\"}, {\"name\": \"\"}],",
            "            [{\"name\": \"foo\"}, {\"name\": \"f\"}],",
            "            [{\"name\": \"f\" * 200}, {\"name\": \"foo\"}],",
            "            [{\"name\": \"Invalid!\"}, {\"name\": \"foo\"}],",
            "        ],",
            "    )",
            "    def test_with_bad_tags(self, tags):",
            "        name = factories.Vocabulary.stub().name",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"vocabulary_create\", name=name, tags=tags)",
            "",
            "    def test_with_no_tags(self):",
            "        name = factories.Vocabulary.stub().name",
            "        with pytest.raises(DataError):",
            "            helpers.call_action(\"vocabulary_create\", name=name, tags=None)",
            "",
            "    def test_id_not_allowed(self):",
            "        name = factories.Vocabulary.stub().name",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"vocabulary_create\", name=name, id=\"xxx\")",
            "",
            "    def test_no_name(self):",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"vocabulary_create\")",
            "",
            "    @pytest.mark.parametrize(\"name\", (None, \"\", \"a\", \"foobar\" * 100))",
            "    def test_invalid_name(self, name):",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"vocabulary_create\", name=name)",
            "",
            "",
            "class TestTagCreate:",
            "    @pytest.mark.usefixtures(\"non_clean_db\")",
            "    def test_add_tag_to_vocab(self):",
            "        tag1 = factories.Tag.stub().name",
            "        tag2 = factories.Tag.stub().name",
            "        vocab = factories.Vocabulary(tags=[{\"name\": tag1}])",
            "        assert set(map(operator.itemgetter(\"name\"), vocab[\"tags\"])) == {tag1}",
            "        helpers.call_action(\"tag_create\", name=tag2, vocabulary_id=vocab[\"id\"])",
            "",
            "        vocab = helpers.call_action(\"vocabulary_show\", id=vocab[\"id\"])",
            "        assert set(map(operator.itemgetter(\"name\"), vocab[\"tags\"])) == {",
            "            tag1,",
            "            tag2,",
            "        }",
            "",
            "    def test_no_vocab(self):",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"tag_create\", name=factories.Tag.stub().name)",
            "",
            "    def test_does_not_exist(self):",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"tag_create\",",
            "                name=factories.Tag.stub().name,",
            "                vocabulary_id=factories.Vocabulary.stub().name,",
            "            )",
            "",
            "    @pytest.mark.usefixtures(\"non_clean_db\")",
            "    def test_duplicate(self):",
            "        tag1 = factories.Tag.stub().name",
            "        vocab = factories.Vocabulary(tags=[{\"name\": tag1}])",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"tag_create\", name=tag1, vocabulary_id=vocab[\"id\"]",
            "            )",
            "",
            "    @pytest.mark.usefixtures(\"non_clean_db\")",
            "    def test_id_not_allowed(self):",
            "        vocab = factories.Vocabulary()",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"tag_create\", name=\"foo\", id=\"xxx\", vocabulary_id=vocab[\"id\"]",
            "            )",
            "",
            "    @pytest.mark.usefixtures(\"non_clean_db\")",
            "    def test_name_is_required(self):",
            "        vocab = factories.Vocabulary()",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"tag_create\", vocabulary_id=vocab[\"id\"])",
            "",
            "    @pytest.mark.usefixtures(\"non_clean_db\")",
            "    def test_invalid_name(self):",
            "        vocab = factories.Vocabulary()",
            "        for name in (\"Not a valid tag name!\", \"\", None):",
            "            with pytest.raises(logic.ValidationError):",
            "                helpers.call_action(",
            "                    \"tag_create\", name=name, vocabulary_id=vocab[\"id\"]",
            "                )",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestMemberCreate2:",
            "    def test_member_create_accepts_object_name_or_id(self):",
            "        org = factories.Organization()",
            "        package = factories.Dataset()",
            "        helpers.call_action(",
            "            \"member_create\",",
            "            object=package[\"id\"],",
            "            id=org[\"id\"],",
            "            object_type=\"package\",",
            "            capacity=\"member\",",
            "        )",
            "        helpers.call_action(",
            "            \"member_create\",",
            "            object=package[\"name\"],",
            "            id=org[\"id\"],",
            "            object_type=\"package\",",
            "            capacity=\"member\",",
            "        )",
            "",
            "    def test_member_create_raises_if_user_unauthorized_to_update_group(self):",
            "        org = factories.Organization()",
            "        pkg = factories.Dataset()",
            "        user = factories.User()",
            "        context = {\"ignore_auth\": False, \"user\": user[\"name\"]}",
            "        with pytest.raises(logic.NotAuthorized):",
            "            helpers.call_action(",
            "                \"member_create\",",
            "                context,",
            "                object=pkg[\"name\"],",
            "                id=org[\"id\"],",
            "                object_type=\"package\",",
            "                capacity=\"member\",",
            "            )",
            "",
            "    def test_member_create_raises_if_any_required_parameter_isnt_defined(self):",
            "        org = factories.Organization()",
            "        pkg = factories.Dataset()",
            "        data = dict(",
            "            object=pkg[\"name\"],",
            "            id=org[\"id\"],",
            "            object_type=\"package\",",
            "            capacity=\"member\",",
            "        )",
            "        for key in [\"id\", \"object\", \"object_type\"]:",
            "            payload = data.copy()",
            "            payload.pop(key)",
            "            with pytest.raises(logic.ValidationError):",
            "                helpers.call_action(\"member_create\", **payload)",
            "",
            "    def test_member_create_raises_if_group_wasnt_found(self):",
            "        pkg = factories.Dataset()",
            "        with pytest.raises(logic.NotFound):",
            "            helpers.call_action(",
            "                \"member_create\",",
            "                object=pkg[\"name\"],",
            "                id=\"not-real\",",
            "                object_type=\"package\",",
            "                capacity=\"member\",",
            "            )",
            "",
            "    def test_member_create_raises_if_object_wasnt_found(self):",
            "        org = factories.Organization()",
            "        with pytest.raises(logic.NotFound):",
            "            helpers.call_action(",
            "                \"member_create\",",
            "                object=\"not-real\",",
            "                id=org[\"id\"],",
            "                object_type=\"package\",",
            "                capacity=\"member\",",
            "            )",
            "",
            "    def test_member_create_raises_if_object_type_is_invalid(self):",
            "        org = factories.Organization()",
            "        pkg = factories.Dataset()",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"member_create\",",
            "                object=pkg[\"name\"],",
            "                id=org[\"id\"],",
            "                object_type=\"notvalid\",",
            "                capacity=\"member\",",
            "            )",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\")",
            "class TestPackagePluginData(object):",
            "",
            "    def test_stored_on_create_if_sysadmin(self):",
            "        sysadmin = factories.Sysadmin()",
            "",
            "        pkg_dict = {",
            "            \"name\": \"test-dataset\",",
            "            \"plugin_data\": {",
            "                \"plugin1\": {",
            "                    \"key1\": \"value1\"",
            "                }",
            "            }",
            "        }",
            "        context = {",
            "            \"user\": sysadmin[\"name\"],",
            "            \"ignore_auth\": False,",
            "            \"auth_user_obj\": model.User.get(sysadmin[\"name\"])",
            "        }",
            "        created_pkg = helpers.call_action(",
            "            \"package_create\", context=context, **pkg_dict",
            "        )",
            "        assert created_pkg[\"plugin_data\"] == {",
            "            \"plugin1\": {",
            "                \"key1\": \"value1\"",
            "            }",
            "        }",
            "        plugin_data_from_db = model.Session.execute(",
            "            sa.text('SELECT plugin_data FROM \"package\" WHERE id=:id'),",
            "            {'id': created_pkg[\"id\"]}",
            "        ).first()[0]",
            "",
            "        assert plugin_data_from_db == {\"plugin1\": {\"key1\": \"value1\"}}",
            "",
            "    def test_ignored_on_create_if_non_sysadmin(self):",
            "        user = factories.User()",
            "",
            "        pkg_dict = {",
            "            \"name\": \"test-dataset\",",
            "            \"plugin_data\": {",
            "                \"plugin1\": {",
            "                    \"key1\": \"value1\"",
            "                }",
            "            }",
            "        }",
            "        context = {",
            "            \"user\": user[\"name\"],",
            "            \"ignore_auth\": False,",
            "        }",
            "        created_pkg = helpers.call_action(",
            "            'package_create', context=context, **pkg_dict",
            "        )",
            "        assert \"plugin_data\" not in created_pkg",
            "",
            "        plugin_data_from_db = model.Session.execute(",
            "            sa.text('SELECT plugin_data FROM \"package\" WHERE id=:id'),",
            "            {'id': created_pkg[\"id\"]}",
            "        ).first()[0]",
            "        assert plugin_data_from_db is None"
        ],
        "afterPatchFile": [
            "# encoding: utf-8",
            "\"\"\"Unit tests for ckan/logic/action/create.py.",
            "",
            "\"\"\"",
            "import datetime",
            "import operator",
            "import unittest.mock as mock",
            "import uuid",
            "",
            "import pytest",
            "import sqlalchemy as sa",
            "",
            "import ckan.logic as logic",
            "from ckan.logic.action.get import package_show as core_package_show",
            "import ckan.model as model",
            "import ckan.tests.factories as factories",
            "import ckan.tests.helpers as helpers",
            "from ckan.common import config",
            "from ckan.lib.navl.dictization_functions import DataError",
            "",
            "from freezegun import freeze_time",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestUserInvite(object):",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_invited_user_is_created_as_pending(self, _):",
            "        invited_user = self._invite_user_to_group(factories.User.stub().email)",
            "",
            "        assert invited_user is not None",
            "        assert invited_user.is_pending()",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_creates_user_with_valid_username(self, _):",
            "        name = factories.User.stub().name",
            "        email = f\"user$%+abc@{name}.com\"",
            "        invited_user = self._invite_user_to_group(email)",
            "",
            "        assert invited_user.name.startswith(\"user---abc\"), invited_user",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_assigns_user_to_group_in_expected_role(self, _):",
            "        role = \"admin\"",
            "        invited_user = self._invite_user_to_group(",
            "            factories.User.stub().email, role=role",
            "        )",
            "",
            "        group_ids = invited_user.get_group_ids(capacity=role)",
            "        assert len(group_ids) == 1, group_ids",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_sends_invite(self, send_invite):",
            "        invited_user = self._invite_user_to_group(factories.User.stub().email)",
            "",
            "        assert send_invite.called",
            "        assert send_invite.call_args[0][0].id == invited_user.id",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    @mock.patch(\"random.SystemRandom\")",
            "    def test_works_even_if_username_already_exists(self, rand, _):",
            "        # usernames",
            "        rand.return_value.random.side_effect = [1000, 1000, 2000, 3000]",
            "        # passwords (need to set something, otherwise choice will break)",
            "        rand.return_value.choice.side_effect = \"TestPassword1\" * 3",
            "        name = factories.User.stub().name",
            "        for _ in range(3):",
            "            invited_user = self._invite_user_to_group(",
            "                email=\"same{}@{}.com\".format(_, name)",
            "            )",
            "            assert invited_user is not None, invited_user",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_requires_email(self, _):",
            "        with pytest.raises(logic.ValidationError):",
            "            self._invite_user_to_group(email=None)",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_existed_email(self, _):",
            "        factories.User(email=\"email@example.com\")",
            "        with pytest.raises(logic.ValidationError):",
            "            self._invite_user_to_group(email=\"email@example.com\")",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_requires_role(self, _):",
            "        with pytest.raises(logic.ValidationError):",
            "            self._invite_user_to_group(factories.User.stub().email, role=None)",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_raises_not_found(self, _):",
            "        user = factories.User()",
            "",
            "        context = {\"user\": user[\"name\"]}",
            "        params = {",
            "            \"email\": \"a@example.com\",",
            "            \"group_id\": \"group_not_found\",",
            "            \"role\": \"admin\",",
            "        }",
            "        with pytest.raises(logic.NotFound):",
            "            helpers.call_action(\"user_invite\", context, **params)",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_requires_group_id(self, _):",
            "        with pytest.raises(logic.ValidationError):",
            "            self._invite_user_to_group(",
            "                factories.User.stub().email, group={\"id\": None}",
            "            )",
            "",
            "    @mock.patch(\"ckan.lib.mailer.send_invite\")",
            "    def test_user_name_lowercase_when_email_is_uppercase(self, _):",
            "        name = factories.User.stub().name",
            "        invited_user = self._invite_user_to_group(email=f\"Maria@{name}.com\")",
            "",
            "        assert invited_user.name.split(\"-\")[0] == \"maria\"",
            "",
            "    @pytest.mark.ckan_config(\"smtp.server\", \"email.example.com\")",
            "    @pytest.mark.usefixtures(\"with_request_context\")",
            "    def test_smtp_error_returns_error_message(self):",
            "",
            "        sysadmin = factories.Sysadmin()",
            "        group = factories.Group()",
            "",
            "        context = {\"user\": sysadmin[\"name\"]}",
            "        params = {",
            "            \"email\": \"example-invited-user@example.com\",",
            "            \"group_id\": group[\"id\"],",
            "            \"role\": \"editor\",",
            "        }",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"user_invite\", context, **params)",
            "",
            "        # Check that the pending user was deleted",
            "        user = (",
            "            model.Session.query(model.User)",
            "            .filter(model.User.name.like(\"example-invited-user%\"))",
            "            .all()",
            "        )",
            "",
            "        assert user[0].state == \"deleted\"",
            "",
            "    def _invite_user_to_group(self, email, group=None, role=\"member\"):",
            "        user = factories.User()",
            "        group = group or factories.Group(user=user)",
            "",
            "        context = {\"user\": user[\"name\"]}",
            "        params = {\"email\": email, \"group_id\": group[\"id\"], \"role\": role}",
            "",
            "        result = helpers.call_action(\"user_invite\", context, **params)",
            "",
            "        return model.User.get(result[\"id\"])",
            "",
            "",
            "@pytest.mark.ckan_config(\"ckan.plugins\", \"image_view\")",
            "@pytest.mark.usefixtures(\"non_clean_db\", \"with_plugins\")",
            "class TestResourceViewCreate(object):",
            "    def test_resource_view_create(self):",
            "        context = {}",
            "        params = self._default_resource_view_attributes()",
            "",
            "        result = helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "        result.pop(\"id\")",
            "        result.pop(\"package_id\")",
            "",
            "        assert params == result",
            "",
            "    def test_requires_resource_id(self):",
            "        context = {}",
            "        params = self._default_resource_view_attributes()",
            "        params.pop(\"resource_id\")",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    def test_requires_title(self):",
            "        context = {}",
            "        params = self._default_resource_view_attributes()",
            "        params.pop(\"title\")",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    def test_sysadmin_can_set_id(self):",
            "        user = factories.Sysadmin()",
            "        _id = str(uuid.uuid4())",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        params = self._default_resource_view_attributes()",
            "        params[\"id\"] = _id",
            "        result = helpers.call_action(\"resource_view_create\", context=context, **params)",
            "        assert result[\"id\"] == _id",
            "",
            "    def test_normal_user_can_not_set_id(self):",
            "        user = factories.User()",
            "        _id = str(uuid.uuid4())",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        params = self._default_resource_view_attributes()",
            "        params[\"id\"] = _id",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context=context, **params)",
            "",
            "    def test_id_cant_already_exist(self):",
            "        user = factories.Sysadmin()",
            "        resource_view = factories.ResourceView()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        params = self._default_resource_view_attributes()",
            "        params[\"id\"] = resource_view.pop(\"id\")",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context=context, **params)",
            "",
            "    @mock.patch(\"ckan.lib.datapreview.get_view_plugin\")",
            "    def test_requires_view_type(self, get_view_plugin):",
            "        context = {}",
            "        params = self._default_resource_view_attributes()",
            "        params.pop(\"view_type\")",
            "",
            "        get_view_plugin.return_value = \"mock_view_plugin\"",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    def test_raises_if_couldnt_find_resource(self):",
            "        context = {}",
            "        params = self._default_resource_view_attributes(resource_id=\"unknown\")",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    def test_raises_if_couldnt_find_view_extension(self):",
            "        context = {}",
            "        params = self._default_resource_view_attributes(view_type=\"unknown\")",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    @mock.patch(\"ckan.lib.datapreview\")",
            "    def test_filterable_views_dont_require_any_extra_fields(",
            "        self, datapreview_mock",
            "    ):",
            "        self._configure_datapreview_to_return_filterable_view(datapreview_mock)",
            "        context = {}",
            "        params = self._default_resource_view_attributes()",
            "",
            "        result = helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "        result.pop(\"id\")",
            "        result.pop(\"package_id\")",
            "",
            "        assert params == result",
            "",
            "    @mock.patch(\"ckan.lib.datapreview\")",
            "    def test_filterable_views_converts_filter_fields_and_values_into_filters_dict(",
            "        self, datapreview_mock",
            "    ):",
            "        self._configure_datapreview_to_return_filterable_view(datapreview_mock)",
            "        context = {}",
            "        filters = {",
            "            \"filter_fields\": [\"country\", \"weather\", \"country\"],",
            "            \"filter_values\": [\"Brazil\", \"warm\", \"Argentina\"],",
            "        }",
            "        params = self._default_resource_view_attributes(**filters)",
            "        result = helpers.call_action(\"resource_view_create\", context, **params)",
            "        expected_filters = {",
            "            \"country\": [\"Brazil\", \"Argentina\"],",
            "            \"weather\": [\"warm\"],",
            "        }",
            "        assert result[\"filters\"] == expected_filters",
            "",
            "    @mock.patch(\"ckan.lib.datapreview\")",
            "    def test_filterable_views_converts_filter_fields_and_values_to_list(",
            "        self, datapreview_mock",
            "    ):",
            "        self._configure_datapreview_to_return_filterable_view(datapreview_mock)",
            "        context = {}",
            "        filters = {\"filter_fields\": \"country\", \"filter_values\": \"Brazil\"}",
            "        params = self._default_resource_view_attributes(**filters)",
            "        result = helpers.call_action(\"resource_view_create\", context, **params)",
            "        assert result[\"filter_fields\"] == [\"country\"]",
            "        assert result[\"filter_values\"] == [\"Brazil\"]",
            "        assert result[\"filters\"] == {\"country\": [\"Brazil\"]}",
            "",
            "    @mock.patch(\"ckan.lib.datapreview\")",
            "    def test_filterable_views_require_filter_fields_and_values_to_have_same_length(",
            "        self, datapreview_mock",
            "    ):",
            "        self._configure_datapreview_to_return_filterable_view(datapreview_mock)",
            "        context = {}",
            "        filters = {",
            "            \"filter_fields\": [\"country\", \"country\"],",
            "            \"filter_values\": \"Brazil\",",
            "        }",
            "        params = self._default_resource_view_attributes(**filters)",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    def test_non_filterable_views_dont_accept_filter_fields_and_values(self):",
            "        context = {}",
            "        filters = {\"filter_fields\": \"country\", \"filter_values\": \"Brazil\"}",
            "        params = self._default_resource_view_attributes(**filters)",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_view_create\", context, **params)",
            "",
            "    def _default_resource_view_attributes(self, **kwargs):",
            "        default_attributes = {",
            "            \"resource_id\": factories.Resource()[\"id\"],",
            "            \"view_type\": \"image_view\",",
            "            \"title\": \"View\",",
            "            \"description\": \"A nice view\",",
            "        }",
            "",
            "        default_attributes.update(kwargs)",
            "",
            "        return default_attributes",
            "",
            "    def _configure_datapreview_to_return_filterable_view(",
            "        self, datapreview_mock",
            "    ):",
            "        filterable_view = mock.MagicMock()",
            "        filterable_view.info.return_value = {\"filterable\": True}",
            "        datapreview_mock.get_view_plugin.return_value = filterable_view",
            "",
            "",
            "@pytest.mark.ckan_config(\"ckan.views.default_views\", \"\")",
            "@pytest.mark.ckan_config(\"ckan.plugins\", \"image_view\")",
            "@pytest.mark.usefixtures(\"non_clean_db\", \"with_plugins\")",
            "class TestCreateDefaultResourceViews(object):",
            "    def test_add_default_views_to_dataset_resources(self):",
            "",
            "        # New resources have no views",
            "        dataset_dict = factories.Dataset(",
            "            resources=[",
            "                {",
            "                    \"url\": \"http://some.image.png\",",
            "                    \"format\": \"png\",",
            "                    \"name\": \"Image 1\",",
            "                },",
            "                {",
            "                    \"url\": \"http://some.image.png\",",
            "                    \"format\": \"png\",",
            "                    \"name\": \"Image 2\",",
            "                },",
            "            ]",
            "        )",
            "",
            "        # Change default views config setting",
            "        config[\"ckan.views.default_views\"] = [\"image_view\"]",
            "",
            "        context = {\"user\": helpers.call_action(\"get_site_user\")[\"name\"]}",
            "        created_views = helpers.call_action(",
            "            \"package_create_default_resource_views\",",
            "            context,",
            "            package=dataset_dict,",
            "        )",
            "",
            "        assert len(created_views) == 2",
            "",
            "        assert created_views[0][\"view_type\"] == \"image_view\"",
            "        assert created_views[1][\"view_type\"] == \"image_view\"",
            "",
            "    def test_add_default_views_to_resource(self):",
            "",
            "        # New resources have no views",
            "        dataset_dict = factories.Dataset()",
            "        resource_dict = factories.Resource(",
            "            package_id=dataset_dict[\"id\"],",
            "            url=\"http://some.image.png\",",
            "            format=\"png\",",
            "        )",
            "",
            "        # Change default views config setting",
            "        config[\"ckan.views.default_views\"] = [\"image_view\"]",
            "",
            "        context = {\"user\": helpers.call_action(\"get_site_user\")[\"name\"]}",
            "        created_views = helpers.call_action(",
            "            \"resource_create_default_resource_views\",",
            "            context,",
            "            resource=resource_dict,",
            "            package=dataset_dict,",
            "        )",
            "",
            "        assert len(created_views) == 1",
            "",
            "        assert created_views[0][\"view_type\"] == \"image_view\"",
            "",
            "    def test_add_default_views_to_resource_no_dataset_passed(self):",
            "",
            "        # New resources have no views",
            "        dataset_dict = factories.Dataset()",
            "        resource_dict = factories.Resource(",
            "            package_id=dataset_dict[\"id\"],",
            "            url=\"http://some.image.png\",",
            "            format=\"png\",",
            "        )",
            "",
            "        # Change default views config setting",
            "        config[\"ckan.views.default_views\"] = [\"image_view\"]",
            "",
            "        context = {\"user\": helpers.call_action(\"get_site_user\")[\"name\"]}",
            "        created_views = helpers.call_action(",
            "            \"resource_create_default_resource_views\",",
            "            context,",
            "            resource=resource_dict,",
            "        )",
            "",
            "        assert len(created_views) == 1",
            "",
            "        assert created_views[0][\"view_type\"] == \"image_view\"",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestResourceCreate:",
            "    def test_resource_create(self):",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://data\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        id = result.pop(\"id\")",
            "",
            "        assert id",
            "",
            "        params.pop(\"package_id\")",
            "        for key in params.keys():",
            "            assert params[key] == result[key]",
            "",
            "    def test_it_requires_package_id(self):",
            "",
            "        data_dict = {\"url\": \"http://data\"}",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_create\", **data_dict)",
            "",
            "    def test_invalid_characters_in_id(self):",
            "",
            "        data_dict = {",
            "            \"id\": \"../../nope.txt\",",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://data\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_create\", **data_dict)",
            "",
            "    def test_id_too_long(self):",
            "",
            "        data_dict = {",
            "            \"id\": \"x\" * 111,",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://data\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"resource_create\", **data_dict)",
            "",
            "    def test_id_already_exists(self):",
            "        data_dict = {",
            "            'id': str(uuid.uuid4()),",
            "            'package_id': factories.Dataset()['id'],",
            "        }",
            "        helpers.call_action('resource_create', **data_dict)",
            "",
            "        data_dict['package_id'] = factories.Dataset()['id']",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action('resource_create', **data_dict)",
            "",
            "    def test_sysadmin_can_set_id(self):",
            "        \"\"\"",
            "        The system admin",
            "        \"\"\"",
            "        user = factories.Sysadmin()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        data_dict = {",
            "            \"id\": _id,",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://data\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "",
            "        result = helpers.call_action(\"resource_create\", context=context, **data_dict)",
            "        assert result[\"id\"] == _id",
            "",
            "    def test_normal_user_can_provide_custom_id(self):",
            "",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        data_dict = {",
            "            \"id\": _id,",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://data\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "        result = helpers.call_action(\"resource_create\", context=context, **data_dict)",
            "        assert result[\"id\"] == _id",
            "",
            "    def test_doesnt_require_url(self):",
            "        dataset = factories.Dataset()",
            "        data_dict = {\"package_id\": dataset[\"id\"]}",
            "        new_resouce = helpers.call_action(\"resource_create\", **data_dict)",
            "",
            "        data_dict = {\"id\": new_resouce[\"id\"]}",
            "        stored_resource = helpers.call_action(\"resource_show\", **data_dict)",
            "",
            "        assert not stored_resource[\"url\"]",
            "",
            "    def test_mimetype_by_url(self, monkeypatch, ckan_config, tmpdir):",
            "        \"\"\"The mimetype is guessed from the url",
            "",
            "        Real world usage would be externally linking the resource and",
            "        the mimetype would be guessed, based on the url",
            "",
            "        \"\"\"",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://localhost/data.csv\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "        monkeypatch.setitem(ckan_config, u'ckan.storage_path', str(tmpdir))",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        mimetype = result.pop(\"mimetype\")",
            "",
            "        assert mimetype",
            "        assert mimetype == \"text/csv\"",
            "",
            "    def test_mimetype_by_url_without_path(self):",
            "        \"\"\"",
            "        The mimetype should not be guessed from url if url contains only domain",
            "",
            "        \"\"\"",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://example.com\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        mimetype = result.pop(\"mimetype\")",
            "        assert mimetype is None",
            "",
            "    def test_mimetype_by_user(self):",
            "        \"\"\"",
            "        The mimetype is supplied by the user",
            "",
            "        Real world usage would be using the FileStore API or web UI form to create a resource",
            "        and the user wanted to specify the mimetype themselves",
            "        \"\"\"",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://localhost/data.csv\",",
            "            \"name\": \"A nice resource\",",
            "            \"mimetype\": \"application/csv\",",
            "        }",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        mimetype = result.pop(\"mimetype\")",
            "        assert mimetype == \"application/csv\"",
            "",
            "    def test_mimetype_by_upload_by_filename(self, create_with_upload):",
            "        \"\"\"The mimetype is guessed from an uploaded file with a filename",
            "",
            "        Real world usage would be using the FileStore API or web UI",
            "        form to upload a file, with a filename plus extension If",
            "        there's no url or the mimetype can't be guessed by the url,",
            "        mimetype will be guessed by the extension in the filename",
            "",
            "        \"\"\"",
            "        content = \"\"\"",
            "        \"info\": {",
            "            \"title\": \"BC Data Catalogue API\",",
            "            \"description\": \"This API provides information about datasets in the BC Data Catalogue.\",",
            "            \"termsOfService\": \"http://www.data.gov.bc.ca/local/dbc/docs/license/API_Terms_of_Use.pdf\",",
            "            \"contact\": {",
            "                \"name\": \"Data BC\",",
            "                \"url\": \"http://data.gov.bc.ca/\",",
            "                \"email\": \"\"",
            "            },",
            "            \"license\": {",
            "                \"name\": \"Open Government License - British Columbia\",",
            "                \"url\": \"http://www.data.gov.bc.ca/local/dbc/docs/license/OGL-vbc2.0.pdf\"",
            "            },",
            "            \"version\": \"3.0.0\"",
            "        }",
            "        \"\"\"",
            "",
            "        result = create_with_upload(",
            "            content,",
            "            \"test.json\",",
            "            url=\"http://data\",",
            "            package_id=factories.Dataset()[u\"id\"],",
            "        )",
            "        mimetype = result.pop(\"mimetype\")",
            "",
            "        assert mimetype",
            "        assert mimetype == \"application/json\"",
            "",
            "    @pytest.mark.ckan_config(\"ckan.mimetype_guess\", \"file_contents\")",
            "    def test_mimetype_by_upload_by_file(self, create_with_upload):",
            "        \"\"\"The mimetype is guessed from an uploaded file by the contents inside",
            "",
            "        Real world usage would be using the FileStore API or web UI",
            "        form to upload a file, that has no extension If the mimetype",
            "        can't be guessed by the url or filename, mimetype will be",
            "        guessed by the contents inside the file",
            "",
            "        \"\"\"",
            "",
            "        content = \"\"\"",
            "        Snow Course Name, Number, Elev. metres, Date of Survey, Snow Depth cm,\\",
            "        Water Equiv. mm, Survey Code, % of Normal, Density %, Survey Period, \\",
            "        Normal mm",
            "        SKINS LAKE,1B05,890,2015/12/30,34,53,,98,16,JAN-01,54",
            "        MCGILLIVRAY PASS,1C05,1725,2015/12/31,88,239,,87,27,JAN-01,274",
            "        NAZKO,1C08,1070,2016/01/05,20,31,,76,16,JAN-01,41",
            "        \"\"\"",
            "        result = create_with_upload(",
            "            content,",
            "            \"test.csv\",",
            "            url=\"http://data\",",
            "            package_id=factories.Dataset()[u\"id\"],",
            "        )",
            "",
            "        mimetype = result.pop(\"mimetype\")",
            "",
            "        assert mimetype",
            "        assert mimetype == \"text/plain\"",
            "",
            "    def test_size_of_resource_by_upload(self, create_with_upload):",
            "        \"\"\"",
            "        The size of the resource determined by the uploaded file",
            "        \"\"\"",
            "",
            "        content = \"\"\"",
            "        Snow Course Name, Number, Elev. metres, Date of Survey, Snow Depth cm,\\",
            "        Water Equiv. mm, Survey Code, % of Normal, Density %, Survey Period, \\",
            "        Normal mm",
            "        SKINS LAKE,1B05,890,2015/12/30,34,53,,98,16,JAN-01,54",
            "        MCGILLIVRAY PASS,1C05,1725,2015/12/31,88,239,,87,27,JAN-01,274",
            "        NAZKO,1C08,1070,2016/01/05,20,31,,76,16,JAN-01,41",
            "        \"\"\"",
            "        result = create_with_upload(",
            "            content,",
            "            \"test.csv\",",
            "            url=\"http://data\",",
            "            package_id=factories.Dataset()[u\"id\"],",
            "        )",
            "",
            "        size = result.pop(\"size\")",
            "",
            "        assert size",
            "        assert size > 0",
            "",
            "    def test_size_of_resource_by_user(self):",
            "        \"\"\"",
            "        The size of the resource is provided by the users",
            "",
            "        Real world usage would be using the FileStore API and the user provides a size for the resource",
            "        \"\"\"",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://data\",",
            "            \"name\": \"A nice resource\",",
            "            \"size\": 500,",
            "        }",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        size = int(result.pop(\"size\"))",
            "        assert size == 500",
            "",
            "    def test_extras(self):",
            "        user = factories.User()",
            "        dataset = factories.Dataset(user=user)",
            "",
            "        resource = helpers.call_action(",
            "            \"resource_create\",",
            "            package_id=dataset[\"id\"],",
            "            somekey=\"somevalue\",  # this is how to do resource extras",
            "            extras={u\"someotherkey\": u\"alt234\"},  # this isn't",
            "            subobject={u\"hello\": u\"there\"},  # JSON objects supported",
            "            sublist=[1, 2, 3],  # JSON lists supported",
            "            format=u\"plain text\",",
            "            url=u\"http://datahub.io/download/\",",
            "        )",
            "",
            "        assert resource[\"somekey\"] == \"somevalue\"",
            "        assert \"extras\" not in resource",
            "        assert \"someotherkey\" not in resource",
            "        assert resource[\"subobject\"] == {u\"hello\": u\"there\"}",
            "        assert resource[\"sublist\"] == [1, 2, 3]",
            "        resource = helpers.call_action(\"package_show\", id=dataset[\"id\"])[",
            "            \"resources\"",
            "        ][0]",
            "        assert resource[\"somekey\"] == \"somevalue\"",
            "        assert \"extras\" not in resource",
            "        assert \"someotherkey\" not in resource",
            "        assert resource[\"subobject\"] == {u\"hello\": u\"there\"}",
            "        assert resource[\"sublist\"] == [1, 2, 3]",
            "",
            "    @freeze_time(\"2020-02-25 12:00:00\")",
            "    def test_metadata_modified_is_set_to_utcnow_when_created(self):",
            "        context = {}",
            "        params = {",
            "            \"package_id\": factories.Dataset()[\"id\"],",
            "            \"url\": \"http://data\",",
            "            \"name\": \"A nice resource\",",
            "        }",
            "        result = helpers.call_action(\"resource_create\", context, **params)",
            "",
            "        assert (",
            "            result[\"metadata_modified\"]",
            "            == datetime.datetime.utcnow().isoformat()",
            "        )",
            "",
            "    @pytest.mark.ckan_config(\"ckan.auth.allow_dataset_collaborators\", True)",
            "    @pytest.mark.ckan_config(\"ckan.auth.allow_admin_collaborators\", True)",
            "    @pytest.mark.parametrize(\"role\", [\"admin\", \"editor\"])",
            "    def test_collaborators_can_create_resources(self, role):",
            "",
            "        org1 = factories.Organization()",
            "        dataset = factories.Dataset(owner_org=org1[\"id\"])",
            "",
            "        user = factories.User()",
            "",
            "        helpers.call_action(",
            "            \"package_collaborator_create\",",
            "            id=dataset[\"id\"],",
            "            user_id=user[\"id\"],",
            "            capacity=role,",
            "        )",
            "",
            "        context = {",
            "            \"user\": user[\"name\"],",
            "            \"ignore_auth\": False,",
            "        }",
            "",
            "        created_resource = helpers.call_action(",
            "            \"resource_create\",",
            "            context=context,",
            "            package_id=dataset[\"id\"],",
            "            name=\"created by collaborator\",",
            "            url=\"https://example.com\",",
            "        )",
            "",
            "        assert created_resource[\"name\"] == \"created by collaborator\"",
            "",
            "    def test_resource_create_for_update(self):",
            "",
            "        dataset = factories.Dataset()",
            "",
            "        mock_package_show = mock.MagicMock()",
            "        mock_package_show.side_effect = lambda context, data_dict: core_package_show(context, data_dict)",
            "",
            "        with mock.patch.dict('ckan.logic._actions', {'package_show': mock_package_show}):",
            "            helpers.call_action('resource_create', package_id=dataset['id'], url='http://example.com', description='hey')",
            "            assert mock_package_show.call_args_list[0][0][0].get('for_update') is True",
            "",
            "    def test_resource_create_copies_other_resources(self):",
            "        from ckan.lib.dictization import model_save",
            "        existing = factories.Resource()",
            "        params = {",
            "            \"package_id\": existing['package_id'],",
            "            \"url\": \"http://data\",",
            "            \"name\": \"A second resource\",",
            "        }",
            "        with mock.patch(",
            "                'ckan.lib.dictization.model_save.package_dict_save',",
            "                wraps=model_save.package_dict_save,",
            "                ) as m:",
            "            helpers.call_action(\"resource_create\", **params)",
            "            assert m.call_args.args[3] == {0: 0}, 'copy existing resource 0'",
            "",
            "    def test_upload_file_paths(self, create_with_upload):",
            "        from ckan.common import config",
            "        import os",
            "",
            "        storage_path = config[\"ckan.storage_path\"]",
            "",
            "        dataset = factories.Dataset()",
            "        resource1 = create_with_upload(",
            "            \"hello world\", \"file1.txt\", url=\"http://data1\",",
            "            package_id=dataset[\"id\"])",
            "",
            "        assert os.path.exists(",
            "            os.path.join(storage_path, \"resources\", resource1[\"id\"][:3])",
            "        )",
            "",
            "        resource2 = create_with_upload(",
            "            \"bye bye world\", \"file2.txt\", url=\"http://data2\",",
            "            package_id=dataset[\"id\"])",
            "",
            "        assert os.path.exists(",
            "            os.path.join(storage_path, \"resources\", resource2[\"id\"][:3])",
            "        )",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestMemberCreate(object):",
            "    def test_group_member_creation(self):",
            "        user = factories.User()",
            "        group = factories.Group()",
            "",
            "        new_membership = helpers.call_action(",
            "            \"group_member_create\",",
            "            id=group[\"id\"],",
            "            username=user[\"name\"],",
            "            role=\"member\",",
            "        )",
            "",
            "        assert new_membership[\"group_id\"] == group[\"id\"]",
            "        assert new_membership[\"table_name\"] == \"user\"",
            "        assert new_membership[\"table_id\"] == user[\"id\"]",
            "        assert new_membership[\"capacity\"] == \"member\"",
            "",
            "    def test_organization_member_creation(self):",
            "        user = factories.User()",
            "        organization = factories.Organization()",
            "",
            "        new_membership = helpers.call_action(",
            "            \"organization_member_create\",",
            "            id=organization[\"id\"],",
            "            username=user[\"name\"],",
            "            role=\"member\",",
            "        )",
            "",
            "        assert new_membership[\"group_id\"] == organization[\"id\"]",
            "        assert new_membership[\"table_name\"] == \"user\"",
            "        assert new_membership[\"table_id\"] == user[\"id\"]",
            "        assert new_membership[\"capacity\"] == \"member\"",
            "",
            "    def test_group_member_creation_raises_validation_error_if_id_missing(self):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"group_member_create\",",
            "                username=factories.User.stub().name,",
            "                role=\"member\",",
            "            )",
            "",
            "    def test_group_member_creation_raises_validation_error_if_username_missing(",
            "        self,",
            "    ):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"group_member_create\", id=\"someid\", role=\"member\"",
            "            )",
            "",
            "    def test_group_member_creation_raises_validation_error_if_role_missing(",
            "        self, faker",
            "    ):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"group_member_create\",",
            "                id=faker.uuid4(),",
            "                username=factories.User.stub().name,",
            "            )",
            "",
            "    def test_org_member_creation_raises_validation_error_if_id_missing(self):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"organization_member_create\",",
            "                username=factories.User.stub().name,",
            "                role=\"member\",",
            "            )",
            "",
            "    def test_org_member_creation_raises_validation_error_if_username_missing(",
            "        self,",
            "    ):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"organization_member_create\",",
            "                id=factories.Group.stub().name,",
            "                role=\"member\",",
            "            )",
            "",
            "    def test_org_member_creation_raises_validation_error_if_role_missing(self, faker):",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"organization_member_create\",",
            "                id=faker.uuid4(),",
            "                username=factories.User.stub().name,",
            "            )",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestDatasetCreate(object):",
            "    def test_private_package(self):",
            "        org = factories.Organization()",
            "        stub = factories.Dataset.stub()",
            "        with pytest.raises(logic.ValidationError):",
            "            pkg = helpers.call_action(",
            "                \"package_create\", name=stub.name, private=True",
            "            )",
            "",
            "        pkg = helpers.call_action(",
            "            \"package_create\", owner_org=org[\"id\"], name=stub.name",
            "        )",
            "        assert not pkg[\"private\"]",
            "        pkg = helpers.call_action(",
            "            \"package_create\",",
            "            owner_org=org[\"id\"],",
            "            name=factories.Dataset.stub().name,",
            "            private=False,",
            "        )",
            "        assert not pkg[\"private\"]",
            "        pkg = helpers.call_action(",
            "            \"package_create\",",
            "            owner_org=org[\"id\"],",
            "            name=factories.Dataset.stub().name,",
            "            private=True,",
            "        )",
            "        assert pkg[\"private\"]",
            "",
            "    def test_normal_user_cant_set_id(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"package_create\",",
            "                context=context,",
            "                id=_id,",
            "                name=\"test\",",
            "            )",
            "",
            "    def test_sysadmin_can_set_id(self):",
            "        user = factories.Sysadmin()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        dataset = helpers.call_action(",
            "            \"package_create\", context=context, id=_id, name=f\"test-dataset-{_id}\"",
            "        )",
            "        assert dataset[\"id\"] == _id",
            "",
            "    def test_context_is_not_polluted(self):",
            "        user = factories.Sysadmin()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        helpers.call_action(",
            "            \"package_create\", context=context, id=_id, name=f\"test-dataset-{_id}\"",
            "        )",
            "        assert \"id\" not in context",
            "        assert \"package\" not in context",
            "",
            "    def test_id_cant_already_exist(self):",
            "        dataset = factories.Dataset()",
            "        factories.Sysadmin()",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"package_create\",",
            "                id=dataset[\"id\"],",
            "                name=factories.Dataset.stub().name,",
            "            )",
            "",
            "    def test_name_not_changed_during_deletion(self):",
            "        dataset = factories.Dataset()",
            "        helpers.call_action(\"package_delete\", id=dataset[\"id\"])",
            "        deleted_dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        assert deleted_dataset[\"name\"] == dataset[\"name\"]",
            "",
            "    def test_name_not_changed_after_restoring(self):",
            "        dataset = factories.Dataset()",
            "        context = {\"user\": factories.Sysadmin()[\"name\"]}",
            "        helpers.call_action(\"package_delete\", id=dataset[\"id\"])",
            "        deleted_dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        restored_dataset = helpers.call_action(",
            "            \"package_patch\", context=context, id=dataset[\"id\"], state=\"active\"",
            "        )",
            "        assert deleted_dataset[\"name\"] == restored_dataset[\"name\"]",
            "        assert deleted_dataset[\"id\"] == restored_dataset[\"id\"]",
            "",
            "    def test_creation_of_dataset_with_name_same_as_of_previously_removed(self):",
            "        dataset = factories.Dataset()",
            "        initial_name = dataset[\"name\"]",
            "        helpers.call_action(\"package_delete\", id=dataset[\"id\"])",
            "        new_dataset = helpers.call_action(\"package_create\", name=initial_name)",
            "        assert new_dataset[\"name\"] == initial_name",
            "        deleted_dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "",
            "        assert new_dataset[\"id\"] != deleted_dataset[\"id\"]",
            "        assert deleted_dataset[\"name\"] == deleted_dataset[\"id\"]",
            "",
            "    def test_missing_id(self):",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"package_create\")",
            "",
            "    def test_name(self):",
            "        stub = factories.Dataset.stub()",
            "        dataset = helpers.call_action(\"package_create\", name=stub.name)",
            "",
            "        assert dataset[\"name\"] == stub.name",
            "        assert (",
            "            helpers.call_action(\"package_show\", id=dataset[\"id\"])[\"name\"]",
            "            == stub.name",
            "        )",
            "",
            "    def test_title(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=factories.Dataset.stub().name,",
            "            title=\"New Title\",",
            "        )",
            "",
            "        assert dataset[\"title\"] == \"New Title\"",
            "        assert (",
            "            helpers.call_action(\"package_show\", id=dataset[\"id\"])[\"title\"]",
            "            == \"New Title\"",
            "        )",
            "",
            "    def test_extras(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=factories.Dataset.stub().name,",
            "            title=\"Test Extras\",",
            "            extras=[{\"key\": \"original media\", \"value\": '\"book\"'}],",
            "        )",
            "",
            "        assert dataset[\"extras\"][0][\"key\"] == \"original media\"",
            "        assert dataset[\"extras\"][0][\"value\"] == '\"book\"'",
            "        dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        assert dataset[\"extras\"][0][\"key\"] == \"original media\"",
            "        assert dataset[\"extras\"][0][\"value\"] == '\"book\"'",
            "",
            "    def test_sysadmin_can_set_extras_id(self):",
            "        user = factories.Sysadmin()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            context=context,",
            "            name=factories.Dataset.stub().name,",
            "            title=\"Test Extras\",",
            "            extras=[{\"id\": _id, \"key\": \"original media\", \"value\": '\"book\"'}],",
            "        )",
            "        dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        assert dataset[\"extras\"][0][\"key\"] == \"original media\"",
            "",
            "    def test_normal_user_can_not_set_extras_id(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        with pytest.raises(logic.ValidationError) as exception:",
            "            helpers.call_action(",
            "                \"package_create\",",
            "                context=context,",
            "                name=factories.Dataset.stub().name,",
            "                title=\"Test Extras\",",
            "                extras=[{\"id\": _id, \"key\": \"original media\", \"value\": '\"book\"'}],",
            "            )",
            "        assert \"The input field id was not expected\" in str(exception.value)",
            "",
            "    def test_license(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=factories.Dataset.stub().name,",
            "            title=\"Test License\",",
            "            license_id=\"other-open\",",
            "        )",
            "",
            "        assert dataset[\"license_id\"] == \"other-open\"",
            "        dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        assert dataset[\"license_id\"] == \"other-open\"",
            "",
            "    def test_notes(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=factories.Dataset.stub().name,",
            "            title=\"Test Notes\",",
            "            notes=\"some notes\",",
            "        )",
            "",
            "        assert dataset[\"notes\"] == \"some notes\"",
            "        dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        assert dataset[\"notes\"] == \"some notes\"",
            "",
            "    def test_resources(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=factories.Dataset.stub().name,",
            "            title=\"Test Resources\",",
            "            resources=[",
            "                {",
            "                    \"alt_url\": u\"alt123\",",
            "                    \"description\": u\"Full text.\",",
            "                    \"somekey\": \"somevalue\",  # this is how to do resource extras",
            "                    \"extras\": {u\"someotherkey\": u\"alt234\"},  # this isn't",
            "                    \"format\": u\"plain text\",",
            "                    \"hash\": u\"abc123\",",
            "                    \"position\": 0,",
            "                    \"url\": u\"http://datahub.io/download/\",",
            "                },",
            "                {",
            "                    \"description\": u\"Index of the novel\",",
            "                    \"format\": u\"JSON\",",
            "                    \"position\": 1,",
            "                    \"url\": u\"http://datahub.io/index.json\",",
            "                },",
            "            ],",
            "        )",
            "",
            "        resources = dataset[\"resources\"]",
            "        assert resources[0][\"alt_url\"] == \"alt123\"",
            "        assert resources[0][\"description\"] == \"Full text.\"",
            "        assert resources[0][\"somekey\"] == \"somevalue\"",
            "        assert \"extras\" not in resources[0]",
            "        assert \"someotherkey\" not in resources[0]",
            "        assert resources[0][\"format\"] == \"plain text\"",
            "        assert resources[0][\"hash\"] == \"abc123\"",
            "        assert resources[0][\"position\"] == 0",
            "        assert resources[0][\"url\"] == \"http://datahub.io/download/\"",
            "        assert resources[1][\"description\"] == \"Index of the novel\"",
            "        assert resources[1][\"format\"] == \"JSON\"",
            "        assert resources[1][\"url\"] == \"http://datahub.io/index.json\"",
            "        assert resources[1][\"position\"] == 1",
            "        resources = helpers.call_action(\"package_show\", id=dataset[\"id\"])[",
            "            \"resources\"",
            "        ]",
            "        assert resources[0][\"alt_url\"] == \"alt123\"",
            "        assert resources[0][\"description\"] == \"Full text.\"",
            "        assert resources[0][\"somekey\"] == \"somevalue\"",
            "        assert \"extras\" not in resources[0]",
            "        assert \"someotherkey\" not in resources[0]",
            "        assert resources[0][\"format\"] == \"plain text\"",
            "        assert resources[0][\"hash\"] == \"abc123\"",
            "        assert resources[0][\"position\"] == 0",
            "        assert resources[0][\"url\"] == \"http://datahub.io/download/\"",
            "        assert resources[1][\"description\"] == \"Index of the novel\"",
            "        assert resources[1][\"format\"] == \"JSON\"",
            "        assert resources[1][\"url\"] == \"http://datahub.io/index.json\"",
            "        assert resources[1][\"position\"] == 1",
            "",
            "    def test_tags(self):",
            "        tag1 = factories.Tag.stub().name",
            "        tag2 = factories.Tag.stub().name",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=factories.Dataset.stub().name,",
            "            title=\"Test Tags\",",
            "            tags=[{\"name\": tag1}, {\"name\": tag2}],",
            "        )",
            "",
            "        tag_names = sorted([tag_dict[\"name\"] for tag_dict in dataset[\"tags\"]])",
            "        assert tag_names == sorted([tag1, tag2])",
            "        dataset = helpers.call_action(\"package_show\", id=dataset[\"id\"])",
            "        tag_names = sorted([tag_dict[\"name\"] for tag_dict in dataset[\"tags\"]])",
            "        assert tag_names == sorted([tag1, tag2])",
            "",
            "    def test_return_id_only(self):",
            "        dataset = helpers.call_action(",
            "            \"package_create\",",
            "            name=factories.Dataset.stub().name,",
            "            context={\"return_id_only\": True},",
            "        )",
            "",
            "        assert isinstance(dataset, str)",
            "",
            "    def test_non_string_extras(self):",
            "        data_dict = {",
            "            \"name\": \"test-non-string-extras\",",
            "            \"extras\": [",
            "                {",
            "                    \"key\": \"some_number\",",
            "                    \"value\": 1.5",
            "                }",
            "            ]",
            "        }",
            "",
            "        helpers.call_action(\"package_create\", **data_dict)",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestGroupCreate(object):",
            "    def test_create_group(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        group = helpers.call_action(",
            "            \"group_create\", context=context, name=factories.Group.stub().name",
            "        )",
            "",
            "        assert len(group[\"users\"]) == 1",
            "        assert group[\"display_name\"] == group[\"name\"]",
            "        assert group[\"package_count\"] == 0",
            "        assert not group[\"is_organization\"]",
            "        assert group[\"type\"] == \"group\"",
            "",
            "    def test_create_group_validation_fail(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"group_create\", context=context, name=\"\"",
            "            )",
            "",
            "    def test_create_group_return_id(self):",
            "        import re",
            "",
            "        user = factories.User()",
            "        context = {",
            "            \"user\": user[\"name\"],",
            "            \"ignore_auth\": True,",
            "            \"return_id_only\": True,",
            "        }",
            "",
            "        group = helpers.call_action(",
            "            \"group_create\", context=context, name=factories.Group.stub().name",
            "        )",
            "",
            "        assert isinstance(group, str)",
            "        assert re.match(r\"([a-f\\d]{8}(-[a-f\\d]{4}){3}-[a-f\\d]{12}?)\", group)",
            "",
            "    def test_create_matches_show(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        created = helpers.call_action(",
            "            \"organization_create\",",
            "            context=context,",
            "            name=factories.Organization.stub().name,",
            "        )",
            "",
            "        shown = helpers.call_action(",
            "            \"organization_show\", context=context, id=created[\"name\"]",
            "        )",
            "",
            "        assert sorted(created.keys()) == sorted(shown.keys())",
            "        for k in created.keys():",
            "            assert created[k] == shown[k], k",
            "",
            "    def test_normal_user_cant_set_id(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"group_create\",",
            "                context=context,",
            "                name=f\"test-group-{_id}\",",
            "                id=_id",
            "            )",
            "",
            "    def test_sysadmin_can_set_id(self):",
            "        user = factories.Sysadmin()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        result = helpers.call_action(",
            "            \"group_create\",",
            "            context=context,",
            "            name=f\"test-group-{_id}\",",
            "            id=_id",
            "        )",
            "        assert result.get(\"id\") == _id",
            "",
            "    def test_id_cant_already_exist(self):",
            "        user = factories.Sysadmin()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        group = helpers.call_action(",
            "            \"group_create\",",
            "            name=factories.Group.stub().name,",
            "            context=context",
            "        )",
            "        with pytest.raises(logic.ValidationError) as exception:",
            "            helpers.call_action(",
            "                \"group_create\",",
            "                id=group[\"id\"],",
            "                context=context,",
            "                name=factories.Group.stub().name,",
            "            )",
            "        assert \"Id already exists\" in str(exception.value)",
            "",
            "    def test_normal_user_cant_set_extras_id(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        with pytest.raises(logic.ValidationError) as exception:",
            "            helpers.call_action(",
            "                \"group_create\",",
            "                context=context,",
            "                name=f\"test-group-{_id}\",",
            "                extras=[{\"id\": _id, \"key\": \"area\", \"value\": '\"non profit\"'}]",
            "            )",
            "        assert \"The input field id was not expected\" in str(exception.value)",
            "",
            "    def test_sysadmin_user_cant_set_extras_id(self):",
            "        user = factories.Sysadmin()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        helpers.call_action(",
            "            \"group_create\",",
            "            context=context,",
            "            name=f\"test-group-{_id}\",",
            "            extras=[{\"id\": _id, \"key\": \"area\", \"value\": '\"non profit\"'}]",
            "        )",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestOrganizationCreate(object):",
            "    def test_create_organization(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        org = helpers.call_action(",
            "            \"organization_create\",",
            "            context=context,",
            "            name=factories.Organization.stub().name,",
            "        )",
            "",
            "        assert len(org[\"users\"]) == 1",
            "        assert org[\"display_name\"] == org[\"name\"]",
            "        assert org[\"package_count\"] == 0",
            "        assert org[\"is_organization\"]",
            "        assert org[\"type\"] == \"organization\"",
            "",
            "    def test_create_organization_validation_fail(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"organization_create\", context=context, name=\"\"",
            "            )",
            "",
            "    def test_create_organization_return_id(self):",
            "        import re",
            "",
            "        user = factories.User()",
            "        context = {",
            "            \"user\": user[\"name\"],",
            "            \"ignore_auth\": True,",
            "            \"return_id_only\": True,",
            "        }",
            "",
            "        org = helpers.call_action(",
            "            \"organization_create\",",
            "            context=context,",
            "            name=factories.Organization.stub().name,",
            "        )",
            "",
            "        assert isinstance(org, str)",
            "        assert re.match(r\"([a-f\\d]{8}(-[a-f\\d]{4}){3}-[a-f\\d]{12}?)\", org)",
            "",
            "    def test_create_matches_show(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        created = helpers.call_action(",
            "            \"organization_create\",",
            "            context=context,",
            "            name=factories.Organization.stub().name,",
            "        )",
            "",
            "        shown = helpers.call_action(",
            "            \"organization_show\", context=context, id=created[\"name\"]",
            "        )",
            "",
            "        assert sorted(created.keys()) == sorted(shown.keys())",
            "        for k in created.keys():",
            "            assert created[k] == shown[k], k",
            "",
            "    def test_create_organization_custom_type(self):",
            "        custom_org_type = \"some-custom-type\"",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": True}",
            "",
            "        org = helpers.call_action(",
            "            \"organization_create\",",
            "            context=context,",
            "            name=factories.Organization.stub().name,",
            "            type=custom_org_type,",
            "        )",
            "",
            "        assert len(org[\"users\"]) == 1",
            "        assert org[\"display_name\"] == org[\"name\"]",
            "        assert org[\"package_count\"] == 0",
            "        assert org[\"is_organization\"]",
            "        assert org[\"type\"] == custom_org_type",
            "",
            "    def test_normal_user_cant_set_id(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"organization_create\",",
            "                context=context,",
            "                name=f\"test-org-{_id}\",",
            "                id=_id",
            "            )",
            "",
            "    def test_sysadmin_can_set_id(self):",
            "        user = factories.Sysadmin()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        _id = str(uuid.uuid4())",
            "        result = helpers.call_action(",
            "            \"organization_create\",",
            "            context=context,",
            "            name=f\"test-org-{_id}\",",
            "            id=_id",
            "        )",
            "        assert result.get(\"id\") == _id",
            "",
            "    def test_id_cant_already_exist(self):",
            "        user = factories.Sysadmin()",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        group = factories.Group()",
            "        with pytest.raises(logic.ValidationError) as exception:",
            "            helpers.call_action(",
            "                \"group_create\",",
            "                id=group.pop(\"id\"),",
            "                context=context,",
            "                name=group.pop(\"name\")",
            "            )",
            "        assert \"Id already exists\" in str(exception.value)",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestUserCreate(object):",
            "    def test_user_create_with_password_hash(self):",
            "        sysadmin = factories.Sysadmin()",
            "        context = {\"user\": sysadmin[\"name\"]}",
            "",
            "        user = helpers.call_action(",
            "            \"user_create\",",
            "            context=context,",
            "            email=factories.User.stub().email,",
            "            name=factories.User.stub().name,",
            "            password_hash=\"pretend-this-is-a-valid-hash\",",
            "        )",
            "",
            "        user_obj = model.User.get(user[\"id\"])",
            "        assert user_obj.password == \"pretend-this-is-a-valid-hash\"",
            "",
            "    @pytest.mark.ckan_config(\"ckan.auth.create_user_via_web\", True)",
            "    def test_user_create_password_hash_not_for_normal_users(self):",
            "        normal_user = factories.User()",
            "        context = {\"user\": normal_user[\"name\"], \"ignore_auth\": False}",
            "",
            "        user = helpers.call_action(",
            "            \"user_create\",",
            "            context=context,",
            "            email=factories.User.stub().email,",
            "            name=factories.User.stub().name,",
            "            password=\"required\",",
            "            password_hash=\"pretend-this-is-a-valid-hash\",",
            "        )",
            "",
            "        user_obj = model.User.get(user[\"id\"])",
            "        assert user_obj.password != \"pretend-this-is-a-valid-hash\"",
            "",
            "    def test_user_create_basic_fields(self):",
            "        email = factories.User.stub().email",
            "        name = factories.User.stub().name",
            "        user = helpers.call_action(",
            "            \"user_create\",",
            "            email=email,",
            "            name=name,",
            "            password=\"required\",",
            "        )",
            "        assert user[\"email\"] == email",
            "        assert user[\"name\"] == name",
            "        assert \"password\" not in user",
            "",
            "    def test_user_create_parameters_missing(self):",
            "        with pytest.raises(logic.ValidationError) as err:",
            "            helpers.call_action(\"user_create\")",
            "        assert err.value.error_dict == {",
            "            \"email\": [\"Missing value\"],",
            "            \"name\": [\"Missing value\"],",
            "            \"password\": [\"Missing value\"],",
            "        }",
            "",
            "    def test_user_create_wrong_password(self):",
            "        stub = factories.User.stub()",
            "        user_dict = {",
            "            \"name\": stub.name,",
            "            \"email\": stub.email,",
            "            \"password\": \"tes\",",
            "        }  # Too short",
            "",
            "        with pytest.raises(logic.ValidationError) as err:",
            "            helpers.call_action(\"user_create\", **user_dict)",
            "        assert err.value.error_dict == {",
            "            \"password\": [\"Your password must be 8 characters or longer\"]",
            "        }",
            "",
            "    def test_user_create_defer_commit(self):",
            "        stub = factories.User.stub()",
            "        user_dict = {",
            "            \"name\": stub.name,",
            "            \"email\": stub.email,",
            "            \"password\": \"test1234\",",
            "        }",
            "        context = {\"defer_commit\": True}",
            "",
            "        helpers.call_action(\"user_create\", context=context, **user_dict)",
            "",
            "        model.Session.close()",
            "",
            "        with pytest.raises(logic.NotFound):",
            "            helpers.call_action(\"user_show\", id=user_dict[\"name\"])",
            "",
            "    def test_create_user_with_apitoken(self):",
            "        stub = factories.User.stub()",
            "        context = {\"ignore_auth\": True}",
            "        user_dict = {",
            "            \"name\": stub.name,",
            "            \"email\": stub.email,",
            "            \"password\": \"test1234\",",
            "            \"with_apitoken\": True",
            "        }",
            "        user = helpers.call_action(\"user_create\", context={}, **user_dict)",
            "        assert user[\"token\"]",
            "",
            "        user_dict = {\"user_id\": user[\"name\"]}",
            "        token = helpers.call_action(",
            "            \"api_token_list\", context=context, **user_dict",
            "        )",
            "        assert len(token) == 1",
            "",
            "    def test_create_user_with_apitoken_missing_flag(self):",
            "        stub = factories.User.stub()",
            "        context = {\"ignore_auth\": True}",
            "        user_dict = {",
            "            \"name\": stub.name,",
            "            \"email\": stub.email,",
            "            \"password\": \"test1234\",",
            "        }",
            "        user = helpers.call_action(\"user_create\", context={}, **user_dict)",
            "        assert \"token\" not in user",
            "",
            "        user_dict = {\"user_id\": user[\"name\"]}",
            "        token = helpers.call_action(",
            "            \"api_token_list\", context=context, **user_dict",
            "        )",
            "        assert not token",
            "",
            "    def test_user_create_fails_with_duplicate_email_case_insensitive(self):",
            "        factories.User(email=\"some_email@example.org\")",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"user_create\",",
            "                context={},",
            "                email=\"Some_Email@example.org\",",
            "                name=\"test\",",
            "                password=\"required\",",
            "            )",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\")",
            "@pytest.mark.ckan_config(\"ckan.auth.create_user_via_web\", True)",
            "class TestUserCreateDb():",
            "",
            "    def test_anon_user_create_does_not_update(self):",
            "        user1 = factories.User(about=\"This is user 1\")",
            "        user_dict = {",
            "            \"id\": user1[\"id\"],",
            "            \"name\": \"some_name\",",
            "            \"email\": \"some_email@example.com\",",
            "            \"password\": \"test1234\",",
            "        }",
            "",
            "        context = {",
            "            \"user\": None,",
            "            \"ignore_auth\": False,",
            "        }",
            "",
            "        user2 = helpers.call_action(\"user_create\", context=context, **user_dict)",
            "        assert user2[\"id\"] != user1[\"id\"]",
            "        assert user2[\"about\"] != \"This is user 1\"",
            "",
            "    def test_normal_user_create_does_not_update(self):",
            "        user1 = factories.User(about=\"This is user 1\")",
            "        user_dict = {",
            "            \"id\": user1[\"id\"],",
            "            \"name\": \"some_name\",",
            "            \"email\": \"some_email@example.com\",",
            "            \"password\": \"test1234\",",
            "        }",
            "",
            "        context = {",
            "            \"user\": factories.User()[\"name\"],",
            "            \"ignore_auth\": False,",
            "        }",
            "",
            "        user2 = helpers.call_action(\"user_create\", context=context, **user_dict)",
            "        assert user2[\"id\"] != user1[\"id\"]",
            "        assert user2[\"about\"] != \"This is user 1\"",
            "",
            "    def test_sysadmin_user_create_does_not_update(self):",
            "        user1 = factories.User(about=\"This is user 1\")",
            "        user_dict = {",
            "            \"id\": user1[\"id\"],",
            "            \"name\": \"some_name\",",
            "            \"email\": \"some_email@example.com\",",
            "            \"password\": \"test1234\",",
            "        }",
            "",
            "        context = {",
            "            \"user\": factories.Sysadmin()[\"name\"],",
            "            \"ignore_auth\": False,",
            "        }",
            "",
            "        user2 = helpers.call_action(\"user_create\", context=context, **user_dict)",
            "        assert user2[\"id\"] != user1[\"id\"]",
            "        assert user2[\"about\"] != \"This is user 1\"",
            "",
            "    def test_anon_users_can_not_provide_custom_id(self):",
            "",
            "        user_dict = {",
            "            \"id\": \"custom_id\",",
            "            \"name\": \"some_name\",",
            "            \"email\": \"some_email@example.com\",",
            "            \"password\": \"test1234\",",
            "        }",
            "",
            "        context = {",
            "            \"user\": None,",
            "            \"ignore_auth\": False,",
            "        }",
            "",
            "        user = helpers.call_action(\"user_create\", context=context, **user_dict)",
            "        assert user[\"id\"] != \"custom_id\"",
            "",
            "    def test_normal_users_can_not_provide_custom_id(self):",
            "",
            "        user_dict = {",
            "            \"id\": \"custom_id\",",
            "            \"name\": \"some_name\",",
            "            \"email\": \"some_email@example.com\",",
            "            \"password\": \"test1234\",",
            "        }",
            "",
            "        context = {",
            "            \"user\": factories.User()[\"name\"],",
            "            \"ignore_auth\": False,",
            "        }",
            "",
            "        user = helpers.call_action(\"user_create\", context=context, **user_dict)",
            "        assert user[\"id\"] != \"custom_id\"",
            "",
            "    def test_sysadmin_can_provide_custom_id(self):",
            "        _id = str(uuid.uuid4())",
            "        user_dict = {",
            "            \"id\": _id,",
            "            \"name\": \"some_name\",",
            "            \"email\": \"some_email@example.com\",",
            "            \"password\": \"test1234\",",
            "        }",
            "        context = {",
            "            \"user\": factories.Sysadmin()[\"name\"],",
            "            \"ignore_auth\": False,",
            "        }",
            "",
            "        user = helpers.call_action(\"user_create\", context=context, **user_dict)",
            "        assert user[\"id\"] == _id",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestFollowCommon(object):",
            "    def test_validation(self):",
            "        user = factories.User()",
            "        unfollow_actions = (",
            "            \"unfollow_user\",",
            "            \"unfollow_dataset\",",
            "            \"unfollow_group\",",
            "        )",
            "        follow_actions = (\"follow_user\", \"follow_dataset\", \"follow_group\")",
            "        count_actions = (",
            "            \"user_follower_count\",",
            "            \"dataset_follower_count\",",
            "            \"group_follower_count\",",
            "        )",
            "        list_actions = (",
            "            \"user_follower_list\",",
            "            \"dataset_follower_list\",",
            "            \"group_follower_list\",",
            "        )",
            "        my_actions = (",
            "            \"am_following_dataset\",",
            "            \"am_following_user\",",
            "            \"am_following_group\",",
            "        )",
            "        for action in (",
            "            follow_actions",
            "            + unfollow_actions",
            "            + count_actions",
            "            + list_actions",
            "            + my_actions",
            "        ):",
            "            for object_id in (\"bad id\", \"     \", 3, 35.7, \"xxx\", None, \"\"):",
            "                with pytest.raises(logic.ValidationError):",
            "                    context = {\"user\": user[\"name\"]}",
            "                    helpers.call_action(action, context, id=object_id)",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestFollowDataset(object):",
            "    def test_auth(self):",
            "        user = factories.User()",
            "        dataset = factories.Dataset()",
            "        context = {\"user\": \"\", \"ignore_auth\": False}",
            "        with pytest.raises(logic.NotAuthorized):",
            "            helpers.call_action(\"follow_dataset\", context, id=dataset[\"id\"])",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        helpers.call_action(\"follow_dataset\", context, id=dataset[\"id\"])",
            "",
            "    def test_follow_dataset(self):",
            "        user = factories.User()",
            "        dataset = factories.Dataset()",
            "        context = {\"user\": user[\"name\"]}",
            "        assert (",
            "            helpers.call_action(\"dataset_follower_count\", id=dataset[\"id\"])",
            "            == 0",
            "        )",
            "        assert (",
            "            helpers.call_action(\"dataset_follower_list\", id=dataset[\"id\"])",
            "            == []",
            "        )",
            "        assert not helpers.call_action(",
            "            \"am_following_dataset\", context, id=dataset[\"id\"]",
            "        )",
            "",
            "        helpers.call_action(\"follow_dataset\", context, id=dataset[\"id\"])",
            "        assert (",
            "            helpers.call_action(\"dataset_follower_count\", id=dataset[\"id\"])",
            "            == 1",
            "        )",
            "        assert [",
            "            u[\"name\"]",
            "            for u in helpers.call_action(",
            "                \"dataset_follower_list\", id=dataset[\"id\"]",
            "            )",
            "        ] == [user[\"name\"]]",
            "        assert helpers.call_action(",
            "            \"am_following_dataset\", context, id=dataset[\"id\"]",
            "        )",
            "",
            "        helpers.call_action(\"unfollow_dataset\", context, id=dataset[\"id\"])",
            "        assert (",
            "            helpers.call_action(\"dataset_follower_count\", id=dataset[\"id\"])",
            "            == 0",
            "        )",
            "        assert (",
            "            helpers.call_action(\"dataset_follower_list\", id=dataset[\"id\"])",
            "            == []",
            "        )",
            "        assert not helpers.call_action(",
            "            \"am_following_dataset\", context, id=dataset[\"id\"]",
            "        )",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestFollowGroup(object):",
            "    def test_auth(self):",
            "        user = factories.User()",
            "        group = factories.Group()",
            "        context = {\"user\": \"\", \"ignore_auth\": False}",
            "        with pytest.raises(logic.NotAuthorized):",
            "            helpers.call_action(\"follow_group\", context, id=group[\"id\"])",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        helpers.call_action(\"follow_group\", context, id=group[\"id\"])",
            "",
            "    def test_follow_group(self):",
            "        user = factories.User()",
            "        group = factories.Group()",
            "        context = {\"user\": user[\"name\"]}",
            "        assert helpers.call_action(\"group_follower_count\", id=group[\"id\"]) == 0",
            "        assert helpers.call_action(\"group_follower_list\", id=group[\"id\"]) == []",
            "        assert not helpers.call_action(",
            "            \"am_following_group\", context, id=group[\"id\"]",
            "        )",
            "",
            "        helpers.call_action(\"follow_group\", context, id=group[\"id\"])",
            "        assert helpers.call_action(\"group_follower_count\", id=group[\"id\"]) == 1",
            "        assert [",
            "            u[\"name\"]",
            "            for u in helpers.call_action(\"group_follower_list\", id=group[\"id\"])",
            "        ] == [user[\"name\"]]",
            "        assert helpers.call_action(",
            "            \"am_following_group\", context, id=group[\"id\"]",
            "        )",
            "",
            "        helpers.call_action(\"unfollow_group\", context, id=group[\"id\"])",
            "        assert helpers.call_action(\"group_follower_count\", id=group[\"id\"]) == 0",
            "        assert helpers.call_action(\"group_follower_list\", id=group[\"id\"]) == []",
            "        assert not helpers.call_action(",
            "            \"am_following_group\", context, id=group[\"id\"]",
            "        )",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestFollowOrganization(object):",
            "    def test_auth(self):",
            "        user = factories.User()",
            "        organization = factories.Organization()",
            "        context = {\"user\": \"\", \"ignore_auth\": False}",
            "        with pytest.raises(logic.NotAuthorized):",
            "            helpers.call_action(\"follow_group\", context, id=organization[\"id\"])",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        helpers.call_action(\"follow_group\", context, id=organization[\"id\"])",
            "",
            "    def test_follow_organization(self):",
            "        user = factories.User()",
            "        group = factories.Organization()",
            "        context = {\"user\": user[\"name\"]}",
            "        assert helpers.call_action(\"group_follower_count\", id=group[\"id\"]) == 0",
            "        assert helpers.call_action(\"group_follower_list\", id=group[\"id\"]) == []",
            "        assert not helpers.call_action(",
            "            \"am_following_group\", context, id=group[\"id\"]",
            "        )",
            "",
            "        helpers.call_action(\"follow_group\", context, id=group[\"id\"])",
            "        assert helpers.call_action(\"group_follower_count\", id=group[\"id\"]) == 1",
            "        assert [",
            "            u[\"name\"]",
            "            for u in helpers.call_action(\"group_follower_list\", id=group[\"id\"])",
            "        ] == [user[\"name\"]]",
            "        assert helpers.call_action(",
            "            \"am_following_group\", context, id=group[\"id\"]",
            "        )",
            "",
            "        helpers.call_action(\"unfollow_group\", context, id=group[\"id\"])",
            "        assert helpers.call_action(\"group_follower_count\", id=group[\"id\"]) == 0",
            "        assert helpers.call_action(\"group_follower_list\", id=group[\"id\"]) == []",
            "        assert not helpers.call_action(",
            "            \"am_following_group\", context, id=group[\"id\"]",
            "        )",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestFollowUser(object):",
            "    def test_auth(self):",
            "        user = factories.User()",
            "        second_user = factories.User()",
            "",
            "        context = {\"user\": \"\", \"ignore_auth\": False}",
            "        with pytest.raises(logic.NotAuthorized):",
            "            helpers.call_action(\"follow_user\", context, id=second_user[\"id\"])",
            "        context = {\"user\": user[\"name\"], \"ignore_auth\": False}",
            "        helpers.call_action(\"follow_user\", context, id=second_user[\"id\"])",
            "",
            "    def test_cannot_follow_myself(self):",
            "        user = factories.User()",
            "        context = {\"user\": user[\"name\"]}",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"follow_user\", context, id=user[\"id\"])",
            "",
            "    def test_follow_user(self):",
            "        user = factories.User()",
            "        another_user = factories.User()",
            "        context = {\"user\": user[\"name\"]}",
            "        assert (",
            "            helpers.call_action(\"user_follower_count\", id=another_user[\"id\"])",
            "            == 0",
            "        )",
            "        assert (",
            "            helpers.call_action(\"user_follower_list\", id=another_user[\"id\"])",
            "            == []",
            "        )",
            "        assert not helpers.call_action(",
            "            \"am_following_user\", context, id=another_user[\"id\"]",
            "        )",
            "",
            "        helpers.call_action(\"follow_user\", context, id=another_user[\"id\"])",
            "        assert (",
            "            helpers.call_action(\"user_follower_count\", id=another_user[\"id\"])",
            "            == 1",
            "        )",
            "        assert [",
            "            u[\"name\"]",
            "            for u in helpers.call_action(",
            "                \"user_follower_list\", id=another_user[\"id\"]",
            "            )",
            "        ] == [user[\"name\"]]",
            "        assert helpers.call_action(",
            "            \"am_following_user\", context, id=another_user[\"id\"]",
            "        )",
            "",
            "        helpers.call_action(\"unfollow_user\", context, id=another_user[\"id\"])",
            "        assert (",
            "            helpers.call_action(\"user_follower_count\", id=another_user[\"id\"])",
            "            == 0",
            "        )",
            "        assert (",
            "            helpers.call_action(\"user_follower_list\", id=another_user[\"id\"])",
            "            == []",
            "        )",
            "        assert not helpers.call_action(",
            "            \"am_following_user\", context, id=another_user[\"id\"]",
            "        )",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestApiToken(object):",
            "    def test_token_created(self):",
            "        from ckan.lib.api_token import decode",
            "",
            "        user = factories.User()",
            "        data = helpers.call_action(",
            "            u\"api_token_create\",",
            "            context={u\"model\": model, u\"user\": user[u\"name\"]},",
            "            user=user[u\"name\"],",
            "            name=u\"token-name\",",
            "        )",
            "        token = data[u\"token\"]",
            "        jti = decode(token)[u\"jti\"]",
            "        res = model.ApiToken.get(jti)",
            "        assert res.user_id == user[u\"id\"]",
            "        assert res.last_access is None",
            "        assert res.id == jti",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "@pytest.mark.ckan_config(\"ckan.auth.allow_dataset_collaborators\", False)",
            "def test_create_package_collaborator_when_config_disabled():",
            "",
            "    dataset = factories.Dataset()",
            "    user = factories.User()",
            "    capacity = \"editor\"",
            "",
            "    with pytest.raises(logic.ValidationError):",
            "        helpers.call_action(",
            "            \"package_collaborator_create\",",
            "            id=dataset[\"id\"],",
            "            user_id=user[\"id\"],",
            "            capacity=capacity,",
            "        )",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "@pytest.mark.ckan_config(\"ckan.auth.allow_dataset_collaborators\", True)",
            "class TestPackageMemberCreate(object):",
            "    def test_create(self):",
            "        initial = model.Session.query(model.PackageMember).count()",
            "        dataset = factories.Dataset()",
            "        user = factories.User()",
            "        capacity = \"editor\"",
            "",
            "        member = helpers.call_action(",
            "            \"package_collaborator_create\",",
            "            id=dataset[\"id\"],",
            "            user_id=user[\"id\"],",
            "            capacity=capacity,",
            "        )",
            "",
            "        assert member[\"package_id\"] == dataset[\"id\"]",
            "        assert member[\"user_id\"] == user[\"id\"]",
            "        assert member[\"capacity\"] == capacity",
            "",
            "        assert model.Session.query(model.PackageMember).count() == initial + 1",
            "",
            "    def test_update(self):",
            "        dataset = factories.Dataset()",
            "        user = factories.User()",
            "        capacity = \"editor\"",
            "",
            "        helpers.call_action(",
            "            \"package_collaborator_create\",",
            "            id=dataset[\"id\"],",
            "            user_id=user[\"id\"],",
            "            capacity=capacity,",
            "        )",
            "",
            "        helpers.call_action(",
            "            \"package_collaborator_create\",",
            "            id=dataset[\"id\"],",
            "            user_id=user[\"id\"],",
            "            capacity=\"member\",",
            "        )",
            "",
            "        assert (",
            "            model.Session.query(model.PackageMember)",
            "            .filter_by(package_id=dataset[\"id\"])",
            "            .one()",
            "            .capacity",
            "            == \"member\"",
            "        )",
            "",
            "    def test_create_wrong_capacity(self):",
            "        dataset = factories.Dataset()",
            "        user = factories.User()",
            "        capacity = \"unknown\"",
            "",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"package_collaborator_create\",",
            "                id=dataset[\"id\"],",
            "                user_id=user[\"id\"],",
            "                capacity=capacity,",
            "            )",
            "",
            "    def test_create_dataset_not_found(self):",
            "        dataset = {\"id\": \"xxx\"}",
            "        user = factories.User()",
            "        capacity = \"editor\"",
            "",
            "        with pytest.raises(logic.NotFound):",
            "            helpers.call_action(",
            "                \"package_collaborator_create\",",
            "                id=dataset[\"id\"],",
            "                user_id=user[\"id\"],",
            "                capacity=capacity,",
            "            )",
            "",
            "    def test_create_user_not_found(self):",
            "        dataset = factories.Dataset()",
            "        user = {\"id\": \"yyy\"}",
            "        capacity = \"editor\"",
            "",
            "        with pytest.raises(logic.NotFound):",
            "            helpers.call_action(",
            "                \"package_collaborator_create\",",
            "                id=dataset[\"id\"],",
            "                user_id=user[\"id\"],",
            "                capacity=capacity,",
            "            )",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "@pytest.mark.ckan_config(\"ckan.auth.create_user_via_web\", True)",
            "class TestUserPluginExtras(object):",
            "    def test_stored_on_create_if_sysadmin(self):",
            "",
            "        sysadmin = factories.Sysadmin()",
            "        stub = factories.User.stub()",
            "        user_dict = {",
            "            \"name\": stub.name,",
            "            \"email\": stub.email,",
            "            \"password\": \"12345678\",",
            "            \"plugin_extras\": {\"plugin1\": {\"key1\": \"value1\"}},",
            "        }",
            "",
            "        # helpers.call_action sets 'ignore_auth' to True by default",
            "        context = {\"user\": sysadmin[\"name\"], \"ignore_auth\": False}",
            "",
            "        created_user = helpers.call_action(",
            "            \"user_create\", context=context, **user_dict",
            "        )",
            "",
            "        assert created_user[\"plugin_extras\"] == {",
            "            \"plugin1\": {",
            "                \"key1\": \"value1\",",
            "            }",
            "        }",
            "",
            "        user_dict = helpers.call_action(",
            "            \"user_show\",",
            "            context=context,",
            "            id=created_user[\"id\"],",
            "            include_plugin_extras=True,",
            "        )",
            "",
            "        assert user_dict[\"plugin_extras\"] == {",
            "            \"plugin1\": {",
            "                \"key1\": \"value1\",",
            "            }",
            "        }",
            "",
            "        plugin_extras_from_db = (",
            "            model.Session.execute(",
            "                sa.text('SELECT plugin_extras FROM \"user\" WHERE id=:id'),",
            "                {\"id\": created_user[\"id\"]},",
            "            )",
            "            .first()[0]",
            "        )",
            "",
            "        assert plugin_extras_from_db == {",
            "            \"plugin1\": {",
            "                \"key1\": \"value1\",",
            "            }",
            "        }",
            "",
            "    def test_ignored_on_create_if_non_sysadmin(self):",
            "",
            "        author = factories.User()",
            "        sysadmin = factories.Sysadmin()",
            "        stub = factories.User.stub()",
            "        user_dict = {",
            "            \"name\": stub.name,",
            "            \"email\": stub.email,",
            "            \"password\": \"12345678\",",
            "            \"plugin_extras\": {\"plugin1\": {\"key1\": \"value1\"}},",
            "        }",
            "",
            "        # helpers.call_action sets 'ignore_auth' to True by default",
            "        context = {\"user\": author[\"name\"], \"ignore_auth\": False}",
            "",
            "        created_user = helpers.call_action(",
            "            \"user_create\", context=context, **user_dict",
            "        )",
            "",
            "        assert \"plugin_extras\" not in created_user",
            "",
            "        context = {\"user\": sysadmin[\"name\"], \"ignore_auth\": False}",
            "        user = helpers.call_action(",
            "            \"user_show\",",
            "            context=context,",
            "            id=created_user[\"id\"],",
            "            include_plugin_extras=True,",
            "        )",
            "",
            "        assert user[\"plugin_extras\"] is None",
            "",
            "    def test_extensions_can_provide_custom_id(self):",
            "",
            "        stub = factories.User.stub()",
            "        context = {\"user\": None, \"ignore_auth\": True}",
            "        _id = str(uuid.uuid4())",
            "        user_dict = {",
            "            \"id\": _id,",
            "            \"name\": stub.name,",
            "            \"email\": stub.email,",
            "            \"password\": \"12345678\",",
            "        }",
            "        created_user = helpers.call_action(\"user_create\", context=context, **user_dict)",
            "",
            "        assert created_user[\"id\"] == _id",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestUserImageUrl(object):",
            "    def test_external_picture(self):",
            "        stub = factories.User.stub()",
            "        params = {",
            "            \"name\": stub.name,",
            "            \"email\": stub.email,",
            "            \"password\": \"12345678\",",
            "            \"image_url\": \"https://example.com/mypic.png\",",
            "        }",
            "",
            "        user_dict = helpers.call_action(\"user_create\", {}, **params)",
            "",
            "        assert user_dict[\"image_url\"] == \"https://example.com/mypic.png\"",
            "        assert (",
            "            user_dict[\"image_display_url\"] == \"https://example.com/mypic.png\"",
            "        )",
            "",
            "    def test_upload_picture_works_without_extra_config(",
            "            self, create_with_upload, faker):",
            "        params = {",
            "            \"name\": faker.user_name(),",
            "            \"email\": faker.email(),",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        assert create_with_upload(faker.image(), \"image.png\", **params)",
            "",
            "    def test_upload_non_picture_fails_without_extra_config(",
            "            self, create_with_upload, faker):",
            "        params = {",
            "            \"name\": faker.user_name(),",
            "            \"email\": faker.email(),",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        with pytest.raises(",
            "                logic.ValidationError, match=\"Unsupported upload type\"):",
            "            create_with_upload(\"hello world\", \"file.txt\", **params)",
            "",
            "    def test_upload_non_picture_html_fails_without_extra_config(",
            "            self, create_with_upload, faker):",
            "        params = {",
            "            \"name\": faker.user_name(),",
            "            \"email\": faker.email(),",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        with pytest.raises(",
            "                logic.ValidationError, match=\"Unsupported upload type\"):",
            "            create_with_upload(\"<html><body>hello world</body></html>\", \"file.html\", **params)",
            "",
            "    def test_upload_svg_fails_without_extra_config(",
            "            self, create_with_upload, faker):",
            "        params = {",
            "            \"name\": faker.user_name(),",
            "            \"email\": faker.email(),",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        with pytest.raises(",
            "                logic.ValidationError, match=\"Unsupported upload type\"):",
            "            create_with_upload('<svg xmlns=\"http://www.w3.org/2000/svg\"></svg>', \"file.svg\", **params)",
            "",
            "    def test_upload_svg_wrong_extension_fails_without_extra_config(",
            "            self, create_with_upload, faker):",
            "        params = {",
            "            \"name\": faker.user_name(),",
            "            \"email\": faker.email(),",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        with pytest.raises(",
            "                logic.ValidationError, match=\"Unsupported upload type\"):",
            "            create_with_upload('<svg xmlns=\"http://www.w3.org/2000/svg\"></svg>', \"file.png\", **params)",
            "",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"image\")",
            "    def test_upload_non_picture_with_png_extension(",
            "            self, create_with_upload, faker):",
            "        params = {",
            "            \"name\": faker.user_name(),",
            "            \"email\": faker.email(),",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        with pytest.raises(",
            "                logic.ValidationError, match=\"Unsupported upload type\"):",
            "            create_with_upload(\"hello world\", \"file.png\", **params)",
            "",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.mimetypes\", \"\")",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"\")",
            "    def test_uploads_not_allowed_when_empty_mimetypes_and_types(",
            "            self, create_with_upload, faker):",
            "        params = {",
            "            \"name\": faker.user_name(),",
            "            \"email\": faker.email(),",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        with pytest.raises(",
            "                logic.ValidationError, match=\"No uploads allowed for object type\"):",
            "            create_with_upload(\"hello world\", \"file.png\", **params)",
            "",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.mimetypes\", \"*\")",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"image\")",
            "    def test_upload_all_types_allowed_needs_both_options(self, create_with_upload, faker):",
            "        params = {",
            "            \"name\": faker.user_name(),",
            "            \"email\": faker.email(),",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        with pytest.raises(",
            "                logic.ValidationError, match=\"Unsupported upload type\"):",
            "            assert create_with_upload(faker.json(), \"file.json\", **params)",
            "",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.mimetypes\", \"*\")",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"*\")",
            "    def test_upload_all_types_allowed(self, create_with_upload, faker):",
            "        params = {",
            "            \"name\": faker.user_name(),",
            "            \"email\": faker.email(),",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        assert create_with_upload(faker.json(), \"file.json\", **params)",
            "",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"image\")",
            "    def test_upload_picture(self, create_with_upload, faker):",
            "        params = {",
            "            \"name\": faker.user_name(),",
            "            \"email\": faker.email(),",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        assert create_with_upload(faker.image(), \"file.png\", **params)",
            "",
            "    @pytest.mark.ckan_config(\"ckan.upload.user.types\", \"image\")",
            "    def test_upload_picture_extension_enforced(self, create_with_upload, faker):",
            "        params = {",
            "            \"name\": faker.user_name(),",
            "            \"email\": faker.email(),",
            "            \"password\": \"12345678\",",
            "            \"action\": \"user_create\",",
            "            \"upload_field_name\": \"image_upload\",",
            "        }",
            "        user = create_with_upload(faker.image(image_format=\"jpeg\"), \"file.png\", **params)",
            "",
            "        assert user[\"image_url\"].endswith(\".jpg\")",
            "        assert user[\"image_display_url\"].endswith(\".jpg\")",
            "",
            "",
            "class TestVocabularyCreate(object):",
            "    @pytest.mark.usefixtures(\"non_clean_db\")",
            "    def test_basic(self):",
            "        name = factories.Vocabulary.stub().name",
            "        vocab = helpers.call_action(\"vocabulary_create\", name=name)",
            "        obj = model.Vocabulary.get(name)",
            "        assert obj.id == vocab[\"id\"]",
            "",
            "    @pytest.mark.usefixtures(\"non_clean_db\")",
            "    def test_with_tags(self):",
            "        name = factories.Vocabulary.stub().name",
            "        tag1 = factories.Tag.stub().name",
            "        tag2 = factories.Tag.stub().name",
            "        tags = [{\"name\": tag1}, {\"name\": tag2}]",
            "        helpers.call_action(\"vocabulary_create\", name=name, tags=tags)",
            "        vocab = helpers.call_action(\"vocabulary_show\", id=name)",
            "        assert vocab[\"name\"] == name",
            "        assert len(vocab[\"tags\"]) == 2",
            "        for tag in vocab[\"tags\"]:",
            "            assert tag[\"vocabulary_id\"] == vocab[\"id\"]",
            "            assert tag[\"name\"] in {tag1, tag2}",
            "",
            "    @pytest.mark.usefixtures(\"non_clean_db\")",
            "    def test_with_empty_tags(self):",
            "        name = factories.Vocabulary.stub().name",
            "        resp = helpers.call_action(\"vocabulary_create\", name=name, tags=[])",
            "        assert resp[\"tags\"] == []",
            "",
            "    @pytest.mark.usefixtures(\"non_clean_db\")",
            "    def test_with_existing_name(self):",
            "        name = factories.Vocabulary.stub().name",
            "        helpers.call_action(\"vocabulary_create\", name=name, tags=[])",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"vocabulary_create\", name=name, tags=[])",
            "",
            "    @pytest.mark.parametrize(",
            "        \"tags\",",
            "        [",
            "            [{\"id\": \"xxx\"}, {\"name\": \"foo\"}],",
            "            [{\"name\": \"foo\"}, {\"name\": None}],",
            "            [{\"name\": \"foo\"}, {\"name\": \"\"}],",
            "            [{\"name\": \"foo\"}, {\"name\": \"f\"}],",
            "            [{\"name\": \"f\" * 200}, {\"name\": \"foo\"}],",
            "            [{\"name\": \"Invalid!\"}, {\"name\": \"foo\"}],",
            "        ],",
            "    )",
            "    def test_with_bad_tags(self, tags):",
            "        name = factories.Vocabulary.stub().name",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"vocabulary_create\", name=name, tags=tags)",
            "",
            "    def test_with_no_tags(self):",
            "        name = factories.Vocabulary.stub().name",
            "        with pytest.raises(DataError):",
            "            helpers.call_action(\"vocabulary_create\", name=name, tags=None)",
            "",
            "    def test_id_not_allowed(self):",
            "        name = factories.Vocabulary.stub().name",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"vocabulary_create\", name=name, id=\"xxx\")",
            "",
            "    def test_no_name(self):",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"vocabulary_create\")",
            "",
            "    @pytest.mark.parametrize(\"name\", (None, \"\", \"a\", \"foobar\" * 100))",
            "    def test_invalid_name(self, name):",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"vocabulary_create\", name=name)",
            "",
            "",
            "class TestTagCreate:",
            "    @pytest.mark.usefixtures(\"non_clean_db\")",
            "    def test_add_tag_to_vocab(self):",
            "        tag1 = factories.Tag.stub().name",
            "        tag2 = factories.Tag.stub().name",
            "        vocab = factories.Vocabulary(tags=[{\"name\": tag1}])",
            "        assert set(map(operator.itemgetter(\"name\"), vocab[\"tags\"])) == {tag1}",
            "        helpers.call_action(\"tag_create\", name=tag2, vocabulary_id=vocab[\"id\"])",
            "",
            "        vocab = helpers.call_action(\"vocabulary_show\", id=vocab[\"id\"])",
            "        assert set(map(operator.itemgetter(\"name\"), vocab[\"tags\"])) == {",
            "            tag1,",
            "            tag2,",
            "        }",
            "",
            "    def test_no_vocab(self):",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"tag_create\", name=factories.Tag.stub().name)",
            "",
            "    def test_does_not_exist(self):",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"tag_create\",",
            "                name=factories.Tag.stub().name,",
            "                vocabulary_id=factories.Vocabulary.stub().name,",
            "            )",
            "",
            "    @pytest.mark.usefixtures(\"non_clean_db\")",
            "    def test_duplicate(self):",
            "        tag1 = factories.Tag.stub().name",
            "        vocab = factories.Vocabulary(tags=[{\"name\": tag1}])",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"tag_create\", name=tag1, vocabulary_id=vocab[\"id\"]",
            "            )",
            "",
            "    @pytest.mark.usefixtures(\"non_clean_db\")",
            "    def test_id_not_allowed(self):",
            "        vocab = factories.Vocabulary()",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"tag_create\", name=\"foo\", id=\"xxx\", vocabulary_id=vocab[\"id\"]",
            "            )",
            "",
            "    @pytest.mark.usefixtures(\"non_clean_db\")",
            "    def test_name_is_required(self):",
            "        vocab = factories.Vocabulary()",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(\"tag_create\", vocabulary_id=vocab[\"id\"])",
            "",
            "    @pytest.mark.usefixtures(\"non_clean_db\")",
            "    def test_invalid_name(self):",
            "        vocab = factories.Vocabulary()",
            "        for name in (\"Not a valid tag name!\", \"\", None):",
            "            with pytest.raises(logic.ValidationError):",
            "                helpers.call_action(",
            "                    \"tag_create\", name=name, vocabulary_id=vocab[\"id\"]",
            "                )",
            "",
            "",
            "@pytest.mark.usefixtures(\"non_clean_db\")",
            "class TestMemberCreate2:",
            "    def test_member_create_accepts_object_name_or_id(self):",
            "        org = factories.Organization()",
            "        package = factories.Dataset()",
            "        helpers.call_action(",
            "            \"member_create\",",
            "            object=package[\"id\"],",
            "            id=org[\"id\"],",
            "            object_type=\"package\",",
            "            capacity=\"member\",",
            "        )",
            "        helpers.call_action(",
            "            \"member_create\",",
            "            object=package[\"name\"],",
            "            id=org[\"id\"],",
            "            object_type=\"package\",",
            "            capacity=\"member\",",
            "        )",
            "",
            "    def test_member_create_raises_if_user_unauthorized_to_update_group(self):",
            "        org = factories.Organization()",
            "        pkg = factories.Dataset()",
            "        user = factories.User()",
            "        context = {\"ignore_auth\": False, \"user\": user[\"name\"]}",
            "        with pytest.raises(logic.NotAuthorized):",
            "            helpers.call_action(",
            "                \"member_create\",",
            "                context,",
            "                object=pkg[\"name\"],",
            "                id=org[\"id\"],",
            "                object_type=\"package\",",
            "                capacity=\"member\",",
            "            )",
            "",
            "    def test_member_create_raises_if_any_required_parameter_isnt_defined(self):",
            "        org = factories.Organization()",
            "        pkg = factories.Dataset()",
            "        data = dict(",
            "            object=pkg[\"name\"],",
            "            id=org[\"id\"],",
            "            object_type=\"package\",",
            "            capacity=\"member\",",
            "        )",
            "        for key in [\"id\", \"object\", \"object_type\"]:",
            "            payload = data.copy()",
            "            payload.pop(key)",
            "            with pytest.raises(logic.ValidationError):",
            "                helpers.call_action(\"member_create\", **payload)",
            "",
            "    def test_member_create_raises_if_group_wasnt_found(self):",
            "        pkg = factories.Dataset()",
            "        with pytest.raises(logic.NotFound):",
            "            helpers.call_action(",
            "                \"member_create\",",
            "                object=pkg[\"name\"],",
            "                id=\"not-real\",",
            "                object_type=\"package\",",
            "                capacity=\"member\",",
            "            )",
            "",
            "    def test_member_create_raises_if_object_wasnt_found(self):",
            "        org = factories.Organization()",
            "        with pytest.raises(logic.NotFound):",
            "            helpers.call_action(",
            "                \"member_create\",",
            "                object=\"not-real\",",
            "                id=org[\"id\"],",
            "                object_type=\"package\",",
            "                capacity=\"member\",",
            "            )",
            "",
            "    def test_member_create_raises_if_object_type_is_invalid(self):",
            "        org = factories.Organization()",
            "        pkg = factories.Dataset()",
            "        with pytest.raises(logic.ValidationError):",
            "            helpers.call_action(",
            "                \"member_create\",",
            "                object=pkg[\"name\"],",
            "                id=org[\"id\"],",
            "                object_type=\"notvalid\",",
            "                capacity=\"member\",",
            "            )",
            "",
            "",
            "@pytest.mark.usefixtures(\"clean_db\")",
            "class TestPackagePluginData(object):",
            "",
            "    def test_stored_on_create_if_sysadmin(self):",
            "        sysadmin = factories.Sysadmin()",
            "",
            "        pkg_dict = {",
            "            \"name\": \"test-dataset\",",
            "            \"plugin_data\": {",
            "                \"plugin1\": {",
            "                    \"key1\": \"value1\"",
            "                }",
            "            }",
            "        }",
            "        context = {",
            "            \"user\": sysadmin[\"name\"],",
            "            \"ignore_auth\": False,",
            "            \"auth_user_obj\": model.User.get(sysadmin[\"name\"])",
            "        }",
            "        created_pkg = helpers.call_action(",
            "            \"package_create\", context=context, **pkg_dict",
            "        )",
            "        assert created_pkg[\"plugin_data\"] == {",
            "            \"plugin1\": {",
            "                \"key1\": \"value1\"",
            "            }",
            "        }",
            "        plugin_data_from_db = model.Session.execute(",
            "            sa.text('SELECT plugin_data FROM \"package\" WHERE id=:id'),",
            "            {'id': created_pkg[\"id\"]}",
            "        ).first()[0]",
            "",
            "        assert plugin_data_from_db == {\"plugin1\": {\"key1\": \"value1\"}}",
            "",
            "    def test_ignored_on_create_if_non_sysadmin(self):",
            "        user = factories.User()",
            "",
            "        pkg_dict = {",
            "            \"name\": \"test-dataset\",",
            "            \"plugin_data\": {",
            "                \"plugin1\": {",
            "                    \"key1\": \"value1\"",
            "                }",
            "            }",
            "        }",
            "        context = {",
            "            \"user\": user[\"name\"],",
            "            \"ignore_auth\": False,",
            "        }",
            "        created_pkg = helpers.call_action(",
            "            'package_create', context=context, **pkg_dict",
            "        )",
            "        assert \"plugin_data\" not in created_pkg",
            "",
            "        plugin_data_from_db = model.Session.execute(",
            "            sa.text('SELECT plugin_data FROM \"package\" WHERE id=:id'),",
            "            {'id': created_pkg[\"id\"]}",
            "        ).first()[0]",
            "        assert plugin_data_from_db is None"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "yt_dlp.YoutubeDL",
            "ckan.tests.logic.action.test_create.TestUserImageUrl.self"
        ]
    }
}