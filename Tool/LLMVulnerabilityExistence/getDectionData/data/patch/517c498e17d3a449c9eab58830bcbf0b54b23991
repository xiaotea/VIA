{
    "airflow/providers/odbc/hooks/odbc.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "     :param args: passed to DbApiHook"
            },
            "2": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "     :param database: database to use -- overrides connection ``schema``"
            },
            "3": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    :param driver: name of driver or path to driver. overrides driver supplied in connection ``extra``"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+    :param driver: name of driver or path to driver. You can also set the driver via:"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+       * setting ``driver`` parameter in ``hook_params`` dictionary when instantiating hook by SQL operators."
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+       * setting `driver`` extra in the connection and setting  ``allow_driver_extra`` to True."
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+       * setting ``OdbcHook.default_driver`` in ``local_settings.py`` file."
            },
            "8": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "     :param dsn: name of DSN to use.  overrides DSN supplied in connection ``extra``"
            },
            "9": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     :param connect_kwargs: keyword arguments passed to ``pyodbc.connect``"
            },
            "10": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     :param sqlalchemy_scheme: Scheme sqlalchemy connection.  Default is ``mssql+pyodbc`` Only used for"
            },
            "11": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "         ``get_sqlalchemy_engine`` and ``get_sqlalchemy_connection`` methods."
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+    :param allow_driver_extra: If True, allows to use driver extra in connection string (default False)."
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+           You should make sure that you trust the users who can edit connections in the UI to not use it"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+           maliciously."
            },
            "15": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "     :param kwargs: passed to DbApiHook"
            },
            "16": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "     \"\"\""
            },
            "17": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "     hook_name = \"ODBC\""
            },
            "19": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 56,
                "PatchRowcode": "     supports_autocommit = True"
            },
            "20": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+    default_driver: str | None = None"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+"
            },
            "23": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "     def __init__("
            },
            "24": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "         self,"
            },
            "25": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         *args,"
            },
            "26": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 65,
                "PatchRowcode": "         dsn: str | None = None,"
            },
            "27": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "         connect_kwargs: dict | None = None,"
            },
            "28": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 67,
                "PatchRowcode": "         sqlalchemy_scheme: str | None = None,"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+        allow_driver_extra: bool = False,"
            },
            "30": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "         **kwargs,"
            },
            "31": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "     ) -> None:"
            },
            "32": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "         super().__init__(*args, **kwargs)"
            },
            "33": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "         self._sqlalchemy_scheme = sqlalchemy_scheme"
            },
            "34": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "         self._connection = None"
            },
            "35": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "         self._connect_kwargs = connect_kwargs"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+        self._allow_driver_extra = allow_driver_extra"
            },
            "37": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 80,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "     @property"
            },
            "39": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "     def connection(self):"
            },
            "40": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 111,
                "PatchRowcode": "     @property"
            },
            "41": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 112,
                "PatchRowcode": "     def driver(self) -> str | None:"
            },
            "42": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 113,
                "PatchRowcode": "         \"\"\"Driver from init param if given; else try to find one in connection extra.\"\"\""
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+        extra_driver = self.connection_extra_lower.get(\"driver\")"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+        if extra_driver:"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+            if self._allow_driver_extra:"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+                self._driver = extra_driver"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+            else:"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+                self.log.warning("
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 120,
                "PatchRowcode": "+                    \"Please provide driver via 'driver' parameter of the Hook constructor\""
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 121,
                "PatchRowcode": "+                    \" or via 'hook_params' dictionary 'driver' key when instantiating hook by the\""
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 122,
                "PatchRowcode": "+                    \" SQL operators. The 'driver' extra will not be used.\""
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+                )"
            },
            "53": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "         if not self._driver:"
            },
            "54": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            driver = self.connection_extra_lower.get(\"driver\")"
            },
            "55": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if driver:"
            },
            "56": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                self._driver = driver"
            },
            "57": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return self._driver and self._driver.strip().lstrip(\"{\").rstrip(\"}\").strip()"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 125,
                "PatchRowcode": "+            self._driver = self.default_driver"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 126,
                "PatchRowcode": "+        return self._driver.strip().lstrip(\"{\").rstrip(\"}\").strip() if self._driver else None"
            },
            "60": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 127,
                "PatchRowcode": " "
            },
            "61": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 128,
                "PatchRowcode": "     @property"
            },
            "62": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "     def dsn(self) -> str | None:"
            }
        },
        "frontPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "\"\"\"This module contains ODBC hook.\"\"\"",
            "from __future__ import annotations",
            "",
            "from typing import Any",
            "from urllib.parse import quote_plus",
            "",
            "import pyodbc",
            "",
            "from airflow.providers.common.sql.hooks.sql import DbApiHook",
            "from airflow.utils.helpers import merge_dicts",
            "",
            "",
            "class OdbcHook(DbApiHook):",
            "    \"\"\"",
            "    Interact with odbc data sources using pyodbc.",
            "",
            "    See :doc:`/connections/odbc` for full documentation.",
            "",
            "    :param args: passed to DbApiHook",
            "    :param database: database to use -- overrides connection ``schema``",
            "    :param driver: name of driver or path to driver. overrides driver supplied in connection ``extra``",
            "    :param dsn: name of DSN to use.  overrides DSN supplied in connection ``extra``",
            "    :param connect_kwargs: keyword arguments passed to ``pyodbc.connect``",
            "    :param sqlalchemy_scheme: Scheme sqlalchemy connection.  Default is ``mssql+pyodbc`` Only used for",
            "        ``get_sqlalchemy_engine`` and ``get_sqlalchemy_connection`` methods.",
            "    :param kwargs: passed to DbApiHook",
            "    \"\"\"",
            "",
            "    DEFAULT_SQLALCHEMY_SCHEME = \"mssql+pyodbc\"",
            "    conn_name_attr = \"odbc_conn_id\"",
            "    default_conn_name = \"odbc_default\"",
            "    conn_type = \"odbc\"",
            "    hook_name = \"ODBC\"",
            "    supports_autocommit = True",
            "",
            "    def __init__(",
            "        self,",
            "        *args,",
            "        database: str | None = None,",
            "        driver: str | None = None,",
            "        dsn: str | None = None,",
            "        connect_kwargs: dict | None = None,",
            "        sqlalchemy_scheme: str | None = None,",
            "        **kwargs,",
            "    ) -> None:",
            "        super().__init__(*args, **kwargs)",
            "        self._database = database",
            "        self._driver = driver",
            "        self._dsn = dsn",
            "        self._conn_str = None",
            "        self._sqlalchemy_scheme = sqlalchemy_scheme",
            "        self._connection = None",
            "        self._connect_kwargs = connect_kwargs",
            "",
            "    @property",
            "    def connection(self):",
            "        \"\"\"The Connection object with ID ``odbc_conn_id``.\"\"\"",
            "        if not self._connection:",
            "            self._connection = self.get_connection(getattr(self, self.conn_name_attr))",
            "        return self._connection",
            "",
            "    @property",
            "    def database(self) -> str | None:",
            "        \"\"\"Database provided in init if exists; otherwise, ``schema`` from ``Connection`` object.\"\"\"",
            "        return self._database or self.connection.schema",
            "",
            "    @property",
            "    def sqlalchemy_scheme(self) -> str:",
            "        \"\"\"SQLAlchemy scheme either from constructor, connection extras or default.\"\"\"",
            "        return (",
            "            self._sqlalchemy_scheme",
            "            or self.connection_extra_lower.get(\"sqlalchemy_scheme\")",
            "            or self.DEFAULT_SQLALCHEMY_SCHEME",
            "        )",
            "",
            "    @property",
            "    def connection_extra_lower(self) -> dict:",
            "        \"\"\"",
            "        ``connection.extra_dejson`` but where keys are converted to lower case.",
            "",
            "        This is used internally for case-insensitive access of odbc params.",
            "        \"\"\"",
            "        return {k.lower(): v for k, v in self.connection.extra_dejson.items()}",
            "",
            "    @property",
            "    def driver(self) -> str | None:",
            "        \"\"\"Driver from init param if given; else try to find one in connection extra.\"\"\"",
            "        if not self._driver:",
            "            driver = self.connection_extra_lower.get(\"driver\")",
            "            if driver:",
            "                self._driver = driver",
            "        return self._driver and self._driver.strip().lstrip(\"{\").rstrip(\"}\").strip()",
            "",
            "    @property",
            "    def dsn(self) -> str | None:",
            "        \"\"\"DSN from init param if given; else try to find one in connection extra.\"\"\"",
            "        if not self._dsn:",
            "            dsn = self.connection_extra_lower.get(\"dsn\")",
            "            if dsn:",
            "                self._dsn = dsn.strip()",
            "        return self._dsn",
            "",
            "    @property",
            "    def odbc_connection_string(self):",
            "        \"\"\"ODBC connection string.",
            "",
            "        We build connection string instead of using ``pyodbc.connect`` params",
            "        because, for example, there is no param representing",
            "        ``ApplicationIntent=ReadOnly``.  Any key-value pairs provided in",
            "        ``Connection.extra`` will be added to the connection string.",
            "        \"\"\"",
            "        if not self._conn_str:",
            "            conn_str = \"\"",
            "            if self.driver:",
            "                conn_str += f\"DRIVER={{{self.driver}}};\"",
            "            if self.dsn:",
            "                conn_str += f\"DSN={self.dsn};\"",
            "            if self.connection.host:",
            "                conn_str += f\"SERVER={self.connection.host};\"",
            "            database = self.database or self.connection.schema",
            "            if database:",
            "                conn_str += f\"DATABASE={database};\"",
            "            if self.connection.login:",
            "                conn_str += f\"UID={self.connection.login};\"",
            "            if self.connection.password:",
            "                conn_str += f\"PWD={self.connection.password};\"",
            "            if self.connection.port:",
            "                conn_str += f\"PORT={self.connection.port};\"",
            "",
            "            extra_exclude = {\"driver\", \"dsn\", \"connect_kwargs\", \"sqlalchemy_scheme\"}",
            "            extra_params = {",
            "                k: v for k, v in self.connection.extra_dejson.items() if k.lower() not in extra_exclude",
            "            }",
            "            for k, v in extra_params.items():",
            "                conn_str += f\"{k}={v};\"",
            "",
            "            self._conn_str = conn_str",
            "        return self._conn_str",
            "",
            "    @property",
            "    def connect_kwargs(self) -> dict:",
            "        \"\"\"Effective kwargs to be passed to ``pyodbc.connect``.",
            "",
            "        The kwargs are merged from connection extra, ``connect_kwargs``, and",
            "        the hook's init arguments. Values received to the hook precede those",
            "        from the connection.",
            "",
            "        If ``attrs_before`` is provided, keys and values are converted to int,",
            "        as required by pyodbc.",
            "        \"\"\"",
            "        conn_connect_kwargs = self.connection_extra_lower.get(\"connect_kwargs\", {})",
            "        hook_connect_kwargs = self._connect_kwargs or {}",
            "        merged_connect_kwargs = merge_dicts(conn_connect_kwargs, hook_connect_kwargs)",
            "",
            "        if \"attrs_before\" in merged_connect_kwargs:",
            "            merged_connect_kwargs[\"attrs_before\"] = {",
            "                int(k): int(v) for k, v in merged_connect_kwargs[\"attrs_before\"].items()",
            "            }",
            "",
            "        return merged_connect_kwargs",
            "",
            "    def get_conn(self) -> pyodbc.Connection:",
            "        \"\"\"Returns a pyodbc connection object.\"\"\"",
            "        conn = pyodbc.connect(self.odbc_connection_string, **self.connect_kwargs)",
            "        return conn",
            "",
            "    def get_uri(self) -> str:",
            "        \"\"\"URI invoked in :meth:`~airflow.providers.common.sql.hooks.sql.DbApiHook.get_sqlalchemy_engine`.\"\"\"",
            "        quoted_conn_str = quote_plus(self.odbc_connection_string)",
            "        uri = f\"{self.sqlalchemy_scheme}:///?odbc_connect={quoted_conn_str}\"",
            "        return uri",
            "",
            "    def get_sqlalchemy_connection(",
            "        self, connect_kwargs: dict | None = None, engine_kwargs: dict | None = None",
            "    ) -> Any:",
            "        \"\"\"SQLAlchemy connection object.\"\"\"",
            "        engine = self.get_sqlalchemy_engine(engine_kwargs=engine_kwargs)",
            "        cnx = engine.connect(**(connect_kwargs or {}))",
            "        return cnx"
        ],
        "afterPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "\"\"\"This module contains ODBC hook.\"\"\"",
            "from __future__ import annotations",
            "",
            "from typing import Any",
            "from urllib.parse import quote_plus",
            "",
            "import pyodbc",
            "",
            "from airflow.providers.common.sql.hooks.sql import DbApiHook",
            "from airflow.utils.helpers import merge_dicts",
            "",
            "",
            "class OdbcHook(DbApiHook):",
            "    \"\"\"",
            "    Interact with odbc data sources using pyodbc.",
            "",
            "    See :doc:`/connections/odbc` for full documentation.",
            "",
            "    :param args: passed to DbApiHook",
            "    :param database: database to use -- overrides connection ``schema``",
            "    :param driver: name of driver or path to driver. You can also set the driver via:",
            "       * setting ``driver`` parameter in ``hook_params`` dictionary when instantiating hook by SQL operators.",
            "       * setting `driver`` extra in the connection and setting  ``allow_driver_extra`` to True.",
            "       * setting ``OdbcHook.default_driver`` in ``local_settings.py`` file.",
            "    :param dsn: name of DSN to use.  overrides DSN supplied in connection ``extra``",
            "    :param connect_kwargs: keyword arguments passed to ``pyodbc.connect``",
            "    :param sqlalchemy_scheme: Scheme sqlalchemy connection.  Default is ``mssql+pyodbc`` Only used for",
            "        ``get_sqlalchemy_engine`` and ``get_sqlalchemy_connection`` methods.",
            "    :param allow_driver_extra: If True, allows to use driver extra in connection string (default False).",
            "           You should make sure that you trust the users who can edit connections in the UI to not use it",
            "           maliciously.",
            "    :param kwargs: passed to DbApiHook",
            "    \"\"\"",
            "",
            "    DEFAULT_SQLALCHEMY_SCHEME = \"mssql+pyodbc\"",
            "    conn_name_attr = \"odbc_conn_id\"",
            "    default_conn_name = \"odbc_default\"",
            "    conn_type = \"odbc\"",
            "    hook_name = \"ODBC\"",
            "    supports_autocommit = True",
            "",
            "    default_driver: str | None = None",
            "",
            "    def __init__(",
            "        self,",
            "        *args,",
            "        database: str | None = None,",
            "        driver: str | None = None,",
            "        dsn: str | None = None,",
            "        connect_kwargs: dict | None = None,",
            "        sqlalchemy_scheme: str | None = None,",
            "        allow_driver_extra: bool = False,",
            "        **kwargs,",
            "    ) -> None:",
            "        super().__init__(*args, **kwargs)",
            "        self._database = database",
            "        self._driver = driver",
            "        self._dsn = dsn",
            "        self._conn_str = None",
            "        self._sqlalchemy_scheme = sqlalchemy_scheme",
            "        self._connection = None",
            "        self._connect_kwargs = connect_kwargs",
            "        self._allow_driver_extra = allow_driver_extra",
            "",
            "    @property",
            "    def connection(self):",
            "        \"\"\"The Connection object with ID ``odbc_conn_id``.\"\"\"",
            "        if not self._connection:",
            "            self._connection = self.get_connection(getattr(self, self.conn_name_attr))",
            "        return self._connection",
            "",
            "    @property",
            "    def database(self) -> str | None:",
            "        \"\"\"Database provided in init if exists; otherwise, ``schema`` from ``Connection`` object.\"\"\"",
            "        return self._database or self.connection.schema",
            "",
            "    @property",
            "    def sqlalchemy_scheme(self) -> str:",
            "        \"\"\"SQLAlchemy scheme either from constructor, connection extras or default.\"\"\"",
            "        return (",
            "            self._sqlalchemy_scheme",
            "            or self.connection_extra_lower.get(\"sqlalchemy_scheme\")",
            "            or self.DEFAULT_SQLALCHEMY_SCHEME",
            "        )",
            "",
            "    @property",
            "    def connection_extra_lower(self) -> dict:",
            "        \"\"\"",
            "        ``connection.extra_dejson`` but where keys are converted to lower case.",
            "",
            "        This is used internally for case-insensitive access of odbc params.",
            "        \"\"\"",
            "        return {k.lower(): v for k, v in self.connection.extra_dejson.items()}",
            "",
            "    @property",
            "    def driver(self) -> str | None:",
            "        \"\"\"Driver from init param if given; else try to find one in connection extra.\"\"\"",
            "        extra_driver = self.connection_extra_lower.get(\"driver\")",
            "        if extra_driver:",
            "            if self._allow_driver_extra:",
            "                self._driver = extra_driver",
            "            else:",
            "                self.log.warning(",
            "                    \"Please provide driver via 'driver' parameter of the Hook constructor\"",
            "                    \" or via 'hook_params' dictionary 'driver' key when instantiating hook by the\"",
            "                    \" SQL operators. The 'driver' extra will not be used.\"",
            "                )",
            "        if not self._driver:",
            "            self._driver = self.default_driver",
            "        return self._driver.strip().lstrip(\"{\").rstrip(\"}\").strip() if self._driver else None",
            "",
            "    @property",
            "    def dsn(self) -> str | None:",
            "        \"\"\"DSN from init param if given; else try to find one in connection extra.\"\"\"",
            "        if not self._dsn:",
            "            dsn = self.connection_extra_lower.get(\"dsn\")",
            "            if dsn:",
            "                self._dsn = dsn.strip()",
            "        return self._dsn",
            "",
            "    @property",
            "    def odbc_connection_string(self):",
            "        \"\"\"ODBC connection string.",
            "",
            "        We build connection string instead of using ``pyodbc.connect`` params",
            "        because, for example, there is no param representing",
            "        ``ApplicationIntent=ReadOnly``.  Any key-value pairs provided in",
            "        ``Connection.extra`` will be added to the connection string.",
            "        \"\"\"",
            "        if not self._conn_str:",
            "            conn_str = \"\"",
            "            if self.driver:",
            "                conn_str += f\"DRIVER={{{self.driver}}};\"",
            "            if self.dsn:",
            "                conn_str += f\"DSN={self.dsn};\"",
            "            if self.connection.host:",
            "                conn_str += f\"SERVER={self.connection.host};\"",
            "            database = self.database or self.connection.schema",
            "            if database:",
            "                conn_str += f\"DATABASE={database};\"",
            "            if self.connection.login:",
            "                conn_str += f\"UID={self.connection.login};\"",
            "            if self.connection.password:",
            "                conn_str += f\"PWD={self.connection.password};\"",
            "            if self.connection.port:",
            "                conn_str += f\"PORT={self.connection.port};\"",
            "",
            "            extra_exclude = {\"driver\", \"dsn\", \"connect_kwargs\", \"sqlalchemy_scheme\"}",
            "            extra_params = {",
            "                k: v for k, v in self.connection.extra_dejson.items() if k.lower() not in extra_exclude",
            "            }",
            "            for k, v in extra_params.items():",
            "                conn_str += f\"{k}={v};\"",
            "",
            "            self._conn_str = conn_str",
            "        return self._conn_str",
            "",
            "    @property",
            "    def connect_kwargs(self) -> dict:",
            "        \"\"\"Effective kwargs to be passed to ``pyodbc.connect``.",
            "",
            "        The kwargs are merged from connection extra, ``connect_kwargs``, and",
            "        the hook's init arguments. Values received to the hook precede those",
            "        from the connection.",
            "",
            "        If ``attrs_before`` is provided, keys and values are converted to int,",
            "        as required by pyodbc.",
            "        \"\"\"",
            "        conn_connect_kwargs = self.connection_extra_lower.get(\"connect_kwargs\", {})",
            "        hook_connect_kwargs = self._connect_kwargs or {}",
            "        merged_connect_kwargs = merge_dicts(conn_connect_kwargs, hook_connect_kwargs)",
            "",
            "        if \"attrs_before\" in merged_connect_kwargs:",
            "            merged_connect_kwargs[\"attrs_before\"] = {",
            "                int(k): int(v) for k, v in merged_connect_kwargs[\"attrs_before\"].items()",
            "            }",
            "",
            "        return merged_connect_kwargs",
            "",
            "    def get_conn(self) -> pyodbc.Connection:",
            "        \"\"\"Returns a pyodbc connection object.\"\"\"",
            "        conn = pyodbc.connect(self.odbc_connection_string, **self.connect_kwargs)",
            "        return conn",
            "",
            "    def get_uri(self) -> str:",
            "        \"\"\"URI invoked in :meth:`~airflow.providers.common.sql.hooks.sql.DbApiHook.get_sqlalchemy_engine`.\"\"\"",
            "        quoted_conn_str = quote_plus(self.odbc_connection_string)",
            "        uri = f\"{self.sqlalchemy_scheme}:///?odbc_connect={quoted_conn_str}\"",
            "        return uri",
            "",
            "    def get_sqlalchemy_connection(",
            "        self, connect_kwargs: dict | None = None, engine_kwargs: dict | None = None",
            "    ) -> Any:",
            "        \"\"\"SQLAlchemy connection object.\"\"\"",
            "        engine = self.get_sqlalchemy_engine(engine_kwargs=engine_kwargs)",
            "        cnx = engine.connect(**(connect_kwargs or {}))",
            "        return cnx"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "37": [
                "OdbcHook"
            ],
            "105": [
                "OdbcHook",
                "driver"
            ],
            "106": [
                "OdbcHook",
                "driver"
            ],
            "107": [
                "OdbcHook",
                "driver"
            ],
            "108": [
                "OdbcHook",
                "driver"
            ]
        },
        "addLocation": []
    }
}