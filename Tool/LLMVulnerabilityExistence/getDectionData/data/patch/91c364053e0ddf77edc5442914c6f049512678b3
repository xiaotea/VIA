{
    "tortoise/backends/mysql/executor.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from tortoise import Model"
            },
            "2": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from tortoise.backends.base.executor import BaseExecutor"
            },
            "3": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from tortoise.fields import BigIntField, Field, IntField, SmallIntField"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+from tortoise.fields import BigIntField, IntField, SmallIntField"
            },
            "5": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from tortoise.filters import ("
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+    Like,"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+    Term,"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+    ValueWrapper,"
            },
            "9": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 12,
                "PatchRowcode": "     contains,"
            },
            "10": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 13,
                "PatchRowcode": "     ends_with,"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+    format_quotes,"
            },
            "12": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "     insensitive_contains,"
            },
            "13": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 16,
                "PatchRowcode": "     insensitive_ends_with,"
            },
            "14": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 17,
                "PatchRowcode": "     insensitive_exact,"
            },
            "15": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " )"
            },
            "16": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "18": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def mysql_contains(field: Field, value: str) -> Criterion:"
            },
            "19": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return functions.Cast(field, SqlTypes.CHAR).like(f\"%{value}%\")"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+class StrWrapper(ValueWrapper):  # type: ignore"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+    \"\"\""
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+    Naive str wrapper that doesn't use the monkey-patched pypika ValueWraper for MySQL"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+    \"\"\""
            },
            "24": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+    def get_value_sql(self, **kwargs):"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+        quote_char = kwargs.get(\"secondary_quote_char\") or \"\""
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+        value = self.value.replace(quote_char, quote_char * 2)"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+        return format_quotes(value, quote_char)"
            },
            "29": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def mysql_starts_with(field: Field, value: str) -> Criterion:"
            },
            "31": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return functions.Cast(field, SqlTypes.CHAR).like(f\"{value}%\")"
            },
            "32": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 33,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+def escape_like(val: str) -> str:"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+    return val.replace(\"\\\\\", \"\\\\\\\\\\\\\\\\\").replace(\"%\", \"\\\\%\").replace(\"_\", \"\\\\_\")"
            },
            "35": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 36,
                "PatchRowcode": " "
            },
            "36": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def mysql_ends_with(field: Field, value: str) -> Criterion:"
            },
            "37": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return functions.Cast(field, SqlTypes.CHAR).like(f\"%{value}\")"
            },
            "38": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " "
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+def mysql_contains(field: Term, value: str) -> Criterion:"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+    return Like("
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+        functions.Cast(field, SqlTypes.CHAR), StrWrapper(f\"%{escape_like(value)}%\"), escape=\"\""
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+    )"
            },
            "43": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def mysql_insensitive_exact(field: Field, value: str) -> Criterion:"
            },
            "45": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return functions.Upper(functions.Cast(field, SqlTypes.CHAR)).eq(functions.Upper(f\"{value}\"))"
            },
            "46": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " "
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+def mysql_starts_with(field: Term, value: str) -> Criterion:"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+    return Like("
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+        functions.Cast(field, SqlTypes.CHAR), StrWrapper(f\"{escape_like(value)}%\"), escape=\"\""
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+    )"
            },
            "51": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 48,
                "PatchRowcode": " "
            },
            "52": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def mysql_insensitive_contains(field: Field, value: str) -> Criterion:"
            },
            "53": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return functions.Upper(functions.Cast(field, SqlTypes.CHAR)).like(functions.Upper(f\"%{value}%\"))"
            },
            "54": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 49,
                "PatchRowcode": " "
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+def mysql_ends_with(field: Term, value: str) -> Criterion:"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+    return Like("
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        functions.Cast(field, SqlTypes.CHAR), StrWrapper(f\"%{escape_like(value)}\"), escape=\"\""
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+    )"
            },
            "59": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " "
            },
            "60": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def mysql_insensitive_starts_with(field: Field, value: str) -> Criterion:"
            },
            "61": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return functions.Upper(functions.Cast(field, SqlTypes.CHAR)).like(functions.Upper(f\"{value}%\"))"
            },
            "62": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " "
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+def mysql_insensitive_exact(field: Term, value: str) -> Criterion:"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+    return functions.Upper(functions.Cast(field, SqlTypes.CHAR)).eq(functions.Upper(str(value)))"
            },
            "65": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 58,
                "PatchRowcode": " "
            },
            "66": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def mysql_insensitive_ends_with(field: Field, value: str) -> Criterion:"
            },
            "67": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return functions.Upper(functions.Cast(field, SqlTypes.CHAR)).like(functions.Upper(f\"%{value}\"))"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+def mysql_insensitive_contains(field: Term, value: str) -> Criterion:"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+    return Like("
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+        functions.Upper(functions.Cast(field, SqlTypes.CHAR)),"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        functions.Upper(StrWrapper(f\"%{escape_like(value)}%\")),"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+        escape=\"\","
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+    )"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+def mysql_insensitive_starts_with(field: Term, value: str) -> Criterion:"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+    return Like("
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+        functions.Upper(functions.Cast(field, SqlTypes.CHAR)),"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+        functions.Upper(StrWrapper(f\"{escape_like(value)}%\")),"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+        escape=\"\","
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+    )"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+def mysql_insensitive_ends_with(field: Term, value: str) -> Criterion:"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+    return Like("
            },
            "87": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+        functions.Upper(functions.Cast(field, SqlTypes.CHAR)),"
            },
            "88": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+        functions.Upper(StrWrapper(f\"%{escape_like(value)}\")),"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+        escape=\"\","
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+    )"
            },
            "91": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 82,
                "PatchRowcode": " "
            },
            "92": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 83,
                "PatchRowcode": " "
            },
            "93": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 84,
                "PatchRowcode": " class MySQLExecutor(BaseExecutor):"
            }
        },
        "frontPatchFile": [
            "from pypika import Parameter, functions",
            "from pypika.enums import SqlTypes",
            "from pypika.terms import Criterion",
            "",
            "from tortoise import Model",
            "from tortoise.backends.base.executor import BaseExecutor",
            "from tortoise.fields import BigIntField, Field, IntField, SmallIntField",
            "from tortoise.filters import (",
            "    contains,",
            "    ends_with,",
            "    insensitive_contains,",
            "    insensitive_ends_with,",
            "    insensitive_exact,",
            "    insensitive_starts_with,",
            "    starts_with,",
            ")",
            "",
            "",
            "def mysql_contains(field: Field, value: str) -> Criterion:",
            "    return functions.Cast(field, SqlTypes.CHAR).like(f\"%{value}%\")",
            "",
            "",
            "def mysql_starts_with(field: Field, value: str) -> Criterion:",
            "    return functions.Cast(field, SqlTypes.CHAR).like(f\"{value}%\")",
            "",
            "",
            "def mysql_ends_with(field: Field, value: str) -> Criterion:",
            "    return functions.Cast(field, SqlTypes.CHAR).like(f\"%{value}\")",
            "",
            "",
            "def mysql_insensitive_exact(field: Field, value: str) -> Criterion:",
            "    return functions.Upper(functions.Cast(field, SqlTypes.CHAR)).eq(functions.Upper(f\"{value}\"))",
            "",
            "",
            "def mysql_insensitive_contains(field: Field, value: str) -> Criterion:",
            "    return functions.Upper(functions.Cast(field, SqlTypes.CHAR)).like(functions.Upper(f\"%{value}%\"))",
            "",
            "",
            "def mysql_insensitive_starts_with(field: Field, value: str) -> Criterion:",
            "    return functions.Upper(functions.Cast(field, SqlTypes.CHAR)).like(functions.Upper(f\"{value}%\"))",
            "",
            "",
            "def mysql_insensitive_ends_with(field: Field, value: str) -> Criterion:",
            "    return functions.Upper(functions.Cast(field, SqlTypes.CHAR)).like(functions.Upper(f\"%{value}\"))",
            "",
            "",
            "class MySQLExecutor(BaseExecutor):",
            "    FILTER_FUNC_OVERRIDE = {",
            "        contains: mysql_contains,",
            "        starts_with: mysql_starts_with,",
            "        ends_with: mysql_ends_with,",
            "        insensitive_exact: mysql_insensitive_exact,",
            "        insensitive_contains: mysql_insensitive_contains,",
            "        insensitive_starts_with: mysql_insensitive_starts_with,",
            "        insensitive_ends_with: mysql_insensitive_ends_with,",
            "    }",
            "    EXPLAIN_PREFIX = \"EXPLAIN FORMAT=JSON\"",
            "",
            "    def parameter(self, pos: int) -> Parameter:",
            "        return Parameter(\"%s\")",
            "",
            "    async def _process_insert_result(self, instance: Model, results: int) -> None:",
            "        pk_field_object = self.model._meta.pk",
            "        if (",
            "            isinstance(pk_field_object, (SmallIntField, IntField, BigIntField))",
            "            and pk_field_object.generated",
            "        ):",
            "            instance.pk = results",
            "",
            "        # MySQL can only generate a single ROWID",
            "        #   so if any other primary key, it won't generate what we want."
        ],
        "afterPatchFile": [
            "from pypika import Parameter, functions",
            "from pypika.enums import SqlTypes",
            "from pypika.terms import Criterion",
            "",
            "from tortoise import Model",
            "from tortoise.backends.base.executor import BaseExecutor",
            "from tortoise.fields import BigIntField, IntField, SmallIntField",
            "from tortoise.filters import (",
            "    Like,",
            "    Term,",
            "    ValueWrapper,",
            "    contains,",
            "    ends_with,",
            "    format_quotes,",
            "    insensitive_contains,",
            "    insensitive_ends_with,",
            "    insensitive_exact,",
            "    insensitive_starts_with,",
            "    starts_with,",
            ")",
            "",
            "",
            "class StrWrapper(ValueWrapper):  # type: ignore",
            "    \"\"\"",
            "    Naive str wrapper that doesn't use the monkey-patched pypika ValueWraper for MySQL",
            "    \"\"\"",
            "",
            "    def get_value_sql(self, **kwargs):",
            "        quote_char = kwargs.get(\"secondary_quote_char\") or \"\"",
            "        value = self.value.replace(quote_char, quote_char * 2)",
            "        return format_quotes(value, quote_char)",
            "",
            "",
            "def escape_like(val: str) -> str:",
            "    return val.replace(\"\\\\\", \"\\\\\\\\\\\\\\\\\").replace(\"%\", \"\\\\%\").replace(\"_\", \"\\\\_\")",
            "",
            "",
            "def mysql_contains(field: Term, value: str) -> Criterion:",
            "    return Like(",
            "        functions.Cast(field, SqlTypes.CHAR), StrWrapper(f\"%{escape_like(value)}%\"), escape=\"\"",
            "    )",
            "",
            "",
            "def mysql_starts_with(field: Term, value: str) -> Criterion:",
            "    return Like(",
            "        functions.Cast(field, SqlTypes.CHAR), StrWrapper(f\"{escape_like(value)}%\"), escape=\"\"",
            "    )",
            "",
            "",
            "def mysql_ends_with(field: Term, value: str) -> Criterion:",
            "    return Like(",
            "        functions.Cast(field, SqlTypes.CHAR), StrWrapper(f\"%{escape_like(value)}\"), escape=\"\"",
            "    )",
            "",
            "",
            "def mysql_insensitive_exact(field: Term, value: str) -> Criterion:",
            "    return functions.Upper(functions.Cast(field, SqlTypes.CHAR)).eq(functions.Upper(str(value)))",
            "",
            "",
            "def mysql_insensitive_contains(field: Term, value: str) -> Criterion:",
            "    return Like(",
            "        functions.Upper(functions.Cast(field, SqlTypes.CHAR)),",
            "        functions.Upper(StrWrapper(f\"%{escape_like(value)}%\")),",
            "        escape=\"\",",
            "    )",
            "",
            "",
            "def mysql_insensitive_starts_with(field: Term, value: str) -> Criterion:",
            "    return Like(",
            "        functions.Upper(functions.Cast(field, SqlTypes.CHAR)),",
            "        functions.Upper(StrWrapper(f\"{escape_like(value)}%\")),",
            "        escape=\"\",",
            "    )",
            "",
            "",
            "def mysql_insensitive_ends_with(field: Term, value: str) -> Criterion:",
            "    return Like(",
            "        functions.Upper(functions.Cast(field, SqlTypes.CHAR)),",
            "        functions.Upper(StrWrapper(f\"%{escape_like(value)}\")),",
            "        escape=\"\",",
            "    )",
            "",
            "",
            "class MySQLExecutor(BaseExecutor):",
            "    FILTER_FUNC_OVERRIDE = {",
            "        contains: mysql_contains,",
            "        starts_with: mysql_starts_with,",
            "        ends_with: mysql_ends_with,",
            "        insensitive_exact: mysql_insensitive_exact,",
            "        insensitive_contains: mysql_insensitive_contains,",
            "        insensitive_starts_with: mysql_insensitive_starts_with,",
            "        insensitive_ends_with: mysql_insensitive_ends_with,",
            "    }",
            "    EXPLAIN_PREFIX = \"EXPLAIN FORMAT=JSON\"",
            "",
            "    def parameter(self, pos: int) -> Parameter:",
            "        return Parameter(\"%s\")",
            "",
            "    async def _process_insert_result(self, instance: Model, results: int) -> None:",
            "        pk_field_object = self.model._meta.pk",
            "        if (",
            "            isinstance(pk_field_object, (SmallIntField, IntField, BigIntField))",
            "            and pk_field_object.generated",
            "        ):",
            "            instance.pk = results",
            "",
            "        # MySQL can only generate a single ROWID",
            "        #   so if any other primary key, it won't generate what we want."
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "7": [],
            "19": [
                "mysql_contains"
            ],
            "20": [
                "mysql_contains"
            ],
            "23": [
                "mysql_starts_with"
            ],
            "24": [
                "mysql_starts_with"
            ],
            "27": [
                "mysql_ends_with"
            ],
            "28": [
                "mysql_ends_with"
            ],
            "31": [
                "mysql_insensitive_exact"
            ],
            "32": [
                "mysql_insensitive_exact"
            ],
            "35": [
                "mysql_insensitive_contains"
            ],
            "36": [
                "mysql_insensitive_contains"
            ],
            "39": [
                "mysql_insensitive_starts_with"
            ],
            "40": [
                "mysql_insensitive_starts_with"
            ],
            "43": [
                "mysql_insensitive_ends_with"
            ],
            "44": [
                "mysql_insensitive_ends_with"
            ]
        },
        "addLocation": []
    },
    "tortoise/filters.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " from pypika import Table"
            },
            "2": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from pypika.functions import Upper"
            },
            "3": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from pypika.terms import BasicCriterion, Criterion, Equality, Term, ValueWrapper"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+from pypika.terms import ("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+    BasicCriterion,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+    Criterion,"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+    Enum,"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+    Equality,"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+    Term,"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+    ValueWrapper,"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+    basestring,"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+    date,"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+    format_quotes,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+)"
            },
            "15": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from tortoise.fields import Field"
            },
            "17": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from tortoise.fields.relational import BackwardFKRelation, ManyToManyFieldInstance"
            },
            "18": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " if TYPE_CHECKING:  # pragma: nocoverage"
            },
            "20": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "     from tortoise.models import Model"
            },
            "21": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+##############################################################################"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+# Here we monkey-patch PyPika Valuewrapper to behave differently for MySQL"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+##############################################################################"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+def get_value_sql(self, **kwargs):  # pragma: nocoverage"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+    quote_char = kwargs.get(\"secondary_quote_char\") or \"\""
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+    dialect = kwargs.get(\"dialect\")"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+    if dialect:"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+        dialect = dialect.value"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+    if isinstance(self.value, Term):"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+        return self.value.get_sql(**kwargs)"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+    if isinstance(self.value, Enum):"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+        return self.value.value"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+    if isinstance(self.value, date):"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+        value = self.value.isoformat()"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+        return format_quotes(value, quote_char)"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+    if isinstance(self.value, basestring):"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        value = self.value.replace(quote_char, quote_char * 2)"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+        if dialect == \"mysql\":"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+            value = value.replace(\"\\\\\", \"\\\\\\\\\")"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+        return format_quotes(value, quote_char)"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+    if isinstance(self.value, bool):"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+        return str.lower(str(self.value))"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+    if self.value is None:"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+        return \"null\""
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+    return str(self.value)"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+ValueWrapper.get_value_sql = get_value_sql"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+##############################################################################"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+class Like(BasicCriterion):  # type: ignore"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+    def __init__(self, left, right, alias=None, escape=\" ESCAPE '\\\\'\") -> None:"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+        \"\"\""
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+        A Like that supports an ESCAPE clause"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        \"\"\""
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+        super().__init__(\" LIKE \", left, right, alias=alias)"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+        self.escape = escape"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+    def get_sql(self, quote_char='\"', with_alias=False, **kwargs):"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+        sql = \"{left}{comparator}{right}{escape}\".format("
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+            comparator=self.comparator,"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+            left=self.left.get_sql(quote_char=quote_char, **kwargs),"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+            right=self.right.get_sql(quote_char=quote_char, **kwargs),"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+            escape=self.escape,"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+        )"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+        if with_alias and self.alias:  # pragma: nocoverage"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+            return '{sql} \"{alias}\"'.format(sql=sql, alias=self.alias)"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+        return sql"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+"
            },
            "76": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+def escape_val(val: Any) -> Any:"
            },
            "77": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+    if isinstance(val, str):"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+        print(val)"
            },
            "79": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+        return val.replace(\"\\\\\", \"\\\\\\\\\")"
            },
            "80": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+    return val"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+"
            },
            "82": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+"
            },
            "83": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+def escape_like(val: str) -> str:"
            },
            "84": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+    return val.replace(\"\\\\\", \"\\\\\\\\\").replace(\"%\", \"\\\\%\").replace(\"_\", \"\\\\_\")"
            },
            "85": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+"
            },
            "87": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 90,
                "PatchRowcode": " ##############################################################################"
            },
            "88": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 91,
                "PatchRowcode": " # Encoders"
            },
            "89": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 92,
                "PatchRowcode": " # Should be type: (Any, instance: \"Model\", field: Field) -> type:"
            },
            "90": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 154,
                "PatchRowcode": " "
            },
            "91": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 155,
                "PatchRowcode": " "
            },
            "92": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 156,
                "PatchRowcode": " def contains(field: Term, value: str) -> Criterion:"
            },
            "93": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return field.like(f\"%{value}%\")"
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+    return Like(field, field.wrap_constant(f\"%{escape_like(value)}%\"))"
            },
            "95": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 158,
                "PatchRowcode": " "
            },
            "96": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 159,
                "PatchRowcode": " "
            },
            "97": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 160,
                "PatchRowcode": " def starts_with(field: Term, value: str) -> Criterion:"
            },
            "98": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return field.like(f\"{value}%\")"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+    return Like(field, field.wrap_constant(f\"{escape_like(value)}%\"))"
            },
            "100": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 162,
                "PatchRowcode": " "
            },
            "101": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 163,
                "PatchRowcode": " "
            },
            "102": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 164,
                "PatchRowcode": " def ends_with(field: Term, value: str) -> Criterion:"
            },
            "103": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return field.like(f\"%{value}\")"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+    return Like(field, field.wrap_constant(f\"%{escape_like(value)}\"))"
            },
            "105": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 166,
                "PatchRowcode": " "
            },
            "106": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 167,
                "PatchRowcode": " "
            },
            "107": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 168,
                "PatchRowcode": " def insensitive_exact(field: Term, value: str) -> Criterion:"
            },
            "108": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return Upper(field).eq(Upper(f\"{value}\"))"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+    return Upper(field).eq(Upper(str(value)))"
            },
            "110": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": 170,
                "PatchRowcode": " "
            },
            "111": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 171,
                "PatchRowcode": " "
            },
            "112": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 172,
                "PatchRowcode": " def insensitive_contains(field: Term, value: str) -> Criterion:"
            },
            "113": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return Upper(field).like(Upper(f\"%{value}%\"))"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+    return Like(Upper(field), field.wrap_constant(Upper(f\"%{escape_like(value)}%\")))"
            },
            "115": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 174,
                "PatchRowcode": " "
            },
            "116": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 175,
                "PatchRowcode": " "
            },
            "117": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 176,
                "PatchRowcode": " def insensitive_starts_with(field: Term, value: str) -> Criterion:"
            },
            "118": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return Upper(field).like(Upper(f\"{value}%\"))"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+    return Like(Upper(field), field.wrap_constant(Upper(f\"{escape_like(value)}%\")))"
            },
            "120": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 178,
                "PatchRowcode": " "
            },
            "121": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 179,
                "PatchRowcode": " "
            },
            "122": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 180,
                "PatchRowcode": " def insensitive_ends_with(field: Term, value: str) -> Criterion:"
            },
            "123": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return Upper(field).like(Upper(f\"%{value}\"))"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+    return Like(Upper(field), field.wrap_constant(Upper(f\"%{escape_like(value)}\")))"
            },
            "125": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 182,
                "PatchRowcode": " "
            },
            "126": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 183,
                "PatchRowcode": " "
            },
            "127": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 184,
                "PatchRowcode": " ##############################################################################"
            }
        },
        "frontPatchFile": [
            "import operator",
            "from functools import partial",
            "from typing import TYPE_CHECKING, Any, Dict, Iterable, Optional, Tuple",
            "",
            "from pypika import Table",
            "from pypika.functions import Upper",
            "from pypika.terms import BasicCriterion, Criterion, Equality, Term, ValueWrapper",
            "",
            "from tortoise.fields import Field",
            "from tortoise.fields.relational import BackwardFKRelation, ManyToManyFieldInstance",
            "",
            "if TYPE_CHECKING:  # pragma: nocoverage",
            "    from tortoise.models import Model",
            "",
            "##############################################################################",
            "# Encoders",
            "# Should be type: (Any, instance: \"Model\", field: Field) -> type:",
            "##############################################################################",
            "",
            "",
            "def list_encoder(values: Iterable[Any], instance: \"Model\", field: Field) -> list:",
            "    \"\"\"Encodes an iterable of a given field into a database-compatible format.\"\"\"",
            "    return [field.to_db_value(element, instance) for element in values]",
            "",
            "",
            "def related_list_encoder(values: Iterable[Any], instance: \"Model\", field: Field) -> list:",
            "    return [",
            "        field.to_db_value(element.pk if hasattr(element, \"pk\") else element, instance)",
            "        for element in values",
            "    ]",
            "",
            "",
            "def bool_encoder(value: Any, instance: \"Model\", field: Field) -> bool:",
            "    return bool(value)",
            "",
            "",
            "def string_encoder(value: Any, instance: \"Model\", field: Field) -> str:",
            "    return str(value)",
            "",
            "",
            "##############################################################################",
            "# Operators",
            "# Should be type: (field: Term, value: Any) -> Criterion:",
            "##############################################################################",
            "",
            "",
            "def is_in(field: Term, value: Any) -> Criterion:",
            "    if value:",
            "        return field.isin(value)",
            "    # SQL has no False, so we return 1=0",
            "    return BasicCriterion(Equality.eq, ValueWrapper(1), ValueWrapper(0))",
            "",
            "",
            "def not_in(field: Term, value: Any) -> Criterion:",
            "    if value:",
            "        return field.notin(value) | field.isnull()",
            "    # SQL has no True, so we return 1=1",
            "    return BasicCriterion(Equality.eq, ValueWrapper(1), ValueWrapper(1))",
            "",
            "",
            "def between_and(field: Term, value: Tuple[Any, Any]) -> Criterion:",
            "    return field.between(value[0], value[1])",
            "",
            "",
            "def not_equal(field: Term, value: Any) -> Criterion:",
            "    return field.ne(value) | field.isnull()",
            "",
            "",
            "def is_null(field: Term, value: Any) -> Criterion:",
            "    if value:",
            "        return field.isnull()",
            "    return field.notnull()",
            "",
            "",
            "def not_null(field: Term, value: Any) -> Criterion:",
            "    if value:",
            "        return field.notnull()",
            "    return field.isnull()",
            "",
            "",
            "def contains(field: Term, value: str) -> Criterion:",
            "    return field.like(f\"%{value}%\")",
            "",
            "",
            "def starts_with(field: Term, value: str) -> Criterion:",
            "    return field.like(f\"{value}%\")",
            "",
            "",
            "def ends_with(field: Term, value: str) -> Criterion:",
            "    return field.like(f\"%{value}\")",
            "",
            "",
            "def insensitive_exact(field: Term, value: str) -> Criterion:",
            "    return Upper(field).eq(Upper(f\"{value}\"))",
            "",
            "",
            "def insensitive_contains(field: Term, value: str) -> Criterion:",
            "    return Upper(field).like(Upper(f\"%{value}%\"))",
            "",
            "",
            "def insensitive_starts_with(field: Term, value: str) -> Criterion:",
            "    return Upper(field).like(Upper(f\"{value}%\"))",
            "",
            "",
            "def insensitive_ends_with(field: Term, value: str) -> Criterion:",
            "    return Upper(field).like(Upper(f\"%{value}\"))",
            "",
            "",
            "##############################################################################",
            "# Filter resolvers",
            "##############################################################################",
            "",
            "",
            "def get_m2m_filters(field_name: str, field: ManyToManyFieldInstance) -> Dict[str, dict]:",
            "    target_table_pk = field.related_model._meta.pk",
            "    return {",
            "        field_name: {",
            "            \"field\": field.forward_key,",
            "            \"backward_key\": field.backward_key,",
            "            \"operator\": operator.eq,",
            "            \"table\": Table(field.through),",
            "            \"value_encoder\": target_table_pk.to_db_value,",
            "        },",
            "        f\"{field_name}__not\": {",
            "            \"field\": field.forward_key,",
            "            \"backward_key\": field.backward_key,",
            "            \"operator\": not_equal,",
            "            \"table\": Table(field.through),",
            "            \"value_encoder\": target_table_pk.to_db_value,",
            "        },",
            "        f\"{field_name}__in\": {",
            "            \"field\": field.forward_key,",
            "            \"backward_key\": field.backward_key,",
            "            \"operator\": is_in,",
            "            \"table\": Table(field.through),",
            "            \"value_encoder\": partial(related_list_encoder, field=target_table_pk),",
            "        },",
            "        f\"{field_name}__not_in\": {",
            "            \"field\": field.forward_key,",
            "            \"backward_key\": field.backward_key,",
            "            \"operator\": not_in,",
            "            \"table\": Table(field.through),",
            "            \"value_encoder\": partial(related_list_encoder, field=target_table_pk),",
            "        },",
            "    }",
            "",
            "",
            "def get_backward_fk_filters(field_name: str, field: BackwardFKRelation) -> Dict[str, dict]:",
            "    target_table_pk = field.related_model._meta.pk",
            "    return {",
            "        field_name: {",
            "            \"field\": field.related_model._meta.pk_attr,",
            "            \"backward_key\": field.relation_field,",
            "            \"operator\": operator.eq,",
            "            \"table\": Table(field.related_model._meta.db_table),",
            "            \"value_encoder\": target_table_pk.to_db_value,",
            "        },",
            "        f\"{field_name}__not\": {",
            "            \"field\": field.related_model._meta.pk_attr,",
            "            \"backward_key\": field.relation_field,",
            "            \"operator\": not_equal,",
            "            \"table\": Table(field.related_model._meta.db_table),",
            "            \"value_encoder\": target_table_pk.to_db_value,",
            "        },",
            "        f\"{field_name}__in\": {",
            "            \"field\": field.related_model._meta.pk_attr,",
            "            \"backward_key\": field.relation_field,",
            "            \"operator\": is_in,",
            "            \"table\": Table(field.related_model._meta.db_table),",
            "            \"value_encoder\": partial(related_list_encoder, field=target_table_pk),",
            "        },",
            "        f\"{field_name}__not_in\": {",
            "            \"field\": field.related_model._meta.pk_attr,",
            "            \"backward_key\": field.relation_field,",
            "            \"operator\": not_in,",
            "            \"table\": Table(field.related_model._meta.db_table),",
            "            \"value_encoder\": partial(related_list_encoder, field=target_table_pk),",
            "        },",
            "    }",
            "",
            "",
            "def get_filters_for_field(",
            "    field_name: str, field: Optional[Field], source_field: str",
            ") -> Dict[str, dict]:",
            "    if isinstance(field, ManyToManyFieldInstance):",
            "        return get_m2m_filters(field_name, field)",
            "    if isinstance(field, BackwardFKRelation):",
            "        return get_backward_fk_filters(field_name, field)",
            "    actual_field_name = field_name",
            "    if field_name == \"pk\" and field:",
            "        actual_field_name = field.model_field_name",
            "    return {",
            "        field_name: {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": operator.eq,",
            "        },",
            "        f\"{field_name}__not\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": not_equal,",
            "        },",
            "        f\"{field_name}__in\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": is_in,",
            "            \"value_encoder\": list_encoder,",
            "        },",
            "        f\"{field_name}__not_in\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": not_in,",
            "            \"value_encoder\": list_encoder,",
            "        },",
            "        f\"{field_name}__isnull\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": is_null,",
            "            \"value_encoder\": bool_encoder,",
            "        },",
            "        f\"{field_name}__not_isnull\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": not_null,",
            "            \"value_encoder\": bool_encoder,",
            "        },",
            "        f\"{field_name}__gte\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": operator.ge,",
            "        },",
            "        f\"{field_name}__lte\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": operator.le,",
            "        },",
            "        f\"{field_name}__gt\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": operator.gt,",
            "        },",
            "        f\"{field_name}__lt\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": operator.lt,",
            "        },",
            "        f\"{field_name}__range\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": between_and,",
            "            \"value_encoder\": list_encoder,",
            "        },",
            "        f\"{field_name}__contains\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": contains,",
            "            \"value_encoder\": string_encoder,",
            "        },",
            "        f\"{field_name}__startswith\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": starts_with,",
            "            \"value_encoder\": string_encoder,",
            "        },",
            "        f\"{field_name}__endswith\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": ends_with,",
            "            \"value_encoder\": string_encoder,",
            "        },",
            "        f\"{field_name}__iexact\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": insensitive_exact,",
            "            \"value_encoder\": string_encoder,",
            "        },",
            "        f\"{field_name}__icontains\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": insensitive_contains,",
            "            \"value_encoder\": string_encoder,",
            "        },",
            "        f\"{field_name}__istartswith\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": insensitive_starts_with,",
            "            \"value_encoder\": string_encoder,",
            "        },",
            "        f\"{field_name}__iendswith\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": insensitive_ends_with,",
            "            \"value_encoder\": string_encoder,",
            "        },",
            "    }"
        ],
        "afterPatchFile": [
            "import operator",
            "from functools import partial",
            "from typing import TYPE_CHECKING, Any, Dict, Iterable, Optional, Tuple",
            "",
            "from pypika import Table",
            "from pypika.functions import Upper",
            "from pypika.terms import (",
            "    BasicCriterion,",
            "    Criterion,",
            "    Enum,",
            "    Equality,",
            "    Term,",
            "    ValueWrapper,",
            "    basestring,",
            "    date,",
            "    format_quotes,",
            ")",
            "",
            "from tortoise.fields import Field",
            "from tortoise.fields.relational import BackwardFKRelation, ManyToManyFieldInstance",
            "",
            "if TYPE_CHECKING:  # pragma: nocoverage",
            "    from tortoise.models import Model",
            "",
            "##############################################################################",
            "# Here we monkey-patch PyPika Valuewrapper to behave differently for MySQL",
            "##############################################################################",
            "",
            "",
            "def get_value_sql(self, **kwargs):  # pragma: nocoverage",
            "    quote_char = kwargs.get(\"secondary_quote_char\") or \"\"",
            "    dialect = kwargs.get(\"dialect\")",
            "    if dialect:",
            "        dialect = dialect.value",
            "",
            "    if isinstance(self.value, Term):",
            "        return self.value.get_sql(**kwargs)",
            "    if isinstance(self.value, Enum):",
            "        return self.value.value",
            "    if isinstance(self.value, date):",
            "        value = self.value.isoformat()",
            "        return format_quotes(value, quote_char)",
            "    if isinstance(self.value, basestring):",
            "        value = self.value.replace(quote_char, quote_char * 2)",
            "        if dialect == \"mysql\":",
            "            value = value.replace(\"\\\\\", \"\\\\\\\\\")",
            "        return format_quotes(value, quote_char)",
            "    if isinstance(self.value, bool):",
            "        return str.lower(str(self.value))",
            "    if self.value is None:",
            "        return \"null\"",
            "    return str(self.value)",
            "",
            "",
            "ValueWrapper.get_value_sql = get_value_sql",
            "##############################################################################",
            "",
            "",
            "class Like(BasicCriterion):  # type: ignore",
            "    def __init__(self, left, right, alias=None, escape=\" ESCAPE '\\\\'\") -> None:",
            "        \"\"\"",
            "        A Like that supports an ESCAPE clause",
            "        \"\"\"",
            "        super().__init__(\" LIKE \", left, right, alias=alias)",
            "        self.escape = escape",
            "",
            "    def get_sql(self, quote_char='\"', with_alias=False, **kwargs):",
            "        sql = \"{left}{comparator}{right}{escape}\".format(",
            "            comparator=self.comparator,",
            "            left=self.left.get_sql(quote_char=quote_char, **kwargs),",
            "            right=self.right.get_sql(quote_char=quote_char, **kwargs),",
            "            escape=self.escape,",
            "        )",
            "        if with_alias and self.alias:  # pragma: nocoverage",
            "            return '{sql} \"{alias}\"'.format(sql=sql, alias=self.alias)",
            "        return sql",
            "",
            "",
            "def escape_val(val: Any) -> Any:",
            "    if isinstance(val, str):",
            "        print(val)",
            "        return val.replace(\"\\\\\", \"\\\\\\\\\")",
            "    return val",
            "",
            "",
            "def escape_like(val: str) -> str:",
            "    return val.replace(\"\\\\\", \"\\\\\\\\\").replace(\"%\", \"\\\\%\").replace(\"_\", \"\\\\_\")",
            "",
            "",
            "##############################################################################",
            "# Encoders",
            "# Should be type: (Any, instance: \"Model\", field: Field) -> type:",
            "##############################################################################",
            "",
            "",
            "def list_encoder(values: Iterable[Any], instance: \"Model\", field: Field) -> list:",
            "    \"\"\"Encodes an iterable of a given field into a database-compatible format.\"\"\"",
            "    return [field.to_db_value(element, instance) for element in values]",
            "",
            "",
            "def related_list_encoder(values: Iterable[Any], instance: \"Model\", field: Field) -> list:",
            "    return [",
            "        field.to_db_value(element.pk if hasattr(element, \"pk\") else element, instance)",
            "        for element in values",
            "    ]",
            "",
            "",
            "def bool_encoder(value: Any, instance: \"Model\", field: Field) -> bool:",
            "    return bool(value)",
            "",
            "",
            "def string_encoder(value: Any, instance: \"Model\", field: Field) -> str:",
            "    return str(value)",
            "",
            "",
            "##############################################################################",
            "# Operators",
            "# Should be type: (field: Term, value: Any) -> Criterion:",
            "##############################################################################",
            "",
            "",
            "def is_in(field: Term, value: Any) -> Criterion:",
            "    if value:",
            "        return field.isin(value)",
            "    # SQL has no False, so we return 1=0",
            "    return BasicCriterion(Equality.eq, ValueWrapper(1), ValueWrapper(0))",
            "",
            "",
            "def not_in(field: Term, value: Any) -> Criterion:",
            "    if value:",
            "        return field.notin(value) | field.isnull()",
            "    # SQL has no True, so we return 1=1",
            "    return BasicCriterion(Equality.eq, ValueWrapper(1), ValueWrapper(1))",
            "",
            "",
            "def between_and(field: Term, value: Tuple[Any, Any]) -> Criterion:",
            "    return field.between(value[0], value[1])",
            "",
            "",
            "def not_equal(field: Term, value: Any) -> Criterion:",
            "    return field.ne(value) | field.isnull()",
            "",
            "",
            "def is_null(field: Term, value: Any) -> Criterion:",
            "    if value:",
            "        return field.isnull()",
            "    return field.notnull()",
            "",
            "",
            "def not_null(field: Term, value: Any) -> Criterion:",
            "    if value:",
            "        return field.notnull()",
            "    return field.isnull()",
            "",
            "",
            "def contains(field: Term, value: str) -> Criterion:",
            "    return Like(field, field.wrap_constant(f\"%{escape_like(value)}%\"))",
            "",
            "",
            "def starts_with(field: Term, value: str) -> Criterion:",
            "    return Like(field, field.wrap_constant(f\"{escape_like(value)}%\"))",
            "",
            "",
            "def ends_with(field: Term, value: str) -> Criterion:",
            "    return Like(field, field.wrap_constant(f\"%{escape_like(value)}\"))",
            "",
            "",
            "def insensitive_exact(field: Term, value: str) -> Criterion:",
            "    return Upper(field).eq(Upper(str(value)))",
            "",
            "",
            "def insensitive_contains(field: Term, value: str) -> Criterion:",
            "    return Like(Upper(field), field.wrap_constant(Upper(f\"%{escape_like(value)}%\")))",
            "",
            "",
            "def insensitive_starts_with(field: Term, value: str) -> Criterion:",
            "    return Like(Upper(field), field.wrap_constant(Upper(f\"{escape_like(value)}%\")))",
            "",
            "",
            "def insensitive_ends_with(field: Term, value: str) -> Criterion:",
            "    return Like(Upper(field), field.wrap_constant(Upper(f\"%{escape_like(value)}\")))",
            "",
            "",
            "##############################################################################",
            "# Filter resolvers",
            "##############################################################################",
            "",
            "",
            "def get_m2m_filters(field_name: str, field: ManyToManyFieldInstance) -> Dict[str, dict]:",
            "    target_table_pk = field.related_model._meta.pk",
            "    return {",
            "        field_name: {",
            "            \"field\": field.forward_key,",
            "            \"backward_key\": field.backward_key,",
            "            \"operator\": operator.eq,",
            "            \"table\": Table(field.through),",
            "            \"value_encoder\": target_table_pk.to_db_value,",
            "        },",
            "        f\"{field_name}__not\": {",
            "            \"field\": field.forward_key,",
            "            \"backward_key\": field.backward_key,",
            "            \"operator\": not_equal,",
            "            \"table\": Table(field.through),",
            "            \"value_encoder\": target_table_pk.to_db_value,",
            "        },",
            "        f\"{field_name}__in\": {",
            "            \"field\": field.forward_key,",
            "            \"backward_key\": field.backward_key,",
            "            \"operator\": is_in,",
            "            \"table\": Table(field.through),",
            "            \"value_encoder\": partial(related_list_encoder, field=target_table_pk),",
            "        },",
            "        f\"{field_name}__not_in\": {",
            "            \"field\": field.forward_key,",
            "            \"backward_key\": field.backward_key,",
            "            \"operator\": not_in,",
            "            \"table\": Table(field.through),",
            "            \"value_encoder\": partial(related_list_encoder, field=target_table_pk),",
            "        },",
            "    }",
            "",
            "",
            "def get_backward_fk_filters(field_name: str, field: BackwardFKRelation) -> Dict[str, dict]:",
            "    target_table_pk = field.related_model._meta.pk",
            "    return {",
            "        field_name: {",
            "            \"field\": field.related_model._meta.pk_attr,",
            "            \"backward_key\": field.relation_field,",
            "            \"operator\": operator.eq,",
            "            \"table\": Table(field.related_model._meta.db_table),",
            "            \"value_encoder\": target_table_pk.to_db_value,",
            "        },",
            "        f\"{field_name}__not\": {",
            "            \"field\": field.related_model._meta.pk_attr,",
            "            \"backward_key\": field.relation_field,",
            "            \"operator\": not_equal,",
            "            \"table\": Table(field.related_model._meta.db_table),",
            "            \"value_encoder\": target_table_pk.to_db_value,",
            "        },",
            "        f\"{field_name}__in\": {",
            "            \"field\": field.related_model._meta.pk_attr,",
            "            \"backward_key\": field.relation_field,",
            "            \"operator\": is_in,",
            "            \"table\": Table(field.related_model._meta.db_table),",
            "            \"value_encoder\": partial(related_list_encoder, field=target_table_pk),",
            "        },",
            "        f\"{field_name}__not_in\": {",
            "            \"field\": field.related_model._meta.pk_attr,",
            "            \"backward_key\": field.relation_field,",
            "            \"operator\": not_in,",
            "            \"table\": Table(field.related_model._meta.db_table),",
            "            \"value_encoder\": partial(related_list_encoder, field=target_table_pk),",
            "        },",
            "    }",
            "",
            "",
            "def get_filters_for_field(",
            "    field_name: str, field: Optional[Field], source_field: str",
            ") -> Dict[str, dict]:",
            "    if isinstance(field, ManyToManyFieldInstance):",
            "        return get_m2m_filters(field_name, field)",
            "    if isinstance(field, BackwardFKRelation):",
            "        return get_backward_fk_filters(field_name, field)",
            "    actual_field_name = field_name",
            "    if field_name == \"pk\" and field:",
            "        actual_field_name = field.model_field_name",
            "    return {",
            "        field_name: {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": operator.eq,",
            "        },",
            "        f\"{field_name}__not\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": not_equal,",
            "        },",
            "        f\"{field_name}__in\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": is_in,",
            "            \"value_encoder\": list_encoder,",
            "        },",
            "        f\"{field_name}__not_in\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": not_in,",
            "            \"value_encoder\": list_encoder,",
            "        },",
            "        f\"{field_name}__isnull\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": is_null,",
            "            \"value_encoder\": bool_encoder,",
            "        },",
            "        f\"{field_name}__not_isnull\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": not_null,",
            "            \"value_encoder\": bool_encoder,",
            "        },",
            "        f\"{field_name}__gte\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": operator.ge,",
            "        },",
            "        f\"{field_name}__lte\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": operator.le,",
            "        },",
            "        f\"{field_name}__gt\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": operator.gt,",
            "        },",
            "        f\"{field_name}__lt\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": operator.lt,",
            "        },",
            "        f\"{field_name}__range\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": between_and,",
            "            \"value_encoder\": list_encoder,",
            "        },",
            "        f\"{field_name}__contains\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": contains,",
            "            \"value_encoder\": string_encoder,",
            "        },",
            "        f\"{field_name}__startswith\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": starts_with,",
            "            \"value_encoder\": string_encoder,",
            "        },",
            "        f\"{field_name}__endswith\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": ends_with,",
            "            \"value_encoder\": string_encoder,",
            "        },",
            "        f\"{field_name}__iexact\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": insensitive_exact,",
            "            \"value_encoder\": string_encoder,",
            "        },",
            "        f\"{field_name}__icontains\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": insensitive_contains,",
            "            \"value_encoder\": string_encoder,",
            "        },",
            "        f\"{field_name}__istartswith\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": insensitive_starts_with,",
            "            \"value_encoder\": string_encoder,",
            "        },",
            "        f\"{field_name}__iendswith\": {",
            "            \"field\": actual_field_name,",
            "            \"source_field\": source_field,",
            "            \"operator\": insensitive_ends_with,",
            "            \"value_encoder\": string_encoder,",
            "        },",
            "    }"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "7": [],
            "82": [
                "contains"
            ],
            "86": [
                "starts_with"
            ],
            "90": [
                "ends_with"
            ],
            "94": [
                "insensitive_exact"
            ],
            "98": [
                "insensitive_contains"
            ],
            "102": [
                "insensitive_starts_with"
            ],
            "106": [
                "insensitive_ends_with"
            ]
        },
        "addLocation": []
    }
}