{
    "keystone/api/_shared/EC2_S3_Resource.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " # Common base resource for EC2 and S3 Authentication"
            },
            "2": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+import datetime"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from oslo_serialization import jsonutils"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+from oslo_utils import timeutils"
            },
            "7": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from werkzeug import exceptions"
            },
            "8": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from keystone.common import provider_api"
            },
            "10": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from keystone.common import utils"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+import keystone.conf"
            },
            "12": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from keystone import exception as ks_exceptions"
            },
            "13": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from keystone.i18n import _"
            },
            "14": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from keystone.server import flask as ks_flask"
            },
            "15": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+CONF = keystone.conf.CONF"
            },
            "17": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " PROVIDERS = provider_api.ProviderAPIs"
            },
            "18": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " CRED_TYPE_EC2 = 'ec2'"
            },
            "19": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "         # the ABC module."
            },
            "21": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "         raise NotImplementedError()"
            },
            "22": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+    @staticmethod"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+    def _check_timestamp(credentials):"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+        timestamp = ("
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+            # AWS Signature v1/v2"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+            credentials.get('params', {}).get('Timestamp') or"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+            # AWS Signature v4"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+            credentials.get('headers', {}).get('X-Amz-Date') or"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+            credentials.get('params', {}).get('X-Amz-Date')"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        )"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+        if not timestamp:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+            # If the signed payload doesn't include a timestamp then the signer"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+            # must have intentionally left it off"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+            return"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+        try:"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+            timestamp = timeutils.parse_isotime(timestamp)"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+            timestamp = timeutils.normalize_time(timestamp)"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+        except Exception as e:"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+            raise ks_exceptions.Unauthorized("
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+                _('Credential timestamp is invalid: %s') % e)"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        auth_ttl = datetime.timedelta(minutes=CONF.credential.auth_ttl)"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+        current_time = timeutils.normalize_time(timeutils.utcnow())"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+        if current_time > timestamp + auth_ttl:"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+            raise ks_exceptions.Unauthorized("
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+                _('Credential is expired'))"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+"
            },
            "48": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 69,
                "PatchRowcode": "     def handle_authenticate(self):"
            },
            "49": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         # TODO(morgan): convert this dirty check to JSON Schema validation"
            },
            "50": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "         # this mirrors the previous behavior of the webob system where an"
            },
            "51": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "         except AssertionError as e:"
            },
            "52": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "             raise ks_exceptions.Unauthorized from e"
            },
            "53": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 133,
                "PatchRowcode": " "
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+        self._check_timestamp(credentials)"
            },
            "55": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "         roles = PROVIDERS.assignment_api.get_roles_for_user_and_project("
            },
            "56": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "             user_ref['id'], project_ref['id'])"
            },
            "57": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 137,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "# Common base resource for EC2 and S3 Authentication",
            "",
            "from oslo_serialization import jsonutils",
            "from werkzeug import exceptions",
            "",
            "from keystone.common import provider_api",
            "from keystone.common import utils",
            "from keystone import exception as ks_exceptions",
            "from keystone.i18n import _",
            "from keystone.server import flask as ks_flask",
            "",
            "PROVIDERS = provider_api.ProviderAPIs",
            "CRED_TYPE_EC2 = 'ec2'",
            "",
            "",
            "class ResourceBase(ks_flask.ResourceBase):",
            "    def get(self):",
            "        # SPECIAL CASE: GET is not allowed, raise METHOD_NOT_ALLOWED",
            "        raise exceptions.MethodNotAllowed(valid_methods=['POST'])",
            "",
            "    @staticmethod",
            "    def _check_signature(cred_ref, credentials):",
            "        # NOTE(morgan): @staticmethod doesn't always play nice with",
            "        # the ABC module.",
            "        raise NotImplementedError()",
            "",
            "    def handle_authenticate(self):",
            "        # TODO(morgan): convert this dirty check to JSON Schema validation",
            "        # this mirrors the previous behavior of the webob system where an",
            "        # empty request body for s3 and ec2 tokens would result in a BAD",
            "        # REQUEST. Almost all other APIs use JSON Schema and therefore would",
            "        # catch this early on. S3 and EC2 did not ever get json schema",
            "        # implemented for them.",
            "        if not self.request_body_json:",
            "            msg = _('request must include a request body')",
            "            raise ks_exceptions.ValidationError(msg)",
            "",
            "        # NOTE(morgan): THIS IS SLOPPY! Apparently... keystone passed values",
            "        # as \"credential\" and \"credentials\" in into the s3/ec2 authenticate",
            "        # methods. There is no reason the multiple names should have worked",
            "        # except that we totally did something wonky in the past... so now",
            "        # there are 2 dirty \"acceptable\" body hacks for compatibility....",
            "        # Try \"credentials\" then \"credential\" and THEN ec2Credentials. Final",
            "        # default is {}",
            "        credentials = (",
            "            self.request_body_json.get('credentials') or",
            "            self.request_body_json.get('credential') or",
            "            self.request_body_json.get('ec2Credentials')",
            "        )",
            "        if not credentials:",
            "            credentials = {}",
            "",
            "        if 'access' not in credentials:",
            "            raise ks_exceptions.Unauthorized(_('EC2 Signature not supplied'))",
            "",
            "        # Load the credential from the backend",
            "        credential_id = utils.hash_access_key(credentials['access'])",
            "        cred = PROVIDERS.credential_api.get_credential(credential_id)",
            "        if not cred or cred['type'] != CRED_TYPE_EC2:",
            "            raise ks_exceptions.Unauthorized(_('EC2 access key not found.'))",
            "",
            "        # load from json if needed",
            "        try:",
            "            loaded = jsonutils.loads(cred['blob'])",
            "        except TypeError:",
            "            loaded = cred['blob']",
            "",
            "        # Convert to the legacy format",
            "        cred_data = dict(",
            "            user_id=cred.get('user_id'),",
            "            project_id=cred.get('project_id'),",
            "            access=loaded.get('access'),",
            "            secret=loaded.get('secret'),",
            "            trust_id=loaded.get('trust_id')",
            "        )",
            "",
            "        # validate the signature",
            "        self._check_signature(cred_data, credentials)",
            "        project_ref = PROVIDERS.resource_api.get_project(",
            "            cred_data['project_id'])",
            "        user_ref = PROVIDERS.identity_api.get_user(cred_data['user_id'])",
            "",
            "        # validate that the auth info is valid and nothing is disabled",
            "        try:",
            "            PROVIDERS.identity_api.assert_user_enabled(",
            "                user_id=user_ref['id'], user=user_ref)",
            "            PROVIDERS.resource_api.assert_project_enabled(",
            "                project_id=project_ref['id'], project=project_ref)",
            "        except AssertionError as e:",
            "            raise ks_exceptions.Unauthorized from e",
            "",
            "        roles = PROVIDERS.assignment_api.get_roles_for_user_and_project(",
            "            user_ref['id'], project_ref['id'])",
            "",
            "        if not roles:",
            "            raise ks_exceptions.Unauthorized(_('User not valid for project.'))",
            "",
            "        for r_id in roles:",
            "            # Assert all roles exist.",
            "            PROVIDERS.role_api.get_role(r_id)",
            "",
            "        method_names = ['ec2credential']",
            "",
            "        token = PROVIDERS.token_provider_api.issue_token(",
            "            user_id=user_ref['id'], method_names=method_names,",
            "            project_id=project_ref['id'])",
            "        return token"
        ],
        "afterPatchFile": [
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "# Common base resource for EC2 and S3 Authentication",
            "",
            "import datetime",
            "",
            "from oslo_serialization import jsonutils",
            "from oslo_utils import timeutils",
            "from werkzeug import exceptions",
            "",
            "from keystone.common import provider_api",
            "from keystone.common import utils",
            "import keystone.conf",
            "from keystone import exception as ks_exceptions",
            "from keystone.i18n import _",
            "from keystone.server import flask as ks_flask",
            "",
            "CONF = keystone.conf.CONF",
            "PROVIDERS = provider_api.ProviderAPIs",
            "CRED_TYPE_EC2 = 'ec2'",
            "",
            "",
            "class ResourceBase(ks_flask.ResourceBase):",
            "    def get(self):",
            "        # SPECIAL CASE: GET is not allowed, raise METHOD_NOT_ALLOWED",
            "        raise exceptions.MethodNotAllowed(valid_methods=['POST'])",
            "",
            "    @staticmethod",
            "    def _check_signature(cred_ref, credentials):",
            "        # NOTE(morgan): @staticmethod doesn't always play nice with",
            "        # the ABC module.",
            "        raise NotImplementedError()",
            "",
            "    @staticmethod",
            "    def _check_timestamp(credentials):",
            "        timestamp = (",
            "            # AWS Signature v1/v2",
            "            credentials.get('params', {}).get('Timestamp') or",
            "            # AWS Signature v4",
            "            credentials.get('headers', {}).get('X-Amz-Date') or",
            "            credentials.get('params', {}).get('X-Amz-Date')",
            "        )",
            "        if not timestamp:",
            "            # If the signed payload doesn't include a timestamp then the signer",
            "            # must have intentionally left it off",
            "            return",
            "        try:",
            "            timestamp = timeutils.parse_isotime(timestamp)",
            "            timestamp = timeutils.normalize_time(timestamp)",
            "        except Exception as e:",
            "            raise ks_exceptions.Unauthorized(",
            "                _('Credential timestamp is invalid: %s') % e)",
            "        auth_ttl = datetime.timedelta(minutes=CONF.credential.auth_ttl)",
            "        current_time = timeutils.normalize_time(timeutils.utcnow())",
            "        if current_time > timestamp + auth_ttl:",
            "            raise ks_exceptions.Unauthorized(",
            "                _('Credential is expired'))",
            "",
            "    def handle_authenticate(self):",
            "        # TODO(morgan): convert this dirty check to JSON Schema validation",
            "        # this mirrors the previous behavior of the webob system where an",
            "        # empty request body for s3 and ec2 tokens would result in a BAD",
            "        # REQUEST. Almost all other APIs use JSON Schema and therefore would",
            "        # catch this early on. S3 and EC2 did not ever get json schema",
            "        # implemented for them.",
            "        if not self.request_body_json:",
            "            msg = _('request must include a request body')",
            "            raise ks_exceptions.ValidationError(msg)",
            "",
            "        # NOTE(morgan): THIS IS SLOPPY! Apparently... keystone passed values",
            "        # as \"credential\" and \"credentials\" in into the s3/ec2 authenticate",
            "        # methods. There is no reason the multiple names should have worked",
            "        # except that we totally did something wonky in the past... so now",
            "        # there are 2 dirty \"acceptable\" body hacks for compatibility....",
            "        # Try \"credentials\" then \"credential\" and THEN ec2Credentials. Final",
            "        # default is {}",
            "        credentials = (",
            "            self.request_body_json.get('credentials') or",
            "            self.request_body_json.get('credential') or",
            "            self.request_body_json.get('ec2Credentials')",
            "        )",
            "        if not credentials:",
            "            credentials = {}",
            "",
            "        if 'access' not in credentials:",
            "            raise ks_exceptions.Unauthorized(_('EC2 Signature not supplied'))",
            "",
            "        # Load the credential from the backend",
            "        credential_id = utils.hash_access_key(credentials['access'])",
            "        cred = PROVIDERS.credential_api.get_credential(credential_id)",
            "        if not cred or cred['type'] != CRED_TYPE_EC2:",
            "            raise ks_exceptions.Unauthorized(_('EC2 access key not found.'))",
            "",
            "        # load from json if needed",
            "        try:",
            "            loaded = jsonutils.loads(cred['blob'])",
            "        except TypeError:",
            "            loaded = cred['blob']",
            "",
            "        # Convert to the legacy format",
            "        cred_data = dict(",
            "            user_id=cred.get('user_id'),",
            "            project_id=cred.get('project_id'),",
            "            access=loaded.get('access'),",
            "            secret=loaded.get('secret'),",
            "            trust_id=loaded.get('trust_id')",
            "        )",
            "",
            "        # validate the signature",
            "        self._check_signature(cred_data, credentials)",
            "        project_ref = PROVIDERS.resource_api.get_project(",
            "            cred_data['project_id'])",
            "        user_ref = PROVIDERS.identity_api.get_user(cred_data['user_id'])",
            "",
            "        # validate that the auth info is valid and nothing is disabled",
            "        try:",
            "            PROVIDERS.identity_api.assert_user_enabled(",
            "                user_id=user_ref['id'], user=user_ref)",
            "            PROVIDERS.resource_api.assert_project_enabled(",
            "                project_id=project_ref['id'], project=project_ref)",
            "        except AssertionError as e:",
            "            raise ks_exceptions.Unauthorized from e",
            "",
            "        self._check_timestamp(credentials)",
            "        roles = PROVIDERS.assignment_api.get_roles_for_user_and_project(",
            "            user_ref['id'], project_ref['id'])",
            "",
            "        if not roles:",
            "            raise ks_exceptions.Unauthorized(_('User not valid for project.'))",
            "",
            "        for r_id in roles:",
            "            # Assert all roles exist.",
            "            PROVIDERS.role_api.get_role(r_id)",
            "",
            "        method_names = ['ec2credential']",
            "",
            "        token = PROVIDERS.token_provider_api.issue_token(",
            "            user_id=user_ref['id'], method_names=method_names,",
            "            project_id=project_ref['id'])",
            "        return token"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "keystone.api._shared.EC2_S3_Resource.ResourceBase.self",
            "keystone.api._shared.EC2_S3_Resource.ResourceBase._check_signature.credentials",
            "keystone.api._shared.EC2_S3_Resource.ResourceBase.handle_authenticate.credentials",
            "keystone.api._shared.EC2_S3_Resource.ResourceBase.handle_authenticate.method_names",
            "keystone.api._shared.EC2_S3_Resource.ResourceBase.handle_authenticate",
            "openstack_dashboard.dashboards.project.stacks.forms.TemplateForm"
        ]
    },
    "keystone/conf/credential.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 61,
                "PatchRowcode": " caching is enabled."
            },
            "1": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": " \"\"\"))"
            },
            "2": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+auth_ttl = cfg.IntOpt("
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+    'auth_ttl',"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+    default=15,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+    help=utils.fmt(\"\"\""
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+The length of time in minutes for which a signed EC2 or S3 token request is"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+valid from the timestamp contained in the token request."
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+\"\"\"))"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+"
            },
            "11": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 72,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 73,
                "PatchRowcode": " GROUP_NAME = __name__.split('.')[-1]"
            },
            "13": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": 74,
                "PatchRowcode": " ALL_OPTS = ["
            },
            "14": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "     driver,"
            },
            "15": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "     provider,"
            },
            "16": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "     key_repository,"
            },
            "17": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "     caching,"
            },
            "18": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    cache_time"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+    cache_time,"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+    auth_ttl"
            },
            "21": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 81,
                "PatchRowcode": " ]"
            },
            "22": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 82,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 83,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "from oslo_config import cfg",
            "",
            "from keystone.conf import utils",
            "",
            "",
            "driver = cfg.StrOpt(",
            "    'driver',",
            "    default='sql',",
            "    help=utils.fmt(\"\"\"",
            "Entry point for the credential backend driver in the `keystone.credential`",
            "namespace. Keystone only provides a `sql` driver, so there's no reason to",
            "change this unless you are providing a custom entry point.",
            "\"\"\"))",
            "",
            "provider = cfg.StrOpt(",
            "    'provider',",
            "    default='fernet',",
            "    help=utils.fmt(\"\"\"",
            "Entry point for credential encryption and decryption operations in the",
            "`keystone.credential.provider` namespace. Keystone only provides a `fernet`",
            "driver, so there's no reason to change this unless you are providing a custom",
            "entry point to encrypt and decrypt credentials.",
            "\"\"\"))",
            "",
            "key_repository = cfg.StrOpt(",
            "    'key_repository',",
            "    default='/etc/keystone/credential-keys/',",
            "    help=utils.fmt(\"\"\"",
            "Directory containing Fernet keys used to encrypt and decrypt credentials stored",
            "in the credential backend. Fernet keys used to encrypt credentials have no",
            "relationship to Fernet keys used to encrypt Fernet tokens. Both sets of keys",
            "should be managed separately and require different rotation policies. Do not",
            "share this repository with the repository used to manage keys for Fernet",
            "tokens.",
            "\"\"\"))",
            "",
            "caching = cfg.BoolOpt(",
            "    'caching',",
            "    default=True,",
            "    help=utils.fmt(\"\"\"",
            "Toggle for caching only on retrieval of user credentials. This has no effect",
            "unless global caching is enabled.",
            "\"\"\"))",
            "",
            "cache_time = cfg.IntOpt(",
            "    'cache_time',",
            "    help=utils.fmt(\"\"\"",
            "Time to cache credential data in seconds. This has no effect unless global",
            "caching is enabled.",
            "\"\"\"))",
            "",
            "",
            "GROUP_NAME = __name__.split('.')[-1]",
            "ALL_OPTS = [",
            "    driver,",
            "    provider,",
            "    key_repository,",
            "    caching,",
            "    cache_time",
            "]",
            "",
            "",
            "def register_opts(conf):",
            "    conf.register_opts(ALL_OPTS, group=GROUP_NAME)",
            "",
            "",
            "def list_opts():",
            "    return {GROUP_NAME: ALL_OPTS}"
        ],
        "afterPatchFile": [
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "from oslo_config import cfg",
            "",
            "from keystone.conf import utils",
            "",
            "",
            "driver = cfg.StrOpt(",
            "    'driver',",
            "    default='sql',",
            "    help=utils.fmt(\"\"\"",
            "Entry point for the credential backend driver in the `keystone.credential`",
            "namespace. Keystone only provides a `sql` driver, so there's no reason to",
            "change this unless you are providing a custom entry point.",
            "\"\"\"))",
            "",
            "provider = cfg.StrOpt(",
            "    'provider',",
            "    default='fernet',",
            "    help=utils.fmt(\"\"\"",
            "Entry point for credential encryption and decryption operations in the",
            "`keystone.credential.provider` namespace. Keystone only provides a `fernet`",
            "driver, so there's no reason to change this unless you are providing a custom",
            "entry point to encrypt and decrypt credentials.",
            "\"\"\"))",
            "",
            "key_repository = cfg.StrOpt(",
            "    'key_repository',",
            "    default='/etc/keystone/credential-keys/',",
            "    help=utils.fmt(\"\"\"",
            "Directory containing Fernet keys used to encrypt and decrypt credentials stored",
            "in the credential backend. Fernet keys used to encrypt credentials have no",
            "relationship to Fernet keys used to encrypt Fernet tokens. Both sets of keys",
            "should be managed separately and require different rotation policies. Do not",
            "share this repository with the repository used to manage keys for Fernet",
            "tokens.",
            "\"\"\"))",
            "",
            "caching = cfg.BoolOpt(",
            "    'caching',",
            "    default=True,",
            "    help=utils.fmt(\"\"\"",
            "Toggle for caching only on retrieval of user credentials. This has no effect",
            "unless global caching is enabled.",
            "\"\"\"))",
            "",
            "cache_time = cfg.IntOpt(",
            "    'cache_time',",
            "    help=utils.fmt(\"\"\"",
            "Time to cache credential data in seconds. This has no effect unless global",
            "caching is enabled.",
            "\"\"\"))",
            "",
            "auth_ttl = cfg.IntOpt(",
            "    'auth_ttl',",
            "    default=15,",
            "    help=utils.fmt(\"\"\"",
            "The length of time in minutes for which a signed EC2 or S3 token request is",
            "valid from the timestamp contained in the token request.",
            "\"\"\"))",
            "",
            "",
            "GROUP_NAME = __name__.split('.')[-1]",
            "ALL_OPTS = [",
            "    driver,",
            "    provider,",
            "    key_repository,",
            "    caching,",
            "    cache_time,",
            "    auth_ttl",
            "]",
            "",
            "",
            "def register_opts(conf):",
            "    conf.register_opts(ALL_OPTS, group=GROUP_NAME)",
            "",
            "",
            "def list_opts():",
            "    return {GROUP_NAME: ALL_OPTS}"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "71": []
        },
        "addLocation": []
    },
    "keystone/tests/unit/test_contrib_ec2_core.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " # License for the specific language governing permissions and limitations"
            },
            "1": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " # under the License."
            },
            "2": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+import datetime"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+import hashlib"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+"
            },
            "6": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " import http.client"
            },
            "7": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from keystoneclient.contrib.ec2 import utils as ec2_utils"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+from oslo_utils import timeutils"
            },
            "9": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from keystone.common import provider_api"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 23,
                "PatchRowcode": "+from keystone.common import utils"
            },
            "12": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from keystone.tests import unit"
            },
            "13": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " from keystone.tests.unit import test_v3"
            },
            "14": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "     def test_valid_authentication_response_with_proper_secret(self):"
            },
            "17": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "         signer = ec2_utils.Ec2Signer(self.cred_blob['secret'])"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+        timestamp = utils.isotime(timeutils.utcnow())"
            },
            "19": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "         credentials = {"
            },
            "20": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "             'access': self.cred_blob['access'],"
            },
            "21": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "             'secret': self.cred_blob['secret'],"
            },
            "22": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "             'params': {"
            },
            "23": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 50,
                "PatchRowcode": "                 'SignatureVersion': '2',"
            },
            "24": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 51,
                "PatchRowcode": "                 'Action': 'Test',"
            },
            "25": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                'Timestamp': '2007-01-31T23:59:59Z'"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+                'Timestamp': timestamp"
            },
            "27": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "             },"
            },
            "28": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "         }"
            },
            "29": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "         credentials['signature'] = signer.generate(credentials)"
            },
            "30": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "             expected_status=http.client.OK)"
            },
            "31": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "         self.assertValidProjectScopedTokenResponse(resp, self.user)"
            },
            "32": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 61,
                "PatchRowcode": " "
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+    def test_valid_authentication_response_with_signature_v4(self):"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        signer = ec2_utils.Ec2Signer(self.cred_blob['secret'])"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+        timestamp = utils.isotime(timeutils.utcnow())"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+        hashed_payload = ("
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+            'GET\\n'"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+            '/\\n'"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+            'Action=Test\\n'"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+            'host:localhost\\n'"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+            'x-amz-date:' + timestamp + '\\n'"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+            '\\n'"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+            'host;x-amz-date\\n'"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+            'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+        )"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+        body_hash = hashlib.sha256(hashed_payload.encode()).hexdigest()"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+        amz_credential = ("
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+            'AKIAIOSFODNN7EXAMPLE/%s/us-east-1/iam/aws4_request,' %"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+            timestamp[:8])"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+        credentials = {"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+            'access': self.cred_blob['access'],"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+            'secret': self.cred_blob['secret'],"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+            'host': 'localhost',"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+            'verb': 'GET',"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+            'path': '/',"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+            'params': {"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+                'Action': 'Test',"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+                'X-Amz-Algorithm': 'AWS4-HMAC-SHA256',"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+                'X-Amz-SignedHeaders': 'host,x-amz-date,',"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+                'X-Amz-Credential': amz_credential"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+            },"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+            'headers': {"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 93,
                "PatchRowcode": "+                'X-Amz-Date': timestamp"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 94,
                "PatchRowcode": "+            },"
            },
            "66": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 95,
                "PatchRowcode": "+            'body_hash': body_hash"
            },
            "67": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+        }"
            },
            "68": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+        credentials['signature'] = signer.generate(credentials)"
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+        resp = self.post("
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+            '/ec2tokens',"
            },
            "71": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+            body={'credentials': credentials},"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+            expected_status=http.client.OK)"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+        self.assertValidProjectScopedTokenResponse(resp, self.user)"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+"
            },
            "75": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "     def test_authenticate_with_empty_body_returns_bad_request(self):"
            },
            "76": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "         self.post("
            },
            "77": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 106,
                "PatchRowcode": "             '/ec2tokens',"
            },
            "78": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 120,
                "PatchRowcode": " "
            },
            "79": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "     def test_authenticate_without_proper_secret_returns_unauthorized(self):"
            },
            "80": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         signer = ec2_utils.Ec2Signer('totally not the secret')"
            },
            "81": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+        timestamp = utils.isotime(timeutils.utcnow())"
            },
            "82": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "         credentials = {"
            },
            "83": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "             'access': self.cred_blob['access'],"
            },
            "84": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "             'secret': 'totally not the secret',"
            },
            "85": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "             'params': {"
            },
            "86": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "                 'SignatureVersion': '2',"
            },
            "87": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "                 'Action': 'Test',"
            },
            "88": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                'Timestamp': '2007-01-31T23:59:59Z'"
            },
            "89": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+                'Timestamp': timestamp"
            },
            "90": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+            },"
            },
            "91": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+        }"
            },
            "92": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+        credentials['signature'] = signer.generate(credentials)"
            },
            "93": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+        self.post("
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+            '/ec2tokens',"
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+            body={'credentials': credentials},"
            },
            "96": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+            expected_status=http.client.UNAUTHORIZED)"
            },
            "97": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+    def test_authenticate_expired_request(self):"
            },
            "99": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+        self.config_fixture.config("
            },
            "100": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+            group='credential',"
            },
            "101": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+            auth_ttl=5"
            },
            "102": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+        )"
            },
            "103": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+        signer = ec2_utils.Ec2Signer(self.cred_blob['secret'])"
            },
            "104": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+        past = timeutils.utcnow() - datetime.timedelta(minutes=10)"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+        timestamp = utils.isotime(past)"
            },
            "106": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+        credentials = {"
            },
            "107": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+            'access': self.cred_blob['access'],"
            },
            "108": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+            'secret': self.cred_blob['secret'],"
            },
            "109": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+            'host': 'localhost',"
            },
            "110": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+            'verb': 'GET',"
            },
            "111": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+            'path': '/',"
            },
            "112": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+            'params': {"
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+                'SignatureVersion': '2',"
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+                'Action': 'Test',"
            },
            "115": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+                'Timestamp': timestamp"
            },
            "116": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+            },"
            },
            "117": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+        }"
            },
            "118": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 162,
                "PatchRowcode": "+        credentials['signature'] = signer.generate(credentials)"
            },
            "119": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 163,
                "PatchRowcode": "+        self.post("
            },
            "120": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 164,
                "PatchRowcode": "+            '/ec2tokens',"
            },
            "121": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 165,
                "PatchRowcode": "+            body={'credentials': credentials},"
            },
            "122": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 166,
                "PatchRowcode": "+            expected_status=http.client.UNAUTHORIZED)"
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+"
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+    def test_authenticate_expired_request_v4(self):"
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+        self.config_fixture.config("
            },
            "126": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+            group='credential',"
            },
            "127": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+            auth_ttl=5"
            },
            "128": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+        )"
            },
            "129": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+        signer = ec2_utils.Ec2Signer(self.cred_blob['secret'])"
            },
            "130": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+        past = timeutils.utcnow() - datetime.timedelta(minutes=10)"
            },
            "131": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+        timestamp = utils.isotime(past)"
            },
            "132": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+        hashed_payload = ("
            },
            "133": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+            'GET\\n'"
            },
            "134": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+            '/\\n'"
            },
            "135": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+            'Action=Test\\n'"
            },
            "136": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+            'host:localhost\\n'"
            },
            "137": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+            'x-amz-date:' + timestamp + '\\n'"
            },
            "138": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+            '\\n'"
            },
            "139": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+            'host;x-amz-date\\n'"
            },
            "140": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+            'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'"
            },
            "141": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+        )"
            },
            "142": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+        body_hash = hashlib.sha256(hashed_payload.encode()).hexdigest()"
            },
            "143": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+        amz_credential = ("
            },
            "144": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 188,
                "PatchRowcode": "+            'AKIAIOSFODNN7EXAMPLE/%s/us-east-1/iam/aws4_request,' %"
            },
            "145": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 189,
                "PatchRowcode": "+            timestamp[:8])"
            },
            "146": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 190,
                "PatchRowcode": "+"
            },
            "147": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 191,
                "PatchRowcode": "+        credentials = {"
            },
            "148": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+            'access': self.cred_blob['access'],"
            },
            "149": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+            'secret': self.cred_blob['secret'],"
            },
            "150": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+            'host': 'localhost',"
            },
            "151": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 195,
                "PatchRowcode": "+            'verb': 'GET',"
            },
            "152": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 196,
                "PatchRowcode": "+            'path': '/',"
            },
            "153": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 197,
                "PatchRowcode": "+            'params': {"
            },
            "154": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 198,
                "PatchRowcode": "+                'Action': 'Test',"
            },
            "155": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 199,
                "PatchRowcode": "+                'X-Amz-Algorithm': 'AWS4-HMAC-SHA256',"
            },
            "156": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 200,
                "PatchRowcode": "+                'X-Amz-SignedHeaders': 'host,x-amz-date,',"
            },
            "157": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 201,
                "PatchRowcode": "+                'X-Amz-Credential': amz_credential"
            },
            "158": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 202,
                "PatchRowcode": "+            },"
            },
            "159": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 203,
                "PatchRowcode": "+            'headers': {"
            },
            "160": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 204,
                "PatchRowcode": "+                'X-Amz-Date': timestamp"
            },
            "161": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 205,
                "PatchRowcode": "             },"
            },
            "162": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 206,
                "PatchRowcode": "+            'body_hash': body_hash"
            },
            "163": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 207,
                "PatchRowcode": "         }"
            },
            "164": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 208,
                "PatchRowcode": "         credentials['signature'] = signer.generate(credentials)"
            },
            "165": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 209,
                "PatchRowcode": "         self.post("
            }
        },
        "frontPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import http.client",
            "from keystoneclient.contrib.ec2 import utils as ec2_utils",
            "",
            "from keystone.common import provider_api",
            "from keystone.tests import unit",
            "from keystone.tests.unit import test_v3",
            "",
            "",
            "PROVIDERS = provider_api.ProviderAPIs",
            "",
            "",
            "class EC2ContribCoreV3(test_v3.RestfulTestCase):",
            "    def setUp(self):",
            "        super(EC2ContribCoreV3, self).setUp()",
            "",
            "        self.cred_blob, self.credential = unit.new_ec2_credential(",
            "            self.user['id'], self.project_id)",
            "        PROVIDERS.credential_api.create_credential(",
            "            self.credential['id'], self.credential)",
            "",
            "    def test_valid_authentication_response_with_proper_secret(self):",
            "        signer = ec2_utils.Ec2Signer(self.cred_blob['secret'])",
            "        credentials = {",
            "            'access': self.cred_blob['access'],",
            "            'secret': self.cred_blob['secret'],",
            "            'host': 'localhost',",
            "            'verb': 'GET',",
            "            'path': '/',",
            "            'params': {",
            "                'SignatureVersion': '2',",
            "                'Action': 'Test',",
            "                'Timestamp': '2007-01-31T23:59:59Z'",
            "            },",
            "        }",
            "        credentials['signature'] = signer.generate(credentials)",
            "        resp = self.post(",
            "            '/ec2tokens',",
            "            body={'credentials': credentials},",
            "            expected_status=http.client.OK)",
            "        self.assertValidProjectScopedTokenResponse(resp, self.user)",
            "",
            "    def test_authenticate_with_empty_body_returns_bad_request(self):",
            "        self.post(",
            "            '/ec2tokens',",
            "            body={},",
            "            expected_status=http.client.BAD_REQUEST)",
            "",
            "    def test_authenticate_without_json_request_returns_bad_request(self):",
            "        self.post(",
            "            '/ec2tokens',",
            "            body='not json',",
            "            expected_status=http.client.BAD_REQUEST)",
            "",
            "    def test_authenticate_without_request_body_returns_bad_request(self):",
            "        self.post(",
            "            '/ec2tokens',",
            "            expected_status=http.client.BAD_REQUEST)",
            "",
            "    def test_authenticate_without_proper_secret_returns_unauthorized(self):",
            "        signer = ec2_utils.Ec2Signer('totally not the secret')",
            "        credentials = {",
            "            'access': self.cred_blob['access'],",
            "            'secret': 'totally not the secret',",
            "            'host': 'localhost',",
            "            'verb': 'GET',",
            "            'path': '/',",
            "            'params': {",
            "                'SignatureVersion': '2',",
            "                'Action': 'Test',",
            "                'Timestamp': '2007-01-31T23:59:59Z'",
            "            },",
            "        }",
            "        credentials['signature'] = signer.generate(credentials)",
            "        self.post(",
            "            '/ec2tokens',",
            "            body={'credentials': credentials},",
            "            expected_status=http.client.UNAUTHORIZED)"
        ],
        "afterPatchFile": [
            "# Copyright 2012 OpenStack Foundation",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import datetime",
            "import hashlib",
            "",
            "import http.client",
            "from keystoneclient.contrib.ec2 import utils as ec2_utils",
            "from oslo_utils import timeutils",
            "",
            "from keystone.common import provider_api",
            "from keystone.common import utils",
            "from keystone.tests import unit",
            "from keystone.tests.unit import test_v3",
            "",
            "",
            "PROVIDERS = provider_api.ProviderAPIs",
            "",
            "",
            "class EC2ContribCoreV3(test_v3.RestfulTestCase):",
            "    def setUp(self):",
            "        super(EC2ContribCoreV3, self).setUp()",
            "",
            "        self.cred_blob, self.credential = unit.new_ec2_credential(",
            "            self.user['id'], self.project_id)",
            "        PROVIDERS.credential_api.create_credential(",
            "            self.credential['id'], self.credential)",
            "",
            "    def test_valid_authentication_response_with_proper_secret(self):",
            "        signer = ec2_utils.Ec2Signer(self.cred_blob['secret'])",
            "        timestamp = utils.isotime(timeutils.utcnow())",
            "        credentials = {",
            "            'access': self.cred_blob['access'],",
            "            'secret': self.cred_blob['secret'],",
            "            'host': 'localhost',",
            "            'verb': 'GET',",
            "            'path': '/',",
            "            'params': {",
            "                'SignatureVersion': '2',",
            "                'Action': 'Test',",
            "                'Timestamp': timestamp",
            "            },",
            "        }",
            "        credentials['signature'] = signer.generate(credentials)",
            "        resp = self.post(",
            "            '/ec2tokens',",
            "            body={'credentials': credentials},",
            "            expected_status=http.client.OK)",
            "        self.assertValidProjectScopedTokenResponse(resp, self.user)",
            "",
            "    def test_valid_authentication_response_with_signature_v4(self):",
            "        signer = ec2_utils.Ec2Signer(self.cred_blob['secret'])",
            "        timestamp = utils.isotime(timeutils.utcnow())",
            "        hashed_payload = (",
            "            'GET\\n'",
            "            '/\\n'",
            "            'Action=Test\\n'",
            "            'host:localhost\\n'",
            "            'x-amz-date:' + timestamp + '\\n'",
            "            '\\n'",
            "            'host;x-amz-date\\n'",
            "            'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'",
            "        )",
            "        body_hash = hashlib.sha256(hashed_payload.encode()).hexdigest()",
            "        amz_credential = (",
            "            'AKIAIOSFODNN7EXAMPLE/%s/us-east-1/iam/aws4_request,' %",
            "            timestamp[:8])",
            "",
            "        credentials = {",
            "            'access': self.cred_blob['access'],",
            "            'secret': self.cred_blob['secret'],",
            "            'host': 'localhost',",
            "            'verb': 'GET',",
            "            'path': '/',",
            "            'params': {",
            "                'Action': 'Test',",
            "                'X-Amz-Algorithm': 'AWS4-HMAC-SHA256',",
            "                'X-Amz-SignedHeaders': 'host,x-amz-date,',",
            "                'X-Amz-Credential': amz_credential",
            "            },",
            "            'headers': {",
            "                'X-Amz-Date': timestamp",
            "            },",
            "            'body_hash': body_hash",
            "        }",
            "        credentials['signature'] = signer.generate(credentials)",
            "        resp = self.post(",
            "            '/ec2tokens',",
            "            body={'credentials': credentials},",
            "            expected_status=http.client.OK)",
            "        self.assertValidProjectScopedTokenResponse(resp, self.user)",
            "",
            "    def test_authenticate_with_empty_body_returns_bad_request(self):",
            "        self.post(",
            "            '/ec2tokens',",
            "            body={},",
            "            expected_status=http.client.BAD_REQUEST)",
            "",
            "    def test_authenticate_without_json_request_returns_bad_request(self):",
            "        self.post(",
            "            '/ec2tokens',",
            "            body='not json',",
            "            expected_status=http.client.BAD_REQUEST)",
            "",
            "    def test_authenticate_without_request_body_returns_bad_request(self):",
            "        self.post(",
            "            '/ec2tokens',",
            "            expected_status=http.client.BAD_REQUEST)",
            "",
            "    def test_authenticate_without_proper_secret_returns_unauthorized(self):",
            "        signer = ec2_utils.Ec2Signer('totally not the secret')",
            "        timestamp = utils.isotime(timeutils.utcnow())",
            "        credentials = {",
            "            'access': self.cred_blob['access'],",
            "            'secret': 'totally not the secret',",
            "            'host': 'localhost',",
            "            'verb': 'GET',",
            "            'path': '/',",
            "            'params': {",
            "                'SignatureVersion': '2',",
            "                'Action': 'Test',",
            "                'Timestamp': timestamp",
            "            },",
            "        }",
            "        credentials['signature'] = signer.generate(credentials)",
            "        self.post(",
            "            '/ec2tokens',",
            "            body={'credentials': credentials},",
            "            expected_status=http.client.UNAUTHORIZED)",
            "",
            "    def test_authenticate_expired_request(self):",
            "        self.config_fixture.config(",
            "            group='credential',",
            "            auth_ttl=5",
            "        )",
            "        signer = ec2_utils.Ec2Signer(self.cred_blob['secret'])",
            "        past = timeutils.utcnow() - datetime.timedelta(minutes=10)",
            "        timestamp = utils.isotime(past)",
            "        credentials = {",
            "            'access': self.cred_blob['access'],",
            "            'secret': self.cred_blob['secret'],",
            "            'host': 'localhost',",
            "            'verb': 'GET',",
            "            'path': '/',",
            "            'params': {",
            "                'SignatureVersion': '2',",
            "                'Action': 'Test',",
            "                'Timestamp': timestamp",
            "            },",
            "        }",
            "        credentials['signature'] = signer.generate(credentials)",
            "        self.post(",
            "            '/ec2tokens',",
            "            body={'credentials': credentials},",
            "            expected_status=http.client.UNAUTHORIZED)",
            "",
            "    def test_authenticate_expired_request_v4(self):",
            "        self.config_fixture.config(",
            "            group='credential',",
            "            auth_ttl=5",
            "        )",
            "        signer = ec2_utils.Ec2Signer(self.cred_blob['secret'])",
            "        past = timeutils.utcnow() - datetime.timedelta(minutes=10)",
            "        timestamp = utils.isotime(past)",
            "        hashed_payload = (",
            "            'GET\\n'",
            "            '/\\n'",
            "            'Action=Test\\n'",
            "            'host:localhost\\n'",
            "            'x-amz-date:' + timestamp + '\\n'",
            "            '\\n'",
            "            'host;x-amz-date\\n'",
            "            'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855'",
            "        )",
            "        body_hash = hashlib.sha256(hashed_payload.encode()).hexdigest()",
            "        amz_credential = (",
            "            'AKIAIOSFODNN7EXAMPLE/%s/us-east-1/iam/aws4_request,' %",
            "            timestamp[:8])",
            "",
            "        credentials = {",
            "            'access': self.cred_blob['access'],",
            "            'secret': self.cred_blob['secret'],",
            "            'host': 'localhost',",
            "            'verb': 'GET',",
            "            'path': '/',",
            "            'params': {",
            "                'Action': 'Test',",
            "                'X-Amz-Algorithm': 'AWS4-HMAC-SHA256',",
            "                'X-Amz-SignedHeaders': 'host,x-amz-date,',",
            "                'X-Amz-Credential': amz_credential",
            "            },",
            "            'headers': {",
            "                'X-Amz-Date': timestamp",
            "            },",
            "            'body_hash': body_hash",
            "        }",
            "        credentials['signature'] = signer.generate(credentials)",
            "        self.post(",
            "            '/ec2tokens',",
            "            body={'credentials': credentials},",
            "            expected_status=http.client.UNAUTHORIZED)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "46": [
                "EC2ContribCoreV3",
                "test_valid_authentication_response_with_proper_secret"
            ],
            "84": [
                "EC2ContribCoreV3",
                "test_authenticate_without_proper_secret_returns_unauthorized"
            ]
        },
        "addLocation": [
            "openstack_dashboard.dashboards.project.stacks.forms.TemplateForm",
            "keystone.tests.unit.test_contrib_ec2_core.EC2ContribCoreV3.test_valid_authentication_response_with_proper_secret.credentials"
        ]
    }
}