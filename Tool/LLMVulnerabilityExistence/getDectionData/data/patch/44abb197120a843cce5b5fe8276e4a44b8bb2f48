{
    "helpdesk/lib.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "                 'application/octet-stream',"
            },
            "1": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "                 size=attached.size,"
            },
            "2": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "             )"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+            att.full_clean()"
            },
            "4": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "             att.save()"
            },
            "5": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 150,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "             if attached.size < max_email_attachment_size:"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "django-helpdesk - A Django powered ticket tracker for small enterprise.",
            "",
            "(c) Copyright 2008 Jutda. All Rights Reserved. See LICENSE for details.",
            "",
            "lib.py - Common functions (eg multipart e-mail)",
            "\"\"\"",
            "",
            "import logging",
            "import mimetypes",
            "",
            "from django.conf import settings",
            "from django.utils.encoding import smart_text",
            "",
            "from helpdesk.models import FollowUpAttachment",
            "",
            "",
            "logger = logging.getLogger('helpdesk')",
            "",
            "",
            "def ticket_template_context(ticket):",
            "    context = {}",
            "",
            "    for field in ('title', 'created', 'modified', 'submitter_email',",
            "                  'status', 'get_status_display', 'on_hold', 'description',",
            "                  'resolution', 'priority', 'get_priority_display',",
            "                  'last_escalation', 'ticket', 'ticket_for_url', 'merged_to',",
            "                  'get_status', 'ticket_url', 'staff_url', '_get_assigned_to'",
            "                  ):",
            "        attr = getattr(ticket, field, None)",
            "        if callable(attr):",
            "            context[field] = '%s' % attr()",
            "        else:",
            "            context[field] = attr",
            "    context['assigned_to'] = context['_get_assigned_to']",
            "",
            "    return context",
            "",
            "",
            "def queue_template_context(queue):",
            "    context = {}",
            "",
            "    for field in ('title', 'slug', 'email_address', 'from_address', 'locale'):",
            "        attr = getattr(queue, field, None)",
            "        if callable(attr):",
            "            context[field] = attr()",
            "        else:",
            "            context[field] = attr",
            "",
            "    return context",
            "",
            "",
            "def safe_template_context(ticket):",
            "    \"\"\"",
            "    Return a dictionary that can be used as a template context to render",
            "    comments and other details with ticket or queue parameters. Note that",
            "    we don't just provide the Ticket & Queue objects to the template as",
            "    they could reveal confidential information. Just imagine these two options:",
            "        * {{ ticket.queue.email_box_password }}",
            "        * {{ ticket.assigned_to.password }}",
            "",
            "    Ouch!",
            "",
            "    The downside to this is that if we make changes to the model, we will also",
            "    have to update this code. Perhaps we can find a better way in the future.",
            "    \"\"\"",
            "",
            "    context = {",
            "        'queue': queue_template_context(ticket.queue),",
            "        'ticket': ticket_template_context(ticket),",
            "    }",
            "    context['ticket']['queue'] = context['queue']",
            "",
            "    return context",
            "",
            "",
            "def text_is_spam(text, request):",
            "    # Based on a blog post by 'sciyoshi':",
            "    # http://sciyoshi.com/blog/2008/aug/27/using-akismet-djangos-new-comments-framework/",
            "    # This will return 'True' is the given text is deemed to be spam, or",
            "    # False if it is not spam. If it cannot be checked for some reason, we",
            "    # assume it isn't spam.",
            "    from django.contrib.sites.models import Site",
            "    from django.core.exceptions import ImproperlyConfigured",
            "    try:",
            "        from akismet import Akismet",
            "    except ImportError:",
            "        return False",
            "    try:",
            "        site = Site.objects.get_current()",
            "    except ImproperlyConfigured:",
            "        site = Site(domain='configure-django-sites.com')",
            "",
            "    # see https://akismet.readthedocs.io/en/latest/overview.html#using-akismet",
            "",
            "    apikey = None",
            "",
            "    if hasattr(settings, 'TYPEPAD_ANTISPAM_API_KEY'):",
            "        apikey = settings.TYPEPAD_ANTISPAM_API_KEY",
            "    elif hasattr(settings, 'PYTHON_AKISMET_API_KEY'):",
            "        # new env var expected by python-akismet package",
            "        apikey = settings.PYTHON_AKISMET_API_KEY",
            "    elif hasattr(settings, 'AKISMET_API_KEY'):",
            "        # deprecated, but kept for backward compatibility",
            "        apikey = settings.AKISMET_API_KEY",
            "    else:",
            "        return False",
            "",
            "    ak = Akismet(",
            "        blog_url='http://%s/' % site.domain,",
            "        key=apikey,",
            "    )",
            "",
            "    if hasattr(settings, 'TYPEPAD_ANTISPAM_API_KEY'):",
            "        ak.baseurl = 'api.antispam.typepad.com/1.1/'",
            "",
            "    if ak.verify_key():",
            "        ak_data = {",
            "            'user_ip': request.META.get('REMOTE_ADDR', '127.0.0.1'),",
            "            'user_agent': request.META.get('HTTP_USER_AGENT', ''),",
            "            'referrer': request.META.get('HTTP_REFERER', ''),",
            "            'comment_type': 'comment',",
            "            'comment_author': '',",
            "        }",
            "",
            "        return ak.comment_check(smart_text(text), data=ak_data)",
            "",
            "    return False",
            "",
            "",
            "def process_attachments(followup, attached_files):",
            "    max_email_attachment_size = getattr(settings, 'HELPDESK_MAX_EMAIL_ATTACHMENT_SIZE', 512000)",
            "    attachments = []",
            "",
            "    for attached in attached_files:",
            "",
            "        if attached.size:",
            "            filename = smart_text(attached.name)",
            "            att = FollowUpAttachment(",
            "                followup=followup,",
            "                file=attached,",
            "                filename=filename,",
            "                mime_type=attached.content_type or",
            "                mimetypes.guess_type(filename, strict=False)[0] or",
            "                'application/octet-stream',",
            "                size=attached.size,",
            "            )",
            "            att.save()",
            "",
            "            if attached.size < max_email_attachment_size:",
            "                # Only files smaller than 512kb (or as defined in",
            "                # settings.HELPDESK_MAX_EMAIL_ATTACHMENT_SIZE) are sent via email.",
            "                attachments.append([filename, att.file])",
            "",
            "    return attachments",
            "",
            "",
            "def format_time_spent(time_spent):",
            "    \"\"\"Format time_spent attribute to \"[H]HHh:MMm\" text string to be allign in",
            "    all graphical outputs",
            "    \"\"\"",
            "",
            "    if time_spent:",
            "        time_spent = \"{0:02d}h:{1:02d}m\".format(",
            "            time_spent.seconds // 3600,",
            "            time_spent.seconds // 60",
            "        )",
            "    else:",
            "        time_spent = \"\"",
            "    return time_spent"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "django-helpdesk - A Django powered ticket tracker for small enterprise.",
            "",
            "(c) Copyright 2008 Jutda. All Rights Reserved. See LICENSE for details.",
            "",
            "lib.py - Common functions (eg multipart e-mail)",
            "\"\"\"",
            "",
            "import logging",
            "import mimetypes",
            "",
            "from django.conf import settings",
            "from django.utils.encoding import smart_text",
            "",
            "from helpdesk.models import FollowUpAttachment",
            "",
            "",
            "logger = logging.getLogger('helpdesk')",
            "",
            "",
            "def ticket_template_context(ticket):",
            "    context = {}",
            "",
            "    for field in ('title', 'created', 'modified', 'submitter_email',",
            "                  'status', 'get_status_display', 'on_hold', 'description',",
            "                  'resolution', 'priority', 'get_priority_display',",
            "                  'last_escalation', 'ticket', 'ticket_for_url', 'merged_to',",
            "                  'get_status', 'ticket_url', 'staff_url', '_get_assigned_to'",
            "                  ):",
            "        attr = getattr(ticket, field, None)",
            "        if callable(attr):",
            "            context[field] = '%s' % attr()",
            "        else:",
            "            context[field] = attr",
            "    context['assigned_to'] = context['_get_assigned_to']",
            "",
            "    return context",
            "",
            "",
            "def queue_template_context(queue):",
            "    context = {}",
            "",
            "    for field in ('title', 'slug', 'email_address', 'from_address', 'locale'):",
            "        attr = getattr(queue, field, None)",
            "        if callable(attr):",
            "            context[field] = attr()",
            "        else:",
            "            context[field] = attr",
            "",
            "    return context",
            "",
            "",
            "def safe_template_context(ticket):",
            "    \"\"\"",
            "    Return a dictionary that can be used as a template context to render",
            "    comments and other details with ticket or queue parameters. Note that",
            "    we don't just provide the Ticket & Queue objects to the template as",
            "    they could reveal confidential information. Just imagine these two options:",
            "        * {{ ticket.queue.email_box_password }}",
            "        * {{ ticket.assigned_to.password }}",
            "",
            "    Ouch!",
            "",
            "    The downside to this is that if we make changes to the model, we will also",
            "    have to update this code. Perhaps we can find a better way in the future.",
            "    \"\"\"",
            "",
            "    context = {",
            "        'queue': queue_template_context(ticket.queue),",
            "        'ticket': ticket_template_context(ticket),",
            "    }",
            "    context['ticket']['queue'] = context['queue']",
            "",
            "    return context",
            "",
            "",
            "def text_is_spam(text, request):",
            "    # Based on a blog post by 'sciyoshi':",
            "    # http://sciyoshi.com/blog/2008/aug/27/using-akismet-djangos-new-comments-framework/",
            "    # This will return 'True' is the given text is deemed to be spam, or",
            "    # False if it is not spam. If it cannot be checked for some reason, we",
            "    # assume it isn't spam.",
            "    from django.contrib.sites.models import Site",
            "    from django.core.exceptions import ImproperlyConfigured",
            "    try:",
            "        from akismet import Akismet",
            "    except ImportError:",
            "        return False",
            "    try:",
            "        site = Site.objects.get_current()",
            "    except ImproperlyConfigured:",
            "        site = Site(domain='configure-django-sites.com')",
            "",
            "    # see https://akismet.readthedocs.io/en/latest/overview.html#using-akismet",
            "",
            "    apikey = None",
            "",
            "    if hasattr(settings, 'TYPEPAD_ANTISPAM_API_KEY'):",
            "        apikey = settings.TYPEPAD_ANTISPAM_API_KEY",
            "    elif hasattr(settings, 'PYTHON_AKISMET_API_KEY'):",
            "        # new env var expected by python-akismet package",
            "        apikey = settings.PYTHON_AKISMET_API_KEY",
            "    elif hasattr(settings, 'AKISMET_API_KEY'):",
            "        # deprecated, but kept for backward compatibility",
            "        apikey = settings.AKISMET_API_KEY",
            "    else:",
            "        return False",
            "",
            "    ak = Akismet(",
            "        blog_url='http://%s/' % site.domain,",
            "        key=apikey,",
            "    )",
            "",
            "    if hasattr(settings, 'TYPEPAD_ANTISPAM_API_KEY'):",
            "        ak.baseurl = 'api.antispam.typepad.com/1.1/'",
            "",
            "    if ak.verify_key():",
            "        ak_data = {",
            "            'user_ip': request.META.get('REMOTE_ADDR', '127.0.0.1'),",
            "            'user_agent': request.META.get('HTTP_USER_AGENT', ''),",
            "            'referrer': request.META.get('HTTP_REFERER', ''),",
            "            'comment_type': 'comment',",
            "            'comment_author': '',",
            "        }",
            "",
            "        return ak.comment_check(smart_text(text), data=ak_data)",
            "",
            "    return False",
            "",
            "",
            "def process_attachments(followup, attached_files):",
            "    max_email_attachment_size = getattr(settings, 'HELPDESK_MAX_EMAIL_ATTACHMENT_SIZE', 512000)",
            "    attachments = []",
            "",
            "    for attached in attached_files:",
            "",
            "        if attached.size:",
            "            filename = smart_text(attached.name)",
            "            att = FollowUpAttachment(",
            "                followup=followup,",
            "                file=attached,",
            "                filename=filename,",
            "                mime_type=attached.content_type or",
            "                mimetypes.guess_type(filename, strict=False)[0] or",
            "                'application/octet-stream',",
            "                size=attached.size,",
            "            )",
            "            att.full_clean()",
            "            att.save()",
            "",
            "            if attached.size < max_email_attachment_size:",
            "                # Only files smaller than 512kb (or as defined in",
            "                # settings.HELPDESK_MAX_EMAIL_ATTACHMENT_SIZE) are sent via email.",
            "                attachments.append([filename, att.file])",
            "",
            "    return attachments",
            "",
            "",
            "def format_time_spent(time_spent):",
            "    \"\"\"Format time_spent attribute to \"[H]HHh:MMm\" text string to be allign in",
            "    all graphical outputs",
            "    \"\"\"",
            "",
            "    if time_spent:",
            "        time_spent = \"{0:02d}h:{1:02d}m\".format(",
            "            time_spent.seconds // 3600,",
            "            time_spent.seconds // 60",
            "        )",
            "    else:",
            "        time_spent = \"\"",
            "    return time_spent"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "omeroweb.webgateway.views",
            "helpdesk.lib.process_attachments.attachments"
        ]
    },
    "helpdesk/tasks.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from celery.decorators import task"
            },
            "1": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1,
                "PatchRowcode": "+from celery import shared_task"
            },
            "2": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from .email import process_email"
            },
            "4": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-@task()"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+@shared_task"
            },
            "8": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " def helpdesk_process_email():"
            },
            "9": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": "     process_email()"
            }
        },
        "frontPatchFile": [
            "from celery.decorators import task",
            "",
            "from .email import process_email",
            "",
            "",
            "@task()",
            "def helpdesk_process_email():",
            "    process_email()"
        ],
        "afterPatchFile": [
            "from celery import shared_task",
            "",
            "from .email import process_email",
            "",
            "",
            "@shared_task",
            "def helpdesk_process_email():",
            "    process_email()"
        ],
        "action": [
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1": [],
            "6": []
        },
        "addLocation": []
    }
}