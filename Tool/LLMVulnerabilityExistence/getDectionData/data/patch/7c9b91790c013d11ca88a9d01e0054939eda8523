{
    "synapse/appservice/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "             url.rstrip(\"/\") if isinstance(url, str) else None"
            },
            "1": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "         )  # url must not end with a slash"
            },
            "2": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "         self.hs_token = hs_token"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+        # The full Matrix ID for this application service's sender."
            },
            "4": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "         self.sender = sender"
            },
            "5": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "         self.namespaces = self._check_namespaces(namespaces)"
            },
            "6": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "         self.id = id"
            },
            "7": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": 213,
                "PatchRowcode": "             True if the application service is interested in the user, False if not."
            },
            "8": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 214,
                "PatchRowcode": "         \"\"\""
            },
            "9": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 215,
                "PatchRowcode": "         return ("
            },
            "10": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # User is the appservice's sender_localpart user"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+            # User is the appservice's configured sender_localpart user"
            },
            "12": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 217,
                "PatchRowcode": "             user_id == self.sender"
            },
            "13": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 218,
                "PatchRowcode": "             # User is in the appservice's user namespace"
            },
            "14": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 219,
                "PatchRowcode": "             or self.is_user_in_namespace(user_id)"
            }
        },
        "frontPatchFile": [
            "# Copyright 2015, 2016 OpenMarket Ltd",
            "# Copyright 2022 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import logging",
            "import re",
            "from enum import Enum",
            "from typing import TYPE_CHECKING, Dict, Iterable, List, Optional, Pattern, Sequence",
            "",
            "import attr",
            "from netaddr import IPSet",
            "",
            "from synapse.api.constants import EventTypes",
            "from synapse.events import EventBase",
            "from synapse.types import DeviceListUpdates, JsonDict, UserID",
            "from synapse.util.caches.descriptors import _CacheContext, cached",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.appservice.api import ApplicationServiceApi",
            "    from synapse.storage.databases.main import DataStore",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "# Type for the `device_one_time_keys_count` field in an appservice transaction",
            "#   user ID -> {device ID -> {algorithm -> count}}",
            "TransactionOneTimeKeysCount = Dict[str, Dict[str, Dict[str, int]]]",
            "",
            "# Type for the `device_unused_fallback_key_types` field in an appservice transaction",
            "#   user ID -> {device ID -> [algorithm]}",
            "TransactionUnusedFallbackKeys = Dict[str, Dict[str, List[str]]]",
            "",
            "",
            "class ApplicationServiceState(Enum):",
            "    DOWN = \"down\"",
            "    UP = \"up\"",
            "",
            "",
            "@attr.s(slots=True, frozen=True, auto_attribs=True)",
            "class Namespace:",
            "    exclusive: bool",
            "    regex: Pattern[str]",
            "",
            "",
            "class ApplicationService:",
            "    \"\"\"Defines an application service. This definition is mostly what is",
            "    provided to the /register AS API.",
            "",
            "    Provides methods to check if this service is \"interested\" in events.",
            "    \"\"\"",
            "",
            "    NS_USERS = \"users\"",
            "    NS_ALIASES = \"aliases\"",
            "    NS_ROOMS = \"rooms\"",
            "    # The ordering here is important as it is used to map database values (which",
            "    # are stored as ints representing the position in this list) to namespace",
            "    # values.",
            "    NS_LIST = [NS_USERS, NS_ALIASES, NS_ROOMS]",
            "",
            "    def __init__(",
            "        self,",
            "        token: str,",
            "        id: str,",
            "        sender: str,",
            "        url: Optional[str] = None,",
            "        namespaces: Optional[JsonDict] = None,",
            "        hs_token: Optional[str] = None,",
            "        protocols: Optional[Iterable[str]] = None,",
            "        rate_limited: bool = True,",
            "        ip_range_whitelist: Optional[IPSet] = None,",
            "        supports_ephemeral: bool = False,",
            "        msc3202_transaction_extensions: bool = False,",
            "    ):",
            "        self.token = token",
            "        self.url = (",
            "            url.rstrip(\"/\") if isinstance(url, str) else None",
            "        )  # url must not end with a slash",
            "        self.hs_token = hs_token",
            "        self.sender = sender",
            "        self.namespaces = self._check_namespaces(namespaces)",
            "        self.id = id",
            "        self.ip_range_whitelist = ip_range_whitelist",
            "        self.supports_ephemeral = supports_ephemeral",
            "        self.msc3202_transaction_extensions = msc3202_transaction_extensions",
            "",
            "        if \"|\" in self.id:",
            "            raise Exception(\"application service ID cannot contain '|' character\")",
            "",
            "        # .protocols is a publicly visible field",
            "        if protocols:",
            "            self.protocols = set(protocols)",
            "        else:",
            "            self.protocols = set()",
            "",
            "        self.rate_limited = rate_limited",
            "",
            "    def _check_namespaces(",
            "        self, namespaces: Optional[JsonDict]",
            "    ) -> Dict[str, List[Namespace]]:",
            "        # Sanity check that it is of the form:",
            "        # {",
            "        #   users: [ {regex: \"[A-z]+.*\", exclusive: true}, ...],",
            "        #   aliases: [ {regex: \"[A-z]+.*\", exclusive: true}, ...],",
            "        #   rooms: [ {regex: \"[A-z]+.*\", exclusive: true}, ...],",
            "        # }",
            "        if namespaces is None:",
            "            namespaces = {}",
            "",
            "        result: Dict[str, List[Namespace]] = {}",
            "",
            "        for ns in ApplicationService.NS_LIST:",
            "            result[ns] = []",
            "",
            "            if ns not in namespaces:",
            "                continue",
            "",
            "            if not isinstance(namespaces[ns], list):",
            "                raise ValueError(\"Bad namespace value for '%s'\" % ns)",
            "            for regex_obj in namespaces[ns]:",
            "                if not isinstance(regex_obj, dict):",
            "                    raise ValueError(\"Expected dict regex for ns '%s'\" % ns)",
            "                exclusive = regex_obj.get(\"exclusive\")",
            "                if not isinstance(exclusive, bool):",
            "                    raise ValueError(\"Expected bool for 'exclusive' in ns '%s'\" % ns)",
            "",
            "                regex = regex_obj.get(\"regex\")",
            "                if not isinstance(regex, str):",
            "                    raise ValueError(\"Expected string for 'regex' in ns '%s'\" % ns)",
            "",
            "                # Pre-compile regex.",
            "                result[ns].append(Namespace(exclusive, re.compile(regex)))",
            "",
            "        return result",
            "",
            "    def _matches_regex(",
            "        self, namespace_key: str, test_string: str",
            "    ) -> Optional[Namespace]:",
            "        for namespace in self.namespaces[namespace_key]:",
            "            if namespace.regex.match(test_string):",
            "                return namespace",
            "        return None",
            "",
            "    def _is_exclusive(self, namespace_key: str, test_string: str) -> bool:",
            "        namespace = self._matches_regex(namespace_key, test_string)",
            "        if namespace:",
            "            return namespace.exclusive",
            "        return False",
            "",
            "    @cached(num_args=1, cache_context=True)",
            "    async def _matches_user_in_member_list(",
            "        self,",
            "        room_id: str,",
            "        store: \"DataStore\",",
            "        cache_context: _CacheContext,",
            "    ) -> bool:",
            "        \"\"\"Check if this service is interested a room based upon its membership",
            "",
            "        Args:",
            "            room_id: The room to check.",
            "            store: The datastore to query.",
            "",
            "        Returns:",
            "            True if this service would like to know about this room.",
            "        \"\"\"",
            "        # We can use `get_local_users_in_room(...)` here because an application service",
            "        # can only be interested in local users of the server it's on (ignore any remote",
            "        # users that might match the user namespace regex).",
            "        #",
            "        # In the future, we can consider re-using",
            "        # `store.get_app_service_users_in_room` which is very similar to this",
            "        # function but has a slightly worse performance than this because we",
            "        # have an early escape-hatch if we find a single user that the",
            "        # appservice is interested in. The juice would be worth the squeeze if",
            "        # `store.get_app_service_users_in_room` was used in more places besides",
            "        # an experimental MSC. But for now we can avoid doing more work and",
            "        # barely using it later.",
            "        local_user_ids = await store.get_local_users_in_room(",
            "            room_id, on_invalidate=cache_context.invalidate",
            "        )",
            "",
            "        # check joined member events",
            "        for user_id in local_user_ids:",
            "            if self.is_interested_in_user(user_id):",
            "                return True",
            "        return False",
            "",
            "    def is_interested_in_user(",
            "        self,",
            "        user_id: str,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Returns whether the application is interested in a given user ID.",
            "",
            "        The appservice is considered to be interested in a user if either: the",
            "        user ID is in the appservice's user namespace, or if the user is the",
            "        appservice's configured sender_localpart.",
            "",
            "        Args:",
            "            user_id: The ID of the user to check.",
            "",
            "        Returns:",
            "            True if the application service is interested in the user, False if not.",
            "        \"\"\"",
            "        return (",
            "            # User is the appservice's sender_localpart user",
            "            user_id == self.sender",
            "            # User is in the appservice's user namespace",
            "            or self.is_user_in_namespace(user_id)",
            "        )",
            "",
            "    @cached(num_args=1, cache_context=True)",
            "    async def is_interested_in_room(",
            "        self,",
            "        room_id: str,",
            "        store: \"DataStore\",",
            "        cache_context: _CacheContext,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Returns whether the application service is interested in a given room ID.",
            "",
            "        The appservice is considered to be interested in the room if either: the ID or one",
            "        of the aliases of the room is in the appservice's room ID or alias namespace",
            "        respectively, or if one of the members of the room fall into the appservice's user",
            "        namespace.",
            "",
            "        Args:",
            "            room_id: The ID of the room to check.",
            "            store: The homeserver's datastore class.",
            "",
            "        Returns:",
            "            True if the application service is interested in the room, False if not.",
            "        \"\"\"",
            "        # Check if we have interest in this room ID",
            "        if self.is_room_id_in_namespace(room_id):",
            "            return True",
            "",
            "        # likewise with the room's aliases (if it has any)",
            "        alias_list = await store.get_aliases_for_room(",
            "            room_id, on_invalidate=cache_context.invalidate",
            "        )",
            "        for alias in alias_list:",
            "            if self.is_room_alias_in_namespace(alias):",
            "                return True",
            "",
            "        # And finally, perform an expensive check on whether any of the",
            "        # users in the room match the appservice's user namespace",
            "        return await self._matches_user_in_member_list(",
            "            room_id, store, on_invalidate=cache_context.invalidate",
            "        )",
            "",
            "    @cached(num_args=1, cache_context=True)",
            "    async def is_interested_in_event(",
            "        self,",
            "        event_id: str,",
            "        event: EventBase,",
            "        store: \"DataStore\",",
            "        cache_context: _CacheContext,",
            "    ) -> bool:",
            "        \"\"\"Check if this service is interested in this event.",
            "",
            "        Args:",
            "            event_id: The ID of the event to check. This is purely used for simplifying the",
            "                caching of calls to this method.",
            "            event: The event to check.",
            "            store: The datastore to query.",
            "",
            "        Returns:",
            "            True if this service would like to know about this event, otherwise False.",
            "        \"\"\"",
            "        # Check if we're interested in this event's sender by namespace (or if they're the",
            "        # sender_localpart user)",
            "        if self.is_interested_in_user(event.sender):",
            "            return True",
            "",
            "        # additionally, if this is a membership event, perform the same checks on",
            "        # the user it references",
            "        if event.type == EventTypes.Member and self.is_interested_in_user(",
            "            event.state_key",
            "        ):",
            "            return True",
            "",
            "        # This will check the datastore, so should be run last",
            "        if await self.is_interested_in_room(",
            "            event.room_id, store, on_invalidate=cache_context.invalidate",
            "        ):",
            "            return True",
            "",
            "        return False",
            "",
            "    @cached(num_args=1, cache_context=True)",
            "    async def is_interested_in_presence(",
            "        self, user_id: UserID, store: \"DataStore\", cache_context: _CacheContext",
            "    ) -> bool:",
            "        \"\"\"Check if this service is interested a user's presence",
            "",
            "        Args:",
            "            user_id: The user to check.",
            "            store: The datastore to query.",
            "",
            "        Returns:",
            "            True if this service would like to know about presence for this user.",
            "        \"\"\"",
            "        # Find all the rooms the sender is in",
            "        if self.is_interested_in_user(user_id.to_string()):",
            "            return True",
            "        room_ids = await store.get_rooms_for_user(",
            "            user_id.to_string(), on_invalidate=cache_context.invalidate",
            "        )",
            "",
            "        # Then find out if the appservice is interested in any of those rooms",
            "        for room_id in room_ids:",
            "            if await self.is_interested_in_room(",
            "                room_id, store, on_invalidate=cache_context.invalidate",
            "            ):",
            "                return True",
            "        return False",
            "",
            "    def is_user_in_namespace(self, user_id: str) -> bool:",
            "        return bool(self._matches_regex(ApplicationService.NS_USERS, user_id))",
            "",
            "    def is_room_alias_in_namespace(self, alias: str) -> bool:",
            "        return bool(self._matches_regex(ApplicationService.NS_ALIASES, alias))",
            "",
            "    def is_room_id_in_namespace(self, room_id: str) -> bool:",
            "        return bool(self._matches_regex(ApplicationService.NS_ROOMS, room_id))",
            "",
            "    def is_exclusive_user(self, user_id: str) -> bool:",
            "        return (",
            "            self._is_exclusive(ApplicationService.NS_USERS, user_id)",
            "            or user_id == self.sender",
            "        )",
            "",
            "    def is_interested_in_protocol(self, protocol: str) -> bool:",
            "        return protocol in self.protocols",
            "",
            "    def is_exclusive_alias(self, alias: str) -> bool:",
            "        return self._is_exclusive(ApplicationService.NS_ALIASES, alias)",
            "",
            "    def is_exclusive_room(self, room_id: str) -> bool:",
            "        return self._is_exclusive(ApplicationService.NS_ROOMS, room_id)",
            "",
            "    def get_exclusive_user_regexes(self) -> List[Pattern[str]]:",
            "        \"\"\"Get the list of regexes used to determine if a user is exclusively",
            "        registered by the AS",
            "        \"\"\"",
            "        return [",
            "            namespace.regex",
            "            for namespace in self.namespaces[ApplicationService.NS_USERS]",
            "            if namespace.exclusive",
            "        ]",
            "",
            "    def is_rate_limited(self) -> bool:",
            "        return self.rate_limited",
            "",
            "    def __str__(self) -> str:",
            "        # copy dictionary and redact token fields so they don't get logged",
            "        dict_copy = self.__dict__.copy()",
            "        dict_copy[\"token\"] = \"<redacted>\"",
            "        dict_copy[\"hs_token\"] = \"<redacted>\"",
            "        return \"ApplicationService: %s\" % (dict_copy,)",
            "",
            "",
            "class AppServiceTransaction:",
            "    \"\"\"Represents an application service transaction.\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        service: ApplicationService,",
            "        id: int,",
            "        events: Sequence[EventBase],",
            "        ephemeral: List[JsonDict],",
            "        to_device_messages: List[JsonDict],",
            "        one_time_keys_count: TransactionOneTimeKeysCount,",
            "        unused_fallback_keys: TransactionUnusedFallbackKeys,",
            "        device_list_summary: DeviceListUpdates,",
            "    ):",
            "        self.service = service",
            "        self.id = id",
            "        self.events = events",
            "        self.ephemeral = ephemeral",
            "        self.to_device_messages = to_device_messages",
            "        self.one_time_keys_count = one_time_keys_count",
            "        self.unused_fallback_keys = unused_fallback_keys",
            "        self.device_list_summary = device_list_summary",
            "",
            "    async def send(self, as_api: \"ApplicationServiceApi\") -> bool:",
            "        \"\"\"Sends this transaction using the provided AS API interface.",
            "",
            "        Args:",
            "            as_api: The API to use to send.",
            "        Returns:",
            "            True if the transaction was sent.",
            "        \"\"\"",
            "        return await as_api.push_bulk(",
            "            service=self.service,",
            "            events=self.events,",
            "            ephemeral=self.ephemeral,",
            "            to_device_messages=self.to_device_messages,",
            "            one_time_keys_count=self.one_time_keys_count,",
            "            unused_fallback_keys=self.unused_fallback_keys,",
            "            device_list_summary=self.device_list_summary,",
            "            txn_id=self.id,",
            "        )",
            "",
            "    async def complete(self, store: \"DataStore\") -> None:",
            "        \"\"\"Completes this transaction as successful.",
            "",
            "        Marks this transaction ID on the application service and removes the",
            "        transaction contents from the database.",
            "",
            "        Args:",
            "            store: The database store to operate on.",
            "        \"\"\"",
            "        await store.complete_appservice_txn(service=self.service, txn_id=self.id)"
        ],
        "afterPatchFile": [
            "# Copyright 2015, 2016 OpenMarket Ltd",
            "# Copyright 2022 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import logging",
            "import re",
            "from enum import Enum",
            "from typing import TYPE_CHECKING, Dict, Iterable, List, Optional, Pattern, Sequence",
            "",
            "import attr",
            "from netaddr import IPSet",
            "",
            "from synapse.api.constants import EventTypes",
            "from synapse.events import EventBase",
            "from synapse.types import DeviceListUpdates, JsonDict, UserID",
            "from synapse.util.caches.descriptors import _CacheContext, cached",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.appservice.api import ApplicationServiceApi",
            "    from synapse.storage.databases.main import DataStore",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "# Type for the `device_one_time_keys_count` field in an appservice transaction",
            "#   user ID -> {device ID -> {algorithm -> count}}",
            "TransactionOneTimeKeysCount = Dict[str, Dict[str, Dict[str, int]]]",
            "",
            "# Type for the `device_unused_fallback_key_types` field in an appservice transaction",
            "#   user ID -> {device ID -> [algorithm]}",
            "TransactionUnusedFallbackKeys = Dict[str, Dict[str, List[str]]]",
            "",
            "",
            "class ApplicationServiceState(Enum):",
            "    DOWN = \"down\"",
            "    UP = \"up\"",
            "",
            "",
            "@attr.s(slots=True, frozen=True, auto_attribs=True)",
            "class Namespace:",
            "    exclusive: bool",
            "    regex: Pattern[str]",
            "",
            "",
            "class ApplicationService:",
            "    \"\"\"Defines an application service. This definition is mostly what is",
            "    provided to the /register AS API.",
            "",
            "    Provides methods to check if this service is \"interested\" in events.",
            "    \"\"\"",
            "",
            "    NS_USERS = \"users\"",
            "    NS_ALIASES = \"aliases\"",
            "    NS_ROOMS = \"rooms\"",
            "    # The ordering here is important as it is used to map database values (which",
            "    # are stored as ints representing the position in this list) to namespace",
            "    # values.",
            "    NS_LIST = [NS_USERS, NS_ALIASES, NS_ROOMS]",
            "",
            "    def __init__(",
            "        self,",
            "        token: str,",
            "        id: str,",
            "        sender: str,",
            "        url: Optional[str] = None,",
            "        namespaces: Optional[JsonDict] = None,",
            "        hs_token: Optional[str] = None,",
            "        protocols: Optional[Iterable[str]] = None,",
            "        rate_limited: bool = True,",
            "        ip_range_whitelist: Optional[IPSet] = None,",
            "        supports_ephemeral: bool = False,",
            "        msc3202_transaction_extensions: bool = False,",
            "    ):",
            "        self.token = token",
            "        self.url = (",
            "            url.rstrip(\"/\") if isinstance(url, str) else None",
            "        )  # url must not end with a slash",
            "        self.hs_token = hs_token",
            "        # The full Matrix ID for this application service's sender.",
            "        self.sender = sender",
            "        self.namespaces = self._check_namespaces(namespaces)",
            "        self.id = id",
            "        self.ip_range_whitelist = ip_range_whitelist",
            "        self.supports_ephemeral = supports_ephemeral",
            "        self.msc3202_transaction_extensions = msc3202_transaction_extensions",
            "",
            "        if \"|\" in self.id:",
            "            raise Exception(\"application service ID cannot contain '|' character\")",
            "",
            "        # .protocols is a publicly visible field",
            "        if protocols:",
            "            self.protocols = set(protocols)",
            "        else:",
            "            self.protocols = set()",
            "",
            "        self.rate_limited = rate_limited",
            "",
            "    def _check_namespaces(",
            "        self, namespaces: Optional[JsonDict]",
            "    ) -> Dict[str, List[Namespace]]:",
            "        # Sanity check that it is of the form:",
            "        # {",
            "        #   users: [ {regex: \"[A-z]+.*\", exclusive: true}, ...],",
            "        #   aliases: [ {regex: \"[A-z]+.*\", exclusive: true}, ...],",
            "        #   rooms: [ {regex: \"[A-z]+.*\", exclusive: true}, ...],",
            "        # }",
            "        if namespaces is None:",
            "            namespaces = {}",
            "",
            "        result: Dict[str, List[Namespace]] = {}",
            "",
            "        for ns in ApplicationService.NS_LIST:",
            "            result[ns] = []",
            "",
            "            if ns not in namespaces:",
            "                continue",
            "",
            "            if not isinstance(namespaces[ns], list):",
            "                raise ValueError(\"Bad namespace value for '%s'\" % ns)",
            "            for regex_obj in namespaces[ns]:",
            "                if not isinstance(regex_obj, dict):",
            "                    raise ValueError(\"Expected dict regex for ns '%s'\" % ns)",
            "                exclusive = regex_obj.get(\"exclusive\")",
            "                if not isinstance(exclusive, bool):",
            "                    raise ValueError(\"Expected bool for 'exclusive' in ns '%s'\" % ns)",
            "",
            "                regex = regex_obj.get(\"regex\")",
            "                if not isinstance(regex, str):",
            "                    raise ValueError(\"Expected string for 'regex' in ns '%s'\" % ns)",
            "",
            "                # Pre-compile regex.",
            "                result[ns].append(Namespace(exclusive, re.compile(regex)))",
            "",
            "        return result",
            "",
            "    def _matches_regex(",
            "        self, namespace_key: str, test_string: str",
            "    ) -> Optional[Namespace]:",
            "        for namespace in self.namespaces[namespace_key]:",
            "            if namespace.regex.match(test_string):",
            "                return namespace",
            "        return None",
            "",
            "    def _is_exclusive(self, namespace_key: str, test_string: str) -> bool:",
            "        namespace = self._matches_regex(namespace_key, test_string)",
            "        if namespace:",
            "            return namespace.exclusive",
            "        return False",
            "",
            "    @cached(num_args=1, cache_context=True)",
            "    async def _matches_user_in_member_list(",
            "        self,",
            "        room_id: str,",
            "        store: \"DataStore\",",
            "        cache_context: _CacheContext,",
            "    ) -> bool:",
            "        \"\"\"Check if this service is interested a room based upon its membership",
            "",
            "        Args:",
            "            room_id: The room to check.",
            "            store: The datastore to query.",
            "",
            "        Returns:",
            "            True if this service would like to know about this room.",
            "        \"\"\"",
            "        # We can use `get_local_users_in_room(...)` here because an application service",
            "        # can only be interested in local users of the server it's on (ignore any remote",
            "        # users that might match the user namespace regex).",
            "        #",
            "        # In the future, we can consider re-using",
            "        # `store.get_app_service_users_in_room` which is very similar to this",
            "        # function but has a slightly worse performance than this because we",
            "        # have an early escape-hatch if we find a single user that the",
            "        # appservice is interested in. The juice would be worth the squeeze if",
            "        # `store.get_app_service_users_in_room` was used in more places besides",
            "        # an experimental MSC. But for now we can avoid doing more work and",
            "        # barely using it later.",
            "        local_user_ids = await store.get_local_users_in_room(",
            "            room_id, on_invalidate=cache_context.invalidate",
            "        )",
            "",
            "        # check joined member events",
            "        for user_id in local_user_ids:",
            "            if self.is_interested_in_user(user_id):",
            "                return True",
            "        return False",
            "",
            "    def is_interested_in_user(",
            "        self,",
            "        user_id: str,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Returns whether the application is interested in a given user ID.",
            "",
            "        The appservice is considered to be interested in a user if either: the",
            "        user ID is in the appservice's user namespace, or if the user is the",
            "        appservice's configured sender_localpart.",
            "",
            "        Args:",
            "            user_id: The ID of the user to check.",
            "",
            "        Returns:",
            "            True if the application service is interested in the user, False if not.",
            "        \"\"\"",
            "        return (",
            "            # User is the appservice's configured sender_localpart user",
            "            user_id == self.sender",
            "            # User is in the appservice's user namespace",
            "            or self.is_user_in_namespace(user_id)",
            "        )",
            "",
            "    @cached(num_args=1, cache_context=True)",
            "    async def is_interested_in_room(",
            "        self,",
            "        room_id: str,",
            "        store: \"DataStore\",",
            "        cache_context: _CacheContext,",
            "    ) -> bool:",
            "        \"\"\"",
            "        Returns whether the application service is interested in a given room ID.",
            "",
            "        The appservice is considered to be interested in the room if either: the ID or one",
            "        of the aliases of the room is in the appservice's room ID or alias namespace",
            "        respectively, or if one of the members of the room fall into the appservice's user",
            "        namespace.",
            "",
            "        Args:",
            "            room_id: The ID of the room to check.",
            "            store: The homeserver's datastore class.",
            "",
            "        Returns:",
            "            True if the application service is interested in the room, False if not.",
            "        \"\"\"",
            "        # Check if we have interest in this room ID",
            "        if self.is_room_id_in_namespace(room_id):",
            "            return True",
            "",
            "        # likewise with the room's aliases (if it has any)",
            "        alias_list = await store.get_aliases_for_room(",
            "            room_id, on_invalidate=cache_context.invalidate",
            "        )",
            "        for alias in alias_list:",
            "            if self.is_room_alias_in_namespace(alias):",
            "                return True",
            "",
            "        # And finally, perform an expensive check on whether any of the",
            "        # users in the room match the appservice's user namespace",
            "        return await self._matches_user_in_member_list(",
            "            room_id, store, on_invalidate=cache_context.invalidate",
            "        )",
            "",
            "    @cached(num_args=1, cache_context=True)",
            "    async def is_interested_in_event(",
            "        self,",
            "        event_id: str,",
            "        event: EventBase,",
            "        store: \"DataStore\",",
            "        cache_context: _CacheContext,",
            "    ) -> bool:",
            "        \"\"\"Check if this service is interested in this event.",
            "",
            "        Args:",
            "            event_id: The ID of the event to check. This is purely used for simplifying the",
            "                caching of calls to this method.",
            "            event: The event to check.",
            "            store: The datastore to query.",
            "",
            "        Returns:",
            "            True if this service would like to know about this event, otherwise False.",
            "        \"\"\"",
            "        # Check if we're interested in this event's sender by namespace (or if they're the",
            "        # sender_localpart user)",
            "        if self.is_interested_in_user(event.sender):",
            "            return True",
            "",
            "        # additionally, if this is a membership event, perform the same checks on",
            "        # the user it references",
            "        if event.type == EventTypes.Member and self.is_interested_in_user(",
            "            event.state_key",
            "        ):",
            "            return True",
            "",
            "        # This will check the datastore, so should be run last",
            "        if await self.is_interested_in_room(",
            "            event.room_id, store, on_invalidate=cache_context.invalidate",
            "        ):",
            "            return True",
            "",
            "        return False",
            "",
            "    @cached(num_args=1, cache_context=True)",
            "    async def is_interested_in_presence(",
            "        self, user_id: UserID, store: \"DataStore\", cache_context: _CacheContext",
            "    ) -> bool:",
            "        \"\"\"Check if this service is interested a user's presence",
            "",
            "        Args:",
            "            user_id: The user to check.",
            "            store: The datastore to query.",
            "",
            "        Returns:",
            "            True if this service would like to know about presence for this user.",
            "        \"\"\"",
            "        # Find all the rooms the sender is in",
            "        if self.is_interested_in_user(user_id.to_string()):",
            "            return True",
            "        room_ids = await store.get_rooms_for_user(",
            "            user_id.to_string(), on_invalidate=cache_context.invalidate",
            "        )",
            "",
            "        # Then find out if the appservice is interested in any of those rooms",
            "        for room_id in room_ids:",
            "            if await self.is_interested_in_room(",
            "                room_id, store, on_invalidate=cache_context.invalidate",
            "            ):",
            "                return True",
            "        return False",
            "",
            "    def is_user_in_namespace(self, user_id: str) -> bool:",
            "        return bool(self._matches_regex(ApplicationService.NS_USERS, user_id))",
            "",
            "    def is_room_alias_in_namespace(self, alias: str) -> bool:",
            "        return bool(self._matches_regex(ApplicationService.NS_ALIASES, alias))",
            "",
            "    def is_room_id_in_namespace(self, room_id: str) -> bool:",
            "        return bool(self._matches_regex(ApplicationService.NS_ROOMS, room_id))",
            "",
            "    def is_exclusive_user(self, user_id: str) -> bool:",
            "        return (",
            "            self._is_exclusive(ApplicationService.NS_USERS, user_id)",
            "            or user_id == self.sender",
            "        )",
            "",
            "    def is_interested_in_protocol(self, protocol: str) -> bool:",
            "        return protocol in self.protocols",
            "",
            "    def is_exclusive_alias(self, alias: str) -> bool:",
            "        return self._is_exclusive(ApplicationService.NS_ALIASES, alias)",
            "",
            "    def is_exclusive_room(self, room_id: str) -> bool:",
            "        return self._is_exclusive(ApplicationService.NS_ROOMS, room_id)",
            "",
            "    def get_exclusive_user_regexes(self) -> List[Pattern[str]]:",
            "        \"\"\"Get the list of regexes used to determine if a user is exclusively",
            "        registered by the AS",
            "        \"\"\"",
            "        return [",
            "            namespace.regex",
            "            for namespace in self.namespaces[ApplicationService.NS_USERS]",
            "            if namespace.exclusive",
            "        ]",
            "",
            "    def is_rate_limited(self) -> bool:",
            "        return self.rate_limited",
            "",
            "    def __str__(self) -> str:",
            "        # copy dictionary and redact token fields so they don't get logged",
            "        dict_copy = self.__dict__.copy()",
            "        dict_copy[\"token\"] = \"<redacted>\"",
            "        dict_copy[\"hs_token\"] = \"<redacted>\"",
            "        return \"ApplicationService: %s\" % (dict_copy,)",
            "",
            "",
            "class AppServiceTransaction:",
            "    \"\"\"Represents an application service transaction.\"\"\"",
            "",
            "    def __init__(",
            "        self,",
            "        service: ApplicationService,",
            "        id: int,",
            "        events: Sequence[EventBase],",
            "        ephemeral: List[JsonDict],",
            "        to_device_messages: List[JsonDict],",
            "        one_time_keys_count: TransactionOneTimeKeysCount,",
            "        unused_fallback_keys: TransactionUnusedFallbackKeys,",
            "        device_list_summary: DeviceListUpdates,",
            "    ):",
            "        self.service = service",
            "        self.id = id",
            "        self.events = events",
            "        self.ephemeral = ephemeral",
            "        self.to_device_messages = to_device_messages",
            "        self.one_time_keys_count = one_time_keys_count",
            "        self.unused_fallback_keys = unused_fallback_keys",
            "        self.device_list_summary = device_list_summary",
            "",
            "    async def send(self, as_api: \"ApplicationServiceApi\") -> bool:",
            "        \"\"\"Sends this transaction using the provided AS API interface.",
            "",
            "        Args:",
            "            as_api: The API to use to send.",
            "        Returns:",
            "            True if the transaction was sent.",
            "        \"\"\"",
            "        return await as_api.push_bulk(",
            "            service=self.service,",
            "            events=self.events,",
            "            ephemeral=self.ephemeral,",
            "            to_device_messages=self.to_device_messages,",
            "            one_time_keys_count=self.one_time_keys_count,",
            "            unused_fallback_keys=self.unused_fallback_keys,",
            "            device_list_summary=self.device_list_summary,",
            "            txn_id=self.id,",
            "        )",
            "",
            "    async def complete(self, store: \"DataStore\") -> None:",
            "        \"\"\"Completes this transaction as successful.",
            "",
            "        Marks this transaction ID on the application service and removes the",
            "        transaction contents from the database.",
            "",
            "        Args:",
            "            store: The database store to operate on.",
            "        \"\"\"",
            "        await store.complete_appservice_txn(service=self.service, txn_id=self.id)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "215": [
                "ApplicationService",
                "is_interested_in_user"
            ]
        },
        "addLocation": [
            "synapse.appservice.ApplicationService",
            "asyncua.server.internal_session"
        ]
    },
    "synapse/handlers/auth.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 52,
                "PatchRowcode": "     NotFoundError,"
            },
            "1": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 53,
                "PatchRowcode": "     StoreError,"
            },
            "2": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": "     SynapseError,"
            },
            "3": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    UserDeactivatedError,"
            },
            "4": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " )"
            },
            "5": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " from synapse.api.ratelimiting import Ratelimiter"
            },
            "6": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " from synapse.handlers.ui_auth import ("
            },
            "7": {
                "beforePatchRowNumber": 1419,
                "afterPatchRowNumber": 1418,
                "PatchRowcode": "             return None"
            },
            "8": {
                "beforePatchRowNumber": 1420,
                "afterPatchRowNumber": 1419,
                "PatchRowcode": "         (user_id, password_hash) = lookupres"
            },
            "9": {
                "beforePatchRowNumber": 1421,
                "afterPatchRowNumber": 1420,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 1422,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # If the password hash is None, the account has likely been deactivated"
            },
            "11": {
                "beforePatchRowNumber": 1423,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not password_hash:"
            },
            "12": {
                "beforePatchRowNumber": 1424,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            deactivated = await self.store.get_user_deactivated_status(user_id)"
            },
            "13": {
                "beforePatchRowNumber": 1425,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if deactivated:"
            },
            "14": {
                "beforePatchRowNumber": 1426,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                raise UserDeactivatedError(\"This account has been deactivated\")"
            },
            "15": {
                "beforePatchRowNumber": 1427,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "16": {
                "beforePatchRowNumber": 1428,
                "afterPatchRowNumber": 1421,
                "PatchRowcode": "         result = await self.validate_hash(password, password_hash)"
            },
            "17": {
                "beforePatchRowNumber": 1429,
                "afterPatchRowNumber": 1422,
                "PatchRowcode": "         if not result:"
            },
            "18": {
                "beforePatchRowNumber": 1430,
                "afterPatchRowNumber": 1423,
                "PatchRowcode": "             logger.warning(\"Failed password login for user %s\", user_id)"
            },
            "19": {
                "beforePatchRowNumber": 1749,
                "afterPatchRowNumber": 1742,
                "PatchRowcode": "                 registered."
            },
            "20": {
                "beforePatchRowNumber": 1750,
                "afterPatchRowNumber": 1743,
                "PatchRowcode": "             auth_provider_session_id: The session ID from the SSO IdP received during login."
            },
            "21": {
                "beforePatchRowNumber": 1751,
                "afterPatchRowNumber": 1744,
                "PatchRowcode": "         \"\"\""
            },
            "22": {
                "beforePatchRowNumber": 1752,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # If the account has been deactivated, do not proceed with the login"
            },
            "23": {
                "beforePatchRowNumber": 1753,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # flow."
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1745,
                "PatchRowcode": "+        # If the account has been deactivated, do not proceed with the login."
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1746,
                "PatchRowcode": "+        #"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1747,
                "PatchRowcode": "+        # This gets checked again when the token is submitted but this lets us"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1748,
                "PatchRowcode": "+        # provide an HTML error page to the user (instead of issuing a token and"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1749,
                "PatchRowcode": "+        # having it error later)."
            },
            "29": {
                "beforePatchRowNumber": 1754,
                "afterPatchRowNumber": 1750,
                "PatchRowcode": "         deactivated = await self.store.get_user_deactivated_status(registered_user_id)"
            },
            "30": {
                "beforePatchRowNumber": 1755,
                "afterPatchRowNumber": 1751,
                "PatchRowcode": "         if deactivated:"
            },
            "31": {
                "beforePatchRowNumber": 1756,
                "afterPatchRowNumber": 1752,
                "PatchRowcode": "             respond_with_html(request, 403, self._sso_account_deactivated_template)"
            }
        },
        "frontPatchFile": [
            "# Copyright 2014 - 2016 OpenMarket Ltd",
            "# Copyright 2017 Vector Creations Ltd",
            "# Copyright 2019 - 2020 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "import logging",
            "import time",
            "import unicodedata",
            "import urllib.parse",
            "from binascii import crc32",
            "from http import HTTPStatus",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    Awaitable,",
            "    Callable,",
            "    Dict,",
            "    Iterable,",
            "    List,",
            "    Mapping,",
            "    Optional,",
            "    Tuple,",
            "    Type,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "import attr",
            "import bcrypt",
            "import unpaddedbase64",
            "from prometheus_client import Counter",
            "",
            "from twisted.internet.defer import CancelledError",
            "from twisted.web.server import Request",
            "",
            "from synapse.api.constants import LoginType",
            "from synapse.api.errors import (",
            "    AuthError,",
            "    Codes,",
            "    InteractiveAuthIncompleteError,",
            "    LoginError,",
            "    NotFoundError,",
            "    StoreError,",
            "    SynapseError,",
            "    UserDeactivatedError,",
            ")",
            "from synapse.api.ratelimiting import Ratelimiter",
            "from synapse.handlers.ui_auth import (",
            "    INTERACTIVE_AUTH_CHECKERS,",
            "    UIAuthSessionDataConstants,",
            ")",
            "from synapse.handlers.ui_auth.checkers import UserInteractiveAuthChecker",
            "from synapse.http import get_request_user_agent",
            "from synapse.http.server import finish_request, respond_with_html",
            "from synapse.http.site import SynapseRequest",
            "from synapse.logging.context import defer_to_thread",
            "from synapse.metrics.background_process_metrics import run_as_background_process",
            "from synapse.storage.databases.main.registration import (",
            "    LoginTokenExpired,",
            "    LoginTokenLookupResult,",
            "    LoginTokenReused,",
            ")",
            "from synapse.types import JsonDict, Requester, UserID",
            "from synapse.util import stringutils as stringutils",
            "from synapse.util.async_helpers import delay_cancellation, maybe_awaitable",
            "from synapse.util.msisdn import phone_number_to_msisdn",
            "from synapse.util.stringutils import base62_encode",
            "from synapse.util.threepids import canonicalise_email",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.module_api import ModuleApi",
            "    from synapse.rest.client.login import LoginResponse",
            "    from synapse.server import HomeServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "INVALID_USERNAME_OR_PASSWORD = \"Invalid username or password\"",
            "",
            "invalid_login_token_counter = Counter(",
            "    \"synapse_user_login_invalid_login_tokens\",",
            "    \"Counts the number of rejected m.login.token on /login\",",
            "    [\"reason\"],",
            ")",
            "",
            "",
            "def convert_client_dict_legacy_fields_to_identifier(",
            "    submission: JsonDict,",
            ") -> Dict[str, str]:",
            "    \"\"\"",
            "    Convert a legacy-formatted login submission to an identifier dict.",
            "",
            "    Legacy login submissions (used in both login and user-interactive authentication)",
            "    provide user-identifying information at the top-level instead.",
            "",
            "    These are now deprecated and replaced with identifiers:",
            "    https://matrix.org/docs/spec/client_server/r0.6.1#identifier-types",
            "",
            "    Args:",
            "        submission: The client dict to convert",
            "",
            "    Returns:",
            "        The matching identifier dict",
            "",
            "    Raises:",
            "        SynapseError: If the format of the client dict is invalid",
            "    \"\"\"",
            "    identifier = submission.get(\"identifier\", {})",
            "",
            "    # Generate an m.id.user identifier if \"user\" parameter is present",
            "    user = submission.get(\"user\")",
            "    if user:",
            "        identifier = {\"type\": \"m.id.user\", \"user\": user}",
            "",
            "    # Generate an m.id.thirdparty identifier if \"medium\" and \"address\" parameters are present",
            "    medium = submission.get(\"medium\")",
            "    address = submission.get(\"address\")",
            "    if medium and address:",
            "        identifier = {",
            "            \"type\": \"m.id.thirdparty\",",
            "            \"medium\": medium,",
            "            \"address\": address,",
            "        }",
            "",
            "    # We've converted valid, legacy login submissions to an identifier. If the",
            "    # submission still doesn't have an identifier, it's invalid",
            "    if not identifier:",
            "        raise SynapseError(400, \"Invalid login submission\", Codes.INVALID_PARAM)",
            "",
            "    # Ensure the identifier has a type",
            "    if \"type\" not in identifier:",
            "        raise SynapseError(",
            "            400,",
            "            \"'identifier' dict has no key 'type'\",",
            "            errcode=Codes.MISSING_PARAM,",
            "        )",
            "",
            "    return identifier",
            "",
            "",
            "def login_id_phone_to_thirdparty(identifier: JsonDict) -> Dict[str, str]:",
            "    \"\"\"",
            "    Convert a phone login identifier type to a generic threepid identifier.",
            "",
            "    Args:",
            "        identifier: Login identifier dict of type 'm.id.phone'",
            "",
            "    Returns:",
            "        An equivalent m.id.thirdparty identifier dict",
            "    \"\"\"",
            "    if \"country\" not in identifier or (",
            "        # The specification requires a \"phone\" field, while Synapse used to require a \"number\"",
            "        # field. Accept both for backwards compatibility.",
            "        \"phone\" not in identifier",
            "        and \"number\" not in identifier",
            "    ):",
            "        raise SynapseError(",
            "            400, \"Invalid phone-type identifier\", errcode=Codes.INVALID_PARAM",
            "        )",
            "",
            "    # Accept both \"phone\" and \"number\" as valid keys in m.id.phone",
            "    phone_number = identifier.get(\"phone\", identifier[\"number\"])",
            "",
            "    # Convert user-provided phone number to a consistent representation",
            "    msisdn = phone_number_to_msisdn(identifier[\"country\"], phone_number)",
            "",
            "    return {",
            "        \"type\": \"m.id.thirdparty\",",
            "        \"medium\": \"msisdn\",",
            "        \"address\": msisdn,",
            "    }",
            "",
            "",
            "@attr.s(slots=True, auto_attribs=True)",
            "class SsoLoginExtraAttributes:",
            "    \"\"\"Data we track about SAML2 sessions\"\"\"",
            "",
            "    # time the session was created, in milliseconds",
            "    creation_time: int",
            "    extra_attributes: JsonDict",
            "",
            "",
            "class AuthHandler:",
            "    SESSION_EXPIRE_MS = 48 * 60 * 60 * 1000",
            "",
            "    def __init__(self, hs: \"HomeServer\"):",
            "        self.store = hs.get_datastores().main",
            "        self.auth = hs.get_auth()",
            "        self.auth_blocking = hs.get_auth_blocking()",
            "        self.clock = hs.get_clock()",
            "        self.checkers: Dict[str, UserInteractiveAuthChecker] = {}",
            "        for auth_checker_class in INTERACTIVE_AUTH_CHECKERS:",
            "            inst = auth_checker_class(hs)",
            "            if inst.is_enabled():",
            "                self.checkers[inst.AUTH_TYPE] = inst",
            "",
            "        self.bcrypt_rounds = hs.config.registration.bcrypt_rounds",
            "",
            "        self.password_auth_provider = hs.get_password_auth_provider()",
            "",
            "        self.hs = hs  # FIXME better possibility to access registrationHandler later?",
            "        self.macaroon_gen = hs.get_macaroon_generator()",
            "        self._password_enabled_for_login = hs.config.auth.password_enabled_for_login",
            "        self._password_enabled_for_reauth = hs.config.auth.password_enabled_for_reauth",
            "        self._password_localdb_enabled = hs.config.auth.password_localdb_enabled",
            "        self._third_party_rules = hs.get_module_api_callbacks().third_party_event_rules",
            "",
            "        # Ratelimiter for failed auth during UIA. Uses same ratelimit config",
            "        # as per `rc_login.failed_attempts`.",
            "        self._failed_uia_attempts_ratelimiter = Ratelimiter(",
            "            store=self.store,",
            "            clock=self.clock,",
            "            rate_hz=self.hs.config.ratelimiting.rc_login_failed_attempts.per_second,",
            "            burst_count=self.hs.config.ratelimiting.rc_login_failed_attempts.burst_count,",
            "        )",
            "",
            "        # The number of seconds to keep a UI auth session active.",
            "        self._ui_auth_session_timeout = hs.config.auth.ui_auth_session_timeout",
            "",
            "        # Ratelimitier for failed /login attempts",
            "        self._failed_login_attempts_ratelimiter = Ratelimiter(",
            "            store=self.store,",
            "            clock=hs.get_clock(),",
            "            rate_hz=self.hs.config.ratelimiting.rc_login_failed_attempts.per_second,",
            "            burst_count=self.hs.config.ratelimiting.rc_login_failed_attempts.burst_count,",
            "        )",
            "",
            "        self._clock = self.hs.get_clock()",
            "",
            "        # Expire old UI auth sessions after a period of time.",
            "        if hs.config.worker.run_background_tasks:",
            "            self._clock.looping_call(",
            "                run_as_background_process,",
            "                5 * 60 * 1000,",
            "                \"expire_old_sessions\",",
            "                self._expire_old_sessions,",
            "            )",
            "",
            "        # Load the SSO HTML templates.",
            "",
            "        # The following template is shown to the user during a client login via SSO,",
            "        # after the SSO completes and before redirecting them back to their client.",
            "        # It notifies the user they are about to give access to their matrix account",
            "        # to the client.",
            "        self._sso_redirect_confirm_template = (",
            "            hs.config.sso.sso_redirect_confirm_template",
            "        )",
            "",
            "        # The following template is shown during user interactive authentication",
            "        # in the fallback auth scenario. It notifies the user that they are",
            "        # authenticating for an operation to occur on their account.",
            "        self._sso_auth_confirm_template = hs.config.sso.sso_auth_confirm_template",
            "",
            "        # The following template is shown during the SSO authentication process if",
            "        # the account is deactivated.",
            "        self._sso_account_deactivated_template = (",
            "            hs.config.sso.sso_account_deactivated_template",
            "        )",
            "",
            "        self._server_name = hs.config.server.server_name",
            "",
            "        # cast to tuple for use with str.startswith",
            "        self._whitelisted_sso_clients = tuple(hs.config.sso.sso_client_whitelist)",
            "",
            "        # A mapping of user ID to extra attributes to include in the login",
            "        # response.",
            "        self._extra_attributes: Dict[str, SsoLoginExtraAttributes] = {}",
            "",
            "    async def validate_user_via_ui_auth(",
            "        self,",
            "        requester: Requester,",
            "        request: SynapseRequest,",
            "        request_body: Dict[str, Any],",
            "        description: str,",
            "        can_skip_ui_auth: bool = False,",
            "    ) -> Tuple[dict, Optional[str]]:",
            "        \"\"\"",
            "        Checks that the user is who they claim to be, via a UI auth.",
            "",
            "        This is used for things like device deletion and password reset where",
            "        the user already has a valid access token, but we want to double-check",
            "        that it isn't stolen by re-authenticating them.",
            "",
            "        Args:",
            "            requester: The user making the request, according to the access token.",
            "",
            "            request: The request sent by the client.",
            "",
            "            request_body: The body of the request sent by the client",
            "",
            "            description: A human readable string to be displayed to the user that",
            "                         describes the operation happening on their account.",
            "",
            "            can_skip_ui_auth: True if the UI auth session timeout applies this",
            "                              action. Should be set to False for any \"dangerous\"",
            "                              actions (e.g. deactivating an account).",
            "",
            "        Returns:",
            "            A tuple of (params, session_id).",
            "",
            "                'params' contains the parameters for this request (which may",
            "                have been given only in a previous call).",
            "",
            "                'session_id' is the ID of this session, either passed in by the",
            "                client or assigned by this call. This is None if UI auth was",
            "                skipped (by re-using a previous validation).",
            "",
            "        Raises:",
            "            InteractiveAuthIncompleteError if the client has not yet completed",
            "                any of the permitted login flows",
            "",
            "            AuthError if the client has completed a login flow, and it gives",
            "                a different user to `requester`",
            "",
            "            LimitExceededError if the ratelimiter's failed request count for this",
            "                user is too high to proceed",
            "",
            "        \"\"\"",
            "        if not requester.access_token_id:",
            "            raise ValueError(\"Cannot validate a user without an access token\")",
            "        if can_skip_ui_auth and self._ui_auth_session_timeout:",
            "            last_validated = await self.store.get_access_token_last_validated(",
            "                requester.access_token_id",
            "            )",
            "            if self.clock.time_msec() - last_validated < self._ui_auth_session_timeout:",
            "                # Return the input parameters, minus the auth key, which matches",
            "                # the logic in check_ui_auth.",
            "                request_body.pop(\"auth\", None)",
            "                return request_body, None",
            "",
            "        requester_user_id = requester.user.to_string()",
            "",
            "        # Check if we should be ratelimited due to too many previous failed attempts",
            "        await self._failed_uia_attempts_ratelimiter.ratelimit(requester, update=False)",
            "",
            "        # build a list of supported flows",
            "        supported_ui_auth_types = await self._get_available_ui_auth_types(",
            "            requester.user",
            "        )",
            "        flows = [[login_type] for login_type in supported_ui_auth_types]",
            "",
            "        def get_new_session_data() -> JsonDict:",
            "            return {UIAuthSessionDataConstants.REQUEST_USER_ID: requester_user_id}",
            "",
            "        try:",
            "            result, params, session_id = await self.check_ui_auth(",
            "                flows,",
            "                request,",
            "                request_body,",
            "                description,",
            "                get_new_session_data,",
            "            )",
            "        except LoginError:",
            "            # Update the ratelimiter to say we failed (`can_do_action` doesn't raise).",
            "            await self._failed_uia_attempts_ratelimiter.can_do_action(",
            "                requester,",
            "            )",
            "            raise",
            "",
            "        # find the completed login type",
            "        for login_type in supported_ui_auth_types:",
            "            if login_type not in result:",
            "                continue",
            "",
            "            validated_user_id = result[login_type]",
            "            break",
            "        else:",
            "            # this can't happen",
            "            raise Exception(\"check_auth returned True but no successful login type\")",
            "",
            "        # check that the UI auth matched the access token",
            "        if validated_user_id != requester_user_id:",
            "            raise AuthError(403, \"Invalid auth\")",
            "",
            "        # Note that the access token has been validated.",
            "        await self.store.update_access_token_last_validated(requester.access_token_id)",
            "",
            "        return params, session_id",
            "",
            "    async def _get_available_ui_auth_types(self, user: UserID) -> Iterable[str]:",
            "        \"\"\"Get a list of the user-interactive authentication types this user can use.\"\"\"",
            "",
            "        ui_auth_types = set()",
            "",
            "        # if the HS supports password auth, and the user has a non-null password, we",
            "        # support password auth",
            "        if self._password_localdb_enabled and self._password_enabled_for_reauth:",
            "            lookupres = await self._find_user_id_and_pwd_hash(user.to_string())",
            "            if lookupres:",
            "                _, password_hash = lookupres",
            "                if password_hash:",
            "                    ui_auth_types.add(LoginType.PASSWORD)",
            "",
            "        # also allow auth from password providers",
            "        for t in self.password_auth_provider.get_supported_login_types().keys():",
            "            if t == LoginType.PASSWORD and not self._password_enabled_for_reauth:",
            "                continue",
            "            ui_auth_types.add(t)",
            "",
            "        # if sso is enabled, allow the user to log in via SSO iff they have a mapping",
            "        # from sso to mxid.",
            "        if await self.hs.get_sso_handler().get_identity_providers_for_user(",
            "            user.to_string()",
            "        ):",
            "            ui_auth_types.add(LoginType.SSO)",
            "",
            "        return ui_auth_types",
            "",
            "    def get_enabled_auth_types(self) -> Iterable[str]:",
            "        \"\"\"Return the enabled user-interactive authentication types",
            "",
            "        Returns the UI-Auth types which are supported by the homeserver's current",
            "        config.",
            "        \"\"\"",
            "        return self.checkers.keys()",
            "",
            "    async def check_ui_auth(",
            "        self,",
            "        flows: List[List[str]],",
            "        request: SynapseRequest,",
            "        clientdict: Dict[str, Any],",
            "        description: str,",
            "        get_new_session_data: Optional[Callable[[], JsonDict]] = None,",
            "    ) -> Tuple[dict, dict, str]:",
            "        \"\"\"",
            "        Takes a dictionary sent by the client in the login / registration",
            "        protocol and handles the User-Interactive Auth flow.",
            "",
            "        If no auth flows have been completed successfully, raises an",
            "        InteractiveAuthIncompleteError. To handle this, you can use",
            "        synapse.rest.client._base.interactive_auth_handler as a",
            "        decorator.",
            "",
            "        Args:",
            "            flows: A list of login flows. Each flow is an ordered list of",
            "                   strings representing auth-types. At least one full",
            "                   flow must be completed in order for auth to be successful.",
            "",
            "            request: The request sent by the client.",
            "",
            "            clientdict: The dictionary from the client root level, not the",
            "                        'auth' key: this method prompts for auth if none is sent.",
            "",
            "            description: A human readable string to be displayed to the user that",
            "                         describes the operation happening on their account.",
            "",
            "            get_new_session_data:",
            "                an optional callback which will be called when starting a new session.",
            "                it should return data to be stored as part of the session.",
            "",
            "                The keys of the returned data should be entries in",
            "                UIAuthSessionDataConstants.",
            "",
            "        Returns:",
            "            A tuple of (creds, params, session_id).",
            "",
            "                'creds' contains the authenticated credentials of each stage.",
            "",
            "                'params' contains the parameters for this request (which may",
            "                have been given only in a previous call).",
            "",
            "                'session_id' is the ID of this session, either passed in by the",
            "                client or assigned by this call",
            "",
            "        Raises:",
            "            InteractiveAuthIncompleteError if the client has not yet completed",
            "                all the stages in any of the permitted flows.",
            "        \"\"\"",
            "",
            "        sid: Optional[str] = None",
            "        authdict = clientdict.pop(\"auth\", {})",
            "        if \"session\" in authdict:",
            "            sid = authdict[\"session\"]",
            "",
            "        # Convert the URI and method to strings.",
            "        uri = request.uri.decode(\"utf-8\")",
            "        method = request.method.decode(\"utf-8\")",
            "",
            "        # If there's no session ID, create a new session.",
            "        if not sid:",
            "            new_session_data = get_new_session_data() if get_new_session_data else {}",
            "",
            "            session = await self.store.create_ui_auth_session(",
            "                clientdict, uri, method, description",
            "            )",
            "",
            "            for k, v in new_session_data.items():",
            "                await self.set_session_data(session.session_id, k, v)",
            "",
            "        else:",
            "            try:",
            "                session = await self.store.get_ui_auth_session(sid)",
            "            except StoreError:",
            "                raise SynapseError(400, \"Unknown session ID: %s\" % (sid,))",
            "",
            "            # If the client provides parameters, update what is persisted,",
            "            # otherwise use whatever was last provided.",
            "            #",
            "            # This was designed to allow the client to omit the parameters",
            "            # and just supply the session in subsequent calls so it split",
            "            # auth between devices by just sharing the session, (eg. so you",
            "            # could continue registration from your phone having clicked the",
            "            # email auth link on there). It's probably too open to abuse",
            "            # because it lets unauthenticated clients store arbitrary objects",
            "            # on a homeserver.",
            "            #",
            "            # Revisit: Assuming the REST APIs do sensible validation, the data",
            "            # isn't arbitrary.",
            "            #",
            "            # Note that the registration endpoint explicitly removes the",
            "            # \"initial_device_display_name\" parameter if it is provided",
            "            # without a \"password\" parameter. See the changes to",
            "            # synapse.rest.client.register.RegisterRestServlet.on_POST",
            "            # in commit 544722bad23fc31056b9240189c3cbbbf0ffd3f9.",
            "            if not clientdict:",
            "                clientdict = session.clientdict",
            "",
            "            # Ensure that the queried operation does not vary between stages of",
            "            # the UI authentication session. This is done by generating a stable",
            "            # comparator and storing it during the initial query. Subsequent",
            "            # queries ensure that this comparator has not changed.",
            "            #",
            "            # The comparator is based on the requested URI and HTTP method. The",
            "            # client dict (minus the auth dict) should also be checked, but some",
            "            # clients are not spec compliant, just warn for now if the client",
            "            # dict changes.",
            "            if (session.uri, session.method) != (uri, method):",
            "                raise SynapseError(",
            "                    403,",
            "                    \"Requested operation has changed during the UI authentication session.\",",
            "                )",
            "",
            "            if session.clientdict != clientdict:",
            "                logger.warning(",
            "                    \"Requested operation has changed during the UI \"",
            "                    \"authentication session. A future version of Synapse \"",
            "                    \"will remove this capability.\"",
            "                )",
            "",
            "            # For backwards compatibility, changes to the client dict are",
            "            # persisted as clients modify them throughout their user interactive",
            "            # authentication flow.",
            "            await self.store.set_ui_auth_clientdict(sid, clientdict)",
            "",
            "        user_agent = get_request_user_agent(request)",
            "        clientip = request.getClientAddress().host",
            "",
            "        await self.store.add_user_agent_ip_to_ui_auth_session(",
            "            session.session_id, user_agent, clientip",
            "        )",
            "",
            "        if not authdict:",
            "            raise InteractiveAuthIncompleteError(",
            "                session.session_id, self._auth_dict_for_flows(flows, session.session_id)",
            "            )",
            "",
            "        # check auth type currently being presented",
            "        errordict: Dict[str, Any] = {}",
            "        if \"type\" in authdict:",
            "            login_type: str = authdict[\"type\"]",
            "            try:",
            "                result = await self._check_auth_dict(authdict, clientip)",
            "                if result:",
            "                    await self.store.mark_ui_auth_stage_complete(",
            "                        session.session_id, login_type, result",
            "                    )",
            "            except LoginError as e:",
            "                # this step failed. Merge the error dict into the response",
            "                # so that the client can have another go.",
            "                errordict = e.error_dict(self.hs.config)",
            "",
            "        creds = await self.store.get_completed_ui_auth_stages(session.session_id)",
            "        for f in flows:",
            "            # If all the required credentials have been supplied, the user has",
            "            # successfully completed the UI auth process!",
            "            if len(set(f) - set(creds)) == 0:",
            "                # it's very useful to know what args are stored, but this can",
            "                # include the password in the case of registering, so only log",
            "                # the keys (confusingly, clientdict may contain a password",
            "                # param, creds is just what the user authed as for UI auth",
            "                # and is not sensitive).",
            "                logger.info(",
            "                    \"Auth completed with creds: %r. Client dict has keys: %r\",",
            "                    creds,",
            "                    list(clientdict),",
            "                )",
            "",
            "                return creds, clientdict, session.session_id",
            "",
            "        ret = self._auth_dict_for_flows(flows, session.session_id)",
            "        ret[\"completed\"] = list(creds)",
            "        ret.update(errordict)",
            "        raise InteractiveAuthIncompleteError(session.session_id, ret)",
            "",
            "    async def add_oob_auth(",
            "        self, stagetype: str, authdict: Dict[str, Any], clientip: str",
            "    ) -> None:",
            "        \"\"\"",
            "        Adds the result of out-of-band authentication into an existing auth",
            "        session. Currently used for adding the result of fallback auth.",
            "",
            "        Raises:",
            "            LoginError if the stagetype is unknown or the session is missing.",
            "            LoginError is raised by check_auth if authentication fails.",
            "        \"\"\"",
            "        if stagetype not in self.checkers:",
            "            raise LoginError(",
            "                400, f\"Unknown UIA stage type: {stagetype}\", Codes.INVALID_PARAM",
            "            )",
            "        if \"session\" not in authdict:",
            "            raise LoginError(400, \"Missing session ID\", Codes.MISSING_PARAM)",
            "",
            "        # If authentication fails a LoginError is raised. Otherwise, store",
            "        # the successful result.",
            "        result = await self.checkers[stagetype].check_auth(authdict, clientip)",
            "        await self.store.mark_ui_auth_stage_complete(",
            "            authdict[\"session\"], stagetype, result",
            "        )",
            "",
            "    def get_session_id(self, clientdict: Dict[str, Any]) -> Optional[str]:",
            "        \"\"\"",
            "        Gets the session ID for a client given the client dictionary",
            "",
            "        Args:",
            "            clientdict: The dictionary sent by the client in the request",
            "",
            "        Returns:",
            "            The string session ID the client sent. If the client did",
            "                not send a session ID, returns None.",
            "        \"\"\"",
            "        sid = None",
            "        if clientdict and \"auth\" in clientdict:",
            "            authdict = clientdict[\"auth\"]",
            "            if \"session\" in authdict:",
            "                sid = authdict[\"session\"]",
            "        return sid",
            "",
            "    async def set_session_data(self, session_id: str, key: str, value: Any) -> None:",
            "        \"\"\"",
            "        Store a key-value pair into the sessions data associated with this",
            "        request. This data is stored server-side and cannot be modified by",
            "        the client.",
            "",
            "        Args:",
            "            session_id: The ID of this session as returned from check_auth",
            "            key: The key to store the data under. An entry from",
            "                UIAuthSessionDataConstants.",
            "            value: The data to store",
            "        \"\"\"",
            "        try:",
            "            await self.store.set_ui_auth_session_data(session_id, key, value)",
            "        except StoreError:",
            "            raise SynapseError(400, \"Unknown session ID: %s\" % (session_id,))",
            "",
            "    async def get_session_data(",
            "        self, session_id: str, key: str, default: Optional[Any] = None",
            "    ) -> Any:",
            "        \"\"\"",
            "        Retrieve data stored with set_session_data",
            "",
            "        Args:",
            "            session_id: The ID of this session as returned from check_auth",
            "            key: The key the data was stored under. An entry from",
            "                UIAuthSessionDataConstants.",
            "            default: Value to return if the key has not been set",
            "        \"\"\"",
            "        try:",
            "            return await self.store.get_ui_auth_session_data(session_id, key, default)",
            "        except StoreError:",
            "            raise SynapseError(400, \"Unknown session ID: %s\" % (session_id,))",
            "",
            "    async def _expire_old_sessions(self) -> None:",
            "        \"\"\"",
            "        Invalidate any user interactive authentication sessions that have expired.",
            "        \"\"\"",
            "        now = self._clock.time_msec()",
            "        expiration_time = now - self.SESSION_EXPIRE_MS",
            "        await self.store.delete_old_ui_auth_sessions(expiration_time)",
            "",
            "    async def _check_auth_dict(",
            "        self, authdict: Dict[str, Any], clientip: str",
            "    ) -> Union[Dict[str, Any], str]:",
            "        \"\"\"Attempt to validate the auth dict provided by a client",
            "",
            "        Args:",
            "            authdict: auth dict provided by the client",
            "            clientip: IP address of the client",
            "",
            "        Returns:",
            "            Result of the stage verification.",
            "",
            "        Raises:",
            "            StoreError if there was a problem accessing the database",
            "            SynapseError if there was a problem with the request",
            "            LoginError if there was an authentication problem.",
            "        \"\"\"",
            "        login_type = authdict[\"type\"]",
            "        checker = self.checkers.get(login_type)",
            "        if checker is not None:",
            "            res = await checker.check_auth(authdict, clientip=clientip)",
            "            return res",
            "",
            "        # fall back to the v1 login flow",
            "        canonical_id, _ = await self.validate_login(authdict, is_reauth=True)",
            "        return canonical_id",
            "",
            "    def _get_params_recaptcha(self) -> dict:",
            "        return {\"public_key\": self.hs.config.captcha.recaptcha_public_key}",
            "",
            "    def _get_params_terms(self) -> dict:",
            "        return {",
            "            \"policies\": {",
            "                \"privacy_policy\": {",
            "                    \"version\": self.hs.config.consent.user_consent_version,",
            "                    \"en\": {",
            "                        \"name\": self.hs.config.consent.user_consent_policy_name,",
            "                        \"url\": \"%s_matrix/consent?v=%s\"",
            "                        % (",
            "                            self.hs.config.server.public_baseurl,",
            "                            self.hs.config.consent.user_consent_version,",
            "                        ),",
            "                    },",
            "                }",
            "            }",
            "        }",
            "",
            "    def _auth_dict_for_flows(",
            "        self,",
            "        flows: List[List[str]],",
            "        session_id: str,",
            "    ) -> Dict[str, Any]:",
            "        public_flows = []",
            "        for f in flows:",
            "            public_flows.append(f)",
            "",
            "        get_params = {",
            "            LoginType.RECAPTCHA: self._get_params_recaptcha,",
            "            LoginType.TERMS: self._get_params_terms,",
            "        }",
            "",
            "        params: Dict[str, Any] = {}",
            "",
            "        for f in public_flows:",
            "            for stage in f:",
            "                if stage in get_params and stage not in params:",
            "                    params[stage] = get_params[stage]()",
            "",
            "        return {",
            "            \"session\": session_id,",
            "            \"flows\": [{\"stages\": f} for f in public_flows],",
            "            \"params\": params,",
            "        }",
            "",
            "    async def refresh_token(",
            "        self,",
            "        refresh_token: str,",
            "        access_token_valid_until_ms: Optional[int],",
            "        refresh_token_valid_until_ms: Optional[int],",
            "    ) -> Tuple[str, str, Optional[int]]:",
            "        \"\"\"",
            "        Consumes a refresh token and generate both a new access token and a new refresh token from it.",
            "",
            "        The consumed refresh token is considered invalid after the first use of the new access token or the new refresh token.",
            "",
            "        The lifetime of both the access token and refresh token will be capped so that they",
            "        do not exceed the session's ultimate expiry time, if applicable.",
            "",
            "        Args:",
            "            refresh_token: The token to consume.",
            "            access_token_valid_until_ms: The expiration timestamp of the new access token.",
            "                None if the access token does not expire.",
            "            refresh_token_valid_until_ms: The expiration timestamp of the new refresh token.",
            "                None if the refresh token does not expire.",
            "        Returns:",
            "            A tuple containing:",
            "              - the new access token",
            "              - the new refresh token",
            "              - the actual expiry time of the access token, which may be earlier than",
            "                `access_token_valid_until_ms`.",
            "        \"\"\"",
            "",
            "        # Verify the token signature first before looking up the token",
            "        if not self._verify_refresh_token(refresh_token):",
            "            raise SynapseError(",
            "                HTTPStatus.UNAUTHORIZED, \"invalid refresh token\", Codes.UNKNOWN_TOKEN",
            "            )",
            "",
            "        existing_token = await self.store.lookup_refresh_token(refresh_token)",
            "        if existing_token is None:",
            "            raise SynapseError(",
            "                HTTPStatus.UNAUTHORIZED,",
            "                \"refresh token does not exist\",",
            "                Codes.UNKNOWN_TOKEN,",
            "            )",
            "",
            "        if (",
            "            existing_token.has_next_access_token_been_used",
            "            or existing_token.has_next_refresh_token_been_refreshed",
            "        ):",
            "            raise SynapseError(",
            "                HTTPStatus.FORBIDDEN,",
            "                \"refresh token isn't valid anymore\",",
            "                Codes.FORBIDDEN,",
            "            )",
            "",
            "        now_ms = self._clock.time_msec()",
            "",
            "        if existing_token.expiry_ts is not None and existing_token.expiry_ts < now_ms:",
            "            raise SynapseError(",
            "                HTTPStatus.FORBIDDEN,",
            "                \"The supplied refresh token has expired\",",
            "                Codes.FORBIDDEN,",
            "            )",
            "",
            "        if existing_token.ultimate_session_expiry_ts is not None:",
            "            # This session has a bounded lifetime, even across refreshes.",
            "",
            "            if access_token_valid_until_ms is not None:",
            "                access_token_valid_until_ms = min(",
            "                    access_token_valid_until_ms,",
            "                    existing_token.ultimate_session_expiry_ts,",
            "                )",
            "            else:",
            "                access_token_valid_until_ms = existing_token.ultimate_session_expiry_ts",
            "",
            "            if refresh_token_valid_until_ms is not None:",
            "                refresh_token_valid_until_ms = min(",
            "                    refresh_token_valid_until_ms,",
            "                    existing_token.ultimate_session_expiry_ts,",
            "                )",
            "            else:",
            "                refresh_token_valid_until_ms = existing_token.ultimate_session_expiry_ts",
            "            if existing_token.ultimate_session_expiry_ts < now_ms:",
            "                raise SynapseError(",
            "                    HTTPStatus.FORBIDDEN,",
            "                    \"The session has expired and can no longer be refreshed\",",
            "                    Codes.FORBIDDEN,",
            "                )",
            "",
            "        (",
            "            new_refresh_token,",
            "            new_refresh_token_id,",
            "        ) = await self.create_refresh_token_for_user_id(",
            "            user_id=existing_token.user_id,",
            "            device_id=existing_token.device_id,",
            "            expiry_ts=refresh_token_valid_until_ms,",
            "            ultimate_session_expiry_ts=existing_token.ultimate_session_expiry_ts,",
            "        )",
            "        access_token = await self.create_access_token_for_user_id(",
            "            user_id=existing_token.user_id,",
            "            device_id=existing_token.device_id,",
            "            valid_until_ms=access_token_valid_until_ms,",
            "            refresh_token_id=new_refresh_token_id,",
            "        )",
            "        await self.store.replace_refresh_token(",
            "            existing_token.token_id, new_refresh_token_id",
            "        )",
            "        return access_token, new_refresh_token, access_token_valid_until_ms",
            "",
            "    def _verify_refresh_token(self, token: str) -> bool:",
            "        \"\"\"",
            "        Verifies the shape of a refresh token.",
            "",
            "        Args:",
            "            token: The refresh token to verify",
            "",
            "        Returns:",
            "            Whether the token has the right shape",
            "        \"\"\"",
            "        parts = token.split(\"_\", maxsplit=4)",
            "        if len(parts) != 4:",
            "            return False",
            "",
            "        type, localpart, rand, crc = parts",
            "",
            "        # Refresh tokens are prefixed by \"syr_\", let's check that",
            "        if type != \"syr\":",
            "            return False",
            "",
            "        # Check the CRC",
            "        base = f\"{type}_{localpart}_{rand}\"",
            "        expected_crc = base62_encode(crc32(base.encode(\"ascii\")), minwidth=6)",
            "        if crc != expected_crc:",
            "            return False",
            "",
            "        return True",
            "",
            "    async def create_login_token_for_user_id(",
            "        self,",
            "        user_id: str,",
            "        duration_ms: int = (2 * 60 * 1000),",
            "        auth_provider_id: Optional[str] = None,",
            "        auth_provider_session_id: Optional[str] = None,",
            "    ) -> str:",
            "        login_token = self.generate_login_token()",
            "        now = self._clock.time_msec()",
            "        expiry_ts = now + duration_ms",
            "        await self.store.add_login_token_to_user(",
            "            user_id=user_id,",
            "            token=login_token,",
            "            expiry_ts=expiry_ts,",
            "            auth_provider_id=auth_provider_id,",
            "            auth_provider_session_id=auth_provider_session_id,",
            "        )",
            "        return login_token",
            "",
            "    async def create_refresh_token_for_user_id(",
            "        self,",
            "        user_id: str,",
            "        device_id: str,",
            "        expiry_ts: Optional[int],",
            "        ultimate_session_expiry_ts: Optional[int],",
            "    ) -> Tuple[str, int]:",
            "        \"\"\"",
            "        Creates a new refresh token for the user with the given user ID.",
            "",
            "        Args:",
            "            user_id: canonical user ID",
            "            device_id: the device ID to associate with the token.",
            "            expiry_ts (milliseconds since the epoch): Time after which the",
            "                refresh token cannot be used.",
            "                If None, the refresh token never expires until it has been used.",
            "            ultimate_session_expiry_ts (milliseconds since the epoch):",
            "                Time at which the session will end and can not be extended any",
            "                further.",
            "                If None, the session can be refreshed indefinitely.",
            "",
            "        Returns:",
            "            The newly created refresh token and its ID in the database",
            "        \"\"\"",
            "        refresh_token = self.generate_refresh_token(UserID.from_string(user_id))",
            "        refresh_token_id = await self.store.add_refresh_token_to_user(",
            "            user_id=user_id,",
            "            token=refresh_token,",
            "            device_id=device_id,",
            "            expiry_ts=expiry_ts,",
            "            ultimate_session_expiry_ts=ultimate_session_expiry_ts,",
            "        )",
            "        return refresh_token, refresh_token_id",
            "",
            "    async def create_access_token_for_user_id(",
            "        self,",
            "        user_id: str,",
            "        device_id: Optional[str],",
            "        valid_until_ms: Optional[int],",
            "        puppets_user_id: Optional[str] = None,",
            "        is_appservice_ghost: bool = False,",
            "        refresh_token_id: Optional[int] = None,",
            "    ) -> str:",
            "        \"\"\"",
            "        Creates a new access token for the user with the given user ID.",
            "",
            "        The user is assumed to have been authenticated by some other",
            "        mechanism (e.g. CAS), and the user_id converted to the canonical case.",
            "",
            "        The device will be recorded in the table if it is not there already.",
            "",
            "        Args:",
            "            user_id: canonical User ID",
            "            device_id: the device ID to associate with the tokens.",
            "               None to leave the tokens unassociated with a device (deprecated:",
            "               we should always have a device ID)",
            "            valid_until_ms: when the token is valid until. None for",
            "                no expiry.",
            "            is_appservice_ghost: Whether the user is an application ghost user",
            "            refresh_token_id: the refresh token ID that will be associated with",
            "                this access token.",
            "        Returns:",
            "              The access token for the user's session.",
            "        Raises:",
            "            StoreError if there was a problem storing the token.",
            "        \"\"\"",
            "        fmt_expiry = \"\"",
            "        if valid_until_ms is not None:",
            "            fmt_expiry = time.strftime(",
            "                \" until %Y-%m-%d %H:%M:%S\", time.localtime(valid_until_ms / 1000.0)",
            "            )",
            "",
            "        if puppets_user_id:",
            "            logger.info(",
            "                \"Logging in user %s as %s%s\", user_id, puppets_user_id, fmt_expiry",
            "            )",
            "            target_user_id_obj = UserID.from_string(puppets_user_id)",
            "        else:",
            "            logger.info(",
            "                \"Logging in user %s on device %s%s\", user_id, device_id, fmt_expiry",
            "            )",
            "            target_user_id_obj = UserID.from_string(user_id)",
            "",
            "        if (",
            "            not is_appservice_ghost",
            "            or self.hs.config.appservice.track_appservice_user_ips",
            "        ):",
            "            await self.auth_blocking.check_auth_blocking(user_id)",
            "",
            "        access_token = self.generate_access_token(target_user_id_obj)",
            "        await self.store.add_access_token_to_user(",
            "            user_id=user_id,",
            "            token=access_token,",
            "            device_id=device_id,",
            "            valid_until_ms=valid_until_ms,",
            "            puppets_user_id=puppets_user_id,",
            "            refresh_token_id=refresh_token_id,",
            "        )",
            "",
            "        # the device *should* have been registered before we got here; however,",
            "        # it's possible we raced against a DELETE operation. The thing we",
            "        # really don't want is active access_tokens without a record of the",
            "        # device, so we double-check it here.",
            "        if device_id is not None:",
            "            if await self.store.get_device(user_id, device_id) is None:",
            "                await self.store.delete_access_token(access_token)",
            "                raise StoreError(400, \"Login raced against device deletion\")",
            "",
            "        return access_token",
            "",
            "    async def check_user_exists(self, user_id: str) -> Optional[str]:",
            "        \"\"\"",
            "        Checks to see if a user with the given id exists. Will check case",
            "        insensitively, but return None if there are multiple inexact matches.",
            "",
            "        Args:",
            "            user_id: complete @user:id",
            "",
            "        Returns:",
            "            The canonical_user_id, or None if zero or multiple matches",
            "        \"\"\"",
            "        res = await self._find_user_id_and_pwd_hash(user_id)",
            "        if res is not None:",
            "            return res[0]",
            "        return None",
            "",
            "    async def is_user_approved(self, user_id: str) -> bool:",
            "        \"\"\"Checks if a user is approved and therefore can be allowed to log in.",
            "",
            "        Args:",
            "            user_id: the user to check the approval status of.",
            "",
            "        Returns:",
            "            A boolean that is True if the user is approved, False otherwise.",
            "        \"\"\"",
            "        return await self.store.is_user_approved(user_id)",
            "",
            "    async def _find_user_id_and_pwd_hash(",
            "        self, user_id: str",
            "    ) -> Optional[Tuple[str, str]]:",
            "        \"\"\"Checks to see if a user with the given id exists. Will check case",
            "        insensitively, but will return None if there are multiple inexact",
            "        matches.",
            "",
            "        Returns:",
            "            A 2-tuple of `(canonical_user_id, password_hash)` or `None`",
            "            if there is not exactly one match",
            "        \"\"\"",
            "        user_infos = await self.store.get_users_by_id_case_insensitive(user_id)",
            "",
            "        result = None",
            "        if not user_infos:",
            "            logger.warning(\"Attempted to login as %s but they do not exist\", user_id)",
            "        elif len(user_infos) == 1:",
            "            # a single match (possibly not exact)",
            "            result = user_infos.popitem()",
            "        elif user_id in user_infos:",
            "            # multiple matches, but one is exact",
            "            result = (user_id, user_infos[user_id])",
            "        else:",
            "            # multiple matches, none of them exact",
            "            logger.warning(",
            "                \"Attempted to login as %s but it matches more than one user \"",
            "                \"inexactly: %r\",",
            "                user_id,",
            "                user_infos.keys(),",
            "            )",
            "        return result",
            "",
            "    def can_change_password(self) -> bool:",
            "        \"\"\"Get whether users on this server are allowed to change or set a password.",
            "",
            "        Both `config.auth.password_enabled` and `config.auth.password_localdb_enabled` must be true.",
            "",
            "        Note that any account (even SSO accounts) are allowed to add passwords if the above",
            "        is true.",
            "",
            "        Returns:",
            "            Whether users on this server are allowed to change or set a password",
            "        \"\"\"",
            "        return self._password_enabled_for_login and self._password_localdb_enabled",
            "",
            "    def get_supported_login_types(self) -> Iterable[str]:",
            "        \"\"\"Get a the login types supported for the /login API",
            "",
            "        By default this is just 'm.login.password' (unless password_enabled is",
            "        False in the config file), but password auth providers can provide",
            "        other login types.",
            "",
            "        Returns:",
            "            login types",
            "        \"\"\"",
            "        # Load any login types registered by modules",
            "        # This is stored in the password_auth_provider so this doesn't trigger",
            "        # any callbacks",
            "        types = list(self.password_auth_provider.get_supported_login_types().keys())",
            "",
            "        # This list should include PASSWORD if (either _password_localdb_enabled is",
            "        # true or if one of the modules registered it) AND _password_enabled is true",
            "        # Also:",
            "        # Some clients just pick the first type in the list. In this case, we want",
            "        # them to use PASSWORD (rather than token or whatever), so we want to make sure",
            "        # that comes first, where it's present.",
            "        if LoginType.PASSWORD in types:",
            "            types.remove(LoginType.PASSWORD)",
            "            if self._password_enabled_for_login:",
            "                types.insert(0, LoginType.PASSWORD)",
            "        elif self._password_localdb_enabled and self._password_enabled_for_login:",
            "            types.insert(0, LoginType.PASSWORD)",
            "",
            "        return types",
            "",
            "    async def validate_login(",
            "        self,",
            "        login_submission: Dict[str, Any],",
            "        ratelimit: bool = False,",
            "        is_reauth: bool = False,",
            "    ) -> Tuple[str, Optional[Callable[[\"LoginResponse\"], Awaitable[None]]]]:",
            "        \"\"\"Authenticates the user for the /login API",
            "",
            "        Also used by the user-interactive auth flow to validate auth types which don't",
            "        have an explicit UIA handler, including m.password.auth.",
            "",
            "        Args:",
            "            login_submission: the whole of the login submission",
            "                (including 'type' and other relevant fields)",
            "            ratelimit: whether to apply the failed_login_attempt ratelimiter",
            "            is_reauth: whether this is part of a User-Interactive Authorisation",
            "                flow to reauthenticate for a privileged action (rather than a",
            "                new login)",
            "        Returns:",
            "            A tuple of the canonical user id, and optional callback",
            "                to be called once the access token and device id are issued",
            "        Raises:",
            "            StoreError if there was a problem accessing the database",
            "            SynapseError if there was a problem with the request",
            "            LoginError if there was an authentication problem.",
            "        \"\"\"",
            "        login_type = login_submission.get(\"type\")",
            "        if not isinstance(login_type, str):",
            "            raise SynapseError(400, \"Bad parameter: type\", Codes.INVALID_PARAM)",
            "",
            "        # ideally, we wouldn't be checking the identifier unless we know we have a login",
            "        # method which uses it (https://github.com/matrix-org/synapse/issues/8836)",
            "        #",
            "        # But the auth providers' check_auth interface requires a username, so in",
            "        # practice we can only support login methods which we can map to a username",
            "        # anyway.",
            "",
            "        # special case to check for \"password\" for the check_password interface",
            "        # for the auth providers",
            "        password = login_submission.get(\"password\")",
            "",
            "        if login_type == LoginType.PASSWORD:",
            "            if is_reauth:",
            "                passwords_allowed_here = self._password_enabled_for_reauth",
            "            else:",
            "                passwords_allowed_here = self._password_enabled_for_login",
            "",
            "            if not passwords_allowed_here:",
            "                raise SynapseError(400, \"Password login has been disabled.\")",
            "            if not isinstance(password, str):",
            "                raise SynapseError(400, \"Bad parameter: password\", Codes.INVALID_PARAM)",
            "",
            "        # map old-school login fields into new-school \"identifier\" fields.",
            "        identifier_dict = convert_client_dict_legacy_fields_to_identifier(",
            "            login_submission",
            "        )",
            "",
            "        # convert phone type identifiers to generic threepids",
            "        if identifier_dict[\"type\"] == \"m.id.phone\":",
            "            identifier_dict = login_id_phone_to_thirdparty(identifier_dict)",
            "",
            "        # convert threepid identifiers to user IDs",
            "        if identifier_dict[\"type\"] == \"m.id.thirdparty\":",
            "            address = identifier_dict.get(\"address\")",
            "            medium = identifier_dict.get(\"medium\")",
            "",
            "            if medium is None or address is None:",
            "                raise SynapseError(400, \"Invalid thirdparty identifier\")",
            "",
            "            # For emails, canonicalise the address.",
            "            # We store all email addresses canonicalised in the DB.",
            "            # (See add_threepid in synapse/handlers/auth.py)",
            "            if medium == \"email\":",
            "                try:",
            "                    address = canonicalise_email(address)",
            "                except ValueError as e:",
            "                    raise SynapseError(400, str(e))",
            "",
            "            # We also apply account rate limiting using the 3PID as a key, as",
            "            # otherwise using 3PID bypasses the ratelimiting based on user ID.",
            "            if ratelimit:",
            "                await self._failed_login_attempts_ratelimiter.ratelimit(",
            "                    None, (medium, address), update=False",
            "                )",
            "",
            "            # Check for login providers that support 3pid login types",
            "            if login_type == LoginType.PASSWORD:",
            "                # we've already checked that there is a (valid) password field",
            "                assert isinstance(password, str)",
            "                (",
            "                    canonical_user_id,",
            "                    callback_3pid,",
            "                ) = await self.check_password_provider_3pid(medium, address, password)",
            "                if canonical_user_id:",
            "                    # Authentication through password provider and 3pid succeeded",
            "                    return canonical_user_id, callback_3pid",
            "",
            "            # No password providers were able to handle this 3pid",
            "            # Check local store",
            "            user_id = await self.hs.get_datastores().main.get_user_id_by_threepid(",
            "                medium, address",
            "            )",
            "            if not user_id:",
            "                logger.warning(",
            "                    \"unknown 3pid identifier medium %s, address %r\", medium, address",
            "                )",
            "                # We mark that we've failed to log in here, as",
            "                # `check_password_provider_3pid` might have returned `None` due",
            "                # to an incorrect password, rather than the account not",
            "                # existing.",
            "                #",
            "                # If it returned None but the 3PID was bound then we won't hit",
            "                # this code path, which is fine as then the per-user ratelimit",
            "                # will kick in below.",
            "                if ratelimit:",
            "                    await self._failed_login_attempts_ratelimiter.can_do_action(",
            "                        None, (medium, address)",
            "                    )",
            "                raise LoginError(",
            "                    403, msg=INVALID_USERNAME_OR_PASSWORD, errcode=Codes.FORBIDDEN",
            "                )",
            "",
            "            identifier_dict = {\"type\": \"m.id.user\", \"user\": user_id}",
            "",
            "        # by this point, the identifier should be an m.id.user: if it's anything",
            "        # else, we haven't understood it.",
            "        if identifier_dict[\"type\"] != \"m.id.user\":",
            "            raise SynapseError(400, \"Unknown login identifier type\")",
            "",
            "        username = identifier_dict.get(\"user\")",
            "        if not username:",
            "            raise SynapseError(400, \"User identifier is missing 'user' key\")",
            "",
            "        if username.startswith(\"@\"):",
            "            qualified_user_id = username",
            "        else:",
            "            qualified_user_id = UserID(username, self.hs.hostname).to_string()",
            "",
            "        # Check if we've hit the failed ratelimit (but don't update it)",
            "        if ratelimit:",
            "            await self._failed_login_attempts_ratelimiter.ratelimit(",
            "                None, qualified_user_id.lower(), update=False",
            "            )",
            "",
            "        try:",
            "            return await self._validate_userid_login(username, login_submission)",
            "        except LoginError:",
            "            # The user has failed to log in, so we need to update the rate",
            "            # limiter. Using `can_do_action` avoids us raising a ratelimit",
            "            # exception and masking the LoginError. The actual ratelimiting",
            "            # should have happened above.",
            "            if ratelimit:",
            "                await self._failed_login_attempts_ratelimiter.can_do_action(",
            "                    None, qualified_user_id.lower()",
            "                )",
            "            raise",
            "",
            "    async def _validate_userid_login(",
            "        self,",
            "        username: str,",
            "        login_submission: Dict[str, Any],",
            "    ) -> Tuple[str, Optional[Callable[[\"LoginResponse\"], Awaitable[None]]]]:",
            "        \"\"\"Helper for validate_login",
            "",
            "        Handles login, once we've mapped 3pids onto userids",
            "",
            "        Args:",
            "            username: the username, from the identifier dict",
            "            login_submission: the whole of the login submission",
            "                (including 'type' and other relevant fields)",
            "        Returns:",
            "            A tuple of the canonical user id, and optional callback",
            "                to be called once the access token and device id are issued",
            "        Raises:",
            "            StoreError if there was a problem accessing the database",
            "            SynapseError if there was a problem with the request",
            "            LoginError if there was an authentication problem.",
            "        \"\"\"",
            "        if username.startswith(\"@\"):",
            "            qualified_user_id = username",
            "        else:",
            "            qualified_user_id = UserID(username, self.hs.hostname).to_string()",
            "",
            "        login_type = login_submission.get(\"type\")",
            "        # we already checked that we have a valid login type",
            "        assert isinstance(login_type, str)",
            "",
            "        known_login_type = False",
            "",
            "        # Check if login_type matches a type registered by one of the modules",
            "        # We don't need to remove LoginType.PASSWORD from the list if password login is",
            "        # disabled, since if that were the case then by this point we know that the",
            "        # login_type is not LoginType.PASSWORD",
            "        supported_login_types = self.password_auth_provider.get_supported_login_types()",
            "        # check if the login type being used is supported by a module",
            "        if login_type in supported_login_types:",
            "            # Make a note that this login type is supported by the server",
            "            known_login_type = True",
            "            # Get all the fields expected for this login types",
            "            login_fields = supported_login_types[login_type]",
            "",
            "            # go through the login submission and keep track of which required fields are",
            "            # provided/not provided",
            "            missing_fields = []",
            "            login_dict = {}",
            "            for f in login_fields:",
            "                if f not in login_submission:",
            "                    missing_fields.append(f)",
            "                else:",
            "                    login_dict[f] = login_submission[f]",
            "            # raise an error if any of the expected fields for that login type weren't provided",
            "            if missing_fields:",
            "                raise SynapseError(",
            "                    400,",
            "                    \"Missing parameters for login type %s: %s\"",
            "                    % (login_type, missing_fields),",
            "                )",
            "",
            "            # call all of the check_auth hooks for that login_type",
            "            # it will return a result once the first success is found (or None otherwise)",
            "            result = await self.password_auth_provider.check_auth(",
            "                username, login_type, login_dict",
            "            )",
            "            if result:",
            "                return result",
            "",
            "        # if no module managed to authenticate the user, then fallback to built in password based auth",
            "        if login_type == LoginType.PASSWORD and self._password_localdb_enabled:",
            "            known_login_type = True",
            "",
            "            # we've already checked that there is a (valid) password field",
            "            password = login_submission[\"password\"]",
            "            assert isinstance(password, str)",
            "",
            "            canonical_user_id = await self._check_local_password(",
            "                qualified_user_id, password",
            "            )",
            "",
            "            if canonical_user_id:",
            "                return canonical_user_id, None",
            "",
            "        if not known_login_type:",
            "            raise SynapseError(400, \"Unknown login type %s\" % login_type)",
            "",
            "        # We raise a 403 here, but note that if we're doing user-interactive",
            "        # login, it turns all LoginErrors into a 401 anyway.",
            "        raise LoginError(403, msg=INVALID_USERNAME_OR_PASSWORD, errcode=Codes.FORBIDDEN)",
            "",
            "    async def check_password_provider_3pid(",
            "        self, medium: str, address: str, password: str",
            "    ) -> Tuple[Optional[str], Optional[Callable[[\"LoginResponse\"], Awaitable[None]]]]:",
            "        \"\"\"Check if a password provider is able to validate a thirdparty login",
            "",
            "        Args:",
            "            medium: The medium of the 3pid (ex. email).",
            "            address: The address of the 3pid (ex. jdoe@example.com).",
            "            password: The password of the user.",
            "",
            "        Returns:",
            "            A tuple of `(user_id, callback)`. If authentication is successful,",
            "            `user_id`is the authenticated, canonical user ID. `callback` is",
            "            then either a function to be later run after the server has",
            "            completed login/registration, or `None`. If authentication was",
            "            unsuccessful, `user_id` and `callback` are both `None`.",
            "        \"\"\"",
            "        # call all of the check_3pid_auth callbacks",
            "        # Result will be from the first callback that returns something other than None",
            "        # If all the callbacks return None, then result is also set to None",
            "        result = await self.password_auth_provider.check_3pid_auth(",
            "            medium, address, password",
            "        )",
            "        if result:",
            "            return result",
            "",
            "        # if result is None then return (None, None)",
            "        return None, None",
            "",
            "    async def _check_local_password(self, user_id: str, password: str) -> Optional[str]:",
            "        \"\"\"Authenticate a user against the local password database.",
            "",
            "        user_id is checked case insensitively, but will return None if there are",
            "        multiple inexact matches.",
            "",
            "        Args:",
            "            user_id: complete @user:id",
            "            password: the provided password",
            "        Returns:",
            "            The canonical_user_id, or None if unknown user/bad password",
            "        \"\"\"",
            "        lookupres = await self._find_user_id_and_pwd_hash(user_id)",
            "        if not lookupres:",
            "            return None",
            "        (user_id, password_hash) = lookupres",
            "",
            "        # If the password hash is None, the account has likely been deactivated",
            "        if not password_hash:",
            "            deactivated = await self.store.get_user_deactivated_status(user_id)",
            "            if deactivated:",
            "                raise UserDeactivatedError(\"This account has been deactivated\")",
            "",
            "        result = await self.validate_hash(password, password_hash)",
            "        if not result:",
            "            logger.warning(\"Failed password login for user %s\", user_id)",
            "            return None",
            "        return user_id",
            "",
            "    def generate_login_token(self) -> str:",
            "        \"\"\"Generates an opaque string, for use as an short-term login token\"\"\"",
            "",
            "        # we use the following format for access tokens:",
            "        #    syl_<random string>_<base62 crc check>",
            "",
            "        random_string = stringutils.random_string(20)",
            "        base = f\"syl_{random_string}\"",
            "",
            "        crc = base62_encode(crc32(base.encode(\"ascii\")), minwidth=6)",
            "        return f\"{base}_{crc}\"",
            "",
            "    def generate_access_token(self, for_user: UserID) -> str:",
            "        \"\"\"Generates an opaque string, for use as an access token\"\"\"",
            "",
            "        # we use the following format for access tokens:",
            "        #    syt_<base64 local part>_<random string>_<base62 crc check>",
            "",
            "        b64local = unpaddedbase64.encode_base64(for_user.localpart.encode(\"utf-8\"))",
            "        random_string = stringutils.random_string(20)",
            "        base = f\"syt_{b64local}_{random_string}\"",
            "",
            "        crc = base62_encode(crc32(base.encode(\"ascii\")), minwidth=6)",
            "        return f\"{base}_{crc}\"",
            "",
            "    def generate_refresh_token(self, for_user: UserID) -> str:",
            "        \"\"\"Generates an opaque string, for use as a refresh token\"\"\"",
            "",
            "        # we use the following format for refresh tokens:",
            "        #    syr_<base64 local part>_<random string>_<base62 crc check>",
            "",
            "        b64local = unpaddedbase64.encode_base64(for_user.localpart.encode(\"utf-8\"))",
            "        random_string = stringutils.random_string(20)",
            "        base = f\"syr_{b64local}_{random_string}\"",
            "",
            "        crc = base62_encode(crc32(base.encode(\"ascii\")), minwidth=6)",
            "        return f\"{base}_{crc}\"",
            "",
            "    async def consume_login_token(self, login_token: str) -> LoginTokenLookupResult:",
            "        try:",
            "            return await self.store.consume_login_token(login_token)",
            "        except LoginTokenExpired:",
            "            invalid_login_token_counter.labels(\"expired\").inc()",
            "        except LoginTokenReused:",
            "            invalid_login_token_counter.labels(\"reused\").inc()",
            "        except NotFoundError:",
            "            invalid_login_token_counter.labels(\"not found\").inc()",
            "",
            "        raise AuthError(403, \"Invalid login token\", errcode=Codes.FORBIDDEN)",
            "",
            "    async def delete_access_token(self, access_token: str) -> None:",
            "        \"\"\"Invalidate a single access token",
            "",
            "        Args:",
            "            access_token: access token to be deleted",
            "",
            "        \"\"\"",
            "        token = await self.store.get_user_by_access_token(access_token)",
            "        if not token:",
            "            # At this point, the token should already have been fetched once by",
            "            # the caller, so this should not happen, unless of a race condition",
            "            # between two delete requests",
            "            raise SynapseError(HTTPStatus.UNAUTHORIZED, \"Unrecognised access token\")",
            "        await self.store.delete_access_token(access_token)",
            "",
            "        # see if any modules want to know about this",
            "        await self.password_auth_provider.on_logged_out(",
            "            user_id=token.user_id,",
            "            device_id=token.device_id,",
            "            access_token=access_token,",
            "        )",
            "",
            "        # delete pushers associated with this access token",
            "        # XXX(quenting): This is only needed until the 'set_device_id_for_pushers'",
            "        # background update completes.",
            "        if token.token_id is not None:",
            "            await self.hs.get_pusherpool().remove_pushers_by_access_tokens(",
            "                token.user_id, (token.token_id,)",
            "            )",
            "",
            "    async def delete_access_tokens_for_user(",
            "        self,",
            "        user_id: str,",
            "        except_token_id: Optional[int] = None,",
            "        device_id: Optional[str] = None,",
            "    ) -> None:",
            "        \"\"\"Invalidate access tokens belonging to a user",
            "",
            "        Args:",
            "            user_id:  ID of user the tokens belong to",
            "            except_token_id: access_token ID which should *not* be deleted",
            "            device_id:  ID of device the tokens are associated with.",
            "                If None, tokens associated with any device (or no device) will",
            "                be deleted",
            "        \"\"\"",
            "        tokens_and_devices = await self.store.user_delete_access_tokens(",
            "            user_id, except_token_id=except_token_id, device_id=device_id",
            "        )",
            "",
            "        # see if any modules want to know about this",
            "        for token, _, device_id in tokens_and_devices:",
            "            await self.password_auth_provider.on_logged_out(",
            "                user_id=user_id, device_id=device_id, access_token=token",
            "            )",
            "",
            "        # delete pushers associated with the access tokens",
            "        # XXX(quenting): This is only needed until the 'set_device_id_for_pushers'",
            "        # background update completes.",
            "        await self.hs.get_pusherpool().remove_pushers_by_access_tokens(",
            "            user_id, (token_id for _, token_id, _ in tokens_and_devices)",
            "        )",
            "",
            "    async def add_threepid(",
            "        self, user_id: str, medium: str, address: str, validated_at: int",
            "    ) -> None:",
            "        \"\"\"",
            "        Adds an association between a user's Matrix ID and a third-party ID (email,",
            "        phone number).",
            "",
            "        Args:",
            "            user_id: The ID of the user to associate.",
            "            medium: The medium of the third-party ID (email, msisdn).",
            "            address: The address of the third-party ID (i.e. an email address).",
            "            validated_at: The timestamp in ms of when the validation that the user owns",
            "                this third-party ID occurred.",
            "        \"\"\"",
            "        # check if medium has a valid value",
            "        if medium not in [\"email\", \"msisdn\"]:",
            "            raise SynapseError(",
            "                code=400,",
            "                msg=(\"'%s' is not a valid value for 'medium'\" % (medium,)),",
            "                errcode=Codes.INVALID_PARAM,",
            "            )",
            "",
            "        # 'Canonicalise' email addresses down to lower case.",
            "        # We've now moving towards the homeserver being the entity that",
            "        # is responsible for validating threepids used for resetting passwords",
            "        # on accounts, so in future Synapse will gain knowledge of specific",
            "        # types (mediums) of threepid. For now, we still use the existing",
            "        # infrastructure, but this is the start of synapse gaining knowledge",
            "        # of specific types of threepid (and fixes the fact that checking",
            "        # for the presence of an email address during password reset was",
            "        # case sensitive).",
            "        if medium == \"email\":",
            "            address = canonicalise_email(address)",
            "",
            "        await self.store.user_add_threepid(",
            "            user_id, medium, address, validated_at, self.hs.get_clock().time_msec()",
            "        )",
            "",
            "        # Inform Synapse modules that a 3PID association has been created.",
            "        await self._third_party_rules.on_add_user_third_party_identifier(",
            "            user_id, medium, address",
            "        )",
            "",
            "        # Deprecated method for informing Synapse modules that a 3PID association",
            "        # has successfully been created.",
            "        await self._third_party_rules.on_threepid_bind(user_id, medium, address)",
            "",
            "    async def delete_local_threepid(",
            "        self, user_id: str, medium: str, address: str",
            "    ) -> None:",
            "        \"\"\"Deletes an association between a third-party ID and a user ID from the local",
            "        database. This method does not unbind the association from any identity servers.",
            "",
            "        If `medium` is 'email' and a pusher is associated with this third-party ID, the",
            "        pusher will also be deleted.",
            "",
            "        Args:",
            "            user_id: ID of user to remove the 3pid from.",
            "            medium: The medium of the 3pid being removed: \"email\" or \"msisdn\".",
            "            address: The 3pid address to remove.",
            "        \"\"\"",
            "        # 'Canonicalise' email addresses as per above",
            "        if medium == \"email\":",
            "            address = canonicalise_email(address)",
            "",
            "        await self.store.user_delete_threepid(user_id, medium, address)",
            "",
            "        # Inform Synapse modules that a 3PID association has been deleted.",
            "        await self._third_party_rules.on_remove_user_third_party_identifier(",
            "            user_id, medium, address",
            "        )",
            "",
            "        if medium == \"email\":",
            "            await self.store.delete_pusher_by_app_id_pushkey_user_id(",
            "                app_id=\"m.email\", pushkey=address, user_id=user_id",
            "            )",
            "",
            "    async def hash(self, password: str) -> str:",
            "        \"\"\"Computes a secure hash of password.",
            "",
            "        Args:",
            "            password: Password to hash.",
            "",
            "        Returns:",
            "            Hashed password.",
            "        \"\"\"",
            "",
            "        def _do_hash() -> str:",
            "            # Normalise the Unicode in the password",
            "            pw = unicodedata.normalize(\"NFKC\", password)",
            "",
            "            return bcrypt.hashpw(",
            "                pw.encode(\"utf8\") + self.hs.config.auth.password_pepper.encode(\"utf8\"),",
            "                bcrypt.gensalt(self.bcrypt_rounds),",
            "            ).decode(\"ascii\")",
            "",
            "        return await defer_to_thread(self.hs.get_reactor(), _do_hash)",
            "",
            "    async def validate_hash(",
            "        self, password: str, stored_hash: Union[bytes, str]",
            "    ) -> bool:",
            "        \"\"\"Validates that self.hash(password) == stored_hash.",
            "",
            "        Args:",
            "            password: Password to hash.",
            "            stored_hash: Expected hash value.",
            "",
            "        Returns:",
            "            Whether self.hash(password) == stored_hash.",
            "        \"\"\"",
            "",
            "        def _do_validate_hash(checked_hash: bytes) -> bool:",
            "            # Normalise the Unicode in the password",
            "            pw = unicodedata.normalize(\"NFKC\", password)",
            "",
            "            return bcrypt.checkpw(",
            "                pw.encode(\"utf8\") + self.hs.config.auth.password_pepper.encode(\"utf8\"),",
            "                checked_hash,",
            "            )",
            "",
            "        if stored_hash:",
            "            if not isinstance(stored_hash, bytes):",
            "                stored_hash = stored_hash.encode(\"ascii\")",
            "",
            "            return await defer_to_thread(",
            "                self.hs.get_reactor(), _do_validate_hash, stored_hash",
            "            )",
            "        else:",
            "            return False",
            "",
            "    async def start_sso_ui_auth(self, request: SynapseRequest, session_id: str) -> str:",
            "        \"\"\"",
            "        Get the HTML for the SSO redirect confirmation page.",
            "",
            "        Args:",
            "            request: The incoming HTTP request",
            "            session_id: The user interactive authentication session ID.",
            "",
            "        Returns:",
            "            The HTML to render.",
            "        \"\"\"",
            "        try:",
            "            session = await self.store.get_ui_auth_session(session_id)",
            "        except StoreError:",
            "            raise SynapseError(400, \"Unknown session ID: %s\" % (session_id,))",
            "",
            "        user_id_to_verify: str = await self.get_session_data(",
            "            session_id, UIAuthSessionDataConstants.REQUEST_USER_ID",
            "        )",
            "",
            "        idps = await self.hs.get_sso_handler().get_identity_providers_for_user(",
            "            user_id_to_verify",
            "        )",
            "",
            "        if not idps:",
            "            # we checked that the user had some remote identities before offering an SSO",
            "            # flow, so either it's been deleted or the client has requested SSO despite",
            "            # it not being offered.",
            "            raise SynapseError(400, \"User has no SSO identities\")",
            "",
            "        # for now, just pick one",
            "        idp_id, sso_auth_provider = next(iter(idps.items()))",
            "        if len(idps) > 0:",
            "            logger.warning(",
            "                \"User %r has previously logged in with multiple SSO IdPs; arbitrarily \"",
            "                \"picking %r\",",
            "                user_id_to_verify,",
            "                idp_id,",
            "            )",
            "",
            "        redirect_url = await sso_auth_provider.handle_redirect_request(",
            "            request, None, session_id",
            "        )",
            "",
            "        return self._sso_auth_confirm_template.render(",
            "            description=session.description,",
            "            redirect_url=redirect_url,",
            "            idp=sso_auth_provider,",
            "        )",
            "",
            "    async def complete_sso_login(",
            "        self,",
            "        registered_user_id: str,",
            "        auth_provider_id: str,",
            "        request: Request,",
            "        client_redirect_url: str,",
            "        extra_attributes: Optional[JsonDict] = None,",
            "        new_user: bool = False,",
            "        auth_provider_session_id: Optional[str] = None,",
            "    ) -> None:",
            "        \"\"\"Having figured out a mxid for this user, complete the HTTP request",
            "",
            "        Args:",
            "            registered_user_id: The registered user ID to complete SSO login for.",
            "            auth_provider_id: The id of the SSO Identity provider that was used for",
            "                login. This will be stored in the login token for future tracking in",
            "                prometheus metrics.",
            "            request: The request to complete.",
            "            client_redirect_url: The URL to which to redirect the user at the end of the",
            "                process.",
            "            extra_attributes: Extra attributes which will be passed to the client",
            "                during successful login. Must be JSON serializable.",
            "            new_user: True if we should use wording appropriate to a user who has just",
            "                registered.",
            "            auth_provider_session_id: The session ID from the SSO IdP received during login.",
            "        \"\"\"",
            "        # If the account has been deactivated, do not proceed with the login",
            "        # flow.",
            "        deactivated = await self.store.get_user_deactivated_status(registered_user_id)",
            "        if deactivated:",
            "            respond_with_html(request, 403, self._sso_account_deactivated_template)",
            "            return",
            "",
            "        user_profile_data = await self.store.get_profileinfo(",
            "            UserID.from_string(registered_user_id).localpart",
            "        )",
            "",
            "        # Store any extra attributes which will be passed in the login response.",
            "        # Note that this is per-user so it may overwrite a previous value, this",
            "        # is considered OK since the newest SSO attributes should be most valid.",
            "        if extra_attributes:",
            "            self._extra_attributes[registered_user_id] = SsoLoginExtraAttributes(",
            "                self._clock.time_msec(),",
            "                extra_attributes,",
            "            )",
            "",
            "        # Create a login token",
            "        login_token = await self.create_login_token_for_user_id(",
            "            registered_user_id,",
            "            auth_provider_id=auth_provider_id,",
            "            auth_provider_session_id=auth_provider_session_id,",
            "        )",
            "",
            "        # Append the login token to the original redirect URL (i.e. with its query",
            "        # parameters kept intact) to build the URL to which the template needs to",
            "        # redirect the users once they have clicked on the confirmation link.",
            "        redirect_url = self.add_query_param_to_url(",
            "            client_redirect_url, \"loginToken\", login_token",
            "        )",
            "",
            "        # if the client is whitelisted, we can redirect straight to it",
            "        if client_redirect_url.startswith(self._whitelisted_sso_clients):",
            "            request.redirect(redirect_url)",
            "            finish_request(request)",
            "            return",
            "",
            "        # Otherwise, serve the redirect confirmation page.",
            "",
            "        # Remove the query parameters from the redirect URL to get a shorter version of",
            "        # it. This is only to display a human-readable URL in the template, but not the",
            "        # URL we redirect users to.",
            "        url_parts = urllib.parse.urlsplit(client_redirect_url)",
            "",
            "        if url_parts.scheme == \"https\":",
            "            # for an https uri, just show the netloc (ie, the hostname. Specifically,",
            "            # the bit between \"//\" and \"/\"; this includes any potential",
            "            # \"username:password@\" prefix.)",
            "            display_url = url_parts.netloc",
            "        else:",
            "            # for other uris, strip the query-params (including the login token) and",
            "            # fragment.",
            "            display_url = urllib.parse.urlunsplit(",
            "                (url_parts.scheme, url_parts.netloc, url_parts.path, \"\", \"\")",
            "            )",
            "",
            "        html = self._sso_redirect_confirm_template.render(",
            "            display_url=display_url,",
            "            redirect_url=redirect_url,",
            "            server_name=self._server_name,",
            "            new_user=new_user,",
            "            user_id=registered_user_id,",
            "            user_profile=user_profile_data,",
            "        )",
            "        respond_with_html(request, 200, html)",
            "",
            "    async def _sso_login_callback(self, login_result: \"LoginResponse\") -> None:",
            "        \"\"\"",
            "        A login callback which might add additional attributes to the login response.",
            "",
            "        Args:",
            "            login_result: The data to be sent to the client. Includes the user",
            "                ID and access token.",
            "        \"\"\"",
            "        # Expire attributes before processing. Note that there shouldn't be any",
            "        # valid logins that still have extra attributes.",
            "        self._expire_sso_extra_attributes()",
            "",
            "        extra_attributes = self._extra_attributes.get(login_result[\"user_id\"])",
            "        if extra_attributes:",
            "            login_result_dict = cast(Dict[str, Any], login_result)",
            "            login_result_dict.update(extra_attributes.extra_attributes)",
            "",
            "    def _expire_sso_extra_attributes(self) -> None:",
            "        \"\"\"",
            "        Iterate through the mapping of user IDs to extra attributes and remove any that are no longer valid.",
            "        \"\"\"",
            "        # TODO This should match the amount of time the macaroon is valid for.",
            "        LOGIN_TOKEN_EXPIRATION_TIME = 2 * 60 * 1000",
            "        expire_before = self._clock.time_msec() - LOGIN_TOKEN_EXPIRATION_TIME",
            "        to_expire = set()",
            "        for user_id, data in self._extra_attributes.items():",
            "            if data.creation_time < expire_before:",
            "                to_expire.add(user_id)",
            "        for user_id in to_expire:",
            "            logger.debug(\"Expiring extra attributes for user %s\", user_id)",
            "            del self._extra_attributes[user_id]",
            "",
            "    @staticmethod",
            "    def add_query_param_to_url(url: str, param_name: str, param: Any) -> str:",
            "        url_parts = list(urllib.parse.urlparse(url))",
            "        query = urllib.parse.parse_qsl(url_parts[4], keep_blank_values=True)",
            "        query.append((param_name, param))",
            "        url_parts[4] = urllib.parse.urlencode(query)",
            "        return urllib.parse.urlunparse(url_parts)",
            "",
            "",
            "def load_legacy_password_auth_providers(hs: \"HomeServer\") -> None:",
            "    module_api = hs.get_module_api()",
            "    for module, config in hs.config.authproviders.password_providers:",
            "        load_single_legacy_password_auth_provider(",
            "            module=module, config=config, api=module_api",
            "        )",
            "",
            "",
            "def load_single_legacy_password_auth_provider(",
            "    module: Type,",
            "    config: JsonDict,",
            "    api: \"ModuleApi\",",
            ") -> None:",
            "    try:",
            "        provider = module(config=config, account_handler=api)",
            "    except Exception as e:",
            "        logger.error(\"Error while initializing %r: %s\", module, e)",
            "        raise",
            "",
            "    # All methods that the module provides should be async, but this wasn't enforced",
            "    # in the old module system, so we wrap them if needed",
            "    def async_wrapper(f: Optional[Callable]) -> Optional[Callable[..., Awaitable]]:",
            "        # f might be None if the callback isn't implemented by the module. In this",
            "        # case we don't want to register a callback at all so we return None.",
            "        if f is None:",
            "            return None",
            "",
            "        # We need to wrap check_password because its old form would return a boolean",
            "        # but we now want it to behave just like check_auth() and return the matrix id of",
            "        # the user if authentication succeeded or None otherwise",
            "        if f.__name__ == \"check_password\":",
            "",
            "            async def wrapped_check_password(",
            "                username: str, login_type: str, login_dict: JsonDict",
            "            ) -> Optional[Tuple[str, Optional[Callable]]]:",
            "                # We've already made sure f is not None above, but mypy doesn't do well",
            "                # across function boundaries so we need to tell it f is definitely not",
            "                # None.",
            "                assert f is not None",
            "",
            "                matrix_user_id = api.get_qualified_user_id(username)",
            "                password = login_dict[\"password\"]",
            "",
            "                is_valid = await f(matrix_user_id, password)",
            "",
            "                if is_valid:",
            "                    return matrix_user_id, None",
            "",
            "                return None",
            "",
            "            return wrapped_check_password",
            "",
            "        # We need to wrap check_auth as in the old form it could return",
            "        # just a str, but now it must return Optional[Tuple[str, Optional[Callable]]",
            "        if f.__name__ == \"check_auth\":",
            "",
            "            async def wrapped_check_auth(",
            "                username: str, login_type: str, login_dict: JsonDict",
            "            ) -> Optional[Tuple[str, Optional[Callable]]]:",
            "                # We've already made sure f is not None above, but mypy doesn't do well",
            "                # across function boundaries so we need to tell it f is definitely not",
            "                # None.",
            "                assert f is not None",
            "",
            "                result = await f(username, login_type, login_dict)",
            "",
            "                if isinstance(result, str):",
            "                    return result, None",
            "",
            "                return result",
            "",
            "            return wrapped_check_auth",
            "",
            "        # We need to wrap check_3pid_auth as in the old form it could return",
            "        # just a str, but now it must return Optional[Tuple[str, Optional[Callable]]",
            "        if f.__name__ == \"check_3pid_auth\":",
            "",
            "            async def wrapped_check_3pid_auth(",
            "                medium: str, address: str, password: str",
            "            ) -> Optional[Tuple[str, Optional[Callable]]]:",
            "                # We've already made sure f is not None above, but mypy doesn't do well",
            "                # across function boundaries so we need to tell it f is definitely not",
            "                # None.",
            "                assert f is not None",
            "",
            "                result = await f(medium, address, password)",
            "",
            "                if isinstance(result, str):",
            "                    return result, None",
            "",
            "                return result",
            "",
            "            return wrapped_check_3pid_auth",
            "",
            "        def run(*args: Tuple, **kwargs: Dict) -> Awaitable:",
            "            # mypy doesn't do well across function boundaries so we need to tell it",
            "            # f is definitely not None.",
            "            assert f is not None",
            "",
            "            return maybe_awaitable(f(*args, **kwargs))",
            "",
            "        return run",
            "",
            "    # If the module has these methods implemented, then we pull them out",
            "    # and register them as hooks.",
            "    check_3pid_auth_hook: Optional[CHECK_3PID_AUTH_CALLBACK] = async_wrapper(",
            "        getattr(provider, \"check_3pid_auth\", None)",
            "    )",
            "    on_logged_out_hook: Optional[ON_LOGGED_OUT_CALLBACK] = async_wrapper(",
            "        getattr(provider, \"on_logged_out\", None)",
            "    )",
            "",
            "    supported_login_types = {}",
            "    # call get_supported_login_types and add that to the dict",
            "    g = getattr(provider, \"get_supported_login_types\", None)",
            "    if g is not None:",
            "        # Note the old module style also called get_supported_login_types at loading time",
            "        # and it is synchronous",
            "        supported_login_types.update(g())",
            "",
            "    auth_checkers = {}",
            "    # Legacy modules have a check_auth method which expects to be called with one of",
            "    # the keys returned by get_supported_login_types. New style modules register a",
            "    # dictionary of login_type->check_auth_method mappings",
            "    check_auth = async_wrapper(getattr(provider, \"check_auth\", None))",
            "    if check_auth is not None:",
            "        for login_type, fields in supported_login_types.items():",
            "            # need tuple(fields) since fields can be any Iterable type (so may not be hashable)",
            "            auth_checkers[(login_type, tuple(fields))] = check_auth",
            "",
            "    # if it has a \"check_password\" method then it should handle all auth checks",
            "    # with login type of LoginType.PASSWORD",
            "    check_password = async_wrapper(getattr(provider, \"check_password\", None))",
            "    if check_password is not None:",
            "        # need to use a tuple here for (\"password\",) not a list since lists aren't hashable",
            "        auth_checkers[(LoginType.PASSWORD, (\"password\",))] = check_password",
            "",
            "    api.register_password_auth_provider_callbacks(",
            "        check_3pid_auth=check_3pid_auth_hook,",
            "        on_logged_out=on_logged_out_hook,",
            "        auth_checkers=auth_checkers,",
            "    )",
            "",
            "",
            "CHECK_3PID_AUTH_CALLBACK = Callable[",
            "    [str, str, str],",
            "    Awaitable[",
            "        Optional[Tuple[str, Optional[Callable[[\"LoginResponse\"], Awaitable[None]]]]]",
            "    ],",
            "]",
            "ON_LOGGED_OUT_CALLBACK = Callable[[str, Optional[str], str], Awaitable]",
            "CHECK_AUTH_CALLBACK = Callable[",
            "    [str, str, JsonDict],",
            "    Awaitable[",
            "        Optional[Tuple[str, Optional[Callable[[\"LoginResponse\"], Awaitable[None]]]]]",
            "    ],",
            "]",
            "GET_USERNAME_FOR_REGISTRATION_CALLBACK = Callable[",
            "    [JsonDict, JsonDict],",
            "    Awaitable[Optional[str]],",
            "]",
            "GET_DISPLAYNAME_FOR_REGISTRATION_CALLBACK = Callable[",
            "    [JsonDict, JsonDict],",
            "    Awaitable[Optional[str]],",
            "]",
            "IS_3PID_ALLOWED_CALLBACK = Callable[[str, str, bool], Awaitable[bool]]",
            "",
            "",
            "class PasswordAuthProvider:",
            "    \"\"\"",
            "    A class that the AuthHandler calls when authenticating users",
            "    It allows modules to provide alternative methods for authentication",
            "    \"\"\"",
            "",
            "    def __init__(self) -> None:",
            "        # lists of callbacks",
            "        self.check_3pid_auth_callbacks: List[CHECK_3PID_AUTH_CALLBACK] = []",
            "        self.on_logged_out_callbacks: List[ON_LOGGED_OUT_CALLBACK] = []",
            "        self.get_username_for_registration_callbacks: List[",
            "            GET_USERNAME_FOR_REGISTRATION_CALLBACK",
            "        ] = []",
            "        self.get_displayname_for_registration_callbacks: List[",
            "            GET_DISPLAYNAME_FOR_REGISTRATION_CALLBACK",
            "        ] = []",
            "        self.is_3pid_allowed_callbacks: List[IS_3PID_ALLOWED_CALLBACK] = []",
            "",
            "        # Mapping from login type to login parameters",
            "        self._supported_login_types: Dict[str, Tuple[str, ...]] = {}",
            "",
            "        # Mapping from login type to auth checker callbacks",
            "        self.auth_checker_callbacks: Dict[str, List[CHECK_AUTH_CALLBACK]] = {}",
            "",
            "    def register_password_auth_provider_callbacks(",
            "        self,",
            "        check_3pid_auth: Optional[CHECK_3PID_AUTH_CALLBACK] = None,",
            "        on_logged_out: Optional[ON_LOGGED_OUT_CALLBACK] = None,",
            "        is_3pid_allowed: Optional[IS_3PID_ALLOWED_CALLBACK] = None,",
            "        auth_checkers: Optional[",
            "            Dict[Tuple[str, Tuple[str, ...]], CHECK_AUTH_CALLBACK]",
            "        ] = None,",
            "        get_username_for_registration: Optional[",
            "            GET_USERNAME_FOR_REGISTRATION_CALLBACK",
            "        ] = None,",
            "        get_displayname_for_registration: Optional[",
            "            GET_DISPLAYNAME_FOR_REGISTRATION_CALLBACK",
            "        ] = None,",
            "    ) -> None:",
            "        # Register check_3pid_auth callback",
            "        if check_3pid_auth is not None:",
            "            self.check_3pid_auth_callbacks.append(check_3pid_auth)",
            "",
            "        # register on_logged_out callback",
            "        if on_logged_out is not None:",
            "            self.on_logged_out_callbacks.append(on_logged_out)",
            "",
            "        if auth_checkers is not None:",
            "            # register a new supported login_type",
            "            # Iterate through all of the types being registered",
            "            for (login_type, fields), callback in auth_checkers.items():",
            "                # Note: fields may be empty here. This would allow a modules auth checker to",
            "                # be called with just 'login_type' and no password or other secrets",
            "",
            "                # Need to check that all the field names are strings or may get nasty errors later",
            "                for f in fields:",
            "                    if not isinstance(f, str):",
            "                        raise RuntimeError(",
            "                            \"A module tried to register support for login type: %s with parameters %s\"",
            "                            \" but all parameter names must be strings\"",
            "                            % (login_type, fields)",
            "                        )",
            "",
            "                # 2 modules supporting the same login type must expect the same fields",
            "                # e.g. 1 can't expect \"pass\" if the other expects \"password\"",
            "                # so throw an exception if that happens",
            "                if login_type not in self._supported_login_types.get(login_type, []):",
            "                    self._supported_login_types[login_type] = fields",
            "                else:",
            "                    fields_currently_supported = self._supported_login_types.get(",
            "                        login_type",
            "                    )",
            "                    if fields_currently_supported != fields:",
            "                        raise RuntimeError(",
            "                            \"A module tried to register support for login type: %s with parameters %s\"",
            "                            \" but another module had already registered support for that type with parameters %s\"",
            "                            % (login_type, fields, fields_currently_supported)",
            "                        )",
            "",
            "                # Add the new method to the list of auth_checker_callbacks for this login type",
            "                self.auth_checker_callbacks.setdefault(login_type, []).append(callback)",
            "",
            "        if get_username_for_registration is not None:",
            "            self.get_username_for_registration_callbacks.append(",
            "                get_username_for_registration,",
            "            )",
            "",
            "        if get_displayname_for_registration is not None:",
            "            self.get_displayname_for_registration_callbacks.append(",
            "                get_displayname_for_registration,",
            "            )",
            "",
            "        if is_3pid_allowed is not None:",
            "            self.is_3pid_allowed_callbacks.append(is_3pid_allowed)",
            "",
            "    def get_supported_login_types(self) -> Mapping[str, Iterable[str]]:",
            "        \"\"\"Get the login types supported by this password provider",
            "",
            "        Returns a map from a login type identifier (such as m.login.password) to an",
            "        iterable giving the fields which must be provided by the user in the submission",
            "        to the /login API.",
            "        \"\"\"",
            "",
            "        return self._supported_login_types",
            "",
            "    async def check_auth(",
            "        self, username: str, login_type: str, login_dict: JsonDict",
            "    ) -> Optional[Tuple[str, Optional[Callable[[\"LoginResponse\"], Awaitable[None]]]]]:",
            "        \"\"\"Check if the user has presented valid login credentials",
            "",
            "        Args:",
            "            username: user id presented by the client. Either an MXID or an unqualified",
            "                username.",
            "",
            "            login_type: the login type being attempted - one of the types returned by",
            "                get_supported_login_types()",
            "",
            "            login_dict: the dictionary of login secrets passed by the client.",
            "",
            "        Returns: (user_id, callback) where `user_id` is the fully-qualified mxid of the",
            "            user, and `callback` is an optional callback which will be called with the",
            "            result from the /login call (including access_token, device_id, etc.)",
            "        \"\"\"",
            "",
            "        # Go through all callbacks for the login type until one returns with a value",
            "        # other than None (i.e. until a callback returns a success)",
            "        for callback in self.auth_checker_callbacks[login_type]:",
            "            try:",
            "                result = await delay_cancellation(",
            "                    callback(username, login_type, login_dict)",
            "                )",
            "            except CancelledError:",
            "                raise",
            "            except Exception as e:",
            "                logger.warning(\"Failed to run module API callback %s: %s\", callback, e)",
            "                continue",
            "",
            "            if result is not None:",
            "                # Check that the callback returned a Tuple[str, Optional[Callable]]",
            "                # \"type: ignore[unreachable]\" is used after some isinstance checks because mypy thinks",
            "                # result is always the right type, but as it is 3rd party code it might not be",
            "",
            "                if not isinstance(result, tuple) or len(result) != 2:",
            "                    logger.warning(",
            "                        \"Wrong type returned by module API callback %s: %s, expected\"",
            "                        \" Optional[Tuple[str, Optional[Callable]]]\",",
            "                        callback,",
            "                        result,",
            "                    )",
            "                    continue",
            "",
            "                # pull out the two parts of the tuple so we can do type checking",
            "                str_result, callback_result = result",
            "",
            "                # the 1st item in the tuple should be a str",
            "                if not isinstance(str_result, str):",
            "                    logger.warning(  # type: ignore[unreachable]",
            "                        \"Wrong type returned by module API callback %s: %s, expected\"",
            "                        \" Optional[Tuple[str, Optional[Callable]]]\",",
            "                        callback,",
            "                        result,",
            "                    )",
            "                    continue",
            "",
            "                # the second should be Optional[Callable]",
            "                if callback_result is not None:",
            "                    if not callable(callback_result):",
            "                        logger.warning(  # type: ignore[unreachable]",
            "                            \"Wrong type returned by module API callback %s: %s, expected\"",
            "                            \" Optional[Tuple[str, Optional[Callable]]]\",",
            "                            callback,",
            "                            result,",
            "                        )",
            "                        continue",
            "",
            "                # The result is a (str, Optional[callback]) tuple so return the successful result",
            "                return result",
            "",
            "        # If this point has been reached then none of the callbacks successfully authenticated",
            "        # the user so return None",
            "        return None",
            "",
            "    async def check_3pid_auth(",
            "        self, medium: str, address: str, password: str",
            "    ) -> Optional[Tuple[str, Optional[Callable[[\"LoginResponse\"], Awaitable[None]]]]]:",
            "        # This function is able to return a deferred that either",
            "        # resolves None, meaning authentication failure, or upon",
            "        # success, to a str (which is the user_id) or a tuple of",
            "        # (user_id, callback_func), where callback_func should be run",
            "        # after we've finished everything else",
            "",
            "        for callback in self.check_3pid_auth_callbacks:",
            "            try:",
            "                result = await delay_cancellation(callback(medium, address, password))",
            "            except CancelledError:",
            "                raise",
            "            except Exception as e:",
            "                logger.warning(\"Failed to run module API callback %s: %s\", callback, e)",
            "                continue",
            "",
            "            if result is not None:",
            "                # Check that the callback returned a Tuple[str, Optional[Callable]]",
            "                # \"type: ignore[unreachable]\" is used after some isinstance checks because mypy thinks",
            "                # result is always the right type, but as it is 3rd party code it might not be",
            "",
            "                if not isinstance(result, tuple) or len(result) != 2:",
            "                    logger.warning(",
            "                        \"Wrong type returned by module API callback %s: %s, expected\"",
            "                        \" Optional[Tuple[str, Optional[Callable]]]\",",
            "                        callback,",
            "                        result,",
            "                    )",
            "                    continue",
            "",
            "                # pull out the two parts of the tuple so we can do type checking",
            "                str_result, callback_result = result",
            "",
            "                # the 1st item in the tuple should be a str",
            "                if not isinstance(str_result, str):",
            "                    logger.warning(  # type: ignore[unreachable]",
            "                        \"Wrong type returned by module API callback %s: %s, expected\"",
            "                        \" Optional[Tuple[str, Optional[Callable]]]\",",
            "                        callback,",
            "                        result,",
            "                    )",
            "                    continue",
            "",
            "                # the second should be Optional[Callable]",
            "                if callback_result is not None:",
            "                    if not callable(callback_result):",
            "                        logger.warning(  # type: ignore[unreachable]",
            "                            \"Wrong type returned by module API callback %s: %s, expected\"",
            "                            \" Optional[Tuple[str, Optional[Callable]]]\",",
            "                            callback,",
            "                            result,",
            "                        )",
            "                        continue",
            "",
            "                # The result is a (str, Optional[callback]) tuple so return the successful result",
            "                return result",
            "",
            "        # If this point has been reached then none of the callbacks successfully authenticated",
            "        # the user so return None",
            "        return None",
            "",
            "    async def on_logged_out(",
            "        self, user_id: str, device_id: Optional[str], access_token: str",
            "    ) -> None:",
            "        # call all of the on_logged_out callbacks",
            "        for callback in self.on_logged_out_callbacks:",
            "            try:",
            "                await callback(user_id, device_id, access_token)",
            "            except Exception as e:",
            "                logger.warning(\"Failed to run module API callback %s: %s\", callback, e)",
            "                continue",
            "",
            "    async def get_username_for_registration(",
            "        self,",
            "        uia_results: JsonDict,",
            "        params: JsonDict,",
            "    ) -> Optional[str]:",
            "        \"\"\"Defines the username to use when registering the user, using the credentials",
            "        and parameters provided during the UIA flow.",
            "",
            "        Stops at the first callback that returns a string.",
            "",
            "        Args:",
            "            uia_results: The credentials provided during the UIA flow.",
            "            params: The parameters provided by the registration request.",
            "",
            "        Returns:",
            "            The localpart to use when registering this user, or None if no module",
            "            returned a localpart.",
            "        \"\"\"",
            "        for callback in self.get_username_for_registration_callbacks:",
            "            try:",
            "                res = await delay_cancellation(callback(uia_results, params))",
            "",
            "                if isinstance(res, str):",
            "                    return res",
            "                elif res is not None:",
            "                    # mypy complains that this line is unreachable because it assumes the",
            "                    # data returned by the module fits the expected type. We just want",
            "                    # to make sure this is the case.",
            "                    logger.warning(  # type: ignore[unreachable]",
            "                        \"Ignoring non-string value returned by\"",
            "                        \" get_username_for_registration callback %s: %s\",",
            "                        callback,",
            "                        res,",
            "                    )",
            "            except CancelledError:",
            "                raise",
            "            except Exception as e:",
            "                logger.error(",
            "                    \"Module raised an exception in get_username_for_registration: %s\",",
            "                    e,",
            "                )",
            "                raise SynapseError(code=500, msg=\"Internal Server Error\")",
            "",
            "        return None",
            "",
            "    async def get_displayname_for_registration(",
            "        self,",
            "        uia_results: JsonDict,",
            "        params: JsonDict,",
            "    ) -> Optional[str]:",
            "        \"\"\"Defines the display name to use when registering the user, using the",
            "        credentials and parameters provided during the UIA flow.",
            "",
            "        Stops at the first callback that returns a tuple containing at least one string.",
            "",
            "        Args:",
            "            uia_results: The credentials provided during the UIA flow.",
            "            params: The parameters provided by the registration request.",
            "",
            "        Returns:",
            "            A tuple which first element is the display name, and the second is an MXC URL",
            "            to the user's avatar.",
            "        \"\"\"",
            "        for callback in self.get_displayname_for_registration_callbacks:",
            "            try:",
            "                res = await delay_cancellation(callback(uia_results, params))",
            "",
            "                if isinstance(res, str):",
            "                    return res",
            "                elif res is not None:",
            "                    # mypy complains that this line is unreachable because it assumes the",
            "                    # data returned by the module fits the expected type. We just want",
            "                    # to make sure this is the case.",
            "                    logger.warning(  # type: ignore[unreachable]",
            "                        \"Ignoring non-string value returned by\"",
            "                        \" get_displayname_for_registration callback %s: %s\",",
            "                        callback,",
            "                        res,",
            "                    )",
            "            except CancelledError:",
            "                raise",
            "            except Exception as e:",
            "                logger.error(",
            "                    \"Module raised an exception in get_displayname_for_registration: %s\",",
            "                    e,",
            "                )",
            "                raise SynapseError(code=500, msg=\"Internal Server Error\")",
            "",
            "        return None",
            "",
            "    async def is_3pid_allowed(",
            "        self,",
            "        medium: str,",
            "        address: str,",
            "        registration: bool,",
            "    ) -> bool:",
            "        \"\"\"Check if the user can be allowed to bind a 3PID on this homeserver.",
            "",
            "        Args:",
            "            medium: The medium of the 3PID.",
            "            address: The address of the 3PID.",
            "            registration: Whether the 3PID is being bound when registering a new user.",
            "",
            "        Returns:",
            "            Whether the 3PID is allowed to be bound on this homeserver",
            "        \"\"\"",
            "        for callback in self.is_3pid_allowed_callbacks:",
            "            try:",
            "                res = await delay_cancellation(callback(medium, address, registration))",
            "",
            "                if res is False:",
            "                    return res",
            "                elif not isinstance(res, bool):",
            "                    # mypy complains that this line is unreachable because it assumes the",
            "                    # data returned by the module fits the expected type. We just want",
            "                    # to make sure this is the case.",
            "                    logger.warning(  # type: ignore[unreachable]",
            "                        \"Ignoring non-string value returned by\"",
            "                        \" is_3pid_allowed callback %s: %s\",",
            "                        callback,",
            "                        res,",
            "                    )",
            "            except CancelledError:",
            "                raise",
            "            except Exception as e:",
            "                logger.error(\"Module raised an exception in is_3pid_allowed: %s\", e)",
            "                raise SynapseError(code=500, msg=\"Internal Server Error\")",
            "",
            "        return True"
        ],
        "afterPatchFile": [
            "# Copyright 2014 - 2016 OpenMarket Ltd",
            "# Copyright 2017 Vector Creations Ltd",
            "# Copyright 2019 - 2020 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "import logging",
            "import time",
            "import unicodedata",
            "import urllib.parse",
            "from binascii import crc32",
            "from http import HTTPStatus",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    Awaitable,",
            "    Callable,",
            "    Dict,",
            "    Iterable,",
            "    List,",
            "    Mapping,",
            "    Optional,",
            "    Tuple,",
            "    Type,",
            "    Union,",
            "    cast,",
            ")",
            "",
            "import attr",
            "import bcrypt",
            "import unpaddedbase64",
            "from prometheus_client import Counter",
            "",
            "from twisted.internet.defer import CancelledError",
            "from twisted.web.server import Request",
            "",
            "from synapse.api.constants import LoginType",
            "from synapse.api.errors import (",
            "    AuthError,",
            "    Codes,",
            "    InteractiveAuthIncompleteError,",
            "    LoginError,",
            "    NotFoundError,",
            "    StoreError,",
            "    SynapseError,",
            ")",
            "from synapse.api.ratelimiting import Ratelimiter",
            "from synapse.handlers.ui_auth import (",
            "    INTERACTIVE_AUTH_CHECKERS,",
            "    UIAuthSessionDataConstants,",
            ")",
            "from synapse.handlers.ui_auth.checkers import UserInteractiveAuthChecker",
            "from synapse.http import get_request_user_agent",
            "from synapse.http.server import finish_request, respond_with_html",
            "from synapse.http.site import SynapseRequest",
            "from synapse.logging.context import defer_to_thread",
            "from synapse.metrics.background_process_metrics import run_as_background_process",
            "from synapse.storage.databases.main.registration import (",
            "    LoginTokenExpired,",
            "    LoginTokenLookupResult,",
            "    LoginTokenReused,",
            ")",
            "from synapse.types import JsonDict, Requester, UserID",
            "from synapse.util import stringutils as stringutils",
            "from synapse.util.async_helpers import delay_cancellation, maybe_awaitable",
            "from synapse.util.msisdn import phone_number_to_msisdn",
            "from synapse.util.stringutils import base62_encode",
            "from synapse.util.threepids import canonicalise_email",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.module_api import ModuleApi",
            "    from synapse.rest.client.login import LoginResponse",
            "    from synapse.server import HomeServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "INVALID_USERNAME_OR_PASSWORD = \"Invalid username or password\"",
            "",
            "invalid_login_token_counter = Counter(",
            "    \"synapse_user_login_invalid_login_tokens\",",
            "    \"Counts the number of rejected m.login.token on /login\",",
            "    [\"reason\"],",
            ")",
            "",
            "",
            "def convert_client_dict_legacy_fields_to_identifier(",
            "    submission: JsonDict,",
            ") -> Dict[str, str]:",
            "    \"\"\"",
            "    Convert a legacy-formatted login submission to an identifier dict.",
            "",
            "    Legacy login submissions (used in both login and user-interactive authentication)",
            "    provide user-identifying information at the top-level instead.",
            "",
            "    These are now deprecated and replaced with identifiers:",
            "    https://matrix.org/docs/spec/client_server/r0.6.1#identifier-types",
            "",
            "    Args:",
            "        submission: The client dict to convert",
            "",
            "    Returns:",
            "        The matching identifier dict",
            "",
            "    Raises:",
            "        SynapseError: If the format of the client dict is invalid",
            "    \"\"\"",
            "    identifier = submission.get(\"identifier\", {})",
            "",
            "    # Generate an m.id.user identifier if \"user\" parameter is present",
            "    user = submission.get(\"user\")",
            "    if user:",
            "        identifier = {\"type\": \"m.id.user\", \"user\": user}",
            "",
            "    # Generate an m.id.thirdparty identifier if \"medium\" and \"address\" parameters are present",
            "    medium = submission.get(\"medium\")",
            "    address = submission.get(\"address\")",
            "    if medium and address:",
            "        identifier = {",
            "            \"type\": \"m.id.thirdparty\",",
            "            \"medium\": medium,",
            "            \"address\": address,",
            "        }",
            "",
            "    # We've converted valid, legacy login submissions to an identifier. If the",
            "    # submission still doesn't have an identifier, it's invalid",
            "    if not identifier:",
            "        raise SynapseError(400, \"Invalid login submission\", Codes.INVALID_PARAM)",
            "",
            "    # Ensure the identifier has a type",
            "    if \"type\" not in identifier:",
            "        raise SynapseError(",
            "            400,",
            "            \"'identifier' dict has no key 'type'\",",
            "            errcode=Codes.MISSING_PARAM,",
            "        )",
            "",
            "    return identifier",
            "",
            "",
            "def login_id_phone_to_thirdparty(identifier: JsonDict) -> Dict[str, str]:",
            "    \"\"\"",
            "    Convert a phone login identifier type to a generic threepid identifier.",
            "",
            "    Args:",
            "        identifier: Login identifier dict of type 'm.id.phone'",
            "",
            "    Returns:",
            "        An equivalent m.id.thirdparty identifier dict",
            "    \"\"\"",
            "    if \"country\" not in identifier or (",
            "        # The specification requires a \"phone\" field, while Synapse used to require a \"number\"",
            "        # field. Accept both for backwards compatibility.",
            "        \"phone\" not in identifier",
            "        and \"number\" not in identifier",
            "    ):",
            "        raise SynapseError(",
            "            400, \"Invalid phone-type identifier\", errcode=Codes.INVALID_PARAM",
            "        )",
            "",
            "    # Accept both \"phone\" and \"number\" as valid keys in m.id.phone",
            "    phone_number = identifier.get(\"phone\", identifier[\"number\"])",
            "",
            "    # Convert user-provided phone number to a consistent representation",
            "    msisdn = phone_number_to_msisdn(identifier[\"country\"], phone_number)",
            "",
            "    return {",
            "        \"type\": \"m.id.thirdparty\",",
            "        \"medium\": \"msisdn\",",
            "        \"address\": msisdn,",
            "    }",
            "",
            "",
            "@attr.s(slots=True, auto_attribs=True)",
            "class SsoLoginExtraAttributes:",
            "    \"\"\"Data we track about SAML2 sessions\"\"\"",
            "",
            "    # time the session was created, in milliseconds",
            "    creation_time: int",
            "    extra_attributes: JsonDict",
            "",
            "",
            "class AuthHandler:",
            "    SESSION_EXPIRE_MS = 48 * 60 * 60 * 1000",
            "",
            "    def __init__(self, hs: \"HomeServer\"):",
            "        self.store = hs.get_datastores().main",
            "        self.auth = hs.get_auth()",
            "        self.auth_blocking = hs.get_auth_blocking()",
            "        self.clock = hs.get_clock()",
            "        self.checkers: Dict[str, UserInteractiveAuthChecker] = {}",
            "        for auth_checker_class in INTERACTIVE_AUTH_CHECKERS:",
            "            inst = auth_checker_class(hs)",
            "            if inst.is_enabled():",
            "                self.checkers[inst.AUTH_TYPE] = inst",
            "",
            "        self.bcrypt_rounds = hs.config.registration.bcrypt_rounds",
            "",
            "        self.password_auth_provider = hs.get_password_auth_provider()",
            "",
            "        self.hs = hs  # FIXME better possibility to access registrationHandler later?",
            "        self.macaroon_gen = hs.get_macaroon_generator()",
            "        self._password_enabled_for_login = hs.config.auth.password_enabled_for_login",
            "        self._password_enabled_for_reauth = hs.config.auth.password_enabled_for_reauth",
            "        self._password_localdb_enabled = hs.config.auth.password_localdb_enabled",
            "        self._third_party_rules = hs.get_module_api_callbacks().third_party_event_rules",
            "",
            "        # Ratelimiter for failed auth during UIA. Uses same ratelimit config",
            "        # as per `rc_login.failed_attempts`.",
            "        self._failed_uia_attempts_ratelimiter = Ratelimiter(",
            "            store=self.store,",
            "            clock=self.clock,",
            "            rate_hz=self.hs.config.ratelimiting.rc_login_failed_attempts.per_second,",
            "            burst_count=self.hs.config.ratelimiting.rc_login_failed_attempts.burst_count,",
            "        )",
            "",
            "        # The number of seconds to keep a UI auth session active.",
            "        self._ui_auth_session_timeout = hs.config.auth.ui_auth_session_timeout",
            "",
            "        # Ratelimitier for failed /login attempts",
            "        self._failed_login_attempts_ratelimiter = Ratelimiter(",
            "            store=self.store,",
            "            clock=hs.get_clock(),",
            "            rate_hz=self.hs.config.ratelimiting.rc_login_failed_attempts.per_second,",
            "            burst_count=self.hs.config.ratelimiting.rc_login_failed_attempts.burst_count,",
            "        )",
            "",
            "        self._clock = self.hs.get_clock()",
            "",
            "        # Expire old UI auth sessions after a period of time.",
            "        if hs.config.worker.run_background_tasks:",
            "            self._clock.looping_call(",
            "                run_as_background_process,",
            "                5 * 60 * 1000,",
            "                \"expire_old_sessions\",",
            "                self._expire_old_sessions,",
            "            )",
            "",
            "        # Load the SSO HTML templates.",
            "",
            "        # The following template is shown to the user during a client login via SSO,",
            "        # after the SSO completes and before redirecting them back to their client.",
            "        # It notifies the user they are about to give access to their matrix account",
            "        # to the client.",
            "        self._sso_redirect_confirm_template = (",
            "            hs.config.sso.sso_redirect_confirm_template",
            "        )",
            "",
            "        # The following template is shown during user interactive authentication",
            "        # in the fallback auth scenario. It notifies the user that they are",
            "        # authenticating for an operation to occur on their account.",
            "        self._sso_auth_confirm_template = hs.config.sso.sso_auth_confirm_template",
            "",
            "        # The following template is shown during the SSO authentication process if",
            "        # the account is deactivated.",
            "        self._sso_account_deactivated_template = (",
            "            hs.config.sso.sso_account_deactivated_template",
            "        )",
            "",
            "        self._server_name = hs.config.server.server_name",
            "",
            "        # cast to tuple for use with str.startswith",
            "        self._whitelisted_sso_clients = tuple(hs.config.sso.sso_client_whitelist)",
            "",
            "        # A mapping of user ID to extra attributes to include in the login",
            "        # response.",
            "        self._extra_attributes: Dict[str, SsoLoginExtraAttributes] = {}",
            "",
            "    async def validate_user_via_ui_auth(",
            "        self,",
            "        requester: Requester,",
            "        request: SynapseRequest,",
            "        request_body: Dict[str, Any],",
            "        description: str,",
            "        can_skip_ui_auth: bool = False,",
            "    ) -> Tuple[dict, Optional[str]]:",
            "        \"\"\"",
            "        Checks that the user is who they claim to be, via a UI auth.",
            "",
            "        This is used for things like device deletion and password reset where",
            "        the user already has a valid access token, but we want to double-check",
            "        that it isn't stolen by re-authenticating them.",
            "",
            "        Args:",
            "            requester: The user making the request, according to the access token.",
            "",
            "            request: The request sent by the client.",
            "",
            "            request_body: The body of the request sent by the client",
            "",
            "            description: A human readable string to be displayed to the user that",
            "                         describes the operation happening on their account.",
            "",
            "            can_skip_ui_auth: True if the UI auth session timeout applies this",
            "                              action. Should be set to False for any \"dangerous\"",
            "                              actions (e.g. deactivating an account).",
            "",
            "        Returns:",
            "            A tuple of (params, session_id).",
            "",
            "                'params' contains the parameters for this request (which may",
            "                have been given only in a previous call).",
            "",
            "                'session_id' is the ID of this session, either passed in by the",
            "                client or assigned by this call. This is None if UI auth was",
            "                skipped (by re-using a previous validation).",
            "",
            "        Raises:",
            "            InteractiveAuthIncompleteError if the client has not yet completed",
            "                any of the permitted login flows",
            "",
            "            AuthError if the client has completed a login flow, and it gives",
            "                a different user to `requester`",
            "",
            "            LimitExceededError if the ratelimiter's failed request count for this",
            "                user is too high to proceed",
            "",
            "        \"\"\"",
            "        if not requester.access_token_id:",
            "            raise ValueError(\"Cannot validate a user without an access token\")",
            "        if can_skip_ui_auth and self._ui_auth_session_timeout:",
            "            last_validated = await self.store.get_access_token_last_validated(",
            "                requester.access_token_id",
            "            )",
            "            if self.clock.time_msec() - last_validated < self._ui_auth_session_timeout:",
            "                # Return the input parameters, minus the auth key, which matches",
            "                # the logic in check_ui_auth.",
            "                request_body.pop(\"auth\", None)",
            "                return request_body, None",
            "",
            "        requester_user_id = requester.user.to_string()",
            "",
            "        # Check if we should be ratelimited due to too many previous failed attempts",
            "        await self._failed_uia_attempts_ratelimiter.ratelimit(requester, update=False)",
            "",
            "        # build a list of supported flows",
            "        supported_ui_auth_types = await self._get_available_ui_auth_types(",
            "            requester.user",
            "        )",
            "        flows = [[login_type] for login_type in supported_ui_auth_types]",
            "",
            "        def get_new_session_data() -> JsonDict:",
            "            return {UIAuthSessionDataConstants.REQUEST_USER_ID: requester_user_id}",
            "",
            "        try:",
            "            result, params, session_id = await self.check_ui_auth(",
            "                flows,",
            "                request,",
            "                request_body,",
            "                description,",
            "                get_new_session_data,",
            "            )",
            "        except LoginError:",
            "            # Update the ratelimiter to say we failed (`can_do_action` doesn't raise).",
            "            await self._failed_uia_attempts_ratelimiter.can_do_action(",
            "                requester,",
            "            )",
            "            raise",
            "",
            "        # find the completed login type",
            "        for login_type in supported_ui_auth_types:",
            "            if login_type not in result:",
            "                continue",
            "",
            "            validated_user_id = result[login_type]",
            "            break",
            "        else:",
            "            # this can't happen",
            "            raise Exception(\"check_auth returned True but no successful login type\")",
            "",
            "        # check that the UI auth matched the access token",
            "        if validated_user_id != requester_user_id:",
            "            raise AuthError(403, \"Invalid auth\")",
            "",
            "        # Note that the access token has been validated.",
            "        await self.store.update_access_token_last_validated(requester.access_token_id)",
            "",
            "        return params, session_id",
            "",
            "    async def _get_available_ui_auth_types(self, user: UserID) -> Iterable[str]:",
            "        \"\"\"Get a list of the user-interactive authentication types this user can use.\"\"\"",
            "",
            "        ui_auth_types = set()",
            "",
            "        # if the HS supports password auth, and the user has a non-null password, we",
            "        # support password auth",
            "        if self._password_localdb_enabled and self._password_enabled_for_reauth:",
            "            lookupres = await self._find_user_id_and_pwd_hash(user.to_string())",
            "            if lookupres:",
            "                _, password_hash = lookupres",
            "                if password_hash:",
            "                    ui_auth_types.add(LoginType.PASSWORD)",
            "",
            "        # also allow auth from password providers",
            "        for t in self.password_auth_provider.get_supported_login_types().keys():",
            "            if t == LoginType.PASSWORD and not self._password_enabled_for_reauth:",
            "                continue",
            "            ui_auth_types.add(t)",
            "",
            "        # if sso is enabled, allow the user to log in via SSO iff they have a mapping",
            "        # from sso to mxid.",
            "        if await self.hs.get_sso_handler().get_identity_providers_for_user(",
            "            user.to_string()",
            "        ):",
            "            ui_auth_types.add(LoginType.SSO)",
            "",
            "        return ui_auth_types",
            "",
            "    def get_enabled_auth_types(self) -> Iterable[str]:",
            "        \"\"\"Return the enabled user-interactive authentication types",
            "",
            "        Returns the UI-Auth types which are supported by the homeserver's current",
            "        config.",
            "        \"\"\"",
            "        return self.checkers.keys()",
            "",
            "    async def check_ui_auth(",
            "        self,",
            "        flows: List[List[str]],",
            "        request: SynapseRequest,",
            "        clientdict: Dict[str, Any],",
            "        description: str,",
            "        get_new_session_data: Optional[Callable[[], JsonDict]] = None,",
            "    ) -> Tuple[dict, dict, str]:",
            "        \"\"\"",
            "        Takes a dictionary sent by the client in the login / registration",
            "        protocol and handles the User-Interactive Auth flow.",
            "",
            "        If no auth flows have been completed successfully, raises an",
            "        InteractiveAuthIncompleteError. To handle this, you can use",
            "        synapse.rest.client._base.interactive_auth_handler as a",
            "        decorator.",
            "",
            "        Args:",
            "            flows: A list of login flows. Each flow is an ordered list of",
            "                   strings representing auth-types. At least one full",
            "                   flow must be completed in order for auth to be successful.",
            "",
            "            request: The request sent by the client.",
            "",
            "            clientdict: The dictionary from the client root level, not the",
            "                        'auth' key: this method prompts for auth if none is sent.",
            "",
            "            description: A human readable string to be displayed to the user that",
            "                         describes the operation happening on their account.",
            "",
            "            get_new_session_data:",
            "                an optional callback which will be called when starting a new session.",
            "                it should return data to be stored as part of the session.",
            "",
            "                The keys of the returned data should be entries in",
            "                UIAuthSessionDataConstants.",
            "",
            "        Returns:",
            "            A tuple of (creds, params, session_id).",
            "",
            "                'creds' contains the authenticated credentials of each stage.",
            "",
            "                'params' contains the parameters for this request (which may",
            "                have been given only in a previous call).",
            "",
            "                'session_id' is the ID of this session, either passed in by the",
            "                client or assigned by this call",
            "",
            "        Raises:",
            "            InteractiveAuthIncompleteError if the client has not yet completed",
            "                all the stages in any of the permitted flows.",
            "        \"\"\"",
            "",
            "        sid: Optional[str] = None",
            "        authdict = clientdict.pop(\"auth\", {})",
            "        if \"session\" in authdict:",
            "            sid = authdict[\"session\"]",
            "",
            "        # Convert the URI and method to strings.",
            "        uri = request.uri.decode(\"utf-8\")",
            "        method = request.method.decode(\"utf-8\")",
            "",
            "        # If there's no session ID, create a new session.",
            "        if not sid:",
            "            new_session_data = get_new_session_data() if get_new_session_data else {}",
            "",
            "            session = await self.store.create_ui_auth_session(",
            "                clientdict, uri, method, description",
            "            )",
            "",
            "            for k, v in new_session_data.items():",
            "                await self.set_session_data(session.session_id, k, v)",
            "",
            "        else:",
            "            try:",
            "                session = await self.store.get_ui_auth_session(sid)",
            "            except StoreError:",
            "                raise SynapseError(400, \"Unknown session ID: %s\" % (sid,))",
            "",
            "            # If the client provides parameters, update what is persisted,",
            "            # otherwise use whatever was last provided.",
            "            #",
            "            # This was designed to allow the client to omit the parameters",
            "            # and just supply the session in subsequent calls so it split",
            "            # auth between devices by just sharing the session, (eg. so you",
            "            # could continue registration from your phone having clicked the",
            "            # email auth link on there). It's probably too open to abuse",
            "            # because it lets unauthenticated clients store arbitrary objects",
            "            # on a homeserver.",
            "            #",
            "            # Revisit: Assuming the REST APIs do sensible validation, the data",
            "            # isn't arbitrary.",
            "            #",
            "            # Note that the registration endpoint explicitly removes the",
            "            # \"initial_device_display_name\" parameter if it is provided",
            "            # without a \"password\" parameter. See the changes to",
            "            # synapse.rest.client.register.RegisterRestServlet.on_POST",
            "            # in commit 544722bad23fc31056b9240189c3cbbbf0ffd3f9.",
            "            if not clientdict:",
            "                clientdict = session.clientdict",
            "",
            "            # Ensure that the queried operation does not vary between stages of",
            "            # the UI authentication session. This is done by generating a stable",
            "            # comparator and storing it during the initial query. Subsequent",
            "            # queries ensure that this comparator has not changed.",
            "            #",
            "            # The comparator is based on the requested URI and HTTP method. The",
            "            # client dict (minus the auth dict) should also be checked, but some",
            "            # clients are not spec compliant, just warn for now if the client",
            "            # dict changes.",
            "            if (session.uri, session.method) != (uri, method):",
            "                raise SynapseError(",
            "                    403,",
            "                    \"Requested operation has changed during the UI authentication session.\",",
            "                )",
            "",
            "            if session.clientdict != clientdict:",
            "                logger.warning(",
            "                    \"Requested operation has changed during the UI \"",
            "                    \"authentication session. A future version of Synapse \"",
            "                    \"will remove this capability.\"",
            "                )",
            "",
            "            # For backwards compatibility, changes to the client dict are",
            "            # persisted as clients modify them throughout their user interactive",
            "            # authentication flow.",
            "            await self.store.set_ui_auth_clientdict(sid, clientdict)",
            "",
            "        user_agent = get_request_user_agent(request)",
            "        clientip = request.getClientAddress().host",
            "",
            "        await self.store.add_user_agent_ip_to_ui_auth_session(",
            "            session.session_id, user_agent, clientip",
            "        )",
            "",
            "        if not authdict:",
            "            raise InteractiveAuthIncompleteError(",
            "                session.session_id, self._auth_dict_for_flows(flows, session.session_id)",
            "            )",
            "",
            "        # check auth type currently being presented",
            "        errordict: Dict[str, Any] = {}",
            "        if \"type\" in authdict:",
            "            login_type: str = authdict[\"type\"]",
            "            try:",
            "                result = await self._check_auth_dict(authdict, clientip)",
            "                if result:",
            "                    await self.store.mark_ui_auth_stage_complete(",
            "                        session.session_id, login_type, result",
            "                    )",
            "            except LoginError as e:",
            "                # this step failed. Merge the error dict into the response",
            "                # so that the client can have another go.",
            "                errordict = e.error_dict(self.hs.config)",
            "",
            "        creds = await self.store.get_completed_ui_auth_stages(session.session_id)",
            "        for f in flows:",
            "            # If all the required credentials have been supplied, the user has",
            "            # successfully completed the UI auth process!",
            "            if len(set(f) - set(creds)) == 0:",
            "                # it's very useful to know what args are stored, but this can",
            "                # include the password in the case of registering, so only log",
            "                # the keys (confusingly, clientdict may contain a password",
            "                # param, creds is just what the user authed as for UI auth",
            "                # and is not sensitive).",
            "                logger.info(",
            "                    \"Auth completed with creds: %r. Client dict has keys: %r\",",
            "                    creds,",
            "                    list(clientdict),",
            "                )",
            "",
            "                return creds, clientdict, session.session_id",
            "",
            "        ret = self._auth_dict_for_flows(flows, session.session_id)",
            "        ret[\"completed\"] = list(creds)",
            "        ret.update(errordict)",
            "        raise InteractiveAuthIncompleteError(session.session_id, ret)",
            "",
            "    async def add_oob_auth(",
            "        self, stagetype: str, authdict: Dict[str, Any], clientip: str",
            "    ) -> None:",
            "        \"\"\"",
            "        Adds the result of out-of-band authentication into an existing auth",
            "        session. Currently used for adding the result of fallback auth.",
            "",
            "        Raises:",
            "            LoginError if the stagetype is unknown or the session is missing.",
            "            LoginError is raised by check_auth if authentication fails.",
            "        \"\"\"",
            "        if stagetype not in self.checkers:",
            "            raise LoginError(",
            "                400, f\"Unknown UIA stage type: {stagetype}\", Codes.INVALID_PARAM",
            "            )",
            "        if \"session\" not in authdict:",
            "            raise LoginError(400, \"Missing session ID\", Codes.MISSING_PARAM)",
            "",
            "        # If authentication fails a LoginError is raised. Otherwise, store",
            "        # the successful result.",
            "        result = await self.checkers[stagetype].check_auth(authdict, clientip)",
            "        await self.store.mark_ui_auth_stage_complete(",
            "            authdict[\"session\"], stagetype, result",
            "        )",
            "",
            "    def get_session_id(self, clientdict: Dict[str, Any]) -> Optional[str]:",
            "        \"\"\"",
            "        Gets the session ID for a client given the client dictionary",
            "",
            "        Args:",
            "            clientdict: The dictionary sent by the client in the request",
            "",
            "        Returns:",
            "            The string session ID the client sent. If the client did",
            "                not send a session ID, returns None.",
            "        \"\"\"",
            "        sid = None",
            "        if clientdict and \"auth\" in clientdict:",
            "            authdict = clientdict[\"auth\"]",
            "            if \"session\" in authdict:",
            "                sid = authdict[\"session\"]",
            "        return sid",
            "",
            "    async def set_session_data(self, session_id: str, key: str, value: Any) -> None:",
            "        \"\"\"",
            "        Store a key-value pair into the sessions data associated with this",
            "        request. This data is stored server-side and cannot be modified by",
            "        the client.",
            "",
            "        Args:",
            "            session_id: The ID of this session as returned from check_auth",
            "            key: The key to store the data under. An entry from",
            "                UIAuthSessionDataConstants.",
            "            value: The data to store",
            "        \"\"\"",
            "        try:",
            "            await self.store.set_ui_auth_session_data(session_id, key, value)",
            "        except StoreError:",
            "            raise SynapseError(400, \"Unknown session ID: %s\" % (session_id,))",
            "",
            "    async def get_session_data(",
            "        self, session_id: str, key: str, default: Optional[Any] = None",
            "    ) -> Any:",
            "        \"\"\"",
            "        Retrieve data stored with set_session_data",
            "",
            "        Args:",
            "            session_id: The ID of this session as returned from check_auth",
            "            key: The key the data was stored under. An entry from",
            "                UIAuthSessionDataConstants.",
            "            default: Value to return if the key has not been set",
            "        \"\"\"",
            "        try:",
            "            return await self.store.get_ui_auth_session_data(session_id, key, default)",
            "        except StoreError:",
            "            raise SynapseError(400, \"Unknown session ID: %s\" % (session_id,))",
            "",
            "    async def _expire_old_sessions(self) -> None:",
            "        \"\"\"",
            "        Invalidate any user interactive authentication sessions that have expired.",
            "        \"\"\"",
            "        now = self._clock.time_msec()",
            "        expiration_time = now - self.SESSION_EXPIRE_MS",
            "        await self.store.delete_old_ui_auth_sessions(expiration_time)",
            "",
            "    async def _check_auth_dict(",
            "        self, authdict: Dict[str, Any], clientip: str",
            "    ) -> Union[Dict[str, Any], str]:",
            "        \"\"\"Attempt to validate the auth dict provided by a client",
            "",
            "        Args:",
            "            authdict: auth dict provided by the client",
            "            clientip: IP address of the client",
            "",
            "        Returns:",
            "            Result of the stage verification.",
            "",
            "        Raises:",
            "            StoreError if there was a problem accessing the database",
            "            SynapseError if there was a problem with the request",
            "            LoginError if there was an authentication problem.",
            "        \"\"\"",
            "        login_type = authdict[\"type\"]",
            "        checker = self.checkers.get(login_type)",
            "        if checker is not None:",
            "            res = await checker.check_auth(authdict, clientip=clientip)",
            "            return res",
            "",
            "        # fall back to the v1 login flow",
            "        canonical_id, _ = await self.validate_login(authdict, is_reauth=True)",
            "        return canonical_id",
            "",
            "    def _get_params_recaptcha(self) -> dict:",
            "        return {\"public_key\": self.hs.config.captcha.recaptcha_public_key}",
            "",
            "    def _get_params_terms(self) -> dict:",
            "        return {",
            "            \"policies\": {",
            "                \"privacy_policy\": {",
            "                    \"version\": self.hs.config.consent.user_consent_version,",
            "                    \"en\": {",
            "                        \"name\": self.hs.config.consent.user_consent_policy_name,",
            "                        \"url\": \"%s_matrix/consent?v=%s\"",
            "                        % (",
            "                            self.hs.config.server.public_baseurl,",
            "                            self.hs.config.consent.user_consent_version,",
            "                        ),",
            "                    },",
            "                }",
            "            }",
            "        }",
            "",
            "    def _auth_dict_for_flows(",
            "        self,",
            "        flows: List[List[str]],",
            "        session_id: str,",
            "    ) -> Dict[str, Any]:",
            "        public_flows = []",
            "        for f in flows:",
            "            public_flows.append(f)",
            "",
            "        get_params = {",
            "            LoginType.RECAPTCHA: self._get_params_recaptcha,",
            "            LoginType.TERMS: self._get_params_terms,",
            "        }",
            "",
            "        params: Dict[str, Any] = {}",
            "",
            "        for f in public_flows:",
            "            for stage in f:",
            "                if stage in get_params and stage not in params:",
            "                    params[stage] = get_params[stage]()",
            "",
            "        return {",
            "            \"session\": session_id,",
            "            \"flows\": [{\"stages\": f} for f in public_flows],",
            "            \"params\": params,",
            "        }",
            "",
            "    async def refresh_token(",
            "        self,",
            "        refresh_token: str,",
            "        access_token_valid_until_ms: Optional[int],",
            "        refresh_token_valid_until_ms: Optional[int],",
            "    ) -> Tuple[str, str, Optional[int]]:",
            "        \"\"\"",
            "        Consumes a refresh token and generate both a new access token and a new refresh token from it.",
            "",
            "        The consumed refresh token is considered invalid after the first use of the new access token or the new refresh token.",
            "",
            "        The lifetime of both the access token and refresh token will be capped so that they",
            "        do not exceed the session's ultimate expiry time, if applicable.",
            "",
            "        Args:",
            "            refresh_token: The token to consume.",
            "            access_token_valid_until_ms: The expiration timestamp of the new access token.",
            "                None if the access token does not expire.",
            "            refresh_token_valid_until_ms: The expiration timestamp of the new refresh token.",
            "                None if the refresh token does not expire.",
            "        Returns:",
            "            A tuple containing:",
            "              - the new access token",
            "              - the new refresh token",
            "              - the actual expiry time of the access token, which may be earlier than",
            "                `access_token_valid_until_ms`.",
            "        \"\"\"",
            "",
            "        # Verify the token signature first before looking up the token",
            "        if not self._verify_refresh_token(refresh_token):",
            "            raise SynapseError(",
            "                HTTPStatus.UNAUTHORIZED, \"invalid refresh token\", Codes.UNKNOWN_TOKEN",
            "            )",
            "",
            "        existing_token = await self.store.lookup_refresh_token(refresh_token)",
            "        if existing_token is None:",
            "            raise SynapseError(",
            "                HTTPStatus.UNAUTHORIZED,",
            "                \"refresh token does not exist\",",
            "                Codes.UNKNOWN_TOKEN,",
            "            )",
            "",
            "        if (",
            "            existing_token.has_next_access_token_been_used",
            "            or existing_token.has_next_refresh_token_been_refreshed",
            "        ):",
            "            raise SynapseError(",
            "                HTTPStatus.FORBIDDEN,",
            "                \"refresh token isn't valid anymore\",",
            "                Codes.FORBIDDEN,",
            "            )",
            "",
            "        now_ms = self._clock.time_msec()",
            "",
            "        if existing_token.expiry_ts is not None and existing_token.expiry_ts < now_ms:",
            "            raise SynapseError(",
            "                HTTPStatus.FORBIDDEN,",
            "                \"The supplied refresh token has expired\",",
            "                Codes.FORBIDDEN,",
            "            )",
            "",
            "        if existing_token.ultimate_session_expiry_ts is not None:",
            "            # This session has a bounded lifetime, even across refreshes.",
            "",
            "            if access_token_valid_until_ms is not None:",
            "                access_token_valid_until_ms = min(",
            "                    access_token_valid_until_ms,",
            "                    existing_token.ultimate_session_expiry_ts,",
            "                )",
            "            else:",
            "                access_token_valid_until_ms = existing_token.ultimate_session_expiry_ts",
            "",
            "            if refresh_token_valid_until_ms is not None:",
            "                refresh_token_valid_until_ms = min(",
            "                    refresh_token_valid_until_ms,",
            "                    existing_token.ultimate_session_expiry_ts,",
            "                )",
            "            else:",
            "                refresh_token_valid_until_ms = existing_token.ultimate_session_expiry_ts",
            "            if existing_token.ultimate_session_expiry_ts < now_ms:",
            "                raise SynapseError(",
            "                    HTTPStatus.FORBIDDEN,",
            "                    \"The session has expired and can no longer be refreshed\",",
            "                    Codes.FORBIDDEN,",
            "                )",
            "",
            "        (",
            "            new_refresh_token,",
            "            new_refresh_token_id,",
            "        ) = await self.create_refresh_token_for_user_id(",
            "            user_id=existing_token.user_id,",
            "            device_id=existing_token.device_id,",
            "            expiry_ts=refresh_token_valid_until_ms,",
            "            ultimate_session_expiry_ts=existing_token.ultimate_session_expiry_ts,",
            "        )",
            "        access_token = await self.create_access_token_for_user_id(",
            "            user_id=existing_token.user_id,",
            "            device_id=existing_token.device_id,",
            "            valid_until_ms=access_token_valid_until_ms,",
            "            refresh_token_id=new_refresh_token_id,",
            "        )",
            "        await self.store.replace_refresh_token(",
            "            existing_token.token_id, new_refresh_token_id",
            "        )",
            "        return access_token, new_refresh_token, access_token_valid_until_ms",
            "",
            "    def _verify_refresh_token(self, token: str) -> bool:",
            "        \"\"\"",
            "        Verifies the shape of a refresh token.",
            "",
            "        Args:",
            "            token: The refresh token to verify",
            "",
            "        Returns:",
            "            Whether the token has the right shape",
            "        \"\"\"",
            "        parts = token.split(\"_\", maxsplit=4)",
            "        if len(parts) != 4:",
            "            return False",
            "",
            "        type, localpart, rand, crc = parts",
            "",
            "        # Refresh tokens are prefixed by \"syr_\", let's check that",
            "        if type != \"syr\":",
            "            return False",
            "",
            "        # Check the CRC",
            "        base = f\"{type}_{localpart}_{rand}\"",
            "        expected_crc = base62_encode(crc32(base.encode(\"ascii\")), minwidth=6)",
            "        if crc != expected_crc:",
            "            return False",
            "",
            "        return True",
            "",
            "    async def create_login_token_for_user_id(",
            "        self,",
            "        user_id: str,",
            "        duration_ms: int = (2 * 60 * 1000),",
            "        auth_provider_id: Optional[str] = None,",
            "        auth_provider_session_id: Optional[str] = None,",
            "    ) -> str:",
            "        login_token = self.generate_login_token()",
            "        now = self._clock.time_msec()",
            "        expiry_ts = now + duration_ms",
            "        await self.store.add_login_token_to_user(",
            "            user_id=user_id,",
            "            token=login_token,",
            "            expiry_ts=expiry_ts,",
            "            auth_provider_id=auth_provider_id,",
            "            auth_provider_session_id=auth_provider_session_id,",
            "        )",
            "        return login_token",
            "",
            "    async def create_refresh_token_for_user_id(",
            "        self,",
            "        user_id: str,",
            "        device_id: str,",
            "        expiry_ts: Optional[int],",
            "        ultimate_session_expiry_ts: Optional[int],",
            "    ) -> Tuple[str, int]:",
            "        \"\"\"",
            "        Creates a new refresh token for the user with the given user ID.",
            "",
            "        Args:",
            "            user_id: canonical user ID",
            "            device_id: the device ID to associate with the token.",
            "            expiry_ts (milliseconds since the epoch): Time after which the",
            "                refresh token cannot be used.",
            "                If None, the refresh token never expires until it has been used.",
            "            ultimate_session_expiry_ts (milliseconds since the epoch):",
            "                Time at which the session will end and can not be extended any",
            "                further.",
            "                If None, the session can be refreshed indefinitely.",
            "",
            "        Returns:",
            "            The newly created refresh token and its ID in the database",
            "        \"\"\"",
            "        refresh_token = self.generate_refresh_token(UserID.from_string(user_id))",
            "        refresh_token_id = await self.store.add_refresh_token_to_user(",
            "            user_id=user_id,",
            "            token=refresh_token,",
            "            device_id=device_id,",
            "            expiry_ts=expiry_ts,",
            "            ultimate_session_expiry_ts=ultimate_session_expiry_ts,",
            "        )",
            "        return refresh_token, refresh_token_id",
            "",
            "    async def create_access_token_for_user_id(",
            "        self,",
            "        user_id: str,",
            "        device_id: Optional[str],",
            "        valid_until_ms: Optional[int],",
            "        puppets_user_id: Optional[str] = None,",
            "        is_appservice_ghost: bool = False,",
            "        refresh_token_id: Optional[int] = None,",
            "    ) -> str:",
            "        \"\"\"",
            "        Creates a new access token for the user with the given user ID.",
            "",
            "        The user is assumed to have been authenticated by some other",
            "        mechanism (e.g. CAS), and the user_id converted to the canonical case.",
            "",
            "        The device will be recorded in the table if it is not there already.",
            "",
            "        Args:",
            "            user_id: canonical User ID",
            "            device_id: the device ID to associate with the tokens.",
            "               None to leave the tokens unassociated with a device (deprecated:",
            "               we should always have a device ID)",
            "            valid_until_ms: when the token is valid until. None for",
            "                no expiry.",
            "            is_appservice_ghost: Whether the user is an application ghost user",
            "            refresh_token_id: the refresh token ID that will be associated with",
            "                this access token.",
            "        Returns:",
            "              The access token for the user's session.",
            "        Raises:",
            "            StoreError if there was a problem storing the token.",
            "        \"\"\"",
            "        fmt_expiry = \"\"",
            "        if valid_until_ms is not None:",
            "            fmt_expiry = time.strftime(",
            "                \" until %Y-%m-%d %H:%M:%S\", time.localtime(valid_until_ms / 1000.0)",
            "            )",
            "",
            "        if puppets_user_id:",
            "            logger.info(",
            "                \"Logging in user %s as %s%s\", user_id, puppets_user_id, fmt_expiry",
            "            )",
            "            target_user_id_obj = UserID.from_string(puppets_user_id)",
            "        else:",
            "            logger.info(",
            "                \"Logging in user %s on device %s%s\", user_id, device_id, fmt_expiry",
            "            )",
            "            target_user_id_obj = UserID.from_string(user_id)",
            "",
            "        if (",
            "            not is_appservice_ghost",
            "            or self.hs.config.appservice.track_appservice_user_ips",
            "        ):",
            "            await self.auth_blocking.check_auth_blocking(user_id)",
            "",
            "        access_token = self.generate_access_token(target_user_id_obj)",
            "        await self.store.add_access_token_to_user(",
            "            user_id=user_id,",
            "            token=access_token,",
            "            device_id=device_id,",
            "            valid_until_ms=valid_until_ms,",
            "            puppets_user_id=puppets_user_id,",
            "            refresh_token_id=refresh_token_id,",
            "        )",
            "",
            "        # the device *should* have been registered before we got here; however,",
            "        # it's possible we raced against a DELETE operation. The thing we",
            "        # really don't want is active access_tokens without a record of the",
            "        # device, so we double-check it here.",
            "        if device_id is not None:",
            "            if await self.store.get_device(user_id, device_id) is None:",
            "                await self.store.delete_access_token(access_token)",
            "                raise StoreError(400, \"Login raced against device deletion\")",
            "",
            "        return access_token",
            "",
            "    async def check_user_exists(self, user_id: str) -> Optional[str]:",
            "        \"\"\"",
            "        Checks to see if a user with the given id exists. Will check case",
            "        insensitively, but return None if there are multiple inexact matches.",
            "",
            "        Args:",
            "            user_id: complete @user:id",
            "",
            "        Returns:",
            "            The canonical_user_id, or None if zero or multiple matches",
            "        \"\"\"",
            "        res = await self._find_user_id_and_pwd_hash(user_id)",
            "        if res is not None:",
            "            return res[0]",
            "        return None",
            "",
            "    async def is_user_approved(self, user_id: str) -> bool:",
            "        \"\"\"Checks if a user is approved and therefore can be allowed to log in.",
            "",
            "        Args:",
            "            user_id: the user to check the approval status of.",
            "",
            "        Returns:",
            "            A boolean that is True if the user is approved, False otherwise.",
            "        \"\"\"",
            "        return await self.store.is_user_approved(user_id)",
            "",
            "    async def _find_user_id_and_pwd_hash(",
            "        self, user_id: str",
            "    ) -> Optional[Tuple[str, str]]:",
            "        \"\"\"Checks to see if a user with the given id exists. Will check case",
            "        insensitively, but will return None if there are multiple inexact",
            "        matches.",
            "",
            "        Returns:",
            "            A 2-tuple of `(canonical_user_id, password_hash)` or `None`",
            "            if there is not exactly one match",
            "        \"\"\"",
            "        user_infos = await self.store.get_users_by_id_case_insensitive(user_id)",
            "",
            "        result = None",
            "        if not user_infos:",
            "            logger.warning(\"Attempted to login as %s but they do not exist\", user_id)",
            "        elif len(user_infos) == 1:",
            "            # a single match (possibly not exact)",
            "            result = user_infos.popitem()",
            "        elif user_id in user_infos:",
            "            # multiple matches, but one is exact",
            "            result = (user_id, user_infos[user_id])",
            "        else:",
            "            # multiple matches, none of them exact",
            "            logger.warning(",
            "                \"Attempted to login as %s but it matches more than one user \"",
            "                \"inexactly: %r\",",
            "                user_id,",
            "                user_infos.keys(),",
            "            )",
            "        return result",
            "",
            "    def can_change_password(self) -> bool:",
            "        \"\"\"Get whether users on this server are allowed to change or set a password.",
            "",
            "        Both `config.auth.password_enabled` and `config.auth.password_localdb_enabled` must be true.",
            "",
            "        Note that any account (even SSO accounts) are allowed to add passwords if the above",
            "        is true.",
            "",
            "        Returns:",
            "            Whether users on this server are allowed to change or set a password",
            "        \"\"\"",
            "        return self._password_enabled_for_login and self._password_localdb_enabled",
            "",
            "    def get_supported_login_types(self) -> Iterable[str]:",
            "        \"\"\"Get a the login types supported for the /login API",
            "",
            "        By default this is just 'm.login.password' (unless password_enabled is",
            "        False in the config file), but password auth providers can provide",
            "        other login types.",
            "",
            "        Returns:",
            "            login types",
            "        \"\"\"",
            "        # Load any login types registered by modules",
            "        # This is stored in the password_auth_provider so this doesn't trigger",
            "        # any callbacks",
            "        types = list(self.password_auth_provider.get_supported_login_types().keys())",
            "",
            "        # This list should include PASSWORD if (either _password_localdb_enabled is",
            "        # true or if one of the modules registered it) AND _password_enabled is true",
            "        # Also:",
            "        # Some clients just pick the first type in the list. In this case, we want",
            "        # them to use PASSWORD (rather than token or whatever), so we want to make sure",
            "        # that comes first, where it's present.",
            "        if LoginType.PASSWORD in types:",
            "            types.remove(LoginType.PASSWORD)",
            "            if self._password_enabled_for_login:",
            "                types.insert(0, LoginType.PASSWORD)",
            "        elif self._password_localdb_enabled and self._password_enabled_for_login:",
            "            types.insert(0, LoginType.PASSWORD)",
            "",
            "        return types",
            "",
            "    async def validate_login(",
            "        self,",
            "        login_submission: Dict[str, Any],",
            "        ratelimit: bool = False,",
            "        is_reauth: bool = False,",
            "    ) -> Tuple[str, Optional[Callable[[\"LoginResponse\"], Awaitable[None]]]]:",
            "        \"\"\"Authenticates the user for the /login API",
            "",
            "        Also used by the user-interactive auth flow to validate auth types which don't",
            "        have an explicit UIA handler, including m.password.auth.",
            "",
            "        Args:",
            "            login_submission: the whole of the login submission",
            "                (including 'type' and other relevant fields)",
            "            ratelimit: whether to apply the failed_login_attempt ratelimiter",
            "            is_reauth: whether this is part of a User-Interactive Authorisation",
            "                flow to reauthenticate for a privileged action (rather than a",
            "                new login)",
            "        Returns:",
            "            A tuple of the canonical user id, and optional callback",
            "                to be called once the access token and device id are issued",
            "        Raises:",
            "            StoreError if there was a problem accessing the database",
            "            SynapseError if there was a problem with the request",
            "            LoginError if there was an authentication problem.",
            "        \"\"\"",
            "        login_type = login_submission.get(\"type\")",
            "        if not isinstance(login_type, str):",
            "            raise SynapseError(400, \"Bad parameter: type\", Codes.INVALID_PARAM)",
            "",
            "        # ideally, we wouldn't be checking the identifier unless we know we have a login",
            "        # method which uses it (https://github.com/matrix-org/synapse/issues/8836)",
            "        #",
            "        # But the auth providers' check_auth interface requires a username, so in",
            "        # practice we can only support login methods which we can map to a username",
            "        # anyway.",
            "",
            "        # special case to check for \"password\" for the check_password interface",
            "        # for the auth providers",
            "        password = login_submission.get(\"password\")",
            "",
            "        if login_type == LoginType.PASSWORD:",
            "            if is_reauth:",
            "                passwords_allowed_here = self._password_enabled_for_reauth",
            "            else:",
            "                passwords_allowed_here = self._password_enabled_for_login",
            "",
            "            if not passwords_allowed_here:",
            "                raise SynapseError(400, \"Password login has been disabled.\")",
            "            if not isinstance(password, str):",
            "                raise SynapseError(400, \"Bad parameter: password\", Codes.INVALID_PARAM)",
            "",
            "        # map old-school login fields into new-school \"identifier\" fields.",
            "        identifier_dict = convert_client_dict_legacy_fields_to_identifier(",
            "            login_submission",
            "        )",
            "",
            "        # convert phone type identifiers to generic threepids",
            "        if identifier_dict[\"type\"] == \"m.id.phone\":",
            "            identifier_dict = login_id_phone_to_thirdparty(identifier_dict)",
            "",
            "        # convert threepid identifiers to user IDs",
            "        if identifier_dict[\"type\"] == \"m.id.thirdparty\":",
            "            address = identifier_dict.get(\"address\")",
            "            medium = identifier_dict.get(\"medium\")",
            "",
            "            if medium is None or address is None:",
            "                raise SynapseError(400, \"Invalid thirdparty identifier\")",
            "",
            "            # For emails, canonicalise the address.",
            "            # We store all email addresses canonicalised in the DB.",
            "            # (See add_threepid in synapse/handlers/auth.py)",
            "            if medium == \"email\":",
            "                try:",
            "                    address = canonicalise_email(address)",
            "                except ValueError as e:",
            "                    raise SynapseError(400, str(e))",
            "",
            "            # We also apply account rate limiting using the 3PID as a key, as",
            "            # otherwise using 3PID bypasses the ratelimiting based on user ID.",
            "            if ratelimit:",
            "                await self._failed_login_attempts_ratelimiter.ratelimit(",
            "                    None, (medium, address), update=False",
            "                )",
            "",
            "            # Check for login providers that support 3pid login types",
            "            if login_type == LoginType.PASSWORD:",
            "                # we've already checked that there is a (valid) password field",
            "                assert isinstance(password, str)",
            "                (",
            "                    canonical_user_id,",
            "                    callback_3pid,",
            "                ) = await self.check_password_provider_3pid(medium, address, password)",
            "                if canonical_user_id:",
            "                    # Authentication through password provider and 3pid succeeded",
            "                    return canonical_user_id, callback_3pid",
            "",
            "            # No password providers were able to handle this 3pid",
            "            # Check local store",
            "            user_id = await self.hs.get_datastores().main.get_user_id_by_threepid(",
            "                medium, address",
            "            )",
            "            if not user_id:",
            "                logger.warning(",
            "                    \"unknown 3pid identifier medium %s, address %r\", medium, address",
            "                )",
            "                # We mark that we've failed to log in here, as",
            "                # `check_password_provider_3pid` might have returned `None` due",
            "                # to an incorrect password, rather than the account not",
            "                # existing.",
            "                #",
            "                # If it returned None but the 3PID was bound then we won't hit",
            "                # this code path, which is fine as then the per-user ratelimit",
            "                # will kick in below.",
            "                if ratelimit:",
            "                    await self._failed_login_attempts_ratelimiter.can_do_action(",
            "                        None, (medium, address)",
            "                    )",
            "                raise LoginError(",
            "                    403, msg=INVALID_USERNAME_OR_PASSWORD, errcode=Codes.FORBIDDEN",
            "                )",
            "",
            "            identifier_dict = {\"type\": \"m.id.user\", \"user\": user_id}",
            "",
            "        # by this point, the identifier should be an m.id.user: if it's anything",
            "        # else, we haven't understood it.",
            "        if identifier_dict[\"type\"] != \"m.id.user\":",
            "            raise SynapseError(400, \"Unknown login identifier type\")",
            "",
            "        username = identifier_dict.get(\"user\")",
            "        if not username:",
            "            raise SynapseError(400, \"User identifier is missing 'user' key\")",
            "",
            "        if username.startswith(\"@\"):",
            "            qualified_user_id = username",
            "        else:",
            "            qualified_user_id = UserID(username, self.hs.hostname).to_string()",
            "",
            "        # Check if we've hit the failed ratelimit (but don't update it)",
            "        if ratelimit:",
            "            await self._failed_login_attempts_ratelimiter.ratelimit(",
            "                None, qualified_user_id.lower(), update=False",
            "            )",
            "",
            "        try:",
            "            return await self._validate_userid_login(username, login_submission)",
            "        except LoginError:",
            "            # The user has failed to log in, so we need to update the rate",
            "            # limiter. Using `can_do_action` avoids us raising a ratelimit",
            "            # exception and masking the LoginError. The actual ratelimiting",
            "            # should have happened above.",
            "            if ratelimit:",
            "                await self._failed_login_attempts_ratelimiter.can_do_action(",
            "                    None, qualified_user_id.lower()",
            "                )",
            "            raise",
            "",
            "    async def _validate_userid_login(",
            "        self,",
            "        username: str,",
            "        login_submission: Dict[str, Any],",
            "    ) -> Tuple[str, Optional[Callable[[\"LoginResponse\"], Awaitable[None]]]]:",
            "        \"\"\"Helper for validate_login",
            "",
            "        Handles login, once we've mapped 3pids onto userids",
            "",
            "        Args:",
            "            username: the username, from the identifier dict",
            "            login_submission: the whole of the login submission",
            "                (including 'type' and other relevant fields)",
            "        Returns:",
            "            A tuple of the canonical user id, and optional callback",
            "                to be called once the access token and device id are issued",
            "        Raises:",
            "            StoreError if there was a problem accessing the database",
            "            SynapseError if there was a problem with the request",
            "            LoginError if there was an authentication problem.",
            "        \"\"\"",
            "        if username.startswith(\"@\"):",
            "            qualified_user_id = username",
            "        else:",
            "            qualified_user_id = UserID(username, self.hs.hostname).to_string()",
            "",
            "        login_type = login_submission.get(\"type\")",
            "        # we already checked that we have a valid login type",
            "        assert isinstance(login_type, str)",
            "",
            "        known_login_type = False",
            "",
            "        # Check if login_type matches a type registered by one of the modules",
            "        # We don't need to remove LoginType.PASSWORD from the list if password login is",
            "        # disabled, since if that were the case then by this point we know that the",
            "        # login_type is not LoginType.PASSWORD",
            "        supported_login_types = self.password_auth_provider.get_supported_login_types()",
            "        # check if the login type being used is supported by a module",
            "        if login_type in supported_login_types:",
            "            # Make a note that this login type is supported by the server",
            "            known_login_type = True",
            "            # Get all the fields expected for this login types",
            "            login_fields = supported_login_types[login_type]",
            "",
            "            # go through the login submission and keep track of which required fields are",
            "            # provided/not provided",
            "            missing_fields = []",
            "            login_dict = {}",
            "            for f in login_fields:",
            "                if f not in login_submission:",
            "                    missing_fields.append(f)",
            "                else:",
            "                    login_dict[f] = login_submission[f]",
            "            # raise an error if any of the expected fields for that login type weren't provided",
            "            if missing_fields:",
            "                raise SynapseError(",
            "                    400,",
            "                    \"Missing parameters for login type %s: %s\"",
            "                    % (login_type, missing_fields),",
            "                )",
            "",
            "            # call all of the check_auth hooks for that login_type",
            "            # it will return a result once the first success is found (or None otherwise)",
            "            result = await self.password_auth_provider.check_auth(",
            "                username, login_type, login_dict",
            "            )",
            "            if result:",
            "                return result",
            "",
            "        # if no module managed to authenticate the user, then fallback to built in password based auth",
            "        if login_type == LoginType.PASSWORD and self._password_localdb_enabled:",
            "            known_login_type = True",
            "",
            "            # we've already checked that there is a (valid) password field",
            "            password = login_submission[\"password\"]",
            "            assert isinstance(password, str)",
            "",
            "            canonical_user_id = await self._check_local_password(",
            "                qualified_user_id, password",
            "            )",
            "",
            "            if canonical_user_id:",
            "                return canonical_user_id, None",
            "",
            "        if not known_login_type:",
            "            raise SynapseError(400, \"Unknown login type %s\" % login_type)",
            "",
            "        # We raise a 403 here, but note that if we're doing user-interactive",
            "        # login, it turns all LoginErrors into a 401 anyway.",
            "        raise LoginError(403, msg=INVALID_USERNAME_OR_PASSWORD, errcode=Codes.FORBIDDEN)",
            "",
            "    async def check_password_provider_3pid(",
            "        self, medium: str, address: str, password: str",
            "    ) -> Tuple[Optional[str], Optional[Callable[[\"LoginResponse\"], Awaitable[None]]]]:",
            "        \"\"\"Check if a password provider is able to validate a thirdparty login",
            "",
            "        Args:",
            "            medium: The medium of the 3pid (ex. email).",
            "            address: The address of the 3pid (ex. jdoe@example.com).",
            "            password: The password of the user.",
            "",
            "        Returns:",
            "            A tuple of `(user_id, callback)`. If authentication is successful,",
            "            `user_id`is the authenticated, canonical user ID. `callback` is",
            "            then either a function to be later run after the server has",
            "            completed login/registration, or `None`. If authentication was",
            "            unsuccessful, `user_id` and `callback` are both `None`.",
            "        \"\"\"",
            "        # call all of the check_3pid_auth callbacks",
            "        # Result will be from the first callback that returns something other than None",
            "        # If all the callbacks return None, then result is also set to None",
            "        result = await self.password_auth_provider.check_3pid_auth(",
            "            medium, address, password",
            "        )",
            "        if result:",
            "            return result",
            "",
            "        # if result is None then return (None, None)",
            "        return None, None",
            "",
            "    async def _check_local_password(self, user_id: str, password: str) -> Optional[str]:",
            "        \"\"\"Authenticate a user against the local password database.",
            "",
            "        user_id is checked case insensitively, but will return None if there are",
            "        multiple inexact matches.",
            "",
            "        Args:",
            "            user_id: complete @user:id",
            "            password: the provided password",
            "        Returns:",
            "            The canonical_user_id, or None if unknown user/bad password",
            "        \"\"\"",
            "        lookupres = await self._find_user_id_and_pwd_hash(user_id)",
            "        if not lookupres:",
            "            return None",
            "        (user_id, password_hash) = lookupres",
            "",
            "        result = await self.validate_hash(password, password_hash)",
            "        if not result:",
            "            logger.warning(\"Failed password login for user %s\", user_id)",
            "            return None",
            "        return user_id",
            "",
            "    def generate_login_token(self) -> str:",
            "        \"\"\"Generates an opaque string, for use as an short-term login token\"\"\"",
            "",
            "        # we use the following format for access tokens:",
            "        #    syl_<random string>_<base62 crc check>",
            "",
            "        random_string = stringutils.random_string(20)",
            "        base = f\"syl_{random_string}\"",
            "",
            "        crc = base62_encode(crc32(base.encode(\"ascii\")), minwidth=6)",
            "        return f\"{base}_{crc}\"",
            "",
            "    def generate_access_token(self, for_user: UserID) -> str:",
            "        \"\"\"Generates an opaque string, for use as an access token\"\"\"",
            "",
            "        # we use the following format for access tokens:",
            "        #    syt_<base64 local part>_<random string>_<base62 crc check>",
            "",
            "        b64local = unpaddedbase64.encode_base64(for_user.localpart.encode(\"utf-8\"))",
            "        random_string = stringutils.random_string(20)",
            "        base = f\"syt_{b64local}_{random_string}\"",
            "",
            "        crc = base62_encode(crc32(base.encode(\"ascii\")), minwidth=6)",
            "        return f\"{base}_{crc}\"",
            "",
            "    def generate_refresh_token(self, for_user: UserID) -> str:",
            "        \"\"\"Generates an opaque string, for use as a refresh token\"\"\"",
            "",
            "        # we use the following format for refresh tokens:",
            "        #    syr_<base64 local part>_<random string>_<base62 crc check>",
            "",
            "        b64local = unpaddedbase64.encode_base64(for_user.localpart.encode(\"utf-8\"))",
            "        random_string = stringutils.random_string(20)",
            "        base = f\"syr_{b64local}_{random_string}\"",
            "",
            "        crc = base62_encode(crc32(base.encode(\"ascii\")), minwidth=6)",
            "        return f\"{base}_{crc}\"",
            "",
            "    async def consume_login_token(self, login_token: str) -> LoginTokenLookupResult:",
            "        try:",
            "            return await self.store.consume_login_token(login_token)",
            "        except LoginTokenExpired:",
            "            invalid_login_token_counter.labels(\"expired\").inc()",
            "        except LoginTokenReused:",
            "            invalid_login_token_counter.labels(\"reused\").inc()",
            "        except NotFoundError:",
            "            invalid_login_token_counter.labels(\"not found\").inc()",
            "",
            "        raise AuthError(403, \"Invalid login token\", errcode=Codes.FORBIDDEN)",
            "",
            "    async def delete_access_token(self, access_token: str) -> None:",
            "        \"\"\"Invalidate a single access token",
            "",
            "        Args:",
            "            access_token: access token to be deleted",
            "",
            "        \"\"\"",
            "        token = await self.store.get_user_by_access_token(access_token)",
            "        if not token:",
            "            # At this point, the token should already have been fetched once by",
            "            # the caller, so this should not happen, unless of a race condition",
            "            # between two delete requests",
            "            raise SynapseError(HTTPStatus.UNAUTHORIZED, \"Unrecognised access token\")",
            "        await self.store.delete_access_token(access_token)",
            "",
            "        # see if any modules want to know about this",
            "        await self.password_auth_provider.on_logged_out(",
            "            user_id=token.user_id,",
            "            device_id=token.device_id,",
            "            access_token=access_token,",
            "        )",
            "",
            "        # delete pushers associated with this access token",
            "        # XXX(quenting): This is only needed until the 'set_device_id_for_pushers'",
            "        # background update completes.",
            "        if token.token_id is not None:",
            "            await self.hs.get_pusherpool().remove_pushers_by_access_tokens(",
            "                token.user_id, (token.token_id,)",
            "            )",
            "",
            "    async def delete_access_tokens_for_user(",
            "        self,",
            "        user_id: str,",
            "        except_token_id: Optional[int] = None,",
            "        device_id: Optional[str] = None,",
            "    ) -> None:",
            "        \"\"\"Invalidate access tokens belonging to a user",
            "",
            "        Args:",
            "            user_id:  ID of user the tokens belong to",
            "            except_token_id: access_token ID which should *not* be deleted",
            "            device_id:  ID of device the tokens are associated with.",
            "                If None, tokens associated with any device (or no device) will",
            "                be deleted",
            "        \"\"\"",
            "        tokens_and_devices = await self.store.user_delete_access_tokens(",
            "            user_id, except_token_id=except_token_id, device_id=device_id",
            "        )",
            "",
            "        # see if any modules want to know about this",
            "        for token, _, device_id in tokens_and_devices:",
            "            await self.password_auth_provider.on_logged_out(",
            "                user_id=user_id, device_id=device_id, access_token=token",
            "            )",
            "",
            "        # delete pushers associated with the access tokens",
            "        # XXX(quenting): This is only needed until the 'set_device_id_for_pushers'",
            "        # background update completes.",
            "        await self.hs.get_pusherpool().remove_pushers_by_access_tokens(",
            "            user_id, (token_id for _, token_id, _ in tokens_and_devices)",
            "        )",
            "",
            "    async def add_threepid(",
            "        self, user_id: str, medium: str, address: str, validated_at: int",
            "    ) -> None:",
            "        \"\"\"",
            "        Adds an association between a user's Matrix ID and a third-party ID (email,",
            "        phone number).",
            "",
            "        Args:",
            "            user_id: The ID of the user to associate.",
            "            medium: The medium of the third-party ID (email, msisdn).",
            "            address: The address of the third-party ID (i.e. an email address).",
            "            validated_at: The timestamp in ms of when the validation that the user owns",
            "                this third-party ID occurred.",
            "        \"\"\"",
            "        # check if medium has a valid value",
            "        if medium not in [\"email\", \"msisdn\"]:",
            "            raise SynapseError(",
            "                code=400,",
            "                msg=(\"'%s' is not a valid value for 'medium'\" % (medium,)),",
            "                errcode=Codes.INVALID_PARAM,",
            "            )",
            "",
            "        # 'Canonicalise' email addresses down to lower case.",
            "        # We've now moving towards the homeserver being the entity that",
            "        # is responsible for validating threepids used for resetting passwords",
            "        # on accounts, so in future Synapse will gain knowledge of specific",
            "        # types (mediums) of threepid. For now, we still use the existing",
            "        # infrastructure, but this is the start of synapse gaining knowledge",
            "        # of specific types of threepid (and fixes the fact that checking",
            "        # for the presence of an email address during password reset was",
            "        # case sensitive).",
            "        if medium == \"email\":",
            "            address = canonicalise_email(address)",
            "",
            "        await self.store.user_add_threepid(",
            "            user_id, medium, address, validated_at, self.hs.get_clock().time_msec()",
            "        )",
            "",
            "        # Inform Synapse modules that a 3PID association has been created.",
            "        await self._third_party_rules.on_add_user_third_party_identifier(",
            "            user_id, medium, address",
            "        )",
            "",
            "        # Deprecated method for informing Synapse modules that a 3PID association",
            "        # has successfully been created.",
            "        await self._third_party_rules.on_threepid_bind(user_id, medium, address)",
            "",
            "    async def delete_local_threepid(",
            "        self, user_id: str, medium: str, address: str",
            "    ) -> None:",
            "        \"\"\"Deletes an association between a third-party ID and a user ID from the local",
            "        database. This method does not unbind the association from any identity servers.",
            "",
            "        If `medium` is 'email' and a pusher is associated with this third-party ID, the",
            "        pusher will also be deleted.",
            "",
            "        Args:",
            "            user_id: ID of user to remove the 3pid from.",
            "            medium: The medium of the 3pid being removed: \"email\" or \"msisdn\".",
            "            address: The 3pid address to remove.",
            "        \"\"\"",
            "        # 'Canonicalise' email addresses as per above",
            "        if medium == \"email\":",
            "            address = canonicalise_email(address)",
            "",
            "        await self.store.user_delete_threepid(user_id, medium, address)",
            "",
            "        # Inform Synapse modules that a 3PID association has been deleted.",
            "        await self._third_party_rules.on_remove_user_third_party_identifier(",
            "            user_id, medium, address",
            "        )",
            "",
            "        if medium == \"email\":",
            "            await self.store.delete_pusher_by_app_id_pushkey_user_id(",
            "                app_id=\"m.email\", pushkey=address, user_id=user_id",
            "            )",
            "",
            "    async def hash(self, password: str) -> str:",
            "        \"\"\"Computes a secure hash of password.",
            "",
            "        Args:",
            "            password: Password to hash.",
            "",
            "        Returns:",
            "            Hashed password.",
            "        \"\"\"",
            "",
            "        def _do_hash() -> str:",
            "            # Normalise the Unicode in the password",
            "            pw = unicodedata.normalize(\"NFKC\", password)",
            "",
            "            return bcrypt.hashpw(",
            "                pw.encode(\"utf8\") + self.hs.config.auth.password_pepper.encode(\"utf8\"),",
            "                bcrypt.gensalt(self.bcrypt_rounds),",
            "            ).decode(\"ascii\")",
            "",
            "        return await defer_to_thread(self.hs.get_reactor(), _do_hash)",
            "",
            "    async def validate_hash(",
            "        self, password: str, stored_hash: Union[bytes, str]",
            "    ) -> bool:",
            "        \"\"\"Validates that self.hash(password) == stored_hash.",
            "",
            "        Args:",
            "            password: Password to hash.",
            "            stored_hash: Expected hash value.",
            "",
            "        Returns:",
            "            Whether self.hash(password) == stored_hash.",
            "        \"\"\"",
            "",
            "        def _do_validate_hash(checked_hash: bytes) -> bool:",
            "            # Normalise the Unicode in the password",
            "            pw = unicodedata.normalize(\"NFKC\", password)",
            "",
            "            return bcrypt.checkpw(",
            "                pw.encode(\"utf8\") + self.hs.config.auth.password_pepper.encode(\"utf8\"),",
            "                checked_hash,",
            "            )",
            "",
            "        if stored_hash:",
            "            if not isinstance(stored_hash, bytes):",
            "                stored_hash = stored_hash.encode(\"ascii\")",
            "",
            "            return await defer_to_thread(",
            "                self.hs.get_reactor(), _do_validate_hash, stored_hash",
            "            )",
            "        else:",
            "            return False",
            "",
            "    async def start_sso_ui_auth(self, request: SynapseRequest, session_id: str) -> str:",
            "        \"\"\"",
            "        Get the HTML for the SSO redirect confirmation page.",
            "",
            "        Args:",
            "            request: The incoming HTTP request",
            "            session_id: The user interactive authentication session ID.",
            "",
            "        Returns:",
            "            The HTML to render.",
            "        \"\"\"",
            "        try:",
            "            session = await self.store.get_ui_auth_session(session_id)",
            "        except StoreError:",
            "            raise SynapseError(400, \"Unknown session ID: %s\" % (session_id,))",
            "",
            "        user_id_to_verify: str = await self.get_session_data(",
            "            session_id, UIAuthSessionDataConstants.REQUEST_USER_ID",
            "        )",
            "",
            "        idps = await self.hs.get_sso_handler().get_identity_providers_for_user(",
            "            user_id_to_verify",
            "        )",
            "",
            "        if not idps:",
            "            # we checked that the user had some remote identities before offering an SSO",
            "            # flow, so either it's been deleted or the client has requested SSO despite",
            "            # it not being offered.",
            "            raise SynapseError(400, \"User has no SSO identities\")",
            "",
            "        # for now, just pick one",
            "        idp_id, sso_auth_provider = next(iter(idps.items()))",
            "        if len(idps) > 0:",
            "            logger.warning(",
            "                \"User %r has previously logged in with multiple SSO IdPs; arbitrarily \"",
            "                \"picking %r\",",
            "                user_id_to_verify,",
            "                idp_id,",
            "            )",
            "",
            "        redirect_url = await sso_auth_provider.handle_redirect_request(",
            "            request, None, session_id",
            "        )",
            "",
            "        return self._sso_auth_confirm_template.render(",
            "            description=session.description,",
            "            redirect_url=redirect_url,",
            "            idp=sso_auth_provider,",
            "        )",
            "",
            "    async def complete_sso_login(",
            "        self,",
            "        registered_user_id: str,",
            "        auth_provider_id: str,",
            "        request: Request,",
            "        client_redirect_url: str,",
            "        extra_attributes: Optional[JsonDict] = None,",
            "        new_user: bool = False,",
            "        auth_provider_session_id: Optional[str] = None,",
            "    ) -> None:",
            "        \"\"\"Having figured out a mxid for this user, complete the HTTP request",
            "",
            "        Args:",
            "            registered_user_id: The registered user ID to complete SSO login for.",
            "            auth_provider_id: The id of the SSO Identity provider that was used for",
            "                login. This will be stored in the login token for future tracking in",
            "                prometheus metrics.",
            "            request: The request to complete.",
            "            client_redirect_url: The URL to which to redirect the user at the end of the",
            "                process.",
            "            extra_attributes: Extra attributes which will be passed to the client",
            "                during successful login. Must be JSON serializable.",
            "            new_user: True if we should use wording appropriate to a user who has just",
            "                registered.",
            "            auth_provider_session_id: The session ID from the SSO IdP received during login.",
            "        \"\"\"",
            "        # If the account has been deactivated, do not proceed with the login.",
            "        #",
            "        # This gets checked again when the token is submitted but this lets us",
            "        # provide an HTML error page to the user (instead of issuing a token and",
            "        # having it error later).",
            "        deactivated = await self.store.get_user_deactivated_status(registered_user_id)",
            "        if deactivated:",
            "            respond_with_html(request, 403, self._sso_account_deactivated_template)",
            "            return",
            "",
            "        user_profile_data = await self.store.get_profileinfo(",
            "            UserID.from_string(registered_user_id).localpart",
            "        )",
            "",
            "        # Store any extra attributes which will be passed in the login response.",
            "        # Note that this is per-user so it may overwrite a previous value, this",
            "        # is considered OK since the newest SSO attributes should be most valid.",
            "        if extra_attributes:",
            "            self._extra_attributes[registered_user_id] = SsoLoginExtraAttributes(",
            "                self._clock.time_msec(),",
            "                extra_attributes,",
            "            )",
            "",
            "        # Create a login token",
            "        login_token = await self.create_login_token_for_user_id(",
            "            registered_user_id,",
            "            auth_provider_id=auth_provider_id,",
            "            auth_provider_session_id=auth_provider_session_id,",
            "        )",
            "",
            "        # Append the login token to the original redirect URL (i.e. with its query",
            "        # parameters kept intact) to build the URL to which the template needs to",
            "        # redirect the users once they have clicked on the confirmation link.",
            "        redirect_url = self.add_query_param_to_url(",
            "            client_redirect_url, \"loginToken\", login_token",
            "        )",
            "",
            "        # if the client is whitelisted, we can redirect straight to it",
            "        if client_redirect_url.startswith(self._whitelisted_sso_clients):",
            "            request.redirect(redirect_url)",
            "            finish_request(request)",
            "            return",
            "",
            "        # Otherwise, serve the redirect confirmation page.",
            "",
            "        # Remove the query parameters from the redirect URL to get a shorter version of",
            "        # it. This is only to display a human-readable URL in the template, but not the",
            "        # URL we redirect users to.",
            "        url_parts = urllib.parse.urlsplit(client_redirect_url)",
            "",
            "        if url_parts.scheme == \"https\":",
            "            # for an https uri, just show the netloc (ie, the hostname. Specifically,",
            "            # the bit between \"//\" and \"/\"; this includes any potential",
            "            # \"username:password@\" prefix.)",
            "            display_url = url_parts.netloc",
            "        else:",
            "            # for other uris, strip the query-params (including the login token) and",
            "            # fragment.",
            "            display_url = urllib.parse.urlunsplit(",
            "                (url_parts.scheme, url_parts.netloc, url_parts.path, \"\", \"\")",
            "            )",
            "",
            "        html = self._sso_redirect_confirm_template.render(",
            "            display_url=display_url,",
            "            redirect_url=redirect_url,",
            "            server_name=self._server_name,",
            "            new_user=new_user,",
            "            user_id=registered_user_id,",
            "            user_profile=user_profile_data,",
            "        )",
            "        respond_with_html(request, 200, html)",
            "",
            "    async def _sso_login_callback(self, login_result: \"LoginResponse\") -> None:",
            "        \"\"\"",
            "        A login callback which might add additional attributes to the login response.",
            "",
            "        Args:",
            "            login_result: The data to be sent to the client. Includes the user",
            "                ID and access token.",
            "        \"\"\"",
            "        # Expire attributes before processing. Note that there shouldn't be any",
            "        # valid logins that still have extra attributes.",
            "        self._expire_sso_extra_attributes()",
            "",
            "        extra_attributes = self._extra_attributes.get(login_result[\"user_id\"])",
            "        if extra_attributes:",
            "            login_result_dict = cast(Dict[str, Any], login_result)",
            "            login_result_dict.update(extra_attributes.extra_attributes)",
            "",
            "    def _expire_sso_extra_attributes(self) -> None:",
            "        \"\"\"",
            "        Iterate through the mapping of user IDs to extra attributes and remove any that are no longer valid.",
            "        \"\"\"",
            "        # TODO This should match the amount of time the macaroon is valid for.",
            "        LOGIN_TOKEN_EXPIRATION_TIME = 2 * 60 * 1000",
            "        expire_before = self._clock.time_msec() - LOGIN_TOKEN_EXPIRATION_TIME",
            "        to_expire = set()",
            "        for user_id, data in self._extra_attributes.items():",
            "            if data.creation_time < expire_before:",
            "                to_expire.add(user_id)",
            "        for user_id in to_expire:",
            "            logger.debug(\"Expiring extra attributes for user %s\", user_id)",
            "            del self._extra_attributes[user_id]",
            "",
            "    @staticmethod",
            "    def add_query_param_to_url(url: str, param_name: str, param: Any) -> str:",
            "        url_parts = list(urllib.parse.urlparse(url))",
            "        query = urllib.parse.parse_qsl(url_parts[4], keep_blank_values=True)",
            "        query.append((param_name, param))",
            "        url_parts[4] = urllib.parse.urlencode(query)",
            "        return urllib.parse.urlunparse(url_parts)",
            "",
            "",
            "def load_legacy_password_auth_providers(hs: \"HomeServer\") -> None:",
            "    module_api = hs.get_module_api()",
            "    for module, config in hs.config.authproviders.password_providers:",
            "        load_single_legacy_password_auth_provider(",
            "            module=module, config=config, api=module_api",
            "        )",
            "",
            "",
            "def load_single_legacy_password_auth_provider(",
            "    module: Type,",
            "    config: JsonDict,",
            "    api: \"ModuleApi\",",
            ") -> None:",
            "    try:",
            "        provider = module(config=config, account_handler=api)",
            "    except Exception as e:",
            "        logger.error(\"Error while initializing %r: %s\", module, e)",
            "        raise",
            "",
            "    # All methods that the module provides should be async, but this wasn't enforced",
            "    # in the old module system, so we wrap them if needed",
            "    def async_wrapper(f: Optional[Callable]) -> Optional[Callable[..., Awaitable]]:",
            "        # f might be None if the callback isn't implemented by the module. In this",
            "        # case we don't want to register a callback at all so we return None.",
            "        if f is None:",
            "            return None",
            "",
            "        # We need to wrap check_password because its old form would return a boolean",
            "        # but we now want it to behave just like check_auth() and return the matrix id of",
            "        # the user if authentication succeeded or None otherwise",
            "        if f.__name__ == \"check_password\":",
            "",
            "            async def wrapped_check_password(",
            "                username: str, login_type: str, login_dict: JsonDict",
            "            ) -> Optional[Tuple[str, Optional[Callable]]]:",
            "                # We've already made sure f is not None above, but mypy doesn't do well",
            "                # across function boundaries so we need to tell it f is definitely not",
            "                # None.",
            "                assert f is not None",
            "",
            "                matrix_user_id = api.get_qualified_user_id(username)",
            "                password = login_dict[\"password\"]",
            "",
            "                is_valid = await f(matrix_user_id, password)",
            "",
            "                if is_valid:",
            "                    return matrix_user_id, None",
            "",
            "                return None",
            "",
            "            return wrapped_check_password",
            "",
            "        # We need to wrap check_auth as in the old form it could return",
            "        # just a str, but now it must return Optional[Tuple[str, Optional[Callable]]",
            "        if f.__name__ == \"check_auth\":",
            "",
            "            async def wrapped_check_auth(",
            "                username: str, login_type: str, login_dict: JsonDict",
            "            ) -> Optional[Tuple[str, Optional[Callable]]]:",
            "                # We've already made sure f is not None above, but mypy doesn't do well",
            "                # across function boundaries so we need to tell it f is definitely not",
            "                # None.",
            "                assert f is not None",
            "",
            "                result = await f(username, login_type, login_dict)",
            "",
            "                if isinstance(result, str):",
            "                    return result, None",
            "",
            "                return result",
            "",
            "            return wrapped_check_auth",
            "",
            "        # We need to wrap check_3pid_auth as in the old form it could return",
            "        # just a str, but now it must return Optional[Tuple[str, Optional[Callable]]",
            "        if f.__name__ == \"check_3pid_auth\":",
            "",
            "            async def wrapped_check_3pid_auth(",
            "                medium: str, address: str, password: str",
            "            ) -> Optional[Tuple[str, Optional[Callable]]]:",
            "                # We've already made sure f is not None above, but mypy doesn't do well",
            "                # across function boundaries so we need to tell it f is definitely not",
            "                # None.",
            "                assert f is not None",
            "",
            "                result = await f(medium, address, password)",
            "",
            "                if isinstance(result, str):",
            "                    return result, None",
            "",
            "                return result",
            "",
            "            return wrapped_check_3pid_auth",
            "",
            "        def run(*args: Tuple, **kwargs: Dict) -> Awaitable:",
            "            # mypy doesn't do well across function boundaries so we need to tell it",
            "            # f is definitely not None.",
            "            assert f is not None",
            "",
            "            return maybe_awaitable(f(*args, **kwargs))",
            "",
            "        return run",
            "",
            "    # If the module has these methods implemented, then we pull them out",
            "    # and register them as hooks.",
            "    check_3pid_auth_hook: Optional[CHECK_3PID_AUTH_CALLBACK] = async_wrapper(",
            "        getattr(provider, \"check_3pid_auth\", None)",
            "    )",
            "    on_logged_out_hook: Optional[ON_LOGGED_OUT_CALLBACK] = async_wrapper(",
            "        getattr(provider, \"on_logged_out\", None)",
            "    )",
            "",
            "    supported_login_types = {}",
            "    # call get_supported_login_types and add that to the dict",
            "    g = getattr(provider, \"get_supported_login_types\", None)",
            "    if g is not None:",
            "        # Note the old module style also called get_supported_login_types at loading time",
            "        # and it is synchronous",
            "        supported_login_types.update(g())",
            "",
            "    auth_checkers = {}",
            "    # Legacy modules have a check_auth method which expects to be called with one of",
            "    # the keys returned by get_supported_login_types. New style modules register a",
            "    # dictionary of login_type->check_auth_method mappings",
            "    check_auth = async_wrapper(getattr(provider, \"check_auth\", None))",
            "    if check_auth is not None:",
            "        for login_type, fields in supported_login_types.items():",
            "            # need tuple(fields) since fields can be any Iterable type (so may not be hashable)",
            "            auth_checkers[(login_type, tuple(fields))] = check_auth",
            "",
            "    # if it has a \"check_password\" method then it should handle all auth checks",
            "    # with login type of LoginType.PASSWORD",
            "    check_password = async_wrapper(getattr(provider, \"check_password\", None))",
            "    if check_password is not None:",
            "        # need to use a tuple here for (\"password\",) not a list since lists aren't hashable",
            "        auth_checkers[(LoginType.PASSWORD, (\"password\",))] = check_password",
            "",
            "    api.register_password_auth_provider_callbacks(",
            "        check_3pid_auth=check_3pid_auth_hook,",
            "        on_logged_out=on_logged_out_hook,",
            "        auth_checkers=auth_checkers,",
            "    )",
            "",
            "",
            "CHECK_3PID_AUTH_CALLBACK = Callable[",
            "    [str, str, str],",
            "    Awaitable[",
            "        Optional[Tuple[str, Optional[Callable[[\"LoginResponse\"], Awaitable[None]]]]]",
            "    ],",
            "]",
            "ON_LOGGED_OUT_CALLBACK = Callable[[str, Optional[str], str], Awaitable]",
            "CHECK_AUTH_CALLBACK = Callable[",
            "    [str, str, JsonDict],",
            "    Awaitable[",
            "        Optional[Tuple[str, Optional[Callable[[\"LoginResponse\"], Awaitable[None]]]]]",
            "    ],",
            "]",
            "GET_USERNAME_FOR_REGISTRATION_CALLBACK = Callable[",
            "    [JsonDict, JsonDict],",
            "    Awaitable[Optional[str]],",
            "]",
            "GET_DISPLAYNAME_FOR_REGISTRATION_CALLBACK = Callable[",
            "    [JsonDict, JsonDict],",
            "    Awaitable[Optional[str]],",
            "]",
            "IS_3PID_ALLOWED_CALLBACK = Callable[[str, str, bool], Awaitable[bool]]",
            "",
            "",
            "class PasswordAuthProvider:",
            "    \"\"\"",
            "    A class that the AuthHandler calls when authenticating users",
            "    It allows modules to provide alternative methods for authentication",
            "    \"\"\"",
            "",
            "    def __init__(self) -> None:",
            "        # lists of callbacks",
            "        self.check_3pid_auth_callbacks: List[CHECK_3PID_AUTH_CALLBACK] = []",
            "        self.on_logged_out_callbacks: List[ON_LOGGED_OUT_CALLBACK] = []",
            "        self.get_username_for_registration_callbacks: List[",
            "            GET_USERNAME_FOR_REGISTRATION_CALLBACK",
            "        ] = []",
            "        self.get_displayname_for_registration_callbacks: List[",
            "            GET_DISPLAYNAME_FOR_REGISTRATION_CALLBACK",
            "        ] = []",
            "        self.is_3pid_allowed_callbacks: List[IS_3PID_ALLOWED_CALLBACK] = []",
            "",
            "        # Mapping from login type to login parameters",
            "        self._supported_login_types: Dict[str, Tuple[str, ...]] = {}",
            "",
            "        # Mapping from login type to auth checker callbacks",
            "        self.auth_checker_callbacks: Dict[str, List[CHECK_AUTH_CALLBACK]] = {}",
            "",
            "    def register_password_auth_provider_callbacks(",
            "        self,",
            "        check_3pid_auth: Optional[CHECK_3PID_AUTH_CALLBACK] = None,",
            "        on_logged_out: Optional[ON_LOGGED_OUT_CALLBACK] = None,",
            "        is_3pid_allowed: Optional[IS_3PID_ALLOWED_CALLBACK] = None,",
            "        auth_checkers: Optional[",
            "            Dict[Tuple[str, Tuple[str, ...]], CHECK_AUTH_CALLBACK]",
            "        ] = None,",
            "        get_username_for_registration: Optional[",
            "            GET_USERNAME_FOR_REGISTRATION_CALLBACK",
            "        ] = None,",
            "        get_displayname_for_registration: Optional[",
            "            GET_DISPLAYNAME_FOR_REGISTRATION_CALLBACK",
            "        ] = None,",
            "    ) -> None:",
            "        # Register check_3pid_auth callback",
            "        if check_3pid_auth is not None:",
            "            self.check_3pid_auth_callbacks.append(check_3pid_auth)",
            "",
            "        # register on_logged_out callback",
            "        if on_logged_out is not None:",
            "            self.on_logged_out_callbacks.append(on_logged_out)",
            "",
            "        if auth_checkers is not None:",
            "            # register a new supported login_type",
            "            # Iterate through all of the types being registered",
            "            for (login_type, fields), callback in auth_checkers.items():",
            "                # Note: fields may be empty here. This would allow a modules auth checker to",
            "                # be called with just 'login_type' and no password or other secrets",
            "",
            "                # Need to check that all the field names are strings or may get nasty errors later",
            "                for f in fields:",
            "                    if not isinstance(f, str):",
            "                        raise RuntimeError(",
            "                            \"A module tried to register support for login type: %s with parameters %s\"",
            "                            \" but all parameter names must be strings\"",
            "                            % (login_type, fields)",
            "                        )",
            "",
            "                # 2 modules supporting the same login type must expect the same fields",
            "                # e.g. 1 can't expect \"pass\" if the other expects \"password\"",
            "                # so throw an exception if that happens",
            "                if login_type not in self._supported_login_types.get(login_type, []):",
            "                    self._supported_login_types[login_type] = fields",
            "                else:",
            "                    fields_currently_supported = self._supported_login_types.get(",
            "                        login_type",
            "                    )",
            "                    if fields_currently_supported != fields:",
            "                        raise RuntimeError(",
            "                            \"A module tried to register support for login type: %s with parameters %s\"",
            "                            \" but another module had already registered support for that type with parameters %s\"",
            "                            % (login_type, fields, fields_currently_supported)",
            "                        )",
            "",
            "                # Add the new method to the list of auth_checker_callbacks for this login type",
            "                self.auth_checker_callbacks.setdefault(login_type, []).append(callback)",
            "",
            "        if get_username_for_registration is not None:",
            "            self.get_username_for_registration_callbacks.append(",
            "                get_username_for_registration,",
            "            )",
            "",
            "        if get_displayname_for_registration is not None:",
            "            self.get_displayname_for_registration_callbacks.append(",
            "                get_displayname_for_registration,",
            "            )",
            "",
            "        if is_3pid_allowed is not None:",
            "            self.is_3pid_allowed_callbacks.append(is_3pid_allowed)",
            "",
            "    def get_supported_login_types(self) -> Mapping[str, Iterable[str]]:",
            "        \"\"\"Get the login types supported by this password provider",
            "",
            "        Returns a map from a login type identifier (such as m.login.password) to an",
            "        iterable giving the fields which must be provided by the user in the submission",
            "        to the /login API.",
            "        \"\"\"",
            "",
            "        return self._supported_login_types",
            "",
            "    async def check_auth(",
            "        self, username: str, login_type: str, login_dict: JsonDict",
            "    ) -> Optional[Tuple[str, Optional[Callable[[\"LoginResponse\"], Awaitable[None]]]]]:",
            "        \"\"\"Check if the user has presented valid login credentials",
            "",
            "        Args:",
            "            username: user id presented by the client. Either an MXID or an unqualified",
            "                username.",
            "",
            "            login_type: the login type being attempted - one of the types returned by",
            "                get_supported_login_types()",
            "",
            "            login_dict: the dictionary of login secrets passed by the client.",
            "",
            "        Returns: (user_id, callback) where `user_id` is the fully-qualified mxid of the",
            "            user, and `callback` is an optional callback which will be called with the",
            "            result from the /login call (including access_token, device_id, etc.)",
            "        \"\"\"",
            "",
            "        # Go through all callbacks for the login type until one returns with a value",
            "        # other than None (i.e. until a callback returns a success)",
            "        for callback in self.auth_checker_callbacks[login_type]:",
            "            try:",
            "                result = await delay_cancellation(",
            "                    callback(username, login_type, login_dict)",
            "                )",
            "            except CancelledError:",
            "                raise",
            "            except Exception as e:",
            "                logger.warning(\"Failed to run module API callback %s: %s\", callback, e)",
            "                continue",
            "",
            "            if result is not None:",
            "                # Check that the callback returned a Tuple[str, Optional[Callable]]",
            "                # \"type: ignore[unreachable]\" is used after some isinstance checks because mypy thinks",
            "                # result is always the right type, but as it is 3rd party code it might not be",
            "",
            "                if not isinstance(result, tuple) or len(result) != 2:",
            "                    logger.warning(",
            "                        \"Wrong type returned by module API callback %s: %s, expected\"",
            "                        \" Optional[Tuple[str, Optional[Callable]]]\",",
            "                        callback,",
            "                        result,",
            "                    )",
            "                    continue",
            "",
            "                # pull out the two parts of the tuple so we can do type checking",
            "                str_result, callback_result = result",
            "",
            "                # the 1st item in the tuple should be a str",
            "                if not isinstance(str_result, str):",
            "                    logger.warning(  # type: ignore[unreachable]",
            "                        \"Wrong type returned by module API callback %s: %s, expected\"",
            "                        \" Optional[Tuple[str, Optional[Callable]]]\",",
            "                        callback,",
            "                        result,",
            "                    )",
            "                    continue",
            "",
            "                # the second should be Optional[Callable]",
            "                if callback_result is not None:",
            "                    if not callable(callback_result):",
            "                        logger.warning(  # type: ignore[unreachable]",
            "                            \"Wrong type returned by module API callback %s: %s, expected\"",
            "                            \" Optional[Tuple[str, Optional[Callable]]]\",",
            "                            callback,",
            "                            result,",
            "                        )",
            "                        continue",
            "",
            "                # The result is a (str, Optional[callback]) tuple so return the successful result",
            "                return result",
            "",
            "        # If this point has been reached then none of the callbacks successfully authenticated",
            "        # the user so return None",
            "        return None",
            "",
            "    async def check_3pid_auth(",
            "        self, medium: str, address: str, password: str",
            "    ) -> Optional[Tuple[str, Optional[Callable[[\"LoginResponse\"], Awaitable[None]]]]]:",
            "        # This function is able to return a deferred that either",
            "        # resolves None, meaning authentication failure, or upon",
            "        # success, to a str (which is the user_id) or a tuple of",
            "        # (user_id, callback_func), where callback_func should be run",
            "        # after we've finished everything else",
            "",
            "        for callback in self.check_3pid_auth_callbacks:",
            "            try:",
            "                result = await delay_cancellation(callback(medium, address, password))",
            "            except CancelledError:",
            "                raise",
            "            except Exception as e:",
            "                logger.warning(\"Failed to run module API callback %s: %s\", callback, e)",
            "                continue",
            "",
            "            if result is not None:",
            "                # Check that the callback returned a Tuple[str, Optional[Callable]]",
            "                # \"type: ignore[unreachable]\" is used after some isinstance checks because mypy thinks",
            "                # result is always the right type, but as it is 3rd party code it might not be",
            "",
            "                if not isinstance(result, tuple) or len(result) != 2:",
            "                    logger.warning(",
            "                        \"Wrong type returned by module API callback %s: %s, expected\"",
            "                        \" Optional[Tuple[str, Optional[Callable]]]\",",
            "                        callback,",
            "                        result,",
            "                    )",
            "                    continue",
            "",
            "                # pull out the two parts of the tuple so we can do type checking",
            "                str_result, callback_result = result",
            "",
            "                # the 1st item in the tuple should be a str",
            "                if not isinstance(str_result, str):",
            "                    logger.warning(  # type: ignore[unreachable]",
            "                        \"Wrong type returned by module API callback %s: %s, expected\"",
            "                        \" Optional[Tuple[str, Optional[Callable]]]\",",
            "                        callback,",
            "                        result,",
            "                    )",
            "                    continue",
            "",
            "                # the second should be Optional[Callable]",
            "                if callback_result is not None:",
            "                    if not callable(callback_result):",
            "                        logger.warning(  # type: ignore[unreachable]",
            "                            \"Wrong type returned by module API callback %s: %s, expected\"",
            "                            \" Optional[Tuple[str, Optional[Callable]]]\",",
            "                            callback,",
            "                            result,",
            "                        )",
            "                        continue",
            "",
            "                # The result is a (str, Optional[callback]) tuple so return the successful result",
            "                return result",
            "",
            "        # If this point has been reached then none of the callbacks successfully authenticated",
            "        # the user so return None",
            "        return None",
            "",
            "    async def on_logged_out(",
            "        self, user_id: str, device_id: Optional[str], access_token: str",
            "    ) -> None:",
            "        # call all of the on_logged_out callbacks",
            "        for callback in self.on_logged_out_callbacks:",
            "            try:",
            "                await callback(user_id, device_id, access_token)",
            "            except Exception as e:",
            "                logger.warning(\"Failed to run module API callback %s: %s\", callback, e)",
            "                continue",
            "",
            "    async def get_username_for_registration(",
            "        self,",
            "        uia_results: JsonDict,",
            "        params: JsonDict,",
            "    ) -> Optional[str]:",
            "        \"\"\"Defines the username to use when registering the user, using the credentials",
            "        and parameters provided during the UIA flow.",
            "",
            "        Stops at the first callback that returns a string.",
            "",
            "        Args:",
            "            uia_results: The credentials provided during the UIA flow.",
            "            params: The parameters provided by the registration request.",
            "",
            "        Returns:",
            "            The localpart to use when registering this user, or None if no module",
            "            returned a localpart.",
            "        \"\"\"",
            "        for callback in self.get_username_for_registration_callbacks:",
            "            try:",
            "                res = await delay_cancellation(callback(uia_results, params))",
            "",
            "                if isinstance(res, str):",
            "                    return res",
            "                elif res is not None:",
            "                    # mypy complains that this line is unreachable because it assumes the",
            "                    # data returned by the module fits the expected type. We just want",
            "                    # to make sure this is the case.",
            "                    logger.warning(  # type: ignore[unreachable]",
            "                        \"Ignoring non-string value returned by\"",
            "                        \" get_username_for_registration callback %s: %s\",",
            "                        callback,",
            "                        res,",
            "                    )",
            "            except CancelledError:",
            "                raise",
            "            except Exception as e:",
            "                logger.error(",
            "                    \"Module raised an exception in get_username_for_registration: %s\",",
            "                    e,",
            "                )",
            "                raise SynapseError(code=500, msg=\"Internal Server Error\")",
            "",
            "        return None",
            "",
            "    async def get_displayname_for_registration(",
            "        self,",
            "        uia_results: JsonDict,",
            "        params: JsonDict,",
            "    ) -> Optional[str]:",
            "        \"\"\"Defines the display name to use when registering the user, using the",
            "        credentials and parameters provided during the UIA flow.",
            "",
            "        Stops at the first callback that returns a tuple containing at least one string.",
            "",
            "        Args:",
            "            uia_results: The credentials provided during the UIA flow.",
            "            params: The parameters provided by the registration request.",
            "",
            "        Returns:",
            "            A tuple which first element is the display name, and the second is an MXC URL",
            "            to the user's avatar.",
            "        \"\"\"",
            "        for callback in self.get_displayname_for_registration_callbacks:",
            "            try:",
            "                res = await delay_cancellation(callback(uia_results, params))",
            "",
            "                if isinstance(res, str):",
            "                    return res",
            "                elif res is not None:",
            "                    # mypy complains that this line is unreachable because it assumes the",
            "                    # data returned by the module fits the expected type. We just want",
            "                    # to make sure this is the case.",
            "                    logger.warning(  # type: ignore[unreachable]",
            "                        \"Ignoring non-string value returned by\"",
            "                        \" get_displayname_for_registration callback %s: %s\",",
            "                        callback,",
            "                        res,",
            "                    )",
            "            except CancelledError:",
            "                raise",
            "            except Exception as e:",
            "                logger.error(",
            "                    \"Module raised an exception in get_displayname_for_registration: %s\",",
            "                    e,",
            "                )",
            "                raise SynapseError(code=500, msg=\"Internal Server Error\")",
            "",
            "        return None",
            "",
            "    async def is_3pid_allowed(",
            "        self,",
            "        medium: str,",
            "        address: str,",
            "        registration: bool,",
            "    ) -> bool:",
            "        \"\"\"Check if the user can be allowed to bind a 3PID on this homeserver.",
            "",
            "        Args:",
            "            medium: The medium of the 3PID.",
            "            address: The address of the 3PID.",
            "            registration: Whether the 3PID is being bound when registering a new user.",
            "",
            "        Returns:",
            "            Whether the 3PID is allowed to be bound on this homeserver",
            "        \"\"\"",
            "        for callback in self.is_3pid_allowed_callbacks:",
            "            try:",
            "                res = await delay_cancellation(callback(medium, address, registration))",
            "",
            "                if res is False:",
            "                    return res",
            "                elif not isinstance(res, bool):",
            "                    # mypy complains that this line is unreachable because it assumes the",
            "                    # data returned by the module fits the expected type. We just want",
            "                    # to make sure this is the case.",
            "                    logger.warning(  # type: ignore[unreachable]",
            "                        \"Ignoring non-string value returned by\"",
            "                        \" is_3pid_allowed callback %s: %s\",",
            "                        callback,",
            "                        res,",
            "                    )",
            "            except CancelledError:",
            "                raise",
            "            except Exception as e:",
            "                logger.error(\"Module raised an exception in is_3pid_allowed: %s\", e)",
            "                raise SynapseError(code=500, msg=\"Internal Server Error\")",
            "",
            "        return True"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "1",
            "1",
            "1",
            "1",
            "1",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "55": [],
            "1422": [
                "AuthHandler"
            ],
            "1423": [
                "AuthHandler"
            ],
            "1424": [
                "AuthHandler"
            ],
            "1425": [
                "AuthHandler"
            ],
            "1426": [
                "AuthHandler"
            ],
            "1427": [
                "AuthHandler"
            ],
            "1752": [
                "AuthHandler"
            ],
            "1753": [
                "AuthHandler"
            ]
        },
        "addLocation": []
    },
    "synapse/handlers/jwt.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from authlib.jose import JsonWebToken, JWTClaims"
            },
            "1": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from authlib.jose.errors import BadSignatureError, InvalidClaimError, JoseError"
            },
            "2": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from synapse.api.errors import Codes, LoginError, StoreError, UserDeactivatedError"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+from synapse.api.errors import Codes, LoginError"
            },
            "5": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from synapse.types import JsonDict, UserID"
            },
            "6": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " if TYPE_CHECKING:"
            },
            "8": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " class JwtHandler:"
            },
            "9": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "     def __init__(self, hs: \"HomeServer\"):"
            },
            "10": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "         self.hs = hs"
            },
            "11": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self._main_store = hs.get_datastores().main"
            },
            "12": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 29,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "         self.jwt_secret = hs.config.jwt.jwt_secret"
            },
            "14": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "         self.jwt_subject_claim = hs.config.jwt.jwt_subject_claim"
            },
            "15": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "         self.jwt_algorithm = hs.config.jwt.jwt_algorithm"
            },
            "16": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "         self.jwt_issuer = hs.config.jwt.jwt_issuer"
            },
            "17": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "         self.jwt_audiences = hs.config.jwt.jwt_audiences"
            },
            "18": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "19": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    async def validate_login(self, login_submission: JsonDict) -> str:"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+    def validate_login(self, login_submission: JsonDict) -> str:"
            },
            "21": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "         \"\"\""
            },
            "22": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "         Authenticates the user for the /login API"
            },
            "23": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " "
            },
            "24": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "         if user is None:"
            },
            "25": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "             raise LoginError(403, \"Invalid JWT\", errcode=Codes.FORBIDDEN)"
            },
            "26": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": 104,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        user_id = UserID(user, self.hs.hostname).to_string()"
            },
            "28": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "29": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # If the account has been deactivated, do not proceed with the login"
            },
            "30": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # flow."
            },
            "31": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        try:"
            },
            "32": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            deactivated = await self._main_store.get_user_deactivated_status(user_id)"
            },
            "33": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        except StoreError:"
            },
            "34": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            # JWT lazily creates users, so they may not exist in the database yet."
            },
            "35": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            deactivated = False"
            },
            "36": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if deactivated:"
            },
            "37": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise UserDeactivatedError(\"This account has been deactivated\")"
            },
            "38": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "39": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return user_id"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+        return UserID(user, self.hs.hostname).to_string()"
            }
        },
        "frontPatchFile": [
            "# Copyright 2023 Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from typing import TYPE_CHECKING",
            "",
            "from authlib.jose import JsonWebToken, JWTClaims",
            "from authlib.jose.errors import BadSignatureError, InvalidClaimError, JoseError",
            "",
            "from synapse.api.errors import Codes, LoginError, StoreError, UserDeactivatedError",
            "from synapse.types import JsonDict, UserID",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.server import HomeServer",
            "",
            "",
            "class JwtHandler:",
            "    def __init__(self, hs: \"HomeServer\"):",
            "        self.hs = hs",
            "        self._main_store = hs.get_datastores().main",
            "",
            "        self.jwt_secret = hs.config.jwt.jwt_secret",
            "        self.jwt_subject_claim = hs.config.jwt.jwt_subject_claim",
            "        self.jwt_algorithm = hs.config.jwt.jwt_algorithm",
            "        self.jwt_issuer = hs.config.jwt.jwt_issuer",
            "        self.jwt_audiences = hs.config.jwt.jwt_audiences",
            "",
            "    async def validate_login(self, login_submission: JsonDict) -> str:",
            "        \"\"\"",
            "        Authenticates the user for the /login API",
            "",
            "        Args:",
            "            login_submission: the whole of the login submission",
            "                (including 'type' and other relevant fields)",
            "",
            "        Returns:",
            "            The user ID that is logging in.",
            "",
            "        Raises:",
            "            LoginError if there was an authentication problem.",
            "        \"\"\"",
            "        token = login_submission.get(\"token\", None)",
            "        if token is None:",
            "            raise LoginError(",
            "                403, \"Token field for JWT is missing\", errcode=Codes.FORBIDDEN",
            "            )",
            "",
            "        jwt = JsonWebToken([self.jwt_algorithm])",
            "        claim_options = {}",
            "        if self.jwt_issuer is not None:",
            "            claim_options[\"iss\"] = {\"value\": self.jwt_issuer, \"essential\": True}",
            "        if self.jwt_audiences is not None:",
            "            claim_options[\"aud\"] = {\"values\": self.jwt_audiences, \"essential\": True}",
            "",
            "        try:",
            "            claims = jwt.decode(",
            "                token,",
            "                key=self.jwt_secret,",
            "                claims_cls=JWTClaims,",
            "                claims_options=claim_options,",
            "            )",
            "        except BadSignatureError:",
            "            # We handle this case separately to provide a better error message",
            "            raise LoginError(",
            "                403,",
            "                \"JWT validation failed: Signature verification failed\",",
            "                errcode=Codes.FORBIDDEN,",
            "            )",
            "        except JoseError as e:",
            "            # A JWT error occurred, return some info back to the client.",
            "            raise LoginError(",
            "                403,",
            "                \"JWT validation failed: %s\" % (str(e),),",
            "                errcode=Codes.FORBIDDEN,",
            "            )",
            "",
            "        try:",
            "            claims.validate(leeway=120)  # allows 2 min of clock skew",
            "",
            "            # Enforce the old behavior which is rolled out in productive",
            "            # servers: if the JWT contains an 'aud' claim but none is",
            "            # configured, the login attempt will fail",
            "            if claims.get(\"aud\") is not None:",
            "                if self.jwt_audiences is None or len(self.jwt_audiences) == 0:",
            "                    raise InvalidClaimError(\"aud\")",
            "        except JoseError as e:",
            "            raise LoginError(",
            "                403,",
            "                \"JWT validation failed: %s\" % (str(e),),",
            "                errcode=Codes.FORBIDDEN,",
            "            )",
            "",
            "        user = claims.get(self.jwt_subject_claim, None)",
            "        if user is None:",
            "            raise LoginError(403, \"Invalid JWT\", errcode=Codes.FORBIDDEN)",
            "",
            "        user_id = UserID(user, self.hs.hostname).to_string()",
            "",
            "        # If the account has been deactivated, do not proceed with the login",
            "        # flow.",
            "        try:",
            "            deactivated = await self._main_store.get_user_deactivated_status(user_id)",
            "        except StoreError:",
            "            # JWT lazily creates users, so they may not exist in the database yet.",
            "            deactivated = False",
            "        if deactivated:",
            "            raise UserDeactivatedError(\"This account has been deactivated\")",
            "",
            "        return user_id"
        ],
        "afterPatchFile": [
            "# Copyright 2023 Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "from typing import TYPE_CHECKING",
            "",
            "from authlib.jose import JsonWebToken, JWTClaims",
            "from authlib.jose.errors import BadSignatureError, InvalidClaimError, JoseError",
            "",
            "from synapse.api.errors import Codes, LoginError",
            "from synapse.types import JsonDict, UserID",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.server import HomeServer",
            "",
            "",
            "class JwtHandler:",
            "    def __init__(self, hs: \"HomeServer\"):",
            "        self.hs = hs",
            "",
            "        self.jwt_secret = hs.config.jwt.jwt_secret",
            "        self.jwt_subject_claim = hs.config.jwt.jwt_subject_claim",
            "        self.jwt_algorithm = hs.config.jwt.jwt_algorithm",
            "        self.jwt_issuer = hs.config.jwt.jwt_issuer",
            "        self.jwt_audiences = hs.config.jwt.jwt_audiences",
            "",
            "    def validate_login(self, login_submission: JsonDict) -> str:",
            "        \"\"\"",
            "        Authenticates the user for the /login API",
            "",
            "        Args:",
            "            login_submission: the whole of the login submission",
            "                (including 'type' and other relevant fields)",
            "",
            "        Returns:",
            "            The user ID that is logging in.",
            "",
            "        Raises:",
            "            LoginError if there was an authentication problem.",
            "        \"\"\"",
            "        token = login_submission.get(\"token\", None)",
            "        if token is None:",
            "            raise LoginError(",
            "                403, \"Token field for JWT is missing\", errcode=Codes.FORBIDDEN",
            "            )",
            "",
            "        jwt = JsonWebToken([self.jwt_algorithm])",
            "        claim_options = {}",
            "        if self.jwt_issuer is not None:",
            "            claim_options[\"iss\"] = {\"value\": self.jwt_issuer, \"essential\": True}",
            "        if self.jwt_audiences is not None:",
            "            claim_options[\"aud\"] = {\"values\": self.jwt_audiences, \"essential\": True}",
            "",
            "        try:",
            "            claims = jwt.decode(",
            "                token,",
            "                key=self.jwt_secret,",
            "                claims_cls=JWTClaims,",
            "                claims_options=claim_options,",
            "            )",
            "        except BadSignatureError:",
            "            # We handle this case separately to provide a better error message",
            "            raise LoginError(",
            "                403,",
            "                \"JWT validation failed: Signature verification failed\",",
            "                errcode=Codes.FORBIDDEN,",
            "            )",
            "        except JoseError as e:",
            "            # A JWT error occurred, return some info back to the client.",
            "            raise LoginError(",
            "                403,",
            "                \"JWT validation failed: %s\" % (str(e),),",
            "                errcode=Codes.FORBIDDEN,",
            "            )",
            "",
            "        try:",
            "            claims.validate(leeway=120)  # allows 2 min of clock skew",
            "",
            "            # Enforce the old behavior which is rolled out in productive",
            "            # servers: if the JWT contains an 'aud' claim but none is",
            "            # configured, the login attempt will fail",
            "            if claims.get(\"aud\") is not None:",
            "                if self.jwt_audiences is None or len(self.jwt_audiences) == 0:",
            "                    raise InvalidClaimError(\"aud\")",
            "        except JoseError as e:",
            "            raise LoginError(",
            "                403,",
            "                \"JWT validation failed: %s\" % (str(e),),",
            "                errcode=Codes.FORBIDDEN,",
            "            )",
            "",
            "        user = claims.get(self.jwt_subject_claim, None)",
            "        if user is None:",
            "            raise LoginError(403, \"Invalid JWT\", errcode=Codes.FORBIDDEN)",
            "",
            "        return UserID(user, self.hs.hostname).to_string()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "19": [],
            "29": [
                "JwtHandler",
                "__init__"
            ],
            "37": [
                "JwtHandler"
            ],
            "106": [
                "JwtHandler"
            ],
            "107": [
                "JwtHandler"
            ],
            "108": [
                "JwtHandler"
            ],
            "109": [
                "JwtHandler"
            ],
            "110": [
                "JwtHandler"
            ],
            "111": [
                "JwtHandler"
            ],
            "112": [
                "JwtHandler"
            ],
            "113": [
                "JwtHandler"
            ],
            "114": [
                "JwtHandler"
            ],
            "115": [
                "JwtHandler"
            ],
            "116": [
                "JwtHandler"
            ],
            "117": [
                "JwtHandler"
            ],
            "118": [
                "JwtHandler"
            ]
        },
        "addLocation": []
    },
    "synapse/rest/client/login.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "     LoginError,"
            },
            "1": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "     NotApprovedError,"
            },
            "2": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "     SynapseError,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+    UserDeactivatedError,"
            },
            "4": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " )"
            },
            "5": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " from synapse.api.ratelimiting import Ratelimiter"
            },
            "6": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " from synapse.api.urls import CLIENT_API_PREFIX"
            },
            "7": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "     def __init__(self, hs: \"HomeServer\"):"
            },
            "8": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "         super().__init__()"
            },
            "9": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "         self.hs = hs"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+        self._main_store = hs.get_datastores().main"
            },
            "11": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 89,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 90,
                "PatchRowcode": "         # JWT configuration variables."
            },
            "13": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "         self.jwt_enabled = hs.config.jwt.jwt_enabled"
            },
            "14": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 114,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": 115,
                "PatchRowcode": "         self._well_known_builder = WellKnownBuilder(hs)"
            },
            "16": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": 116,
                "PatchRowcode": "         self._address_ratelimiter = Ratelimiter("
            },
            "17": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            store=hs.get_datastores().main,"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+            store=self._main_store,"
            },
            "19": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 118,
                "PatchRowcode": "             clock=hs.get_clock(),"
            },
            "20": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 119,
                "PatchRowcode": "             rate_hz=self.hs.config.ratelimiting.rc_login_address.per_second,"
            },
            "21": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "             burst_count=self.hs.config.ratelimiting.rc_login_address.burst_count,"
            },
            "22": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "         )"
            },
            "23": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         self._account_ratelimiter = Ratelimiter("
            },
            "24": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            store=hs.get_datastores().main,"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+            store=self._main_store,"
            },
            "26": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 124,
                "PatchRowcode": "             clock=hs.get_clock(),"
            },
            "27": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "             rate_hz=self.hs.config.ratelimiting.rc_login_account.per_second,"
            },
            "28": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "             burst_count=self.hs.config.ratelimiting.rc_login_account.burst_count,"
            },
            "29": {
                "beforePatchRowNumber": 280,
                "afterPatchRowNumber": 282,
                "PatchRowcode": "             login_submission,"
            },
            "30": {
                "beforePatchRowNumber": 281,
                "afterPatchRowNumber": 283,
                "PatchRowcode": "             ratelimit=appservice.is_rate_limited(),"
            },
            "31": {
                "beforePatchRowNumber": 282,
                "afterPatchRowNumber": 284,
                "PatchRowcode": "             should_issue_refresh_token=should_issue_refresh_token,"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 285,
                "PatchRowcode": "+            # The user represented by an appservice's configured sender_localpart"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 286,
                "PatchRowcode": "+            # is not actually created in Synapse."
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 287,
                "PatchRowcode": "+            should_check_deactivated=qualified_user_id != appservice.sender,"
            },
            "35": {
                "beforePatchRowNumber": 283,
                "afterPatchRowNumber": 288,
                "PatchRowcode": "         )"
            },
            "36": {
                "beforePatchRowNumber": 284,
                "afterPatchRowNumber": 289,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 290,
                "PatchRowcode": "     async def _do_other_login("
            },
            "38": {
                "beforePatchRowNumber": 326,
                "afterPatchRowNumber": 331,
                "PatchRowcode": "         auth_provider_id: Optional[str] = None,"
            },
            "39": {
                "beforePatchRowNumber": 327,
                "afterPatchRowNumber": 332,
                "PatchRowcode": "         should_issue_refresh_token: bool = False,"
            },
            "40": {
                "beforePatchRowNumber": 328,
                "afterPatchRowNumber": 333,
                "PatchRowcode": "         auth_provider_session_id: Optional[str] = None,"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 334,
                "PatchRowcode": "+        should_check_deactivated: bool = True,"
            },
            "42": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": 335,
                "PatchRowcode": "     ) -> LoginResponse:"
            },
            "43": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 336,
                "PatchRowcode": "         \"\"\"Called when we've successfully authed the user and now need to"
            },
            "44": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": 337,
                "PatchRowcode": "         actually login them in (e.g. create devices). This gets called on"
            },
            "45": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": 351,
                "PatchRowcode": "             should_issue_refresh_token: True if this login should issue"
            },
            "46": {
                "beforePatchRowNumber": 346,
                "afterPatchRowNumber": 352,
                "PatchRowcode": "                 a refresh token alongside the access token."
            },
            "47": {
                "beforePatchRowNumber": 347,
                "afterPatchRowNumber": 353,
                "PatchRowcode": "             auth_provider_session_id: The session ID got during login from the SSO IdP."
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 354,
                "PatchRowcode": "+            should_check_deactivated: True if the user should be checked for"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 355,
                "PatchRowcode": "+                deactivation status before logging in."
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 356,
                "PatchRowcode": "+"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 357,
                "PatchRowcode": "+                This exists purely for appservice's configured sender_localpart"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 358,
                "PatchRowcode": "+                which doesn't have an associated user in the database."
            },
            "53": {
                "beforePatchRowNumber": 348,
                "afterPatchRowNumber": 359,
                "PatchRowcode": " "
            },
            "54": {
                "beforePatchRowNumber": 349,
                "afterPatchRowNumber": 360,
                "PatchRowcode": "         Returns:"
            },
            "55": {
                "beforePatchRowNumber": 350,
                "afterPatchRowNumber": 361,
                "PatchRowcode": "             Dictionary of account information after successful login."
            },
            "56": {
                "beforePatchRowNumber": 364,
                "afterPatchRowNumber": 375,
                "PatchRowcode": "                 )"
            },
            "57": {
                "beforePatchRowNumber": 365,
                "afterPatchRowNumber": 376,
                "PatchRowcode": "             user_id = canonical_uid"
            },
            "58": {
                "beforePatchRowNumber": 366,
                "afterPatchRowNumber": 377,
                "PatchRowcode": " "
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 378,
                "PatchRowcode": "+        # If the account has been deactivated, do not proceed with the login."
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 379,
                "PatchRowcode": "+        if should_check_deactivated:"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 380,
                "PatchRowcode": "+            deactivated = await self._main_store.get_user_deactivated_status(user_id)"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 381,
                "PatchRowcode": "+            if deactivated:"
            },
            "63": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 382,
                "PatchRowcode": "+                raise UserDeactivatedError(\"This account has been deactivated\")"
            },
            "64": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 383,
                "PatchRowcode": "+"
            },
            "65": {
                "beforePatchRowNumber": 367,
                "afterPatchRowNumber": 384,
                "PatchRowcode": "         device_id = login_submission.get(\"device_id\")"
            },
            "66": {
                "beforePatchRowNumber": 368,
                "afterPatchRowNumber": 385,
                "PatchRowcode": " "
            },
            "67": {
                "beforePatchRowNumber": 369,
                "afterPatchRowNumber": 386,
                "PatchRowcode": "         # If device_id is present, check that device_id is not longer than a reasonable 512 characters"
            },
            "68": {
                "beforePatchRowNumber": 458,
                "afterPatchRowNumber": 475,
                "PatchRowcode": "         Returns:"
            },
            "69": {
                "beforePatchRowNumber": 459,
                "afterPatchRowNumber": 476,
                "PatchRowcode": "             The body of the JSON response."
            },
            "70": {
                "beforePatchRowNumber": 460,
                "afterPatchRowNumber": 477,
                "PatchRowcode": "         \"\"\""
            },
            "71": {
                "beforePatchRowNumber": 461,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        user_id = await self.hs.get_jwt_handler().validate_login(login_submission)"
            },
            "72": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 478,
                "PatchRowcode": "+        user_id = self.hs.get_jwt_handler().validate_login(login_submission)"
            },
            "73": {
                "beforePatchRowNumber": 462,
                "afterPatchRowNumber": 479,
                "PatchRowcode": "         return await self._complete_login("
            },
            "74": {
                "beforePatchRowNumber": 463,
                "afterPatchRowNumber": 480,
                "PatchRowcode": "             user_id,"
            },
            "75": {
                "beforePatchRowNumber": 464,
                "afterPatchRowNumber": 481,
                "PatchRowcode": "             login_submission,"
            }
        },
        "frontPatchFile": [
            "# Copyright 2014-2021 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import logging",
            "import re",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    Awaitable,",
            "    Callable,",
            "    Dict,",
            "    List,",
            "    Optional,",
            "    Tuple,",
            "    Union,",
            ")",
            "",
            "from typing_extensions import TypedDict",
            "",
            "from synapse.api.constants import ApprovalNoticeMedium",
            "from synapse.api.errors import (",
            "    Codes,",
            "    InvalidClientTokenError,",
            "    LoginError,",
            "    NotApprovedError,",
            "    SynapseError,",
            ")",
            "from synapse.api.ratelimiting import Ratelimiter",
            "from synapse.api.urls import CLIENT_API_PREFIX",
            "from synapse.appservice import ApplicationService",
            "from synapse.handlers.sso import SsoIdentityProvider",
            "from synapse.http import get_request_uri",
            "from synapse.http.server import HttpServer, finish_request",
            "from synapse.http.servlet import (",
            "    RestServlet,",
            "    assert_params_in_dict,",
            "    parse_bytes_from_args,",
            "    parse_json_object_from_request,",
            "    parse_string,",
            ")",
            "from synapse.http.site import SynapseRequest",
            "from synapse.rest.client._base import client_patterns",
            "from synapse.rest.well_known import WellKnownBuilder",
            "from synapse.types import JsonDict, UserID",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.server import HomeServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class LoginResponse(TypedDict, total=False):",
            "    user_id: str",
            "    access_token: Optional[str]",
            "    home_server: str",
            "    expires_in_ms: Optional[int]",
            "    refresh_token: Optional[str]",
            "    device_id: Optional[str]",
            "    well_known: Optional[Dict[str, Any]]",
            "",
            "",
            "class LoginRestServlet(RestServlet):",
            "    PATTERNS = client_patterns(\"/login$\", v1=True)",
            "    CATEGORY = \"Registration/login requests\"",
            "",
            "    CAS_TYPE = \"m.login.cas\"",
            "    SSO_TYPE = \"m.login.sso\"",
            "    TOKEN_TYPE = \"m.login.token\"",
            "    JWT_TYPE = \"org.matrix.login.jwt\"",
            "    APPSERVICE_TYPE = \"m.login.application_service\"",
            "    REFRESH_TOKEN_PARAM = \"refresh_token\"",
            "",
            "    def __init__(self, hs: \"HomeServer\"):",
            "        super().__init__()",
            "        self.hs = hs",
            "",
            "        # JWT configuration variables.",
            "        self.jwt_enabled = hs.config.jwt.jwt_enabled",
            "",
            "        # SSO configuration.",
            "        self.saml2_enabled = hs.config.saml2.saml2_enabled",
            "        self.cas_enabled = hs.config.cas.cas_enabled",
            "        self.oidc_enabled = hs.config.oidc.oidc_enabled",
            "        self._refresh_tokens_enabled = (",
            "            hs.config.registration.refreshable_access_token_lifetime is not None",
            "        )",
            "",
            "        # Whether we need to check if the user has been approved or not.",
            "        self._require_approval = (",
            "            hs.config.experimental.msc3866.enabled",
            "            and hs.config.experimental.msc3866.require_approval_for_new_accounts",
            "        )",
            "",
            "        self.auth = hs.get_auth()",
            "",
            "        self.clock = hs.get_clock()",
            "",
            "        self.auth_handler = self.hs.get_auth_handler()",
            "        self.registration_handler = hs.get_registration_handler()",
            "        self._sso_handler = hs.get_sso_handler()",
            "",
            "        self._well_known_builder = WellKnownBuilder(hs)",
            "        self._address_ratelimiter = Ratelimiter(",
            "            store=hs.get_datastores().main,",
            "            clock=hs.get_clock(),",
            "            rate_hz=self.hs.config.ratelimiting.rc_login_address.per_second,",
            "            burst_count=self.hs.config.ratelimiting.rc_login_address.burst_count,",
            "        )",
            "        self._account_ratelimiter = Ratelimiter(",
            "            store=hs.get_datastores().main,",
            "            clock=hs.get_clock(),",
            "            rate_hz=self.hs.config.ratelimiting.rc_login_account.per_second,",
            "            burst_count=self.hs.config.ratelimiting.rc_login_account.burst_count,",
            "        )",
            "",
            "        # ensure the CAS/SAML/OIDC handlers are loaded on this worker instance.",
            "        # The reason for this is to ensure that the auth_provider_ids are registered",
            "        # with SsoHandler, which in turn ensures that the login/registration prometheus",
            "        # counters are initialised for the auth_provider_ids.",
            "        _load_sso_handlers(hs)",
            "",
            "    def on_GET(self, request: SynapseRequest) -> Tuple[int, JsonDict]:",
            "        flows: List[JsonDict] = []",
            "        if self.jwt_enabled:",
            "            flows.append({\"type\": LoginRestServlet.JWT_TYPE})",
            "",
            "        if self.cas_enabled:",
            "            # we advertise CAS for backwards compat, though MSC1721 renamed it",
            "            # to SSO.",
            "            flows.append({\"type\": LoginRestServlet.CAS_TYPE})",
            "",
            "        if self.cas_enabled or self.saml2_enabled or self.oidc_enabled:",
            "            flows.append(",
            "                {",
            "                    \"type\": LoginRestServlet.SSO_TYPE,",
            "                    \"identity_providers\": [",
            "                        _get_auth_flow_dict_for_idp(idp)",
            "                        for idp in self._sso_handler.get_identity_providers().values()",
            "                    ],",
            "                }",
            "            )",
            "",
            "            # While it's valid for us to advertise this login type generally,",
            "            # synapse currently only gives out these tokens as part of the",
            "            # SSO login flow.",
            "            # Generally we don't want to advertise login flows that clients",
            "            # don't know how to implement, since they (currently) will always",
            "            # fall back to the fallback API if they don't understand one of the",
            "            # login flow types returned.",
            "            flows.append({\"type\": LoginRestServlet.TOKEN_TYPE})",
            "",
            "        flows.extend({\"type\": t} for t in self.auth_handler.get_supported_login_types())",
            "",
            "        flows.append({\"type\": LoginRestServlet.APPSERVICE_TYPE})",
            "",
            "        return 200, {\"flows\": flows}",
            "",
            "    async def on_POST(self, request: SynapseRequest) -> Tuple[int, LoginResponse]:",
            "        login_submission = parse_json_object_from_request(request)",
            "",
            "        # Check to see if the client requested a refresh token.",
            "        client_requested_refresh_token = login_submission.get(",
            "            LoginRestServlet.REFRESH_TOKEN_PARAM, False",
            "        )",
            "        if not isinstance(client_requested_refresh_token, bool):",
            "            raise SynapseError(400, \"`refresh_token` should be true or false.\")",
            "",
            "        should_issue_refresh_token = (",
            "            self._refresh_tokens_enabled and client_requested_refresh_token",
            "        )",
            "",
            "        try:",
            "            if login_submission[\"type\"] == LoginRestServlet.APPSERVICE_TYPE:",
            "                requester = await self.auth.get_user_by_req(request)",
            "                appservice = requester.app_service",
            "",
            "                if appservice is None:",
            "                    raise InvalidClientTokenError(",
            "                        \"This login method is only valid for application services\"",
            "                    )",
            "",
            "                if appservice.is_rate_limited():",
            "                    await self._address_ratelimiter.ratelimit(",
            "                        None, request.getClientAddress().host",
            "                    )",
            "",
            "                result = await self._do_appservice_login(",
            "                    login_submission,",
            "                    appservice,",
            "                    should_issue_refresh_token=should_issue_refresh_token,",
            "                )",
            "            elif (",
            "                self.jwt_enabled",
            "                and login_submission[\"type\"] == LoginRestServlet.JWT_TYPE",
            "            ):",
            "                await self._address_ratelimiter.ratelimit(",
            "                    None, request.getClientAddress().host",
            "                )",
            "                result = await self._do_jwt_login(",
            "                    login_submission,",
            "                    should_issue_refresh_token=should_issue_refresh_token,",
            "                )",
            "            elif login_submission[\"type\"] == LoginRestServlet.TOKEN_TYPE:",
            "                await self._address_ratelimiter.ratelimit(",
            "                    None, request.getClientAddress().host",
            "                )",
            "                result = await self._do_token_login(",
            "                    login_submission,",
            "                    should_issue_refresh_token=should_issue_refresh_token,",
            "                )",
            "            else:",
            "                await self._address_ratelimiter.ratelimit(",
            "                    None, request.getClientAddress().host",
            "                )",
            "                result = await self._do_other_login(",
            "                    login_submission,",
            "                    should_issue_refresh_token=should_issue_refresh_token,",
            "                )",
            "        except KeyError:",
            "            raise SynapseError(400, \"Missing JSON keys.\")",
            "",
            "        if self._require_approval:",
            "            approved = await self.auth_handler.is_user_approved(result[\"user_id\"])",
            "            if not approved:",
            "                raise NotApprovedError(",
            "                    msg=\"This account is pending approval by a server administrator.\",",
            "                    approval_notice_medium=ApprovalNoticeMedium.NONE,",
            "                )",
            "",
            "        well_known_data = self._well_known_builder.get_well_known()",
            "        if well_known_data:",
            "            result[\"well_known\"] = well_known_data",
            "        return 200, result",
            "",
            "    async def _do_appservice_login(",
            "        self,",
            "        login_submission: JsonDict,",
            "        appservice: ApplicationService,",
            "        should_issue_refresh_token: bool = False,",
            "    ) -> LoginResponse:",
            "        identifier = login_submission.get(\"identifier\")",
            "        logger.info(\"Got appservice login request with identifier: %r\", identifier)",
            "",
            "        if not isinstance(identifier, dict):",
            "            raise SynapseError(",
            "                400, \"Invalid identifier in login submission\", Codes.INVALID_PARAM",
            "            )",
            "",
            "        # this login flow only supports identifiers of type \"m.id.user\".",
            "        if identifier.get(\"type\") != \"m.id.user\":",
            "            raise SynapseError(",
            "                400, \"Unknown login identifier type\", Codes.INVALID_PARAM",
            "            )",
            "",
            "        user = identifier.get(\"user\")",
            "        if not isinstance(user, str):",
            "            raise SynapseError(400, \"Invalid user in identifier\", Codes.INVALID_PARAM)",
            "",
            "        if user.startswith(\"@\"):",
            "            qualified_user_id = user",
            "        else:",
            "            qualified_user_id = UserID(user, self.hs.hostname).to_string()",
            "",
            "        if not appservice.is_interested_in_user(qualified_user_id):",
            "            raise LoginError(403, \"Invalid access_token\", errcode=Codes.FORBIDDEN)",
            "",
            "        return await self._complete_login(",
            "            qualified_user_id,",
            "            login_submission,",
            "            ratelimit=appservice.is_rate_limited(),",
            "            should_issue_refresh_token=should_issue_refresh_token,",
            "        )",
            "",
            "    async def _do_other_login(",
            "        self, login_submission: JsonDict, should_issue_refresh_token: bool = False",
            "    ) -> LoginResponse:",
            "        \"\"\"Handle non-token/saml/jwt logins",
            "",
            "        Args:",
            "            login_submission:",
            "            should_issue_refresh_token: True if this login should issue",
            "                a refresh token alongside the access token.",
            "",
            "        Returns:",
            "            HTTP response",
            "        \"\"\"",
            "        # Log the request we got, but only certain fields to minimise the chance of",
            "        # logging someone's password (even if they accidentally put it in the wrong",
            "        # field)",
            "        logger.info(",
            "            \"Got login request with identifier: %r, medium: %r, address: %r, user: %r\",",
            "            login_submission.get(\"identifier\"),",
            "            login_submission.get(\"medium\"),",
            "            login_submission.get(\"address\"),",
            "            login_submission.get(\"user\"),",
            "        )",
            "        canonical_user_id, callback = await self.auth_handler.validate_login(",
            "            login_submission, ratelimit=True",
            "        )",
            "        result = await self._complete_login(",
            "            canonical_user_id,",
            "            login_submission,",
            "            callback,",
            "            should_issue_refresh_token=should_issue_refresh_token,",
            "        )",
            "        return result",
            "",
            "    async def _complete_login(",
            "        self,",
            "        user_id: str,",
            "        login_submission: JsonDict,",
            "        callback: Optional[Callable[[LoginResponse], Awaitable[None]]] = None,",
            "        create_non_existent_users: bool = False,",
            "        ratelimit: bool = True,",
            "        auth_provider_id: Optional[str] = None,",
            "        should_issue_refresh_token: bool = False,",
            "        auth_provider_session_id: Optional[str] = None,",
            "    ) -> LoginResponse:",
            "        \"\"\"Called when we've successfully authed the user and now need to",
            "        actually login them in (e.g. create devices). This gets called on",
            "        all successful logins.",
            "",
            "        Applies the ratelimiting for successful login attempts against an",
            "        account.",
            "",
            "        Args:",
            "            user_id: ID of the user to register.",
            "            login_submission: Dictionary of login information.",
            "            callback: Callback function to run after login.",
            "            create_non_existent_users: Whether to create the user if they don't",
            "                exist. Defaults to False.",
            "            ratelimit: Whether to ratelimit the login request.",
            "            auth_provider_id: The SSO IdP the user used, if any.",
            "            should_issue_refresh_token: True if this login should issue",
            "                a refresh token alongside the access token.",
            "            auth_provider_session_id: The session ID got during login from the SSO IdP.",
            "",
            "        Returns:",
            "            Dictionary of account information after successful login.",
            "        \"\"\"",
            "",
            "        # Before we actually log them in we check if they've already logged in",
            "        # too often. This happens here rather than before as we don't",
            "        # necessarily know the user before now.",
            "        if ratelimit:",
            "            await self._account_ratelimiter.ratelimit(None, user_id.lower())",
            "",
            "        if create_non_existent_users:",
            "            canonical_uid = await self.auth_handler.check_user_exists(user_id)",
            "            if not canonical_uid:",
            "                canonical_uid = await self.registration_handler.register_user(",
            "                    localpart=UserID.from_string(user_id).localpart",
            "                )",
            "            user_id = canonical_uid",
            "",
            "        device_id = login_submission.get(\"device_id\")",
            "",
            "        # If device_id is present, check that device_id is not longer than a reasonable 512 characters",
            "        if device_id and len(device_id) > 512:",
            "            raise LoginError(",
            "                400,",
            "                \"device_id cannot be longer than 512 characters.\",",
            "                errcode=Codes.INVALID_PARAM,",
            "            )",
            "",
            "        if self._require_approval:",
            "            approved = await self.auth_handler.is_user_approved(user_id)",
            "            if not approved:",
            "                # If the user isn't approved (and needs to be) we won't allow them to",
            "                # actually log in, so we don't want to create a device/access token.",
            "                return LoginResponse(",
            "                    user_id=user_id,",
            "                    home_server=self.hs.hostname,",
            "                )",
            "",
            "        initial_display_name = login_submission.get(\"initial_device_display_name\")",
            "        (",
            "            device_id,",
            "            access_token,",
            "            valid_until_ms,",
            "            refresh_token,",
            "        ) = await self.registration_handler.register_device(",
            "            user_id,",
            "            device_id,",
            "            initial_display_name,",
            "            auth_provider_id=auth_provider_id,",
            "            should_issue_refresh_token=should_issue_refresh_token,",
            "            auth_provider_session_id=auth_provider_session_id,",
            "        )",
            "",
            "        result = LoginResponse(",
            "            user_id=user_id,",
            "            access_token=access_token,",
            "            home_server=self.hs.hostname,",
            "            device_id=device_id,",
            "        )",
            "",
            "        if valid_until_ms is not None:",
            "            expires_in_ms = valid_until_ms - self.clock.time_msec()",
            "            result[\"expires_in_ms\"] = expires_in_ms",
            "",
            "        if refresh_token is not None:",
            "            result[\"refresh_token\"] = refresh_token",
            "",
            "        if callback is not None:",
            "            await callback(result)",
            "",
            "        return result",
            "",
            "    async def _do_token_login(",
            "        self, login_submission: JsonDict, should_issue_refresh_token: bool = False",
            "    ) -> LoginResponse:",
            "        \"\"\"",
            "        Handle token login.",
            "",
            "        Args:",
            "            login_submission: The JSON request body.",
            "            should_issue_refresh_token: True if this login should issue",
            "                a refresh token alongside the access token.",
            "",
            "        Returns:",
            "            The body of the JSON response.",
            "        \"\"\"",
            "        token = login_submission[\"token\"]",
            "        res = await self.auth_handler.consume_login_token(token)",
            "",
            "        return await self._complete_login(",
            "            res.user_id,",
            "            login_submission,",
            "            self.auth_handler._sso_login_callback,",
            "            auth_provider_id=res.auth_provider_id,",
            "            should_issue_refresh_token=should_issue_refresh_token,",
            "            auth_provider_session_id=res.auth_provider_session_id,",
            "        )",
            "",
            "    async def _do_jwt_login(",
            "        self, login_submission: JsonDict, should_issue_refresh_token: bool = False",
            "    ) -> LoginResponse:",
            "        \"\"\"",
            "        Handle the custom JWT login.",
            "",
            "        Args:",
            "            login_submission: The JSON request body.",
            "            should_issue_refresh_token: True if this login should issue",
            "                a refresh token alongside the access token.",
            "",
            "        Returns:",
            "            The body of the JSON response.",
            "        \"\"\"",
            "        user_id = await self.hs.get_jwt_handler().validate_login(login_submission)",
            "        return await self._complete_login(",
            "            user_id,",
            "            login_submission,",
            "            create_non_existent_users=True,",
            "            should_issue_refresh_token=should_issue_refresh_token,",
            "        )",
            "",
            "",
            "def _get_auth_flow_dict_for_idp(idp: SsoIdentityProvider) -> JsonDict:",
            "    \"\"\"Return an entry for the login flow dict",
            "",
            "    Returns an entry suitable for inclusion in \"identity_providers\" in the",
            "    response to GET /_matrix/client/r0/login",
            "",
            "    Args:",
            "        idp: the identity provider to describe",
            "    \"\"\"",
            "    e: JsonDict = {\"id\": idp.idp_id, \"name\": idp.idp_name}",
            "    if idp.idp_icon:",
            "        e[\"icon\"] = idp.idp_icon",
            "    if idp.idp_brand:",
            "        e[\"brand\"] = idp.idp_brand",
            "    return e",
            "",
            "",
            "class RefreshTokenServlet(RestServlet):",
            "    PATTERNS = client_patterns(\"/refresh$\")",
            "    CATEGORY = \"Registration/login requests\"",
            "",
            "    def __init__(self, hs: \"HomeServer\"):",
            "        self._auth_handler = hs.get_auth_handler()",
            "        self._clock = hs.get_clock()",
            "        self.refreshable_access_token_lifetime = (",
            "            hs.config.registration.refreshable_access_token_lifetime",
            "        )",
            "        self.refresh_token_lifetime = hs.config.registration.refresh_token_lifetime",
            "",
            "    async def on_POST(self, request: SynapseRequest) -> Tuple[int, JsonDict]:",
            "        refresh_submission = parse_json_object_from_request(request)",
            "",
            "        assert_params_in_dict(refresh_submission, [\"refresh_token\"])",
            "        token = refresh_submission[\"refresh_token\"]",
            "        if not isinstance(token, str):",
            "            raise SynapseError(400, \"Invalid param: refresh_token\", Codes.INVALID_PARAM)",
            "",
            "        now = self._clock.time_msec()",
            "        access_valid_until_ms = None",
            "        if self.refreshable_access_token_lifetime is not None:",
            "            access_valid_until_ms = now + self.refreshable_access_token_lifetime",
            "        refresh_valid_until_ms = None",
            "        if self.refresh_token_lifetime is not None:",
            "            refresh_valid_until_ms = now + self.refresh_token_lifetime",
            "",
            "        (",
            "            access_token,",
            "            refresh_token,",
            "            actual_access_token_expiry,",
            "        ) = await self._auth_handler.refresh_token(",
            "            token, access_valid_until_ms, refresh_valid_until_ms",
            "        )",
            "",
            "        response: Dict[str, Union[str, int]] = {",
            "            \"access_token\": access_token,",
            "            \"refresh_token\": refresh_token,",
            "        }",
            "",
            "        # expires_in_ms is only present if the token expires",
            "        if actual_access_token_expiry is not None:",
            "            response[\"expires_in_ms\"] = actual_access_token_expiry - now",
            "",
            "        return 200, response",
            "",
            "",
            "class SsoRedirectServlet(RestServlet):",
            "    PATTERNS = list(client_patterns(\"/login/(cas|sso)/redirect$\", v1=True)) + [",
            "        re.compile(",
            "            \"^\"",
            "            + CLIENT_API_PREFIX",
            "            + \"/(r0|v3)/login/sso/redirect/(?P<idp_id>[A-Za-z0-9_.~-]+)$\"",
            "        )",
            "    ]",
            "    CATEGORY = \"SSO requests needed for all SSO providers\"",
            "",
            "    def __init__(self, hs: \"HomeServer\"):",
            "        # make sure that the relevant handlers are instantiated, so that they",
            "        # register themselves with the main SSOHandler.",
            "        _load_sso_handlers(hs)",
            "        self._sso_handler = hs.get_sso_handler()",
            "        self._public_baseurl = hs.config.server.public_baseurl",
            "",
            "    async def on_GET(",
            "        self, request: SynapseRequest, idp_id: Optional[str] = None",
            "    ) -> None:",
            "        if not self._public_baseurl:",
            "            raise SynapseError(400, \"SSO requires a valid public_baseurl\")",
            "",
            "        # if this isn't the expected hostname, redirect to the right one, so that we",
            "        # get our cookies back.",
            "        requested_uri = get_request_uri(request)",
            "        baseurl_bytes = self._public_baseurl.encode(\"utf-8\")",
            "        if not requested_uri.startswith(baseurl_bytes):",
            "            # swap out the incorrect base URL for the right one.",
            "            #",
            "            # The idea here is to redirect from",
            "            #    https://foo.bar/whatever/_matrix/...",
            "            # to",
            "            #    https://public.baseurl/_matrix/...",
            "            #",
            "            i = requested_uri.index(b\"/_matrix\")",
            "            new_uri = baseurl_bytes[:-1] + requested_uri[i:]",
            "            logger.info(",
            "                \"Requested URI %s is not canonical: redirecting to %s\",",
            "                requested_uri.decode(\"utf-8\", errors=\"replace\"),",
            "                new_uri.decode(\"utf-8\", errors=\"replace\"),",
            "            )",
            "            request.redirect(new_uri)",
            "            finish_request(request)",
            "            return",
            "",
            "        args: Dict[bytes, List[bytes]] = request.args  # type: ignore",
            "        client_redirect_url = parse_bytes_from_args(args, \"redirectUrl\", required=True)",
            "        sso_url = await self._sso_handler.handle_redirect_request(",
            "            request,",
            "            client_redirect_url,",
            "            idp_id,",
            "        )",
            "        logger.info(\"Redirecting to %s\", sso_url)",
            "        request.redirect(sso_url)",
            "        finish_request(request)",
            "",
            "",
            "class CasTicketServlet(RestServlet):",
            "    PATTERNS = client_patterns(\"/login/cas/ticket\", v1=True)",
            "",
            "    def __init__(self, hs: \"HomeServer\"):",
            "        super().__init__()",
            "        self._cas_handler = hs.get_cas_handler()",
            "",
            "    async def on_GET(self, request: SynapseRequest) -> None:",
            "        client_redirect_url = parse_string(request, \"redirectUrl\")",
            "        ticket = parse_string(request, \"ticket\", required=True)",
            "",
            "        # Maybe get a session ID (if this ticket is from user interactive",
            "        # authentication).",
            "        session = parse_string(request, \"session\")",
            "",
            "        # Either client_redirect_url or session must be provided.",
            "        if not client_redirect_url and not session:",
            "            message = \"Missing string query parameter redirectUrl or session\"",
            "            raise SynapseError(400, message, errcode=Codes.MISSING_PARAM)",
            "",
            "        await self._cas_handler.handle_ticket(",
            "            request, ticket, client_redirect_url, session",
            "        )",
            "",
            "",
            "def register_servlets(hs: \"HomeServer\", http_server: HttpServer) -> None:",
            "    LoginRestServlet(hs).register(http_server)",
            "    if (",
            "        hs.config.worker.worker_app is None",
            "        and hs.config.registration.refreshable_access_token_lifetime is not None",
            "    ):",
            "        RefreshTokenServlet(hs).register(http_server)",
            "    if (",
            "        hs.config.cas.cas_enabled",
            "        or hs.config.saml2.saml2_enabled",
            "        or hs.config.oidc.oidc_enabled",
            "    ):",
            "        SsoRedirectServlet(hs).register(http_server)",
            "    if hs.config.cas.cas_enabled:",
            "        CasTicketServlet(hs).register(http_server)",
            "",
            "",
            "def _load_sso_handlers(hs: \"HomeServer\") -> None:",
            "    \"\"\"Ensure that the SSO handlers are loaded, if they are enabled by configuration.",
            "",
            "    This is mostly useful to ensure that the CAS/SAML/OIDC handlers register themselves",
            "    with the main SsoHandler.",
            "",
            "    It's safe to call this multiple times.",
            "    \"\"\"",
            "    if hs.config.cas.cas_enabled:",
            "        hs.get_cas_handler()",
            "    if hs.config.saml2.saml2_enabled:",
            "        hs.get_saml_handler()",
            "    if hs.config.oidc.oidc_enabled:",
            "        hs.get_oidc_handler()"
        ],
        "afterPatchFile": [
            "# Copyright 2014-2021 The Matrix.org Foundation C.I.C.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "# you may not use this file except in compliance with the License.",
            "# You may obtain a copy of the License at",
            "#",
            "#     http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "# See the License for the specific language governing permissions and",
            "# limitations under the License.",
            "",
            "import logging",
            "import re",
            "from typing import (",
            "    TYPE_CHECKING,",
            "    Any,",
            "    Awaitable,",
            "    Callable,",
            "    Dict,",
            "    List,",
            "    Optional,",
            "    Tuple,",
            "    Union,",
            ")",
            "",
            "from typing_extensions import TypedDict",
            "",
            "from synapse.api.constants import ApprovalNoticeMedium",
            "from synapse.api.errors import (",
            "    Codes,",
            "    InvalidClientTokenError,",
            "    LoginError,",
            "    NotApprovedError,",
            "    SynapseError,",
            "    UserDeactivatedError,",
            ")",
            "from synapse.api.ratelimiting import Ratelimiter",
            "from synapse.api.urls import CLIENT_API_PREFIX",
            "from synapse.appservice import ApplicationService",
            "from synapse.handlers.sso import SsoIdentityProvider",
            "from synapse.http import get_request_uri",
            "from synapse.http.server import HttpServer, finish_request",
            "from synapse.http.servlet import (",
            "    RestServlet,",
            "    assert_params_in_dict,",
            "    parse_bytes_from_args,",
            "    parse_json_object_from_request,",
            "    parse_string,",
            ")",
            "from synapse.http.site import SynapseRequest",
            "from synapse.rest.client._base import client_patterns",
            "from synapse.rest.well_known import WellKnownBuilder",
            "from synapse.types import JsonDict, UserID",
            "",
            "if TYPE_CHECKING:",
            "    from synapse.server import HomeServer",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class LoginResponse(TypedDict, total=False):",
            "    user_id: str",
            "    access_token: Optional[str]",
            "    home_server: str",
            "    expires_in_ms: Optional[int]",
            "    refresh_token: Optional[str]",
            "    device_id: Optional[str]",
            "    well_known: Optional[Dict[str, Any]]",
            "",
            "",
            "class LoginRestServlet(RestServlet):",
            "    PATTERNS = client_patterns(\"/login$\", v1=True)",
            "    CATEGORY = \"Registration/login requests\"",
            "",
            "    CAS_TYPE = \"m.login.cas\"",
            "    SSO_TYPE = \"m.login.sso\"",
            "    TOKEN_TYPE = \"m.login.token\"",
            "    JWT_TYPE = \"org.matrix.login.jwt\"",
            "    APPSERVICE_TYPE = \"m.login.application_service\"",
            "    REFRESH_TOKEN_PARAM = \"refresh_token\"",
            "",
            "    def __init__(self, hs: \"HomeServer\"):",
            "        super().__init__()",
            "        self.hs = hs",
            "        self._main_store = hs.get_datastores().main",
            "",
            "        # JWT configuration variables.",
            "        self.jwt_enabled = hs.config.jwt.jwt_enabled",
            "",
            "        # SSO configuration.",
            "        self.saml2_enabled = hs.config.saml2.saml2_enabled",
            "        self.cas_enabled = hs.config.cas.cas_enabled",
            "        self.oidc_enabled = hs.config.oidc.oidc_enabled",
            "        self._refresh_tokens_enabled = (",
            "            hs.config.registration.refreshable_access_token_lifetime is not None",
            "        )",
            "",
            "        # Whether we need to check if the user has been approved or not.",
            "        self._require_approval = (",
            "            hs.config.experimental.msc3866.enabled",
            "            and hs.config.experimental.msc3866.require_approval_for_new_accounts",
            "        )",
            "",
            "        self.auth = hs.get_auth()",
            "",
            "        self.clock = hs.get_clock()",
            "",
            "        self.auth_handler = self.hs.get_auth_handler()",
            "        self.registration_handler = hs.get_registration_handler()",
            "        self._sso_handler = hs.get_sso_handler()",
            "",
            "        self._well_known_builder = WellKnownBuilder(hs)",
            "        self._address_ratelimiter = Ratelimiter(",
            "            store=self._main_store,",
            "            clock=hs.get_clock(),",
            "            rate_hz=self.hs.config.ratelimiting.rc_login_address.per_second,",
            "            burst_count=self.hs.config.ratelimiting.rc_login_address.burst_count,",
            "        )",
            "        self._account_ratelimiter = Ratelimiter(",
            "            store=self._main_store,",
            "            clock=hs.get_clock(),",
            "            rate_hz=self.hs.config.ratelimiting.rc_login_account.per_second,",
            "            burst_count=self.hs.config.ratelimiting.rc_login_account.burst_count,",
            "        )",
            "",
            "        # ensure the CAS/SAML/OIDC handlers are loaded on this worker instance.",
            "        # The reason for this is to ensure that the auth_provider_ids are registered",
            "        # with SsoHandler, which in turn ensures that the login/registration prometheus",
            "        # counters are initialised for the auth_provider_ids.",
            "        _load_sso_handlers(hs)",
            "",
            "    def on_GET(self, request: SynapseRequest) -> Tuple[int, JsonDict]:",
            "        flows: List[JsonDict] = []",
            "        if self.jwt_enabled:",
            "            flows.append({\"type\": LoginRestServlet.JWT_TYPE})",
            "",
            "        if self.cas_enabled:",
            "            # we advertise CAS for backwards compat, though MSC1721 renamed it",
            "            # to SSO.",
            "            flows.append({\"type\": LoginRestServlet.CAS_TYPE})",
            "",
            "        if self.cas_enabled or self.saml2_enabled or self.oidc_enabled:",
            "            flows.append(",
            "                {",
            "                    \"type\": LoginRestServlet.SSO_TYPE,",
            "                    \"identity_providers\": [",
            "                        _get_auth_flow_dict_for_idp(idp)",
            "                        for idp in self._sso_handler.get_identity_providers().values()",
            "                    ],",
            "                }",
            "            )",
            "",
            "            # While it's valid for us to advertise this login type generally,",
            "            # synapse currently only gives out these tokens as part of the",
            "            # SSO login flow.",
            "            # Generally we don't want to advertise login flows that clients",
            "            # don't know how to implement, since they (currently) will always",
            "            # fall back to the fallback API if they don't understand one of the",
            "            # login flow types returned.",
            "            flows.append({\"type\": LoginRestServlet.TOKEN_TYPE})",
            "",
            "        flows.extend({\"type\": t} for t in self.auth_handler.get_supported_login_types())",
            "",
            "        flows.append({\"type\": LoginRestServlet.APPSERVICE_TYPE})",
            "",
            "        return 200, {\"flows\": flows}",
            "",
            "    async def on_POST(self, request: SynapseRequest) -> Tuple[int, LoginResponse]:",
            "        login_submission = parse_json_object_from_request(request)",
            "",
            "        # Check to see if the client requested a refresh token.",
            "        client_requested_refresh_token = login_submission.get(",
            "            LoginRestServlet.REFRESH_TOKEN_PARAM, False",
            "        )",
            "        if not isinstance(client_requested_refresh_token, bool):",
            "            raise SynapseError(400, \"`refresh_token` should be true or false.\")",
            "",
            "        should_issue_refresh_token = (",
            "            self._refresh_tokens_enabled and client_requested_refresh_token",
            "        )",
            "",
            "        try:",
            "            if login_submission[\"type\"] == LoginRestServlet.APPSERVICE_TYPE:",
            "                requester = await self.auth.get_user_by_req(request)",
            "                appservice = requester.app_service",
            "",
            "                if appservice is None:",
            "                    raise InvalidClientTokenError(",
            "                        \"This login method is only valid for application services\"",
            "                    )",
            "",
            "                if appservice.is_rate_limited():",
            "                    await self._address_ratelimiter.ratelimit(",
            "                        None, request.getClientAddress().host",
            "                    )",
            "",
            "                result = await self._do_appservice_login(",
            "                    login_submission,",
            "                    appservice,",
            "                    should_issue_refresh_token=should_issue_refresh_token,",
            "                )",
            "            elif (",
            "                self.jwt_enabled",
            "                and login_submission[\"type\"] == LoginRestServlet.JWT_TYPE",
            "            ):",
            "                await self._address_ratelimiter.ratelimit(",
            "                    None, request.getClientAddress().host",
            "                )",
            "                result = await self._do_jwt_login(",
            "                    login_submission,",
            "                    should_issue_refresh_token=should_issue_refresh_token,",
            "                )",
            "            elif login_submission[\"type\"] == LoginRestServlet.TOKEN_TYPE:",
            "                await self._address_ratelimiter.ratelimit(",
            "                    None, request.getClientAddress().host",
            "                )",
            "                result = await self._do_token_login(",
            "                    login_submission,",
            "                    should_issue_refresh_token=should_issue_refresh_token,",
            "                )",
            "            else:",
            "                await self._address_ratelimiter.ratelimit(",
            "                    None, request.getClientAddress().host",
            "                )",
            "                result = await self._do_other_login(",
            "                    login_submission,",
            "                    should_issue_refresh_token=should_issue_refresh_token,",
            "                )",
            "        except KeyError:",
            "            raise SynapseError(400, \"Missing JSON keys.\")",
            "",
            "        if self._require_approval:",
            "            approved = await self.auth_handler.is_user_approved(result[\"user_id\"])",
            "            if not approved:",
            "                raise NotApprovedError(",
            "                    msg=\"This account is pending approval by a server administrator.\",",
            "                    approval_notice_medium=ApprovalNoticeMedium.NONE,",
            "                )",
            "",
            "        well_known_data = self._well_known_builder.get_well_known()",
            "        if well_known_data:",
            "            result[\"well_known\"] = well_known_data",
            "        return 200, result",
            "",
            "    async def _do_appservice_login(",
            "        self,",
            "        login_submission: JsonDict,",
            "        appservice: ApplicationService,",
            "        should_issue_refresh_token: bool = False,",
            "    ) -> LoginResponse:",
            "        identifier = login_submission.get(\"identifier\")",
            "        logger.info(\"Got appservice login request with identifier: %r\", identifier)",
            "",
            "        if not isinstance(identifier, dict):",
            "            raise SynapseError(",
            "                400, \"Invalid identifier in login submission\", Codes.INVALID_PARAM",
            "            )",
            "",
            "        # this login flow only supports identifiers of type \"m.id.user\".",
            "        if identifier.get(\"type\") != \"m.id.user\":",
            "            raise SynapseError(",
            "                400, \"Unknown login identifier type\", Codes.INVALID_PARAM",
            "            )",
            "",
            "        user = identifier.get(\"user\")",
            "        if not isinstance(user, str):",
            "            raise SynapseError(400, \"Invalid user in identifier\", Codes.INVALID_PARAM)",
            "",
            "        if user.startswith(\"@\"):",
            "            qualified_user_id = user",
            "        else:",
            "            qualified_user_id = UserID(user, self.hs.hostname).to_string()",
            "",
            "        if not appservice.is_interested_in_user(qualified_user_id):",
            "            raise LoginError(403, \"Invalid access_token\", errcode=Codes.FORBIDDEN)",
            "",
            "        return await self._complete_login(",
            "            qualified_user_id,",
            "            login_submission,",
            "            ratelimit=appservice.is_rate_limited(),",
            "            should_issue_refresh_token=should_issue_refresh_token,",
            "            # The user represented by an appservice's configured sender_localpart",
            "            # is not actually created in Synapse.",
            "            should_check_deactivated=qualified_user_id != appservice.sender,",
            "        )",
            "",
            "    async def _do_other_login(",
            "        self, login_submission: JsonDict, should_issue_refresh_token: bool = False",
            "    ) -> LoginResponse:",
            "        \"\"\"Handle non-token/saml/jwt logins",
            "",
            "        Args:",
            "            login_submission:",
            "            should_issue_refresh_token: True if this login should issue",
            "                a refresh token alongside the access token.",
            "",
            "        Returns:",
            "            HTTP response",
            "        \"\"\"",
            "        # Log the request we got, but only certain fields to minimise the chance of",
            "        # logging someone's password (even if they accidentally put it in the wrong",
            "        # field)",
            "        logger.info(",
            "            \"Got login request with identifier: %r, medium: %r, address: %r, user: %r\",",
            "            login_submission.get(\"identifier\"),",
            "            login_submission.get(\"medium\"),",
            "            login_submission.get(\"address\"),",
            "            login_submission.get(\"user\"),",
            "        )",
            "        canonical_user_id, callback = await self.auth_handler.validate_login(",
            "            login_submission, ratelimit=True",
            "        )",
            "        result = await self._complete_login(",
            "            canonical_user_id,",
            "            login_submission,",
            "            callback,",
            "            should_issue_refresh_token=should_issue_refresh_token,",
            "        )",
            "        return result",
            "",
            "    async def _complete_login(",
            "        self,",
            "        user_id: str,",
            "        login_submission: JsonDict,",
            "        callback: Optional[Callable[[LoginResponse], Awaitable[None]]] = None,",
            "        create_non_existent_users: bool = False,",
            "        ratelimit: bool = True,",
            "        auth_provider_id: Optional[str] = None,",
            "        should_issue_refresh_token: bool = False,",
            "        auth_provider_session_id: Optional[str] = None,",
            "        should_check_deactivated: bool = True,",
            "    ) -> LoginResponse:",
            "        \"\"\"Called when we've successfully authed the user and now need to",
            "        actually login them in (e.g. create devices). This gets called on",
            "        all successful logins.",
            "",
            "        Applies the ratelimiting for successful login attempts against an",
            "        account.",
            "",
            "        Args:",
            "            user_id: ID of the user to register.",
            "            login_submission: Dictionary of login information.",
            "            callback: Callback function to run after login.",
            "            create_non_existent_users: Whether to create the user if they don't",
            "                exist. Defaults to False.",
            "            ratelimit: Whether to ratelimit the login request.",
            "            auth_provider_id: The SSO IdP the user used, if any.",
            "            should_issue_refresh_token: True if this login should issue",
            "                a refresh token alongside the access token.",
            "            auth_provider_session_id: The session ID got during login from the SSO IdP.",
            "            should_check_deactivated: True if the user should be checked for",
            "                deactivation status before logging in.",
            "",
            "                This exists purely for appservice's configured sender_localpart",
            "                which doesn't have an associated user in the database.",
            "",
            "        Returns:",
            "            Dictionary of account information after successful login.",
            "        \"\"\"",
            "",
            "        # Before we actually log them in we check if they've already logged in",
            "        # too often. This happens here rather than before as we don't",
            "        # necessarily know the user before now.",
            "        if ratelimit:",
            "            await self._account_ratelimiter.ratelimit(None, user_id.lower())",
            "",
            "        if create_non_existent_users:",
            "            canonical_uid = await self.auth_handler.check_user_exists(user_id)",
            "            if not canonical_uid:",
            "                canonical_uid = await self.registration_handler.register_user(",
            "                    localpart=UserID.from_string(user_id).localpart",
            "                )",
            "            user_id = canonical_uid",
            "",
            "        # If the account has been deactivated, do not proceed with the login.",
            "        if should_check_deactivated:",
            "            deactivated = await self._main_store.get_user_deactivated_status(user_id)",
            "            if deactivated:",
            "                raise UserDeactivatedError(\"This account has been deactivated\")",
            "",
            "        device_id = login_submission.get(\"device_id\")",
            "",
            "        # If device_id is present, check that device_id is not longer than a reasonable 512 characters",
            "        if device_id and len(device_id) > 512:",
            "            raise LoginError(",
            "                400,",
            "                \"device_id cannot be longer than 512 characters.\",",
            "                errcode=Codes.INVALID_PARAM,",
            "            )",
            "",
            "        if self._require_approval:",
            "            approved = await self.auth_handler.is_user_approved(user_id)",
            "            if not approved:",
            "                # If the user isn't approved (and needs to be) we won't allow them to",
            "                # actually log in, so we don't want to create a device/access token.",
            "                return LoginResponse(",
            "                    user_id=user_id,",
            "                    home_server=self.hs.hostname,",
            "                )",
            "",
            "        initial_display_name = login_submission.get(\"initial_device_display_name\")",
            "        (",
            "            device_id,",
            "            access_token,",
            "            valid_until_ms,",
            "            refresh_token,",
            "        ) = await self.registration_handler.register_device(",
            "            user_id,",
            "            device_id,",
            "            initial_display_name,",
            "            auth_provider_id=auth_provider_id,",
            "            should_issue_refresh_token=should_issue_refresh_token,",
            "            auth_provider_session_id=auth_provider_session_id,",
            "        )",
            "",
            "        result = LoginResponse(",
            "            user_id=user_id,",
            "            access_token=access_token,",
            "            home_server=self.hs.hostname,",
            "            device_id=device_id,",
            "        )",
            "",
            "        if valid_until_ms is not None:",
            "            expires_in_ms = valid_until_ms - self.clock.time_msec()",
            "            result[\"expires_in_ms\"] = expires_in_ms",
            "",
            "        if refresh_token is not None:",
            "            result[\"refresh_token\"] = refresh_token",
            "",
            "        if callback is not None:",
            "            await callback(result)",
            "",
            "        return result",
            "",
            "    async def _do_token_login(",
            "        self, login_submission: JsonDict, should_issue_refresh_token: bool = False",
            "    ) -> LoginResponse:",
            "        \"\"\"",
            "        Handle token login.",
            "",
            "        Args:",
            "            login_submission: The JSON request body.",
            "            should_issue_refresh_token: True if this login should issue",
            "                a refresh token alongside the access token.",
            "",
            "        Returns:",
            "            The body of the JSON response.",
            "        \"\"\"",
            "        token = login_submission[\"token\"]",
            "        res = await self.auth_handler.consume_login_token(token)",
            "",
            "        return await self._complete_login(",
            "            res.user_id,",
            "            login_submission,",
            "            self.auth_handler._sso_login_callback,",
            "            auth_provider_id=res.auth_provider_id,",
            "            should_issue_refresh_token=should_issue_refresh_token,",
            "            auth_provider_session_id=res.auth_provider_session_id,",
            "        )",
            "",
            "    async def _do_jwt_login(",
            "        self, login_submission: JsonDict, should_issue_refresh_token: bool = False",
            "    ) -> LoginResponse:",
            "        \"\"\"",
            "        Handle the custom JWT login.",
            "",
            "        Args:",
            "            login_submission: The JSON request body.",
            "            should_issue_refresh_token: True if this login should issue",
            "                a refresh token alongside the access token.",
            "",
            "        Returns:",
            "            The body of the JSON response.",
            "        \"\"\"",
            "        user_id = self.hs.get_jwt_handler().validate_login(login_submission)",
            "        return await self._complete_login(",
            "            user_id,",
            "            login_submission,",
            "            create_non_existent_users=True,",
            "            should_issue_refresh_token=should_issue_refresh_token,",
            "        )",
            "",
            "",
            "def _get_auth_flow_dict_for_idp(idp: SsoIdentityProvider) -> JsonDict:",
            "    \"\"\"Return an entry for the login flow dict",
            "",
            "    Returns an entry suitable for inclusion in \"identity_providers\" in the",
            "    response to GET /_matrix/client/r0/login",
            "",
            "    Args:",
            "        idp: the identity provider to describe",
            "    \"\"\"",
            "    e: JsonDict = {\"id\": idp.idp_id, \"name\": idp.idp_name}",
            "    if idp.idp_icon:",
            "        e[\"icon\"] = idp.idp_icon",
            "    if idp.idp_brand:",
            "        e[\"brand\"] = idp.idp_brand",
            "    return e",
            "",
            "",
            "class RefreshTokenServlet(RestServlet):",
            "    PATTERNS = client_patterns(\"/refresh$\")",
            "    CATEGORY = \"Registration/login requests\"",
            "",
            "    def __init__(self, hs: \"HomeServer\"):",
            "        self._auth_handler = hs.get_auth_handler()",
            "        self._clock = hs.get_clock()",
            "        self.refreshable_access_token_lifetime = (",
            "            hs.config.registration.refreshable_access_token_lifetime",
            "        )",
            "        self.refresh_token_lifetime = hs.config.registration.refresh_token_lifetime",
            "",
            "    async def on_POST(self, request: SynapseRequest) -> Tuple[int, JsonDict]:",
            "        refresh_submission = parse_json_object_from_request(request)",
            "",
            "        assert_params_in_dict(refresh_submission, [\"refresh_token\"])",
            "        token = refresh_submission[\"refresh_token\"]",
            "        if not isinstance(token, str):",
            "            raise SynapseError(400, \"Invalid param: refresh_token\", Codes.INVALID_PARAM)",
            "",
            "        now = self._clock.time_msec()",
            "        access_valid_until_ms = None",
            "        if self.refreshable_access_token_lifetime is not None:",
            "            access_valid_until_ms = now + self.refreshable_access_token_lifetime",
            "        refresh_valid_until_ms = None",
            "        if self.refresh_token_lifetime is not None:",
            "            refresh_valid_until_ms = now + self.refresh_token_lifetime",
            "",
            "        (",
            "            access_token,",
            "            refresh_token,",
            "            actual_access_token_expiry,",
            "        ) = await self._auth_handler.refresh_token(",
            "            token, access_valid_until_ms, refresh_valid_until_ms",
            "        )",
            "",
            "        response: Dict[str, Union[str, int]] = {",
            "            \"access_token\": access_token,",
            "            \"refresh_token\": refresh_token,",
            "        }",
            "",
            "        # expires_in_ms is only present if the token expires",
            "        if actual_access_token_expiry is not None:",
            "            response[\"expires_in_ms\"] = actual_access_token_expiry - now",
            "",
            "        return 200, response",
            "",
            "",
            "class SsoRedirectServlet(RestServlet):",
            "    PATTERNS = list(client_patterns(\"/login/(cas|sso)/redirect$\", v1=True)) + [",
            "        re.compile(",
            "            \"^\"",
            "            + CLIENT_API_PREFIX",
            "            + \"/(r0|v3)/login/sso/redirect/(?P<idp_id>[A-Za-z0-9_.~-]+)$\"",
            "        )",
            "    ]",
            "    CATEGORY = \"SSO requests needed for all SSO providers\"",
            "",
            "    def __init__(self, hs: \"HomeServer\"):",
            "        # make sure that the relevant handlers are instantiated, so that they",
            "        # register themselves with the main SSOHandler.",
            "        _load_sso_handlers(hs)",
            "        self._sso_handler = hs.get_sso_handler()",
            "        self._public_baseurl = hs.config.server.public_baseurl",
            "",
            "    async def on_GET(",
            "        self, request: SynapseRequest, idp_id: Optional[str] = None",
            "    ) -> None:",
            "        if not self._public_baseurl:",
            "            raise SynapseError(400, \"SSO requires a valid public_baseurl\")",
            "",
            "        # if this isn't the expected hostname, redirect to the right one, so that we",
            "        # get our cookies back.",
            "        requested_uri = get_request_uri(request)",
            "        baseurl_bytes = self._public_baseurl.encode(\"utf-8\")",
            "        if not requested_uri.startswith(baseurl_bytes):",
            "            # swap out the incorrect base URL for the right one.",
            "            #",
            "            # The idea here is to redirect from",
            "            #    https://foo.bar/whatever/_matrix/...",
            "            # to",
            "            #    https://public.baseurl/_matrix/...",
            "            #",
            "            i = requested_uri.index(b\"/_matrix\")",
            "            new_uri = baseurl_bytes[:-1] + requested_uri[i:]",
            "            logger.info(",
            "                \"Requested URI %s is not canonical: redirecting to %s\",",
            "                requested_uri.decode(\"utf-8\", errors=\"replace\"),",
            "                new_uri.decode(\"utf-8\", errors=\"replace\"),",
            "            )",
            "            request.redirect(new_uri)",
            "            finish_request(request)",
            "            return",
            "",
            "        args: Dict[bytes, List[bytes]] = request.args  # type: ignore",
            "        client_redirect_url = parse_bytes_from_args(args, \"redirectUrl\", required=True)",
            "        sso_url = await self._sso_handler.handle_redirect_request(",
            "            request,",
            "            client_redirect_url,",
            "            idp_id,",
            "        )",
            "        logger.info(\"Redirecting to %s\", sso_url)",
            "        request.redirect(sso_url)",
            "        finish_request(request)",
            "",
            "",
            "class CasTicketServlet(RestServlet):",
            "    PATTERNS = client_patterns(\"/login/cas/ticket\", v1=True)",
            "",
            "    def __init__(self, hs: \"HomeServer\"):",
            "        super().__init__()",
            "        self._cas_handler = hs.get_cas_handler()",
            "",
            "    async def on_GET(self, request: SynapseRequest) -> None:",
            "        client_redirect_url = parse_string(request, \"redirectUrl\")",
            "        ticket = parse_string(request, \"ticket\", required=True)",
            "",
            "        # Maybe get a session ID (if this ticket is from user interactive",
            "        # authentication).",
            "        session = parse_string(request, \"session\")",
            "",
            "        # Either client_redirect_url or session must be provided.",
            "        if not client_redirect_url and not session:",
            "            message = \"Missing string query parameter redirectUrl or session\"",
            "            raise SynapseError(400, message, errcode=Codes.MISSING_PARAM)",
            "",
            "        await self._cas_handler.handle_ticket(",
            "            request, ticket, client_redirect_url, session",
            "        )",
            "",
            "",
            "def register_servlets(hs: \"HomeServer\", http_server: HttpServer) -> None:",
            "    LoginRestServlet(hs).register(http_server)",
            "    if (",
            "        hs.config.worker.worker_app is None",
            "        and hs.config.registration.refreshable_access_token_lifetime is not None",
            "    ):",
            "        RefreshTokenServlet(hs).register(http_server)",
            "    if (",
            "        hs.config.cas.cas_enabled",
            "        or hs.config.saml2.saml2_enabled",
            "        or hs.config.oidc.oidc_enabled",
            "    ):",
            "        SsoRedirectServlet(hs).register(http_server)",
            "    if hs.config.cas.cas_enabled:",
            "        CasTicketServlet(hs).register(http_server)",
            "",
            "",
            "def _load_sso_handlers(hs: \"HomeServer\") -> None:",
            "    \"\"\"Ensure that the SSO handlers are loaded, if they are enabled by configuration.",
            "",
            "    This is mostly useful to ensure that the CAS/SAML/OIDC handlers register themselves",
            "    with the main SsoHandler.",
            "",
            "    It's safe to call this multiple times.",
            "    \"\"\"",
            "    if hs.config.cas.cas_enabled:",
            "        hs.get_cas_handler()",
            "    if hs.config.saml2.saml2_enabled:",
            "        hs.get_saml_handler()",
            "    if hs.config.oidc.oidc_enabled:",
            "        hs.get_oidc_handler()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "115": [
                "LoginRestServlet",
                "__init__"
            ],
            "121": [
                "LoginRestServlet",
                "__init__"
            ],
            "461": [
                "LoginRestServlet"
            ]
        },
        "addLocation": [
            "synapse.rest.client.login.register_servlets",
            "asyncua.server.internal_session",
            "synapse.rest.client.login.LoginRestServlet"
        ]
    }
}