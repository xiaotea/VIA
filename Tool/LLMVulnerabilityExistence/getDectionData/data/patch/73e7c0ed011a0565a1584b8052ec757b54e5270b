{
    "scrapy/spiders/feed.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 5,
                "PatchRowcode": " See documentation in docs/topics/spiders.rst"
            },
            "1": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " \"\"\""
            },
            "2": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from scrapy.spiders import Spider"
            },
            "3": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from scrapy.utils.iterators import xmliter, csviter"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+from scrapy.utils.iterators import csviter, xmliter_lxml"
            },
            "5": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " from scrapy.utils.spider import iterate_spider_output"
            },
            "6": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " from scrapy.selector import Selector"
            },
            "7": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " from scrapy.exceptions import NotConfigured, NotSupported"
            },
            "8": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "         return self.parse_nodes(response, nodes)"
            },
            "9": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 83,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "     def _iternodes(self, response):"
            },
            "11": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        for node in xmliter(response, self.itertag):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+        for node in xmliter_lxml(response, self.itertag):"
            },
            "13": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "             self._register_namespaces(node)"
            },
            "14": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "             yield node"
            },
            "15": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 88,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "This module implements the XMLFeedSpider which is the recommended spider to use",
            "for scraping from an XML feed.",
            "",
            "See documentation in docs/topics/spiders.rst",
            "\"\"\"",
            "from scrapy.spiders import Spider",
            "from scrapy.utils.iterators import xmliter, csviter",
            "from scrapy.utils.spider import iterate_spider_output",
            "from scrapy.selector import Selector",
            "from scrapy.exceptions import NotConfigured, NotSupported",
            "",
            "",
            "class XMLFeedSpider(Spider):",
            "    \"\"\"",
            "    This class intends to be the base class for spiders that scrape",
            "    from XML feeds.",
            "",
            "    You can choose whether to parse the file using the 'iternodes' iterator, an",
            "    'xml' selector, or an 'html' selector.  In most cases, it's convenient to",
            "    use iternodes, since it's a faster and cleaner.",
            "    \"\"\"",
            "",
            "    iterator = 'iternodes'",
            "    itertag = 'item'",
            "    namespaces = ()",
            "",
            "    def process_results(self, response, results):",
            "        \"\"\"This overridable method is called for each result (item or request)",
            "        returned by the spider, and it's intended to perform any last time",
            "        processing required before returning the results to the framework core,",
            "        for example setting the item GUIDs. It receives a list of results and",
            "        the response which originated that results. It must return a list of",
            "        results (Items or Requests).",
            "        \"\"\"",
            "        return results",
            "",
            "    def adapt_response(self, response):",
            "        \"\"\"You can override this function in order to make any changes you want",
            "        to into the feed before parsing it. This function must return a",
            "        response.",
            "        \"\"\"",
            "        return response",
            "",
            "    def parse_node(self, response, selector):",
            "        \"\"\"This method must be overriden with your custom spider functionality\"\"\"",
            "        if hasattr(self, 'parse_item'):  # backward compatibility",
            "            return self.parse_item(response, selector)",
            "        raise NotImplementedError",
            "",
            "    def parse_nodes(self, response, nodes):",
            "        \"\"\"This method is called for the nodes matching the provided tag name",
            "        (itertag). Receives the response and an Selector for each node.",
            "        Overriding this method is mandatory. Otherwise, you spider won't work.",
            "        This method must return either a BaseItem, a Request, or a list",
            "        containing any of them.",
            "        \"\"\"",
            "",
            "        for selector in nodes:",
            "            ret = iterate_spider_output(self.parse_node(response, selector))",
            "            for result_item in self.process_results(response, ret):",
            "                yield result_item",
            "",
            "    def parse(self, response):",
            "        if not hasattr(self, 'parse_node'):",
            "            raise NotConfigured('You must define parse_node method in order to scrape this XML feed')",
            "",
            "        response = self.adapt_response(response)",
            "        if self.iterator == 'iternodes':",
            "            nodes = self._iternodes(response)",
            "        elif self.iterator == 'xml':",
            "            selector = Selector(response, type='xml')",
            "            self._register_namespaces(selector)",
            "            nodes = selector.xpath('//%s' % self.itertag)",
            "        elif self.iterator == 'html':",
            "            selector = Selector(response, type='html')",
            "            self._register_namespaces(selector)",
            "            nodes = selector.xpath('//%s' % self.itertag)",
            "        else:",
            "            raise NotSupported('Unsupported node iterator')",
            "",
            "        return self.parse_nodes(response, nodes)",
            "",
            "    def _iternodes(self, response):",
            "        for node in xmliter(response, self.itertag):",
            "            self._register_namespaces(node)",
            "            yield node",
            "",
            "    def _register_namespaces(self, selector):",
            "        for (prefix, uri) in self.namespaces:",
            "            selector.register_namespace(prefix, uri)",
            "",
            "",
            "class CSVFeedSpider(Spider):",
            "    \"\"\"Spider for parsing CSV feeds.",
            "    It receives a CSV file in a response; iterates through each of its rows,",
            "    and calls parse_row with a dict containing each field's data.",
            "",
            "    You can set some options regarding the CSV file, such as the delimiter, quotechar",
            "    and the file's headers.",
            "    \"\"\"",
            "",
            "    delimiter = None # When this is None, python's csv module's default delimiter is used",
            "    quotechar = None # When this is None, python's csv module's default quotechar is used",
            "    headers = None",
            "",
            "    def process_results(self, response, results):",
            "        \"\"\"This method has the same purpose as the one in XMLFeedSpider\"\"\"",
            "        return results",
            "",
            "    def adapt_response(self, response):",
            "        \"\"\"This method has the same purpose as the one in XMLFeedSpider\"\"\"",
            "        return response",
            "",
            "    def parse_row(self, response, row):",
            "        \"\"\"This method must be overriden with your custom spider functionality\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def parse_rows(self, response):",
            "        \"\"\"Receives a response and a dict (representing each row) with a key for",
            "        each provided (or detected) header of the CSV file.  This spider also",
            "        gives the opportunity to override adapt_response and",
            "        process_results methods for pre and post-processing purposes.",
            "        \"\"\"",
            "",
            "        for row in csviter(response, self.delimiter, self.headers, self.quotechar):",
            "            ret = iterate_spider_output(self.parse_row(response, row))",
            "            for result_item in self.process_results(response, ret):",
            "                yield result_item",
            "",
            "    def parse(self, response):",
            "        if not hasattr(self, 'parse_row'):",
            "            raise NotConfigured('You must define parse_row method in order to scrape this CSV feed')",
            "        response = self.adapt_response(response)",
            "        return self.parse_rows(response)"
        ],
        "afterPatchFile": [
            "\"\"\"",
            "This module implements the XMLFeedSpider which is the recommended spider to use",
            "for scraping from an XML feed.",
            "",
            "See documentation in docs/topics/spiders.rst",
            "\"\"\"",
            "from scrapy.spiders import Spider",
            "from scrapy.utils.iterators import csviter, xmliter_lxml",
            "from scrapy.utils.spider import iterate_spider_output",
            "from scrapy.selector import Selector",
            "from scrapy.exceptions import NotConfigured, NotSupported",
            "",
            "",
            "class XMLFeedSpider(Spider):",
            "    \"\"\"",
            "    This class intends to be the base class for spiders that scrape",
            "    from XML feeds.",
            "",
            "    You can choose whether to parse the file using the 'iternodes' iterator, an",
            "    'xml' selector, or an 'html' selector.  In most cases, it's convenient to",
            "    use iternodes, since it's a faster and cleaner.",
            "    \"\"\"",
            "",
            "    iterator = 'iternodes'",
            "    itertag = 'item'",
            "    namespaces = ()",
            "",
            "    def process_results(self, response, results):",
            "        \"\"\"This overridable method is called for each result (item or request)",
            "        returned by the spider, and it's intended to perform any last time",
            "        processing required before returning the results to the framework core,",
            "        for example setting the item GUIDs. It receives a list of results and",
            "        the response which originated that results. It must return a list of",
            "        results (Items or Requests).",
            "        \"\"\"",
            "        return results",
            "",
            "    def adapt_response(self, response):",
            "        \"\"\"You can override this function in order to make any changes you want",
            "        to into the feed before parsing it. This function must return a",
            "        response.",
            "        \"\"\"",
            "        return response",
            "",
            "    def parse_node(self, response, selector):",
            "        \"\"\"This method must be overriden with your custom spider functionality\"\"\"",
            "        if hasattr(self, 'parse_item'):  # backward compatibility",
            "            return self.parse_item(response, selector)",
            "        raise NotImplementedError",
            "",
            "    def parse_nodes(self, response, nodes):",
            "        \"\"\"This method is called for the nodes matching the provided tag name",
            "        (itertag). Receives the response and an Selector for each node.",
            "        Overriding this method is mandatory. Otherwise, you spider won't work.",
            "        This method must return either a BaseItem, a Request, or a list",
            "        containing any of them.",
            "        \"\"\"",
            "",
            "        for selector in nodes:",
            "            ret = iterate_spider_output(self.parse_node(response, selector))",
            "            for result_item in self.process_results(response, ret):",
            "                yield result_item",
            "",
            "    def parse(self, response):",
            "        if not hasattr(self, 'parse_node'):",
            "            raise NotConfigured('You must define parse_node method in order to scrape this XML feed')",
            "",
            "        response = self.adapt_response(response)",
            "        if self.iterator == 'iternodes':",
            "            nodes = self._iternodes(response)",
            "        elif self.iterator == 'xml':",
            "            selector = Selector(response, type='xml')",
            "            self._register_namespaces(selector)",
            "            nodes = selector.xpath('//%s' % self.itertag)",
            "        elif self.iterator == 'html':",
            "            selector = Selector(response, type='html')",
            "            self._register_namespaces(selector)",
            "            nodes = selector.xpath('//%s' % self.itertag)",
            "        else:",
            "            raise NotSupported('Unsupported node iterator')",
            "",
            "        return self.parse_nodes(response, nodes)",
            "",
            "    def _iternodes(self, response):",
            "        for node in xmliter_lxml(response, self.itertag):",
            "            self._register_namespaces(node)",
            "            yield node",
            "",
            "    def _register_namespaces(self, selector):",
            "        for (prefix, uri) in self.namespaces:",
            "            selector.register_namespace(prefix, uri)",
            "",
            "",
            "class CSVFeedSpider(Spider):",
            "    \"\"\"Spider for parsing CSV feeds.",
            "    It receives a CSV file in a response; iterates through each of its rows,",
            "    and calls parse_row with a dict containing each field's data.",
            "",
            "    You can set some options regarding the CSV file, such as the delimiter, quotechar",
            "    and the file's headers.",
            "    \"\"\"",
            "",
            "    delimiter = None # When this is None, python's csv module's default delimiter is used",
            "    quotechar = None # When this is None, python's csv module's default quotechar is used",
            "    headers = None",
            "",
            "    def process_results(self, response, results):",
            "        \"\"\"This method has the same purpose as the one in XMLFeedSpider\"\"\"",
            "        return results",
            "",
            "    def adapt_response(self, response):",
            "        \"\"\"This method has the same purpose as the one in XMLFeedSpider\"\"\"",
            "        return response",
            "",
            "    def parse_row(self, response, row):",
            "        \"\"\"This method must be overriden with your custom spider functionality\"\"\"",
            "        raise NotImplementedError",
            "",
            "    def parse_rows(self, response):",
            "        \"\"\"Receives a response and a dict (representing each row) with a key for",
            "        each provided (or detected) header of the CSV file.  This spider also",
            "        gives the opportunity to override adapt_response and",
            "        process_results methods for pre and post-processing purposes.",
            "        \"\"\"",
            "",
            "        for row in csviter(response, self.delimiter, self.headers, self.quotechar):",
            "            ret = iterate_spider_output(self.parse_row(response, row))",
            "            for result_item in self.process_results(response, ret):",
            "                yield result_item",
            "",
            "    def parse(self, response):",
            "        if not hasattr(self, 'parse_row'):",
            "            raise NotConfigured('You must define parse_row method in order to scrape this CSV feed')",
            "        response = self.adapt_response(response)",
            "        return self.parse_rows(response)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "8": [],
            "85": [
                "XMLFeedSpider",
                "_iternodes"
            ]
        },
        "addLocation": []
    },
    "scrapy/utils/iterators.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " except ImportError:"
            },
            "1": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 7,
                "PatchRowcode": "     from io import BytesIO"
            },
            "2": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from io import StringIO"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+from warnings import warn"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 10,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " import six"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+from lxml import etree"
            },
            "7": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+from scrapy.exceptions import ScrapyDeprecationWarning"
            },
            "9": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from scrapy.http import TextResponse, Response"
            },
            "10": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from scrapy.selector import Selector"
            },
            "11": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from scrapy.utils.python import re_rsearch, to_unicode"
            },
            "12": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "     - a unicode string"
            },
            "13": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "     - a string encoded as utf-8"
            },
            "14": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "     \"\"\""
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 31,
                "PatchRowcode": "+    warn("
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+        ("
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+            \"xmliter is deprecated and its use strongly discouraged because \""
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+            \"it is vulnerable to ReDoS attacks. Use xmliter_lxml instead. See \""
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+            \"https://github.com/scrapy/scrapy/security/advisories/GHSA-cc65-xxvf-f7r9\""
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+        ),"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+        ScrapyDeprecationWarning,"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+        stacklevel=2,"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+    )"
            },
            "24": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 40,
                "PatchRowcode": "     nodename_patt = re.escape(nodename)"
            },
            "25": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " "
            },
            "26": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     HEADER_START_RE = re.compile(r'^(.{,1024}?)<\\s*%s(?:\\s|>)' % nodename_patt, re.S)"
            },
            "27": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 55,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " def xmliter_lxml(obj, nodename, namespace=None, prefix='x'):"
            },
            "30": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    from lxml import etree"
            },
            "31": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "     reader = _StreamReader(obj)"
            },
            "32": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "     tag = '{%s}%s' % (namespace, nodename) if namespace else nodename"
            },
            "33": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    iterable = etree.iterparse(reader, tag=tag, encoding=reader.encoding)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+    iterable = etree.iterparse("
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+        reader,"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+        encoding=reader.encoding,"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        events=(\"end\", \"start-ns\"),"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+        huge_tree=True,"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+    )"
            },
            "40": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "     selxpath = '//' + ('%s:%s' % (prefix, nodename) if namespace else nodename)"
            },
            "41": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    for _, node in iterable:"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+    needs_namespace_resolution = not namespace and \":\" in nodename"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+    if needs_namespace_resolution:"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+        prefix, nodename = nodename.split(\":\", maxsplit=1)"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+    for event, data in iterable:"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+        if event == \"start-ns\":"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+            assert isinstance(data, tuple)"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+            if needs_namespace_resolution:"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+                _prefix, _namespace = data"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+                if _prefix != prefix:"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+                    continue"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+                namespace = _namespace"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+                needs_namespace_resolution = False"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+                selxpath = \"//{prefix}:{nodename}\".format(prefix=prefix, nodename=nodename)"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+                tag = \"{{{namespace}}}{nodename}\".format(namespace=namespace, nodename=nodename)"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+            continue"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+        assert isinstance(data, etree._Element)"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+        node = data"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+        if node.tag != tag:"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+            continue"
            },
            "61": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "         nodetext = etree.tostring(node, encoding='unicode')"
            },
            "62": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "         node.clear()"
            },
            "63": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "         xs = Selector(text=nodetext, type='xml')"
            }
        },
        "frontPatchFile": [
            "import re",
            "import csv",
            "import logging",
            "try:",
            "    from cStringIO import StringIO as BytesIO",
            "except ImportError:",
            "    from io import BytesIO",
            "from io import StringIO",
            "import six",
            "",
            "from scrapy.http import TextResponse, Response",
            "from scrapy.selector import Selector",
            "from scrapy.utils.python import re_rsearch, to_unicode",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def xmliter(obj, nodename):",
            "    \"\"\"Return a iterator of Selector's over all nodes of a XML document,",
            "       given the name of the node to iterate. Useful for parsing XML feeds.",
            "",
            "    obj can be:",
            "    - a Response object",
            "    - a unicode string",
            "    - a string encoded as utf-8",
            "    \"\"\"",
            "    nodename_patt = re.escape(nodename)",
            "",
            "    HEADER_START_RE = re.compile(r'^(.{,1024}?)<\\s*%s(?:\\s|>)' % nodename_patt, re.S)",
            "    HEADER_END_RE = re.compile(r'<\\s*/%s\\s*>' % nodename_patt, re.S)",
            "    text = _body_or_str(obj)",
            "",
            "    header_start = re.search(HEADER_START_RE, text)",
            "    header_start = header_start.group(1).strip() if header_start else ''",
            "    header_end = re_rsearch(HEADER_END_RE, text)",
            "    header_end = text[header_end[1]:].strip() if header_end else ''",
            "",
            "    r = re.compile(r'<%(np)s[\\s>].{,1024}?</%(np)s>' % {'np': nodename_patt}, re.DOTALL)",
            "    for match in r.finditer(text):",
            "        nodetext = header_start + match.group() + header_end",
            "        yield Selector(text=nodetext, type='xml').xpath('//' + nodename)[0]",
            "",
            "",
            "def xmliter_lxml(obj, nodename, namespace=None, prefix='x'):",
            "    from lxml import etree",
            "    reader = _StreamReader(obj)",
            "    tag = '{%s}%s' % (namespace, nodename) if namespace else nodename",
            "    iterable = etree.iterparse(reader, tag=tag, encoding=reader.encoding)",
            "    selxpath = '//' + ('%s:%s' % (prefix, nodename) if namespace else nodename)",
            "    for _, node in iterable:",
            "        nodetext = etree.tostring(node, encoding='unicode')",
            "        node.clear()",
            "        xs = Selector(text=nodetext, type='xml')",
            "        if namespace:",
            "            xs.register_namespace(prefix, namespace)",
            "        yield xs.xpath(selxpath)[0]",
            "",
            "",
            "class _StreamReader(object):",
            "",
            "    def __init__(self, obj):",
            "        self._ptr = 0",
            "        if isinstance(obj, Response):",
            "            self._text, self.encoding = obj.body, obj.encoding",
            "        else:",
            "            self._text, self.encoding = obj, 'utf-8'",
            "        self._is_unicode = isinstance(self._text, six.text_type)",
            "",
            "    def read(self, n=65535):",
            "        self.read = self._read_unicode if self._is_unicode else self._read_string",
            "        return self.read(n).lstrip()",
            "",
            "    def _read_string(self, n=65535):",
            "        s, e = self._ptr, self._ptr + n",
            "        self._ptr = e",
            "        return self._text[s:e]",
            "",
            "    def _read_unicode(self, n=65535):",
            "        s, e = self._ptr, self._ptr + n",
            "        self._ptr = e",
            "        return self._text[s:e].encode('utf-8')",
            "",
            "",
            "def csviter(obj, delimiter=None, headers=None, encoding=None, quotechar=None):",
            "    \"\"\" Returns an iterator of dictionaries from the given csv object",
            "",
            "    obj can be:",
            "    - a Response object",
            "    - a unicode string",
            "    - a string encoded as utf-8",
            "",
            "    delimiter is the character used to separate fields on the given obj.",
            "",
            "    headers is an iterable that when provided offers the keys",
            "    for the returned dictionaries, if not the first row is used.",
            "",
            "    quotechar is the character used to enclosure fields on the given obj.",
            "    \"\"\"",
            "",
            "    encoding = obj.encoding if isinstance(obj, TextResponse) else encoding or 'utf-8'",
            "",
            "    def row_to_unicode(row_):",
            "        return [to_unicode(field, encoding) for field in row_]",
            "",
            "    # Python 3 csv reader input object needs to return strings",
            "    if six.PY3:",
            "        lines = StringIO(_body_or_str(obj, unicode=True))",
            "    else:",
            "        lines = BytesIO(_body_or_str(obj, unicode=False))",
            "",
            "    kwargs = {}",
            "    if delimiter: kwargs[\"delimiter\"] = delimiter",
            "    if quotechar: kwargs[\"quotechar\"] = quotechar",
            "    csv_r = csv.reader(lines, **kwargs)",
            "",
            "    if not headers:",
            "        try:",
            "            row = next(csv_r)",
            "        except StopIteration:",
            "            return",
            "        headers = row_to_unicode(row)",
            "",
            "    for row in csv_r:",
            "        row = row_to_unicode(row)",
            "        if len(row) != len(headers):",
            "            logger.warning(\"ignoring row %(csvlnum)d (length: %(csvrow)d, \"",
            "                           \"should be: %(csvheader)d)\",",
            "                           {'csvlnum': csv_r.line_num, 'csvrow': len(row),",
            "                            'csvheader': len(headers)})",
            "            continue",
            "        else:",
            "            yield dict(zip(headers, row))",
            "",
            "",
            "def _body_or_str(obj, unicode=True):",
            "    expected_types = (Response, six.text_type, six.binary_type)",
            "    assert isinstance(obj, expected_types), \\",
            "        \"obj must be %s, not %s\" % (",
            "            \" or \".join(t.__name__ for t in expected_types),",
            "            type(obj).__name__)",
            "    if isinstance(obj, Response):",
            "        if not unicode:",
            "            return obj.body",
            "        elif isinstance(obj, TextResponse):",
            "            return obj.text",
            "        else:",
            "            return obj.body.decode('utf-8')",
            "    elif isinstance(obj, six.text_type):",
            "        return obj if unicode else obj.encode('utf-8')",
            "    else:",
            "        return obj.decode('utf-8') if unicode else obj"
        ],
        "afterPatchFile": [
            "import re",
            "import csv",
            "import logging",
            "try:",
            "    from cStringIO import StringIO as BytesIO",
            "except ImportError:",
            "    from io import BytesIO",
            "from io import StringIO",
            "from warnings import warn",
            "",
            "import six",
            "from lxml import etree",
            "",
            "from scrapy.exceptions import ScrapyDeprecationWarning",
            "from scrapy.http import TextResponse, Response",
            "from scrapy.selector import Selector",
            "from scrapy.utils.python import re_rsearch, to_unicode",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "def xmliter(obj, nodename):",
            "    \"\"\"Return a iterator of Selector's over all nodes of a XML document,",
            "       given the name of the node to iterate. Useful for parsing XML feeds.",
            "",
            "    obj can be:",
            "    - a Response object",
            "    - a unicode string",
            "    - a string encoded as utf-8",
            "    \"\"\"",
            "    warn(",
            "        (",
            "            \"xmliter is deprecated and its use strongly discouraged because \"",
            "            \"it is vulnerable to ReDoS attacks. Use xmliter_lxml instead. See \"",
            "            \"https://github.com/scrapy/scrapy/security/advisories/GHSA-cc65-xxvf-f7r9\"",
            "        ),",
            "        ScrapyDeprecationWarning,",
            "        stacklevel=2,",
            "    )",
            "    nodename_patt = re.escape(nodename)",
            "",
            "    HEADER_START_RE = re.compile(r'^(.{,1024}?)<\\s*%s(?:\\s|>)' % nodename_patt, re.S)",
            "    HEADER_END_RE = re.compile(r'<\\s*/%s\\s*>' % nodename_patt, re.S)",
            "    text = _body_or_str(obj)",
            "",
            "    header_start = re.search(HEADER_START_RE, text)",
            "    header_start = header_start.group(1).strip() if header_start else ''",
            "    header_end = re_rsearch(HEADER_END_RE, text)",
            "    header_end = text[header_end[1]:].strip() if header_end else ''",
            "",
            "    r = re.compile(r'<%(np)s[\\s>].{,1024}?</%(np)s>' % {'np': nodename_patt}, re.DOTALL)",
            "    for match in r.finditer(text):",
            "        nodetext = header_start + match.group() + header_end",
            "        yield Selector(text=nodetext, type='xml').xpath('//' + nodename)[0]",
            "",
            "",
            "def xmliter_lxml(obj, nodename, namespace=None, prefix='x'):",
            "    reader = _StreamReader(obj)",
            "    tag = '{%s}%s' % (namespace, nodename) if namespace else nodename",
            "    iterable = etree.iterparse(",
            "        reader,",
            "        encoding=reader.encoding,",
            "        events=(\"end\", \"start-ns\"),",
            "        huge_tree=True,",
            "    )",
            "    selxpath = '//' + ('%s:%s' % (prefix, nodename) if namespace else nodename)",
            "    needs_namespace_resolution = not namespace and \":\" in nodename",
            "    if needs_namespace_resolution:",
            "        prefix, nodename = nodename.split(\":\", maxsplit=1)",
            "    for event, data in iterable:",
            "        if event == \"start-ns\":",
            "            assert isinstance(data, tuple)",
            "            if needs_namespace_resolution:",
            "                _prefix, _namespace = data",
            "                if _prefix != prefix:",
            "                    continue",
            "                namespace = _namespace",
            "                needs_namespace_resolution = False",
            "                selxpath = \"//{prefix}:{nodename}\".format(prefix=prefix, nodename=nodename)",
            "                tag = \"{{{namespace}}}{nodename}\".format(namespace=namespace, nodename=nodename)",
            "            continue",
            "        assert isinstance(data, etree._Element)",
            "        node = data",
            "        if node.tag != tag:",
            "            continue",
            "        nodetext = etree.tostring(node, encoding='unicode')",
            "        node.clear()",
            "        xs = Selector(text=nodetext, type='xml')",
            "        if namespace:",
            "            xs.register_namespace(prefix, namespace)",
            "        yield xs.xpath(selxpath)[0]",
            "",
            "",
            "class _StreamReader(object):",
            "",
            "    def __init__(self, obj):",
            "        self._ptr = 0",
            "        if isinstance(obj, Response):",
            "            self._text, self.encoding = obj.body, obj.encoding",
            "        else:",
            "            self._text, self.encoding = obj, 'utf-8'",
            "        self._is_unicode = isinstance(self._text, six.text_type)",
            "",
            "    def read(self, n=65535):",
            "        self.read = self._read_unicode if self._is_unicode else self._read_string",
            "        return self.read(n).lstrip()",
            "",
            "    def _read_string(self, n=65535):",
            "        s, e = self._ptr, self._ptr + n",
            "        self._ptr = e",
            "        return self._text[s:e]",
            "",
            "    def _read_unicode(self, n=65535):",
            "        s, e = self._ptr, self._ptr + n",
            "        self._ptr = e",
            "        return self._text[s:e].encode('utf-8')",
            "",
            "",
            "def csviter(obj, delimiter=None, headers=None, encoding=None, quotechar=None):",
            "    \"\"\" Returns an iterator of dictionaries from the given csv object",
            "",
            "    obj can be:",
            "    - a Response object",
            "    - a unicode string",
            "    - a string encoded as utf-8",
            "",
            "    delimiter is the character used to separate fields on the given obj.",
            "",
            "    headers is an iterable that when provided offers the keys",
            "    for the returned dictionaries, if not the first row is used.",
            "",
            "    quotechar is the character used to enclosure fields on the given obj.",
            "    \"\"\"",
            "",
            "    encoding = obj.encoding if isinstance(obj, TextResponse) else encoding or 'utf-8'",
            "",
            "    def row_to_unicode(row_):",
            "        return [to_unicode(field, encoding) for field in row_]",
            "",
            "    # Python 3 csv reader input object needs to return strings",
            "    if six.PY3:",
            "        lines = StringIO(_body_or_str(obj, unicode=True))",
            "    else:",
            "        lines = BytesIO(_body_or_str(obj, unicode=False))",
            "",
            "    kwargs = {}",
            "    if delimiter: kwargs[\"delimiter\"] = delimiter",
            "    if quotechar: kwargs[\"quotechar\"] = quotechar",
            "    csv_r = csv.reader(lines, **kwargs)",
            "",
            "    if not headers:",
            "        try:",
            "            row = next(csv_r)",
            "        except StopIteration:",
            "            return",
            "        headers = row_to_unicode(row)",
            "",
            "    for row in csv_r:",
            "        row = row_to_unicode(row)",
            "        if len(row) != len(headers):",
            "            logger.warning(\"ignoring row %(csvlnum)d (length: %(csvrow)d, \"",
            "                           \"should be: %(csvheader)d)\",",
            "                           {'csvlnum': csv_r.line_num, 'csvrow': len(row),",
            "                            'csvheader': len(headers)})",
            "            continue",
            "        else:",
            "            yield dict(zip(headers, row))",
            "",
            "",
            "def _body_or_str(obj, unicode=True):",
            "    expected_types = (Response, six.text_type, six.binary_type)",
            "    assert isinstance(obj, expected_types), \\",
            "        \"obj must be %s, not %s\" % (",
            "            \" or \".join(t.__name__ for t in expected_types),",
            "            type(obj).__name__)",
            "    if isinstance(obj, Response):",
            "        if not unicode:",
            "            return obj.body",
            "        elif isinstance(obj, TextResponse):",
            "            return obj.text",
            "        else:",
            "            return obj.body.decode('utf-8')",
            "    elif isinstance(obj, six.text_type):",
            "        return obj if unicode else obj.encode('utf-8')",
            "    else:",
            "        return obj.decode('utf-8') if unicode else obj"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "-1",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "45": [
                "xmliter_lxml"
            ],
            "48": [
                "xmliter_lxml"
            ],
            "50": [
                "xmliter_lxml"
            ]
        },
        "addLocation": [
            "nova.virt.libvirt.driver.LibvirtDriver"
        ]
    }
}