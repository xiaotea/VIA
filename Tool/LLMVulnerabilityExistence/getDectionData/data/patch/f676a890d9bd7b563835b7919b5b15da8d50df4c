{
    "superset/connectors/sqla/models.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 96,
                "PatchRowcode": " from superset.superset_typing import ("
            },
            "1": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "     AdhocColumn,"
            },
            "2": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 98,
                "PatchRowcode": "     AdhocMetric,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+    Column as ColumnTyping,"
            },
            "4": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "     Metric,"
            },
            "5": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "     OrderBy,"
            },
            "6": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "     QueryObjectDict,"
            },
            "7": {
                "beforePatchRowNumber": 1067,
                "afterPatchRowNumber": 1068,
                "PatchRowcode": "     def get_sqla_query(  # pylint: disable=too-many-arguments,too-many-locals,too-many-branches,too-many-statements"
            },
            "8": {
                "beforePatchRowNumber": 1068,
                "afterPatchRowNumber": 1069,
                "PatchRowcode": "         self,"
            },
            "9": {
                "beforePatchRowNumber": 1069,
                "afterPatchRowNumber": 1070,
                "PatchRowcode": "         apply_fetch_values_predicate: bool = False,"
            },
            "10": {
                "beforePatchRowNumber": 1070,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        columns: Optional[List[Column]] = None,"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1071,
                "PatchRowcode": "+        columns: Optional[List[ColumnTyping]] = None,"
            },
            "12": {
                "beforePatchRowNumber": 1071,
                "afterPatchRowNumber": 1072,
                "PatchRowcode": "         extras: Optional[Dict[str, Any]] = None,"
            },
            "13": {
                "beforePatchRowNumber": 1072,
                "afterPatchRowNumber": 1073,
                "PatchRowcode": "         filter: Optional[  # pylint: disable=redefined-builtin"
            },
            "14": {
                "beforePatchRowNumber": 1073,
                "afterPatchRowNumber": 1074,
                "PatchRowcode": "             List[QueryObjectFilterClause]"
            },
            "15": {
                "beforePatchRowNumber": 1261,
                "afterPatchRowNumber": 1262,
                "PatchRowcode": "                 select_exprs.append(outer)"
            },
            "16": {
                "beforePatchRowNumber": 1262,
                "afterPatchRowNumber": 1263,
                "PatchRowcode": "         elif columns:"
            },
            "17": {
                "beforePatchRowNumber": 1263,
                "afterPatchRowNumber": 1264,
                "PatchRowcode": "             for selected in columns:"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1265,
                "PatchRowcode": "+                if is_adhoc_column(selected):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1266,
                "PatchRowcode": "+                    _sql = selected[\"sqlExpression\"]"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1267,
                "PatchRowcode": "+                    _column_label = selected[\"label\"]"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1268,
                "PatchRowcode": "+                elif isinstance(selected, str):"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1269,
                "PatchRowcode": "+                    _sql = selected"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1270,
                "PatchRowcode": "+                    _column_label = selected"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1271,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": 1264,
                "afterPatchRowNumber": 1272,
                "PatchRowcode": "                 selected = validate_adhoc_subquery("
            },
            "26": {
                "beforePatchRowNumber": 1265,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    selected,"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1273,
                "PatchRowcode": "+                    _sql,"
            },
            "28": {
                "beforePatchRowNumber": 1266,
                "afterPatchRowNumber": 1274,
                "PatchRowcode": "                     self.database_id,"
            },
            "29": {
                "beforePatchRowNumber": 1267,
                "afterPatchRowNumber": 1275,
                "PatchRowcode": "                     self.schema,"
            },
            "30": {
                "beforePatchRowNumber": 1268,
                "afterPatchRowNumber": 1276,
                "PatchRowcode": "                 )"
            },
            "31": {
                "beforePatchRowNumber": 1269,
                "afterPatchRowNumber": 1277,
                "PatchRowcode": "                 select_exprs.append("
            },
            "32": {
                "beforePatchRowNumber": 1270,
                "afterPatchRowNumber": 1278,
                "PatchRowcode": "                     columns_by_name[selected].get_sqla_col()"
            },
            "33": {
                "beforePatchRowNumber": 1271,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    if selected in columns_by_name"
            },
            "34": {
                "beforePatchRowNumber": 1272,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    else self.make_sqla_column_compatible(literal_column(selected))"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1279,
                "PatchRowcode": "+                    if isinstance(selected, str) and selected in columns_by_name"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1280,
                "PatchRowcode": "+                    else self.make_sqla_column_compatible("
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1281,
                "PatchRowcode": "+                        literal_column(selected), _column_label"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1282,
                "PatchRowcode": "+                    )"
            },
            "39": {
                "beforePatchRowNumber": 1273,
                "afterPatchRowNumber": 1283,
                "PatchRowcode": "                 )"
            },
            "40": {
                "beforePatchRowNumber": 1274,
                "afterPatchRowNumber": 1284,
                "PatchRowcode": "             metrics_exprs = []"
            },
            "41": {
                "beforePatchRowNumber": 1275,
                "afterPatchRowNumber": 1285,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "# pylint: disable=too-many-lines",
            "import dataclasses",
            "import json",
            "import logging",
            "import re",
            "from collections import defaultdict",
            "from dataclasses import dataclass, field",
            "from datetime import datetime, timedelta",
            "from typing import (",
            "    Any,",
            "    cast,",
            "    Dict,",
            "    Hashable,",
            "    List,",
            "    NamedTuple,",
            "    Optional,",
            "    Tuple,",
            "    Type,",
            "    Union,",
            ")",
            "",
            "import dateutil.parser",
            "import numpy as np",
            "import pandas as pd",
            "import sqlalchemy as sa",
            "import sqlparse",
            "from flask import escape, Markup",
            "from flask_appbuilder import Model",
            "from flask_babel import lazy_gettext as _",
            "from jinja2.exceptions import TemplateError",
            "from sqlalchemy import (",
            "    and_,",
            "    asc,",
            "    Boolean,",
            "    Column,",
            "    DateTime,",
            "    desc,",
            "    Enum,",
            "    ForeignKey,",
            "    inspect,",
            "    Integer,",
            "    or_,",
            "    select,",
            "    String,",
            "    Table,",
            "    Text,",
            "    update,",
            ")",
            "from sqlalchemy.engine.base import Connection",
            "from sqlalchemy.orm import backref, Query, relationship, RelationshipProperty, Session",
            "from sqlalchemy.orm.mapper import Mapper",
            "from sqlalchemy.schema import UniqueConstraint",
            "from sqlalchemy.sql import column, ColumnElement, literal_column, table",
            "from sqlalchemy.sql.elements import ColumnClause, TextClause",
            "from sqlalchemy.sql.expression import Label, Select, TextAsFrom",
            "from sqlalchemy.sql.selectable import Alias, TableClause",
            "",
            "from superset import app, db, is_feature_enabled, security_manager",
            "from superset.common.db_query_status import QueryStatus",
            "from superset.connectors.base.models import BaseColumn, BaseDatasource, BaseMetric",
            "from superset.connectors.sqla.utils import (",
            "    get_physical_table_metadata,",
            "    get_virtual_table_metadata,",
            "    validate_adhoc_subquery,",
            ")",
            "from superset.db_engine_specs.base import BaseEngineSpec, CTE_ALIAS, TimestampExpression",
            "from superset.exceptions import (",
            "    QueryClauseValidationException,",
            "    QueryObjectValidationError,",
            ")",
            "from superset.jinja_context import (",
            "    BaseTemplateProcessor,",
            "    ExtraCache,",
            "    get_template_processor,",
            ")",
            "from superset.models.annotations import Annotation",
            "from superset.models.core import Database",
            "from superset.models.helpers import AuditMixinNullable, CertificationMixin, QueryResult",
            "from superset.sql_parse import ParsedQuery, sanitize_clause",
            "from superset.superset_typing import (",
            "    AdhocColumn,",
            "    AdhocMetric,",
            "    Metric,",
            "    OrderBy,",
            "    QueryObjectDict,",
            ")",
            "from superset.utils import core as utils",
            "from superset.utils.core import (",
            "    GenericDataType,",
            "    get_column_name,",
            "    is_adhoc_column,",
            "    QueryObjectFilterClause,",
            "    remove_duplicates,",
            ")",
            "",
            "config = app.config",
            "metadata = Model.metadata  # pylint: disable=no-member",
            "logger = logging.getLogger(__name__)",
            "",
            "VIRTUAL_TABLE_ALIAS = \"virtual_table\"",
            "",
            "# a non-exhaustive set of additive metrics",
            "ADDITIVE_METRIC_TYPES = {",
            "    \"count\",",
            "    \"sum\",",
            "    \"doubleSum\",",
            "}",
            "",
            "",
            "class SqlaQuery(NamedTuple):",
            "    applied_template_filters: List[str]",
            "    cte: Optional[str]",
            "    extra_cache_keys: List[Any]",
            "    labels_expected: List[str]",
            "    prequeries: List[str]",
            "    sqla_query: Select",
            "",
            "",
            "class QueryStringExtended(NamedTuple):",
            "    applied_template_filters: Optional[List[str]]",
            "    labels_expected: List[str]",
            "    prequeries: List[str]",
            "    sql: str",
            "",
            "",
            "@dataclass",
            "class MetadataResult:",
            "    added: List[str] = field(default_factory=list)",
            "    removed: List[str] = field(default_factory=list)",
            "    modified: List[str] = field(default_factory=list)",
            "",
            "",
            "class AnnotationDatasource(BaseDatasource):",
            "    \"\"\"Dummy object so we can query annotations using 'Viz' objects just like",
            "    regular datasources.",
            "    \"\"\"",
            "",
            "    cache_timeout = 0",
            "    changed_on = None",
            "    type = \"annotation\"",
            "    column_names = [",
            "        \"created_on\",",
            "        \"changed_on\",",
            "        \"id\",",
            "        \"start_dttm\",",
            "        \"end_dttm\",",
            "        \"layer_id\",",
            "        \"short_descr\",",
            "        \"long_descr\",",
            "        \"json_metadata\",",
            "        \"created_by_fk\",",
            "        \"changed_by_fk\",",
            "    ]",
            "",
            "    def query(self, query_obj: QueryObjectDict) -> QueryResult:",
            "        error_message = None",
            "        qry = db.session.query(Annotation)",
            "        qry = qry.filter(Annotation.layer_id == query_obj[\"filter\"][0][\"val\"])",
            "        if query_obj[\"from_dttm\"]:",
            "            qry = qry.filter(Annotation.start_dttm >= query_obj[\"from_dttm\"])",
            "        if query_obj[\"to_dttm\"]:",
            "            qry = qry.filter(Annotation.end_dttm <= query_obj[\"to_dttm\"])",
            "        status = QueryStatus.SUCCESS",
            "        try:",
            "            df = pd.read_sql_query(qry.statement, db.engine)",
            "        except Exception as ex:  # pylint: disable=broad-except",
            "            df = pd.DataFrame()",
            "            status = QueryStatus.FAILED",
            "            logger.exception(ex)",
            "            error_message = utils.error_msg_from_exception(ex)",
            "        return QueryResult(",
            "            status=status,",
            "            df=df,",
            "            duration=timedelta(0),",
            "            query=\"\",",
            "            error_message=error_message,",
            "        )",
            "",
            "    def get_query_str(self, query_obj: QueryObjectDict) -> str:",
            "        raise NotImplementedError()",
            "",
            "    def values_for_column(self, column_name: str, limit: int = 10000) -> List[Any]:",
            "        raise NotImplementedError()",
            "",
            "",
            "class TableColumn(Model, BaseColumn, CertificationMixin):",
            "",
            "    \"\"\"ORM object for table columns, each table can have multiple columns\"\"\"",
            "",
            "    __tablename__ = \"table_columns\"",
            "    __table_args__ = (UniqueConstraint(\"table_id\", \"column_name\"),)",
            "    table_id = Column(Integer, ForeignKey(\"tables.id\"))",
            "    table = relationship(",
            "        \"SqlaTable\",",
            "        backref=backref(\"columns\", cascade=\"all, delete-orphan\"),",
            "        foreign_keys=[table_id],",
            "    )",
            "    is_dttm = Column(Boolean, default=False)",
            "    expression = Column(Text)",
            "    python_date_format = Column(String(255))",
            "    extra = Column(Text)",
            "",
            "    export_fields = [",
            "        \"table_id\",",
            "        \"column_name\",",
            "        \"verbose_name\",",
            "        \"is_dttm\",",
            "        \"is_active\",",
            "        \"type\",",
            "        \"groupby\",",
            "        \"filterable\",",
            "        \"expression\",",
            "        \"description\",",
            "        \"python_date_format\",",
            "        \"extra\",",
            "    ]",
            "",
            "    update_from_object_fields = [s for s in export_fields if s not in (\"table_id\",)]",
            "    export_parent = \"table\"",
            "",
            "    @property",
            "    def is_boolean(self) -> bool:",
            "        \"\"\"",
            "        Check if the column has a boolean datatype.",
            "        \"\"\"",
            "        return self.type_generic == GenericDataType.BOOLEAN",
            "",
            "    @property",
            "    def is_numeric(self) -> bool:",
            "        \"\"\"",
            "        Check if the column has a numeric datatype.",
            "        \"\"\"",
            "        return self.type_generic == GenericDataType.NUMERIC",
            "",
            "    @property",
            "    def is_string(self) -> bool:",
            "        \"\"\"",
            "        Check if the column has a string datatype.",
            "        \"\"\"",
            "        return self.type_generic == GenericDataType.STRING",
            "",
            "    @property",
            "    def is_temporal(self) -> bool:",
            "        \"\"\"",
            "        Check if the column has a temporal datatype. If column has been set as",
            "        temporal/non-temporal (`is_dttm` is True or False respectively), return that",
            "        value. This usually happens during initial metadata fetching or when a column",
            "        is manually set as temporal (for this `python_date_format` needs to be set).",
            "        \"\"\"",
            "        if self.is_dttm is not None:",
            "            return self.is_dttm",
            "        return self.type_generic == GenericDataType.TEMPORAL",
            "",
            "    @property",
            "    def db_engine_spec(self) -> Type[BaseEngineSpec]:",
            "        return self.table.db_engine_spec",
            "",
            "    @property",
            "    def db_extra(self) -> Dict[str, Any]:",
            "        return self.table.database.get_extra()",
            "",
            "    @property",
            "    def type_generic(self) -> Optional[utils.GenericDataType]:",
            "        if self.is_dttm:",
            "            return GenericDataType.TEMPORAL",
            "        column_spec = self.db_engine_spec.get_column_spec(",
            "            self.type, db_extra=self.db_extra",
            "        )",
            "        return column_spec.generic_type if column_spec else None",
            "",
            "    def get_sqla_col(self, label: Optional[str] = None) -> Column:",
            "        label = label or self.column_name",
            "        db_engine_spec = self.db_engine_spec",
            "        column_spec = db_engine_spec.get_column_spec(self.type, db_extra=self.db_extra)",
            "        type_ = column_spec.sqla_type if column_spec else None",
            "        if self.expression:",
            "            tp = self.table.get_template_processor()",
            "            expression = tp.process_template(self.expression)",
            "            col = literal_column(expression, type_=type_)",
            "        else:",
            "            col = column(self.column_name, type_=type_)",
            "        col = self.table.make_sqla_column_compatible(col, label)",
            "        return col",
            "",
            "    @property",
            "    def datasource(self) -> RelationshipProperty:",
            "        return self.table",
            "",
            "    def get_time_filter(",
            "        self,",
            "        start_dttm: DateTime,",
            "        end_dttm: DateTime,",
            "        time_range_endpoints: Optional[",
            "            Tuple[utils.TimeRangeEndpoint, utils.TimeRangeEndpoint]",
            "        ],",
            "    ) -> ColumnElement:",
            "        col = self.get_sqla_col(label=\"__time\")",
            "        l = []",
            "        if start_dttm:",
            "            l.append(",
            "                col",
            "                >= self.table.text(",
            "                    self.dttm_sql_literal(start_dttm, time_range_endpoints)",
            "                )",
            "            )",
            "        if end_dttm:",
            "            if (",
            "                time_range_endpoints",
            "                and time_range_endpoints[1] == utils.TimeRangeEndpoint.EXCLUSIVE",
            "            ):",
            "                l.append(",
            "                    col",
            "                    < self.table.text(",
            "                        self.dttm_sql_literal(end_dttm, time_range_endpoints)",
            "                    )",
            "                )",
            "            else:",
            "                l.append(col <= self.table.text(self.dttm_sql_literal(end_dttm, None)))",
            "        return and_(*l)",
            "",
            "    def get_timestamp_expression(",
            "        self,",
            "        time_grain: Optional[str],",
            "        label: Optional[str] = None,",
            "        template_processor: Optional[BaseTemplateProcessor] = None,",
            "    ) -> Union[TimestampExpression, Label]:",
            "        \"\"\"",
            "        Return a SQLAlchemy Core element representation of self to be used in a query.",
            "",
            "        :param time_grain: Optional time grain, e.g. P1Y",
            "        :param label: alias/label that column is expected to have",
            "        :param template_processor: template processor",
            "        :return: A TimeExpression object wrapped in a Label if supported by db",
            "        \"\"\"",
            "        label = label or utils.DTTM_ALIAS",
            "",
            "        pdf = self.python_date_format",
            "        is_epoch = pdf in (\"epoch_s\", \"epoch_ms\")",
            "        column_spec = self.db_engine_spec.get_column_spec(",
            "            self.type, db_extra=self.db_extra",
            "        )",
            "        type_ = column_spec.sqla_type if column_spec else DateTime",
            "        if not self.expression and not time_grain and not is_epoch:",
            "            sqla_col = column(self.column_name, type_=type_)",
            "            return self.table.make_sqla_column_compatible(sqla_col, label)",
            "        if self.expression:",
            "            expression = self.expression",
            "            if template_processor:",
            "                expression = template_processor.process_template(self.expression)",
            "            col = literal_column(expression, type_=type_)",
            "        else:",
            "            col = column(self.column_name, type_=type_)",
            "        time_expr = self.db_engine_spec.get_timestamp_expr(",
            "            col, pdf, time_grain, self.type",
            "        )",
            "        return self.table.make_sqla_column_compatible(time_expr, label)",
            "",
            "    def dttm_sql_literal(",
            "        self,",
            "        dttm: DateTime,",
            "        time_range_endpoints: Optional[",
            "            Tuple[utils.TimeRangeEndpoint, utils.TimeRangeEndpoint]",
            "        ],",
            "    ) -> str:",
            "        \"\"\"Convert datetime object to a SQL expression string\"\"\"",
            "        sql = (",
            "            self.db_engine_spec.convert_dttm(self.type, dttm, db_extra=self.db_extra)",
            "            if self.type",
            "            else None",
            "        )",
            "",
            "        if sql:",
            "            return sql",
            "",
            "        tf = self.python_date_format",
            "",
            "        # Fallback to the default format (if defined) only if the SIP-15 time range",
            "        # endpoints, i.e., [start, end) are enabled.",
            "        if not tf and time_range_endpoints == (",
            "            utils.TimeRangeEndpoint.INCLUSIVE,",
            "            utils.TimeRangeEndpoint.EXCLUSIVE,",
            "        ):",
            "            tf = self.db_extra.get(\"python_date_format_by_column_name\", {}).get(",
            "                self.column_name",
            "            )",
            "",
            "        if tf:",
            "            if tf in [\"epoch_ms\", \"epoch_s\"]:",
            "                seconds_since_epoch = int(dttm.timestamp())",
            "                if tf == \"epoch_s\":",
            "                    return str(seconds_since_epoch)",
            "                return str(seconds_since_epoch * 1000)",
            "            return f\"'{dttm.strftime(tf)}'\"",
            "",
            "        # TODO(john-bodley): SIP-15 will explicitly require a type conversion.",
            "        return f\"\"\"'{dttm.strftime(\"%Y-%m-%d %H:%M:%S.%f\")}'\"\"\"",
            "",
            "    @property",
            "    def data(self) -> Dict[str, Any]:",
            "        attrs = (",
            "            \"id\",",
            "            \"column_name\",",
            "            \"verbose_name\",",
            "            \"description\",",
            "            \"expression\",",
            "            \"filterable\",",
            "            \"groupby\",",
            "            \"is_dttm\",",
            "            \"type\",",
            "            \"type_generic\",",
            "            \"python_date_format\",",
            "            \"is_certified\",",
            "            \"certified_by\",",
            "            \"certification_details\",",
            "            \"warning_markdown\",",
            "        )",
            "",
            "        attr_dict = {s: getattr(self, s) for s in attrs if hasattr(self, s)}",
            "",
            "        attr_dict.update(super().data)",
            "",
            "        return attr_dict",
            "",
            "",
            "class SqlMetric(Model, BaseMetric, CertificationMixin):",
            "",
            "    \"\"\"ORM object for metrics, each table can have multiple metrics\"\"\"",
            "",
            "    __tablename__ = \"sql_metrics\"",
            "    __table_args__ = (UniqueConstraint(\"table_id\", \"metric_name\"),)",
            "    table_id = Column(Integer, ForeignKey(\"tables.id\"))",
            "    table = relationship(",
            "        \"SqlaTable\",",
            "        backref=backref(\"metrics\", cascade=\"all, delete-orphan\"),",
            "        foreign_keys=[table_id],",
            "    )",
            "    expression = Column(Text, nullable=False)",
            "    extra = Column(Text)",
            "",
            "    export_fields = [",
            "        \"metric_name\",",
            "        \"verbose_name\",",
            "        \"metric_type\",",
            "        \"table_id\",",
            "        \"expression\",",
            "        \"description\",",
            "        \"d3format\",",
            "        \"extra\",",
            "        \"warning_text\",",
            "    ]",
            "    update_from_object_fields = list(s for s in export_fields if s != \"table_id\")",
            "    export_parent = \"table\"",
            "",
            "    def get_sqla_col(self, label: Optional[str] = None) -> Column:",
            "        label = label or self.metric_name",
            "        tp = self.table.get_template_processor()",
            "        sqla_col: ColumnClause = literal_column(tp.process_template(self.expression))",
            "        return self.table.make_sqla_column_compatible(sqla_col, label)",
            "",
            "    @property",
            "    def perm(self) -> Optional[str]:",
            "        return (",
            "            (\"{parent_name}.[{obj.metric_name}](id:{obj.id})\").format(",
            "                obj=self, parent_name=self.table.full_name",
            "            )",
            "            if self.table",
            "            else None",
            "        )",
            "",
            "    def get_perm(self) -> Optional[str]:",
            "        return self.perm",
            "",
            "    @property",
            "    def data(self) -> Dict[str, Any]:",
            "        attrs = (",
            "            \"is_certified\",",
            "            \"certified_by\",",
            "            \"certification_details\",",
            "            \"warning_markdown\",",
            "        )",
            "        attr_dict = {s: getattr(self, s) for s in attrs}",
            "",
            "        attr_dict.update(super().data)",
            "        return attr_dict",
            "",
            "",
            "sqlatable_user = Table(",
            "    \"sqlatable_user\",",
            "    metadata,",
            "    Column(\"id\", Integer, primary_key=True),",
            "    Column(\"user_id\", Integer, ForeignKey(\"ab_user.id\")),",
            "    Column(\"table_id\", Integer, ForeignKey(\"tables.id\")),",
            ")",
            "",
            "",
            "def _process_sql_expression(",
            "    expression: Optional[str],",
            "    database_id: int,",
            "    schema: str,",
            "    template_processor: Optional[BaseTemplateProcessor],",
            ") -> Optional[str]:",
            "    if template_processor and expression:",
            "        expression = template_processor.process_template(expression)",
            "    if expression:",
            "        expression = validate_adhoc_subquery(",
            "            expression,",
            "            database_id,",
            "            schema,",
            "        )",
            "        try:",
            "            expression = sanitize_clause(expression)",
            "        except QueryClauseValidationException as ex:",
            "            raise QueryObjectValidationError(ex.message) from ex",
            "    return expression",
            "",
            "",
            "class SqlaTable(Model, BaseDatasource):  # pylint: disable=too-many-public-methods",
            "    \"\"\"An ORM object for SqlAlchemy table references\"\"\"",
            "",
            "    type = \"table\"",
            "    query_language = \"sql\"",
            "    is_rls_supported = True",
            "    columns: List[TableColumn] = []",
            "    metrics: List[SqlMetric] = []",
            "    metric_class = SqlMetric",
            "    column_class = TableColumn",
            "    owner_class = security_manager.user_model",
            "",
            "    __tablename__ = \"tables\"",
            "",
            "    # Note this uniqueness constraint is not part of the physical schema, i.e., it does",
            "    # not exist in the migrations, but is required by `import_from_dict` to ensure the",
            "    # correct filters are applied in order to identify uniqueness.",
            "    #",
            "    # The reason it does not physically exist is MySQL, PostgreSQL, etc. have a",
            "    # different interpretation of uniqueness when it comes to NULL which is problematic",
            "    # given the schema is optional.",
            "    __table_args__ = (UniqueConstraint(\"database_id\", \"schema\", \"table_name\"),)",
            "",
            "    table_name = Column(String(250), nullable=False)",
            "    main_dttm_col = Column(String(250))",
            "    database_id = Column(Integer, ForeignKey(\"dbs.id\"), nullable=False)",
            "    fetch_values_predicate = Column(Text)",
            "    owners = relationship(owner_class, secondary=sqlatable_user, backref=\"tables\")",
            "    database: Database = relationship(",
            "        \"Database\",",
            "        backref=backref(\"tables\", cascade=\"all, delete-orphan\"),",
            "        foreign_keys=[database_id],",
            "    )",
            "    schema = Column(String(255))",
            "    sql = Column(Text)",
            "    is_sqllab_view = Column(Boolean, default=False)",
            "    template_params = Column(Text)",
            "    extra = Column(Text)",
            "",
            "    baselink = \"tablemodelview\"",
            "",
            "    export_fields = [",
            "        \"table_name\",",
            "        \"main_dttm_col\",",
            "        \"description\",",
            "        \"default_endpoint\",",
            "        \"database_id\",",
            "        \"offset\",",
            "        \"cache_timeout\",",
            "        \"schema\",",
            "        \"sql\",",
            "        \"params\",",
            "        \"template_params\",",
            "        \"filter_select_enabled\",",
            "        \"fetch_values_predicate\",",
            "        \"extra\",",
            "    ]",
            "    update_from_object_fields = [f for f in export_fields if f != \"database_id\"]",
            "    export_parent = \"database\"",
            "    export_children = [\"metrics\", \"columns\"]",
            "",
            "    sqla_aggregations = {",
            "        \"COUNT_DISTINCT\": lambda column_name: sa.func.COUNT(sa.distinct(column_name)),",
            "        \"COUNT\": sa.func.COUNT,",
            "        \"SUM\": sa.func.SUM,",
            "        \"AVG\": sa.func.AVG,",
            "        \"MIN\": sa.func.MIN,",
            "        \"MAX\": sa.func.MAX,",
            "    }",
            "",
            "    def __repr__(self) -> str:",
            "        return self.name",
            "",
            "    @staticmethod",
            "    def _apply_cte(sql: str, cte: Optional[str]) -> str:",
            "        \"\"\"",
            "        Append a CTE before the SELECT statement if defined",
            "",
            "        :param sql: SELECT statement",
            "        :param cte: CTE statement",
            "        :return:",
            "        \"\"\"",
            "        if cte:",
            "            sql = f\"{cte}\\n{sql}\"",
            "        return sql",
            "",
            "    @property",
            "    def db_engine_spec(self) -> Type[BaseEngineSpec]:",
            "        return self.database.db_engine_spec",
            "",
            "    @property",
            "    def changed_by_name(self) -> str:",
            "        if not self.changed_by:",
            "            return \"\"",
            "        return str(self.changed_by)",
            "",
            "    @property",
            "    def changed_by_url(self) -> str:",
            "        if not self.changed_by:",
            "            return \"\"",
            "        return f\"/superset/profile/{self.changed_by.username}\"",
            "",
            "    @property",
            "    def connection(self) -> str:",
            "        return str(self.database)",
            "",
            "    @property",
            "    def description_markeddown(self) -> str:",
            "        return utils.markdown(self.description)",
            "",
            "    @property",
            "    def datasource_name(self) -> str:",
            "        return self.table_name",
            "",
            "    @property",
            "    def datasource_type(self) -> str:",
            "        return self.type",
            "",
            "    @property",
            "    def database_name(self) -> str:",
            "        return self.database.name",
            "",
            "    @classmethod",
            "    def get_datasource_by_name(",
            "        cls,",
            "        session: Session,",
            "        datasource_name: str,",
            "        schema: Optional[str],",
            "        database_name: str,",
            "    ) -> Optional[\"SqlaTable\"]:",
            "        schema = schema or None",
            "        query = (",
            "            session.query(cls)",
            "            .join(Database)",
            "            .filter(cls.table_name == datasource_name)",
            "            .filter(Database.database_name == database_name)",
            "        )",
            "        # Handling schema being '' or None, which is easier to handle",
            "        # in python than in the SQLA query in a multi-dialect way",
            "        for tbl in query.all():",
            "            if schema == (tbl.schema or None):",
            "                return tbl",
            "        return None",
            "",
            "    @property",
            "    def link(self) -> Markup:",
            "        name = escape(self.name)",
            "        anchor = f'<a target=\"_blank\" href=\"{self.explore_url}\">{name}</a>'",
            "        return Markup(anchor)",
            "",
            "    def get_schema_perm(self) -> Optional[str]:",
            "        \"\"\"Returns schema permission if present, database one otherwise.\"\"\"",
            "        return security_manager.get_schema_perm(self.database, self.schema)",
            "",
            "    def get_perm(self) -> str:",
            "        return f\"[{self.database}].[{self.table_name}](id:{self.id})\"",
            "",
            "    @property",
            "    def name(self) -> str:",
            "        if not self.schema:",
            "            return self.table_name",
            "        return \"{}.{}\".format(self.schema, self.table_name)",
            "",
            "    @property",
            "    def full_name(self) -> str:",
            "        return utils.get_datasource_full_name(",
            "            self.database, self.table_name, schema=self.schema",
            "        )",
            "",
            "    @property",
            "    def dttm_cols(self) -> List[str]:",
            "        l = [c.column_name for c in self.columns if c.is_dttm]",
            "        if self.main_dttm_col and self.main_dttm_col not in l:",
            "            l.append(self.main_dttm_col)",
            "        return l",
            "",
            "    @property",
            "    def num_cols(self) -> List[str]:",
            "        return [c.column_name for c in self.columns if c.is_numeric]",
            "",
            "    @property",
            "    def any_dttm_col(self) -> Optional[str]:",
            "        cols = self.dttm_cols",
            "        return cols[0] if cols else None",
            "",
            "    @property",
            "    def html(self) -> str:",
            "        df = pd.DataFrame((c.column_name, c.type) for c in self.columns)",
            "        df.columns = [\"field\", \"type\"]",
            "        return df.to_html(",
            "            index=False,",
            "            classes=(\"dataframe table table-striped table-bordered \" \"table-condensed\"),",
            "        )",
            "",
            "    @property",
            "    def sql_url(self) -> str:",
            "        return self.database.sql_url + \"?table_name=\" + str(self.table_name)",
            "",
            "    def external_metadata(self) -> List[Dict[str, str]]:",
            "        # todo(yongjie): create a pysical table column type in seprated PR",
            "        if self.sql:",
            "            return get_virtual_table_metadata(dataset=self)  # type: ignore",
            "        return get_physical_table_metadata(",
            "            database=self.database,",
            "            table_name=self.table_name,",
            "            schema_name=self.schema,",
            "        )",
            "",
            "    @property",
            "    def time_column_grains(self) -> Dict[str, Any]:",
            "        return {",
            "            \"time_columns\": self.dttm_cols,",
            "            \"time_grains\": [grain.name for grain in self.database.grains()],",
            "        }",
            "",
            "    @property",
            "    def select_star(self) -> Optional[str]:",
            "        # show_cols and latest_partition set to false to avoid",
            "        # the expensive cost of inspecting the DB",
            "        return self.database.select_star(",
            "            self.table_name, schema=self.schema, show_cols=False, latest_partition=False",
            "        )",
            "",
            "    @property",
            "    def health_check_message(self) -> Optional[str]:",
            "        check = config[\"DATASET_HEALTH_CHECK\"]",
            "        return check(self) if check else None",
            "",
            "    @property",
            "    def data(self) -> Dict[str, Any]:",
            "        data_ = super().data",
            "        if self.type == \"table\":",
            "            data_[\"granularity_sqla\"] = utils.choicify(self.dttm_cols)",
            "            data_[\"time_grain_sqla\"] = [",
            "                (g.duration, g.name) for g in self.database.grains() or []",
            "            ]",
            "            data_[\"main_dttm_col\"] = self.main_dttm_col",
            "            data_[\"fetch_values_predicate\"] = self.fetch_values_predicate",
            "            data_[\"template_params\"] = self.template_params",
            "            data_[\"is_sqllab_view\"] = self.is_sqllab_view",
            "            data_[\"health_check_message\"] = self.health_check_message",
            "            data_[\"extra\"] = self.extra",
            "        return data_",
            "",
            "    @property",
            "    def extra_dict(self) -> Dict[str, Any]:",
            "        try:",
            "            return json.loads(self.extra)",
            "        except (TypeError, json.JSONDecodeError):",
            "            return {}",
            "",
            "    def get_fetch_values_predicate(self) -> TextClause:",
            "        tp = self.get_template_processor()",
            "        try:",
            "            return self.text(tp.process_template(self.fetch_values_predicate))",
            "        except TemplateError as ex:",
            "            raise QueryObjectValidationError(",
            "                _(",
            "                    \"Error in jinja expression in fetch values predicate: %(msg)s\",",
            "                    msg=ex.message,",
            "                )",
            "            ) from ex",
            "",
            "    def values_for_column(self, column_name: str, limit: int = 10000) -> List[Any]:",
            "        \"\"\"Runs query against sqla to retrieve some",
            "        sample values for the given column.",
            "        \"\"\"",
            "        cols = {col.column_name: col for col in self.columns}",
            "        target_col = cols[column_name]",
            "        tp = self.get_template_processor()",
            "        tbl, cte = self.get_from_clause(tp)",
            "",
            "        qry = select([target_col.get_sqla_col()]).select_from(tbl).distinct()",
            "        if limit:",
            "            qry = qry.limit(limit)",
            "",
            "        if self.fetch_values_predicate:",
            "            qry = qry.where(self.get_fetch_values_predicate())",
            "",
            "        engine = self.database.get_sqla_engine()",
            "        sql = qry.compile(engine, compile_kwargs={\"literal_binds\": True})",
            "        sql = self._apply_cte(sql, cte)",
            "        sql = self.mutate_query_from_config(sql)",
            "",
            "        df = pd.read_sql_query(sql=sql, con=engine)",
            "        return df[column_name].to_list()",
            "",
            "    def mutate_query_from_config(self, sql: str) -> str:",
            "        \"\"\"Apply config's SQL_QUERY_MUTATOR",
            "",
            "        Typically adds comments to the query with context\"\"\"",
            "        sql_query_mutator = config[\"SQL_QUERY_MUTATOR\"]",
            "        if sql_query_mutator:",
            "            username = utils.get_username()",
            "            sql = sql_query_mutator(sql, username, security_manager, self.database)",
            "        return sql",
            "",
            "    def get_template_processor(self, **kwargs: Any) -> BaseTemplateProcessor:",
            "        return get_template_processor(table=self, database=self.database, **kwargs)",
            "",
            "    def get_query_str_extended(self, query_obj: QueryObjectDict) -> QueryStringExtended:",
            "        sqlaq = self.get_sqla_query(**query_obj)",
            "        sql = self.database.compile_sqla_query(sqlaq.sqla_query)",
            "        sql = self._apply_cte(sql, sqlaq.cte)",
            "        sql = sqlparse.format(sql, reindent=True)",
            "        sql = self.mutate_query_from_config(sql)",
            "        return QueryStringExtended(",
            "            applied_template_filters=sqlaq.applied_template_filters,",
            "            labels_expected=sqlaq.labels_expected,",
            "            prequeries=sqlaq.prequeries,",
            "            sql=sql,",
            "        )",
            "",
            "    def get_query_str(self, query_obj: QueryObjectDict) -> str:",
            "        query_str_ext = self.get_query_str_extended(query_obj)",
            "        all_queries = query_str_ext.prequeries + [query_str_ext.sql]",
            "        return \";\\n\\n\".join(all_queries) + \";\"",
            "",
            "    def get_sqla_table(self) -> TableClause:",
            "        tbl = table(self.table_name)",
            "        if self.schema:",
            "            tbl.schema = self.schema",
            "        return tbl",
            "",
            "    def get_from_clause(",
            "        self, template_processor: Optional[BaseTemplateProcessor] = None",
            "    ) -> Tuple[Union[TableClause, Alias], Optional[str]]:",
            "        \"\"\"",
            "        Return where to select the columns and metrics from. Either a physical table",
            "        or a virtual table with it's own subquery. If the FROM is referencing a",
            "        CTE, the CTE is returned as the second value in the return tuple.",
            "        \"\"\"",
            "        if not self.is_virtual:",
            "            return self.get_sqla_table(), None",
            "",
            "        from_sql = self.get_rendered_sql(template_processor)",
            "        parsed_query = ParsedQuery(from_sql)",
            "        if not (",
            "            parsed_query.is_unknown()",
            "            or self.db_engine_spec.is_readonly_query(parsed_query)",
            "        ):",
            "            raise QueryObjectValidationError(",
            "                _(\"Virtual dataset query must be read-only\")",
            "            )",
            "",
            "        cte = self.db_engine_spec.get_cte_query(from_sql)",
            "        from_clause = (",
            "            table(CTE_ALIAS)",
            "            if cte",
            "            else TextAsFrom(self.text(from_sql), []).alias(VIRTUAL_TABLE_ALIAS)",
            "        )",
            "",
            "        return from_clause, cte",
            "",
            "    def get_rendered_sql(",
            "        self, template_processor: Optional[BaseTemplateProcessor] = None",
            "    ) -> str:",
            "        \"\"\"",
            "        Render sql with template engine (Jinja).",
            "        \"\"\"",
            "",
            "        sql = self.sql",
            "        if template_processor:",
            "            try:",
            "                sql = template_processor.process_template(sql)",
            "            except TemplateError as ex:",
            "                raise QueryObjectValidationError(",
            "                    _(",
            "                        \"Error while rendering virtual dataset query: %(msg)s\",",
            "                        msg=ex.message,",
            "                    )",
            "                ) from ex",
            "        sql = sqlparse.format(sql.strip(\"\\t\\r\\n; \"), strip_comments=True)",
            "        if not sql:",
            "            raise QueryObjectValidationError(_(\"Virtual dataset query cannot be empty\"))",
            "        if len(sqlparse.split(sql)) > 1:",
            "            raise QueryObjectValidationError(",
            "                _(\"Virtual dataset query cannot consist of multiple statements\")",
            "            )",
            "        return sql",
            "",
            "    def adhoc_metric_to_sqla(",
            "        self,",
            "        metric: AdhocMetric,",
            "        columns_by_name: Dict[str, TableColumn],",
            "        template_processor: Optional[BaseTemplateProcessor] = None,",
            "    ) -> ColumnElement:",
            "        \"\"\"",
            "        Turn an adhoc metric into a sqlalchemy column.",
            "",
            "        :param dict metric: Adhoc metric definition",
            "        :param dict columns_by_name: Columns for the current table",
            "        :param template_processor: template_processor instance",
            "        :returns: The metric defined as a sqlalchemy column",
            "        :rtype: sqlalchemy.sql.column",
            "        \"\"\"",
            "        expression_type = metric.get(\"expressionType\")",
            "        label = utils.get_metric_name(metric)",
            "",
            "        if expression_type == utils.AdhocMetricExpressionType.SIMPLE:",
            "            metric_column = metric.get(\"column\") or {}",
            "            column_name = cast(str, metric_column.get(\"column_name\"))",
            "            table_column: Optional[TableColumn] = columns_by_name.get(column_name)",
            "            if table_column:",
            "                sqla_column = table_column.get_sqla_col()",
            "            else:",
            "                sqla_column = column(column_name)",
            "            sqla_metric = self.sqla_aggregations[metric[\"aggregate\"]](sqla_column)",
            "        elif expression_type == utils.AdhocMetricExpressionType.SQL:",
            "            expression = _process_sql_expression(",
            "                expression=metric[\"sqlExpression\"],",
            "                database_id=self.database_id,",
            "                schema=self.schema,",
            "                template_processor=template_processor,",
            "            )",
            "            sqla_metric = literal_column(expression)",
            "        else:",
            "            raise QueryObjectValidationError(\"Adhoc metric expressionType is invalid\")",
            "",
            "        return self.make_sqla_column_compatible(sqla_metric, label)",
            "",
            "    def adhoc_column_to_sqla(",
            "        self,",
            "        col: AdhocColumn,",
            "        template_processor: Optional[BaseTemplateProcessor] = None,",
            "    ) -> ColumnElement:",
            "        \"\"\"",
            "        Turn an adhoc column into a sqlalchemy column.",
            "",
            "        :param col: Adhoc column definition",
            "        :param template_processor: template_processor instance",
            "        :returns: The metric defined as a sqlalchemy column",
            "        :rtype: sqlalchemy.sql.column",
            "        \"\"\"",
            "        label = utils.get_column_name(col)",
            "        expression = _process_sql_expression(",
            "            expression=col[\"sqlExpression\"],",
            "            database_id=self.database_id,",
            "            schema=self.schema,",
            "            template_processor=template_processor,",
            "        )",
            "        sqla_column = literal_column(expression)",
            "        return self.make_sqla_column_compatible(sqla_column, label)",
            "",
            "    def make_sqla_column_compatible(",
            "        self, sqla_col: ColumnElement, label: Optional[str] = None",
            "    ) -> ColumnElement:",
            "        \"\"\"Takes a sqlalchemy column object and adds label info if supported by engine.",
            "        :param sqla_col: sqlalchemy column instance",
            "        :param label: alias/label that column is expected to have",
            "        :return: either a sql alchemy column or label instance if supported by engine",
            "        \"\"\"",
            "        label_expected = label or sqla_col.name",
            "        db_engine_spec = self.db_engine_spec",
            "        # add quotes to tables",
            "        if db_engine_spec.allows_alias_in_select:",
            "            label = db_engine_spec.make_label_compatible(label_expected)",
            "            sqla_col = sqla_col.label(label)",
            "        sqla_col.key = label_expected",
            "        return sqla_col",
            "",
            "    def make_orderby_compatible(",
            "        self, select_exprs: List[ColumnElement], orderby_exprs: List[ColumnElement]",
            "    ) -> None:",
            "        \"\"\"",
            "        If needed, make sure aliases for selected columns are not used in",
            "        `ORDER BY`.",
            "",
            "        In some databases (e.g. Presto), `ORDER BY` clause is not able to",
            "        automatically pick the source column if a `SELECT` clause alias is named",
            "        the same as a source column. In this case, we update the SELECT alias to",
            "        another name to avoid the conflict.",
            "        \"\"\"",
            "        if self.db_engine_spec.allows_alias_to_source_column:",
            "            return",
            "",
            "        def is_alias_used_in_orderby(col: ColumnElement) -> bool:",
            "            if not isinstance(col, Label):",
            "                return False",
            "            regexp = re.compile(f\"\\\\(.*\\\\b{re.escape(col.name)}\\\\b.*\\\\)\", re.IGNORECASE)",
            "            return any(regexp.search(str(x)) for x in orderby_exprs)",
            "",
            "        # Iterate through selected columns, if column alias appears in orderby",
            "        # use another `alias`. The final output columns will still use the",
            "        # original names, because they are updated by `labels_expected` after",
            "        # querying.",
            "        for col in select_exprs:",
            "            if is_alias_used_in_orderby(col):",
            "                col.name = f\"{col.name}__\"",
            "",
            "    def get_sqla_row_level_filters(",
            "        self, template_processor: BaseTemplateProcessor",
            "    ) -> List[TextClause]:",
            "        \"\"\"",
            "        Return the appropriate row level security filters for",
            "        this table and the current user.",
            "",
            "        :param BaseTemplateProcessor template_processor: The template",
            "        processor to apply to the filters.",
            "        :returns: A list of SQL clauses to be ANDed together.",
            "        \"\"\"",
            "        all_filters: List[TextClause] = []",
            "        filter_groups: Dict[Union[int, str], List[TextClause]] = defaultdict(list)",
            "        try:",
            "            for filter_ in security_manager.get_rls_filters(self):",
            "                clause = self.text(",
            "                    f\"({template_processor.process_template(filter_.clause)})\"",
            "                )",
            "                if filter_.group_key:",
            "                    filter_groups[filter_.group_key].append(clause)",
            "                else:",
            "                    all_filters.append(clause)",
            "",
            "            if is_feature_enabled(\"EMBEDDED_SUPERSET\"):",
            "                for rule in security_manager.get_guest_rls_filters(self):",
            "                    clause = self.text(",
            "                        f\"({template_processor.process_template(rule['clause'])})\"",
            "                    )",
            "                    all_filters.append(clause)",
            "",
            "            grouped_filters = [or_(*clauses) for clauses in filter_groups.values()]",
            "            all_filters.extend(grouped_filters)",
            "            return all_filters",
            "        except TemplateError as ex:",
            "            raise QueryObjectValidationError(",
            "                _(",
            "                    \"Error in jinja expression in RLS filters: %(msg)s\",",
            "                    msg=ex.message,",
            "                )",
            "            ) from ex",
            "",
            "    def text(self, clause: str) -> TextClause:",
            "        return self.db_engine_spec.get_text_clause(clause)",
            "",
            "    def get_sqla_query(  # pylint: disable=too-many-arguments,too-many-locals,too-many-branches,too-many-statements",
            "        self,",
            "        apply_fetch_values_predicate: bool = False,",
            "        columns: Optional[List[Column]] = None,",
            "        extras: Optional[Dict[str, Any]] = None,",
            "        filter: Optional[  # pylint: disable=redefined-builtin",
            "            List[QueryObjectFilterClause]",
            "        ] = None,",
            "        from_dttm: Optional[datetime] = None,",
            "        granularity: Optional[str] = None,",
            "        groupby: Optional[List[Column]] = None,",
            "        inner_from_dttm: Optional[datetime] = None,",
            "        inner_to_dttm: Optional[datetime] = None,",
            "        is_rowcount: bool = False,",
            "        is_timeseries: bool = True,",
            "        metrics: Optional[List[Metric]] = None,",
            "        orderby: Optional[List[OrderBy]] = None,",
            "        order_desc: bool = True,",
            "        to_dttm: Optional[datetime] = None,",
            "        series_columns: Optional[List[Column]] = None,",
            "        series_limit: Optional[int] = None,",
            "        series_limit_metric: Optional[Metric] = None,",
            "        row_limit: Optional[int] = None,",
            "        row_offset: Optional[int] = None,",
            "        timeseries_limit: Optional[int] = None,",
            "        timeseries_limit_metric: Optional[Metric] = None,",
            "    ) -> SqlaQuery:",
            "        \"\"\"Querying any sqla table from this common interface\"\"\"",
            "        if granularity not in self.dttm_cols and granularity is not None:",
            "            granularity = self.main_dttm_col",
            "",
            "        extras = extras or {}",
            "        time_grain = extras.get(\"time_grain_sqla\")",
            "",
            "        template_kwargs = {",
            "            \"columns\": columns,",
            "            \"from_dttm\": from_dttm.isoformat() if from_dttm else None,",
            "            \"groupby\": groupby,",
            "            \"metrics\": metrics,",
            "            \"row_limit\": row_limit,",
            "            \"row_offset\": row_offset,",
            "            \"time_column\": granularity,",
            "            \"time_grain\": time_grain,",
            "            \"to_dttm\": to_dttm.isoformat() if to_dttm else None,",
            "            \"table_columns\": [col.column_name for col in self.columns],",
            "            \"filter\": filter,",
            "        }",
            "        columns = columns or []",
            "        groupby = groupby or []",
            "        series_column_names = utils.get_column_names(series_columns or [])",
            "        # deprecated, to be removed in 2.0",
            "        if is_timeseries and timeseries_limit:",
            "            series_limit = timeseries_limit",
            "        series_limit_metric = series_limit_metric or timeseries_limit_metric",
            "        template_kwargs.update(self.template_params_dict)",
            "        extra_cache_keys: List[Any] = []",
            "        template_kwargs[\"extra_cache_keys\"] = extra_cache_keys",
            "        removed_filters: List[str] = []",
            "        applied_template_filters: List[str] = []",
            "        template_kwargs[\"removed_filters\"] = removed_filters",
            "        template_kwargs[\"applied_filters\"] = applied_template_filters",
            "        template_processor = self.get_template_processor(**template_kwargs)",
            "        db_engine_spec = self.db_engine_spec",
            "        prequeries: List[str] = []",
            "        orderby = orderby or []",
            "        need_groupby = bool(metrics is not None or groupby)",
            "        metrics = metrics or []",
            "",
            "        # For backward compatibility",
            "        if granularity not in self.dttm_cols and granularity is not None:",
            "            granularity = self.main_dttm_col",
            "",
            "        columns_by_name: Dict[str, TableColumn] = {",
            "            col.column_name: col for col in self.columns",
            "        }",
            "",
            "        metrics_by_name: Dict[str, SqlMetric] = {m.metric_name: m for m in self.metrics}",
            "",
            "        if not granularity and is_timeseries:",
            "            raise QueryObjectValidationError(",
            "                _(",
            "                    \"Datetime column not provided as part table configuration \"",
            "                    \"and is required by this type of chart\"",
            "                )",
            "            )",
            "        if not metrics and not columns and not groupby:",
            "            raise QueryObjectValidationError(_(\"Empty query?\"))",
            "",
            "        metrics_exprs: List[ColumnElement] = []",
            "        for metric in metrics:",
            "            if utils.is_adhoc_metric(metric):",
            "                assert isinstance(metric, dict)",
            "                metrics_exprs.append(",
            "                    self.adhoc_metric_to_sqla(",
            "                        metric=metric,",
            "                        columns_by_name=columns_by_name,",
            "                        template_processor=template_processor,",
            "                    )",
            "                )",
            "            elif isinstance(metric, str) and metric in metrics_by_name:",
            "                metrics_exprs.append(metrics_by_name[metric].get_sqla_col())",
            "            else:",
            "                raise QueryObjectValidationError(",
            "                    _(\"Metric '%(metric)s' does not exist\", metric=metric)",
            "                )",
            "",
            "        if metrics_exprs:",
            "            main_metric_expr = metrics_exprs[0]",
            "        else:",
            "            main_metric_expr, label = literal_column(\"COUNT(*)\"), \"ccount\"",
            "            main_metric_expr = self.make_sqla_column_compatible(main_metric_expr, label)",
            "",
            "        # To ensure correct handling of the ORDER BY labeling we need to reference the",
            "        # metric instance if defined in the SELECT clause.",
            "        # use the key of the ColumnClause for the expected label",
            "        metrics_exprs_by_label = {m.key: m for m in metrics_exprs}",
            "        metrics_exprs_by_expr = {str(m): m for m in metrics_exprs}",
            "",
            "        # Since orderby may use adhoc metrics, too; we need to process them first",
            "        orderby_exprs: List[ColumnElement] = []",
            "        for orig_col, ascending in orderby:",
            "            col: Union[AdhocMetric, ColumnElement] = orig_col",
            "            if isinstance(col, dict):",
            "                col = cast(AdhocMetric, col)",
            "                if col.get(\"sqlExpression\"):",
            "                    col[\"sqlExpression\"] = _process_sql_expression(",
            "                        expression=col[\"sqlExpression\"],",
            "                        database_id=self.database_id,",
            "                        schema=self.schema,",
            "                        template_processor=template_processor,",
            "                    )",
            "                if utils.is_adhoc_metric(col):",
            "                    # add adhoc sort by column to columns_by_name if not exists",
            "                    col = self.adhoc_metric_to_sqla(col, columns_by_name)",
            "                    # if the adhoc metric has been defined before",
            "                    # use the existing instance.",
            "                    col = metrics_exprs_by_expr.get(str(col), col)",
            "                    need_groupby = True",
            "            elif col in columns_by_name:",
            "                col = columns_by_name[col].get_sqla_col()",
            "            elif col in metrics_exprs_by_label:",
            "                col = metrics_exprs_by_label[col]",
            "                need_groupby = True",
            "            elif col in metrics_by_name:",
            "                col = metrics_by_name[col].get_sqla_col()",
            "                need_groupby = True",
            "",
            "            if isinstance(col, ColumnElement):",
            "                orderby_exprs.append(col)",
            "            else:",
            "                # Could not convert a column reference to valid ColumnElement",
            "                raise QueryObjectValidationError(",
            "                    _(\"Unknown column used in orderby: %(col)s\", col=orig_col)",
            "                )",
            "",
            "        select_exprs: List[Union[Column, Label]] = []",
            "        groupby_all_columns = {}",
            "        groupby_series_columns = {}",
            "",
            "        # filter out the pseudo column  __timestamp from columns",
            "        columns = [col for col in columns if col != utils.DTTM_ALIAS]",
            "        dttm_col = columns_by_name.get(granularity) if granularity else None",
            "",
            "        if need_groupby:",
            "            # dedup columns while preserving order",
            "            columns = groupby or columns",
            "            for selected in columns:",
            "                if isinstance(selected, str):",
            "                    # if groupby field/expr equals granularity field/expr",
            "                    if selected == granularity:",
            "                        table_col = columns_by_name[selected]",
            "                        outer = table_col.get_timestamp_expression(",
            "                            time_grain=time_grain,",
            "                            label=selected,",
            "                            template_processor=template_processor,",
            "                        )",
            "                    # if groupby field equals a selected column",
            "                    elif selected in columns_by_name:",
            "                        outer = columns_by_name[selected].get_sqla_col()",
            "                    else:",
            "                        selected = validate_adhoc_subquery(",
            "                            selected,",
            "                            self.database_id,",
            "                            self.schema,",
            "                        )",
            "                        outer = literal_column(f\"({selected})\")",
            "                        outer = self.make_sqla_column_compatible(outer, selected)",
            "                else:",
            "                    outer = self.adhoc_column_to_sqla(",
            "                        col=selected, template_processor=template_processor",
            "                    )",
            "                groupby_all_columns[outer.name] = outer",
            "                if not series_column_names or outer.name in series_column_names:",
            "                    groupby_series_columns[outer.name] = outer",
            "                select_exprs.append(outer)",
            "        elif columns:",
            "            for selected in columns:",
            "                selected = validate_adhoc_subquery(",
            "                    selected,",
            "                    self.database_id,",
            "                    self.schema,",
            "                )",
            "                select_exprs.append(",
            "                    columns_by_name[selected].get_sqla_col()",
            "                    if selected in columns_by_name",
            "                    else self.make_sqla_column_compatible(literal_column(selected))",
            "                )",
            "            metrics_exprs = []",
            "",
            "        time_range_endpoints = extras.get(\"time_range_endpoints\")",
            "",
            "        if granularity:",
            "            if granularity not in columns_by_name or not dttm_col:",
            "                raise QueryObjectValidationError(",
            "                    _(",
            "                        'Time column \"%(col)s\" does not exist in dataset',",
            "                        col=granularity,",
            "                    )",
            "                )",
            "            time_filters = []",
            "",
            "            if is_timeseries:",
            "                timestamp = dttm_col.get_timestamp_expression(",
            "                    time_grain=time_grain, template_processor=template_processor",
            "                )",
            "                # always put timestamp as the first column",
            "                select_exprs.insert(0, timestamp)",
            "                groupby_all_columns[timestamp.name] = timestamp",
            "",
            "            # Use main dttm column to support index with secondary dttm columns.",
            "            if (",
            "                db_engine_spec.time_secondary_columns",
            "                and self.main_dttm_col in self.dttm_cols",
            "                and self.main_dttm_col != dttm_col.column_name",
            "            ):",
            "                time_filters.append(",
            "                    columns_by_name[self.main_dttm_col].get_time_filter(",
            "                        from_dttm,",
            "                        to_dttm,",
            "                        time_range_endpoints,",
            "                    )",
            "                )",
            "            time_filters.append(",
            "                dttm_col.get_time_filter(from_dttm, to_dttm, time_range_endpoints)",
            "            )",
            "",
            "        # Always remove duplicates by column name, as sometimes `metrics_exprs`",
            "        # can have the same name as a groupby column (e.g. when users use",
            "        # raw columns as custom SQL adhoc metric).",
            "        select_exprs = remove_duplicates(",
            "            select_exprs + metrics_exprs, key=lambda x: x.name",
            "        )",
            "",
            "        # Expected output columns",
            "        labels_expected = [c.key for c in select_exprs]",
            "",
            "        # Order by columns are \"hidden\" columns, some databases require them",
            "        # always be present in SELECT if an aggregation function is used",
            "        if not db_engine_spec.allows_hidden_ordeby_agg:",
            "            select_exprs = remove_duplicates(select_exprs + orderby_exprs)",
            "",
            "        qry = sa.select(select_exprs)",
            "",
            "        tbl, cte = self.get_from_clause(template_processor)",
            "",
            "        if groupby_all_columns:",
            "            qry = qry.group_by(*groupby_all_columns.values())",
            "",
            "        where_clause_and = []",
            "        having_clause_and = []",
            "",
            "        for flt in filter:  # type: ignore",
            "            if not all(flt.get(s) for s in [\"col\", \"op\"]):",
            "                continue",
            "            flt_col = flt[\"col\"]",
            "            val = flt.get(\"val\")",
            "            op = flt[\"op\"].upper()",
            "            col_obj: Optional[TableColumn] = None",
            "            sqla_col: Optional[Column] = None",
            "            if flt_col == utils.DTTM_ALIAS and is_timeseries and dttm_col:",
            "                col_obj = dttm_col",
            "            elif is_adhoc_column(flt_col):",
            "                sqla_col = self.adhoc_column_to_sqla(flt_col)",
            "            else:",
            "                col_obj = columns_by_name.get(flt_col)",
            "            filter_grain = flt.get(\"grain\")",
            "",
            "            if is_feature_enabled(\"ENABLE_TEMPLATE_REMOVE_FILTERS\"):",
            "                if get_column_name(flt_col) in removed_filters:",
            "                    # Skip generating SQLA filter when the jinja template handles it.",
            "                    continue",
            "",
            "            if col_obj or sqla_col is not None:",
            "                if sqla_col is not None:",
            "                    pass",
            "                elif col_obj and filter_grain:",
            "                    sqla_col = col_obj.get_timestamp_expression(",
            "                        time_grain=filter_grain, template_processor=template_processor",
            "                    )",
            "                elif col_obj:",
            "                    sqla_col = col_obj.get_sqla_col()",
            "                col_type = col_obj.type if col_obj else None",
            "                col_spec = db_engine_spec.get_column_spec(",
            "                    native_type=col_type,",
            "                    db_extra=self.database.get_extra(),",
            "                )",
            "                is_list_target = op in (",
            "                    utils.FilterOperator.IN.value,",
            "                    utils.FilterOperator.NOT_IN.value,",
            "                )",
            "                if col_spec:",
            "                    target_generic_type = col_spec.generic_type",
            "                else:",
            "                    target_generic_type = GenericDataType.STRING",
            "                eq = self.filter_values_handler(",
            "                    values=val,",
            "                    target_generic_type=target_generic_type,",
            "                    target_native_type=col_type,",
            "                    is_list_target=is_list_target,",
            "                    db_engine_spec=db_engine_spec,",
            "                    db_extra=self.database.get_extra(),",
            "                )",
            "                if is_list_target:",
            "                    assert isinstance(eq, (tuple, list))",
            "                    if len(eq) == 0:",
            "                        raise QueryObjectValidationError(",
            "                            _(\"Filter value list cannot be empty\")",
            "                        )",
            "                    if len(eq) > len(",
            "                        eq_without_none := [x for x in eq if x is not None]",
            "                    ):",
            "                        is_null_cond = sqla_col.is_(None)",
            "                        if eq:",
            "                            cond = or_(is_null_cond, sqla_col.in_(eq_without_none))",
            "                        else:",
            "                            cond = is_null_cond",
            "                    else:",
            "                        cond = sqla_col.in_(eq)",
            "                    if op == utils.FilterOperator.NOT_IN.value:",
            "                        cond = ~cond",
            "                    where_clause_and.append(cond)",
            "                elif op == utils.FilterOperator.IS_NULL.value:",
            "                    where_clause_and.append(sqla_col.is_(None))",
            "                elif op == utils.FilterOperator.IS_NOT_NULL.value:",
            "                    where_clause_and.append(sqla_col.isnot(None))",
            "                elif op == utils.FilterOperator.IS_TRUE.value:",
            "                    where_clause_and.append(sqla_col.is_(True))",
            "                elif op == utils.FilterOperator.IS_FALSE.value:",
            "                    where_clause_and.append(sqla_col.is_(False))",
            "                else:",
            "                    if eq is None:",
            "                        raise QueryObjectValidationError(",
            "                            _(",
            "                                \"Must specify a value for filters \"",
            "                                \"with comparison operators\"",
            "                            )",
            "                        )",
            "                    if op == utils.FilterOperator.EQUALS.value:",
            "                        where_clause_and.append(sqla_col == eq)",
            "                    elif op == utils.FilterOperator.NOT_EQUALS.value:",
            "                        where_clause_and.append(sqla_col != eq)",
            "                    elif op == utils.FilterOperator.GREATER_THAN.value:",
            "                        where_clause_and.append(sqla_col > eq)",
            "                    elif op == utils.FilterOperator.LESS_THAN.value:",
            "                        where_clause_and.append(sqla_col < eq)",
            "                    elif op == utils.FilterOperator.GREATER_THAN_OR_EQUALS.value:",
            "                        where_clause_and.append(sqla_col >= eq)",
            "                    elif op == utils.FilterOperator.LESS_THAN_OR_EQUALS.value:",
            "                        where_clause_and.append(sqla_col <= eq)",
            "                    elif op == utils.FilterOperator.LIKE.value:",
            "                        where_clause_and.append(sqla_col.like(eq))",
            "                    elif op == utils.FilterOperator.ILIKE.value:",
            "                        where_clause_and.append(sqla_col.ilike(eq))",
            "                    else:",
            "                        raise QueryObjectValidationError(",
            "                            _(\"Invalid filter operation type: %(op)s\", op=op)",
            "                        )",
            "        if is_feature_enabled(\"ROW_LEVEL_SECURITY\"):",
            "            where_clause_and += self.get_sqla_row_level_filters(template_processor)",
            "        if extras:",
            "            where = extras.get(\"where\")",
            "            if where:",
            "                try:",
            "                    where = template_processor.process_template(f\"({where})\")",
            "                except TemplateError as ex:",
            "                    raise QueryObjectValidationError(",
            "                        _(",
            "                            \"Error in jinja expression in WHERE clause: %(msg)s\",",
            "                            msg=ex.message,",
            "                        )",
            "                    ) from ex",
            "                where_clause_and += [self.text(where)]",
            "            having = extras.get(\"having\")",
            "            if having:",
            "                try:",
            "                    having = template_processor.process_template(f\"({having})\")",
            "                except TemplateError as ex:",
            "                    raise QueryObjectValidationError(",
            "                        _(",
            "                            \"Error in jinja expression in HAVING clause: %(msg)s\",",
            "                            msg=ex.message,",
            "                        )",
            "                    ) from ex",
            "                having_clause_and += [self.text(having)]",
            "        if apply_fetch_values_predicate and self.fetch_values_predicate:",
            "            qry = qry.where(self.get_fetch_values_predicate())",
            "        if granularity:",
            "            qry = qry.where(and_(*(time_filters + where_clause_and)))",
            "        else:",
            "            qry = qry.where(and_(*where_clause_and))",
            "        qry = qry.having(and_(*having_clause_and))",
            "",
            "        self.make_orderby_compatible(select_exprs, orderby_exprs)",
            "",
            "        for col, (orig_col, ascending) in zip(orderby_exprs, orderby):",
            "            if not db_engine_spec.allows_alias_in_orderby and isinstance(col, Label):",
            "                # if engine does not allow using SELECT alias in ORDER BY",
            "                # revert to the underlying column",
            "                col = col.element",
            "",
            "            if (",
            "                db_engine_spec.allows_alias_in_select",
            "                and db_engine_spec.allows_hidden_cc_in_orderby",
            "                and col.name in [select_col.name for select_col in select_exprs]",
            "            ):",
            "                col = literal_column(col.name)",
            "            direction = asc if ascending else desc",
            "            qry = qry.order_by(direction(col))",
            "",
            "        if row_limit:",
            "            qry = qry.limit(row_limit)",
            "        if row_offset:",
            "            qry = qry.offset(row_offset)",
            "",
            "        if series_limit and groupby_series_columns:",
            "            if db_engine_spec.allows_joins and db_engine_spec.allows_subqueries:",
            "                # some sql dialects require for order by expressions",
            "                # to also be in the select clause -- others, e.g. vertica,",
            "                # require a unique inner alias",
            "                inner_main_metric_expr = self.make_sqla_column_compatible(",
            "                    main_metric_expr, \"mme_inner__\"",
            "                )",
            "                inner_groupby_exprs = []",
            "                inner_select_exprs = []",
            "                for gby_name, gby_obj in groupby_series_columns.items():",
            "                    label = get_column_name(gby_name)",
            "                    inner = self.make_sqla_column_compatible(gby_obj, gby_name + \"__\")",
            "                    inner_groupby_exprs.append(inner)",
            "                    inner_select_exprs.append(inner)",
            "",
            "                inner_select_exprs += [inner_main_metric_expr]",
            "                subq = select(inner_select_exprs).select_from(tbl)",
            "                inner_time_filter = []",
            "",
            "                if dttm_col and not db_engine_spec.time_groupby_inline:",
            "                    inner_time_filter = [",
            "                        dttm_col.get_time_filter(",
            "                            inner_from_dttm or from_dttm,",
            "                            inner_to_dttm or to_dttm,",
            "                            time_range_endpoints,",
            "                        )",
            "                    ]",
            "                subq = subq.where(and_(*(where_clause_and + inner_time_filter)))",
            "                subq = subq.group_by(*inner_groupby_exprs)",
            "",
            "                ob = inner_main_metric_expr",
            "                if series_limit_metric:",
            "                    ob = self._get_series_orderby(",
            "                        series_limit_metric, metrics_by_name, columns_by_name",
            "                    )",
            "                direction = desc if order_desc else asc",
            "                subq = subq.order_by(direction(ob))",
            "                subq = subq.limit(series_limit)",
            "",
            "                on_clause = []",
            "                for gby_name, gby_obj in groupby_series_columns.items():",
            "                    # in this case the column name, not the alias, needs to be",
            "                    # conditionally mutated, as it refers to the column alias in",
            "                    # the inner query",
            "                    col_name = db_engine_spec.make_label_compatible(gby_name + \"__\")",
            "                    on_clause.append(gby_obj == column(col_name))",
            "",
            "                tbl = tbl.join(subq.alias(), and_(*on_clause))",
            "            else:",
            "                if series_limit_metric:",
            "                    orderby = [",
            "                        (",
            "                            self._get_series_orderby(",
            "                                series_limit_metric,",
            "                                metrics_by_name,",
            "                                columns_by_name,",
            "                            ),",
            "                            not order_desc,",
            "                        )",
            "                    ]",
            "",
            "                # run prequery to get top groups",
            "                prequery_obj = {",
            "                    \"is_timeseries\": False,",
            "                    \"row_limit\": series_limit,",
            "                    \"metrics\": metrics,",
            "                    \"granularity\": granularity,",
            "                    \"groupby\": groupby,",
            "                    \"from_dttm\": inner_from_dttm or from_dttm,",
            "                    \"to_dttm\": inner_to_dttm or to_dttm,",
            "                    \"filter\": filter,",
            "                    \"orderby\": orderby,",
            "                    \"extras\": extras,",
            "                    \"columns\": columns,",
            "                    \"order_desc\": True,",
            "                }",
            "",
            "                result = self.query(prequery_obj)",
            "                prequeries.append(result.query)",
            "                dimensions = [",
            "                    c",
            "                    for c in result.df.columns",
            "                    if c not in metrics and c in groupby_series_columns",
            "                ]",
            "                top_groups = self._get_top_groups(",
            "                    result.df, dimensions, groupby_series_columns, columns_by_name",
            "                )",
            "                qry = qry.where(top_groups)",
            "",
            "        qry = qry.select_from(tbl)",
            "",
            "        if is_rowcount:",
            "            if not db_engine_spec.allows_subqueries:",
            "                raise QueryObjectValidationError(",
            "                    _(\"Database does not support subqueries\")",
            "                )",
            "            label = \"rowcount\"",
            "            col = self.make_sqla_column_compatible(literal_column(\"COUNT(*)\"), label)",
            "            qry = select([col]).select_from(qry.alias(\"rowcount_qry\"))",
            "            labels_expected = [label]",
            "",
            "        return SqlaQuery(",
            "            applied_template_filters=applied_template_filters,",
            "            cte=cte,",
            "            extra_cache_keys=extra_cache_keys,",
            "            labels_expected=labels_expected,",
            "            sqla_query=qry,",
            "            prequeries=prequeries,",
            "        )",
            "",
            "    def _get_series_orderby(",
            "        self,",
            "        series_limit_metric: Metric,",
            "        metrics_by_name: Dict[str, SqlMetric],",
            "        columns_by_name: Dict[str, TableColumn],",
            "    ) -> Column:",
            "        if utils.is_adhoc_metric(series_limit_metric):",
            "            assert isinstance(series_limit_metric, dict)",
            "            ob = self.adhoc_metric_to_sqla(series_limit_metric, columns_by_name)",
            "        elif (",
            "            isinstance(series_limit_metric, str)",
            "            and series_limit_metric in metrics_by_name",
            "        ):",
            "            ob = metrics_by_name[series_limit_metric].get_sqla_col()",
            "        else:",
            "            raise QueryObjectValidationError(",
            "                _(\"Metric '%(metric)s' does not exist\", metric=series_limit_metric)",
            "            )",
            "        return ob",
            "",
            "    def _normalize_prequery_result_type(",
            "        self,",
            "        row: pd.Series,",
            "        dimension: str,",
            "        columns_by_name: Dict[str, TableColumn],",
            "    ) -> Union[str, int, float, bool, Text]:",
            "        \"\"\"",
            "        Convert a prequery result type to its equivalent Python type.",
            "",
            "        Some databases like Druid will return timestamps as strings, but do not perform",
            "        automatic casting when comparing these strings to a timestamp. For cases like",
            "        this we convert the value via the appropriate SQL transform.",
            "",
            "        :param row: A prequery record",
            "        :param dimension: The dimension name",
            "        :param columns_by_name: The mapping of columns by name",
            "        :return: equivalent primitive python type",
            "        \"\"\"",
            "",
            "        value = row[dimension]",
            "",
            "        if isinstance(value, np.generic):",
            "            value = value.item()",
            "",
            "        column_ = columns_by_name[dimension]",
            "        db_extra: Dict[str, Any] = self.database.get_extra()",
            "",
            "        if column_.type and column_.is_temporal and isinstance(value, str):",
            "            sql = self.db_engine_spec.convert_dttm(",
            "                column_.type, dateutil.parser.parse(value), db_extra=db_extra",
            "            )",
            "",
            "            if sql:",
            "                value = self.text(sql)",
            "",
            "        return value",
            "",
            "    def _get_top_groups(",
            "        self,",
            "        df: pd.DataFrame,",
            "        dimensions: List[str],",
            "        groupby_exprs: Dict[str, Any],",
            "        columns_by_name: Dict[str, TableColumn],",
            "    ) -> ColumnElement:",
            "        groups = []",
            "        for _unused, row in df.iterrows():",
            "            group = []",
            "            for dimension in dimensions:",
            "                value = self._normalize_prequery_result_type(",
            "                    row,",
            "                    dimension,",
            "                    columns_by_name,",
            "                )",
            "",
            "                group.append(groupby_exprs[dimension] == value)",
            "            groups.append(and_(*group))",
            "",
            "        return or_(*groups)",
            "",
            "    def query(self, query_obj: QueryObjectDict) -> QueryResult:",
            "        qry_start_dttm = datetime.now()",
            "        query_str_ext = self.get_query_str_extended(query_obj)",
            "        sql = query_str_ext.sql",
            "        status = QueryStatus.SUCCESS",
            "        errors = None",
            "        error_message = None",
            "",
            "        def assign_column_label(df: pd.DataFrame) -> Optional[pd.DataFrame]:",
            "            \"\"\"",
            "            Some engines change the case or generate bespoke column names, either by",
            "            default or due to lack of support for aliasing. This function ensures that",
            "            the column names in the DataFrame correspond to what is expected by",
            "            the viz components.",
            "",
            "            Sometimes a query may also contain only order by columns that are not used",
            "            as metrics or groupby columns, but need to present in the SQL `select`,",
            "            filtering by `labels_expected` make sure we only return columns users want.",
            "",
            "            :param df: Original DataFrame returned by the engine",
            "            :return: Mutated DataFrame",
            "            \"\"\"",
            "            labels_expected = query_str_ext.labels_expected",
            "            if df is not None and not df.empty:",
            "                if len(df.columns) < len(labels_expected):",
            "                    raise QueryObjectValidationError(",
            "                        _(\"Db engine did not return all queried columns\")",
            "                    )",
            "                if len(df.columns) > len(labels_expected):",
            "                    df = df.iloc[:, 0 : len(labels_expected)]",
            "                df.columns = labels_expected",
            "            return df",
            "",
            "        try:",
            "            df = self.database.get_df(sql, self.schema, mutator=assign_column_label)",
            "        except Exception as ex:  # pylint: disable=broad-except",
            "            df = pd.DataFrame()",
            "            status = QueryStatus.FAILED",
            "            logger.warning(",
            "                \"Query %s on schema %s failed\", sql, self.schema, exc_info=True",
            "            )",
            "            db_engine_spec = self.db_engine_spec",
            "            errors = [",
            "                dataclasses.asdict(error) for error in db_engine_spec.extract_errors(ex)",
            "            ]",
            "            error_message = utils.error_msg_from_exception(ex)",
            "",
            "        return QueryResult(",
            "            applied_template_filters=query_str_ext.applied_template_filters,",
            "            status=status,",
            "            df=df,",
            "            duration=datetime.now() - qry_start_dttm,",
            "            query=sql,",
            "            errors=errors,",
            "            error_message=error_message,",
            "        )",
            "",
            "    def get_sqla_table_object(self) -> Table:",
            "        return self.database.get_table(self.table_name, schema=self.schema)",
            "",
            "    def fetch_metadata(self, commit: bool = True) -> MetadataResult:",
            "        \"\"\"",
            "        Fetches the metadata for the table and merges it in",
            "",
            "        :param commit: should the changes be committed or not.",
            "        :return: Tuple with lists of added, removed and modified column names.",
            "        \"\"\"",
            "        new_columns = self.external_metadata()",
            "        metrics = []",
            "        any_date_col = None",
            "        db_engine_spec = self.db_engine_spec",
            "        old_columns = db.session.query(TableColumn).filter(TableColumn.table == self)",
            "",
            "        old_columns_by_name: Dict[str, TableColumn] = {",
            "            col.column_name: col for col in old_columns",
            "        }",
            "        results = MetadataResult(",
            "            removed=[",
            "                col",
            "                for col in old_columns_by_name",
            "                if col not in {col[\"name\"] for col in new_columns}",
            "            ]",
            "        )",
            "",
            "        # clear old columns before adding modified columns back",
            "        self.columns = []",
            "        for col in new_columns:",
            "            old_column = old_columns_by_name.pop(col[\"name\"], None)",
            "            if not old_column:",
            "                results.added.append(col[\"name\"])",
            "                new_column = TableColumn(",
            "                    column_name=col[\"name\"], type=col[\"type\"], table=self",
            "                )",
            "                new_column.is_dttm = new_column.is_temporal",
            "                db_engine_spec.alter_new_orm_column(new_column)",
            "            else:",
            "                new_column = old_column",
            "                if new_column.type != col[\"type\"]:",
            "                    results.modified.append(col[\"name\"])",
            "                new_column.type = col[\"type\"]",
            "                new_column.expression = \"\"",
            "            new_column.groupby = True",
            "            new_column.filterable = True",
            "            self.columns.append(new_column)",
            "            if not any_date_col and new_column.is_temporal:",
            "                any_date_col = col[\"name\"]",
            "        self.columns.extend(",
            "            [col for col in old_columns_by_name.values() if col.expression]",
            "        )",
            "        metrics.append(",
            "            SqlMetric(",
            "                metric_name=\"count\",",
            "                verbose_name=\"COUNT(*)\",",
            "                metric_type=\"count\",",
            "                expression=\"COUNT(*)\",",
            "            )",
            "        )",
            "        if not self.main_dttm_col:",
            "            self.main_dttm_col = any_date_col",
            "        self.add_missing_metrics(metrics)",
            "",
            "        # Apply config supplied mutations.",
            "        config[\"SQLA_TABLE_MUTATOR\"](self)",
            "",
            "        db.session.merge(self)",
            "        if commit:",
            "            db.session.commit()",
            "        return results",
            "",
            "    @classmethod",
            "    def query_datasources_by_name(",
            "        cls,",
            "        session: Session,",
            "        database: Database,",
            "        datasource_name: str,",
            "        schema: Optional[str] = None,",
            "    ) -> List[\"SqlaTable\"]:",
            "        query = (",
            "            session.query(cls)",
            "            .filter_by(database_id=database.id)",
            "            .filter_by(table_name=datasource_name)",
            "        )",
            "        if schema:",
            "            query = query.filter_by(schema=schema)",
            "        return query.all()",
            "",
            "    @staticmethod",
            "    def default_query(qry: Query) -> Query:",
            "        return qry.filter_by(is_sqllab_view=False)",
            "",
            "    def has_extra_cache_key_calls(self, query_obj: QueryObjectDict) -> bool:",
            "        \"\"\"",
            "        Detects the presence of calls to `ExtraCache` methods in items in query_obj that",
            "        can be templated. If any are present, the query must be evaluated to extract",
            "        additional keys for the cache key. This method is needed to avoid executing the",
            "        template code unnecessarily, as it may contain expensive calls, e.g. to extract",
            "        the latest partition of a database.",
            "",
            "        :param query_obj: query object to analyze",
            "        :return: True if there are call(s) to an `ExtraCache` method, False otherwise",
            "        \"\"\"",
            "        templatable_statements: List[str] = []",
            "        if self.sql:",
            "            templatable_statements.append(self.sql)",
            "        if self.fetch_values_predicate:",
            "            templatable_statements.append(self.fetch_values_predicate)",
            "        extras = query_obj.get(\"extras\", {})",
            "        if \"where\" in extras:",
            "            templatable_statements.append(extras[\"where\"])",
            "        if \"having\" in extras:",
            "            templatable_statements.append(extras[\"having\"])",
            "        if is_feature_enabled(\"ROW_LEVEL_SECURITY\") and self.is_rls_supported:",
            "            templatable_statements += [",
            "                f.clause for f in security_manager.get_rls_filters(self)",
            "            ]",
            "        for statement in templatable_statements:",
            "            if ExtraCache.regex.search(statement):",
            "                return True",
            "        return False",
            "",
            "    def get_extra_cache_keys(self, query_obj: QueryObjectDict) -> List[Hashable]:",
            "        \"\"\"",
            "        The cache key of a SqlaTable needs to consider any keys added by the parent",
            "        class and any keys added via `ExtraCache`.",
            "",
            "        :param query_obj: query object to analyze",
            "        :return: The extra cache keys",
            "        \"\"\"",
            "        extra_cache_keys = super().get_extra_cache_keys(query_obj)",
            "        if self.has_extra_cache_key_calls(query_obj):",
            "            sqla_query = self.get_sqla_query(**query_obj)",
            "            extra_cache_keys += sqla_query.extra_cache_keys",
            "        return extra_cache_keys",
            "",
            "    @staticmethod",
            "    def before_update(",
            "        mapper: Mapper,  # pylint: disable=unused-argument",
            "        connection: Connection,  # pylint: disable=unused-argument",
            "        target: \"SqlaTable\",",
            "    ) -> None:",
            "        \"\"\"",
            "        Check before update if the target table already exists.",
            "",
            "        Note this listener is called when any fields are being updated and thus it is",
            "        necessary to first check whether the reference table is being updated.",
            "",
            "        Note this logic is temporary, given uniqueness is handled via the dataset DAO,",
            "        but is necessary until both the legacy datasource editor and datasource/save",
            "        endpoints are deprecated.",
            "",
            "        :param mapper: The table mapper",
            "        :param connection: The DB-API connection",
            "        :param target: The mapped instance being persisted",
            "        :raises Exception: If the target table is not unique",
            "        \"\"\"",
            "",
            "        # pylint: disable=import-outside-toplevel",
            "        from superset.datasets.commands.exceptions import get_dataset_exist_error_msg",
            "        from superset.datasets.dao import DatasetDAO",
            "",
            "        # Check whether the relevant attributes have changed.",
            "        state = db.inspect(target)  # pylint: disable=no-member",
            "",
            "        for attr in [\"database_id\", \"schema\", \"table_name\"]:",
            "            history = state.get_history(attr, True)",
            "            if history.has_changes():",
            "                break",
            "        else:",
            "            return None",
            "",
            "        if not DatasetDAO.validate_uniqueness(",
            "            target.database_id, target.schema, target.table_name, target.id",
            "        ):",
            "            raise Exception(get_dataset_exist_error_msg(target.full_name))",
            "",
            "    @staticmethod",
            "    def update_table(  # pylint: disable=unused-argument",
            "        mapper: Mapper, connection: Connection, target: Union[SqlMetric, TableColumn]",
            "    ) -> None:",
            "        \"\"\"",
            "        Forces an update to the table's changed_on value when a metric or column on the",
            "        table is updated. This busts the cache key for all charts that use the table.",
            "",
            "        :param mapper: Unused.",
            "        :param connection: Unused.",
            "        :param target: The metric or column that was updated.",
            "        \"\"\"",
            "        inspector = inspect(target)",
            "        session = inspector.session",
            "        session.execute(update(SqlaTable).where(SqlaTable.id == target.table.id))",
            "",
            "",
            "sa.event.listen(SqlaTable, \"after_insert\", security_manager.set_perm)",
            "sa.event.listen(SqlaTable, \"after_update\", security_manager.set_perm)",
            "sa.event.listen(SqlaTable, \"before_update\", SqlaTable.before_update)",
            "sa.event.listen(SqlMetric, \"after_update\", SqlaTable.update_table)",
            "sa.event.listen(TableColumn, \"after_update\", SqlaTable.update_table)",
            "",
            "RLSFilterRoles = Table(",
            "    \"rls_filter_roles\",",
            "    metadata,",
            "    Column(\"id\", Integer, primary_key=True),",
            "    Column(\"role_id\", Integer, ForeignKey(\"ab_role.id\"), nullable=False),",
            "    Column(\"rls_filter_id\", Integer, ForeignKey(\"row_level_security_filters.id\")),",
            ")",
            "",
            "RLSFilterTables = Table(",
            "    \"rls_filter_tables\",",
            "    metadata,",
            "    Column(\"id\", Integer, primary_key=True),",
            "    Column(\"table_id\", Integer, ForeignKey(\"tables.id\")),",
            "    Column(\"rls_filter_id\", Integer, ForeignKey(\"row_level_security_filters.id\")),",
            ")",
            "",
            "",
            "class RowLevelSecurityFilter(Model, AuditMixinNullable):",
            "    \"\"\"",
            "    Custom where clauses attached to Tables and Roles.",
            "    \"\"\"",
            "",
            "    __tablename__ = \"row_level_security_filters\"",
            "    id = Column(Integer, primary_key=True)",
            "    filter_type = Column(",
            "        Enum(*[filter_type.value for filter_type in utils.RowLevelSecurityFilterType])",
            "    )",
            "    group_key = Column(String(255), nullable=True)",
            "    roles = relationship(",
            "        security_manager.role_model,",
            "        secondary=RLSFilterRoles,",
            "        backref=\"row_level_security_filters\",",
            "    )",
            "    tables = relationship(",
            "        SqlaTable, secondary=RLSFilterTables, backref=\"row_level_security_filters\"",
            "    )",
            "",
            "    clause = Column(Text, nullable=False)"
        ],
        "afterPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "# pylint: disable=too-many-lines",
            "import dataclasses",
            "import json",
            "import logging",
            "import re",
            "from collections import defaultdict",
            "from dataclasses import dataclass, field",
            "from datetime import datetime, timedelta",
            "from typing import (",
            "    Any,",
            "    cast,",
            "    Dict,",
            "    Hashable,",
            "    List,",
            "    NamedTuple,",
            "    Optional,",
            "    Tuple,",
            "    Type,",
            "    Union,",
            ")",
            "",
            "import dateutil.parser",
            "import numpy as np",
            "import pandas as pd",
            "import sqlalchemy as sa",
            "import sqlparse",
            "from flask import escape, Markup",
            "from flask_appbuilder import Model",
            "from flask_babel import lazy_gettext as _",
            "from jinja2.exceptions import TemplateError",
            "from sqlalchemy import (",
            "    and_,",
            "    asc,",
            "    Boolean,",
            "    Column,",
            "    DateTime,",
            "    desc,",
            "    Enum,",
            "    ForeignKey,",
            "    inspect,",
            "    Integer,",
            "    or_,",
            "    select,",
            "    String,",
            "    Table,",
            "    Text,",
            "    update,",
            ")",
            "from sqlalchemy.engine.base import Connection",
            "from sqlalchemy.orm import backref, Query, relationship, RelationshipProperty, Session",
            "from sqlalchemy.orm.mapper import Mapper",
            "from sqlalchemy.schema import UniqueConstraint",
            "from sqlalchemy.sql import column, ColumnElement, literal_column, table",
            "from sqlalchemy.sql.elements import ColumnClause, TextClause",
            "from sqlalchemy.sql.expression import Label, Select, TextAsFrom",
            "from sqlalchemy.sql.selectable import Alias, TableClause",
            "",
            "from superset import app, db, is_feature_enabled, security_manager",
            "from superset.common.db_query_status import QueryStatus",
            "from superset.connectors.base.models import BaseColumn, BaseDatasource, BaseMetric",
            "from superset.connectors.sqla.utils import (",
            "    get_physical_table_metadata,",
            "    get_virtual_table_metadata,",
            "    validate_adhoc_subquery,",
            ")",
            "from superset.db_engine_specs.base import BaseEngineSpec, CTE_ALIAS, TimestampExpression",
            "from superset.exceptions import (",
            "    QueryClauseValidationException,",
            "    QueryObjectValidationError,",
            ")",
            "from superset.jinja_context import (",
            "    BaseTemplateProcessor,",
            "    ExtraCache,",
            "    get_template_processor,",
            ")",
            "from superset.models.annotations import Annotation",
            "from superset.models.core import Database",
            "from superset.models.helpers import AuditMixinNullable, CertificationMixin, QueryResult",
            "from superset.sql_parse import ParsedQuery, sanitize_clause",
            "from superset.superset_typing import (",
            "    AdhocColumn,",
            "    AdhocMetric,",
            "    Column as ColumnTyping,",
            "    Metric,",
            "    OrderBy,",
            "    QueryObjectDict,",
            ")",
            "from superset.utils import core as utils",
            "from superset.utils.core import (",
            "    GenericDataType,",
            "    get_column_name,",
            "    is_adhoc_column,",
            "    QueryObjectFilterClause,",
            "    remove_duplicates,",
            ")",
            "",
            "config = app.config",
            "metadata = Model.metadata  # pylint: disable=no-member",
            "logger = logging.getLogger(__name__)",
            "",
            "VIRTUAL_TABLE_ALIAS = \"virtual_table\"",
            "",
            "# a non-exhaustive set of additive metrics",
            "ADDITIVE_METRIC_TYPES = {",
            "    \"count\",",
            "    \"sum\",",
            "    \"doubleSum\",",
            "}",
            "",
            "",
            "class SqlaQuery(NamedTuple):",
            "    applied_template_filters: List[str]",
            "    cte: Optional[str]",
            "    extra_cache_keys: List[Any]",
            "    labels_expected: List[str]",
            "    prequeries: List[str]",
            "    sqla_query: Select",
            "",
            "",
            "class QueryStringExtended(NamedTuple):",
            "    applied_template_filters: Optional[List[str]]",
            "    labels_expected: List[str]",
            "    prequeries: List[str]",
            "    sql: str",
            "",
            "",
            "@dataclass",
            "class MetadataResult:",
            "    added: List[str] = field(default_factory=list)",
            "    removed: List[str] = field(default_factory=list)",
            "    modified: List[str] = field(default_factory=list)",
            "",
            "",
            "class AnnotationDatasource(BaseDatasource):",
            "    \"\"\"Dummy object so we can query annotations using 'Viz' objects just like",
            "    regular datasources.",
            "    \"\"\"",
            "",
            "    cache_timeout = 0",
            "    changed_on = None",
            "    type = \"annotation\"",
            "    column_names = [",
            "        \"created_on\",",
            "        \"changed_on\",",
            "        \"id\",",
            "        \"start_dttm\",",
            "        \"end_dttm\",",
            "        \"layer_id\",",
            "        \"short_descr\",",
            "        \"long_descr\",",
            "        \"json_metadata\",",
            "        \"created_by_fk\",",
            "        \"changed_by_fk\",",
            "    ]",
            "",
            "    def query(self, query_obj: QueryObjectDict) -> QueryResult:",
            "        error_message = None",
            "        qry = db.session.query(Annotation)",
            "        qry = qry.filter(Annotation.layer_id == query_obj[\"filter\"][0][\"val\"])",
            "        if query_obj[\"from_dttm\"]:",
            "            qry = qry.filter(Annotation.start_dttm >= query_obj[\"from_dttm\"])",
            "        if query_obj[\"to_dttm\"]:",
            "            qry = qry.filter(Annotation.end_dttm <= query_obj[\"to_dttm\"])",
            "        status = QueryStatus.SUCCESS",
            "        try:",
            "            df = pd.read_sql_query(qry.statement, db.engine)",
            "        except Exception as ex:  # pylint: disable=broad-except",
            "            df = pd.DataFrame()",
            "            status = QueryStatus.FAILED",
            "            logger.exception(ex)",
            "            error_message = utils.error_msg_from_exception(ex)",
            "        return QueryResult(",
            "            status=status,",
            "            df=df,",
            "            duration=timedelta(0),",
            "            query=\"\",",
            "            error_message=error_message,",
            "        )",
            "",
            "    def get_query_str(self, query_obj: QueryObjectDict) -> str:",
            "        raise NotImplementedError()",
            "",
            "    def values_for_column(self, column_name: str, limit: int = 10000) -> List[Any]:",
            "        raise NotImplementedError()",
            "",
            "",
            "class TableColumn(Model, BaseColumn, CertificationMixin):",
            "",
            "    \"\"\"ORM object for table columns, each table can have multiple columns\"\"\"",
            "",
            "    __tablename__ = \"table_columns\"",
            "    __table_args__ = (UniqueConstraint(\"table_id\", \"column_name\"),)",
            "    table_id = Column(Integer, ForeignKey(\"tables.id\"))",
            "    table = relationship(",
            "        \"SqlaTable\",",
            "        backref=backref(\"columns\", cascade=\"all, delete-orphan\"),",
            "        foreign_keys=[table_id],",
            "    )",
            "    is_dttm = Column(Boolean, default=False)",
            "    expression = Column(Text)",
            "    python_date_format = Column(String(255))",
            "    extra = Column(Text)",
            "",
            "    export_fields = [",
            "        \"table_id\",",
            "        \"column_name\",",
            "        \"verbose_name\",",
            "        \"is_dttm\",",
            "        \"is_active\",",
            "        \"type\",",
            "        \"groupby\",",
            "        \"filterable\",",
            "        \"expression\",",
            "        \"description\",",
            "        \"python_date_format\",",
            "        \"extra\",",
            "    ]",
            "",
            "    update_from_object_fields = [s for s in export_fields if s not in (\"table_id\",)]",
            "    export_parent = \"table\"",
            "",
            "    @property",
            "    def is_boolean(self) -> bool:",
            "        \"\"\"",
            "        Check if the column has a boolean datatype.",
            "        \"\"\"",
            "        return self.type_generic == GenericDataType.BOOLEAN",
            "",
            "    @property",
            "    def is_numeric(self) -> bool:",
            "        \"\"\"",
            "        Check if the column has a numeric datatype.",
            "        \"\"\"",
            "        return self.type_generic == GenericDataType.NUMERIC",
            "",
            "    @property",
            "    def is_string(self) -> bool:",
            "        \"\"\"",
            "        Check if the column has a string datatype.",
            "        \"\"\"",
            "        return self.type_generic == GenericDataType.STRING",
            "",
            "    @property",
            "    def is_temporal(self) -> bool:",
            "        \"\"\"",
            "        Check if the column has a temporal datatype. If column has been set as",
            "        temporal/non-temporal (`is_dttm` is True or False respectively), return that",
            "        value. This usually happens during initial metadata fetching or when a column",
            "        is manually set as temporal (for this `python_date_format` needs to be set).",
            "        \"\"\"",
            "        if self.is_dttm is not None:",
            "            return self.is_dttm",
            "        return self.type_generic == GenericDataType.TEMPORAL",
            "",
            "    @property",
            "    def db_engine_spec(self) -> Type[BaseEngineSpec]:",
            "        return self.table.db_engine_spec",
            "",
            "    @property",
            "    def db_extra(self) -> Dict[str, Any]:",
            "        return self.table.database.get_extra()",
            "",
            "    @property",
            "    def type_generic(self) -> Optional[utils.GenericDataType]:",
            "        if self.is_dttm:",
            "            return GenericDataType.TEMPORAL",
            "        column_spec = self.db_engine_spec.get_column_spec(",
            "            self.type, db_extra=self.db_extra",
            "        )",
            "        return column_spec.generic_type if column_spec else None",
            "",
            "    def get_sqla_col(self, label: Optional[str] = None) -> Column:",
            "        label = label or self.column_name",
            "        db_engine_spec = self.db_engine_spec",
            "        column_spec = db_engine_spec.get_column_spec(self.type, db_extra=self.db_extra)",
            "        type_ = column_spec.sqla_type if column_spec else None",
            "        if self.expression:",
            "            tp = self.table.get_template_processor()",
            "            expression = tp.process_template(self.expression)",
            "            col = literal_column(expression, type_=type_)",
            "        else:",
            "            col = column(self.column_name, type_=type_)",
            "        col = self.table.make_sqla_column_compatible(col, label)",
            "        return col",
            "",
            "    @property",
            "    def datasource(self) -> RelationshipProperty:",
            "        return self.table",
            "",
            "    def get_time_filter(",
            "        self,",
            "        start_dttm: DateTime,",
            "        end_dttm: DateTime,",
            "        time_range_endpoints: Optional[",
            "            Tuple[utils.TimeRangeEndpoint, utils.TimeRangeEndpoint]",
            "        ],",
            "    ) -> ColumnElement:",
            "        col = self.get_sqla_col(label=\"__time\")",
            "        l = []",
            "        if start_dttm:",
            "            l.append(",
            "                col",
            "                >= self.table.text(",
            "                    self.dttm_sql_literal(start_dttm, time_range_endpoints)",
            "                )",
            "            )",
            "        if end_dttm:",
            "            if (",
            "                time_range_endpoints",
            "                and time_range_endpoints[1] == utils.TimeRangeEndpoint.EXCLUSIVE",
            "            ):",
            "                l.append(",
            "                    col",
            "                    < self.table.text(",
            "                        self.dttm_sql_literal(end_dttm, time_range_endpoints)",
            "                    )",
            "                )",
            "            else:",
            "                l.append(col <= self.table.text(self.dttm_sql_literal(end_dttm, None)))",
            "        return and_(*l)",
            "",
            "    def get_timestamp_expression(",
            "        self,",
            "        time_grain: Optional[str],",
            "        label: Optional[str] = None,",
            "        template_processor: Optional[BaseTemplateProcessor] = None,",
            "    ) -> Union[TimestampExpression, Label]:",
            "        \"\"\"",
            "        Return a SQLAlchemy Core element representation of self to be used in a query.",
            "",
            "        :param time_grain: Optional time grain, e.g. P1Y",
            "        :param label: alias/label that column is expected to have",
            "        :param template_processor: template processor",
            "        :return: A TimeExpression object wrapped in a Label if supported by db",
            "        \"\"\"",
            "        label = label or utils.DTTM_ALIAS",
            "",
            "        pdf = self.python_date_format",
            "        is_epoch = pdf in (\"epoch_s\", \"epoch_ms\")",
            "        column_spec = self.db_engine_spec.get_column_spec(",
            "            self.type, db_extra=self.db_extra",
            "        )",
            "        type_ = column_spec.sqla_type if column_spec else DateTime",
            "        if not self.expression and not time_grain and not is_epoch:",
            "            sqla_col = column(self.column_name, type_=type_)",
            "            return self.table.make_sqla_column_compatible(sqla_col, label)",
            "        if self.expression:",
            "            expression = self.expression",
            "            if template_processor:",
            "                expression = template_processor.process_template(self.expression)",
            "            col = literal_column(expression, type_=type_)",
            "        else:",
            "            col = column(self.column_name, type_=type_)",
            "        time_expr = self.db_engine_spec.get_timestamp_expr(",
            "            col, pdf, time_grain, self.type",
            "        )",
            "        return self.table.make_sqla_column_compatible(time_expr, label)",
            "",
            "    def dttm_sql_literal(",
            "        self,",
            "        dttm: DateTime,",
            "        time_range_endpoints: Optional[",
            "            Tuple[utils.TimeRangeEndpoint, utils.TimeRangeEndpoint]",
            "        ],",
            "    ) -> str:",
            "        \"\"\"Convert datetime object to a SQL expression string\"\"\"",
            "        sql = (",
            "            self.db_engine_spec.convert_dttm(self.type, dttm, db_extra=self.db_extra)",
            "            if self.type",
            "            else None",
            "        )",
            "",
            "        if sql:",
            "            return sql",
            "",
            "        tf = self.python_date_format",
            "",
            "        # Fallback to the default format (if defined) only if the SIP-15 time range",
            "        # endpoints, i.e., [start, end) are enabled.",
            "        if not tf and time_range_endpoints == (",
            "            utils.TimeRangeEndpoint.INCLUSIVE,",
            "            utils.TimeRangeEndpoint.EXCLUSIVE,",
            "        ):",
            "            tf = self.db_extra.get(\"python_date_format_by_column_name\", {}).get(",
            "                self.column_name",
            "            )",
            "",
            "        if tf:",
            "            if tf in [\"epoch_ms\", \"epoch_s\"]:",
            "                seconds_since_epoch = int(dttm.timestamp())",
            "                if tf == \"epoch_s\":",
            "                    return str(seconds_since_epoch)",
            "                return str(seconds_since_epoch * 1000)",
            "            return f\"'{dttm.strftime(tf)}'\"",
            "",
            "        # TODO(john-bodley): SIP-15 will explicitly require a type conversion.",
            "        return f\"\"\"'{dttm.strftime(\"%Y-%m-%d %H:%M:%S.%f\")}'\"\"\"",
            "",
            "    @property",
            "    def data(self) -> Dict[str, Any]:",
            "        attrs = (",
            "            \"id\",",
            "            \"column_name\",",
            "            \"verbose_name\",",
            "            \"description\",",
            "            \"expression\",",
            "            \"filterable\",",
            "            \"groupby\",",
            "            \"is_dttm\",",
            "            \"type\",",
            "            \"type_generic\",",
            "            \"python_date_format\",",
            "            \"is_certified\",",
            "            \"certified_by\",",
            "            \"certification_details\",",
            "            \"warning_markdown\",",
            "        )",
            "",
            "        attr_dict = {s: getattr(self, s) for s in attrs if hasattr(self, s)}",
            "",
            "        attr_dict.update(super().data)",
            "",
            "        return attr_dict",
            "",
            "",
            "class SqlMetric(Model, BaseMetric, CertificationMixin):",
            "",
            "    \"\"\"ORM object for metrics, each table can have multiple metrics\"\"\"",
            "",
            "    __tablename__ = \"sql_metrics\"",
            "    __table_args__ = (UniqueConstraint(\"table_id\", \"metric_name\"),)",
            "    table_id = Column(Integer, ForeignKey(\"tables.id\"))",
            "    table = relationship(",
            "        \"SqlaTable\",",
            "        backref=backref(\"metrics\", cascade=\"all, delete-orphan\"),",
            "        foreign_keys=[table_id],",
            "    )",
            "    expression = Column(Text, nullable=False)",
            "    extra = Column(Text)",
            "",
            "    export_fields = [",
            "        \"metric_name\",",
            "        \"verbose_name\",",
            "        \"metric_type\",",
            "        \"table_id\",",
            "        \"expression\",",
            "        \"description\",",
            "        \"d3format\",",
            "        \"extra\",",
            "        \"warning_text\",",
            "    ]",
            "    update_from_object_fields = list(s for s in export_fields if s != \"table_id\")",
            "    export_parent = \"table\"",
            "",
            "    def get_sqla_col(self, label: Optional[str] = None) -> Column:",
            "        label = label or self.metric_name",
            "        tp = self.table.get_template_processor()",
            "        sqla_col: ColumnClause = literal_column(tp.process_template(self.expression))",
            "        return self.table.make_sqla_column_compatible(sqla_col, label)",
            "",
            "    @property",
            "    def perm(self) -> Optional[str]:",
            "        return (",
            "            (\"{parent_name}.[{obj.metric_name}](id:{obj.id})\").format(",
            "                obj=self, parent_name=self.table.full_name",
            "            )",
            "            if self.table",
            "            else None",
            "        )",
            "",
            "    def get_perm(self) -> Optional[str]:",
            "        return self.perm",
            "",
            "    @property",
            "    def data(self) -> Dict[str, Any]:",
            "        attrs = (",
            "            \"is_certified\",",
            "            \"certified_by\",",
            "            \"certification_details\",",
            "            \"warning_markdown\",",
            "        )",
            "        attr_dict = {s: getattr(self, s) for s in attrs}",
            "",
            "        attr_dict.update(super().data)",
            "        return attr_dict",
            "",
            "",
            "sqlatable_user = Table(",
            "    \"sqlatable_user\",",
            "    metadata,",
            "    Column(\"id\", Integer, primary_key=True),",
            "    Column(\"user_id\", Integer, ForeignKey(\"ab_user.id\")),",
            "    Column(\"table_id\", Integer, ForeignKey(\"tables.id\")),",
            ")",
            "",
            "",
            "def _process_sql_expression(",
            "    expression: Optional[str],",
            "    database_id: int,",
            "    schema: str,",
            "    template_processor: Optional[BaseTemplateProcessor],",
            ") -> Optional[str]:",
            "    if template_processor and expression:",
            "        expression = template_processor.process_template(expression)",
            "    if expression:",
            "        expression = validate_adhoc_subquery(",
            "            expression,",
            "            database_id,",
            "            schema,",
            "        )",
            "        try:",
            "            expression = sanitize_clause(expression)",
            "        except QueryClauseValidationException as ex:",
            "            raise QueryObjectValidationError(ex.message) from ex",
            "    return expression",
            "",
            "",
            "class SqlaTable(Model, BaseDatasource):  # pylint: disable=too-many-public-methods",
            "    \"\"\"An ORM object for SqlAlchemy table references\"\"\"",
            "",
            "    type = \"table\"",
            "    query_language = \"sql\"",
            "    is_rls_supported = True",
            "    columns: List[TableColumn] = []",
            "    metrics: List[SqlMetric] = []",
            "    metric_class = SqlMetric",
            "    column_class = TableColumn",
            "    owner_class = security_manager.user_model",
            "",
            "    __tablename__ = \"tables\"",
            "",
            "    # Note this uniqueness constraint is not part of the physical schema, i.e., it does",
            "    # not exist in the migrations, but is required by `import_from_dict` to ensure the",
            "    # correct filters are applied in order to identify uniqueness.",
            "    #",
            "    # The reason it does not physically exist is MySQL, PostgreSQL, etc. have a",
            "    # different interpretation of uniqueness when it comes to NULL which is problematic",
            "    # given the schema is optional.",
            "    __table_args__ = (UniqueConstraint(\"database_id\", \"schema\", \"table_name\"),)",
            "",
            "    table_name = Column(String(250), nullable=False)",
            "    main_dttm_col = Column(String(250))",
            "    database_id = Column(Integer, ForeignKey(\"dbs.id\"), nullable=False)",
            "    fetch_values_predicate = Column(Text)",
            "    owners = relationship(owner_class, secondary=sqlatable_user, backref=\"tables\")",
            "    database: Database = relationship(",
            "        \"Database\",",
            "        backref=backref(\"tables\", cascade=\"all, delete-orphan\"),",
            "        foreign_keys=[database_id],",
            "    )",
            "    schema = Column(String(255))",
            "    sql = Column(Text)",
            "    is_sqllab_view = Column(Boolean, default=False)",
            "    template_params = Column(Text)",
            "    extra = Column(Text)",
            "",
            "    baselink = \"tablemodelview\"",
            "",
            "    export_fields = [",
            "        \"table_name\",",
            "        \"main_dttm_col\",",
            "        \"description\",",
            "        \"default_endpoint\",",
            "        \"database_id\",",
            "        \"offset\",",
            "        \"cache_timeout\",",
            "        \"schema\",",
            "        \"sql\",",
            "        \"params\",",
            "        \"template_params\",",
            "        \"filter_select_enabled\",",
            "        \"fetch_values_predicate\",",
            "        \"extra\",",
            "    ]",
            "    update_from_object_fields = [f for f in export_fields if f != \"database_id\"]",
            "    export_parent = \"database\"",
            "    export_children = [\"metrics\", \"columns\"]",
            "",
            "    sqla_aggregations = {",
            "        \"COUNT_DISTINCT\": lambda column_name: sa.func.COUNT(sa.distinct(column_name)),",
            "        \"COUNT\": sa.func.COUNT,",
            "        \"SUM\": sa.func.SUM,",
            "        \"AVG\": sa.func.AVG,",
            "        \"MIN\": sa.func.MIN,",
            "        \"MAX\": sa.func.MAX,",
            "    }",
            "",
            "    def __repr__(self) -> str:",
            "        return self.name",
            "",
            "    @staticmethod",
            "    def _apply_cte(sql: str, cte: Optional[str]) -> str:",
            "        \"\"\"",
            "        Append a CTE before the SELECT statement if defined",
            "",
            "        :param sql: SELECT statement",
            "        :param cte: CTE statement",
            "        :return:",
            "        \"\"\"",
            "        if cte:",
            "            sql = f\"{cte}\\n{sql}\"",
            "        return sql",
            "",
            "    @property",
            "    def db_engine_spec(self) -> Type[BaseEngineSpec]:",
            "        return self.database.db_engine_spec",
            "",
            "    @property",
            "    def changed_by_name(self) -> str:",
            "        if not self.changed_by:",
            "            return \"\"",
            "        return str(self.changed_by)",
            "",
            "    @property",
            "    def changed_by_url(self) -> str:",
            "        if not self.changed_by:",
            "            return \"\"",
            "        return f\"/superset/profile/{self.changed_by.username}\"",
            "",
            "    @property",
            "    def connection(self) -> str:",
            "        return str(self.database)",
            "",
            "    @property",
            "    def description_markeddown(self) -> str:",
            "        return utils.markdown(self.description)",
            "",
            "    @property",
            "    def datasource_name(self) -> str:",
            "        return self.table_name",
            "",
            "    @property",
            "    def datasource_type(self) -> str:",
            "        return self.type",
            "",
            "    @property",
            "    def database_name(self) -> str:",
            "        return self.database.name",
            "",
            "    @classmethod",
            "    def get_datasource_by_name(",
            "        cls,",
            "        session: Session,",
            "        datasource_name: str,",
            "        schema: Optional[str],",
            "        database_name: str,",
            "    ) -> Optional[\"SqlaTable\"]:",
            "        schema = schema or None",
            "        query = (",
            "            session.query(cls)",
            "            .join(Database)",
            "            .filter(cls.table_name == datasource_name)",
            "            .filter(Database.database_name == database_name)",
            "        )",
            "        # Handling schema being '' or None, which is easier to handle",
            "        # in python than in the SQLA query in a multi-dialect way",
            "        for tbl in query.all():",
            "            if schema == (tbl.schema or None):",
            "                return tbl",
            "        return None",
            "",
            "    @property",
            "    def link(self) -> Markup:",
            "        name = escape(self.name)",
            "        anchor = f'<a target=\"_blank\" href=\"{self.explore_url}\">{name}</a>'",
            "        return Markup(anchor)",
            "",
            "    def get_schema_perm(self) -> Optional[str]:",
            "        \"\"\"Returns schema permission if present, database one otherwise.\"\"\"",
            "        return security_manager.get_schema_perm(self.database, self.schema)",
            "",
            "    def get_perm(self) -> str:",
            "        return f\"[{self.database}].[{self.table_name}](id:{self.id})\"",
            "",
            "    @property",
            "    def name(self) -> str:",
            "        if not self.schema:",
            "            return self.table_name",
            "        return \"{}.{}\".format(self.schema, self.table_name)",
            "",
            "    @property",
            "    def full_name(self) -> str:",
            "        return utils.get_datasource_full_name(",
            "            self.database, self.table_name, schema=self.schema",
            "        )",
            "",
            "    @property",
            "    def dttm_cols(self) -> List[str]:",
            "        l = [c.column_name for c in self.columns if c.is_dttm]",
            "        if self.main_dttm_col and self.main_dttm_col not in l:",
            "            l.append(self.main_dttm_col)",
            "        return l",
            "",
            "    @property",
            "    def num_cols(self) -> List[str]:",
            "        return [c.column_name for c in self.columns if c.is_numeric]",
            "",
            "    @property",
            "    def any_dttm_col(self) -> Optional[str]:",
            "        cols = self.dttm_cols",
            "        return cols[0] if cols else None",
            "",
            "    @property",
            "    def html(self) -> str:",
            "        df = pd.DataFrame((c.column_name, c.type) for c in self.columns)",
            "        df.columns = [\"field\", \"type\"]",
            "        return df.to_html(",
            "            index=False,",
            "            classes=(\"dataframe table table-striped table-bordered \" \"table-condensed\"),",
            "        )",
            "",
            "    @property",
            "    def sql_url(self) -> str:",
            "        return self.database.sql_url + \"?table_name=\" + str(self.table_name)",
            "",
            "    def external_metadata(self) -> List[Dict[str, str]]:",
            "        # todo(yongjie): create a pysical table column type in seprated PR",
            "        if self.sql:",
            "            return get_virtual_table_metadata(dataset=self)  # type: ignore",
            "        return get_physical_table_metadata(",
            "            database=self.database,",
            "            table_name=self.table_name,",
            "            schema_name=self.schema,",
            "        )",
            "",
            "    @property",
            "    def time_column_grains(self) -> Dict[str, Any]:",
            "        return {",
            "            \"time_columns\": self.dttm_cols,",
            "            \"time_grains\": [grain.name for grain in self.database.grains()],",
            "        }",
            "",
            "    @property",
            "    def select_star(self) -> Optional[str]:",
            "        # show_cols and latest_partition set to false to avoid",
            "        # the expensive cost of inspecting the DB",
            "        return self.database.select_star(",
            "            self.table_name, schema=self.schema, show_cols=False, latest_partition=False",
            "        )",
            "",
            "    @property",
            "    def health_check_message(self) -> Optional[str]:",
            "        check = config[\"DATASET_HEALTH_CHECK\"]",
            "        return check(self) if check else None",
            "",
            "    @property",
            "    def data(self) -> Dict[str, Any]:",
            "        data_ = super().data",
            "        if self.type == \"table\":",
            "            data_[\"granularity_sqla\"] = utils.choicify(self.dttm_cols)",
            "            data_[\"time_grain_sqla\"] = [",
            "                (g.duration, g.name) for g in self.database.grains() or []",
            "            ]",
            "            data_[\"main_dttm_col\"] = self.main_dttm_col",
            "            data_[\"fetch_values_predicate\"] = self.fetch_values_predicate",
            "            data_[\"template_params\"] = self.template_params",
            "            data_[\"is_sqllab_view\"] = self.is_sqllab_view",
            "            data_[\"health_check_message\"] = self.health_check_message",
            "            data_[\"extra\"] = self.extra",
            "        return data_",
            "",
            "    @property",
            "    def extra_dict(self) -> Dict[str, Any]:",
            "        try:",
            "            return json.loads(self.extra)",
            "        except (TypeError, json.JSONDecodeError):",
            "            return {}",
            "",
            "    def get_fetch_values_predicate(self) -> TextClause:",
            "        tp = self.get_template_processor()",
            "        try:",
            "            return self.text(tp.process_template(self.fetch_values_predicate))",
            "        except TemplateError as ex:",
            "            raise QueryObjectValidationError(",
            "                _(",
            "                    \"Error in jinja expression in fetch values predicate: %(msg)s\",",
            "                    msg=ex.message,",
            "                )",
            "            ) from ex",
            "",
            "    def values_for_column(self, column_name: str, limit: int = 10000) -> List[Any]:",
            "        \"\"\"Runs query against sqla to retrieve some",
            "        sample values for the given column.",
            "        \"\"\"",
            "        cols = {col.column_name: col for col in self.columns}",
            "        target_col = cols[column_name]",
            "        tp = self.get_template_processor()",
            "        tbl, cte = self.get_from_clause(tp)",
            "",
            "        qry = select([target_col.get_sqla_col()]).select_from(tbl).distinct()",
            "        if limit:",
            "            qry = qry.limit(limit)",
            "",
            "        if self.fetch_values_predicate:",
            "            qry = qry.where(self.get_fetch_values_predicate())",
            "",
            "        engine = self.database.get_sqla_engine()",
            "        sql = qry.compile(engine, compile_kwargs={\"literal_binds\": True})",
            "        sql = self._apply_cte(sql, cte)",
            "        sql = self.mutate_query_from_config(sql)",
            "",
            "        df = pd.read_sql_query(sql=sql, con=engine)",
            "        return df[column_name].to_list()",
            "",
            "    def mutate_query_from_config(self, sql: str) -> str:",
            "        \"\"\"Apply config's SQL_QUERY_MUTATOR",
            "",
            "        Typically adds comments to the query with context\"\"\"",
            "        sql_query_mutator = config[\"SQL_QUERY_MUTATOR\"]",
            "        if sql_query_mutator:",
            "            username = utils.get_username()",
            "            sql = sql_query_mutator(sql, username, security_manager, self.database)",
            "        return sql",
            "",
            "    def get_template_processor(self, **kwargs: Any) -> BaseTemplateProcessor:",
            "        return get_template_processor(table=self, database=self.database, **kwargs)",
            "",
            "    def get_query_str_extended(self, query_obj: QueryObjectDict) -> QueryStringExtended:",
            "        sqlaq = self.get_sqla_query(**query_obj)",
            "        sql = self.database.compile_sqla_query(sqlaq.sqla_query)",
            "        sql = self._apply_cte(sql, sqlaq.cte)",
            "        sql = sqlparse.format(sql, reindent=True)",
            "        sql = self.mutate_query_from_config(sql)",
            "        return QueryStringExtended(",
            "            applied_template_filters=sqlaq.applied_template_filters,",
            "            labels_expected=sqlaq.labels_expected,",
            "            prequeries=sqlaq.prequeries,",
            "            sql=sql,",
            "        )",
            "",
            "    def get_query_str(self, query_obj: QueryObjectDict) -> str:",
            "        query_str_ext = self.get_query_str_extended(query_obj)",
            "        all_queries = query_str_ext.prequeries + [query_str_ext.sql]",
            "        return \";\\n\\n\".join(all_queries) + \";\"",
            "",
            "    def get_sqla_table(self) -> TableClause:",
            "        tbl = table(self.table_name)",
            "        if self.schema:",
            "            tbl.schema = self.schema",
            "        return tbl",
            "",
            "    def get_from_clause(",
            "        self, template_processor: Optional[BaseTemplateProcessor] = None",
            "    ) -> Tuple[Union[TableClause, Alias], Optional[str]]:",
            "        \"\"\"",
            "        Return where to select the columns and metrics from. Either a physical table",
            "        or a virtual table with it's own subquery. If the FROM is referencing a",
            "        CTE, the CTE is returned as the second value in the return tuple.",
            "        \"\"\"",
            "        if not self.is_virtual:",
            "            return self.get_sqla_table(), None",
            "",
            "        from_sql = self.get_rendered_sql(template_processor)",
            "        parsed_query = ParsedQuery(from_sql)",
            "        if not (",
            "            parsed_query.is_unknown()",
            "            or self.db_engine_spec.is_readonly_query(parsed_query)",
            "        ):",
            "            raise QueryObjectValidationError(",
            "                _(\"Virtual dataset query must be read-only\")",
            "            )",
            "",
            "        cte = self.db_engine_spec.get_cte_query(from_sql)",
            "        from_clause = (",
            "            table(CTE_ALIAS)",
            "            if cte",
            "            else TextAsFrom(self.text(from_sql), []).alias(VIRTUAL_TABLE_ALIAS)",
            "        )",
            "",
            "        return from_clause, cte",
            "",
            "    def get_rendered_sql(",
            "        self, template_processor: Optional[BaseTemplateProcessor] = None",
            "    ) -> str:",
            "        \"\"\"",
            "        Render sql with template engine (Jinja).",
            "        \"\"\"",
            "",
            "        sql = self.sql",
            "        if template_processor:",
            "            try:",
            "                sql = template_processor.process_template(sql)",
            "            except TemplateError as ex:",
            "                raise QueryObjectValidationError(",
            "                    _(",
            "                        \"Error while rendering virtual dataset query: %(msg)s\",",
            "                        msg=ex.message,",
            "                    )",
            "                ) from ex",
            "        sql = sqlparse.format(sql.strip(\"\\t\\r\\n; \"), strip_comments=True)",
            "        if not sql:",
            "            raise QueryObjectValidationError(_(\"Virtual dataset query cannot be empty\"))",
            "        if len(sqlparse.split(sql)) > 1:",
            "            raise QueryObjectValidationError(",
            "                _(\"Virtual dataset query cannot consist of multiple statements\")",
            "            )",
            "        return sql",
            "",
            "    def adhoc_metric_to_sqla(",
            "        self,",
            "        metric: AdhocMetric,",
            "        columns_by_name: Dict[str, TableColumn],",
            "        template_processor: Optional[BaseTemplateProcessor] = None,",
            "    ) -> ColumnElement:",
            "        \"\"\"",
            "        Turn an adhoc metric into a sqlalchemy column.",
            "",
            "        :param dict metric: Adhoc metric definition",
            "        :param dict columns_by_name: Columns for the current table",
            "        :param template_processor: template_processor instance",
            "        :returns: The metric defined as a sqlalchemy column",
            "        :rtype: sqlalchemy.sql.column",
            "        \"\"\"",
            "        expression_type = metric.get(\"expressionType\")",
            "        label = utils.get_metric_name(metric)",
            "",
            "        if expression_type == utils.AdhocMetricExpressionType.SIMPLE:",
            "            metric_column = metric.get(\"column\") or {}",
            "            column_name = cast(str, metric_column.get(\"column_name\"))",
            "            table_column: Optional[TableColumn] = columns_by_name.get(column_name)",
            "            if table_column:",
            "                sqla_column = table_column.get_sqla_col()",
            "            else:",
            "                sqla_column = column(column_name)",
            "            sqla_metric = self.sqla_aggregations[metric[\"aggregate\"]](sqla_column)",
            "        elif expression_type == utils.AdhocMetricExpressionType.SQL:",
            "            expression = _process_sql_expression(",
            "                expression=metric[\"sqlExpression\"],",
            "                database_id=self.database_id,",
            "                schema=self.schema,",
            "                template_processor=template_processor,",
            "            )",
            "            sqla_metric = literal_column(expression)",
            "        else:",
            "            raise QueryObjectValidationError(\"Adhoc metric expressionType is invalid\")",
            "",
            "        return self.make_sqla_column_compatible(sqla_metric, label)",
            "",
            "    def adhoc_column_to_sqla(",
            "        self,",
            "        col: AdhocColumn,",
            "        template_processor: Optional[BaseTemplateProcessor] = None,",
            "    ) -> ColumnElement:",
            "        \"\"\"",
            "        Turn an adhoc column into a sqlalchemy column.",
            "",
            "        :param col: Adhoc column definition",
            "        :param template_processor: template_processor instance",
            "        :returns: The metric defined as a sqlalchemy column",
            "        :rtype: sqlalchemy.sql.column",
            "        \"\"\"",
            "        label = utils.get_column_name(col)",
            "        expression = _process_sql_expression(",
            "            expression=col[\"sqlExpression\"],",
            "            database_id=self.database_id,",
            "            schema=self.schema,",
            "            template_processor=template_processor,",
            "        )",
            "        sqla_column = literal_column(expression)",
            "        return self.make_sqla_column_compatible(sqla_column, label)",
            "",
            "    def make_sqla_column_compatible(",
            "        self, sqla_col: ColumnElement, label: Optional[str] = None",
            "    ) -> ColumnElement:",
            "        \"\"\"Takes a sqlalchemy column object and adds label info if supported by engine.",
            "        :param sqla_col: sqlalchemy column instance",
            "        :param label: alias/label that column is expected to have",
            "        :return: either a sql alchemy column or label instance if supported by engine",
            "        \"\"\"",
            "        label_expected = label or sqla_col.name",
            "        db_engine_spec = self.db_engine_spec",
            "        # add quotes to tables",
            "        if db_engine_spec.allows_alias_in_select:",
            "            label = db_engine_spec.make_label_compatible(label_expected)",
            "            sqla_col = sqla_col.label(label)",
            "        sqla_col.key = label_expected",
            "        return sqla_col",
            "",
            "    def make_orderby_compatible(",
            "        self, select_exprs: List[ColumnElement], orderby_exprs: List[ColumnElement]",
            "    ) -> None:",
            "        \"\"\"",
            "        If needed, make sure aliases for selected columns are not used in",
            "        `ORDER BY`.",
            "",
            "        In some databases (e.g. Presto), `ORDER BY` clause is not able to",
            "        automatically pick the source column if a `SELECT` clause alias is named",
            "        the same as a source column. In this case, we update the SELECT alias to",
            "        another name to avoid the conflict.",
            "        \"\"\"",
            "        if self.db_engine_spec.allows_alias_to_source_column:",
            "            return",
            "",
            "        def is_alias_used_in_orderby(col: ColumnElement) -> bool:",
            "            if not isinstance(col, Label):",
            "                return False",
            "            regexp = re.compile(f\"\\\\(.*\\\\b{re.escape(col.name)}\\\\b.*\\\\)\", re.IGNORECASE)",
            "            return any(regexp.search(str(x)) for x in orderby_exprs)",
            "",
            "        # Iterate through selected columns, if column alias appears in orderby",
            "        # use another `alias`. The final output columns will still use the",
            "        # original names, because they are updated by `labels_expected` after",
            "        # querying.",
            "        for col in select_exprs:",
            "            if is_alias_used_in_orderby(col):",
            "                col.name = f\"{col.name}__\"",
            "",
            "    def get_sqla_row_level_filters(",
            "        self, template_processor: BaseTemplateProcessor",
            "    ) -> List[TextClause]:",
            "        \"\"\"",
            "        Return the appropriate row level security filters for",
            "        this table and the current user.",
            "",
            "        :param BaseTemplateProcessor template_processor: The template",
            "        processor to apply to the filters.",
            "        :returns: A list of SQL clauses to be ANDed together.",
            "        \"\"\"",
            "        all_filters: List[TextClause] = []",
            "        filter_groups: Dict[Union[int, str], List[TextClause]] = defaultdict(list)",
            "        try:",
            "            for filter_ in security_manager.get_rls_filters(self):",
            "                clause = self.text(",
            "                    f\"({template_processor.process_template(filter_.clause)})\"",
            "                )",
            "                if filter_.group_key:",
            "                    filter_groups[filter_.group_key].append(clause)",
            "                else:",
            "                    all_filters.append(clause)",
            "",
            "            if is_feature_enabled(\"EMBEDDED_SUPERSET\"):",
            "                for rule in security_manager.get_guest_rls_filters(self):",
            "                    clause = self.text(",
            "                        f\"({template_processor.process_template(rule['clause'])})\"",
            "                    )",
            "                    all_filters.append(clause)",
            "",
            "            grouped_filters = [or_(*clauses) for clauses in filter_groups.values()]",
            "            all_filters.extend(grouped_filters)",
            "            return all_filters",
            "        except TemplateError as ex:",
            "            raise QueryObjectValidationError(",
            "                _(",
            "                    \"Error in jinja expression in RLS filters: %(msg)s\",",
            "                    msg=ex.message,",
            "                )",
            "            ) from ex",
            "",
            "    def text(self, clause: str) -> TextClause:",
            "        return self.db_engine_spec.get_text_clause(clause)",
            "",
            "    def get_sqla_query(  # pylint: disable=too-many-arguments,too-many-locals,too-many-branches,too-many-statements",
            "        self,",
            "        apply_fetch_values_predicate: bool = False,",
            "        columns: Optional[List[ColumnTyping]] = None,",
            "        extras: Optional[Dict[str, Any]] = None,",
            "        filter: Optional[  # pylint: disable=redefined-builtin",
            "            List[QueryObjectFilterClause]",
            "        ] = None,",
            "        from_dttm: Optional[datetime] = None,",
            "        granularity: Optional[str] = None,",
            "        groupby: Optional[List[Column]] = None,",
            "        inner_from_dttm: Optional[datetime] = None,",
            "        inner_to_dttm: Optional[datetime] = None,",
            "        is_rowcount: bool = False,",
            "        is_timeseries: bool = True,",
            "        metrics: Optional[List[Metric]] = None,",
            "        orderby: Optional[List[OrderBy]] = None,",
            "        order_desc: bool = True,",
            "        to_dttm: Optional[datetime] = None,",
            "        series_columns: Optional[List[Column]] = None,",
            "        series_limit: Optional[int] = None,",
            "        series_limit_metric: Optional[Metric] = None,",
            "        row_limit: Optional[int] = None,",
            "        row_offset: Optional[int] = None,",
            "        timeseries_limit: Optional[int] = None,",
            "        timeseries_limit_metric: Optional[Metric] = None,",
            "    ) -> SqlaQuery:",
            "        \"\"\"Querying any sqla table from this common interface\"\"\"",
            "        if granularity not in self.dttm_cols and granularity is not None:",
            "            granularity = self.main_dttm_col",
            "",
            "        extras = extras or {}",
            "        time_grain = extras.get(\"time_grain_sqla\")",
            "",
            "        template_kwargs = {",
            "            \"columns\": columns,",
            "            \"from_dttm\": from_dttm.isoformat() if from_dttm else None,",
            "            \"groupby\": groupby,",
            "            \"metrics\": metrics,",
            "            \"row_limit\": row_limit,",
            "            \"row_offset\": row_offset,",
            "            \"time_column\": granularity,",
            "            \"time_grain\": time_grain,",
            "            \"to_dttm\": to_dttm.isoformat() if to_dttm else None,",
            "            \"table_columns\": [col.column_name for col in self.columns],",
            "            \"filter\": filter,",
            "        }",
            "        columns = columns or []",
            "        groupby = groupby or []",
            "        series_column_names = utils.get_column_names(series_columns or [])",
            "        # deprecated, to be removed in 2.0",
            "        if is_timeseries and timeseries_limit:",
            "            series_limit = timeseries_limit",
            "        series_limit_metric = series_limit_metric or timeseries_limit_metric",
            "        template_kwargs.update(self.template_params_dict)",
            "        extra_cache_keys: List[Any] = []",
            "        template_kwargs[\"extra_cache_keys\"] = extra_cache_keys",
            "        removed_filters: List[str] = []",
            "        applied_template_filters: List[str] = []",
            "        template_kwargs[\"removed_filters\"] = removed_filters",
            "        template_kwargs[\"applied_filters\"] = applied_template_filters",
            "        template_processor = self.get_template_processor(**template_kwargs)",
            "        db_engine_spec = self.db_engine_spec",
            "        prequeries: List[str] = []",
            "        orderby = orderby or []",
            "        need_groupby = bool(metrics is not None or groupby)",
            "        metrics = metrics or []",
            "",
            "        # For backward compatibility",
            "        if granularity not in self.dttm_cols and granularity is not None:",
            "            granularity = self.main_dttm_col",
            "",
            "        columns_by_name: Dict[str, TableColumn] = {",
            "            col.column_name: col for col in self.columns",
            "        }",
            "",
            "        metrics_by_name: Dict[str, SqlMetric] = {m.metric_name: m for m in self.metrics}",
            "",
            "        if not granularity and is_timeseries:",
            "            raise QueryObjectValidationError(",
            "                _(",
            "                    \"Datetime column not provided as part table configuration \"",
            "                    \"and is required by this type of chart\"",
            "                )",
            "            )",
            "        if not metrics and not columns and not groupby:",
            "            raise QueryObjectValidationError(_(\"Empty query?\"))",
            "",
            "        metrics_exprs: List[ColumnElement] = []",
            "        for metric in metrics:",
            "            if utils.is_adhoc_metric(metric):",
            "                assert isinstance(metric, dict)",
            "                metrics_exprs.append(",
            "                    self.adhoc_metric_to_sqla(",
            "                        metric=metric,",
            "                        columns_by_name=columns_by_name,",
            "                        template_processor=template_processor,",
            "                    )",
            "                )",
            "            elif isinstance(metric, str) and metric in metrics_by_name:",
            "                metrics_exprs.append(metrics_by_name[metric].get_sqla_col())",
            "            else:",
            "                raise QueryObjectValidationError(",
            "                    _(\"Metric '%(metric)s' does not exist\", metric=metric)",
            "                )",
            "",
            "        if metrics_exprs:",
            "            main_metric_expr = metrics_exprs[0]",
            "        else:",
            "            main_metric_expr, label = literal_column(\"COUNT(*)\"), \"ccount\"",
            "            main_metric_expr = self.make_sqla_column_compatible(main_metric_expr, label)",
            "",
            "        # To ensure correct handling of the ORDER BY labeling we need to reference the",
            "        # metric instance if defined in the SELECT clause.",
            "        # use the key of the ColumnClause for the expected label",
            "        metrics_exprs_by_label = {m.key: m for m in metrics_exprs}",
            "        metrics_exprs_by_expr = {str(m): m for m in metrics_exprs}",
            "",
            "        # Since orderby may use adhoc metrics, too; we need to process them first",
            "        orderby_exprs: List[ColumnElement] = []",
            "        for orig_col, ascending in orderby:",
            "            col: Union[AdhocMetric, ColumnElement] = orig_col",
            "            if isinstance(col, dict):",
            "                col = cast(AdhocMetric, col)",
            "                if col.get(\"sqlExpression\"):",
            "                    col[\"sqlExpression\"] = _process_sql_expression(",
            "                        expression=col[\"sqlExpression\"],",
            "                        database_id=self.database_id,",
            "                        schema=self.schema,",
            "                        template_processor=template_processor,",
            "                    )",
            "                if utils.is_adhoc_metric(col):",
            "                    # add adhoc sort by column to columns_by_name if not exists",
            "                    col = self.adhoc_metric_to_sqla(col, columns_by_name)",
            "                    # if the adhoc metric has been defined before",
            "                    # use the existing instance.",
            "                    col = metrics_exprs_by_expr.get(str(col), col)",
            "                    need_groupby = True",
            "            elif col in columns_by_name:",
            "                col = columns_by_name[col].get_sqla_col()",
            "            elif col in metrics_exprs_by_label:",
            "                col = metrics_exprs_by_label[col]",
            "                need_groupby = True",
            "            elif col in metrics_by_name:",
            "                col = metrics_by_name[col].get_sqla_col()",
            "                need_groupby = True",
            "",
            "            if isinstance(col, ColumnElement):",
            "                orderby_exprs.append(col)",
            "            else:",
            "                # Could not convert a column reference to valid ColumnElement",
            "                raise QueryObjectValidationError(",
            "                    _(\"Unknown column used in orderby: %(col)s\", col=orig_col)",
            "                )",
            "",
            "        select_exprs: List[Union[Column, Label]] = []",
            "        groupby_all_columns = {}",
            "        groupby_series_columns = {}",
            "",
            "        # filter out the pseudo column  __timestamp from columns",
            "        columns = [col for col in columns if col != utils.DTTM_ALIAS]",
            "        dttm_col = columns_by_name.get(granularity) if granularity else None",
            "",
            "        if need_groupby:",
            "            # dedup columns while preserving order",
            "            columns = groupby or columns",
            "            for selected in columns:",
            "                if isinstance(selected, str):",
            "                    # if groupby field/expr equals granularity field/expr",
            "                    if selected == granularity:",
            "                        table_col = columns_by_name[selected]",
            "                        outer = table_col.get_timestamp_expression(",
            "                            time_grain=time_grain,",
            "                            label=selected,",
            "                            template_processor=template_processor,",
            "                        )",
            "                    # if groupby field equals a selected column",
            "                    elif selected in columns_by_name:",
            "                        outer = columns_by_name[selected].get_sqla_col()",
            "                    else:",
            "                        selected = validate_adhoc_subquery(",
            "                            selected,",
            "                            self.database_id,",
            "                            self.schema,",
            "                        )",
            "                        outer = literal_column(f\"({selected})\")",
            "                        outer = self.make_sqla_column_compatible(outer, selected)",
            "                else:",
            "                    outer = self.adhoc_column_to_sqla(",
            "                        col=selected, template_processor=template_processor",
            "                    )",
            "                groupby_all_columns[outer.name] = outer",
            "                if not series_column_names or outer.name in series_column_names:",
            "                    groupby_series_columns[outer.name] = outer",
            "                select_exprs.append(outer)",
            "        elif columns:",
            "            for selected in columns:",
            "                if is_adhoc_column(selected):",
            "                    _sql = selected[\"sqlExpression\"]",
            "                    _column_label = selected[\"label\"]",
            "                elif isinstance(selected, str):",
            "                    _sql = selected",
            "                    _column_label = selected",
            "",
            "                selected = validate_adhoc_subquery(",
            "                    _sql,",
            "                    self.database_id,",
            "                    self.schema,",
            "                )",
            "                select_exprs.append(",
            "                    columns_by_name[selected].get_sqla_col()",
            "                    if isinstance(selected, str) and selected in columns_by_name",
            "                    else self.make_sqla_column_compatible(",
            "                        literal_column(selected), _column_label",
            "                    )",
            "                )",
            "            metrics_exprs = []",
            "",
            "        time_range_endpoints = extras.get(\"time_range_endpoints\")",
            "",
            "        if granularity:",
            "            if granularity not in columns_by_name or not dttm_col:",
            "                raise QueryObjectValidationError(",
            "                    _(",
            "                        'Time column \"%(col)s\" does not exist in dataset',",
            "                        col=granularity,",
            "                    )",
            "                )",
            "            time_filters = []",
            "",
            "            if is_timeseries:",
            "                timestamp = dttm_col.get_timestamp_expression(",
            "                    time_grain=time_grain, template_processor=template_processor",
            "                )",
            "                # always put timestamp as the first column",
            "                select_exprs.insert(0, timestamp)",
            "                groupby_all_columns[timestamp.name] = timestamp",
            "",
            "            # Use main dttm column to support index with secondary dttm columns.",
            "            if (",
            "                db_engine_spec.time_secondary_columns",
            "                and self.main_dttm_col in self.dttm_cols",
            "                and self.main_dttm_col != dttm_col.column_name",
            "            ):",
            "                time_filters.append(",
            "                    columns_by_name[self.main_dttm_col].get_time_filter(",
            "                        from_dttm,",
            "                        to_dttm,",
            "                        time_range_endpoints,",
            "                    )",
            "                )",
            "            time_filters.append(",
            "                dttm_col.get_time_filter(from_dttm, to_dttm, time_range_endpoints)",
            "            )",
            "",
            "        # Always remove duplicates by column name, as sometimes `metrics_exprs`",
            "        # can have the same name as a groupby column (e.g. when users use",
            "        # raw columns as custom SQL adhoc metric).",
            "        select_exprs = remove_duplicates(",
            "            select_exprs + metrics_exprs, key=lambda x: x.name",
            "        )",
            "",
            "        # Expected output columns",
            "        labels_expected = [c.key for c in select_exprs]",
            "",
            "        # Order by columns are \"hidden\" columns, some databases require them",
            "        # always be present in SELECT if an aggregation function is used",
            "        if not db_engine_spec.allows_hidden_ordeby_agg:",
            "            select_exprs = remove_duplicates(select_exprs + orderby_exprs)",
            "",
            "        qry = sa.select(select_exprs)",
            "",
            "        tbl, cte = self.get_from_clause(template_processor)",
            "",
            "        if groupby_all_columns:",
            "            qry = qry.group_by(*groupby_all_columns.values())",
            "",
            "        where_clause_and = []",
            "        having_clause_and = []",
            "",
            "        for flt in filter:  # type: ignore",
            "            if not all(flt.get(s) for s in [\"col\", \"op\"]):",
            "                continue",
            "            flt_col = flt[\"col\"]",
            "            val = flt.get(\"val\")",
            "            op = flt[\"op\"].upper()",
            "            col_obj: Optional[TableColumn] = None",
            "            sqla_col: Optional[Column] = None",
            "            if flt_col == utils.DTTM_ALIAS and is_timeseries and dttm_col:",
            "                col_obj = dttm_col",
            "            elif is_adhoc_column(flt_col):",
            "                sqla_col = self.adhoc_column_to_sqla(flt_col)",
            "            else:",
            "                col_obj = columns_by_name.get(flt_col)",
            "            filter_grain = flt.get(\"grain\")",
            "",
            "            if is_feature_enabled(\"ENABLE_TEMPLATE_REMOVE_FILTERS\"):",
            "                if get_column_name(flt_col) in removed_filters:",
            "                    # Skip generating SQLA filter when the jinja template handles it.",
            "                    continue",
            "",
            "            if col_obj or sqla_col is not None:",
            "                if sqla_col is not None:",
            "                    pass",
            "                elif col_obj and filter_grain:",
            "                    sqla_col = col_obj.get_timestamp_expression(",
            "                        time_grain=filter_grain, template_processor=template_processor",
            "                    )",
            "                elif col_obj:",
            "                    sqla_col = col_obj.get_sqla_col()",
            "                col_type = col_obj.type if col_obj else None",
            "                col_spec = db_engine_spec.get_column_spec(",
            "                    native_type=col_type,",
            "                    db_extra=self.database.get_extra(),",
            "                )",
            "                is_list_target = op in (",
            "                    utils.FilterOperator.IN.value,",
            "                    utils.FilterOperator.NOT_IN.value,",
            "                )",
            "                if col_spec:",
            "                    target_generic_type = col_spec.generic_type",
            "                else:",
            "                    target_generic_type = GenericDataType.STRING",
            "                eq = self.filter_values_handler(",
            "                    values=val,",
            "                    target_generic_type=target_generic_type,",
            "                    target_native_type=col_type,",
            "                    is_list_target=is_list_target,",
            "                    db_engine_spec=db_engine_spec,",
            "                    db_extra=self.database.get_extra(),",
            "                )",
            "                if is_list_target:",
            "                    assert isinstance(eq, (tuple, list))",
            "                    if len(eq) == 0:",
            "                        raise QueryObjectValidationError(",
            "                            _(\"Filter value list cannot be empty\")",
            "                        )",
            "                    if len(eq) > len(",
            "                        eq_without_none := [x for x in eq if x is not None]",
            "                    ):",
            "                        is_null_cond = sqla_col.is_(None)",
            "                        if eq:",
            "                            cond = or_(is_null_cond, sqla_col.in_(eq_without_none))",
            "                        else:",
            "                            cond = is_null_cond",
            "                    else:",
            "                        cond = sqla_col.in_(eq)",
            "                    if op == utils.FilterOperator.NOT_IN.value:",
            "                        cond = ~cond",
            "                    where_clause_and.append(cond)",
            "                elif op == utils.FilterOperator.IS_NULL.value:",
            "                    where_clause_and.append(sqla_col.is_(None))",
            "                elif op == utils.FilterOperator.IS_NOT_NULL.value:",
            "                    where_clause_and.append(sqla_col.isnot(None))",
            "                elif op == utils.FilterOperator.IS_TRUE.value:",
            "                    where_clause_and.append(sqla_col.is_(True))",
            "                elif op == utils.FilterOperator.IS_FALSE.value:",
            "                    where_clause_and.append(sqla_col.is_(False))",
            "                else:",
            "                    if eq is None:",
            "                        raise QueryObjectValidationError(",
            "                            _(",
            "                                \"Must specify a value for filters \"",
            "                                \"with comparison operators\"",
            "                            )",
            "                        )",
            "                    if op == utils.FilterOperator.EQUALS.value:",
            "                        where_clause_and.append(sqla_col == eq)",
            "                    elif op == utils.FilterOperator.NOT_EQUALS.value:",
            "                        where_clause_and.append(sqla_col != eq)",
            "                    elif op == utils.FilterOperator.GREATER_THAN.value:",
            "                        where_clause_and.append(sqla_col > eq)",
            "                    elif op == utils.FilterOperator.LESS_THAN.value:",
            "                        where_clause_and.append(sqla_col < eq)",
            "                    elif op == utils.FilterOperator.GREATER_THAN_OR_EQUALS.value:",
            "                        where_clause_and.append(sqla_col >= eq)",
            "                    elif op == utils.FilterOperator.LESS_THAN_OR_EQUALS.value:",
            "                        where_clause_and.append(sqla_col <= eq)",
            "                    elif op == utils.FilterOperator.LIKE.value:",
            "                        where_clause_and.append(sqla_col.like(eq))",
            "                    elif op == utils.FilterOperator.ILIKE.value:",
            "                        where_clause_and.append(sqla_col.ilike(eq))",
            "                    else:",
            "                        raise QueryObjectValidationError(",
            "                            _(\"Invalid filter operation type: %(op)s\", op=op)",
            "                        )",
            "        if is_feature_enabled(\"ROW_LEVEL_SECURITY\"):",
            "            where_clause_and += self.get_sqla_row_level_filters(template_processor)",
            "        if extras:",
            "            where = extras.get(\"where\")",
            "            if where:",
            "                try:",
            "                    where = template_processor.process_template(f\"({where})\")",
            "                except TemplateError as ex:",
            "                    raise QueryObjectValidationError(",
            "                        _(",
            "                            \"Error in jinja expression in WHERE clause: %(msg)s\",",
            "                            msg=ex.message,",
            "                        )",
            "                    ) from ex",
            "                where_clause_and += [self.text(where)]",
            "            having = extras.get(\"having\")",
            "            if having:",
            "                try:",
            "                    having = template_processor.process_template(f\"({having})\")",
            "                except TemplateError as ex:",
            "                    raise QueryObjectValidationError(",
            "                        _(",
            "                            \"Error in jinja expression in HAVING clause: %(msg)s\",",
            "                            msg=ex.message,",
            "                        )",
            "                    ) from ex",
            "                having_clause_and += [self.text(having)]",
            "        if apply_fetch_values_predicate and self.fetch_values_predicate:",
            "            qry = qry.where(self.get_fetch_values_predicate())",
            "        if granularity:",
            "            qry = qry.where(and_(*(time_filters + where_clause_and)))",
            "        else:",
            "            qry = qry.where(and_(*where_clause_and))",
            "        qry = qry.having(and_(*having_clause_and))",
            "",
            "        self.make_orderby_compatible(select_exprs, orderby_exprs)",
            "",
            "        for col, (orig_col, ascending) in zip(orderby_exprs, orderby):",
            "            if not db_engine_spec.allows_alias_in_orderby and isinstance(col, Label):",
            "                # if engine does not allow using SELECT alias in ORDER BY",
            "                # revert to the underlying column",
            "                col = col.element",
            "",
            "            if (",
            "                db_engine_spec.allows_alias_in_select",
            "                and db_engine_spec.allows_hidden_cc_in_orderby",
            "                and col.name in [select_col.name for select_col in select_exprs]",
            "            ):",
            "                col = literal_column(col.name)",
            "            direction = asc if ascending else desc",
            "            qry = qry.order_by(direction(col))",
            "",
            "        if row_limit:",
            "            qry = qry.limit(row_limit)",
            "        if row_offset:",
            "            qry = qry.offset(row_offset)",
            "",
            "        if series_limit and groupby_series_columns:",
            "            if db_engine_spec.allows_joins and db_engine_spec.allows_subqueries:",
            "                # some sql dialects require for order by expressions",
            "                # to also be in the select clause -- others, e.g. vertica,",
            "                # require a unique inner alias",
            "                inner_main_metric_expr = self.make_sqla_column_compatible(",
            "                    main_metric_expr, \"mme_inner__\"",
            "                )",
            "                inner_groupby_exprs = []",
            "                inner_select_exprs = []",
            "                for gby_name, gby_obj in groupby_series_columns.items():",
            "                    label = get_column_name(gby_name)",
            "                    inner = self.make_sqla_column_compatible(gby_obj, gby_name + \"__\")",
            "                    inner_groupby_exprs.append(inner)",
            "                    inner_select_exprs.append(inner)",
            "",
            "                inner_select_exprs += [inner_main_metric_expr]",
            "                subq = select(inner_select_exprs).select_from(tbl)",
            "                inner_time_filter = []",
            "",
            "                if dttm_col and not db_engine_spec.time_groupby_inline:",
            "                    inner_time_filter = [",
            "                        dttm_col.get_time_filter(",
            "                            inner_from_dttm or from_dttm,",
            "                            inner_to_dttm or to_dttm,",
            "                            time_range_endpoints,",
            "                        )",
            "                    ]",
            "                subq = subq.where(and_(*(where_clause_and + inner_time_filter)))",
            "                subq = subq.group_by(*inner_groupby_exprs)",
            "",
            "                ob = inner_main_metric_expr",
            "                if series_limit_metric:",
            "                    ob = self._get_series_orderby(",
            "                        series_limit_metric, metrics_by_name, columns_by_name",
            "                    )",
            "                direction = desc if order_desc else asc",
            "                subq = subq.order_by(direction(ob))",
            "                subq = subq.limit(series_limit)",
            "",
            "                on_clause = []",
            "                for gby_name, gby_obj in groupby_series_columns.items():",
            "                    # in this case the column name, not the alias, needs to be",
            "                    # conditionally mutated, as it refers to the column alias in",
            "                    # the inner query",
            "                    col_name = db_engine_spec.make_label_compatible(gby_name + \"__\")",
            "                    on_clause.append(gby_obj == column(col_name))",
            "",
            "                tbl = tbl.join(subq.alias(), and_(*on_clause))",
            "            else:",
            "                if series_limit_metric:",
            "                    orderby = [",
            "                        (",
            "                            self._get_series_orderby(",
            "                                series_limit_metric,",
            "                                metrics_by_name,",
            "                                columns_by_name,",
            "                            ),",
            "                            not order_desc,",
            "                        )",
            "                    ]",
            "",
            "                # run prequery to get top groups",
            "                prequery_obj = {",
            "                    \"is_timeseries\": False,",
            "                    \"row_limit\": series_limit,",
            "                    \"metrics\": metrics,",
            "                    \"granularity\": granularity,",
            "                    \"groupby\": groupby,",
            "                    \"from_dttm\": inner_from_dttm or from_dttm,",
            "                    \"to_dttm\": inner_to_dttm or to_dttm,",
            "                    \"filter\": filter,",
            "                    \"orderby\": orderby,",
            "                    \"extras\": extras,",
            "                    \"columns\": columns,",
            "                    \"order_desc\": True,",
            "                }",
            "",
            "                result = self.query(prequery_obj)",
            "                prequeries.append(result.query)",
            "                dimensions = [",
            "                    c",
            "                    for c in result.df.columns",
            "                    if c not in metrics and c in groupby_series_columns",
            "                ]",
            "                top_groups = self._get_top_groups(",
            "                    result.df, dimensions, groupby_series_columns, columns_by_name",
            "                )",
            "                qry = qry.where(top_groups)",
            "",
            "        qry = qry.select_from(tbl)",
            "",
            "        if is_rowcount:",
            "            if not db_engine_spec.allows_subqueries:",
            "                raise QueryObjectValidationError(",
            "                    _(\"Database does not support subqueries\")",
            "                )",
            "            label = \"rowcount\"",
            "            col = self.make_sqla_column_compatible(literal_column(\"COUNT(*)\"), label)",
            "            qry = select([col]).select_from(qry.alias(\"rowcount_qry\"))",
            "            labels_expected = [label]",
            "",
            "        return SqlaQuery(",
            "            applied_template_filters=applied_template_filters,",
            "            cte=cte,",
            "            extra_cache_keys=extra_cache_keys,",
            "            labels_expected=labels_expected,",
            "            sqla_query=qry,",
            "            prequeries=prequeries,",
            "        )",
            "",
            "    def _get_series_orderby(",
            "        self,",
            "        series_limit_metric: Metric,",
            "        metrics_by_name: Dict[str, SqlMetric],",
            "        columns_by_name: Dict[str, TableColumn],",
            "    ) -> Column:",
            "        if utils.is_adhoc_metric(series_limit_metric):",
            "            assert isinstance(series_limit_metric, dict)",
            "            ob = self.adhoc_metric_to_sqla(series_limit_metric, columns_by_name)",
            "        elif (",
            "            isinstance(series_limit_metric, str)",
            "            and series_limit_metric in metrics_by_name",
            "        ):",
            "            ob = metrics_by_name[series_limit_metric].get_sqla_col()",
            "        else:",
            "            raise QueryObjectValidationError(",
            "                _(\"Metric '%(metric)s' does not exist\", metric=series_limit_metric)",
            "            )",
            "        return ob",
            "",
            "    def _normalize_prequery_result_type(",
            "        self,",
            "        row: pd.Series,",
            "        dimension: str,",
            "        columns_by_name: Dict[str, TableColumn],",
            "    ) -> Union[str, int, float, bool, Text]:",
            "        \"\"\"",
            "        Convert a prequery result type to its equivalent Python type.",
            "",
            "        Some databases like Druid will return timestamps as strings, but do not perform",
            "        automatic casting when comparing these strings to a timestamp. For cases like",
            "        this we convert the value via the appropriate SQL transform.",
            "",
            "        :param row: A prequery record",
            "        :param dimension: The dimension name",
            "        :param columns_by_name: The mapping of columns by name",
            "        :return: equivalent primitive python type",
            "        \"\"\"",
            "",
            "        value = row[dimension]",
            "",
            "        if isinstance(value, np.generic):",
            "            value = value.item()",
            "",
            "        column_ = columns_by_name[dimension]",
            "        db_extra: Dict[str, Any] = self.database.get_extra()",
            "",
            "        if column_.type and column_.is_temporal and isinstance(value, str):",
            "            sql = self.db_engine_spec.convert_dttm(",
            "                column_.type, dateutil.parser.parse(value), db_extra=db_extra",
            "            )",
            "",
            "            if sql:",
            "                value = self.text(sql)",
            "",
            "        return value",
            "",
            "    def _get_top_groups(",
            "        self,",
            "        df: pd.DataFrame,",
            "        dimensions: List[str],",
            "        groupby_exprs: Dict[str, Any],",
            "        columns_by_name: Dict[str, TableColumn],",
            "    ) -> ColumnElement:",
            "        groups = []",
            "        for _unused, row in df.iterrows():",
            "            group = []",
            "            for dimension in dimensions:",
            "                value = self._normalize_prequery_result_type(",
            "                    row,",
            "                    dimension,",
            "                    columns_by_name,",
            "                )",
            "",
            "                group.append(groupby_exprs[dimension] == value)",
            "            groups.append(and_(*group))",
            "",
            "        return or_(*groups)",
            "",
            "    def query(self, query_obj: QueryObjectDict) -> QueryResult:",
            "        qry_start_dttm = datetime.now()",
            "        query_str_ext = self.get_query_str_extended(query_obj)",
            "        sql = query_str_ext.sql",
            "        status = QueryStatus.SUCCESS",
            "        errors = None",
            "        error_message = None",
            "",
            "        def assign_column_label(df: pd.DataFrame) -> Optional[pd.DataFrame]:",
            "            \"\"\"",
            "            Some engines change the case or generate bespoke column names, either by",
            "            default or due to lack of support for aliasing. This function ensures that",
            "            the column names in the DataFrame correspond to what is expected by",
            "            the viz components.",
            "",
            "            Sometimes a query may also contain only order by columns that are not used",
            "            as metrics or groupby columns, but need to present in the SQL `select`,",
            "            filtering by `labels_expected` make sure we only return columns users want.",
            "",
            "            :param df: Original DataFrame returned by the engine",
            "            :return: Mutated DataFrame",
            "            \"\"\"",
            "            labels_expected = query_str_ext.labels_expected",
            "            if df is not None and not df.empty:",
            "                if len(df.columns) < len(labels_expected):",
            "                    raise QueryObjectValidationError(",
            "                        _(\"Db engine did not return all queried columns\")",
            "                    )",
            "                if len(df.columns) > len(labels_expected):",
            "                    df = df.iloc[:, 0 : len(labels_expected)]",
            "                df.columns = labels_expected",
            "            return df",
            "",
            "        try:",
            "            df = self.database.get_df(sql, self.schema, mutator=assign_column_label)",
            "        except Exception as ex:  # pylint: disable=broad-except",
            "            df = pd.DataFrame()",
            "            status = QueryStatus.FAILED",
            "            logger.warning(",
            "                \"Query %s on schema %s failed\", sql, self.schema, exc_info=True",
            "            )",
            "            db_engine_spec = self.db_engine_spec",
            "            errors = [",
            "                dataclasses.asdict(error) for error in db_engine_spec.extract_errors(ex)",
            "            ]",
            "            error_message = utils.error_msg_from_exception(ex)",
            "",
            "        return QueryResult(",
            "            applied_template_filters=query_str_ext.applied_template_filters,",
            "            status=status,",
            "            df=df,",
            "            duration=datetime.now() - qry_start_dttm,",
            "            query=sql,",
            "            errors=errors,",
            "            error_message=error_message,",
            "        )",
            "",
            "    def get_sqla_table_object(self) -> Table:",
            "        return self.database.get_table(self.table_name, schema=self.schema)",
            "",
            "    def fetch_metadata(self, commit: bool = True) -> MetadataResult:",
            "        \"\"\"",
            "        Fetches the metadata for the table and merges it in",
            "",
            "        :param commit: should the changes be committed or not.",
            "        :return: Tuple with lists of added, removed and modified column names.",
            "        \"\"\"",
            "        new_columns = self.external_metadata()",
            "        metrics = []",
            "        any_date_col = None",
            "        db_engine_spec = self.db_engine_spec",
            "        old_columns = db.session.query(TableColumn).filter(TableColumn.table == self)",
            "",
            "        old_columns_by_name: Dict[str, TableColumn] = {",
            "            col.column_name: col for col in old_columns",
            "        }",
            "        results = MetadataResult(",
            "            removed=[",
            "                col",
            "                for col in old_columns_by_name",
            "                if col not in {col[\"name\"] for col in new_columns}",
            "            ]",
            "        )",
            "",
            "        # clear old columns before adding modified columns back",
            "        self.columns = []",
            "        for col in new_columns:",
            "            old_column = old_columns_by_name.pop(col[\"name\"], None)",
            "            if not old_column:",
            "                results.added.append(col[\"name\"])",
            "                new_column = TableColumn(",
            "                    column_name=col[\"name\"], type=col[\"type\"], table=self",
            "                )",
            "                new_column.is_dttm = new_column.is_temporal",
            "                db_engine_spec.alter_new_orm_column(new_column)",
            "            else:",
            "                new_column = old_column",
            "                if new_column.type != col[\"type\"]:",
            "                    results.modified.append(col[\"name\"])",
            "                new_column.type = col[\"type\"]",
            "                new_column.expression = \"\"",
            "            new_column.groupby = True",
            "            new_column.filterable = True",
            "            self.columns.append(new_column)",
            "            if not any_date_col and new_column.is_temporal:",
            "                any_date_col = col[\"name\"]",
            "        self.columns.extend(",
            "            [col for col in old_columns_by_name.values() if col.expression]",
            "        )",
            "        metrics.append(",
            "            SqlMetric(",
            "                metric_name=\"count\",",
            "                verbose_name=\"COUNT(*)\",",
            "                metric_type=\"count\",",
            "                expression=\"COUNT(*)\",",
            "            )",
            "        )",
            "        if not self.main_dttm_col:",
            "            self.main_dttm_col = any_date_col",
            "        self.add_missing_metrics(metrics)",
            "",
            "        # Apply config supplied mutations.",
            "        config[\"SQLA_TABLE_MUTATOR\"](self)",
            "",
            "        db.session.merge(self)",
            "        if commit:",
            "            db.session.commit()",
            "        return results",
            "",
            "    @classmethod",
            "    def query_datasources_by_name(",
            "        cls,",
            "        session: Session,",
            "        database: Database,",
            "        datasource_name: str,",
            "        schema: Optional[str] = None,",
            "    ) -> List[\"SqlaTable\"]:",
            "        query = (",
            "            session.query(cls)",
            "            .filter_by(database_id=database.id)",
            "            .filter_by(table_name=datasource_name)",
            "        )",
            "        if schema:",
            "            query = query.filter_by(schema=schema)",
            "        return query.all()",
            "",
            "    @staticmethod",
            "    def default_query(qry: Query) -> Query:",
            "        return qry.filter_by(is_sqllab_view=False)",
            "",
            "    def has_extra_cache_key_calls(self, query_obj: QueryObjectDict) -> bool:",
            "        \"\"\"",
            "        Detects the presence of calls to `ExtraCache` methods in items in query_obj that",
            "        can be templated. If any are present, the query must be evaluated to extract",
            "        additional keys for the cache key. This method is needed to avoid executing the",
            "        template code unnecessarily, as it may contain expensive calls, e.g. to extract",
            "        the latest partition of a database.",
            "",
            "        :param query_obj: query object to analyze",
            "        :return: True if there are call(s) to an `ExtraCache` method, False otherwise",
            "        \"\"\"",
            "        templatable_statements: List[str] = []",
            "        if self.sql:",
            "            templatable_statements.append(self.sql)",
            "        if self.fetch_values_predicate:",
            "            templatable_statements.append(self.fetch_values_predicate)",
            "        extras = query_obj.get(\"extras\", {})",
            "        if \"where\" in extras:",
            "            templatable_statements.append(extras[\"where\"])",
            "        if \"having\" in extras:",
            "            templatable_statements.append(extras[\"having\"])",
            "        if is_feature_enabled(\"ROW_LEVEL_SECURITY\") and self.is_rls_supported:",
            "            templatable_statements += [",
            "                f.clause for f in security_manager.get_rls_filters(self)",
            "            ]",
            "        for statement in templatable_statements:",
            "            if ExtraCache.regex.search(statement):",
            "                return True",
            "        return False",
            "",
            "    def get_extra_cache_keys(self, query_obj: QueryObjectDict) -> List[Hashable]:",
            "        \"\"\"",
            "        The cache key of a SqlaTable needs to consider any keys added by the parent",
            "        class and any keys added via `ExtraCache`.",
            "",
            "        :param query_obj: query object to analyze",
            "        :return: The extra cache keys",
            "        \"\"\"",
            "        extra_cache_keys = super().get_extra_cache_keys(query_obj)",
            "        if self.has_extra_cache_key_calls(query_obj):",
            "            sqla_query = self.get_sqla_query(**query_obj)",
            "            extra_cache_keys += sqla_query.extra_cache_keys",
            "        return extra_cache_keys",
            "",
            "    @staticmethod",
            "    def before_update(",
            "        mapper: Mapper,  # pylint: disable=unused-argument",
            "        connection: Connection,  # pylint: disable=unused-argument",
            "        target: \"SqlaTable\",",
            "    ) -> None:",
            "        \"\"\"",
            "        Check before update if the target table already exists.",
            "",
            "        Note this listener is called when any fields are being updated and thus it is",
            "        necessary to first check whether the reference table is being updated.",
            "",
            "        Note this logic is temporary, given uniqueness is handled via the dataset DAO,",
            "        but is necessary until both the legacy datasource editor and datasource/save",
            "        endpoints are deprecated.",
            "",
            "        :param mapper: The table mapper",
            "        :param connection: The DB-API connection",
            "        :param target: The mapped instance being persisted",
            "        :raises Exception: If the target table is not unique",
            "        \"\"\"",
            "",
            "        # pylint: disable=import-outside-toplevel",
            "        from superset.datasets.commands.exceptions import get_dataset_exist_error_msg",
            "        from superset.datasets.dao import DatasetDAO",
            "",
            "        # Check whether the relevant attributes have changed.",
            "        state = db.inspect(target)  # pylint: disable=no-member",
            "",
            "        for attr in [\"database_id\", \"schema\", \"table_name\"]:",
            "            history = state.get_history(attr, True)",
            "            if history.has_changes():",
            "                break",
            "        else:",
            "            return None",
            "",
            "        if not DatasetDAO.validate_uniqueness(",
            "            target.database_id, target.schema, target.table_name, target.id",
            "        ):",
            "            raise Exception(get_dataset_exist_error_msg(target.full_name))",
            "",
            "    @staticmethod",
            "    def update_table(  # pylint: disable=unused-argument",
            "        mapper: Mapper, connection: Connection, target: Union[SqlMetric, TableColumn]",
            "    ) -> None:",
            "        \"\"\"",
            "        Forces an update to the table's changed_on value when a metric or column on the",
            "        table is updated. This busts the cache key for all charts that use the table.",
            "",
            "        :param mapper: Unused.",
            "        :param connection: Unused.",
            "        :param target: The metric or column that was updated.",
            "        \"\"\"",
            "        inspector = inspect(target)",
            "        session = inspector.session",
            "        session.execute(update(SqlaTable).where(SqlaTable.id == target.table.id))",
            "",
            "",
            "sa.event.listen(SqlaTable, \"after_insert\", security_manager.set_perm)",
            "sa.event.listen(SqlaTable, \"after_update\", security_manager.set_perm)",
            "sa.event.listen(SqlaTable, \"before_update\", SqlaTable.before_update)",
            "sa.event.listen(SqlMetric, \"after_update\", SqlaTable.update_table)",
            "sa.event.listen(TableColumn, \"after_update\", SqlaTable.update_table)",
            "",
            "RLSFilterRoles = Table(",
            "    \"rls_filter_roles\",",
            "    metadata,",
            "    Column(\"id\", Integer, primary_key=True),",
            "    Column(\"role_id\", Integer, ForeignKey(\"ab_role.id\"), nullable=False),",
            "    Column(\"rls_filter_id\", Integer, ForeignKey(\"row_level_security_filters.id\")),",
            ")",
            "",
            "RLSFilterTables = Table(",
            "    \"rls_filter_tables\",",
            "    metadata,",
            "    Column(\"id\", Integer, primary_key=True),",
            "    Column(\"table_id\", Integer, ForeignKey(\"tables.id\")),",
            "    Column(\"rls_filter_id\", Integer, ForeignKey(\"row_level_security_filters.id\")),",
            ")",
            "",
            "",
            "class RowLevelSecurityFilter(Model, AuditMixinNullable):",
            "    \"\"\"",
            "    Custom where clauses attached to Tables and Roles.",
            "    \"\"\"",
            "",
            "    __tablename__ = \"row_level_security_filters\"",
            "    id = Column(Integer, primary_key=True)",
            "    filter_type = Column(",
            "        Enum(*[filter_type.value for filter_type in utils.RowLevelSecurityFilterType])",
            "    )",
            "    group_key = Column(String(255), nullable=True)",
            "    roles = relationship(",
            "        security_manager.role_model,",
            "        secondary=RLSFilterRoles,",
            "        backref=\"row_level_security_filters\",",
            "    )",
            "    tables = relationship(",
            "        SqlaTable, secondary=RLSFilterTables, backref=\"row_level_security_filters\"",
            "    )",
            "",
            "    clause = Column(Text, nullable=False)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1070": [
                "SqlaTable",
                "get_sqla_query"
            ],
            "1265": [
                "SqlaTable",
                "get_sqla_query"
            ],
            "1271": [
                "SqlaTable",
                "get_sqla_query"
            ],
            "1272": [
                "SqlaTable",
                "get_sqla_query"
            ]
        },
        "addLocation": []
    },
    "superset/superset_typing.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 53,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " class AdhocColumn(TypedDict, total=False):"
            },
            "2": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "     hasCustomLabel: Optional[bool]"
            },
            "3": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    label: Optional[str]"
            },
            "4": {
                "beforePatchRowNumber": 57,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    sqlExpression: Optional[str]"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+    label: str"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+    sqlExpression: str"
            },
            "7": {
                "beforePatchRowNumber": 58,
                "afterPatchRowNumber": 58,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 59,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 60,
                "PatchRowcode": " class ResultSetColumnType(TypedDict):"
            }
        },
        "frontPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from datetime import datetime",
            "from typing import Any, Dict, List, Optional, Sequence, Tuple, TYPE_CHECKING, Union",
            "",
            "from typing_extensions import Literal, TypedDict",
            "from werkzeug.wrappers import Response",
            "",
            "if TYPE_CHECKING:",
            "    from superset.utils.core import GenericDataType",
            "",
            "",
            "class LegacyMetric(TypedDict):",
            "    label: Optional[str]",
            "",
            "",
            "class AdhocMetricColumn(TypedDict, total=False):",
            "    column_name: Optional[str]",
            "    description: Optional[str]",
            "    expression: Optional[str]",
            "    filterable: bool",
            "    groupby: bool",
            "    id: int",
            "    is_dttm: bool",
            "    python_date_format: Optional[str]",
            "    type: str",
            "    type_generic: \"GenericDataType\"",
            "    verbose_name: Optional[str]",
            "",
            "",
            "class AdhocMetric(TypedDict, total=False):",
            "    aggregate: str",
            "    column: Optional[AdhocMetricColumn]",
            "    expressionType: Literal[\"SIMPLE\", \"SQL\"]",
            "    hasCustomLabel: Optional[bool]",
            "    label: Optional[str]",
            "    sqlExpression: Optional[str]",
            "",
            "",
            "class AdhocColumn(TypedDict, total=False):",
            "    hasCustomLabel: Optional[bool]",
            "    label: Optional[str]",
            "    sqlExpression: Optional[str]",
            "",
            "",
            "class ResultSetColumnType(TypedDict):",
            "    \"\"\"",
            "    Superset virtual dataset column interface",
            "    \"\"\"",
            "",
            "    name: str",
            "    type: Optional[str]",
            "    is_dttm: bool",
            "",
            "",
            "CacheConfig = Dict[str, Any]",
            "DbapiDescriptionRow = Tuple[",
            "    str, str, Optional[str], Optional[str], Optional[int], Optional[int], bool",
            "]",
            "DbapiDescription = Union[List[DbapiDescriptionRow], Tuple[DbapiDescriptionRow, ...]]",
            "DbapiResult = Sequence[Union[List[Any], Tuple[Any, ...]]]",
            "FilterValue = Union[bool, datetime, float, int, str]",
            "FilterValues = Union[FilterValue, List[FilterValue], Tuple[FilterValue]]",
            "FormData = Dict[str, Any]",
            "Granularity = Union[str, Dict[str, Union[str, float]]]",
            "Column = Union[AdhocColumn, str]",
            "Metric = Union[AdhocMetric, str]",
            "OrderBy = Tuple[Metric, bool]",
            "QueryObjectDict = Dict[str, Any]",
            "VizData = Optional[Union[List[Any], Dict[Any, Any]]]",
            "VizPayload = Dict[str, Any]",
            "",
            "# Flask response.",
            "Base = Union[bytes, str]",
            "Status = Union[int, str]",
            "Headers = Dict[str, Any]",
            "FlaskResponse = Union[",
            "    Response,",
            "    Base,",
            "    Tuple[Base, Status],",
            "    Tuple[Base, Status, Headers],",
            "    Tuple[Response, Status],",
            "]"
        ],
        "afterPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "from datetime import datetime",
            "from typing import Any, Dict, List, Optional, Sequence, Tuple, TYPE_CHECKING, Union",
            "",
            "from typing_extensions import Literal, TypedDict",
            "from werkzeug.wrappers import Response",
            "",
            "if TYPE_CHECKING:",
            "    from superset.utils.core import GenericDataType",
            "",
            "",
            "class LegacyMetric(TypedDict):",
            "    label: Optional[str]",
            "",
            "",
            "class AdhocMetricColumn(TypedDict, total=False):",
            "    column_name: Optional[str]",
            "    description: Optional[str]",
            "    expression: Optional[str]",
            "    filterable: bool",
            "    groupby: bool",
            "    id: int",
            "    is_dttm: bool",
            "    python_date_format: Optional[str]",
            "    type: str",
            "    type_generic: \"GenericDataType\"",
            "    verbose_name: Optional[str]",
            "",
            "",
            "class AdhocMetric(TypedDict, total=False):",
            "    aggregate: str",
            "    column: Optional[AdhocMetricColumn]",
            "    expressionType: Literal[\"SIMPLE\", \"SQL\"]",
            "    hasCustomLabel: Optional[bool]",
            "    label: Optional[str]",
            "    sqlExpression: Optional[str]",
            "",
            "",
            "class AdhocColumn(TypedDict, total=False):",
            "    hasCustomLabel: Optional[bool]",
            "    label: str",
            "    sqlExpression: str",
            "",
            "",
            "class ResultSetColumnType(TypedDict):",
            "    \"\"\"",
            "    Superset virtual dataset column interface",
            "    \"\"\"",
            "",
            "    name: str",
            "    type: Optional[str]",
            "    is_dttm: bool",
            "",
            "",
            "CacheConfig = Dict[str, Any]",
            "DbapiDescriptionRow = Tuple[",
            "    str, str, Optional[str], Optional[str], Optional[int], Optional[int], bool",
            "]",
            "DbapiDescription = Union[List[DbapiDescriptionRow], Tuple[DbapiDescriptionRow, ...]]",
            "DbapiResult = Sequence[Union[List[Any], Tuple[Any, ...]]]",
            "FilterValue = Union[bool, datetime, float, int, str]",
            "FilterValues = Union[FilterValue, List[FilterValue], Tuple[FilterValue]]",
            "FormData = Dict[str, Any]",
            "Granularity = Union[str, Dict[str, Union[str, float]]]",
            "Column = Union[AdhocColumn, str]",
            "Metric = Union[AdhocMetric, str]",
            "OrderBy = Tuple[Metric, bool]",
            "QueryObjectDict = Dict[str, Any]",
            "VizData = Optional[Union[List[Any], Dict[Any, Any]]]",
            "VizPayload = Dict[str, Any]",
            "",
            "# Flask response.",
            "Base = Union[bytes, str]",
            "Status = Union[int, str]",
            "Headers = Dict[str, Any]",
            "FlaskResponse = Union[",
            "    Response,",
            "    Base,",
            "    Tuple[Base, Status],",
            "    Tuple[Base, Status, Headers],",
            "    Tuple[Response, Status],",
            "]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "56": [
                "AdhocColumn"
            ],
            "57": [
                "AdhocColumn"
            ]
        },
        "addLocation": []
    },
    "superset/utils/core.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 1247,
                "afterPatchRowNumber": 1247,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 1248,
                "afterPatchRowNumber": 1248,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 1249,
                "afterPatchRowNumber": 1249,
                "PatchRowcode": " def is_adhoc_column(column: Column) -> TypeGuard[AdhocColumn]:"
            },
            "3": {
                "beforePatchRowNumber": 1250,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    return isinstance(column, dict)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1250,
                "PatchRowcode": "+    return isinstance(column, dict) and ({\"label\", \"sqlExpression\"}).issubset("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1251,
                "PatchRowcode": "+        column.keys()"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 1252,
                "PatchRowcode": "+    )"
            },
            "7": {
                "beforePatchRowNumber": 1251,
                "afterPatchRowNumber": 1253,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 1252,
                "afterPatchRowNumber": 1254,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 1253,
                "afterPatchRowNumber": 1255,
                "PatchRowcode": " def get_column_name("
            }
        },
        "frontPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "\"\"\"Utility functions used across Superset\"\"\"",
            "# pylint: disable=too-many-lines",
            "import _thread",
            "import collections",
            "import decimal",
            "import errno",
            "import json",
            "import logging",
            "import os",
            "import platform",
            "import re",
            "import signal",
            "import smtplib",
            "import ssl",
            "import tempfile",
            "import threading",
            "import traceback",
            "import uuid",
            "import zlib",
            "from datetime import date, datetime, time, timedelta",
            "from distutils.util import strtobool",
            "from email.mime.application import MIMEApplication",
            "from email.mime.image import MIMEImage",
            "from email.mime.multipart import MIMEMultipart",
            "from email.mime.text import MIMEText",
            "from email.utils import formatdate",
            "from enum import Enum, IntEnum",
            "from io import BytesIO",
            "from timeit import default_timer",
            "from types import TracebackType",
            "from typing import (",
            "    Any,",
            "    Callable,",
            "    cast,",
            "    Dict,",
            "    Iterable,",
            "    Iterator,",
            "    List,",
            "    NamedTuple,",
            "    Optional,",
            "    Sequence,",
            "    Set,",
            "    Tuple,",
            "    Type,",
            "    TYPE_CHECKING,",
            "    TypeVar,",
            "    Union,",
            ")",
            "from urllib.parse import unquote_plus",
            "from zipfile import ZipFile",
            "",
            "import bleach",
            "import markdown as md",
            "import numpy as np",
            "import pandas as pd",
            "import sqlalchemy as sa",
            "from cryptography import x509",
            "from cryptography.hazmat.backends import default_backend",
            "from cryptography.hazmat.backends.openssl.x509 import _Certificate",
            "from flask import current_app, flash, g, Markup, render_template, request",
            "from flask_appbuilder import SQLA",
            "from flask_appbuilder.security.sqla.models import Role, User",
            "from flask_babel import gettext as __",
            "from flask_babel.speaklater import LazyString",
            "from pandas.api.types import infer_dtype",
            "from pandas.core.dtypes.common import is_numeric_dtype",
            "from sqlalchemy import event, exc, inspect, select, Text",
            "from sqlalchemy.dialects.mysql import MEDIUMTEXT",
            "from sqlalchemy.engine import Connection, Engine",
            "from sqlalchemy.engine.reflection import Inspector",
            "from sqlalchemy.sql.type_api import Variant",
            "from sqlalchemy.types import TEXT, TypeDecorator, TypeEngine",
            "from typing_extensions import TypedDict, TypeGuard",
            "",
            "from superset.constants import (",
            "    EXTRA_FORM_DATA_APPEND_KEYS,",
            "    EXTRA_FORM_DATA_OVERRIDE_EXTRA_KEYS,",
            "    EXTRA_FORM_DATA_OVERRIDE_REGULAR_MAPPINGS,",
            ")",
            "from superset.errors import ErrorLevel, SupersetErrorType",
            "from superset.exceptions import (",
            "    CertificateException,",
            "    SupersetException,",
            "    SupersetTimeoutException,",
            ")",
            "from superset.sql_parse import sanitize_clause",
            "from superset.superset_typing import (",
            "    AdhocColumn,",
            "    AdhocMetric,",
            "    AdhocMetricColumn,",
            "    Column,",
            "    FilterValues,",
            "    FlaskResponse,",
            "    FormData,",
            "    Metric,",
            ")",
            "from superset.utils.database import get_example_database",
            "from superset.utils.dates import datetime_to_epoch, EPOCH",
            "from superset.utils.hashing import md5_sha_from_dict, md5_sha_from_str",
            "",
            "try:",
            "    from pydruid.utils.having import Having",
            "except ImportError:",
            "    pass",
            "",
            "if TYPE_CHECKING:",
            "    from superset.connectors.base.models import BaseColumn, BaseDatasource",
            "",
            "logging.getLogger(\"MARKDOWN\").setLevel(logging.INFO)",
            "logger = logging.getLogger(__name__)",
            "",
            "DTTM_ALIAS = \"__timestamp\"",
            "",
            "NO_TIME_RANGE = \"No filter\"",
            "",
            "TIME_COMPARISION = \"__\"",
            "",
            "JS_MAX_INTEGER = 9007199254740991  # Largest int Java Script can handle 2^53-1",
            "",
            "InputType = TypeVar(\"InputType\")",
            "",
            "",
            "class LenientEnum(Enum):",
            "    \"\"\"Enums with a `get` method that convert a enum value to `Enum` if it is a",
            "    valid value.\"\"\"",
            "",
            "    @classmethod",
            "    def get(cls, value: Any) -> Any:",
            "        try:",
            "            return super().__new__(cls, value)",
            "        except ValueError:",
            "            return None",
            "",
            "",
            "class AdhocMetricExpressionType(str, Enum):",
            "    SIMPLE = \"SIMPLE\"",
            "    SQL = \"SQL\"",
            "",
            "",
            "class AnnotationType(str, Enum):",
            "    FORMULA = \"FORMULA\"",
            "    INTERVAL = \"INTERVAL\"",
            "    EVENT = \"EVENT\"",
            "    TIME_SERIES = \"TIME_SERIES\"",
            "",
            "",
            "class GenericDataType(IntEnum):",
            "    \"\"\"",
            "    Generic database column type that fits both frontend and backend.",
            "    \"\"\"",
            "",
            "    NUMERIC = 0",
            "    STRING = 1",
            "    TEMPORAL = 2",
            "    BOOLEAN = 3",
            "    # ARRAY = 4     # Mapping all the complex data types to STRING for now",
            "    # JSON = 5      # and leaving these as a reminder.",
            "    # MAP = 6",
            "    # ROW = 7",
            "",
            "",
            "class DatasourceType(str, Enum):",
            "    SLTABLE = \"sl_table\"",
            "    TABLE = \"table\"",
            "    DATASET = \"dataset\"",
            "    QUERY = \"query\"",
            "    SAVEDQUERY = \"saved_query\"",
            "    VIEW = \"view\"",
            "",
            "",
            "class DatasourceDict(TypedDict):",
            "    type: str",
            "    id: int",
            "",
            "",
            "class AdhocFilterClause(TypedDict, total=False):",
            "    clause: str",
            "    expressionType: str",
            "    filterOptionName: Optional[str]",
            "    comparator: Optional[FilterValues]",
            "    operator: str",
            "    subject: str",
            "    isExtra: Optional[bool]",
            "    sqlExpression: Optional[str]",
            "",
            "",
            "class QueryObjectFilterClause(TypedDict, total=False):",
            "    col: str",
            "    op: str  # pylint: disable=invalid-name",
            "    val: Optional[FilterValues]",
            "    grain: Optional[str]",
            "    isExtra: Optional[bool]",
            "",
            "",
            "class ExtraFiltersTimeColumnType(str, Enum):",
            "    GRANULARITY = \"__granularity\"",
            "    TIME_COL = \"__time_col\"",
            "    TIME_GRAIN = \"__time_grain\"",
            "    TIME_ORIGIN = \"__time_origin\"",
            "    TIME_RANGE = \"__time_range\"",
            "",
            "",
            "class ExtraFiltersReasonType(str, Enum):",
            "    NO_TEMPORAL_COLUMN = \"no_temporal_column\"",
            "    COL_NOT_IN_DATASOURCE = \"not_in_datasource\"",
            "    NOT_DRUID_DATASOURCE = \"not_druid_datasource\"",
            "",
            "",
            "class FilterOperator(str, Enum):",
            "    \"\"\"",
            "    Operators used filter controls",
            "    \"\"\"",
            "",
            "    EQUALS = \"==\"",
            "    NOT_EQUALS = \"!=\"",
            "    GREATER_THAN = \">\"",
            "    LESS_THAN = \"<\"",
            "    GREATER_THAN_OR_EQUALS = \">=\"",
            "    LESS_THAN_OR_EQUALS = \"<=\"",
            "    LIKE = \"LIKE\"",
            "    ILIKE = \"ILIKE\"",
            "    IS_NULL = \"IS NULL\"",
            "    IS_NOT_NULL = \"IS NOT NULL\"",
            "    IN = \"IN\"",
            "    NOT_IN = \"NOT IN\"",
            "    REGEX = \"REGEX\"",
            "    IS_TRUE = \"IS TRUE\"",
            "    IS_FALSE = \"IS FALSE\"",
            "",
            "",
            "class PostProcessingBoxplotWhiskerType(str, Enum):",
            "    \"\"\"",
            "    Calculate cell contribution to row/column total",
            "    \"\"\"",
            "",
            "    TUKEY = \"tukey\"",
            "    MINMAX = \"min/max\"",
            "    PERCENTILE = \"percentile\"",
            "",
            "",
            "class PostProcessingContributionOrientation(str, Enum):",
            "    \"\"\"",
            "    Calculate cell contribution to row/column total",
            "    \"\"\"",
            "",
            "    ROW = \"row\"",
            "    COLUMN = \"column\"",
            "",
            "",
            "class QueryMode(str, LenientEnum):",
            "    \"\"\"",
            "    Whether the query runs on aggregate or returns raw records",
            "    \"\"\"",
            "",
            "    RAW = \"raw\"",
            "    AGGREGATE = \"aggregate\"",
            "",
            "",
            "class QuerySource(Enum):",
            "    \"\"\"",
            "    The source of a SQL query.",
            "    \"\"\"",
            "",
            "    CHART = 0",
            "    DASHBOARD = 1",
            "    SQL_LAB = 2",
            "",
            "",
            "class QueryStatus(str, Enum):",
            "    \"\"\"Enum-type class for query statuses\"\"\"",
            "",
            "    STOPPED: str = \"stopped\"",
            "    FAILED: str = \"failed\"",
            "    PENDING: str = \"pending\"",
            "    RUNNING: str = \"running\"",
            "    SCHEDULED: str = \"scheduled\"",
            "    SUCCESS: str = \"success\"",
            "    FETCHING: str = \"fetching\"",
            "    TIMED_OUT: str = \"timed_out\"",
            "",
            "",
            "class DashboardStatus(str, Enum):",
            "    \"\"\"Dashboard status used for frontend filters\"\"\"",
            "",
            "    PUBLISHED = \"published\"",
            "    DRAFT = \"draft\"",
            "",
            "",
            "class ReservedUrlParameters(str, Enum):",
            "    \"\"\"",
            "    Reserved URL parameters that are used internally by Superset. These will not be",
            "    passed to chart queries, as they control the behavior of the UI.",
            "    \"\"\"",
            "",
            "    STANDALONE = \"standalone\"",
            "    EDIT_MODE = \"edit\"",
            "",
            "    @staticmethod",
            "    def is_standalone_mode() -> Optional[bool]:",
            "        standalone_param = request.args.get(ReservedUrlParameters.STANDALONE.value)",
            "        standalone: Optional[bool] = bool(",
            "            standalone_param and standalone_param != \"false\" and standalone_param != \"0\"",
            "        )",
            "        return standalone",
            "",
            "",
            "class RowLevelSecurityFilterType(str, Enum):",
            "    REGULAR = \"Regular\"",
            "    BASE = \"Base\"",
            "",
            "",
            "class TimeRangeEndpoint(str, Enum):",
            "    \"\"\"",
            "    The time range endpoint types which represent inclusive, exclusive, or unknown.",
            "",
            "    Unknown represents endpoints which are ill-defined as though the interval may be",
            "    [start, end] the filter may behave like (start, end] due to mixed data types and",
            "    lexicographical ordering.",
            "",
            "    :see: https://github.com/apache/superset/issues/6360",
            "    \"\"\"",
            "",
            "    EXCLUSIVE = \"exclusive\"",
            "    INCLUSIVE = \"inclusive\"",
            "    UNKNOWN = \"unknown\"",
            "",
            "",
            "class TemporalType(str, Enum):",
            "    \"\"\"",
            "    Supported temporal types",
            "    \"\"\"",
            "",
            "    DATE = \"DATE\"",
            "    DATETIME = \"DATETIME\"",
            "    SMALLDATETIME = \"SMALLDATETIME\"",
            "    TEXT = \"TEXT\"",
            "    TIME = \"TIME\"",
            "    TIME_WITH_TIME_ZONE = \"TIME WITH TIME ZONE\"",
            "    TIMESTAMP = \"TIMESTAMP\"",
            "    TIMESTAMP_WITH_TIME_ZONE = \"TIMESTAMP WITH TIME ZONE\"",
            "",
            "",
            "class ColumnTypeSource(Enum):",
            "    GET_TABLE = 1",
            "    CURSOR_DESCRIPION = 2",
            "",
            "",
            "class ColumnSpec(NamedTuple):",
            "    sqla_type: Union[TypeEngine, str]",
            "    generic_type: GenericDataType",
            "    is_dttm: bool",
            "    python_date_format: Optional[str] = None",
            "",
            "",
            "try:",
            "    # Having might not have been imported.",
            "    class DimSelector(Having):",
            "        def __init__(self, **args: Any) -> None:",
            "            # Just a hack to prevent any exceptions",
            "            Having.__init__(self, type=\"equalTo\", aggregation=None, value=None)",
            "",
            "            self.having = {",
            "                \"having\": {",
            "                    \"type\": \"dimSelector\",",
            "                    \"dimension\": args[\"dimension\"],",
            "                    \"value\": args[\"value\"],",
            "                }",
            "            }",
            "",
            "except NameError:",
            "    pass",
            "",
            "",
            "def flasher(msg: str, severity: str = \"message\") -> None:",
            "    \"\"\"Flask's flash if available, logging call if not\"\"\"",
            "    try:",
            "        flash(msg, severity)",
            "    except RuntimeError:",
            "        if severity == \"danger\":",
            "            logger.error(msg, exc_info=True)",
            "        else:",
            "            logger.info(msg)",
            "",
            "",
            "def parse_js_uri_path_item(",
            "    item: Optional[str], unquote: bool = True, eval_undefined: bool = False",
            ") -> Optional[str]:",
            "    \"\"\"Parse a uri path item made with js.",
            "",
            "    :param item: a uri path component",
            "    :param unquote: Perform unquoting of string using urllib.parse.unquote_plus()",
            "    :param eval_undefined: When set to True and item is either 'null'  or 'undefined',",
            "    assume item is undefined and return None.",
            "    :return: Either None, the original item or unquoted item",
            "    \"\"\"",
            "    item = None if eval_undefined and item in (\"null\", \"undefined\") else item",
            "    return unquote_plus(item) if unquote and item else item",
            "",
            "",
            "def cast_to_num(value: Optional[Union[float, int, str]]) -> Optional[Union[float, int]]:",
            "    \"\"\"Casts a value to an int/float",
            "",
            "    >>> cast_to_num('1 ')",
            "    1.0",
            "    >>> cast_to_num(' 2')",
            "    2.0",
            "    >>> cast_to_num('5')",
            "    5",
            "    >>> cast_to_num('5.2')",
            "    5.2",
            "    >>> cast_to_num(10)",
            "    10",
            "    >>> cast_to_num(10.1)",
            "    10.1",
            "    >>> cast_to_num(None) is None",
            "    True",
            "    >>> cast_to_num('this is not a string') is None",
            "    True",
            "",
            "    :param value: value to be converted to numeric representation",
            "    :returns: value cast to `int` if value is all digits, `float` if `value` is",
            "              decimal value and `None`` if it can't be converted",
            "    \"\"\"",
            "    if value is None:",
            "        return None",
            "    if isinstance(value, (int, float)):",
            "        return value",
            "    if value.isdigit():",
            "        return int(value)",
            "    try:",
            "        return float(value)",
            "    except ValueError:",
            "        return None",
            "",
            "",
            "def cast_to_boolean(value: Any) -> Optional[bool]:",
            "    \"\"\"Casts a value to an int/float",
            "",
            "    >>> cast_to_boolean(1)",
            "    True",
            "    >>> cast_to_boolean(0)",
            "    False",
            "    >>> cast_to_boolean(0.5)",
            "    True",
            "    >>> cast_to_boolean('true')",
            "    True",
            "    >>> cast_to_boolean('false')",
            "    False",
            "    >>> cast_to_boolean('False')",
            "    False",
            "    >>> cast_to_boolean(None)",
            "",
            "    :param value: value to be converted to boolean representation",
            "    :returns: value cast to `bool`. when value is 'true' or value that are not 0",
            "              converted into True. Return `None` if value is `None`",
            "    \"\"\"",
            "    if value is None:",
            "        return None",
            "    if isinstance(value, (int, float)):",
            "        return value != 0",
            "    if isinstance(value, str):",
            "        return value.strip().lower() == \"true\"",
            "    return False",
            "",
            "",
            "def list_minus(l: List[Any], minus: List[Any]) -> List[Any]:",
            "    \"\"\"Returns l without what is in minus",
            "",
            "    >>> list_minus([1, 2, 3], [2])",
            "    [1, 3]",
            "    \"\"\"",
            "    return [o for o in l if o not in minus]",
            "",
            "",
            "class DashboardEncoder(json.JSONEncoder):",
            "    def __init__(self, *args: Any, **kwargs: Any) -> None:",
            "        super().__init__(*args, **kwargs)",
            "        self.sort_keys = True",
            "",
            "    def default(self, o: Any) -> Union[Dict[Any, Any], str]:",
            "        if isinstance(o, uuid.UUID):",
            "            return str(o)",
            "        try:",
            "            vals = {k: v for k, v in o.__dict__.items() if k != \"_sa_instance_state\"}",
            "            return {\"__{}__\".format(o.__class__.__name__): vals}",
            "        except Exception:  # pylint: disable=broad-except",
            "            if isinstance(o, datetime):",
            "                return {\"__datetime__\": o.replace(microsecond=0).isoformat()}",
            "            return json.JSONEncoder(sort_keys=True).default(o)",
            "",
            "",
            "class JSONEncodedDict(TypeDecorator):  # pylint: disable=abstract-method",
            "    \"\"\"Represents an immutable structure as a json-encoded string.\"\"\"",
            "",
            "    impl = TEXT",
            "",
            "    def process_bind_param(",
            "        self, value: Optional[Dict[Any, Any]], dialect: str",
            "    ) -> Optional[str]:",
            "        return json.dumps(value) if value is not None else None",
            "",
            "    def process_result_value(",
            "        self, value: Optional[str], dialect: str",
            "    ) -> Optional[Dict[Any, Any]]:",
            "        return json.loads(value) if value is not None else None",
            "",
            "",
            "def format_timedelta(time_delta: timedelta) -> str:",
            "    \"\"\"",
            "    Ensures negative time deltas are easily interpreted by humans",
            "",
            "    >>> td = timedelta(0) - timedelta(days=1, hours=5,minutes=6)",
            "    >>> str(td)",
            "    '-2 days, 18:54:00'",
            "    >>> format_timedelta(td)",
            "    '-1 day, 5:06:00'",
            "    \"\"\"",
            "    if time_delta < timedelta(0):",
            "        return \"-\" + str(abs(time_delta))",
            "",
            "    # Change this to format positive time deltas the way you want",
            "    return str(time_delta)",
            "",
            "",
            "def base_json_conv(  # pylint: disable=inconsistent-return-statements",
            "    obj: Any,",
            ") -> Any:",
            "    if isinstance(obj, memoryview):",
            "        obj = obj.tobytes()",
            "    if isinstance(obj, np.int64):",
            "        return int(obj)",
            "    if isinstance(obj, np.bool_):",
            "        return bool(obj)",
            "    if isinstance(obj, np.ndarray):",
            "        return obj.tolist()",
            "    if isinstance(obj, set):",
            "        return list(obj)",
            "    if isinstance(obj, decimal.Decimal):",
            "        return float(obj)",
            "    if isinstance(obj, (uuid.UUID, time, LazyString)):",
            "        return str(obj)",
            "    if isinstance(obj, timedelta):",
            "        return format_timedelta(obj)",
            "    if isinstance(obj, bytes):",
            "        try:",
            "            return obj.decode(\"utf-8\")",
            "        except Exception:  # pylint: disable=broad-except",
            "            return \"[bytes]\"",
            "",
            "",
            "def json_iso_dttm_ser(obj: Any, pessimistic: bool = False) -> str:",
            "    \"\"\"",
            "    json serializer that deals with dates",
            "",
            "    >>> dttm = datetime(1970, 1, 1)",
            "    >>> json.dumps({'dttm': dttm}, default=json_iso_dttm_ser)",
            "    '{\"dttm\": \"1970-01-01T00:00:00\"}'",
            "    \"\"\"",
            "    val = base_json_conv(obj)",
            "    if val is not None:",
            "        return val",
            "    if isinstance(obj, (datetime, date, pd.Timestamp)):",
            "        obj = obj.isoformat()",
            "    else:",
            "        if pessimistic:",
            "            return \"Unserializable [{}]\".format(type(obj))",
            "",
            "        raise TypeError(\"Unserializable object {} of type {}\".format(obj, type(obj)))",
            "    return obj",
            "",
            "",
            "def pessimistic_json_iso_dttm_ser(obj: Any) -> str:",
            "    \"\"\"Proxy to call json_iso_dttm_ser in a pessimistic way",
            "",
            "    If one of object is not serializable to json, it will still succeed\"\"\"",
            "    return json_iso_dttm_ser(obj, pessimistic=True)",
            "",
            "",
            "def json_int_dttm_ser(obj: Any) -> float:",
            "    \"\"\"json serializer that deals with dates\"\"\"",
            "    val = base_json_conv(obj)",
            "    if val is not None:",
            "        return val",
            "    if isinstance(obj, (datetime, pd.Timestamp)):",
            "        obj = datetime_to_epoch(obj)",
            "    elif isinstance(obj, date):",
            "        obj = (obj - EPOCH.date()).total_seconds() * 1000",
            "    else:",
            "        raise TypeError(\"Unserializable object {} of type {}\".format(obj, type(obj)))",
            "    return obj",
            "",
            "",
            "def json_dumps_w_dates(payload: Dict[Any, Any]) -> str:",
            "    return json.dumps(payload, default=json_int_dttm_ser)",
            "",
            "",
            "def error_msg_from_exception(ex: Exception) -> str:",
            "    \"\"\"Translate exception into error message",
            "",
            "    Database have different ways to handle exception. This function attempts",
            "    to make sense of the exception object and construct a human readable",
            "    sentence.",
            "",
            "    TODO(bkyryliuk): parse the Presto error message from the connection",
            "                     created via create_engine.",
            "    engine = create_engine('presto://localhost:3506/silver') -",
            "      gives an e.message as the str(dict)",
            "    presto.connect('localhost', port=3506, catalog='silver') - as a dict.",
            "    The latter version is parsed correctly by this function.",
            "    \"\"\"",
            "    msg = \"\"",
            "    if hasattr(ex, \"message\"):",
            "        if isinstance(ex.message, dict):  # type: ignore",
            "            msg = ex.message.get(\"message\")  # type: ignore",
            "        elif ex.message:  # type: ignore",
            "            msg = ex.message  # type: ignore",
            "    return msg or str(ex)",
            "",
            "",
            "def markdown(raw: str, markup_wrap: Optional[bool] = False) -> str:",
            "    safe_markdown_tags = [",
            "        \"h1\",",
            "        \"h2\",",
            "        \"h3\",",
            "        \"h4\",",
            "        \"h5\",",
            "        \"h6\",",
            "        \"b\",",
            "        \"i\",",
            "        \"strong\",",
            "        \"em\",",
            "        \"tt\",",
            "        \"p\",",
            "        \"br\",",
            "        \"span\",",
            "        \"div\",",
            "        \"blockquote\",",
            "        \"code\",",
            "        \"hr\",",
            "        \"ul\",",
            "        \"ol\",",
            "        \"li\",",
            "        \"dd\",",
            "        \"dt\",",
            "        \"img\",",
            "        \"a\",",
            "    ]",
            "    safe_markdown_attrs = {",
            "        \"img\": [\"src\", \"alt\", \"title\"],",
            "        \"a\": [\"href\", \"alt\", \"title\"],",
            "    }",
            "    safe = md.markdown(",
            "        raw or \"\",",
            "        extensions=[",
            "            \"markdown.extensions.tables\",",
            "            \"markdown.extensions.fenced_code\",",
            "            \"markdown.extensions.codehilite\",",
            "        ],",
            "    )",
            "    safe = bleach.clean(safe, safe_markdown_tags, safe_markdown_attrs)",
            "    if markup_wrap:",
            "        safe = Markup(safe)",
            "    return safe",
            "",
            "",
            "def readfile(file_path: str) -> Optional[str]:",
            "    with open(file_path) as f:",
            "        content = f.read()",
            "    return content",
            "",
            "",
            "def generic_find_constraint_name(",
            "    table: str, columns: Set[str], referenced: str, database: SQLA",
            ") -> Optional[str]:",
            "    \"\"\"Utility to find a constraint name in alembic migrations\"\"\"",
            "    tbl = sa.Table(",
            "        table, database.metadata, autoload=True, autoload_with=database.engine",
            "    )",
            "",
            "    for fk in tbl.foreign_key_constraints:",
            "        if fk.referred_table.name == referenced and set(fk.column_keys) == columns:",
            "            return fk.name",
            "",
            "    return None",
            "",
            "",
            "def generic_find_fk_constraint_name(",
            "    table: str, columns: Set[str], referenced: str, insp: Inspector",
            ") -> Optional[str]:",
            "    \"\"\"Utility to find a foreign-key constraint name in alembic migrations\"\"\"",
            "    for fk in insp.get_foreign_keys(table):",
            "        if (",
            "            fk[\"referred_table\"] == referenced",
            "            and set(fk[\"referred_columns\"]) == columns",
            "        ):",
            "            return fk[\"name\"]",
            "",
            "    return None",
            "",
            "",
            "def generic_find_fk_constraint_names(  # pylint: disable=invalid-name",
            "    table: str, columns: Set[str], referenced: str, insp: Inspector",
            ") -> Set[str]:",
            "    \"\"\"Utility to find foreign-key constraint names in alembic migrations\"\"\"",
            "    names = set()",
            "",
            "    for fk in insp.get_foreign_keys(table):",
            "        if (",
            "            fk[\"referred_table\"] == referenced",
            "            and set(fk[\"referred_columns\"]) == columns",
            "        ):",
            "            names.add(fk[\"name\"])",
            "",
            "    return names",
            "",
            "",
            "def generic_find_uq_constraint_name(",
            "    table: str, columns: Set[str], insp: Inspector",
            ") -> Optional[str]:",
            "    \"\"\"Utility to find a unique constraint name in alembic migrations\"\"\"",
            "",
            "    for uq in insp.get_unique_constraints(table):",
            "        if columns == set(uq[\"column_names\"]):",
            "            return uq[\"name\"]",
            "",
            "    return None",
            "",
            "",
            "def get_datasource_full_name(",
            "    database_name: str, datasource_name: str, schema: Optional[str] = None",
            ") -> str:",
            "    if not schema:",
            "        return \"[{}].[{}]\".format(database_name, datasource_name)",
            "    return \"[{}].[{}].[{}]\".format(database_name, schema, datasource_name)",
            "",
            "",
            "def validate_json(obj: Union[bytes, bytearray, str]) -> None:",
            "    if obj:",
            "        try:",
            "            json.loads(obj)",
            "        except Exception as ex:",
            "            logger.error(\"JSON is not valid %s\", str(ex), exc_info=True)",
            "            raise SupersetException(\"JSON is not valid\") from ex",
            "",
            "",
            "class SigalrmTimeout:",
            "    \"\"\"",
            "    To be used in a ``with`` block and timeout its content.",
            "    \"\"\"",
            "",
            "    def __init__(self, seconds: int = 1, error_message: str = \"Timeout\") -> None:",
            "        self.seconds = seconds",
            "        self.error_message = error_message",
            "",
            "    def handle_timeout(  # pylint: disable=unused-argument",
            "        self, signum: int, frame: Any",
            "    ) -> None:",
            "        logger.error(\"Process timed out\", exc_info=True)",
            "        raise SupersetTimeoutException(",
            "            error_type=SupersetErrorType.BACKEND_TIMEOUT_ERROR,",
            "            message=self.error_message,",
            "            level=ErrorLevel.ERROR,",
            "            extra={\"timeout\": self.seconds},",
            "        )",
            "",
            "    def __enter__(self) -> None:",
            "        try:",
            "            if threading.current_thread() == threading.main_thread():",
            "                signal.signal(signal.SIGALRM, self.handle_timeout)",
            "                signal.alarm(self.seconds)",
            "        except ValueError as ex:",
            "            logger.warning(\"timeout can't be used in the current context\")",
            "            logger.exception(ex)",
            "",
            "    def __exit__(  # pylint: disable=redefined-outer-name,redefined-builtin",
            "        self, type: Any, value: Any, traceback: TracebackType",
            "    ) -> None:",
            "        try:",
            "            signal.alarm(0)",
            "        except ValueError as ex:",
            "            logger.warning(\"timeout can't be used in the current context\")",
            "            logger.exception(ex)",
            "",
            "",
            "class TimerTimeout:",
            "    def __init__(self, seconds: int = 1, error_message: str = \"Timeout\") -> None:",
            "        self.seconds = seconds",
            "        self.error_message = error_message",
            "        self.timer = threading.Timer(seconds, _thread.interrupt_main)",
            "",
            "    def __enter__(self) -> None:",
            "        self.timer.start()",
            "",
            "    def __exit__(  # pylint: disable=redefined-outer-name,redefined-builtin",
            "        self, type: Any, value: Any, traceback: TracebackType",
            "    ) -> None:",
            "        self.timer.cancel()",
            "        if type is KeyboardInterrupt:  # raised by _thread.interrupt_main",
            "            raise SupersetTimeoutException(",
            "                error_type=SupersetErrorType.BACKEND_TIMEOUT_ERROR,",
            "                message=self.error_message,",
            "                level=ErrorLevel.ERROR,",
            "                extra={\"timeout\": self.seconds},",
            "            )",
            "",
            "",
            "# Windows has no support for SIGALRM, so we use the timer based timeout",
            "timeout: Union[Type[TimerTimeout], Type[SigalrmTimeout]] = (",
            "    TimerTimeout if platform.system() == \"Windows\" else SigalrmTimeout",
            ")",
            "",
            "",
            "def pessimistic_connection_handling(some_engine: Engine) -> None:",
            "    @event.listens_for(some_engine, \"engine_connect\")",
            "    def ping_connection(connection: Connection, branch: bool) -> None:",
            "        if branch:",
            "            # 'branch' refers to a sub-connection of a connection,",
            "            # we don't want to bother pinging on these.",
            "            return",
            "",
            "        # turn off 'close with result'.  This flag is only used with",
            "        # 'connectionless' execution, otherwise will be False in any case",
            "        save_should_close_with_result = connection.should_close_with_result",
            "        connection.should_close_with_result = False",
            "",
            "        try:",
            "            # run a SELECT 1.   use a core select() so that",
            "            # the SELECT of a scalar value without a table is",
            "            # appropriately formatted for the backend",
            "            connection.scalar(select([1]))",
            "        except exc.DBAPIError as err:",
            "            # catch SQLAlchemy's DBAPIError, which is a wrapper",
            "            # for the DBAPI's exception.  It includes a .connection_invalidated",
            "            # attribute which specifies if this connection is a 'disconnect'",
            "            # condition, which is based on inspection of the original exception",
            "            # by the dialect in use.",
            "            if err.connection_invalidated:",
            "                # run the same SELECT again - the connection will re-validate",
            "                # itself and establish a new connection.  The disconnect detection",
            "                # here also causes the whole connection pool to be invalidated",
            "                # so that all stale connections are discarded.",
            "                connection.scalar(select([1]))",
            "            else:",
            "                raise",
            "        finally:",
            "            # restore 'close with result'",
            "            connection.should_close_with_result = save_should_close_with_result",
            "",
            "",
            "def notify_user_about_perm_udate(  # pylint: disable=too-many-arguments",
            "    granter: User,",
            "    user: User,",
            "    role: Role,",
            "    datasource: \"BaseDatasource\",",
            "    tpl_name: str,",
            "    config: Dict[str, Any],",
            ") -> None:",
            "    msg = render_template(",
            "        tpl_name, granter=granter, user=user, role=role, datasource=datasource",
            "    )",
            "    logger.info(msg)",
            "    subject = __(",
            "        \"[Superset] Access to the datasource %(name)s was granted\",",
            "        name=datasource.full_name,",
            "    )",
            "    send_email_smtp(",
            "        user.email,",
            "        subject,",
            "        msg,",
            "        config,",
            "        bcc=granter.email,",
            "        dryrun=not config[\"EMAIL_NOTIFICATIONS\"],",
            "    )",
            "",
            "",
            "def send_email_smtp(  # pylint: disable=invalid-name,too-many-arguments,too-many-locals",
            "    to: str,",
            "    subject: str,",
            "    html_content: str,",
            "    config: Dict[str, Any],",
            "    files: Optional[List[str]] = None,",
            "    data: Optional[Dict[str, str]] = None,",
            "    images: Optional[Dict[str, bytes]] = None,",
            "    dryrun: bool = False,",
            "    cc: Optional[str] = None,",
            "    bcc: Optional[str] = None,",
            "    mime_subtype: str = \"mixed\",",
            ") -> None:",
            "    \"\"\"",
            "    Send an email with html content, eg:",
            "    send_email_smtp(",
            "        'test@example.com', 'foo', '<b>Foo</b> bar',['/dev/null'], dryrun=True)",
            "    \"\"\"",
            "    smtp_mail_from = config[\"SMTP_MAIL_FROM\"]",
            "    smtp_mail_to = get_email_address_list(to)",
            "",
            "    msg = MIMEMultipart(mime_subtype)",
            "    msg[\"Subject\"] = subject",
            "    msg[\"From\"] = smtp_mail_from",
            "    msg[\"To\"] = \", \".join(smtp_mail_to)",
            "    msg.preamble = \"This is a multi-part message in MIME format.\"",
            "",
            "    recipients = smtp_mail_to",
            "    if cc:",
            "        smtp_mail_cc = get_email_address_list(cc)",
            "        msg[\"CC\"] = \", \".join(smtp_mail_cc)",
            "        recipients = recipients + smtp_mail_cc",
            "",
            "    if bcc:",
            "        # don't add bcc in header",
            "        smtp_mail_bcc = get_email_address_list(bcc)",
            "        recipients = recipients + smtp_mail_bcc",
            "",
            "    msg[\"Date\"] = formatdate(localtime=True)",
            "    mime_text = MIMEText(html_content, \"html\")",
            "    msg.attach(mime_text)",
            "",
            "    # Attach files by reading them from disk",
            "    for fname in files or []:",
            "        basename = os.path.basename(fname)",
            "        with open(fname, \"rb\") as f:",
            "            msg.attach(",
            "                MIMEApplication(",
            "                    f.read(),",
            "                    Content_Disposition=\"attachment; filename='%s'\" % basename,",
            "                    Name=basename,",
            "                )",
            "            )",
            "",
            "    # Attach any files passed directly",
            "    for name, body in (data or {}).items():",
            "        msg.attach(",
            "            MIMEApplication(",
            "                body, Content_Disposition=\"attachment; filename='%s'\" % name, Name=name",
            "            )",
            "        )",
            "",
            "    # Attach any inline images, which may be required for display in",
            "    # HTML content (inline)",
            "    for msgid, imgdata in (images or {}).items():",
            "        image = MIMEImage(imgdata)",
            "        image.add_header(\"Content-ID\", \"<%s>\" % msgid)",
            "        image.add_header(\"Content-Disposition\", \"inline\")",
            "        msg.attach(image)",
            "",
            "    send_mime_email(smtp_mail_from, recipients, msg, config, dryrun=dryrun)",
            "",
            "",
            "def send_mime_email(",
            "    e_from: str,",
            "    e_to: List[str],",
            "    mime_msg: MIMEMultipart,",
            "    config: Dict[str, Any],",
            "    dryrun: bool = False,",
            ") -> None:",
            "    smtp_host = config[\"SMTP_HOST\"]",
            "    smtp_port = config[\"SMTP_PORT\"]",
            "    smtp_user = config[\"SMTP_USER\"]",
            "    smtp_password = config[\"SMTP_PASSWORD\"]",
            "    smtp_starttls = config[\"SMTP_STARTTLS\"]",
            "    smtp_ssl = config[\"SMTP_SSL\"]",
            "    smpt_ssl_server_auth = config[\"SMTP_SSL_SERVER_AUTH\"]",
            "",
            "    if dryrun:",
            "        logger.info(\"Dryrun enabled, email notification content is below:\")",
            "        logger.info(mime_msg.as_string())",
            "        return",
            "",
            "    # Default ssl context is SERVER_AUTH using the default system",
            "    # root CA certificates",
            "    ssl_context = ssl.create_default_context() if smpt_ssl_server_auth else None",
            "    smtp = (",
            "        smtplib.SMTP_SSL(smtp_host, smtp_port, context=ssl_context)",
            "        if smtp_ssl",
            "        else smtplib.SMTP(smtp_host, smtp_port)",
            "    )",
            "    if smtp_starttls:",
            "        smtp.starttls(context=ssl_context)",
            "    if smtp_user and smtp_password:",
            "        smtp.login(smtp_user, smtp_password)",
            "    logger.debug(\"Sent an email to %s\", str(e_to))",
            "    smtp.sendmail(e_from, e_to, mime_msg.as_string())",
            "    smtp.quit()",
            "",
            "",
            "def get_email_address_list(address_string: str) -> List[str]:",
            "    address_string_list: List[str] = []",
            "    if isinstance(address_string, str):",
            "        address_string_list = re.split(r\",|\\s|;\", address_string)",
            "    return [x.strip() for x in address_string_list if x.strip()]",
            "",
            "",
            "def get_email_address_str(address_string: str) -> str:",
            "    address_list = get_email_address_list(address_string)",
            "    address_list_str = \", \".join(address_list)",
            "",
            "    return address_list_str",
            "",
            "",
            "def choicify(values: Iterable[Any]) -> List[Tuple[Any, Any]]:",
            "    \"\"\"Takes an iterable and makes an iterable of tuples with it\"\"\"",
            "    return [(v, v) for v in values]",
            "",
            "",
            "def zlib_compress(data: Union[bytes, str]) -> bytes:",
            "    \"\"\"",
            "    Compress things in a py2/3 safe fashion",
            "    >>> json_str = '{\"test\": 1}'",
            "    >>> blob = zlib_compress(json_str)",
            "    \"\"\"",
            "    if isinstance(data, str):",
            "        return zlib.compress(bytes(data, \"utf-8\"))",
            "    return zlib.compress(data)",
            "",
            "",
            "def zlib_decompress(blob: bytes, decode: Optional[bool] = True) -> Union[bytes, str]:",
            "    \"\"\"",
            "    Decompress things to a string in a py2/3 safe fashion",
            "    >>> json_str = '{\"test\": 1}'",
            "    >>> blob = zlib_compress(json_str)",
            "    >>> got_str = zlib_decompress(blob)",
            "    >>> got_str == json_str",
            "    True",
            "    \"\"\"",
            "    if isinstance(blob, bytes):",
            "        decompressed = zlib.decompress(blob)",
            "    else:",
            "        decompressed = zlib.decompress(bytes(blob, \"utf-8\"))",
            "    return decompressed.decode(\"utf-8\") if decode else decompressed",
            "",
            "",
            "def simple_filter_to_adhoc(",
            "    filter_clause: QueryObjectFilterClause,",
            "    clause: str = \"where\",",
            ") -> AdhocFilterClause:",
            "    result: AdhocFilterClause = {",
            "        \"clause\": clause.upper(),",
            "        \"expressionType\": \"SIMPLE\",",
            "        \"comparator\": filter_clause.get(\"val\"),",
            "        \"operator\": filter_clause[\"op\"],",
            "        \"subject\": filter_clause[\"col\"],",
            "    }",
            "    if filter_clause.get(\"isExtra\"):",
            "        result[\"isExtra\"] = True",
            "    result[\"filterOptionName\"] = md5_sha_from_dict(cast(Dict[Any, Any], result))",
            "",
            "    return result",
            "",
            "",
            "def form_data_to_adhoc(form_data: Dict[str, Any], clause: str) -> AdhocFilterClause:",
            "    if clause not in (\"where\", \"having\"):",
            "        raise ValueError(__(\"Unsupported clause type: %(clause)s\", clause=clause))",
            "    result: AdhocFilterClause = {",
            "        \"clause\": clause.upper(),",
            "        \"expressionType\": \"SQL\",",
            "        \"sqlExpression\": form_data.get(clause),",
            "    }",
            "    result[\"filterOptionName\"] = md5_sha_from_dict(cast(Dict[Any, Any], result))",
            "",
            "    return result",
            "",
            "",
            "def merge_extra_form_data(form_data: Dict[str, Any]) -> None:",
            "    \"\"\"",
            "    Merge extra form data (appends and overrides) into the main payload",
            "    and add applied time extras to the payload.",
            "    \"\"\"",
            "    filter_keys = [\"filters\", \"adhoc_filters\"]",
            "    extra_form_data = form_data.pop(\"extra_form_data\", {})",
            "    append_filters: List[QueryObjectFilterClause] = extra_form_data.get(\"filters\", None)",
            "",
            "    # merge append extras",
            "    for key in [key for key in EXTRA_FORM_DATA_APPEND_KEYS if key not in filter_keys]:",
            "        extra_value = getattr(extra_form_data, key, {})",
            "        form_value = getattr(form_data, key, {})",
            "        form_value.update(extra_value)",
            "        if form_value:",
            "            form_data[\"key\"] = extra_value",
            "",
            "    # map regular extras that apply to form data properties",
            "    for src_key, target_key in EXTRA_FORM_DATA_OVERRIDE_REGULAR_MAPPINGS.items():",
            "        value = extra_form_data.get(src_key)",
            "        if value is not None:",
            "            form_data[target_key] = value",
            "",
            "    # map extras that apply to form data extra properties",
            "    extras = form_data.get(\"extras\", {})",
            "    for key in EXTRA_FORM_DATA_OVERRIDE_EXTRA_KEYS:",
            "        value = extra_form_data.get(key)",
            "        if value is not None:",
            "            extras[key] = value",
            "    if extras:",
            "        form_data[\"extras\"] = extras",
            "",
            "    adhoc_filters: List[AdhocFilterClause] = form_data.get(\"adhoc_filters\", [])",
            "    form_data[\"adhoc_filters\"] = adhoc_filters",
            "    append_adhoc_filters: List[AdhocFilterClause] = extra_form_data.get(",
            "        \"adhoc_filters\", []",
            "    )",
            "    adhoc_filters.extend(",
            "        {\"isExtra\": True, **fltr} for fltr in append_adhoc_filters  # type: ignore",
            "    )",
            "    if append_filters:",
            "        for key, value in form_data.items():",
            "            if re.match(\"adhoc_filter.*\", key):",
            "                value.extend(",
            "                    simple_filter_to_adhoc({\"isExtra\": True, **fltr})  # type: ignore",
            "                    for fltr in append_filters",
            "                    if fltr",
            "                )",
            "",
            "",
            "def merge_extra_filters(form_data: Dict[str, Any]) -> None:",
            "    # extra_filters are temporary/contextual filters (using the legacy constructs)",
            "    # that are external to the slice definition. We use those for dynamic",
            "    # interactive filters like the ones emitted by the \"Filter Box\" visualization.",
            "    # Note extra_filters only support simple filters.",
            "    applied_time_extras: Dict[str, str] = {}",
            "    form_data[\"applied_time_extras\"] = applied_time_extras",
            "    adhoc_filters = form_data.get(\"adhoc_filters\", [])",
            "    form_data[\"adhoc_filters\"] = adhoc_filters",
            "    merge_extra_form_data(form_data)",
            "    if \"extra_filters\" in form_data:",
            "        # __form and __to are special extra_filters that target time",
            "        # boundaries. The rest of extra_filters are simple",
            "        # [column_name in list_of_values]. `__` prefix is there to avoid",
            "        # potential conflicts with column that would be named `from` or `to`",
            "        date_options = {",
            "            \"__time_range\": \"time_range\",",
            "            \"__time_col\": \"granularity_sqla\",",
            "            \"__time_grain\": \"time_grain_sqla\",",
            "            \"__time_origin\": \"druid_time_origin\",",
            "            \"__granularity\": \"granularity\",",
            "        }",
            "        # Grab list of existing filters 'keyed' on the column and operator",
            "",
            "        def get_filter_key(f: Dict[str, Any]) -> str:",
            "            if \"expressionType\" in f:",
            "                return \"{}__{}\".format(f[\"subject\"], f[\"operator\"])",
            "",
            "            return \"{}__{}\".format(f[\"col\"], f[\"op\"])",
            "",
            "        existing_filters = {}",
            "        for existing in adhoc_filters:",
            "            if (",
            "                existing[\"expressionType\"] == \"SIMPLE\"",
            "                and existing.get(\"comparator\") is not None",
            "                and existing.get(\"subject\") is not None",
            "            ):",
            "                existing_filters[get_filter_key(existing)] = existing[\"comparator\"]",
            "",
            "        for filtr in form_data[  # pylint: disable=too-many-nested-blocks",
            "            \"extra_filters\"",
            "        ]:",
            "            filtr[\"isExtra\"] = True",
            "            # Pull out time filters/options and merge into form data",
            "            filter_column = filtr[\"col\"]",
            "            time_extra = date_options.get(filter_column)",
            "            if time_extra:",
            "                time_extra_value = filtr.get(\"val\")",
            "                if time_extra_value and time_extra_value != NO_TIME_RANGE:",
            "                    form_data[time_extra] = time_extra_value",
            "                    applied_time_extras[filter_column] = time_extra_value",
            "            elif filtr[\"val\"]:",
            "                # Merge column filters",
            "                filter_key = get_filter_key(filtr)",
            "                if filter_key in existing_filters:",
            "                    # Check if the filter already exists",
            "                    if isinstance(filtr[\"val\"], list):",
            "                        if isinstance(existing_filters[filter_key], list):",
            "                            # Add filters for unequal lists",
            "                            # order doesn't matter",
            "                            if set(existing_filters[filter_key]) != set(filtr[\"val\"]):",
            "                                adhoc_filters.append(simple_filter_to_adhoc(filtr))",
            "                        else:",
            "                            adhoc_filters.append(simple_filter_to_adhoc(filtr))",
            "                    else:",
            "                        # Do not add filter if same value already exists",
            "                        if filtr[\"val\"] != existing_filters[filter_key]:",
            "                            adhoc_filters.append(simple_filter_to_adhoc(filtr))",
            "                else:",
            "                    # Filter not found, add it",
            "                    adhoc_filters.append(simple_filter_to_adhoc(filtr))",
            "        # Remove extra filters from the form data since no longer needed",
            "        del form_data[\"extra_filters\"]",
            "",
            "",
            "def merge_request_params(form_data: Dict[str, Any], params: Dict[str, Any]) -> None:",
            "    \"\"\"",
            "    Merge request parameters to the key `url_params` in form_data. Only updates",
            "    or appends parameters to `form_data` that are defined in `params; pre-existing",
            "    parameters not defined in params are left unchanged.",
            "",
            "    :param form_data: object to be updated",
            "    :param params: request parameters received via query string",
            "    \"\"\"",
            "    url_params = form_data.get(\"url_params\", {})",
            "    for key, value in params.items():",
            "        if key in (\"form_data\", \"r\"):",
            "            continue",
            "        url_params[key] = value",
            "    form_data[\"url_params\"] = url_params",
            "",
            "",
            "def user_label(user: User) -> Optional[str]:",
            "    \"\"\"Given a user ORM FAB object, returns a label\"\"\"",
            "    if user:",
            "        if user.first_name and user.last_name:",
            "            return user.first_name + \" \" + user.last_name",
            "",
            "        return user.username",
            "",
            "    return None",
            "",
            "",
            "def get_example_default_schema() -> Optional[str]:",
            "    \"\"\"",
            "    Return the default schema of the examples database, if any.",
            "    \"\"\"",
            "    database = get_example_database()",
            "    engine = database.get_sqla_engine()",
            "    return inspect(engine).default_schema_name",
            "",
            "",
            "def backend() -> str:",
            "    return get_example_database().backend",
            "",
            "",
            "def is_adhoc_metric(metric: Metric) -> TypeGuard[AdhocMetric]:",
            "    return isinstance(metric, dict) and \"expressionType\" in metric",
            "",
            "",
            "def is_adhoc_column(column: Column) -> TypeGuard[AdhocColumn]:",
            "    return isinstance(column, dict)",
            "",
            "",
            "def get_column_name(",
            "    column: Column, verbose_map: Optional[Dict[str, Any]] = None",
            ") -> str:",
            "    \"\"\"",
            "    Extract label from column",
            "",
            "    :param column: object to extract label from",
            "    :param verbose_map: verbose_map from dataset for optional mapping from",
            "                        raw name to verbose name",
            "    :return: String representation of column",
            "    :raises ValueError: if metric object is invalid",
            "    \"\"\"",
            "    if isinstance(column, dict):",
            "        label = column.get(\"label\")",
            "        if label:",
            "            return label",
            "        expr = column.get(\"sqlExpression\")",
            "        if expr:",
            "            return expr",
            "        raise ValueError(\"Missing label\")",
            "    verbose_map = verbose_map or {}",
            "    return verbose_map.get(column, column)",
            "",
            "",
            "def get_metric_name(",
            "    metric: Metric, verbose_map: Optional[Dict[str, Any]] = None",
            ") -> str:",
            "    \"\"\"",
            "    Extract label from metric",
            "",
            "    :param metric: object to extract label from",
            "    :param verbose_map: verbose_map from dataset for optional mapping from",
            "                        raw name to verbose name",
            "    :return: String representation of metric",
            "    :raises ValueError: if metric object is invalid",
            "    \"\"\"",
            "    if is_adhoc_metric(metric):",
            "        label = metric.get(\"label\")",
            "        if label:",
            "            return label",
            "        expression_type = metric.get(\"expressionType\")",
            "        if expression_type == \"SQL\":",
            "            sql_expression = metric.get(\"sqlExpression\")",
            "            if sql_expression:",
            "                return sql_expression",
            "        elif expression_type == \"SIMPLE\":",
            "            column: AdhocMetricColumn = metric.get(\"column\") or {}",
            "            column_name = column.get(\"column_name\")",
            "            aggregate = metric.get(\"aggregate\")",
            "            if column and aggregate:",
            "                return f\"{aggregate}({column_name})\"",
            "            if column_name:",
            "                return column_name",
            "        raise ValueError(__(\"Invalid metric object\"))",
            "",
            "    verbose_map = verbose_map or {}",
            "    return verbose_map.get(metric, metric)  # type: ignore",
            "",
            "",
            "def get_column_names(",
            "    columns: Optional[Sequence[Column]],",
            "    verbose_map: Optional[Dict[str, Any]] = None,",
            ") -> List[str]:",
            "    return [",
            "        column",
            "        for column in [get_column_name(column, verbose_map) for column in columns or []]",
            "        if column",
            "    ]",
            "",
            "",
            "def get_metric_names(",
            "    metrics: Optional[Sequence[Metric]],",
            "    verbose_map: Optional[Dict[str, Any]] = None,",
            ") -> List[str]:",
            "    return [",
            "        metric",
            "        for metric in [get_metric_name(metric, verbose_map) for metric in metrics or []]",
            "        if metric",
            "    ]",
            "",
            "",
            "def get_first_metric_name(",
            "    metrics: Optional[Sequence[Metric]],",
            "    verbose_map: Optional[Dict[str, Any]] = None,",
            ") -> Optional[str]:",
            "    metric_labels = get_metric_names(metrics, verbose_map)",
            "    return metric_labels[0] if metric_labels else None",
            "",
            "",
            "def ensure_path_exists(path: str) -> None:",
            "    try:",
            "        os.makedirs(path)",
            "    except OSError as ex:",
            "        if not (os.path.isdir(path) and ex.errno == errno.EEXIST):",
            "            raise",
            "",
            "",
            "def convert_legacy_filters_into_adhoc(  # pylint: disable=invalid-name",
            "    form_data: FormData,",
            ") -> None:",
            "    mapping = {\"having\": \"having_filters\", \"where\": \"filters\"}",
            "",
            "    if not form_data.get(\"adhoc_filters\"):",
            "        adhoc_filters: List[AdhocFilterClause] = []",
            "        form_data[\"adhoc_filters\"] = adhoc_filters",
            "",
            "        for clause, filters in mapping.items():",
            "            if clause in form_data and form_data[clause] != \"\":",
            "                adhoc_filters.append(form_data_to_adhoc(form_data, clause))",
            "",
            "            if filters in form_data:",
            "                for filt in filter(lambda x: x is not None, form_data[filters]):",
            "                    adhoc_filters.append(simple_filter_to_adhoc(filt, clause))",
            "",
            "    for key in (\"filters\", \"having\", \"having_filters\", \"where\"):",
            "        if key in form_data:",
            "            del form_data[key]",
            "",
            "",
            "def split_adhoc_filters_into_base_filters(  # pylint: disable=invalid-name",
            "    form_data: FormData,",
            ") -> None:",
            "    \"\"\"",
            "    Mutates form data to restructure the adhoc filters in the form of the four base",
            "    filters, `where`, `having`, `filters`, and `having_filters` which represent",
            "    free form where sql, free form having sql, structured where clauses and structured",
            "    having clauses.",
            "    \"\"\"",
            "    adhoc_filters = form_data.get(\"adhoc_filters\")",
            "    if isinstance(adhoc_filters, list):",
            "        simple_where_filters = []",
            "        simple_having_filters = []",
            "        sql_where_filters = []",
            "        sql_having_filters = []",
            "        for adhoc_filter in adhoc_filters:",
            "            expression_type = adhoc_filter.get(\"expressionType\")",
            "            clause = adhoc_filter.get(\"clause\")",
            "            if expression_type == \"SIMPLE\":",
            "                if clause == \"WHERE\":",
            "                    simple_where_filters.append(",
            "                        {",
            "                            \"col\": adhoc_filter.get(\"subject\"),",
            "                            \"op\": adhoc_filter.get(\"operator\"),",
            "                            \"val\": adhoc_filter.get(\"comparator\"),",
            "                        }",
            "                    )",
            "                elif clause == \"HAVING\":",
            "                    simple_having_filters.append(",
            "                        {",
            "                            \"col\": adhoc_filter.get(\"subject\"),",
            "                            \"op\": adhoc_filter.get(\"operator\"),",
            "                            \"val\": adhoc_filter.get(\"comparator\"),",
            "                        }",
            "                    )",
            "            elif expression_type == \"SQL\":",
            "                sql_expression = adhoc_filter.get(\"sqlExpression\")",
            "                sql_expression = sanitize_clause(sql_expression)",
            "                if clause == \"WHERE\":",
            "                    sql_where_filters.append(sql_expression)",
            "                elif clause == \"HAVING\":",
            "                    sql_having_filters.append(sql_expression)",
            "        form_data[\"where\"] = \" AND \".join(",
            "            [\"({})\".format(sql) for sql in sql_where_filters]",
            "        )",
            "        form_data[\"having\"] = \" AND \".join(",
            "            [\"({})\".format(sql) for sql in sql_having_filters]",
            "        )",
            "        form_data[\"having_filters\"] = simple_having_filters",
            "        form_data[\"filters\"] = simple_where_filters",
            "",
            "",
            "def get_username() -> Optional[str]:",
            "    \"\"\"Get username if within the flask context, otherwise return noffin'\"\"\"",
            "    try:",
            "        return g.user.username",
            "    except Exception:  # pylint: disable=broad-except",
            "        return None",
            "",
            "",
            "def parse_ssl_cert(certificate: str) -> _Certificate:",
            "    \"\"\"",
            "    Parses the contents of a certificate and returns a valid certificate object",
            "    if valid.",
            "",
            "    :param certificate: Contents of certificate file",
            "    :return: Valid certificate instance",
            "    :raises CertificateException: If certificate is not valid/unparseable",
            "    \"\"\"",
            "    try:",
            "        return x509.load_pem_x509_certificate(",
            "            certificate.encode(\"utf-8\"), default_backend()",
            "        )",
            "    except ValueError as ex:",
            "        raise CertificateException(\"Invalid certificate\") from ex",
            "",
            "",
            "def create_ssl_cert_file(certificate: str) -> str:",
            "    \"\"\"",
            "    This creates a certificate file that can be used to validate HTTPS",
            "    sessions. A certificate is only written to disk once; on subsequent calls,",
            "    only the path of the existing certificate is returned.",
            "",
            "    :param certificate: The contents of the certificate",
            "    :return: The path to the certificate file",
            "    :raises CertificateException: If certificate is not valid/unparseable",
            "    \"\"\"",
            "    filename = f\"{md5_sha_from_str(certificate)}.crt\"",
            "    cert_dir = current_app.config[\"SSL_CERT_PATH\"]",
            "    path = cert_dir if cert_dir else tempfile.gettempdir()",
            "    path = os.path.join(path, filename)",
            "    if not os.path.exists(path):",
            "        # Validate certificate prior to persisting to temporary directory",
            "        parse_ssl_cert(certificate)",
            "        with open(path, \"w\") as cert_file:",
            "            cert_file.write(certificate)",
            "    return path",
            "",
            "",
            "def time_function(",
            "    func: Callable[..., FlaskResponse], *args: Any, **kwargs: Any",
            ") -> Tuple[float, Any]:",
            "    \"\"\"",
            "    Measures the amount of time a function takes to execute in ms",
            "",
            "    :param func: The function execution time to measure",
            "    :param args: args to be passed to the function",
            "    :param kwargs: kwargs to be passed to the function",
            "    :return: A tuple with the duration and response from the function",
            "    \"\"\"",
            "    start = default_timer()",
            "    response = func(*args, **kwargs)",
            "    stop = default_timer()",
            "    return (stop - start) * 1000.0, response",
            "",
            "",
            "def MediumText() -> Variant:  # pylint:disable=invalid-name",
            "    return Text().with_variant(MEDIUMTEXT(), \"mysql\")",
            "",
            "",
            "def shortid() -> str:",
            "    return \"{}\".format(uuid.uuid4())[-12:]",
            "",
            "",
            "class DatasourceName(NamedTuple):",
            "    table: str",
            "    schema: str",
            "",
            "",
            "def get_stacktrace() -> Optional[str]:",
            "    if current_app.config[\"SHOW_STACKTRACE\"]:",
            "        return traceback.format_exc()",
            "    return None",
            "",
            "",
            "def split(",
            "    string: str, delimiter: str = \" \", quote: str = '\"', escaped_quote: str = r\"\\\"\"",
            ") -> Iterator[str]:",
            "    \"\"\"",
            "    A split function that is aware of quotes and parentheses.",
            "",
            "    :param string: string to split",
            "    :param delimiter: string defining where to split, usually a comma or space",
            "    :param quote: string, either a single or a double quote",
            "    :param escaped_quote: string representing an escaped quote",
            "    :return: list of strings",
            "    \"\"\"",
            "    parens = 0",
            "    quotes = False",
            "    i = 0",
            "    for j, character in enumerate(string):",
            "        complete = parens == 0 and not quotes",
            "        if complete and character == delimiter:",
            "            yield string[i:j]",
            "            i = j + len(delimiter)",
            "        elif character == \"(\":",
            "            parens += 1",
            "        elif character == \")\":",
            "            parens -= 1",
            "        elif character == quote:",
            "            if quotes and string[j - len(escaped_quote) + 1 : j + 1] != escaped_quote:",
            "                quotes = False",
            "            elif not quotes:",
            "                quotes = True",
            "    yield string[i:]",
            "",
            "",
            "def get_iterable(x: Any) -> List[Any]:",
            "    \"\"\"",
            "    Get an iterable (list) representation of the object.",
            "",
            "    :param x: The object",
            "    :returns: An iterable representation",
            "    \"\"\"",
            "    return x if isinstance(x, list) else [x]",
            "",
            "",
            "def get_form_data_token(form_data: Dict[str, Any]) -> str:",
            "    \"\"\"",
            "    Return the token contained within form data or generate a new one.",
            "",
            "    :param form_data: chart form data",
            "    :return: original token if predefined, otherwise new uuid4 based token",
            "    \"\"\"",
            "    return form_data.get(\"token\") or \"token_\" + uuid.uuid4().hex[:8]",
            "",
            "",
            "def get_column_name_from_column(column: Column) -> Optional[str]:",
            "    \"\"\"",
            "    Extract the physical column that a column is referencing. If the column is",
            "    an adhoc column, always returns `None`.",
            "",
            "    :param column: Physical and ad-hoc column",
            "    :return: column name if physical column, otherwise None",
            "    \"\"\"",
            "    if is_adhoc_column(column):",
            "        return None",
            "    return column  # type: ignore",
            "",
            "",
            "def get_column_names_from_columns(columns: List[Column]) -> List[str]:",
            "    \"\"\"",
            "    Extract the physical columns that a list of columns are referencing. Ignore",
            "    adhoc columns",
            "",
            "    :param columns: Physical and adhoc columns",
            "    :return: column names of all physical columns",
            "    \"\"\"",
            "    return [col for col in map(get_column_name_from_column, columns) if col]",
            "",
            "",
            "def get_column_name_from_metric(metric: Metric) -> Optional[str]:",
            "    \"\"\"",
            "    Extract the column that a metric is referencing. If the metric isn't",
            "    a simple metric, always returns `None`.",
            "",
            "    :param metric: Ad-hoc metric",
            "    :return: column name if simple metric, otherwise None",
            "    \"\"\"",
            "    if is_adhoc_metric(metric):",
            "        metric = cast(AdhocMetric, metric)",
            "        if metric[\"expressionType\"] == AdhocMetricExpressionType.SIMPLE:",
            "            return cast(Dict[str, Any], metric[\"column\"])[\"column_name\"]",
            "    return None",
            "",
            "",
            "def get_column_names_from_metrics(metrics: List[Metric]) -> List[str]:",
            "    \"\"\"",
            "    Extract the columns that a list of metrics are referencing. Expcludes all",
            "    SQL metrics.",
            "",
            "    :param metrics: Ad-hoc metric",
            "    :return: column name if simple metric, otherwise None",
            "    \"\"\"",
            "    return [col for col in map(get_column_name_from_metric, metrics) if col]",
            "",
            "",
            "def extract_dataframe_dtypes(",
            "    df: pd.DataFrame,",
            "    datasource: Optional[\"BaseDatasource\"] = None,",
            ") -> List[GenericDataType]:",
            "    \"\"\"Serialize pandas/numpy dtypes to generic types\"\"\"",
            "",
            "    # omitting string types as those will be the default type",
            "    inferred_type_map: Dict[str, GenericDataType] = {",
            "        \"floating\": GenericDataType.NUMERIC,",
            "        \"integer\": GenericDataType.NUMERIC,",
            "        \"mixed-integer-float\": GenericDataType.NUMERIC,",
            "        \"decimal\": GenericDataType.NUMERIC,",
            "        \"boolean\": GenericDataType.BOOLEAN,",
            "        \"datetime64\": GenericDataType.TEMPORAL,",
            "        \"datetime\": GenericDataType.TEMPORAL,",
            "        \"date\": GenericDataType.TEMPORAL,",
            "    }",
            "",
            "    columns_by_name = (",
            "        {column.column_name: column for column in datasource.columns}",
            "        if datasource",
            "        else {}",
            "    )",
            "    generic_types: List[GenericDataType] = []",
            "    for column in df.columns:",
            "        column_object = columns_by_name.get(column)",
            "        series = df[column]",
            "        inferred_type = infer_dtype(series)",
            "        generic_type = (",
            "            GenericDataType.TEMPORAL",
            "            if column_object and column_object.is_dttm",
            "            else inferred_type_map.get(inferred_type, GenericDataType.STRING)",
            "        )",
            "        generic_types.append(generic_type)",
            "",
            "    return generic_types",
            "",
            "",
            "def extract_column_dtype(col: \"BaseColumn\") -> GenericDataType:",
            "    if col.is_temporal:",
            "        return GenericDataType.TEMPORAL",
            "    if col.is_numeric:",
            "        return GenericDataType.NUMERIC",
            "    # TODO: add check for boolean data type when proper support is added",
            "    return GenericDataType.STRING",
            "",
            "",
            "def indexed(",
            "    items: List[Any], key: Union[str, Callable[[Any], Any]]",
            ") -> Dict[Any, List[Any]]:",
            "    \"\"\"Build an index for a list of objects\"\"\"",
            "    idx: Dict[Any, Any] = {}",
            "    for item in items:",
            "        key_ = getattr(item, key) if isinstance(key, str) else key(item)",
            "        idx.setdefault(key_, []).append(item)",
            "    return idx",
            "",
            "",
            "def is_test() -> bool:",
            "    return strtobool(os.environ.get(\"SUPERSET_TESTENV\", \"false\"))",
            "",
            "",
            "def get_time_filter_status(",
            "    datasource: \"BaseDatasource\",",
            "    applied_time_extras: Dict[str, str],",
            ") -> Tuple[List[Dict[str, str]], List[Dict[str, str]]]:",
            "    temporal_columns = {col.column_name for col in datasource.columns if col.is_dttm}",
            "    applied: List[Dict[str, str]] = []",
            "    rejected: List[Dict[str, str]] = []",
            "    time_column = applied_time_extras.get(ExtraFiltersTimeColumnType.TIME_COL)",
            "    if time_column:",
            "        if time_column in temporal_columns:",
            "            applied.append({\"column\": ExtraFiltersTimeColumnType.TIME_COL})",
            "        else:",
            "            rejected.append(",
            "                {",
            "                    \"reason\": ExtraFiltersReasonType.COL_NOT_IN_DATASOURCE,",
            "                    \"column\": ExtraFiltersTimeColumnType.TIME_COL,",
            "                }",
            "            )",
            "",
            "    if ExtraFiltersTimeColumnType.TIME_GRAIN in applied_time_extras:",
            "        # are there any temporal columns to assign the time grain to?",
            "        if temporal_columns:",
            "            applied.append({\"column\": ExtraFiltersTimeColumnType.TIME_GRAIN})",
            "        else:",
            "            rejected.append(",
            "                {",
            "                    \"reason\": ExtraFiltersReasonType.NO_TEMPORAL_COLUMN,",
            "                    \"column\": ExtraFiltersTimeColumnType.TIME_GRAIN,",
            "                }",
            "            )",
            "",
            "    time_range = applied_time_extras.get(ExtraFiltersTimeColumnType.TIME_RANGE)",
            "    if time_range:",
            "        # are there any temporal columns to assign the time grain to?",
            "        if temporal_columns:",
            "            applied.append({\"column\": ExtraFiltersTimeColumnType.TIME_RANGE})",
            "        else:",
            "            rejected.append(",
            "                {",
            "                    \"reason\": ExtraFiltersReasonType.NO_TEMPORAL_COLUMN,",
            "                    \"column\": ExtraFiltersTimeColumnType.TIME_RANGE,",
            "                }",
            "            )",
            "",
            "    if ExtraFiltersTimeColumnType.TIME_ORIGIN in applied_time_extras:",
            "        if datasource.type == \"druid\":",
            "            applied.append({\"column\": ExtraFiltersTimeColumnType.TIME_ORIGIN})",
            "        else:",
            "            rejected.append(",
            "                {",
            "                    \"reason\": ExtraFiltersReasonType.NOT_DRUID_DATASOURCE,",
            "                    \"column\": ExtraFiltersTimeColumnType.TIME_ORIGIN,",
            "                }",
            "            )",
            "",
            "    if ExtraFiltersTimeColumnType.GRANULARITY in applied_time_extras:",
            "        if datasource.type == \"druid\":",
            "            applied.append({\"column\": ExtraFiltersTimeColumnType.GRANULARITY})",
            "        else:",
            "            rejected.append(",
            "                {",
            "                    \"reason\": ExtraFiltersReasonType.NOT_DRUID_DATASOURCE,",
            "                    \"column\": ExtraFiltersTimeColumnType.GRANULARITY,",
            "                }",
            "            )",
            "",
            "    return applied, rejected",
            "",
            "",
            "def format_list(items: Sequence[str], sep: str = \", \", quote: str = '\"') -> str:",
            "    quote_escaped = \"\\\\\" + quote",
            "    return sep.join(f\"{quote}{x.replace(quote, quote_escaped)}{quote}\" for x in items)",
            "",
            "",
            "def find_duplicates(items: Iterable[InputType]) -> List[InputType]:",
            "    \"\"\"Find duplicate items in an iterable.\"\"\"",
            "    return [item for item, count in collections.Counter(items).items() if count > 1]",
            "",
            "",
            "def remove_duplicates(",
            "    items: Iterable[InputType], key: Optional[Callable[[InputType], Any]] = None",
            ") -> List[InputType]:",
            "    \"\"\"Remove duplicate items in an iterable.\"\"\"",
            "    if not key:",
            "        return list(dict.fromkeys(items).keys())",
            "    seen = set()",
            "    result = []",
            "    for item in items:",
            "        item_key = key(item)",
            "        if item_key not in seen:",
            "            seen.add(item_key)",
            "            result.append(item)",
            "    return result",
            "",
            "",
            "def normalize_dttm_col(",
            "    df: pd.DataFrame,",
            "    timestamp_format: Optional[str],",
            "    offset: int,",
            "    time_shift: Optional[timedelta],",
            ") -> None:",
            "    if DTTM_ALIAS not in df.columns:",
            "        return",
            "    if timestamp_format in (\"epoch_s\", \"epoch_ms\"):",
            "        dttm_col = df[DTTM_ALIAS]",
            "        if is_numeric_dtype(dttm_col):",
            "            # Column is formatted as a numeric value",
            "            unit = timestamp_format.replace(\"epoch_\", \"\")",
            "            df[DTTM_ALIAS] = pd.to_datetime(",
            "                dttm_col, utc=False, unit=unit, origin=\"unix\", errors=\"coerce\"",
            "            )",
            "        else:",
            "            # Column has already been formatted as a timestamp.",
            "            df[DTTM_ALIAS] = dttm_col.apply(pd.Timestamp)",
            "    else:",
            "        df[DTTM_ALIAS] = pd.to_datetime(",
            "            df[DTTM_ALIAS], utc=False, format=timestamp_format, errors=\"coerce\"",
            "        )",
            "    if offset:",
            "        df[DTTM_ALIAS] += timedelta(hours=offset)",
            "    if time_shift is not None:",
            "        df[DTTM_ALIAS] += time_shift",
            "",
            "",
            "def parse_boolean_string(bool_str: Optional[str]) -> bool:",
            "    \"\"\"",
            "    Convert a string representation of a true/false value into a boolean",
            "",
            "    >>> parse_boolean_string(None)",
            "    False",
            "    >>> parse_boolean_string('false')",
            "    False",
            "    >>> parse_boolean_string('true')",
            "    True",
            "    >>> parse_boolean_string('False')",
            "    False",
            "    >>> parse_boolean_string('True')",
            "    True",
            "    >>> parse_boolean_string('foo')",
            "    False",
            "    >>> parse_boolean_string('0')",
            "    False",
            "    >>> parse_boolean_string('1')",
            "    True",
            "",
            "    :param bool_str: string representation of a value that is assumed to be boolean",
            "    :return: parsed boolean value",
            "    \"\"\"",
            "    if bool_str is None:",
            "        return False",
            "    try:",
            "        return bool(strtobool(bool_str.lower()))",
            "    except ValueError:",
            "        return False",
            "",
            "",
            "def apply_max_row_limit(",
            "    limit: int,",
            "    max_limit: Optional[int] = None,",
            ") -> int:",
            "    \"\"\"",
            "    Override row limit if max global limit is defined",
            "",
            "    :param limit: requested row limit",
            "    :param max_limit: Maximum allowed row limit",
            "    :return: Capped row limit",
            "",
            "    >>> apply_max_row_limit(100000, 10)",
            "    10",
            "    >>> apply_max_row_limit(10, 100000)",
            "    10",
            "    >>> apply_max_row_limit(0, 10000)",
            "    10000",
            "    \"\"\"",
            "    if max_limit is None:",
            "        max_limit = current_app.config[\"SQL_MAX_ROW\"]",
            "    if limit != 0:",
            "        return min(max_limit, limit)",
            "    return max_limit",
            "",
            "",
            "def create_zip(files: Dict[str, Any]) -> BytesIO:",
            "    buf = BytesIO()",
            "    with ZipFile(buf, \"w\") as bundle:",
            "        for filename, contents in files.items():",
            "            with bundle.open(filename, \"w\") as fp:",
            "                fp.write(contents)",
            "    buf.seek(0)",
            "    return buf"
        ],
        "afterPatchFile": [
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "\"\"\"Utility functions used across Superset\"\"\"",
            "# pylint: disable=too-many-lines",
            "import _thread",
            "import collections",
            "import decimal",
            "import errno",
            "import json",
            "import logging",
            "import os",
            "import platform",
            "import re",
            "import signal",
            "import smtplib",
            "import ssl",
            "import tempfile",
            "import threading",
            "import traceback",
            "import uuid",
            "import zlib",
            "from datetime import date, datetime, time, timedelta",
            "from distutils.util import strtobool",
            "from email.mime.application import MIMEApplication",
            "from email.mime.image import MIMEImage",
            "from email.mime.multipart import MIMEMultipart",
            "from email.mime.text import MIMEText",
            "from email.utils import formatdate",
            "from enum import Enum, IntEnum",
            "from io import BytesIO",
            "from timeit import default_timer",
            "from types import TracebackType",
            "from typing import (",
            "    Any,",
            "    Callable,",
            "    cast,",
            "    Dict,",
            "    Iterable,",
            "    Iterator,",
            "    List,",
            "    NamedTuple,",
            "    Optional,",
            "    Sequence,",
            "    Set,",
            "    Tuple,",
            "    Type,",
            "    TYPE_CHECKING,",
            "    TypeVar,",
            "    Union,",
            ")",
            "from urllib.parse import unquote_plus",
            "from zipfile import ZipFile",
            "",
            "import bleach",
            "import markdown as md",
            "import numpy as np",
            "import pandas as pd",
            "import sqlalchemy as sa",
            "from cryptography import x509",
            "from cryptography.hazmat.backends import default_backend",
            "from cryptography.hazmat.backends.openssl.x509 import _Certificate",
            "from flask import current_app, flash, g, Markup, render_template, request",
            "from flask_appbuilder import SQLA",
            "from flask_appbuilder.security.sqla.models import Role, User",
            "from flask_babel import gettext as __",
            "from flask_babel.speaklater import LazyString",
            "from pandas.api.types import infer_dtype",
            "from pandas.core.dtypes.common import is_numeric_dtype",
            "from sqlalchemy import event, exc, inspect, select, Text",
            "from sqlalchemy.dialects.mysql import MEDIUMTEXT",
            "from sqlalchemy.engine import Connection, Engine",
            "from sqlalchemy.engine.reflection import Inspector",
            "from sqlalchemy.sql.type_api import Variant",
            "from sqlalchemy.types import TEXT, TypeDecorator, TypeEngine",
            "from typing_extensions import TypedDict, TypeGuard",
            "",
            "from superset.constants import (",
            "    EXTRA_FORM_DATA_APPEND_KEYS,",
            "    EXTRA_FORM_DATA_OVERRIDE_EXTRA_KEYS,",
            "    EXTRA_FORM_DATA_OVERRIDE_REGULAR_MAPPINGS,",
            ")",
            "from superset.errors import ErrorLevel, SupersetErrorType",
            "from superset.exceptions import (",
            "    CertificateException,",
            "    SupersetException,",
            "    SupersetTimeoutException,",
            ")",
            "from superset.sql_parse import sanitize_clause",
            "from superset.superset_typing import (",
            "    AdhocColumn,",
            "    AdhocMetric,",
            "    AdhocMetricColumn,",
            "    Column,",
            "    FilterValues,",
            "    FlaskResponse,",
            "    FormData,",
            "    Metric,",
            ")",
            "from superset.utils.database import get_example_database",
            "from superset.utils.dates import datetime_to_epoch, EPOCH",
            "from superset.utils.hashing import md5_sha_from_dict, md5_sha_from_str",
            "",
            "try:",
            "    from pydruid.utils.having import Having",
            "except ImportError:",
            "    pass",
            "",
            "if TYPE_CHECKING:",
            "    from superset.connectors.base.models import BaseColumn, BaseDatasource",
            "",
            "logging.getLogger(\"MARKDOWN\").setLevel(logging.INFO)",
            "logger = logging.getLogger(__name__)",
            "",
            "DTTM_ALIAS = \"__timestamp\"",
            "",
            "NO_TIME_RANGE = \"No filter\"",
            "",
            "TIME_COMPARISION = \"__\"",
            "",
            "JS_MAX_INTEGER = 9007199254740991  # Largest int Java Script can handle 2^53-1",
            "",
            "InputType = TypeVar(\"InputType\")",
            "",
            "",
            "class LenientEnum(Enum):",
            "    \"\"\"Enums with a `get` method that convert a enum value to `Enum` if it is a",
            "    valid value.\"\"\"",
            "",
            "    @classmethod",
            "    def get(cls, value: Any) -> Any:",
            "        try:",
            "            return super().__new__(cls, value)",
            "        except ValueError:",
            "            return None",
            "",
            "",
            "class AdhocMetricExpressionType(str, Enum):",
            "    SIMPLE = \"SIMPLE\"",
            "    SQL = \"SQL\"",
            "",
            "",
            "class AnnotationType(str, Enum):",
            "    FORMULA = \"FORMULA\"",
            "    INTERVAL = \"INTERVAL\"",
            "    EVENT = \"EVENT\"",
            "    TIME_SERIES = \"TIME_SERIES\"",
            "",
            "",
            "class GenericDataType(IntEnum):",
            "    \"\"\"",
            "    Generic database column type that fits both frontend and backend.",
            "    \"\"\"",
            "",
            "    NUMERIC = 0",
            "    STRING = 1",
            "    TEMPORAL = 2",
            "    BOOLEAN = 3",
            "    # ARRAY = 4     # Mapping all the complex data types to STRING for now",
            "    # JSON = 5      # and leaving these as a reminder.",
            "    # MAP = 6",
            "    # ROW = 7",
            "",
            "",
            "class DatasourceType(str, Enum):",
            "    SLTABLE = \"sl_table\"",
            "    TABLE = \"table\"",
            "    DATASET = \"dataset\"",
            "    QUERY = \"query\"",
            "    SAVEDQUERY = \"saved_query\"",
            "    VIEW = \"view\"",
            "",
            "",
            "class DatasourceDict(TypedDict):",
            "    type: str",
            "    id: int",
            "",
            "",
            "class AdhocFilterClause(TypedDict, total=False):",
            "    clause: str",
            "    expressionType: str",
            "    filterOptionName: Optional[str]",
            "    comparator: Optional[FilterValues]",
            "    operator: str",
            "    subject: str",
            "    isExtra: Optional[bool]",
            "    sqlExpression: Optional[str]",
            "",
            "",
            "class QueryObjectFilterClause(TypedDict, total=False):",
            "    col: str",
            "    op: str  # pylint: disable=invalid-name",
            "    val: Optional[FilterValues]",
            "    grain: Optional[str]",
            "    isExtra: Optional[bool]",
            "",
            "",
            "class ExtraFiltersTimeColumnType(str, Enum):",
            "    GRANULARITY = \"__granularity\"",
            "    TIME_COL = \"__time_col\"",
            "    TIME_GRAIN = \"__time_grain\"",
            "    TIME_ORIGIN = \"__time_origin\"",
            "    TIME_RANGE = \"__time_range\"",
            "",
            "",
            "class ExtraFiltersReasonType(str, Enum):",
            "    NO_TEMPORAL_COLUMN = \"no_temporal_column\"",
            "    COL_NOT_IN_DATASOURCE = \"not_in_datasource\"",
            "    NOT_DRUID_DATASOURCE = \"not_druid_datasource\"",
            "",
            "",
            "class FilterOperator(str, Enum):",
            "    \"\"\"",
            "    Operators used filter controls",
            "    \"\"\"",
            "",
            "    EQUALS = \"==\"",
            "    NOT_EQUALS = \"!=\"",
            "    GREATER_THAN = \">\"",
            "    LESS_THAN = \"<\"",
            "    GREATER_THAN_OR_EQUALS = \">=\"",
            "    LESS_THAN_OR_EQUALS = \"<=\"",
            "    LIKE = \"LIKE\"",
            "    ILIKE = \"ILIKE\"",
            "    IS_NULL = \"IS NULL\"",
            "    IS_NOT_NULL = \"IS NOT NULL\"",
            "    IN = \"IN\"",
            "    NOT_IN = \"NOT IN\"",
            "    REGEX = \"REGEX\"",
            "    IS_TRUE = \"IS TRUE\"",
            "    IS_FALSE = \"IS FALSE\"",
            "",
            "",
            "class PostProcessingBoxplotWhiskerType(str, Enum):",
            "    \"\"\"",
            "    Calculate cell contribution to row/column total",
            "    \"\"\"",
            "",
            "    TUKEY = \"tukey\"",
            "    MINMAX = \"min/max\"",
            "    PERCENTILE = \"percentile\"",
            "",
            "",
            "class PostProcessingContributionOrientation(str, Enum):",
            "    \"\"\"",
            "    Calculate cell contribution to row/column total",
            "    \"\"\"",
            "",
            "    ROW = \"row\"",
            "    COLUMN = \"column\"",
            "",
            "",
            "class QueryMode(str, LenientEnum):",
            "    \"\"\"",
            "    Whether the query runs on aggregate or returns raw records",
            "    \"\"\"",
            "",
            "    RAW = \"raw\"",
            "    AGGREGATE = \"aggregate\"",
            "",
            "",
            "class QuerySource(Enum):",
            "    \"\"\"",
            "    The source of a SQL query.",
            "    \"\"\"",
            "",
            "    CHART = 0",
            "    DASHBOARD = 1",
            "    SQL_LAB = 2",
            "",
            "",
            "class QueryStatus(str, Enum):",
            "    \"\"\"Enum-type class for query statuses\"\"\"",
            "",
            "    STOPPED: str = \"stopped\"",
            "    FAILED: str = \"failed\"",
            "    PENDING: str = \"pending\"",
            "    RUNNING: str = \"running\"",
            "    SCHEDULED: str = \"scheduled\"",
            "    SUCCESS: str = \"success\"",
            "    FETCHING: str = \"fetching\"",
            "    TIMED_OUT: str = \"timed_out\"",
            "",
            "",
            "class DashboardStatus(str, Enum):",
            "    \"\"\"Dashboard status used for frontend filters\"\"\"",
            "",
            "    PUBLISHED = \"published\"",
            "    DRAFT = \"draft\"",
            "",
            "",
            "class ReservedUrlParameters(str, Enum):",
            "    \"\"\"",
            "    Reserved URL parameters that are used internally by Superset. These will not be",
            "    passed to chart queries, as they control the behavior of the UI.",
            "    \"\"\"",
            "",
            "    STANDALONE = \"standalone\"",
            "    EDIT_MODE = \"edit\"",
            "",
            "    @staticmethod",
            "    def is_standalone_mode() -> Optional[bool]:",
            "        standalone_param = request.args.get(ReservedUrlParameters.STANDALONE.value)",
            "        standalone: Optional[bool] = bool(",
            "            standalone_param and standalone_param != \"false\" and standalone_param != \"0\"",
            "        )",
            "        return standalone",
            "",
            "",
            "class RowLevelSecurityFilterType(str, Enum):",
            "    REGULAR = \"Regular\"",
            "    BASE = \"Base\"",
            "",
            "",
            "class TimeRangeEndpoint(str, Enum):",
            "    \"\"\"",
            "    The time range endpoint types which represent inclusive, exclusive, or unknown.",
            "",
            "    Unknown represents endpoints which are ill-defined as though the interval may be",
            "    [start, end] the filter may behave like (start, end] due to mixed data types and",
            "    lexicographical ordering.",
            "",
            "    :see: https://github.com/apache/superset/issues/6360",
            "    \"\"\"",
            "",
            "    EXCLUSIVE = \"exclusive\"",
            "    INCLUSIVE = \"inclusive\"",
            "    UNKNOWN = \"unknown\"",
            "",
            "",
            "class TemporalType(str, Enum):",
            "    \"\"\"",
            "    Supported temporal types",
            "    \"\"\"",
            "",
            "    DATE = \"DATE\"",
            "    DATETIME = \"DATETIME\"",
            "    SMALLDATETIME = \"SMALLDATETIME\"",
            "    TEXT = \"TEXT\"",
            "    TIME = \"TIME\"",
            "    TIME_WITH_TIME_ZONE = \"TIME WITH TIME ZONE\"",
            "    TIMESTAMP = \"TIMESTAMP\"",
            "    TIMESTAMP_WITH_TIME_ZONE = \"TIMESTAMP WITH TIME ZONE\"",
            "",
            "",
            "class ColumnTypeSource(Enum):",
            "    GET_TABLE = 1",
            "    CURSOR_DESCRIPION = 2",
            "",
            "",
            "class ColumnSpec(NamedTuple):",
            "    sqla_type: Union[TypeEngine, str]",
            "    generic_type: GenericDataType",
            "    is_dttm: bool",
            "    python_date_format: Optional[str] = None",
            "",
            "",
            "try:",
            "    # Having might not have been imported.",
            "    class DimSelector(Having):",
            "        def __init__(self, **args: Any) -> None:",
            "            # Just a hack to prevent any exceptions",
            "            Having.__init__(self, type=\"equalTo\", aggregation=None, value=None)",
            "",
            "            self.having = {",
            "                \"having\": {",
            "                    \"type\": \"dimSelector\",",
            "                    \"dimension\": args[\"dimension\"],",
            "                    \"value\": args[\"value\"],",
            "                }",
            "            }",
            "",
            "except NameError:",
            "    pass",
            "",
            "",
            "def flasher(msg: str, severity: str = \"message\") -> None:",
            "    \"\"\"Flask's flash if available, logging call if not\"\"\"",
            "    try:",
            "        flash(msg, severity)",
            "    except RuntimeError:",
            "        if severity == \"danger\":",
            "            logger.error(msg, exc_info=True)",
            "        else:",
            "            logger.info(msg)",
            "",
            "",
            "def parse_js_uri_path_item(",
            "    item: Optional[str], unquote: bool = True, eval_undefined: bool = False",
            ") -> Optional[str]:",
            "    \"\"\"Parse a uri path item made with js.",
            "",
            "    :param item: a uri path component",
            "    :param unquote: Perform unquoting of string using urllib.parse.unquote_plus()",
            "    :param eval_undefined: When set to True and item is either 'null'  or 'undefined',",
            "    assume item is undefined and return None.",
            "    :return: Either None, the original item or unquoted item",
            "    \"\"\"",
            "    item = None if eval_undefined and item in (\"null\", \"undefined\") else item",
            "    return unquote_plus(item) if unquote and item else item",
            "",
            "",
            "def cast_to_num(value: Optional[Union[float, int, str]]) -> Optional[Union[float, int]]:",
            "    \"\"\"Casts a value to an int/float",
            "",
            "    >>> cast_to_num('1 ')",
            "    1.0",
            "    >>> cast_to_num(' 2')",
            "    2.0",
            "    >>> cast_to_num('5')",
            "    5",
            "    >>> cast_to_num('5.2')",
            "    5.2",
            "    >>> cast_to_num(10)",
            "    10",
            "    >>> cast_to_num(10.1)",
            "    10.1",
            "    >>> cast_to_num(None) is None",
            "    True",
            "    >>> cast_to_num('this is not a string') is None",
            "    True",
            "",
            "    :param value: value to be converted to numeric representation",
            "    :returns: value cast to `int` if value is all digits, `float` if `value` is",
            "              decimal value and `None`` if it can't be converted",
            "    \"\"\"",
            "    if value is None:",
            "        return None",
            "    if isinstance(value, (int, float)):",
            "        return value",
            "    if value.isdigit():",
            "        return int(value)",
            "    try:",
            "        return float(value)",
            "    except ValueError:",
            "        return None",
            "",
            "",
            "def cast_to_boolean(value: Any) -> Optional[bool]:",
            "    \"\"\"Casts a value to an int/float",
            "",
            "    >>> cast_to_boolean(1)",
            "    True",
            "    >>> cast_to_boolean(0)",
            "    False",
            "    >>> cast_to_boolean(0.5)",
            "    True",
            "    >>> cast_to_boolean('true')",
            "    True",
            "    >>> cast_to_boolean('false')",
            "    False",
            "    >>> cast_to_boolean('False')",
            "    False",
            "    >>> cast_to_boolean(None)",
            "",
            "    :param value: value to be converted to boolean representation",
            "    :returns: value cast to `bool`. when value is 'true' or value that are not 0",
            "              converted into True. Return `None` if value is `None`",
            "    \"\"\"",
            "    if value is None:",
            "        return None",
            "    if isinstance(value, (int, float)):",
            "        return value != 0",
            "    if isinstance(value, str):",
            "        return value.strip().lower() == \"true\"",
            "    return False",
            "",
            "",
            "def list_minus(l: List[Any], minus: List[Any]) -> List[Any]:",
            "    \"\"\"Returns l without what is in minus",
            "",
            "    >>> list_minus([1, 2, 3], [2])",
            "    [1, 3]",
            "    \"\"\"",
            "    return [o for o in l if o not in minus]",
            "",
            "",
            "class DashboardEncoder(json.JSONEncoder):",
            "    def __init__(self, *args: Any, **kwargs: Any) -> None:",
            "        super().__init__(*args, **kwargs)",
            "        self.sort_keys = True",
            "",
            "    def default(self, o: Any) -> Union[Dict[Any, Any], str]:",
            "        if isinstance(o, uuid.UUID):",
            "            return str(o)",
            "        try:",
            "            vals = {k: v for k, v in o.__dict__.items() if k != \"_sa_instance_state\"}",
            "            return {\"__{}__\".format(o.__class__.__name__): vals}",
            "        except Exception:  # pylint: disable=broad-except",
            "            if isinstance(o, datetime):",
            "                return {\"__datetime__\": o.replace(microsecond=0).isoformat()}",
            "            return json.JSONEncoder(sort_keys=True).default(o)",
            "",
            "",
            "class JSONEncodedDict(TypeDecorator):  # pylint: disable=abstract-method",
            "    \"\"\"Represents an immutable structure as a json-encoded string.\"\"\"",
            "",
            "    impl = TEXT",
            "",
            "    def process_bind_param(",
            "        self, value: Optional[Dict[Any, Any]], dialect: str",
            "    ) -> Optional[str]:",
            "        return json.dumps(value) if value is not None else None",
            "",
            "    def process_result_value(",
            "        self, value: Optional[str], dialect: str",
            "    ) -> Optional[Dict[Any, Any]]:",
            "        return json.loads(value) if value is not None else None",
            "",
            "",
            "def format_timedelta(time_delta: timedelta) -> str:",
            "    \"\"\"",
            "    Ensures negative time deltas are easily interpreted by humans",
            "",
            "    >>> td = timedelta(0) - timedelta(days=1, hours=5,minutes=6)",
            "    >>> str(td)",
            "    '-2 days, 18:54:00'",
            "    >>> format_timedelta(td)",
            "    '-1 day, 5:06:00'",
            "    \"\"\"",
            "    if time_delta < timedelta(0):",
            "        return \"-\" + str(abs(time_delta))",
            "",
            "    # Change this to format positive time deltas the way you want",
            "    return str(time_delta)",
            "",
            "",
            "def base_json_conv(  # pylint: disable=inconsistent-return-statements",
            "    obj: Any,",
            ") -> Any:",
            "    if isinstance(obj, memoryview):",
            "        obj = obj.tobytes()",
            "    if isinstance(obj, np.int64):",
            "        return int(obj)",
            "    if isinstance(obj, np.bool_):",
            "        return bool(obj)",
            "    if isinstance(obj, np.ndarray):",
            "        return obj.tolist()",
            "    if isinstance(obj, set):",
            "        return list(obj)",
            "    if isinstance(obj, decimal.Decimal):",
            "        return float(obj)",
            "    if isinstance(obj, (uuid.UUID, time, LazyString)):",
            "        return str(obj)",
            "    if isinstance(obj, timedelta):",
            "        return format_timedelta(obj)",
            "    if isinstance(obj, bytes):",
            "        try:",
            "            return obj.decode(\"utf-8\")",
            "        except Exception:  # pylint: disable=broad-except",
            "            return \"[bytes]\"",
            "",
            "",
            "def json_iso_dttm_ser(obj: Any, pessimistic: bool = False) -> str:",
            "    \"\"\"",
            "    json serializer that deals with dates",
            "",
            "    >>> dttm = datetime(1970, 1, 1)",
            "    >>> json.dumps({'dttm': dttm}, default=json_iso_dttm_ser)",
            "    '{\"dttm\": \"1970-01-01T00:00:00\"}'",
            "    \"\"\"",
            "    val = base_json_conv(obj)",
            "    if val is not None:",
            "        return val",
            "    if isinstance(obj, (datetime, date, pd.Timestamp)):",
            "        obj = obj.isoformat()",
            "    else:",
            "        if pessimistic:",
            "            return \"Unserializable [{}]\".format(type(obj))",
            "",
            "        raise TypeError(\"Unserializable object {} of type {}\".format(obj, type(obj)))",
            "    return obj",
            "",
            "",
            "def pessimistic_json_iso_dttm_ser(obj: Any) -> str:",
            "    \"\"\"Proxy to call json_iso_dttm_ser in a pessimistic way",
            "",
            "    If one of object is not serializable to json, it will still succeed\"\"\"",
            "    return json_iso_dttm_ser(obj, pessimistic=True)",
            "",
            "",
            "def json_int_dttm_ser(obj: Any) -> float:",
            "    \"\"\"json serializer that deals with dates\"\"\"",
            "    val = base_json_conv(obj)",
            "    if val is not None:",
            "        return val",
            "    if isinstance(obj, (datetime, pd.Timestamp)):",
            "        obj = datetime_to_epoch(obj)",
            "    elif isinstance(obj, date):",
            "        obj = (obj - EPOCH.date()).total_seconds() * 1000",
            "    else:",
            "        raise TypeError(\"Unserializable object {} of type {}\".format(obj, type(obj)))",
            "    return obj",
            "",
            "",
            "def json_dumps_w_dates(payload: Dict[Any, Any]) -> str:",
            "    return json.dumps(payload, default=json_int_dttm_ser)",
            "",
            "",
            "def error_msg_from_exception(ex: Exception) -> str:",
            "    \"\"\"Translate exception into error message",
            "",
            "    Database have different ways to handle exception. This function attempts",
            "    to make sense of the exception object and construct a human readable",
            "    sentence.",
            "",
            "    TODO(bkyryliuk): parse the Presto error message from the connection",
            "                     created via create_engine.",
            "    engine = create_engine('presto://localhost:3506/silver') -",
            "      gives an e.message as the str(dict)",
            "    presto.connect('localhost', port=3506, catalog='silver') - as a dict.",
            "    The latter version is parsed correctly by this function.",
            "    \"\"\"",
            "    msg = \"\"",
            "    if hasattr(ex, \"message\"):",
            "        if isinstance(ex.message, dict):  # type: ignore",
            "            msg = ex.message.get(\"message\")  # type: ignore",
            "        elif ex.message:  # type: ignore",
            "            msg = ex.message  # type: ignore",
            "    return msg or str(ex)",
            "",
            "",
            "def markdown(raw: str, markup_wrap: Optional[bool] = False) -> str:",
            "    safe_markdown_tags = [",
            "        \"h1\",",
            "        \"h2\",",
            "        \"h3\",",
            "        \"h4\",",
            "        \"h5\",",
            "        \"h6\",",
            "        \"b\",",
            "        \"i\",",
            "        \"strong\",",
            "        \"em\",",
            "        \"tt\",",
            "        \"p\",",
            "        \"br\",",
            "        \"span\",",
            "        \"div\",",
            "        \"blockquote\",",
            "        \"code\",",
            "        \"hr\",",
            "        \"ul\",",
            "        \"ol\",",
            "        \"li\",",
            "        \"dd\",",
            "        \"dt\",",
            "        \"img\",",
            "        \"a\",",
            "    ]",
            "    safe_markdown_attrs = {",
            "        \"img\": [\"src\", \"alt\", \"title\"],",
            "        \"a\": [\"href\", \"alt\", \"title\"],",
            "    }",
            "    safe = md.markdown(",
            "        raw or \"\",",
            "        extensions=[",
            "            \"markdown.extensions.tables\",",
            "            \"markdown.extensions.fenced_code\",",
            "            \"markdown.extensions.codehilite\",",
            "        ],",
            "    )",
            "    safe = bleach.clean(safe, safe_markdown_tags, safe_markdown_attrs)",
            "    if markup_wrap:",
            "        safe = Markup(safe)",
            "    return safe",
            "",
            "",
            "def readfile(file_path: str) -> Optional[str]:",
            "    with open(file_path) as f:",
            "        content = f.read()",
            "    return content",
            "",
            "",
            "def generic_find_constraint_name(",
            "    table: str, columns: Set[str], referenced: str, database: SQLA",
            ") -> Optional[str]:",
            "    \"\"\"Utility to find a constraint name in alembic migrations\"\"\"",
            "    tbl = sa.Table(",
            "        table, database.metadata, autoload=True, autoload_with=database.engine",
            "    )",
            "",
            "    for fk in tbl.foreign_key_constraints:",
            "        if fk.referred_table.name == referenced and set(fk.column_keys) == columns:",
            "            return fk.name",
            "",
            "    return None",
            "",
            "",
            "def generic_find_fk_constraint_name(",
            "    table: str, columns: Set[str], referenced: str, insp: Inspector",
            ") -> Optional[str]:",
            "    \"\"\"Utility to find a foreign-key constraint name in alembic migrations\"\"\"",
            "    for fk in insp.get_foreign_keys(table):",
            "        if (",
            "            fk[\"referred_table\"] == referenced",
            "            and set(fk[\"referred_columns\"]) == columns",
            "        ):",
            "            return fk[\"name\"]",
            "",
            "    return None",
            "",
            "",
            "def generic_find_fk_constraint_names(  # pylint: disable=invalid-name",
            "    table: str, columns: Set[str], referenced: str, insp: Inspector",
            ") -> Set[str]:",
            "    \"\"\"Utility to find foreign-key constraint names in alembic migrations\"\"\"",
            "    names = set()",
            "",
            "    for fk in insp.get_foreign_keys(table):",
            "        if (",
            "            fk[\"referred_table\"] == referenced",
            "            and set(fk[\"referred_columns\"]) == columns",
            "        ):",
            "            names.add(fk[\"name\"])",
            "",
            "    return names",
            "",
            "",
            "def generic_find_uq_constraint_name(",
            "    table: str, columns: Set[str], insp: Inspector",
            ") -> Optional[str]:",
            "    \"\"\"Utility to find a unique constraint name in alembic migrations\"\"\"",
            "",
            "    for uq in insp.get_unique_constraints(table):",
            "        if columns == set(uq[\"column_names\"]):",
            "            return uq[\"name\"]",
            "",
            "    return None",
            "",
            "",
            "def get_datasource_full_name(",
            "    database_name: str, datasource_name: str, schema: Optional[str] = None",
            ") -> str:",
            "    if not schema:",
            "        return \"[{}].[{}]\".format(database_name, datasource_name)",
            "    return \"[{}].[{}].[{}]\".format(database_name, schema, datasource_name)",
            "",
            "",
            "def validate_json(obj: Union[bytes, bytearray, str]) -> None:",
            "    if obj:",
            "        try:",
            "            json.loads(obj)",
            "        except Exception as ex:",
            "            logger.error(\"JSON is not valid %s\", str(ex), exc_info=True)",
            "            raise SupersetException(\"JSON is not valid\") from ex",
            "",
            "",
            "class SigalrmTimeout:",
            "    \"\"\"",
            "    To be used in a ``with`` block and timeout its content.",
            "    \"\"\"",
            "",
            "    def __init__(self, seconds: int = 1, error_message: str = \"Timeout\") -> None:",
            "        self.seconds = seconds",
            "        self.error_message = error_message",
            "",
            "    def handle_timeout(  # pylint: disable=unused-argument",
            "        self, signum: int, frame: Any",
            "    ) -> None:",
            "        logger.error(\"Process timed out\", exc_info=True)",
            "        raise SupersetTimeoutException(",
            "            error_type=SupersetErrorType.BACKEND_TIMEOUT_ERROR,",
            "            message=self.error_message,",
            "            level=ErrorLevel.ERROR,",
            "            extra={\"timeout\": self.seconds},",
            "        )",
            "",
            "    def __enter__(self) -> None:",
            "        try:",
            "            if threading.current_thread() == threading.main_thread():",
            "                signal.signal(signal.SIGALRM, self.handle_timeout)",
            "                signal.alarm(self.seconds)",
            "        except ValueError as ex:",
            "            logger.warning(\"timeout can't be used in the current context\")",
            "            logger.exception(ex)",
            "",
            "    def __exit__(  # pylint: disable=redefined-outer-name,redefined-builtin",
            "        self, type: Any, value: Any, traceback: TracebackType",
            "    ) -> None:",
            "        try:",
            "            signal.alarm(0)",
            "        except ValueError as ex:",
            "            logger.warning(\"timeout can't be used in the current context\")",
            "            logger.exception(ex)",
            "",
            "",
            "class TimerTimeout:",
            "    def __init__(self, seconds: int = 1, error_message: str = \"Timeout\") -> None:",
            "        self.seconds = seconds",
            "        self.error_message = error_message",
            "        self.timer = threading.Timer(seconds, _thread.interrupt_main)",
            "",
            "    def __enter__(self) -> None:",
            "        self.timer.start()",
            "",
            "    def __exit__(  # pylint: disable=redefined-outer-name,redefined-builtin",
            "        self, type: Any, value: Any, traceback: TracebackType",
            "    ) -> None:",
            "        self.timer.cancel()",
            "        if type is KeyboardInterrupt:  # raised by _thread.interrupt_main",
            "            raise SupersetTimeoutException(",
            "                error_type=SupersetErrorType.BACKEND_TIMEOUT_ERROR,",
            "                message=self.error_message,",
            "                level=ErrorLevel.ERROR,",
            "                extra={\"timeout\": self.seconds},",
            "            )",
            "",
            "",
            "# Windows has no support for SIGALRM, so we use the timer based timeout",
            "timeout: Union[Type[TimerTimeout], Type[SigalrmTimeout]] = (",
            "    TimerTimeout if platform.system() == \"Windows\" else SigalrmTimeout",
            ")",
            "",
            "",
            "def pessimistic_connection_handling(some_engine: Engine) -> None:",
            "    @event.listens_for(some_engine, \"engine_connect\")",
            "    def ping_connection(connection: Connection, branch: bool) -> None:",
            "        if branch:",
            "            # 'branch' refers to a sub-connection of a connection,",
            "            # we don't want to bother pinging on these.",
            "            return",
            "",
            "        # turn off 'close with result'.  This flag is only used with",
            "        # 'connectionless' execution, otherwise will be False in any case",
            "        save_should_close_with_result = connection.should_close_with_result",
            "        connection.should_close_with_result = False",
            "",
            "        try:",
            "            # run a SELECT 1.   use a core select() so that",
            "            # the SELECT of a scalar value without a table is",
            "            # appropriately formatted for the backend",
            "            connection.scalar(select([1]))",
            "        except exc.DBAPIError as err:",
            "            # catch SQLAlchemy's DBAPIError, which is a wrapper",
            "            # for the DBAPI's exception.  It includes a .connection_invalidated",
            "            # attribute which specifies if this connection is a 'disconnect'",
            "            # condition, which is based on inspection of the original exception",
            "            # by the dialect in use.",
            "            if err.connection_invalidated:",
            "                # run the same SELECT again - the connection will re-validate",
            "                # itself and establish a new connection.  The disconnect detection",
            "                # here also causes the whole connection pool to be invalidated",
            "                # so that all stale connections are discarded.",
            "                connection.scalar(select([1]))",
            "            else:",
            "                raise",
            "        finally:",
            "            # restore 'close with result'",
            "            connection.should_close_with_result = save_should_close_with_result",
            "",
            "",
            "def notify_user_about_perm_udate(  # pylint: disable=too-many-arguments",
            "    granter: User,",
            "    user: User,",
            "    role: Role,",
            "    datasource: \"BaseDatasource\",",
            "    tpl_name: str,",
            "    config: Dict[str, Any],",
            ") -> None:",
            "    msg = render_template(",
            "        tpl_name, granter=granter, user=user, role=role, datasource=datasource",
            "    )",
            "    logger.info(msg)",
            "    subject = __(",
            "        \"[Superset] Access to the datasource %(name)s was granted\",",
            "        name=datasource.full_name,",
            "    )",
            "    send_email_smtp(",
            "        user.email,",
            "        subject,",
            "        msg,",
            "        config,",
            "        bcc=granter.email,",
            "        dryrun=not config[\"EMAIL_NOTIFICATIONS\"],",
            "    )",
            "",
            "",
            "def send_email_smtp(  # pylint: disable=invalid-name,too-many-arguments,too-many-locals",
            "    to: str,",
            "    subject: str,",
            "    html_content: str,",
            "    config: Dict[str, Any],",
            "    files: Optional[List[str]] = None,",
            "    data: Optional[Dict[str, str]] = None,",
            "    images: Optional[Dict[str, bytes]] = None,",
            "    dryrun: bool = False,",
            "    cc: Optional[str] = None,",
            "    bcc: Optional[str] = None,",
            "    mime_subtype: str = \"mixed\",",
            ") -> None:",
            "    \"\"\"",
            "    Send an email with html content, eg:",
            "    send_email_smtp(",
            "        'test@example.com', 'foo', '<b>Foo</b> bar',['/dev/null'], dryrun=True)",
            "    \"\"\"",
            "    smtp_mail_from = config[\"SMTP_MAIL_FROM\"]",
            "    smtp_mail_to = get_email_address_list(to)",
            "",
            "    msg = MIMEMultipart(mime_subtype)",
            "    msg[\"Subject\"] = subject",
            "    msg[\"From\"] = smtp_mail_from",
            "    msg[\"To\"] = \", \".join(smtp_mail_to)",
            "    msg.preamble = \"This is a multi-part message in MIME format.\"",
            "",
            "    recipients = smtp_mail_to",
            "    if cc:",
            "        smtp_mail_cc = get_email_address_list(cc)",
            "        msg[\"CC\"] = \", \".join(smtp_mail_cc)",
            "        recipients = recipients + smtp_mail_cc",
            "",
            "    if bcc:",
            "        # don't add bcc in header",
            "        smtp_mail_bcc = get_email_address_list(bcc)",
            "        recipients = recipients + smtp_mail_bcc",
            "",
            "    msg[\"Date\"] = formatdate(localtime=True)",
            "    mime_text = MIMEText(html_content, \"html\")",
            "    msg.attach(mime_text)",
            "",
            "    # Attach files by reading them from disk",
            "    for fname in files or []:",
            "        basename = os.path.basename(fname)",
            "        with open(fname, \"rb\") as f:",
            "            msg.attach(",
            "                MIMEApplication(",
            "                    f.read(),",
            "                    Content_Disposition=\"attachment; filename='%s'\" % basename,",
            "                    Name=basename,",
            "                )",
            "            )",
            "",
            "    # Attach any files passed directly",
            "    for name, body in (data or {}).items():",
            "        msg.attach(",
            "            MIMEApplication(",
            "                body, Content_Disposition=\"attachment; filename='%s'\" % name, Name=name",
            "            )",
            "        )",
            "",
            "    # Attach any inline images, which may be required for display in",
            "    # HTML content (inline)",
            "    for msgid, imgdata in (images or {}).items():",
            "        image = MIMEImage(imgdata)",
            "        image.add_header(\"Content-ID\", \"<%s>\" % msgid)",
            "        image.add_header(\"Content-Disposition\", \"inline\")",
            "        msg.attach(image)",
            "",
            "    send_mime_email(smtp_mail_from, recipients, msg, config, dryrun=dryrun)",
            "",
            "",
            "def send_mime_email(",
            "    e_from: str,",
            "    e_to: List[str],",
            "    mime_msg: MIMEMultipart,",
            "    config: Dict[str, Any],",
            "    dryrun: bool = False,",
            ") -> None:",
            "    smtp_host = config[\"SMTP_HOST\"]",
            "    smtp_port = config[\"SMTP_PORT\"]",
            "    smtp_user = config[\"SMTP_USER\"]",
            "    smtp_password = config[\"SMTP_PASSWORD\"]",
            "    smtp_starttls = config[\"SMTP_STARTTLS\"]",
            "    smtp_ssl = config[\"SMTP_SSL\"]",
            "    smpt_ssl_server_auth = config[\"SMTP_SSL_SERVER_AUTH\"]",
            "",
            "    if dryrun:",
            "        logger.info(\"Dryrun enabled, email notification content is below:\")",
            "        logger.info(mime_msg.as_string())",
            "        return",
            "",
            "    # Default ssl context is SERVER_AUTH using the default system",
            "    # root CA certificates",
            "    ssl_context = ssl.create_default_context() if smpt_ssl_server_auth else None",
            "    smtp = (",
            "        smtplib.SMTP_SSL(smtp_host, smtp_port, context=ssl_context)",
            "        if smtp_ssl",
            "        else smtplib.SMTP(smtp_host, smtp_port)",
            "    )",
            "    if smtp_starttls:",
            "        smtp.starttls(context=ssl_context)",
            "    if smtp_user and smtp_password:",
            "        smtp.login(smtp_user, smtp_password)",
            "    logger.debug(\"Sent an email to %s\", str(e_to))",
            "    smtp.sendmail(e_from, e_to, mime_msg.as_string())",
            "    smtp.quit()",
            "",
            "",
            "def get_email_address_list(address_string: str) -> List[str]:",
            "    address_string_list: List[str] = []",
            "    if isinstance(address_string, str):",
            "        address_string_list = re.split(r\",|\\s|;\", address_string)",
            "    return [x.strip() for x in address_string_list if x.strip()]",
            "",
            "",
            "def get_email_address_str(address_string: str) -> str:",
            "    address_list = get_email_address_list(address_string)",
            "    address_list_str = \", \".join(address_list)",
            "",
            "    return address_list_str",
            "",
            "",
            "def choicify(values: Iterable[Any]) -> List[Tuple[Any, Any]]:",
            "    \"\"\"Takes an iterable and makes an iterable of tuples with it\"\"\"",
            "    return [(v, v) for v in values]",
            "",
            "",
            "def zlib_compress(data: Union[bytes, str]) -> bytes:",
            "    \"\"\"",
            "    Compress things in a py2/3 safe fashion",
            "    >>> json_str = '{\"test\": 1}'",
            "    >>> blob = zlib_compress(json_str)",
            "    \"\"\"",
            "    if isinstance(data, str):",
            "        return zlib.compress(bytes(data, \"utf-8\"))",
            "    return zlib.compress(data)",
            "",
            "",
            "def zlib_decompress(blob: bytes, decode: Optional[bool] = True) -> Union[bytes, str]:",
            "    \"\"\"",
            "    Decompress things to a string in a py2/3 safe fashion",
            "    >>> json_str = '{\"test\": 1}'",
            "    >>> blob = zlib_compress(json_str)",
            "    >>> got_str = zlib_decompress(blob)",
            "    >>> got_str == json_str",
            "    True",
            "    \"\"\"",
            "    if isinstance(blob, bytes):",
            "        decompressed = zlib.decompress(blob)",
            "    else:",
            "        decompressed = zlib.decompress(bytes(blob, \"utf-8\"))",
            "    return decompressed.decode(\"utf-8\") if decode else decompressed",
            "",
            "",
            "def simple_filter_to_adhoc(",
            "    filter_clause: QueryObjectFilterClause,",
            "    clause: str = \"where\",",
            ") -> AdhocFilterClause:",
            "    result: AdhocFilterClause = {",
            "        \"clause\": clause.upper(),",
            "        \"expressionType\": \"SIMPLE\",",
            "        \"comparator\": filter_clause.get(\"val\"),",
            "        \"operator\": filter_clause[\"op\"],",
            "        \"subject\": filter_clause[\"col\"],",
            "    }",
            "    if filter_clause.get(\"isExtra\"):",
            "        result[\"isExtra\"] = True",
            "    result[\"filterOptionName\"] = md5_sha_from_dict(cast(Dict[Any, Any], result))",
            "",
            "    return result",
            "",
            "",
            "def form_data_to_adhoc(form_data: Dict[str, Any], clause: str) -> AdhocFilterClause:",
            "    if clause not in (\"where\", \"having\"):",
            "        raise ValueError(__(\"Unsupported clause type: %(clause)s\", clause=clause))",
            "    result: AdhocFilterClause = {",
            "        \"clause\": clause.upper(),",
            "        \"expressionType\": \"SQL\",",
            "        \"sqlExpression\": form_data.get(clause),",
            "    }",
            "    result[\"filterOptionName\"] = md5_sha_from_dict(cast(Dict[Any, Any], result))",
            "",
            "    return result",
            "",
            "",
            "def merge_extra_form_data(form_data: Dict[str, Any]) -> None:",
            "    \"\"\"",
            "    Merge extra form data (appends and overrides) into the main payload",
            "    and add applied time extras to the payload.",
            "    \"\"\"",
            "    filter_keys = [\"filters\", \"adhoc_filters\"]",
            "    extra_form_data = form_data.pop(\"extra_form_data\", {})",
            "    append_filters: List[QueryObjectFilterClause] = extra_form_data.get(\"filters\", None)",
            "",
            "    # merge append extras",
            "    for key in [key for key in EXTRA_FORM_DATA_APPEND_KEYS if key not in filter_keys]:",
            "        extra_value = getattr(extra_form_data, key, {})",
            "        form_value = getattr(form_data, key, {})",
            "        form_value.update(extra_value)",
            "        if form_value:",
            "            form_data[\"key\"] = extra_value",
            "",
            "    # map regular extras that apply to form data properties",
            "    for src_key, target_key in EXTRA_FORM_DATA_OVERRIDE_REGULAR_MAPPINGS.items():",
            "        value = extra_form_data.get(src_key)",
            "        if value is not None:",
            "            form_data[target_key] = value",
            "",
            "    # map extras that apply to form data extra properties",
            "    extras = form_data.get(\"extras\", {})",
            "    for key in EXTRA_FORM_DATA_OVERRIDE_EXTRA_KEYS:",
            "        value = extra_form_data.get(key)",
            "        if value is not None:",
            "            extras[key] = value",
            "    if extras:",
            "        form_data[\"extras\"] = extras",
            "",
            "    adhoc_filters: List[AdhocFilterClause] = form_data.get(\"adhoc_filters\", [])",
            "    form_data[\"adhoc_filters\"] = adhoc_filters",
            "    append_adhoc_filters: List[AdhocFilterClause] = extra_form_data.get(",
            "        \"adhoc_filters\", []",
            "    )",
            "    adhoc_filters.extend(",
            "        {\"isExtra\": True, **fltr} for fltr in append_adhoc_filters  # type: ignore",
            "    )",
            "    if append_filters:",
            "        for key, value in form_data.items():",
            "            if re.match(\"adhoc_filter.*\", key):",
            "                value.extend(",
            "                    simple_filter_to_adhoc({\"isExtra\": True, **fltr})  # type: ignore",
            "                    for fltr in append_filters",
            "                    if fltr",
            "                )",
            "",
            "",
            "def merge_extra_filters(form_data: Dict[str, Any]) -> None:",
            "    # extra_filters are temporary/contextual filters (using the legacy constructs)",
            "    # that are external to the slice definition. We use those for dynamic",
            "    # interactive filters like the ones emitted by the \"Filter Box\" visualization.",
            "    # Note extra_filters only support simple filters.",
            "    applied_time_extras: Dict[str, str] = {}",
            "    form_data[\"applied_time_extras\"] = applied_time_extras",
            "    adhoc_filters = form_data.get(\"adhoc_filters\", [])",
            "    form_data[\"adhoc_filters\"] = adhoc_filters",
            "    merge_extra_form_data(form_data)",
            "    if \"extra_filters\" in form_data:",
            "        # __form and __to are special extra_filters that target time",
            "        # boundaries. The rest of extra_filters are simple",
            "        # [column_name in list_of_values]. `__` prefix is there to avoid",
            "        # potential conflicts with column that would be named `from` or `to`",
            "        date_options = {",
            "            \"__time_range\": \"time_range\",",
            "            \"__time_col\": \"granularity_sqla\",",
            "            \"__time_grain\": \"time_grain_sqla\",",
            "            \"__time_origin\": \"druid_time_origin\",",
            "            \"__granularity\": \"granularity\",",
            "        }",
            "        # Grab list of existing filters 'keyed' on the column and operator",
            "",
            "        def get_filter_key(f: Dict[str, Any]) -> str:",
            "            if \"expressionType\" in f:",
            "                return \"{}__{}\".format(f[\"subject\"], f[\"operator\"])",
            "",
            "            return \"{}__{}\".format(f[\"col\"], f[\"op\"])",
            "",
            "        existing_filters = {}",
            "        for existing in adhoc_filters:",
            "            if (",
            "                existing[\"expressionType\"] == \"SIMPLE\"",
            "                and existing.get(\"comparator\") is not None",
            "                and existing.get(\"subject\") is not None",
            "            ):",
            "                existing_filters[get_filter_key(existing)] = existing[\"comparator\"]",
            "",
            "        for filtr in form_data[  # pylint: disable=too-many-nested-blocks",
            "            \"extra_filters\"",
            "        ]:",
            "            filtr[\"isExtra\"] = True",
            "            # Pull out time filters/options and merge into form data",
            "            filter_column = filtr[\"col\"]",
            "            time_extra = date_options.get(filter_column)",
            "            if time_extra:",
            "                time_extra_value = filtr.get(\"val\")",
            "                if time_extra_value and time_extra_value != NO_TIME_RANGE:",
            "                    form_data[time_extra] = time_extra_value",
            "                    applied_time_extras[filter_column] = time_extra_value",
            "            elif filtr[\"val\"]:",
            "                # Merge column filters",
            "                filter_key = get_filter_key(filtr)",
            "                if filter_key in existing_filters:",
            "                    # Check if the filter already exists",
            "                    if isinstance(filtr[\"val\"], list):",
            "                        if isinstance(existing_filters[filter_key], list):",
            "                            # Add filters for unequal lists",
            "                            # order doesn't matter",
            "                            if set(existing_filters[filter_key]) != set(filtr[\"val\"]):",
            "                                adhoc_filters.append(simple_filter_to_adhoc(filtr))",
            "                        else:",
            "                            adhoc_filters.append(simple_filter_to_adhoc(filtr))",
            "                    else:",
            "                        # Do not add filter if same value already exists",
            "                        if filtr[\"val\"] != existing_filters[filter_key]:",
            "                            adhoc_filters.append(simple_filter_to_adhoc(filtr))",
            "                else:",
            "                    # Filter not found, add it",
            "                    adhoc_filters.append(simple_filter_to_adhoc(filtr))",
            "        # Remove extra filters from the form data since no longer needed",
            "        del form_data[\"extra_filters\"]",
            "",
            "",
            "def merge_request_params(form_data: Dict[str, Any], params: Dict[str, Any]) -> None:",
            "    \"\"\"",
            "    Merge request parameters to the key `url_params` in form_data. Only updates",
            "    or appends parameters to `form_data` that are defined in `params; pre-existing",
            "    parameters not defined in params are left unchanged.",
            "",
            "    :param form_data: object to be updated",
            "    :param params: request parameters received via query string",
            "    \"\"\"",
            "    url_params = form_data.get(\"url_params\", {})",
            "    for key, value in params.items():",
            "        if key in (\"form_data\", \"r\"):",
            "            continue",
            "        url_params[key] = value",
            "    form_data[\"url_params\"] = url_params",
            "",
            "",
            "def user_label(user: User) -> Optional[str]:",
            "    \"\"\"Given a user ORM FAB object, returns a label\"\"\"",
            "    if user:",
            "        if user.first_name and user.last_name:",
            "            return user.first_name + \" \" + user.last_name",
            "",
            "        return user.username",
            "",
            "    return None",
            "",
            "",
            "def get_example_default_schema() -> Optional[str]:",
            "    \"\"\"",
            "    Return the default schema of the examples database, if any.",
            "    \"\"\"",
            "    database = get_example_database()",
            "    engine = database.get_sqla_engine()",
            "    return inspect(engine).default_schema_name",
            "",
            "",
            "def backend() -> str:",
            "    return get_example_database().backend",
            "",
            "",
            "def is_adhoc_metric(metric: Metric) -> TypeGuard[AdhocMetric]:",
            "    return isinstance(metric, dict) and \"expressionType\" in metric",
            "",
            "",
            "def is_adhoc_column(column: Column) -> TypeGuard[AdhocColumn]:",
            "    return isinstance(column, dict) and ({\"label\", \"sqlExpression\"}).issubset(",
            "        column.keys()",
            "    )",
            "",
            "",
            "def get_column_name(",
            "    column: Column, verbose_map: Optional[Dict[str, Any]] = None",
            ") -> str:",
            "    \"\"\"",
            "    Extract label from column",
            "",
            "    :param column: object to extract label from",
            "    :param verbose_map: verbose_map from dataset for optional mapping from",
            "                        raw name to verbose name",
            "    :return: String representation of column",
            "    :raises ValueError: if metric object is invalid",
            "    \"\"\"",
            "    if isinstance(column, dict):",
            "        label = column.get(\"label\")",
            "        if label:",
            "            return label",
            "        expr = column.get(\"sqlExpression\")",
            "        if expr:",
            "            return expr",
            "        raise ValueError(\"Missing label\")",
            "    verbose_map = verbose_map or {}",
            "    return verbose_map.get(column, column)",
            "",
            "",
            "def get_metric_name(",
            "    metric: Metric, verbose_map: Optional[Dict[str, Any]] = None",
            ") -> str:",
            "    \"\"\"",
            "    Extract label from metric",
            "",
            "    :param metric: object to extract label from",
            "    :param verbose_map: verbose_map from dataset for optional mapping from",
            "                        raw name to verbose name",
            "    :return: String representation of metric",
            "    :raises ValueError: if metric object is invalid",
            "    \"\"\"",
            "    if is_adhoc_metric(metric):",
            "        label = metric.get(\"label\")",
            "        if label:",
            "            return label",
            "        expression_type = metric.get(\"expressionType\")",
            "        if expression_type == \"SQL\":",
            "            sql_expression = metric.get(\"sqlExpression\")",
            "            if sql_expression:",
            "                return sql_expression",
            "        elif expression_type == \"SIMPLE\":",
            "            column: AdhocMetricColumn = metric.get(\"column\") or {}",
            "            column_name = column.get(\"column_name\")",
            "            aggregate = metric.get(\"aggregate\")",
            "            if column and aggregate:",
            "                return f\"{aggregate}({column_name})\"",
            "            if column_name:",
            "                return column_name",
            "        raise ValueError(__(\"Invalid metric object\"))",
            "",
            "    verbose_map = verbose_map or {}",
            "    return verbose_map.get(metric, metric)  # type: ignore",
            "",
            "",
            "def get_column_names(",
            "    columns: Optional[Sequence[Column]],",
            "    verbose_map: Optional[Dict[str, Any]] = None,",
            ") -> List[str]:",
            "    return [",
            "        column",
            "        for column in [get_column_name(column, verbose_map) for column in columns or []]",
            "        if column",
            "    ]",
            "",
            "",
            "def get_metric_names(",
            "    metrics: Optional[Sequence[Metric]],",
            "    verbose_map: Optional[Dict[str, Any]] = None,",
            ") -> List[str]:",
            "    return [",
            "        metric",
            "        for metric in [get_metric_name(metric, verbose_map) for metric in metrics or []]",
            "        if metric",
            "    ]",
            "",
            "",
            "def get_first_metric_name(",
            "    metrics: Optional[Sequence[Metric]],",
            "    verbose_map: Optional[Dict[str, Any]] = None,",
            ") -> Optional[str]:",
            "    metric_labels = get_metric_names(metrics, verbose_map)",
            "    return metric_labels[0] if metric_labels else None",
            "",
            "",
            "def ensure_path_exists(path: str) -> None:",
            "    try:",
            "        os.makedirs(path)",
            "    except OSError as ex:",
            "        if not (os.path.isdir(path) and ex.errno == errno.EEXIST):",
            "            raise",
            "",
            "",
            "def convert_legacy_filters_into_adhoc(  # pylint: disable=invalid-name",
            "    form_data: FormData,",
            ") -> None:",
            "    mapping = {\"having\": \"having_filters\", \"where\": \"filters\"}",
            "",
            "    if not form_data.get(\"adhoc_filters\"):",
            "        adhoc_filters: List[AdhocFilterClause] = []",
            "        form_data[\"adhoc_filters\"] = adhoc_filters",
            "",
            "        for clause, filters in mapping.items():",
            "            if clause in form_data and form_data[clause] != \"\":",
            "                adhoc_filters.append(form_data_to_adhoc(form_data, clause))",
            "",
            "            if filters in form_data:",
            "                for filt in filter(lambda x: x is not None, form_data[filters]):",
            "                    adhoc_filters.append(simple_filter_to_adhoc(filt, clause))",
            "",
            "    for key in (\"filters\", \"having\", \"having_filters\", \"where\"):",
            "        if key in form_data:",
            "            del form_data[key]",
            "",
            "",
            "def split_adhoc_filters_into_base_filters(  # pylint: disable=invalid-name",
            "    form_data: FormData,",
            ") -> None:",
            "    \"\"\"",
            "    Mutates form data to restructure the adhoc filters in the form of the four base",
            "    filters, `where`, `having`, `filters`, and `having_filters` which represent",
            "    free form where sql, free form having sql, structured where clauses and structured",
            "    having clauses.",
            "    \"\"\"",
            "    adhoc_filters = form_data.get(\"adhoc_filters\")",
            "    if isinstance(adhoc_filters, list):",
            "        simple_where_filters = []",
            "        simple_having_filters = []",
            "        sql_where_filters = []",
            "        sql_having_filters = []",
            "        for adhoc_filter in adhoc_filters:",
            "            expression_type = adhoc_filter.get(\"expressionType\")",
            "            clause = adhoc_filter.get(\"clause\")",
            "            if expression_type == \"SIMPLE\":",
            "                if clause == \"WHERE\":",
            "                    simple_where_filters.append(",
            "                        {",
            "                            \"col\": adhoc_filter.get(\"subject\"),",
            "                            \"op\": adhoc_filter.get(\"operator\"),",
            "                            \"val\": adhoc_filter.get(\"comparator\"),",
            "                        }",
            "                    )",
            "                elif clause == \"HAVING\":",
            "                    simple_having_filters.append(",
            "                        {",
            "                            \"col\": adhoc_filter.get(\"subject\"),",
            "                            \"op\": adhoc_filter.get(\"operator\"),",
            "                            \"val\": adhoc_filter.get(\"comparator\"),",
            "                        }",
            "                    )",
            "            elif expression_type == \"SQL\":",
            "                sql_expression = adhoc_filter.get(\"sqlExpression\")",
            "                sql_expression = sanitize_clause(sql_expression)",
            "                if clause == \"WHERE\":",
            "                    sql_where_filters.append(sql_expression)",
            "                elif clause == \"HAVING\":",
            "                    sql_having_filters.append(sql_expression)",
            "        form_data[\"where\"] = \" AND \".join(",
            "            [\"({})\".format(sql) for sql in sql_where_filters]",
            "        )",
            "        form_data[\"having\"] = \" AND \".join(",
            "            [\"({})\".format(sql) for sql in sql_having_filters]",
            "        )",
            "        form_data[\"having_filters\"] = simple_having_filters",
            "        form_data[\"filters\"] = simple_where_filters",
            "",
            "",
            "def get_username() -> Optional[str]:",
            "    \"\"\"Get username if within the flask context, otherwise return noffin'\"\"\"",
            "    try:",
            "        return g.user.username",
            "    except Exception:  # pylint: disable=broad-except",
            "        return None",
            "",
            "",
            "def parse_ssl_cert(certificate: str) -> _Certificate:",
            "    \"\"\"",
            "    Parses the contents of a certificate and returns a valid certificate object",
            "    if valid.",
            "",
            "    :param certificate: Contents of certificate file",
            "    :return: Valid certificate instance",
            "    :raises CertificateException: If certificate is not valid/unparseable",
            "    \"\"\"",
            "    try:",
            "        return x509.load_pem_x509_certificate(",
            "            certificate.encode(\"utf-8\"), default_backend()",
            "        )",
            "    except ValueError as ex:",
            "        raise CertificateException(\"Invalid certificate\") from ex",
            "",
            "",
            "def create_ssl_cert_file(certificate: str) -> str:",
            "    \"\"\"",
            "    This creates a certificate file that can be used to validate HTTPS",
            "    sessions. A certificate is only written to disk once; on subsequent calls,",
            "    only the path of the existing certificate is returned.",
            "",
            "    :param certificate: The contents of the certificate",
            "    :return: The path to the certificate file",
            "    :raises CertificateException: If certificate is not valid/unparseable",
            "    \"\"\"",
            "    filename = f\"{md5_sha_from_str(certificate)}.crt\"",
            "    cert_dir = current_app.config[\"SSL_CERT_PATH\"]",
            "    path = cert_dir if cert_dir else tempfile.gettempdir()",
            "    path = os.path.join(path, filename)",
            "    if not os.path.exists(path):",
            "        # Validate certificate prior to persisting to temporary directory",
            "        parse_ssl_cert(certificate)",
            "        with open(path, \"w\") as cert_file:",
            "            cert_file.write(certificate)",
            "    return path",
            "",
            "",
            "def time_function(",
            "    func: Callable[..., FlaskResponse], *args: Any, **kwargs: Any",
            ") -> Tuple[float, Any]:",
            "    \"\"\"",
            "    Measures the amount of time a function takes to execute in ms",
            "",
            "    :param func: The function execution time to measure",
            "    :param args: args to be passed to the function",
            "    :param kwargs: kwargs to be passed to the function",
            "    :return: A tuple with the duration and response from the function",
            "    \"\"\"",
            "    start = default_timer()",
            "    response = func(*args, **kwargs)",
            "    stop = default_timer()",
            "    return (stop - start) * 1000.0, response",
            "",
            "",
            "def MediumText() -> Variant:  # pylint:disable=invalid-name",
            "    return Text().with_variant(MEDIUMTEXT(), \"mysql\")",
            "",
            "",
            "def shortid() -> str:",
            "    return \"{}\".format(uuid.uuid4())[-12:]",
            "",
            "",
            "class DatasourceName(NamedTuple):",
            "    table: str",
            "    schema: str",
            "",
            "",
            "def get_stacktrace() -> Optional[str]:",
            "    if current_app.config[\"SHOW_STACKTRACE\"]:",
            "        return traceback.format_exc()",
            "    return None",
            "",
            "",
            "def split(",
            "    string: str, delimiter: str = \" \", quote: str = '\"', escaped_quote: str = r\"\\\"\"",
            ") -> Iterator[str]:",
            "    \"\"\"",
            "    A split function that is aware of quotes and parentheses.",
            "",
            "    :param string: string to split",
            "    :param delimiter: string defining where to split, usually a comma or space",
            "    :param quote: string, either a single or a double quote",
            "    :param escaped_quote: string representing an escaped quote",
            "    :return: list of strings",
            "    \"\"\"",
            "    parens = 0",
            "    quotes = False",
            "    i = 0",
            "    for j, character in enumerate(string):",
            "        complete = parens == 0 and not quotes",
            "        if complete and character == delimiter:",
            "            yield string[i:j]",
            "            i = j + len(delimiter)",
            "        elif character == \"(\":",
            "            parens += 1",
            "        elif character == \")\":",
            "            parens -= 1",
            "        elif character == quote:",
            "            if quotes and string[j - len(escaped_quote) + 1 : j + 1] != escaped_quote:",
            "                quotes = False",
            "            elif not quotes:",
            "                quotes = True",
            "    yield string[i:]",
            "",
            "",
            "def get_iterable(x: Any) -> List[Any]:",
            "    \"\"\"",
            "    Get an iterable (list) representation of the object.",
            "",
            "    :param x: The object",
            "    :returns: An iterable representation",
            "    \"\"\"",
            "    return x if isinstance(x, list) else [x]",
            "",
            "",
            "def get_form_data_token(form_data: Dict[str, Any]) -> str:",
            "    \"\"\"",
            "    Return the token contained within form data or generate a new one.",
            "",
            "    :param form_data: chart form data",
            "    :return: original token if predefined, otherwise new uuid4 based token",
            "    \"\"\"",
            "    return form_data.get(\"token\") or \"token_\" + uuid.uuid4().hex[:8]",
            "",
            "",
            "def get_column_name_from_column(column: Column) -> Optional[str]:",
            "    \"\"\"",
            "    Extract the physical column that a column is referencing. If the column is",
            "    an adhoc column, always returns `None`.",
            "",
            "    :param column: Physical and ad-hoc column",
            "    :return: column name if physical column, otherwise None",
            "    \"\"\"",
            "    if is_adhoc_column(column):",
            "        return None",
            "    return column  # type: ignore",
            "",
            "",
            "def get_column_names_from_columns(columns: List[Column]) -> List[str]:",
            "    \"\"\"",
            "    Extract the physical columns that a list of columns are referencing. Ignore",
            "    adhoc columns",
            "",
            "    :param columns: Physical and adhoc columns",
            "    :return: column names of all physical columns",
            "    \"\"\"",
            "    return [col for col in map(get_column_name_from_column, columns) if col]",
            "",
            "",
            "def get_column_name_from_metric(metric: Metric) -> Optional[str]:",
            "    \"\"\"",
            "    Extract the column that a metric is referencing. If the metric isn't",
            "    a simple metric, always returns `None`.",
            "",
            "    :param metric: Ad-hoc metric",
            "    :return: column name if simple metric, otherwise None",
            "    \"\"\"",
            "    if is_adhoc_metric(metric):",
            "        metric = cast(AdhocMetric, metric)",
            "        if metric[\"expressionType\"] == AdhocMetricExpressionType.SIMPLE:",
            "            return cast(Dict[str, Any], metric[\"column\"])[\"column_name\"]",
            "    return None",
            "",
            "",
            "def get_column_names_from_metrics(metrics: List[Metric]) -> List[str]:",
            "    \"\"\"",
            "    Extract the columns that a list of metrics are referencing. Expcludes all",
            "    SQL metrics.",
            "",
            "    :param metrics: Ad-hoc metric",
            "    :return: column name if simple metric, otherwise None",
            "    \"\"\"",
            "    return [col for col in map(get_column_name_from_metric, metrics) if col]",
            "",
            "",
            "def extract_dataframe_dtypes(",
            "    df: pd.DataFrame,",
            "    datasource: Optional[\"BaseDatasource\"] = None,",
            ") -> List[GenericDataType]:",
            "    \"\"\"Serialize pandas/numpy dtypes to generic types\"\"\"",
            "",
            "    # omitting string types as those will be the default type",
            "    inferred_type_map: Dict[str, GenericDataType] = {",
            "        \"floating\": GenericDataType.NUMERIC,",
            "        \"integer\": GenericDataType.NUMERIC,",
            "        \"mixed-integer-float\": GenericDataType.NUMERIC,",
            "        \"decimal\": GenericDataType.NUMERIC,",
            "        \"boolean\": GenericDataType.BOOLEAN,",
            "        \"datetime64\": GenericDataType.TEMPORAL,",
            "        \"datetime\": GenericDataType.TEMPORAL,",
            "        \"date\": GenericDataType.TEMPORAL,",
            "    }",
            "",
            "    columns_by_name = (",
            "        {column.column_name: column for column in datasource.columns}",
            "        if datasource",
            "        else {}",
            "    )",
            "    generic_types: List[GenericDataType] = []",
            "    for column in df.columns:",
            "        column_object = columns_by_name.get(column)",
            "        series = df[column]",
            "        inferred_type = infer_dtype(series)",
            "        generic_type = (",
            "            GenericDataType.TEMPORAL",
            "            if column_object and column_object.is_dttm",
            "            else inferred_type_map.get(inferred_type, GenericDataType.STRING)",
            "        )",
            "        generic_types.append(generic_type)",
            "",
            "    return generic_types",
            "",
            "",
            "def extract_column_dtype(col: \"BaseColumn\") -> GenericDataType:",
            "    if col.is_temporal:",
            "        return GenericDataType.TEMPORAL",
            "    if col.is_numeric:",
            "        return GenericDataType.NUMERIC",
            "    # TODO: add check for boolean data type when proper support is added",
            "    return GenericDataType.STRING",
            "",
            "",
            "def indexed(",
            "    items: List[Any], key: Union[str, Callable[[Any], Any]]",
            ") -> Dict[Any, List[Any]]:",
            "    \"\"\"Build an index for a list of objects\"\"\"",
            "    idx: Dict[Any, Any] = {}",
            "    for item in items:",
            "        key_ = getattr(item, key) if isinstance(key, str) else key(item)",
            "        idx.setdefault(key_, []).append(item)",
            "    return idx",
            "",
            "",
            "def is_test() -> bool:",
            "    return strtobool(os.environ.get(\"SUPERSET_TESTENV\", \"false\"))",
            "",
            "",
            "def get_time_filter_status(",
            "    datasource: \"BaseDatasource\",",
            "    applied_time_extras: Dict[str, str],",
            ") -> Tuple[List[Dict[str, str]], List[Dict[str, str]]]:",
            "    temporal_columns = {col.column_name for col in datasource.columns if col.is_dttm}",
            "    applied: List[Dict[str, str]] = []",
            "    rejected: List[Dict[str, str]] = []",
            "    time_column = applied_time_extras.get(ExtraFiltersTimeColumnType.TIME_COL)",
            "    if time_column:",
            "        if time_column in temporal_columns:",
            "            applied.append({\"column\": ExtraFiltersTimeColumnType.TIME_COL})",
            "        else:",
            "            rejected.append(",
            "                {",
            "                    \"reason\": ExtraFiltersReasonType.COL_NOT_IN_DATASOURCE,",
            "                    \"column\": ExtraFiltersTimeColumnType.TIME_COL,",
            "                }",
            "            )",
            "",
            "    if ExtraFiltersTimeColumnType.TIME_GRAIN in applied_time_extras:",
            "        # are there any temporal columns to assign the time grain to?",
            "        if temporal_columns:",
            "            applied.append({\"column\": ExtraFiltersTimeColumnType.TIME_GRAIN})",
            "        else:",
            "            rejected.append(",
            "                {",
            "                    \"reason\": ExtraFiltersReasonType.NO_TEMPORAL_COLUMN,",
            "                    \"column\": ExtraFiltersTimeColumnType.TIME_GRAIN,",
            "                }",
            "            )",
            "",
            "    time_range = applied_time_extras.get(ExtraFiltersTimeColumnType.TIME_RANGE)",
            "    if time_range:",
            "        # are there any temporal columns to assign the time grain to?",
            "        if temporal_columns:",
            "            applied.append({\"column\": ExtraFiltersTimeColumnType.TIME_RANGE})",
            "        else:",
            "            rejected.append(",
            "                {",
            "                    \"reason\": ExtraFiltersReasonType.NO_TEMPORAL_COLUMN,",
            "                    \"column\": ExtraFiltersTimeColumnType.TIME_RANGE,",
            "                }",
            "            )",
            "",
            "    if ExtraFiltersTimeColumnType.TIME_ORIGIN in applied_time_extras:",
            "        if datasource.type == \"druid\":",
            "            applied.append({\"column\": ExtraFiltersTimeColumnType.TIME_ORIGIN})",
            "        else:",
            "            rejected.append(",
            "                {",
            "                    \"reason\": ExtraFiltersReasonType.NOT_DRUID_DATASOURCE,",
            "                    \"column\": ExtraFiltersTimeColumnType.TIME_ORIGIN,",
            "                }",
            "            )",
            "",
            "    if ExtraFiltersTimeColumnType.GRANULARITY in applied_time_extras:",
            "        if datasource.type == \"druid\":",
            "            applied.append({\"column\": ExtraFiltersTimeColumnType.GRANULARITY})",
            "        else:",
            "            rejected.append(",
            "                {",
            "                    \"reason\": ExtraFiltersReasonType.NOT_DRUID_DATASOURCE,",
            "                    \"column\": ExtraFiltersTimeColumnType.GRANULARITY,",
            "                }",
            "            )",
            "",
            "    return applied, rejected",
            "",
            "",
            "def format_list(items: Sequence[str], sep: str = \", \", quote: str = '\"') -> str:",
            "    quote_escaped = \"\\\\\" + quote",
            "    return sep.join(f\"{quote}{x.replace(quote, quote_escaped)}{quote}\" for x in items)",
            "",
            "",
            "def find_duplicates(items: Iterable[InputType]) -> List[InputType]:",
            "    \"\"\"Find duplicate items in an iterable.\"\"\"",
            "    return [item for item, count in collections.Counter(items).items() if count > 1]",
            "",
            "",
            "def remove_duplicates(",
            "    items: Iterable[InputType], key: Optional[Callable[[InputType], Any]] = None",
            ") -> List[InputType]:",
            "    \"\"\"Remove duplicate items in an iterable.\"\"\"",
            "    if not key:",
            "        return list(dict.fromkeys(items).keys())",
            "    seen = set()",
            "    result = []",
            "    for item in items:",
            "        item_key = key(item)",
            "        if item_key not in seen:",
            "            seen.add(item_key)",
            "            result.append(item)",
            "    return result",
            "",
            "",
            "def normalize_dttm_col(",
            "    df: pd.DataFrame,",
            "    timestamp_format: Optional[str],",
            "    offset: int,",
            "    time_shift: Optional[timedelta],",
            ") -> None:",
            "    if DTTM_ALIAS not in df.columns:",
            "        return",
            "    if timestamp_format in (\"epoch_s\", \"epoch_ms\"):",
            "        dttm_col = df[DTTM_ALIAS]",
            "        if is_numeric_dtype(dttm_col):",
            "            # Column is formatted as a numeric value",
            "            unit = timestamp_format.replace(\"epoch_\", \"\")",
            "            df[DTTM_ALIAS] = pd.to_datetime(",
            "                dttm_col, utc=False, unit=unit, origin=\"unix\", errors=\"coerce\"",
            "            )",
            "        else:",
            "            # Column has already been formatted as a timestamp.",
            "            df[DTTM_ALIAS] = dttm_col.apply(pd.Timestamp)",
            "    else:",
            "        df[DTTM_ALIAS] = pd.to_datetime(",
            "            df[DTTM_ALIAS], utc=False, format=timestamp_format, errors=\"coerce\"",
            "        )",
            "    if offset:",
            "        df[DTTM_ALIAS] += timedelta(hours=offset)",
            "    if time_shift is not None:",
            "        df[DTTM_ALIAS] += time_shift",
            "",
            "",
            "def parse_boolean_string(bool_str: Optional[str]) -> bool:",
            "    \"\"\"",
            "    Convert a string representation of a true/false value into a boolean",
            "",
            "    >>> parse_boolean_string(None)",
            "    False",
            "    >>> parse_boolean_string('false')",
            "    False",
            "    >>> parse_boolean_string('true')",
            "    True",
            "    >>> parse_boolean_string('False')",
            "    False",
            "    >>> parse_boolean_string('True')",
            "    True",
            "    >>> parse_boolean_string('foo')",
            "    False",
            "    >>> parse_boolean_string('0')",
            "    False",
            "    >>> parse_boolean_string('1')",
            "    True",
            "",
            "    :param bool_str: string representation of a value that is assumed to be boolean",
            "    :return: parsed boolean value",
            "    \"\"\"",
            "    if bool_str is None:",
            "        return False",
            "    try:",
            "        return bool(strtobool(bool_str.lower()))",
            "    except ValueError:",
            "        return False",
            "",
            "",
            "def apply_max_row_limit(",
            "    limit: int,",
            "    max_limit: Optional[int] = None,",
            ") -> int:",
            "    \"\"\"",
            "    Override row limit if max global limit is defined",
            "",
            "    :param limit: requested row limit",
            "    :param max_limit: Maximum allowed row limit",
            "    :return: Capped row limit",
            "",
            "    >>> apply_max_row_limit(100000, 10)",
            "    10",
            "    >>> apply_max_row_limit(10, 100000)",
            "    10",
            "    >>> apply_max_row_limit(0, 10000)",
            "    10000",
            "    \"\"\"",
            "    if max_limit is None:",
            "        max_limit = current_app.config[\"SQL_MAX_ROW\"]",
            "    if limit != 0:",
            "        return min(max_limit, limit)",
            "    return max_limit",
            "",
            "",
            "def create_zip(files: Dict[str, Any]) -> BytesIO:",
            "    buf = BytesIO()",
            "    with ZipFile(buf, \"w\") as bundle:",
            "        for filename, contents in files.items():",
            "            with bundle.open(filename, \"w\") as fp:",
            "                fp.write(contents)",
            "    buf.seek(0)",
            "    return buf"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "1250": [
                "is_adhoc_column"
            ]
        },
        "addLocation": []
    }
}