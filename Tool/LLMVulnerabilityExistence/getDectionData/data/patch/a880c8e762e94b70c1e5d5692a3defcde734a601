{
    "glance/common/scripts/image_import/main.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from glance.api.v2 import images as v2_api"
            },
            "1": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from glance.common import exception"
            },
            "2": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " from glance.common.scripts import utils as script_utils"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+from glance.common import store_utils"
            },
            "4": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " from glance.common import utils as common_utils"
            },
            "5": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " from glance import i18n"
            },
            "6": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " from glance.openstack.common import excutils"
            },
            "7": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "     new_image = image_repo.get(image_id)"
            },
            "8": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "     set_image_data(new_image, uri, None)"
            },
            "9": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 95,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 95,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # NOTE: Check if the Image is not deleted after setting the data"
            },
            "11": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # before saving the active image. Here if image status is"
            },
            "12": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # saving, then new_image is saved as it contains updated location,"
            },
            "13": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # size, virtual_size and checksum information and the status of"
            },
            "14": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # new_image is already set to active in set_image_data() call."
            },
            "15": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    image = image_repo.get(image_id)"
            },
            "16": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    if image.status == 'saving':"
            },
            "17": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        image_repo.save(new_image)"
            },
            "18": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        return image_id"
            },
            "19": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    else:"
            },
            "20": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        msg = _LE(\"The Image %(image_id)s object being created by this task \""
            },
            "21": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                  \"%(task_id)s, is no longer in valid status for further \""
            },
            "22": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                  \"processing.\" % {\"image_id\": new_image.image_id,"
            },
            "23": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                                   \"task_id\": task_id})"
            },
            "24": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise exception.Conflict(msg)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 96,
                "PatchRowcode": "+    try:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 97,
                "PatchRowcode": "+        # NOTE: Check if the Image is not deleted after setting the data"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 98,
                "PatchRowcode": "+        # before saving the active image. Here if image status is"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+        # saving, then new_image is saved as it contains updated location,"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+        # size, virtual_size and checksum information and the status of"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+        # new_image is already set to active in set_image_data() call."
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+        image = image_repo.get(image_id)"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+        if image.status == 'saving':"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+            image_repo.save(new_image)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+            return image_id"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+        else:"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+            msg = _(\"The Image %(image_id)s object being created by this task \""
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+                    \"%(task_id)s, is no longer in valid status for further \""
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+                    \"processing.\") % {\"image_id\": image_id,"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+                                      \"task_id\": task_id}"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+            raise exception.Conflict(msg)"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+    except (exception.Conflict, exception.NotFound):"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+        with excutils.save_and_reraise_exception():"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+            if new_image.locations:"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+                for location in new_image.locations:"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+                    store_utils.delete_image_location_from_backend("
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+                        new_image.context,"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+                        image_id,"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+                        location)"
            },
            "49": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 120,
                "PatchRowcode": " "
            },
            "50": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": 121,
                "PatchRowcode": " "
            },
            "51": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": 122,
                "PatchRowcode": " def create_image(image_repo, image_factory, image_properties, task_id):"
            }
        },
        "frontPatchFile": [
            "# Copyright 2014 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "__all__ = [",
            "    'run',",
            "]",
            "",
            "import six",
            "",
            "from glance.api.v2 import images as v2_api",
            "from glance.common import exception",
            "from glance.common.scripts import utils as script_utils",
            "from glance.common import utils as common_utils",
            "from glance import i18n",
            "from glance.openstack.common import excutils",
            "from glance.openstack.common import lockutils",
            "import glance.openstack.common.log as logging",
            "",
            "",
            "_LE = i18n._LE",
            "_LI = i18n._LI",
            "_LW = i18n._LW",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "def run(t_id, context, task_repo, image_repo, image_factory):",
            "    LOG.info(_LI('Task %(task_id)s beginning import '",
            "                 'execution.') % {'task_id': t_id})",
            "    _execute(t_id, task_repo, image_repo, image_factory)",
            "",
            "",
            "# NOTE(nikhil): This lock prevents more than N number of threads to be spawn",
            "# simultaneously. The number N represents the number of threads in the",
            "# executor pool. The value is set to 10 in the eventlet executor.",
            "@lockutils.synchronized(\"glance_import\")",
            "def _execute(t_id, task_repo, image_repo, image_factory):",
            "    task = script_utils.get_task(task_repo, t_id)",
            "",
            "    if task is None:",
            "        # NOTE: This happens if task is not found in the database. In",
            "        # such cases, there is no way to update the task status so,",
            "        # it's ignored here.",
            "        return",
            "",
            "    try:",
            "        task_input = script_utils.unpack_task_input(task)",
            "",
            "        uri = script_utils.validate_location_uri(task_input.get('import_from'))",
            "        image_id = import_image(image_repo, image_factory, task_input, t_id,",
            "                                uri)",
            "",
            "        task.succeed({'image_id': image_id})",
            "    except Exception as e:",
            "        # Note: The message string contains Error in it to indicate",
            "        # in the task.message that it's a error message for the user.",
            "",
            "        #TODO(nikhil): need to bring back save_and_reraise_exception when",
            "        # necessary",
            "        err_msg = (\"Error: \" + six.text_type(type(e)) + ': ' +",
            "                   common_utils.exception_to_str(e))",
            "        log_msg = _LE(err_msg + (\"Task ID %s\" % task.task_id))",
            "        LOG.exception(log_msg)",
            "",
            "        task.fail(_LE(err_msg))",
            "    finally:",
            "        task_repo.save(task)",
            "",
            "",
            "def import_image(image_repo, image_factory, task_input, task_id, uri):",
            "    original_image = create_image(image_repo, image_factory,",
            "                                  task_input.get('image_properties'), task_id)",
            "    # NOTE: set image status to saving just before setting data",
            "    original_image.status = 'saving'",
            "    image_repo.save(original_image)",
            "    image_id = original_image.image_id",
            "",
            "    # NOTE: Retrieving image from the database because the Image object",
            "    # returned from create_image method does not have appropriate factories",
            "    # wrapped around it.",
            "    new_image = image_repo.get(image_id)",
            "    set_image_data(new_image, uri, None)",
            "",
            "    # NOTE: Check if the Image is not deleted after setting the data",
            "    # before saving the active image. Here if image status is",
            "    # saving, then new_image is saved as it contains updated location,",
            "    # size, virtual_size and checksum information and the status of",
            "    # new_image is already set to active in set_image_data() call.",
            "    image = image_repo.get(image_id)",
            "    if image.status == 'saving':",
            "        image_repo.save(new_image)",
            "        return image_id",
            "    else:",
            "        msg = _LE(\"The Image %(image_id)s object being created by this task \"",
            "                  \"%(task_id)s, is no longer in valid status for further \"",
            "                  \"processing.\" % {\"image_id\": new_image.image_id,",
            "                                   \"task_id\": task_id})",
            "        raise exception.Conflict(msg)",
            "",
            "",
            "def create_image(image_repo, image_factory, image_properties, task_id):",
            "    _base_properties = []",
            "    for k, v in v2_api.get_base_properties().items():",
            "        _base_properties.append(k)",
            "",
            "    properties = {}",
            "    # NOTE: get the base properties",
            "    for key in _base_properties:",
            "        try:",
            "            properties[key] = image_properties.pop(key)",
            "        except KeyError:",
            "            msg = _(\"Task ID %(task_id)s: Ignoring property %(k)s for setting \"",
            "                    \"base properties while creating \"",
            "                    \"Image.\") % {'task_id': task_id, 'k': key}",
            "            LOG.debug(msg)",
            "",
            "    # NOTE: get the rest of the properties and pass them as",
            "    # extra_properties for Image to be created with them.",
            "    properties['extra_properties'] = image_properties",
            "    script_utils.set_base_image_properties(properties=properties)",
            "",
            "    image = image_factory.new_image(**properties)",
            "    image_repo.add(image)",
            "    return image",
            "",
            "",
            "def set_image_data(image, uri, task_id):",
            "    data_iter = None",
            "    try:",
            "        LOG.info(_LI(\"Task %(task_id)s: Got image data uri %(data_uri)s to be \"",
            "                 \"imported\") % {\"data_uri\": uri, \"task_id\": task_id})",
            "        data_iter = script_utils.get_image_data_iter(uri)",
            "        image.set_data(data_iter)",
            "    except Exception as e:",
            "        with excutils.save_and_reraise_exception():",
            "            LOG.warn(_LW(\"Task %(task_id)s failed with exception %(error)s\") %",
            "                     {\"error\": common_utils.exception_to_str(e),",
            "                      \"task_id\": task_id})",
            "            LOG.info(_LI(\"Task %(task_id)s: Could not import image file\"",
            "                         \" %(image_data)s\") % {\"image_data\": uri,",
            "                                               \"task_id\": task_id})",
            "    finally:",
            "        if isinstance(data_iter, file):",
            "            data_iter.close()"
        ],
        "afterPatchFile": [
            "# Copyright 2014 OpenStack Foundation",
            "# All Rights Reserved.",
            "#",
            "#    Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "#    not use this file except in compliance with the License. You may obtain",
            "#    a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#    Unless required by applicable law or agreed to in writing, software",
            "#    distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "#    License for the specific language governing permissions and limitations",
            "#    under the License.",
            "",
            "__all__ = [",
            "    'run',",
            "]",
            "",
            "import six",
            "",
            "from glance.api.v2 import images as v2_api",
            "from glance.common import exception",
            "from glance.common.scripts import utils as script_utils",
            "from glance.common import store_utils",
            "from glance.common import utils as common_utils",
            "from glance import i18n",
            "from glance.openstack.common import excutils",
            "from glance.openstack.common import lockutils",
            "import glance.openstack.common.log as logging",
            "",
            "",
            "_LE = i18n._LE",
            "_LI = i18n._LI",
            "_LW = i18n._LW",
            "LOG = logging.getLogger(__name__)",
            "",
            "",
            "def run(t_id, context, task_repo, image_repo, image_factory):",
            "    LOG.info(_LI('Task %(task_id)s beginning import '",
            "                 'execution.') % {'task_id': t_id})",
            "    _execute(t_id, task_repo, image_repo, image_factory)",
            "",
            "",
            "# NOTE(nikhil): This lock prevents more than N number of threads to be spawn",
            "# simultaneously. The number N represents the number of threads in the",
            "# executor pool. The value is set to 10 in the eventlet executor.",
            "@lockutils.synchronized(\"glance_import\")",
            "def _execute(t_id, task_repo, image_repo, image_factory):",
            "    task = script_utils.get_task(task_repo, t_id)",
            "",
            "    if task is None:",
            "        # NOTE: This happens if task is not found in the database. In",
            "        # such cases, there is no way to update the task status so,",
            "        # it's ignored here.",
            "        return",
            "",
            "    try:",
            "        task_input = script_utils.unpack_task_input(task)",
            "",
            "        uri = script_utils.validate_location_uri(task_input.get('import_from'))",
            "        image_id = import_image(image_repo, image_factory, task_input, t_id,",
            "                                uri)",
            "",
            "        task.succeed({'image_id': image_id})",
            "    except Exception as e:",
            "        # Note: The message string contains Error in it to indicate",
            "        # in the task.message that it's a error message for the user.",
            "",
            "        #TODO(nikhil): need to bring back save_and_reraise_exception when",
            "        # necessary",
            "        err_msg = (\"Error: \" + six.text_type(type(e)) + ': ' +",
            "                   common_utils.exception_to_str(e))",
            "        log_msg = _LE(err_msg + (\"Task ID %s\" % task.task_id))",
            "        LOG.exception(log_msg)",
            "",
            "        task.fail(_LE(err_msg))",
            "    finally:",
            "        task_repo.save(task)",
            "",
            "",
            "def import_image(image_repo, image_factory, task_input, task_id, uri):",
            "    original_image = create_image(image_repo, image_factory,",
            "                                  task_input.get('image_properties'), task_id)",
            "    # NOTE: set image status to saving just before setting data",
            "    original_image.status = 'saving'",
            "    image_repo.save(original_image)",
            "    image_id = original_image.image_id",
            "",
            "    # NOTE: Retrieving image from the database because the Image object",
            "    # returned from create_image method does not have appropriate factories",
            "    # wrapped around it.",
            "    new_image = image_repo.get(image_id)",
            "    set_image_data(new_image, uri, None)",
            "",
            "    try:",
            "        # NOTE: Check if the Image is not deleted after setting the data",
            "        # before saving the active image. Here if image status is",
            "        # saving, then new_image is saved as it contains updated location,",
            "        # size, virtual_size and checksum information and the status of",
            "        # new_image is already set to active in set_image_data() call.",
            "        image = image_repo.get(image_id)",
            "        if image.status == 'saving':",
            "            image_repo.save(new_image)",
            "            return image_id",
            "        else:",
            "            msg = _(\"The Image %(image_id)s object being created by this task \"",
            "                    \"%(task_id)s, is no longer in valid status for further \"",
            "                    \"processing.\") % {\"image_id\": image_id,",
            "                                      \"task_id\": task_id}",
            "            raise exception.Conflict(msg)",
            "    except (exception.Conflict, exception.NotFound):",
            "        with excutils.save_and_reraise_exception():",
            "            if new_image.locations:",
            "                for location in new_image.locations:",
            "                    store_utils.delete_image_location_from_backend(",
            "                        new_image.context,",
            "                        image_id,",
            "                        location)",
            "",
            "",
            "def create_image(image_repo, image_factory, image_properties, task_id):",
            "    _base_properties = []",
            "    for k, v in v2_api.get_base_properties().items():",
            "        _base_properties.append(k)",
            "",
            "    properties = {}",
            "    # NOTE: get the base properties",
            "    for key in _base_properties:",
            "        try:",
            "            properties[key] = image_properties.pop(key)",
            "        except KeyError:",
            "            msg = _(\"Task ID %(task_id)s: Ignoring property %(k)s for setting \"",
            "                    \"base properties while creating \"",
            "                    \"Image.\") % {'task_id': task_id, 'k': key}",
            "            LOG.debug(msg)",
            "",
            "    # NOTE: get the rest of the properties and pass them as",
            "    # extra_properties for Image to be created with them.",
            "    properties['extra_properties'] = image_properties",
            "    script_utils.set_base_image_properties(properties=properties)",
            "",
            "    image = image_factory.new_image(**properties)",
            "    image_repo.add(image)",
            "    return image",
            "",
            "",
            "def set_image_data(image, uri, task_id):",
            "    data_iter = None",
            "    try:",
            "        LOG.info(_LI(\"Task %(task_id)s: Got image data uri %(data_uri)s to be \"",
            "                 \"imported\") % {\"data_uri\": uri, \"task_id\": task_id})",
            "        data_iter = script_utils.get_image_data_iter(uri)",
            "        image.set_data(data_iter)",
            "    except Exception as e:",
            "        with excutils.save_and_reraise_exception():",
            "            LOG.warn(_LW(\"Task %(task_id)s failed with exception %(error)s\") %",
            "                     {\"error\": common_utils.exception_to_str(e),",
            "                      \"task_id\": task_id})",
            "            LOG.info(_LI(\"Task %(task_id)s: Could not import image file\"",
            "                         \" %(image_data)s\") % {\"image_data\": uri,",
            "                                               \"task_id\": task_id})",
            "    finally:",
            "        if isinstance(data_iter, file):",
            "            data_iter.close()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "95": [
                "import_image"
            ],
            "96": [
                "import_image"
            ],
            "97": [
                "import_image"
            ],
            "98": [
                "import_image"
            ],
            "99": [
                "import_image"
            ],
            "100": [
                "import_image"
            ],
            "101": [
                "import_image"
            ],
            "102": [
                "import_image"
            ],
            "103": [
                "import_image"
            ],
            "104": [
                "import_image"
            ],
            "105": [
                "import_image"
            ],
            "106": [
                "import_image"
            ],
            "107": [
                "import_image"
            ],
            "108": [
                "import_image"
            ],
            "109": [
                "import_image"
            ]
        },
        "addLocation": []
    }
}