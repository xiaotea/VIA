{
    "lnbits/core/services.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 64,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 65,
                "PatchRowcode": " class PaymentError(Exception):"
            },
            "3": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    pass"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+    def __init__(self, message: str, status: str = \"pending\"):"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+        self.message = message"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+        self.status = status"
            },
            "7": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": 69,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 70,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " class InvoiceError(Exception):"
            },
            "10": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    pass"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+    def __init__(self, message: str, status: str = \"pending\"):"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+        self.message = message"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+        self.status = status"
            },
            "14": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 75,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 76,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 77,
                "PatchRowcode": " async def calculate_fiat_amounts("
            },
            "17": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": 127,
                "PatchRowcode": "     conn: Optional[Connection] = None,"
            },
            "18": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 128,
                "PatchRowcode": " ) -> Tuple[str, str]:"
            },
            "19": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "     if not amount > 0:"
            },
            "20": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise InvoiceError(\"Amountless invoices not supported.\")"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 130,
                "PatchRowcode": "+        raise InvoiceError(\"Amountless invoices not supported.\", status=\"failed\")"
            },
            "22": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": 131,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "     user_wallet = await get_wallet(wallet_id, conn=conn)"
            },
            "24": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 133,
                "PatchRowcode": "     if not user_wallet:"
            },
            "25": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise InvoiceError(f\"Could not fetch wallet '{wallet_id}'.\")"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+        raise InvoiceError(f\"Could not fetch wallet '{wallet_id}'.\", status=\"failed\")"
            },
            "27": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 135,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "     invoice_memo = None if description_hash else memo"
            },
            "29": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 137,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "         user_wallet.balance_msat / 1000 + amount_sat"
            },
            "31": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "     ):"
            },
            "32": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "         raise InvoiceError("
            },
            "33": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            f\"Wallet balance  cannot exceed \""
            },
            "34": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            f\"{settings.lnbits_wallet_limit_max_balance} sats.\""
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+            f\"Wallet balance cannot exceed \""
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+            f\"{settings.lnbits_wallet_limit_max_balance} sats.\","
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+            status=\"failed\","
            },
            "38": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "         )"
            },
            "39": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 153,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "     ("
            },
            "41": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "         expiry=expiry or settings.lightning_invoice_expiry,"
            },
            "42": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "     )"
            },
            "43": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "     if not ok or not payment_request or not checking_id:"
            },
            "44": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise InvoiceError(error_message or \"unexpected backend error.\")"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+        raise InvoiceError("
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+            error_message or \"unexpected backend error.\", status=\"pending\""
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+        )"
            },
            "48": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 170,
                "PatchRowcode": " "
            },
            "49": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "     invoice = bolt11_decode(payment_request)"
            },
            "50": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": 172,
                "PatchRowcode": " "
            },
            "51": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 209,
                "PatchRowcode": "     try:"
            },
            "52": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 210,
                "PatchRowcode": "         invoice = bolt11_decode(payment_request)"
            },
            "53": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "     except Exception as exc:"
            },
            "54": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise InvoiceError(\"Bolt11 decoding failed.\") from exc"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 212,
                "PatchRowcode": "+        raise PaymentError(\"Bolt11 decoding failed.\", status=\"failed\") from exc"
            },
            "56": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 213,
                "PatchRowcode": " "
            },
            "57": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 214,
                "PatchRowcode": "     if not invoice.amount_msat or not invoice.amount_msat > 0:"
            },
            "58": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise InvoiceError(\"Amountless invoices not supported.\")"
            },
            "59": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+        raise PaymentError(\"Amountless invoices not supported.\", status=\"failed\")"
            },
            "60": {
                "beforePatchRowNumber": 209,
                "afterPatchRowNumber": 216,
                "PatchRowcode": "     if max_sat and invoice.amount_msat > max_sat * 1000:"
            },
            "61": {
                "beforePatchRowNumber": 210,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise InvoiceError(\"Amount in invoice is too high.\")"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+        raise PaymentError(\"Amount in invoice is too high.\", status=\"failed\")"
            },
            "63": {
                "beforePatchRowNumber": 211,
                "afterPatchRowNumber": 218,
                "PatchRowcode": " "
            },
            "64": {
                "beforePatchRowNumber": 212,
                "afterPatchRowNumber": 219,
                "PatchRowcode": "     await check_wallet_limits(wallet_id, conn, invoice.amount_msat)"
            },
            "65": {
                "beforePatchRowNumber": 213,
                "afterPatchRowNumber": 220,
                "PatchRowcode": " "
            },
            "66": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 249,
                "PatchRowcode": "         # we check if an internal invoice exists that has already been paid"
            },
            "67": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "         # (not pending anymore)"
            },
            "68": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 251,
                "PatchRowcode": "         if not await check_internal_pending(invoice.payment_hash, conn=conn):"
            },
            "69": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise PaymentError(\"Internal invoice already paid.\")"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+            raise PaymentError(\"Internal invoice already paid.\", status=\"failed\")"
            },
            "71": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": 253,
                "PatchRowcode": " "
            },
            "72": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "         # check_internal() returns the checking_id of the invoice we're waiting for"
            },
            "73": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "         # (pending only)"
            },
            "74": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 268,
                "PatchRowcode": "                 internal_invoice.amount != invoice.amount_msat"
            },
            "75": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 269,
                "PatchRowcode": "                 or internal_invoice.bolt11 != payment_request.lower()"
            },
            "76": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": 270,
                "PatchRowcode": "             ):"
            },
            "77": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                raise PaymentError(\"Invalid invoice.\")"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 271,
                "PatchRowcode": "+                raise PaymentError(\"Invalid invoice.\", status=\"failed\")"
            },
            "79": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 272,
                "PatchRowcode": " "
            },
            "80": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": 273,
                "PatchRowcode": "             logger.debug(f\"creating temporary internal payment with id {internal_id}\")"
            },
            "81": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": 274,
                "PatchRowcode": "             # create a new payment from this wallet"
            },
            "82": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 296,
                "PatchRowcode": "             except Exception as exc:"
            },
            "83": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 297,
                "PatchRowcode": "                 logger.error(f\"could not create temporary payment: {exc}\")"
            },
            "84": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 298,
                "PatchRowcode": "                 # happens if the same wallet tries to pay an invoice twice"
            },
            "85": {
                "beforePatchRowNumber": 292,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                raise PaymentError(\"Could not make payment.\") from exc"
            },
            "86": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 299,
                "PatchRowcode": "+                raise PaymentError(\"Could not make payment.\", status=\"failed\") from exc"
            },
            "87": {
                "beforePatchRowNumber": 293,
                "afterPatchRowNumber": 300,
                "PatchRowcode": " "
            },
            "88": {
                "beforePatchRowNumber": 294,
                "afterPatchRowNumber": 301,
                "PatchRowcode": "         # do the balance check"
            },
            "89": {
                "beforePatchRowNumber": 295,
                "afterPatchRowNumber": 302,
                "PatchRowcode": "         wallet = await get_wallet(wallet_id, conn=conn)"
            },
            "90": {
                "beforePatchRowNumber": 302,
                "afterPatchRowNumber": 309,
                "PatchRowcode": "             ):"
            },
            "91": {
                "beforePatchRowNumber": 303,
                "afterPatchRowNumber": 310,
                "PatchRowcode": "                 raise PaymentError("
            },
            "92": {
                "beforePatchRowNumber": 304,
                "afterPatchRowNumber": 311,
                "PatchRowcode": "                     f\"You must reserve at least ({round(fee_reserve_total_msat/1000)}\""
            },
            "93": {
                "beforePatchRowNumber": 305,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                    \"  sat) to cover potential routing fees.\""
            },
            "94": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 312,
                "PatchRowcode": "+                    \"  sat) to cover potential routing fees.\","
            },
            "95": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 313,
                "PatchRowcode": "+                    status=\"failed\","
            },
            "96": {
                "beforePatchRowNumber": 306,
                "afterPatchRowNumber": 314,
                "PatchRowcode": "                 )"
            },
            "97": {
                "beforePatchRowNumber": 307,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise PermissionError(\"Insufficient balance.\")"
            },
            "98": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 315,
                "PatchRowcode": "+            raise PaymentError(\"Insufficient balance.\", status=\"failed\")"
            },
            "99": {
                "beforePatchRowNumber": 308,
                "afterPatchRowNumber": 316,
                "PatchRowcode": " "
            },
            "100": {
                "beforePatchRowNumber": 309,
                "afterPatchRowNumber": 317,
                "PatchRowcode": "     if internal_checking_id:"
            },
            "101": {
                "beforePatchRowNumber": 310,
                "afterPatchRowNumber": 318,
                "PatchRowcode": "         service_fee_msat = service_fee(invoice.amount_msat, internal=True)"
            },
            "102": {
                "beforePatchRowNumber": 340,
                "afterPatchRowNumber": 348,
                "PatchRowcode": "             )"
            },
            "103": {
                "beforePatchRowNumber": 341,
                "afterPatchRowNumber": 349,
                "PatchRowcode": " "
            },
            "104": {
                "beforePatchRowNumber": 342,
                "afterPatchRowNumber": 350,
                "PatchRowcode": "         logger.debug(f\"backend: pay_invoice finished {temp_id}\")"
            },
            "105": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 351,
                "PatchRowcode": "+        logger.debug(f\"backend: pay_invoice response {payment}\")"
            },
            "106": {
                "beforePatchRowNumber": 343,
                "afterPatchRowNumber": 352,
                "PatchRowcode": "         if payment.checking_id and payment.ok is not False:"
            },
            "107": {
                "beforePatchRowNumber": 344,
                "afterPatchRowNumber": 353,
                "PatchRowcode": "             # payment.ok can be True (paid) or None (pending)!"
            },
            "108": {
                "beforePatchRowNumber": 345,
                "afterPatchRowNumber": 354,
                "PatchRowcode": "             logger.debug(f\"updating payment {temp_id}\")"
            },
            "109": {
                "beforePatchRowNumber": 370,
                "afterPatchRowNumber": 379,
                "PatchRowcode": "                 await delete_wallet_payment(temp_id, wallet_id, conn=conn)"
            },
            "110": {
                "beforePatchRowNumber": 371,
                "afterPatchRowNumber": 380,
                "PatchRowcode": "             raise PaymentError("
            },
            "111": {
                "beforePatchRowNumber": 372,
                "afterPatchRowNumber": 381,
                "PatchRowcode": "                 f\"Payment failed: {payment.error_message}\""
            },
            "112": {
                "beforePatchRowNumber": 373,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                or \"Payment failed, but backend didn't give us an error message.\""
            },
            "113": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 382,
                "PatchRowcode": "+                or \"Payment failed, but backend didn't give us an error message.\","
            },
            "114": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 383,
                "PatchRowcode": "+                status=\"failed\","
            },
            "115": {
                "beforePatchRowNumber": 374,
                "afterPatchRowNumber": 384,
                "PatchRowcode": "             )"
            },
            "116": {
                "beforePatchRowNumber": 375,
                "afterPatchRowNumber": 385,
                "PatchRowcode": "         else:"
            },
            "117": {
                "beforePatchRowNumber": 376,
                "afterPatchRowNumber": 386,
                "PatchRowcode": "             logger.warning("
            },
            "118": {
                "beforePatchRowNumber": 413,
                "afterPatchRowNumber": 423,
                "PatchRowcode": "     if len(payments) == 0:"
            },
            "119": {
                "beforePatchRowNumber": 414,
                "afterPatchRowNumber": 424,
                "PatchRowcode": "         return"
            },
            "120": {
                "beforePatchRowNumber": 415,
                "afterPatchRowNumber": 425,
                "PatchRowcode": " "
            },
            "121": {
                "beforePatchRowNumber": 416,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    raise ValueError("
            },
            "122": {
                "beforePatchRowNumber": 417,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        f\"The time limit of {limit} seconds between payments has been reached.\""
            },
            "123": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 426,
                "PatchRowcode": "+    raise PaymentError("
            },
            "124": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 427,
                "PatchRowcode": "+        status=\"failed\","
            },
            "125": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 428,
                "PatchRowcode": "+        message=f\"The time limit of {limit} seconds between payments has been reached.\","
            },
            "126": {
                "beforePatchRowNumber": 418,
                "afterPatchRowNumber": 429,
                "PatchRowcode": "     )"
            },
            "127": {
                "beforePatchRowNumber": 419,
                "afterPatchRowNumber": 430,
                "PatchRowcode": " "
            },
            "128": {
                "beforePatchRowNumber": 420,
                "afterPatchRowNumber": 431,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "import asyncio",
            "import datetime",
            "import json",
            "import time",
            "from io import BytesIO",
            "from pathlib import Path",
            "from typing import Dict, List, Optional, Tuple, TypedDict",
            "from urllib.parse import parse_qs, urlparse",
            "",
            "import httpx",
            "from bolt11 import Bolt11",
            "from bolt11 import decode as bolt11_decode",
            "from cryptography.hazmat.primitives import serialization",
            "from fastapi import Depends, WebSocket",
            "from loguru import logger",
            "from py_vapid import Vapid",
            "from py_vapid.utils import b64urlencode",
            "",
            "from lnbits.core.db import db",
            "from lnbits.db import Connection",
            "from lnbits.decorators import WalletTypeInfo, require_admin_key",
            "from lnbits.helpers import url_for",
            "from lnbits.lnurl import LnurlErrorResponse",
            "from lnbits.lnurl import decode as decode_lnurl",
            "from lnbits.settings import (",
            "    EditableSettings,",
            "    SuperSettings,",
            "    readonly_variables,",
            "    send_admin_user_to_saas,",
            "    settings,",
            ")",
            "from lnbits.utils.exchange_rates import fiat_amount_as_satoshis, satoshis_amount_as_fiat",
            "from lnbits.wallets import fake_wallet, get_funding_source, set_funding_source",
            "from lnbits.wallets.base import (",
            "    PaymentPendingStatus,",
            "    PaymentResponse,",
            "    PaymentStatus,",
            "    PaymentSuccessStatus,",
            ")",
            "",
            "from .crud import (",
            "    check_internal,",
            "    check_internal_pending,",
            "    create_account,",
            "    create_admin_settings,",
            "    create_payment,",
            "    create_wallet,",
            "    delete_wallet_payment,",
            "    get_account,",
            "    get_payments,",
            "    get_standalone_payment,",
            "    get_super_settings,",
            "    get_total_balance,",
            "    get_wallet,",
            "    get_wallet_payment,",
            "    update_admin_settings,",
            "    update_payment_details,",
            "    update_payment_status,",
            "    update_super_user,",
            ")",
            "from .helpers import to_valid_user_id",
            "from .models import Payment, UserConfig, Wallet",
            "",
            "",
            "class PaymentError(Exception):",
            "    pass",
            "",
            "",
            "class InvoiceError(Exception):",
            "    pass",
            "",
            "",
            "async def calculate_fiat_amounts(",
            "    amount: float,",
            "    wallet_id: str,",
            "    currency: Optional[str] = None,",
            "    extra: Optional[Dict] = None,",
            "    conn: Optional[Connection] = None,",
            ") -> Tuple[int, Optional[Dict]]:",
            "    wallet = await get_wallet(wallet_id, conn=conn)",
            "    assert wallet, \"invalid wallet_id\"",
            "    wallet_currency = wallet.currency or settings.lnbits_default_accounting_currency",
            "",
            "    if currency and currency != \"sat\":",
            "        amount_sat = await fiat_amount_as_satoshis(amount, currency)",
            "        extra = extra or {}",
            "        if currency != wallet_currency:",
            "            extra[\"fiat_currency\"] = currency",
            "            extra[\"fiat_amount\"] = round(amount, ndigits=3)",
            "            extra[\"fiat_rate\"] = amount_sat / amount",
            "    else:",
            "        amount_sat = int(amount)",
            "",
            "    if wallet_currency:",
            "        if wallet_currency == currency:",
            "            fiat_amount = amount",
            "        else:",
            "            fiat_amount = await satoshis_amount_as_fiat(amount_sat, wallet_currency)",
            "        extra = extra or {}",
            "        extra[\"wallet_fiat_currency\"] = wallet_currency",
            "        extra[\"wallet_fiat_amount\"] = round(fiat_amount, ndigits=3)",
            "        extra[\"wallet_fiat_rate\"] = amount_sat / fiat_amount",
            "",
            "    logger.debug(",
            "        f\"Calculated fiat amounts {wallet.id=} {amount=} {currency=}: {extra=}\"",
            "    )",
            "",
            "    return amount_sat, extra",
            "",
            "",
            "async def create_invoice(",
            "    *,",
            "    wallet_id: str,",
            "    amount: float,",
            "    currency: Optional[str] = \"sat\",",
            "    memo: str,",
            "    description_hash: Optional[bytes] = None,",
            "    unhashed_description: Optional[bytes] = None,",
            "    expiry: Optional[int] = None,",
            "    extra: Optional[Dict] = None,",
            "    webhook: Optional[str] = None,",
            "    internal: Optional[bool] = False,",
            "    conn: Optional[Connection] = None,",
            ") -> Tuple[str, str]:",
            "    if not amount > 0:",
            "        raise InvoiceError(\"Amountless invoices not supported.\")",
            "",
            "    user_wallet = await get_wallet(wallet_id, conn=conn)",
            "    if not user_wallet:",
            "        raise InvoiceError(f\"Could not fetch wallet '{wallet_id}'.\")",
            "",
            "    invoice_memo = None if description_hash else memo",
            "",
            "    # use the fake wallet if the invoice is for internal use only",
            "    funding_source = fake_wallet if internal else get_funding_source()",
            "",
            "    amount_sat, extra = await calculate_fiat_amounts(",
            "        amount, wallet_id, currency=currency, extra=extra, conn=conn",
            "    )",
            "",
            "    if settings.is_wallet_max_balance_exceeded(",
            "        user_wallet.balance_msat / 1000 + amount_sat",
            "    ):",
            "        raise InvoiceError(",
            "            f\"Wallet balance  cannot exceed \"",
            "            f\"{settings.lnbits_wallet_limit_max_balance} sats.\"",
            "        )",
            "",
            "    (",
            "        ok,",
            "        checking_id,",
            "        payment_request,",
            "        error_message,",
            "    ) = await funding_source.create_invoice(",
            "        amount=amount_sat,",
            "        memo=invoice_memo,",
            "        description_hash=description_hash,",
            "        unhashed_description=unhashed_description,",
            "        expiry=expiry or settings.lightning_invoice_expiry,",
            "    )",
            "    if not ok or not payment_request or not checking_id:",
            "        raise InvoiceError(error_message or \"unexpected backend error.\")",
            "",
            "    invoice = bolt11_decode(payment_request)",
            "",
            "    amount_msat = 1000 * amount_sat",
            "    await create_payment(",
            "        wallet_id=wallet_id,",
            "        checking_id=checking_id,",
            "        payment_request=payment_request,",
            "        payment_hash=invoice.payment_hash,",
            "        amount=amount_msat,",
            "        expiry=get_bolt11_expiry(invoice),",
            "        memo=memo,",
            "        extra=extra,",
            "        webhook=webhook,",
            "        conn=conn,",
            "    )",
            "",
            "    return invoice.payment_hash, payment_request",
            "",
            "",
            "async def pay_invoice(",
            "    *,",
            "    wallet_id: str,",
            "    payment_request: str,",
            "    max_sat: Optional[int] = None,",
            "    extra: Optional[Dict] = None,",
            "    description: str = \"\",",
            "    conn: Optional[Connection] = None,",
            ") -> str:",
            "    \"\"\"",
            "    Pay a Lightning invoice.",
            "    First, we create a temporary payment in the database with fees set to the reserve",
            "    fee. We then check whether the balance of the payer would go negative.",
            "    We then attempt to pay the invoice through the backend. If the payment is",
            "    successful, we update the payment in the database with the payment details.",
            "    If the payment is unsuccessful, we delete the temporary payment.",
            "    If the payment is still in flight, we hope that some other process",
            "    will regularly check for the payment.",
            "    \"\"\"",
            "    try:",
            "        invoice = bolt11_decode(payment_request)",
            "    except Exception as exc:",
            "        raise InvoiceError(\"Bolt11 decoding failed.\") from exc",
            "",
            "    if not invoice.amount_msat or not invoice.amount_msat > 0:",
            "        raise InvoiceError(\"Amountless invoices not supported.\")",
            "    if max_sat and invoice.amount_msat > max_sat * 1000:",
            "        raise InvoiceError(\"Amount in invoice is too high.\")",
            "",
            "    await check_wallet_limits(wallet_id, conn, invoice.amount_msat)",
            "",
            "    async with db.reuse_conn(conn) if conn else db.connect() as conn:",
            "        temp_id = invoice.payment_hash",
            "        internal_id = f\"internal_{invoice.payment_hash}\"",
            "",
            "        _, extra = await calculate_fiat_amounts(",
            "            invoice.amount_msat / 1000, wallet_id, extra=extra, conn=conn",
            "        )",
            "",
            "        # put all parameters that don't change here",
            "        class PaymentKwargs(TypedDict):",
            "            wallet_id: str",
            "            payment_request: str",
            "            payment_hash: str",
            "            amount: int",
            "            memo: str",
            "            expiry: Optional[datetime.datetime]",
            "            extra: Optional[Dict]",
            "",
            "        payment_kwargs: PaymentKwargs = PaymentKwargs(",
            "            wallet_id=wallet_id,",
            "            payment_request=payment_request,",
            "            payment_hash=invoice.payment_hash,",
            "            amount=-invoice.amount_msat,",
            "            expiry=get_bolt11_expiry(invoice),",
            "            memo=description or invoice.description or \"\",",
            "            extra=extra,",
            "        )",
            "",
            "        # we check if an internal invoice exists that has already been paid",
            "        # (not pending anymore)",
            "        if not await check_internal_pending(invoice.payment_hash, conn=conn):",
            "            raise PaymentError(\"Internal invoice already paid.\")",
            "",
            "        # check_internal() returns the checking_id of the invoice we're waiting for",
            "        # (pending only)",
            "        internal_checking_id = await check_internal(invoice.payment_hash, conn=conn)",
            "        if internal_checking_id:",
            "            fee_reserve_total_msat = fee_reserve_total(",
            "                invoice.amount_msat, internal=True",
            "            )",
            "            # perform additional checks on the internal payment",
            "            # the payment hash is not enough to make sure that this is the same invoice",
            "            internal_invoice = await get_standalone_payment(",
            "                internal_checking_id, incoming=True, conn=conn",
            "            )",
            "            assert internal_invoice is not None",
            "            if (",
            "                internal_invoice.amount != invoice.amount_msat",
            "                or internal_invoice.bolt11 != payment_request.lower()",
            "            ):",
            "                raise PaymentError(\"Invalid invoice.\")",
            "",
            "            logger.debug(f\"creating temporary internal payment with id {internal_id}\")",
            "            # create a new payment from this wallet",
            "            new_payment = await create_payment(",
            "                checking_id=internal_id,",
            "                fee=0 + abs(fee_reserve_total_msat),",
            "                pending=False,",
            "                conn=conn,",
            "                **payment_kwargs,",
            "            )",
            "        else:",
            "            fee_reserve_total_msat = fee_reserve_total(",
            "                invoice.amount_msat, internal=False",
            "            )",
            "            logger.debug(f\"creating temporary payment with id {temp_id}\")",
            "            # create a temporary payment here so we can check if",
            "            # the balance is enough in the next step",
            "            try:",
            "                new_payment = await create_payment(",
            "                    checking_id=temp_id,",
            "                    fee=-abs(fee_reserve_total_msat),",
            "                    conn=conn,",
            "                    **payment_kwargs,",
            "                )",
            "            except Exception as exc:",
            "                logger.error(f\"could not create temporary payment: {exc}\")",
            "                # happens if the same wallet tries to pay an invoice twice",
            "                raise PaymentError(\"Could not make payment.\") from exc",
            "",
            "        # do the balance check",
            "        wallet = await get_wallet(wallet_id, conn=conn)",
            "        assert wallet, \"Wallet for balancecheck could not be fetched\"",
            "        if wallet.balance_msat < 0:",
            "            logger.debug(\"balance is too low, deleting temporary payment\")",
            "            if (",
            "                not internal_checking_id",
            "                and wallet.balance_msat > -fee_reserve_total_msat",
            "            ):",
            "                raise PaymentError(",
            "                    f\"You must reserve at least ({round(fee_reserve_total_msat/1000)}\"",
            "                    \"  sat) to cover potential routing fees.\"",
            "                )",
            "            raise PermissionError(\"Insufficient balance.\")",
            "",
            "    if internal_checking_id:",
            "        service_fee_msat = service_fee(invoice.amount_msat, internal=True)",
            "        logger.debug(f\"marking temporary payment as not pending {internal_checking_id}\")",
            "        # mark the invoice from the other side as not pending anymore",
            "        # so the other side only has access to his new money when we are sure",
            "        # the payer has enough to deduct from",
            "        async with db.connect() as conn:",
            "            await update_payment_status(",
            "                checking_id=internal_checking_id, pending=False, conn=conn",
            "            )",
            "        await send_payment_notification(wallet, new_payment)",
            "",
            "        # notify receiver asynchronously",
            "        from lnbits.tasks import internal_invoice_queue",
            "",
            "        logger.debug(f\"enqueuing internal invoice {internal_checking_id}\")",
            "        await internal_invoice_queue.put(internal_checking_id)",
            "    else:",
            "        fee_reserve_msat = fee_reserve(invoice.amount_msat, internal=False)",
            "        service_fee_msat = service_fee(invoice.amount_msat, internal=False)",
            "        logger.debug(f\"backend: sending payment {temp_id}\")",
            "        # actually pay the external invoice",
            "        funding_source = get_funding_source()",
            "        payment: PaymentResponse = await funding_source.pay_invoice(",
            "            payment_request, fee_reserve_msat",
            "        )",
            "",
            "        if payment.checking_id and payment.checking_id != temp_id:",
            "            logger.warning(",
            "                f\"backend sent unexpected checking_id (expected: {temp_id} got:\"",
            "                f\" {payment.checking_id})\"",
            "            )",
            "",
            "        logger.debug(f\"backend: pay_invoice finished {temp_id}\")",
            "        if payment.checking_id and payment.ok is not False:",
            "            # payment.ok can be True (paid) or None (pending)!",
            "            logger.debug(f\"updating payment {temp_id}\")",
            "            async with db.connect() as conn:",
            "                await update_payment_details(",
            "                    checking_id=temp_id,",
            "                    pending=payment.ok is not True,",
            "                    fee=-(",
            "                        abs(payment.fee_msat if payment.fee_msat else 0)",
            "                        + abs(service_fee_msat)",
            "                    ),",
            "                    preimage=payment.preimage,",
            "                    new_checking_id=payment.checking_id,",
            "                    conn=conn,",
            "                )",
            "                wallet = await get_wallet(wallet_id, conn=conn)",
            "                updated = await get_wallet_payment(",
            "                    wallet_id, payment.checking_id, conn=conn",
            "                )",
            "                if wallet and updated:",
            "                    await send_payment_notification(wallet, updated)",
            "                logger.debug(f\"payment successful {payment.checking_id}\")",
            "        elif payment.checking_id is None and payment.ok is False:",
            "            # payment failed",
            "            logger.warning(\"backend sent payment failure\")",
            "            async with db.connect() as conn:",
            "                logger.debug(f\"deleting temporary payment {temp_id}\")",
            "                await delete_wallet_payment(temp_id, wallet_id, conn=conn)",
            "            raise PaymentError(",
            "                f\"Payment failed: {payment.error_message}\"",
            "                or \"Payment failed, but backend didn't give us an error message.\"",
            "            )",
            "        else:",
            "            logger.warning(",
            "                \"didn't receive checking_id from backend, payment may be stuck in\"",
            "                f\" database: {temp_id}\"",
            "            )",
            "",
            "    # credit service fee wallet",
            "    if settings.lnbits_service_fee_wallet and service_fee_msat:",
            "        new_payment = await create_payment(",
            "            wallet_id=settings.lnbits_service_fee_wallet,",
            "            fee=0,",
            "            amount=abs(service_fee_msat),",
            "            memo=\"Service fee\",",
            "            checking_id=\"service_fee\" + temp_id,",
            "            payment_request=payment_request,",
            "            payment_hash=invoice.payment_hash,",
            "            pending=False,",
            "        )",
            "    return invoice.payment_hash",
            "",
            "",
            "async def check_wallet_limits(wallet_id, conn, amount_msat):",
            "    await check_time_limit_between_transactions(conn, wallet_id)",
            "    await check_wallet_daily_withdraw_limit(conn, wallet_id, amount_msat)",
            "",
            "",
            "async def check_time_limit_between_transactions(conn, wallet_id):",
            "    limit = settings.lnbits_wallet_limit_secs_between_trans",
            "    if not limit or limit <= 0:",
            "        return",
            "",
            "    payments = await get_payments(",
            "        since=int(time.time()) - limit,",
            "        wallet_id=wallet_id,",
            "        limit=1,",
            "        conn=conn,",
            "    )",
            "",
            "    if len(payments) == 0:",
            "        return",
            "",
            "    raise ValueError(",
            "        f\"The time limit of {limit} seconds between payments has been reached.\"",
            "    )",
            "",
            "",
            "async def check_wallet_daily_withdraw_limit(conn, wallet_id, amount_msat):",
            "    limit = settings.lnbits_wallet_limit_daily_max_withdraw",
            "    if not limit or limit <= 0:",
            "        return",
            "",
            "    payments = await get_payments(",
            "        since=int(time.time()) - 60 * 60 * 24,",
            "        outgoing=True,",
            "        wallet_id=wallet_id,",
            "        limit=1,",
            "        conn=conn,",
            "    )",
            "    if len(payments) == 0:",
            "        return",
            "",
            "    total = 0",
            "    for pay in payments:",
            "        total += pay.amount",
            "    total = total - amount_msat",
            "    if limit * 1000 + total < 0:",
            "        raise ValueError(",
            "            \"Daily withdrawal limit of \"",
            "            + str(settings.lnbits_wallet_limit_daily_max_withdraw)",
            "            + \" sats reached.\"",
            "        )",
            "",
            "",
            "async def redeem_lnurl_withdraw(",
            "    wallet_id: str,",
            "    lnurl_request: str,",
            "    memo: Optional[str] = None,",
            "    extra: Optional[Dict] = None,",
            "    wait_seconds: int = 0,",
            "    conn: Optional[Connection] = None,",
            ") -> None:",
            "    if not lnurl_request:",
            "        return None",
            "",
            "    res = {}",
            "",
            "    headers = {\"User-Agent\": settings.user_agent}",
            "    async with httpx.AsyncClient(headers=headers) as client:",
            "        lnurl = decode_lnurl(lnurl_request)",
            "        r = await client.get(str(lnurl))",
            "        res = r.json()",
            "",
            "    try:",
            "        _, payment_request = await create_invoice(",
            "            wallet_id=wallet_id,",
            "            amount=int(res[\"maxWithdrawable\"] / 1000),",
            "            memo=memo or res[\"defaultDescription\"] or \"\",",
            "            extra=extra,",
            "            conn=conn,",
            "        )",
            "    except Exception:",
            "        logger.warning(",
            "            f\"failed to create invoice on redeem_lnurl_withdraw \"",
            "            f\"from {lnurl}. params: {res}\"",
            "        )",
            "        return None",
            "",
            "    if wait_seconds:",
            "        await asyncio.sleep(wait_seconds)",
            "",
            "    params = {\"k1\": res[\"k1\"], \"pr\": payment_request}",
            "",
            "    try:",
            "        params[\"balanceNotify\"] = url_for(",
            "            f\"/withdraw/notify/{urlparse(lnurl_request).netloc}\",",
            "            external=True,",
            "            wal=wallet_id,",
            "        )",
            "    except Exception:",
            "        pass",
            "",
            "    headers = {\"User-Agent\": settings.user_agent}",
            "    async with httpx.AsyncClient(headers=headers) as client:",
            "        try:",
            "            await client.get(res[\"callback\"], params=params)",
            "        except Exception:",
            "            pass",
            "",
            "",
            "async def perform_lnurlauth(",
            "    callback: str,",
            "    wallet: WalletTypeInfo = Depends(require_admin_key),",
            ") -> Optional[LnurlErrorResponse]:",
            "    cb = urlparse(callback)",
            "",
            "    k1 = bytes.fromhex(parse_qs(cb.query)[\"k1\"][0])",
            "",
            "    key = wallet.wallet.lnurlauth_key(cb.netloc)",
            "",
            "    def int_to_bytes_suitable_der(x: int) -> bytes:",
            "        \"\"\"for strict DER we need to encode the integer with some quirks\"\"\"",
            "        b = x.to_bytes((x.bit_length() + 7) // 8, \"big\")",
            "",
            "        if len(b) == 0:",
            "            # ensure there's at least one byte when the int is zero",
            "            return bytes([0])",
            "",
            "        if b[0] & 0x80 != 0:",
            "            # ensure it doesn't start with a 0x80 and so it isn't",
            "            # interpreted as a negative number",
            "            return bytes([0]) + b",
            "",
            "        return b",
            "",
            "    def encode_strict_der(r: int, s: int, order: int):",
            "        # if s > order/2 verification will fail sometimes",
            "        # so we must fix it here see:",
            "        # https://github.com/indutny/elliptic/blob/e71b2d9359c5fe9437fbf46f1f05096de447de57/lib/elliptic/ec/index.js#L146-L147",
            "        if s > order // 2:",
            "            s = order - s",
            "",
            "        # now we do the strict DER encoding copied from",
            "        # https://github.com/KiriKiri/bip66 (without any checks)",
            "        r_temp = int_to_bytes_suitable_der(r)",
            "        s_temp = int_to_bytes_suitable_der(s)",
            "",
            "        r_len = len(r_temp)",
            "        s_len = len(s_temp)",
            "        sign_len = 6 + r_len + s_len",
            "",
            "        signature = BytesIO()",
            "        signature.write(0x30.to_bytes(1, \"big\", signed=False))",
            "        signature.write((sign_len - 2).to_bytes(1, \"big\", signed=False))",
            "        signature.write(0x02.to_bytes(1, \"big\", signed=False))",
            "        signature.write(r_len.to_bytes(1, \"big\", signed=False))",
            "        signature.write(r_temp)",
            "        signature.write(0x02.to_bytes(1, \"big\", signed=False))",
            "        signature.write(s_len.to_bytes(1, \"big\", signed=False))",
            "        signature.write(s_temp)",
            "",
            "        return signature.getvalue()",
            "",
            "    sig = key.sign_digest_deterministic(k1, sigencode=encode_strict_der)",
            "",
            "    headers = {\"User-Agent\": settings.user_agent}",
            "    async with httpx.AsyncClient(headers=headers) as client:",
            "        assert key.verifying_key, \"LNURLauth verifying_key does not exist\"",
            "        r = await client.get(",
            "            callback,",
            "            params={",
            "                \"k1\": k1.hex(),",
            "                \"key\": key.verifying_key.to_string(\"compressed\").hex(),",
            "                \"sig\": sig.hex(),",
            "            },",
            "        )",
            "        try:",
            "            resp = json.loads(r.text)",
            "            if resp[\"status\"] == \"OK\":",
            "                return None",
            "",
            "            return LnurlErrorResponse(reason=resp[\"reason\"])",
            "        except (KeyError, json.decoder.JSONDecodeError):",
            "            return LnurlErrorResponse(",
            "                reason=r.text[:200] + \"...\" if len(r.text) > 200 else r.text",
            "            )",
            "",
            "",
            "async def check_transaction_status(",
            "    wallet_id: str, payment_hash: str, conn: Optional[Connection] = None",
            ") -> PaymentStatus:",
            "    payment: Optional[Payment] = await get_wallet_payment(",
            "        wallet_id, payment_hash, conn=conn",
            "    )",
            "    if not payment:",
            "        return PaymentPendingStatus()",
            "    if not payment.pending:",
            "        # note: before, we still checked the status of the payment again",
            "        return PaymentSuccessStatus(fee_msat=payment.fee)",
            "",
            "    status: PaymentStatus = await payment.check_status()",
            "    return status",
            "",
            "",
            "# WARN: this same value must be used for balance check and passed to",
            "# funding_source.pay_invoice(), it may cause a vulnerability if the values differ",
            "def fee_reserve(amount_msat: int, internal: bool = False) -> int:",
            "    if internal:",
            "        return 0",
            "    reserve_min = settings.lnbits_reserve_fee_min",
            "    reserve_percent = settings.lnbits_reserve_fee_percent",
            "    return max(int(reserve_min), int(amount_msat * reserve_percent / 100.0))",
            "",
            "",
            "def service_fee(amount_msat: int, internal: bool = False) -> int:",
            "    service_fee_percent = settings.lnbits_service_fee",
            "    fee_max = settings.lnbits_service_fee_max * 1000",
            "    if settings.lnbits_service_fee_wallet:",
            "        if internal and settings.lnbits_service_fee_ignore_internal:",
            "            return 0",
            "        fee_percentage = int(amount_msat / 100 * service_fee_percent)",
            "        if fee_max > 0 and fee_percentage > fee_max:",
            "            return fee_max",
            "        else:",
            "            return fee_percentage",
            "    else:",
            "        return 0",
            "",
            "",
            "def fee_reserve_total(amount_msat: int, internal: bool = False) -> int:",
            "    return fee_reserve(amount_msat, internal) + service_fee(amount_msat, internal)",
            "",
            "",
            "async def send_payment_notification(wallet: Wallet, payment: Payment):",
            "    await websocket_updater(",
            "        wallet.id,",
            "        json.dumps(",
            "            {",
            "                \"wallet_balance\": wallet.balance,",
            "                \"payment\": payment.dict(),",
            "            }",
            "        ),",
            "    )",
            "",
            "",
            "async def update_wallet_balance(wallet_id: str, amount: int):",
            "    payment_hash, _ = await create_invoice(",
            "        wallet_id=wallet_id,",
            "        amount=amount,",
            "        memo=\"Admin top up\",",
            "        internal=True,",
            "    )",
            "    async with db.connect() as conn:",
            "        checking_id = await check_internal(payment_hash, conn=conn)",
            "        assert checking_id, \"newly created checking_id cannot be retrieved\"",
            "        await update_payment_status(checking_id=checking_id, pending=False, conn=conn)",
            "        # notify receiver asynchronously",
            "        from lnbits.tasks import internal_invoice_queue",
            "",
            "        await internal_invoice_queue.put(checking_id)",
            "",
            "",
            "async def check_admin_settings():",
            "    if settings.super_user:",
            "        settings.super_user = to_valid_user_id(settings.super_user).hex",
            "",
            "    if settings.lnbits_admin_ui:",
            "        settings_db = await get_super_settings()",
            "        if not settings_db:",
            "            # create new settings if table is empty",
            "            logger.warning(\"Settings DB empty. Inserting default settings.\")",
            "            settings_db = await init_admin_settings(settings.super_user)",
            "            logger.warning(\"Initialized settings from environment variables.\")",
            "",
            "        if settings.super_user and settings.super_user != settings_db.super_user:",
            "            # .env super_user overwrites DB super_user",
            "            settings_db = await update_super_user(settings.super_user)",
            "",
            "        update_cached_settings(settings_db.dict())",
            "",
            "        # saving superuser to {data_dir}/.super_user file",
            "        with open(Path(settings.lnbits_data_folder) / \".super_user\", \"w\") as file:",
            "            file.write(settings.super_user)",
            "",
            "        # callback for saas",
            "        if (",
            "            settings.lnbits_saas_callback",
            "            and settings.lnbits_saas_secret",
            "            and settings.lnbits_saas_instance_id",
            "        ):",
            "            send_admin_user_to_saas()",
            "",
            "        account = await get_account(settings.super_user)",
            "        if account and account.config and account.config.provider == \"env\":",
            "            settings.first_install = True",
            "",
            "        logger.success(",
            "            \"\u2714\ufe0f Admin UI is enabled. run `poetry run lnbits-cli superuser` \"",
            "            \"to get the superuser.\"",
            "        )",
            "",
            "",
            "async def check_webpush_settings():",
            "    if not settings.lnbits_webpush_privkey:",
            "        vapid = Vapid()",
            "        vapid.generate_keys()",
            "        privkey = vapid.private_pem()",
            "        assert vapid.public_key, \"VAPID public key does not exist\"",
            "        pubkey = b64urlencode(",
            "            vapid.public_key.public_bytes(",
            "                serialization.Encoding.X962,",
            "                serialization.PublicFormat.UncompressedPoint,",
            "            )",
            "        )",
            "        push_settings = {",
            "            \"lnbits_webpush_privkey\": privkey.decode(),",
            "            \"lnbits_webpush_pubkey\": pubkey,",
            "        }",
            "        update_cached_settings(push_settings)",
            "        await update_admin_settings(EditableSettings(**push_settings))",
            "",
            "    logger.info(\"Initialized webpush settings with generated VAPID key pair.\")",
            "    logger.info(f\"Pubkey: {settings.lnbits_webpush_pubkey}\")",
            "",
            "",
            "def update_cached_settings(sets_dict: dict):",
            "    for key, value in sets_dict.items():",
            "        if key in readonly_variables:",
            "            continue",
            "        if key not in settings.dict().keys():",
            "            continue",
            "        try:",
            "            setattr(settings, key, value)",
            "        except Exception:",
            "            logger.warning(f\"Failed overriding setting: {key}, value: {value}\")",
            "    if \"super_user\" in sets_dict:",
            "        settings.super_user = sets_dict[\"super_user\"]",
            "",
            "",
            "async def init_admin_settings(super_user: Optional[str] = None) -> SuperSettings:",
            "    account = None",
            "    if super_user:",
            "        account = await get_account(super_user)",
            "    if not account:",
            "        account = await create_account(",
            "            user_id=super_user, user_config=UserConfig(provider=\"env\")",
            "        )",
            "    if not account.wallets or len(account.wallets) == 0:",
            "        await create_wallet(user_id=account.id)",
            "",
            "    editable_settings = EditableSettings.from_dict(settings.dict())",
            "",
            "    return await create_admin_settings(account.id, editable_settings.dict())",
            "",
            "",
            "class WebsocketConnectionManager:",
            "    def __init__(self) -> None:",
            "        self.active_connections: List[WebSocket] = []",
            "",
            "    async def connect(self, websocket: WebSocket, item_id: str):",
            "        logger.debug(f\"Websocket connected to {item_id}\")",
            "        await websocket.accept()",
            "        self.active_connections.append(websocket)",
            "",
            "    def disconnect(self, websocket: WebSocket):",
            "        self.active_connections.remove(websocket)",
            "",
            "    async def send_data(self, message: str, item_id: str):",
            "        for connection in self.active_connections:",
            "            if connection.path_params[\"item_id\"] == item_id:",
            "                await connection.send_text(message)",
            "",
            "",
            "websocket_manager = WebsocketConnectionManager()",
            "",
            "",
            "async def websocket_updater(item_id, data):",
            "    return await websocket_manager.send_data(f\"{data}\", item_id)",
            "",
            "",
            "async def switch_to_voidwallet() -> None:",
            "    funding_source = get_funding_source()",
            "    if funding_source.__class__.__name__ == \"VoidWallet\":",
            "        return",
            "    set_funding_source(\"VoidWallet\")",
            "    settings.lnbits_backend_wallet_class = \"VoidWallet\"",
            "",
            "",
            "async def get_balance_delta() -> Tuple[int, int, int]:",
            "    funding_source = get_funding_source()",
            "    total_balance = await get_total_balance()",
            "    error_message, node_balance = await funding_source.status()",
            "    if error_message:",
            "        raise Exception(error_message)",
            "    return node_balance - total_balance, node_balance, total_balance",
            "",
            "",
            "def get_bolt11_expiry(invoice: Bolt11) -> datetime.datetime:",
            "    if invoice.expiry:",
            "        return datetime.datetime.fromtimestamp(invoice.date + invoice.expiry)",
            "    else:",
            "        # assume maximum bolt11 expiry of 31 days to be on the safe side",
            "        return datetime.datetime.now() + datetime.timedelta(days=31)"
        ],
        "afterPatchFile": [
            "import asyncio",
            "import datetime",
            "import json",
            "import time",
            "from io import BytesIO",
            "from pathlib import Path",
            "from typing import Dict, List, Optional, Tuple, TypedDict",
            "from urllib.parse import parse_qs, urlparse",
            "",
            "import httpx",
            "from bolt11 import Bolt11",
            "from bolt11 import decode as bolt11_decode",
            "from cryptography.hazmat.primitives import serialization",
            "from fastapi import Depends, WebSocket",
            "from loguru import logger",
            "from py_vapid import Vapid",
            "from py_vapid.utils import b64urlencode",
            "",
            "from lnbits.core.db import db",
            "from lnbits.db import Connection",
            "from lnbits.decorators import WalletTypeInfo, require_admin_key",
            "from lnbits.helpers import url_for",
            "from lnbits.lnurl import LnurlErrorResponse",
            "from lnbits.lnurl import decode as decode_lnurl",
            "from lnbits.settings import (",
            "    EditableSettings,",
            "    SuperSettings,",
            "    readonly_variables,",
            "    send_admin_user_to_saas,",
            "    settings,",
            ")",
            "from lnbits.utils.exchange_rates import fiat_amount_as_satoshis, satoshis_amount_as_fiat",
            "from lnbits.wallets import fake_wallet, get_funding_source, set_funding_source",
            "from lnbits.wallets.base import (",
            "    PaymentPendingStatus,",
            "    PaymentResponse,",
            "    PaymentStatus,",
            "    PaymentSuccessStatus,",
            ")",
            "",
            "from .crud import (",
            "    check_internal,",
            "    check_internal_pending,",
            "    create_account,",
            "    create_admin_settings,",
            "    create_payment,",
            "    create_wallet,",
            "    delete_wallet_payment,",
            "    get_account,",
            "    get_payments,",
            "    get_standalone_payment,",
            "    get_super_settings,",
            "    get_total_balance,",
            "    get_wallet,",
            "    get_wallet_payment,",
            "    update_admin_settings,",
            "    update_payment_details,",
            "    update_payment_status,",
            "    update_super_user,",
            ")",
            "from .helpers import to_valid_user_id",
            "from .models import Payment, UserConfig, Wallet",
            "",
            "",
            "class PaymentError(Exception):",
            "    def __init__(self, message: str, status: str = \"pending\"):",
            "        self.message = message",
            "        self.status = status",
            "",
            "",
            "class InvoiceError(Exception):",
            "    def __init__(self, message: str, status: str = \"pending\"):",
            "        self.message = message",
            "        self.status = status",
            "",
            "",
            "async def calculate_fiat_amounts(",
            "    amount: float,",
            "    wallet_id: str,",
            "    currency: Optional[str] = None,",
            "    extra: Optional[Dict] = None,",
            "    conn: Optional[Connection] = None,",
            ") -> Tuple[int, Optional[Dict]]:",
            "    wallet = await get_wallet(wallet_id, conn=conn)",
            "    assert wallet, \"invalid wallet_id\"",
            "    wallet_currency = wallet.currency or settings.lnbits_default_accounting_currency",
            "",
            "    if currency and currency != \"sat\":",
            "        amount_sat = await fiat_amount_as_satoshis(amount, currency)",
            "        extra = extra or {}",
            "        if currency != wallet_currency:",
            "            extra[\"fiat_currency\"] = currency",
            "            extra[\"fiat_amount\"] = round(amount, ndigits=3)",
            "            extra[\"fiat_rate\"] = amount_sat / amount",
            "    else:",
            "        amount_sat = int(amount)",
            "",
            "    if wallet_currency:",
            "        if wallet_currency == currency:",
            "            fiat_amount = amount",
            "        else:",
            "            fiat_amount = await satoshis_amount_as_fiat(amount_sat, wallet_currency)",
            "        extra = extra or {}",
            "        extra[\"wallet_fiat_currency\"] = wallet_currency",
            "        extra[\"wallet_fiat_amount\"] = round(fiat_amount, ndigits=3)",
            "        extra[\"wallet_fiat_rate\"] = amount_sat / fiat_amount",
            "",
            "    logger.debug(",
            "        f\"Calculated fiat amounts {wallet.id=} {amount=} {currency=}: {extra=}\"",
            "    )",
            "",
            "    return amount_sat, extra",
            "",
            "",
            "async def create_invoice(",
            "    *,",
            "    wallet_id: str,",
            "    amount: float,",
            "    currency: Optional[str] = \"sat\",",
            "    memo: str,",
            "    description_hash: Optional[bytes] = None,",
            "    unhashed_description: Optional[bytes] = None,",
            "    expiry: Optional[int] = None,",
            "    extra: Optional[Dict] = None,",
            "    webhook: Optional[str] = None,",
            "    internal: Optional[bool] = False,",
            "    conn: Optional[Connection] = None,",
            ") -> Tuple[str, str]:",
            "    if not amount > 0:",
            "        raise InvoiceError(\"Amountless invoices not supported.\", status=\"failed\")",
            "",
            "    user_wallet = await get_wallet(wallet_id, conn=conn)",
            "    if not user_wallet:",
            "        raise InvoiceError(f\"Could not fetch wallet '{wallet_id}'.\", status=\"failed\")",
            "",
            "    invoice_memo = None if description_hash else memo",
            "",
            "    # use the fake wallet if the invoice is for internal use only",
            "    funding_source = fake_wallet if internal else get_funding_source()",
            "",
            "    amount_sat, extra = await calculate_fiat_amounts(",
            "        amount, wallet_id, currency=currency, extra=extra, conn=conn",
            "    )",
            "",
            "    if settings.is_wallet_max_balance_exceeded(",
            "        user_wallet.balance_msat / 1000 + amount_sat",
            "    ):",
            "        raise InvoiceError(",
            "            f\"Wallet balance cannot exceed \"",
            "            f\"{settings.lnbits_wallet_limit_max_balance} sats.\",",
            "            status=\"failed\",",
            "        )",
            "",
            "    (",
            "        ok,",
            "        checking_id,",
            "        payment_request,",
            "        error_message,",
            "    ) = await funding_source.create_invoice(",
            "        amount=amount_sat,",
            "        memo=invoice_memo,",
            "        description_hash=description_hash,",
            "        unhashed_description=unhashed_description,",
            "        expiry=expiry or settings.lightning_invoice_expiry,",
            "    )",
            "    if not ok or not payment_request or not checking_id:",
            "        raise InvoiceError(",
            "            error_message or \"unexpected backend error.\", status=\"pending\"",
            "        )",
            "",
            "    invoice = bolt11_decode(payment_request)",
            "",
            "    amount_msat = 1000 * amount_sat",
            "    await create_payment(",
            "        wallet_id=wallet_id,",
            "        checking_id=checking_id,",
            "        payment_request=payment_request,",
            "        payment_hash=invoice.payment_hash,",
            "        amount=amount_msat,",
            "        expiry=get_bolt11_expiry(invoice),",
            "        memo=memo,",
            "        extra=extra,",
            "        webhook=webhook,",
            "        conn=conn,",
            "    )",
            "",
            "    return invoice.payment_hash, payment_request",
            "",
            "",
            "async def pay_invoice(",
            "    *,",
            "    wallet_id: str,",
            "    payment_request: str,",
            "    max_sat: Optional[int] = None,",
            "    extra: Optional[Dict] = None,",
            "    description: str = \"\",",
            "    conn: Optional[Connection] = None,",
            ") -> str:",
            "    \"\"\"",
            "    Pay a Lightning invoice.",
            "    First, we create a temporary payment in the database with fees set to the reserve",
            "    fee. We then check whether the balance of the payer would go negative.",
            "    We then attempt to pay the invoice through the backend. If the payment is",
            "    successful, we update the payment in the database with the payment details.",
            "    If the payment is unsuccessful, we delete the temporary payment.",
            "    If the payment is still in flight, we hope that some other process",
            "    will regularly check for the payment.",
            "    \"\"\"",
            "    try:",
            "        invoice = bolt11_decode(payment_request)",
            "    except Exception as exc:",
            "        raise PaymentError(\"Bolt11 decoding failed.\", status=\"failed\") from exc",
            "",
            "    if not invoice.amount_msat or not invoice.amount_msat > 0:",
            "        raise PaymentError(\"Amountless invoices not supported.\", status=\"failed\")",
            "    if max_sat and invoice.amount_msat > max_sat * 1000:",
            "        raise PaymentError(\"Amount in invoice is too high.\", status=\"failed\")",
            "",
            "    await check_wallet_limits(wallet_id, conn, invoice.amount_msat)",
            "",
            "    async with db.reuse_conn(conn) if conn else db.connect() as conn:",
            "        temp_id = invoice.payment_hash",
            "        internal_id = f\"internal_{invoice.payment_hash}\"",
            "",
            "        _, extra = await calculate_fiat_amounts(",
            "            invoice.amount_msat / 1000, wallet_id, extra=extra, conn=conn",
            "        )",
            "",
            "        # put all parameters that don't change here",
            "        class PaymentKwargs(TypedDict):",
            "            wallet_id: str",
            "            payment_request: str",
            "            payment_hash: str",
            "            amount: int",
            "            memo: str",
            "            expiry: Optional[datetime.datetime]",
            "            extra: Optional[Dict]",
            "",
            "        payment_kwargs: PaymentKwargs = PaymentKwargs(",
            "            wallet_id=wallet_id,",
            "            payment_request=payment_request,",
            "            payment_hash=invoice.payment_hash,",
            "            amount=-invoice.amount_msat,",
            "            expiry=get_bolt11_expiry(invoice),",
            "            memo=description or invoice.description or \"\",",
            "            extra=extra,",
            "        )",
            "",
            "        # we check if an internal invoice exists that has already been paid",
            "        # (not pending anymore)",
            "        if not await check_internal_pending(invoice.payment_hash, conn=conn):",
            "            raise PaymentError(\"Internal invoice already paid.\", status=\"failed\")",
            "",
            "        # check_internal() returns the checking_id of the invoice we're waiting for",
            "        # (pending only)",
            "        internal_checking_id = await check_internal(invoice.payment_hash, conn=conn)",
            "        if internal_checking_id:",
            "            fee_reserve_total_msat = fee_reserve_total(",
            "                invoice.amount_msat, internal=True",
            "            )",
            "            # perform additional checks on the internal payment",
            "            # the payment hash is not enough to make sure that this is the same invoice",
            "            internal_invoice = await get_standalone_payment(",
            "                internal_checking_id, incoming=True, conn=conn",
            "            )",
            "            assert internal_invoice is not None",
            "            if (",
            "                internal_invoice.amount != invoice.amount_msat",
            "                or internal_invoice.bolt11 != payment_request.lower()",
            "            ):",
            "                raise PaymentError(\"Invalid invoice.\", status=\"failed\")",
            "",
            "            logger.debug(f\"creating temporary internal payment with id {internal_id}\")",
            "            # create a new payment from this wallet",
            "            new_payment = await create_payment(",
            "                checking_id=internal_id,",
            "                fee=0 + abs(fee_reserve_total_msat),",
            "                pending=False,",
            "                conn=conn,",
            "                **payment_kwargs,",
            "            )",
            "        else:",
            "            fee_reserve_total_msat = fee_reserve_total(",
            "                invoice.amount_msat, internal=False",
            "            )",
            "            logger.debug(f\"creating temporary payment with id {temp_id}\")",
            "            # create a temporary payment here so we can check if",
            "            # the balance is enough in the next step",
            "            try:",
            "                new_payment = await create_payment(",
            "                    checking_id=temp_id,",
            "                    fee=-abs(fee_reserve_total_msat),",
            "                    conn=conn,",
            "                    **payment_kwargs,",
            "                )",
            "            except Exception as exc:",
            "                logger.error(f\"could not create temporary payment: {exc}\")",
            "                # happens if the same wallet tries to pay an invoice twice",
            "                raise PaymentError(\"Could not make payment.\", status=\"failed\") from exc",
            "",
            "        # do the balance check",
            "        wallet = await get_wallet(wallet_id, conn=conn)",
            "        assert wallet, \"Wallet for balancecheck could not be fetched\"",
            "        if wallet.balance_msat < 0:",
            "            logger.debug(\"balance is too low, deleting temporary payment\")",
            "            if (",
            "                not internal_checking_id",
            "                and wallet.balance_msat > -fee_reserve_total_msat",
            "            ):",
            "                raise PaymentError(",
            "                    f\"You must reserve at least ({round(fee_reserve_total_msat/1000)}\"",
            "                    \"  sat) to cover potential routing fees.\",",
            "                    status=\"failed\",",
            "                )",
            "            raise PaymentError(\"Insufficient balance.\", status=\"failed\")",
            "",
            "    if internal_checking_id:",
            "        service_fee_msat = service_fee(invoice.amount_msat, internal=True)",
            "        logger.debug(f\"marking temporary payment as not pending {internal_checking_id}\")",
            "        # mark the invoice from the other side as not pending anymore",
            "        # so the other side only has access to his new money when we are sure",
            "        # the payer has enough to deduct from",
            "        async with db.connect() as conn:",
            "            await update_payment_status(",
            "                checking_id=internal_checking_id, pending=False, conn=conn",
            "            )",
            "        await send_payment_notification(wallet, new_payment)",
            "",
            "        # notify receiver asynchronously",
            "        from lnbits.tasks import internal_invoice_queue",
            "",
            "        logger.debug(f\"enqueuing internal invoice {internal_checking_id}\")",
            "        await internal_invoice_queue.put(internal_checking_id)",
            "    else:",
            "        fee_reserve_msat = fee_reserve(invoice.amount_msat, internal=False)",
            "        service_fee_msat = service_fee(invoice.amount_msat, internal=False)",
            "        logger.debug(f\"backend: sending payment {temp_id}\")",
            "        # actually pay the external invoice",
            "        funding_source = get_funding_source()",
            "        payment: PaymentResponse = await funding_source.pay_invoice(",
            "            payment_request, fee_reserve_msat",
            "        )",
            "",
            "        if payment.checking_id and payment.checking_id != temp_id:",
            "            logger.warning(",
            "                f\"backend sent unexpected checking_id (expected: {temp_id} got:\"",
            "                f\" {payment.checking_id})\"",
            "            )",
            "",
            "        logger.debug(f\"backend: pay_invoice finished {temp_id}\")",
            "        logger.debug(f\"backend: pay_invoice response {payment}\")",
            "        if payment.checking_id and payment.ok is not False:",
            "            # payment.ok can be True (paid) or None (pending)!",
            "            logger.debug(f\"updating payment {temp_id}\")",
            "            async with db.connect() as conn:",
            "                await update_payment_details(",
            "                    checking_id=temp_id,",
            "                    pending=payment.ok is not True,",
            "                    fee=-(",
            "                        abs(payment.fee_msat if payment.fee_msat else 0)",
            "                        + abs(service_fee_msat)",
            "                    ),",
            "                    preimage=payment.preimage,",
            "                    new_checking_id=payment.checking_id,",
            "                    conn=conn,",
            "                )",
            "                wallet = await get_wallet(wallet_id, conn=conn)",
            "                updated = await get_wallet_payment(",
            "                    wallet_id, payment.checking_id, conn=conn",
            "                )",
            "                if wallet and updated:",
            "                    await send_payment_notification(wallet, updated)",
            "                logger.debug(f\"payment successful {payment.checking_id}\")",
            "        elif payment.checking_id is None and payment.ok is False:",
            "            # payment failed",
            "            logger.warning(\"backend sent payment failure\")",
            "            async with db.connect() as conn:",
            "                logger.debug(f\"deleting temporary payment {temp_id}\")",
            "                await delete_wallet_payment(temp_id, wallet_id, conn=conn)",
            "            raise PaymentError(",
            "                f\"Payment failed: {payment.error_message}\"",
            "                or \"Payment failed, but backend didn't give us an error message.\",",
            "                status=\"failed\",",
            "            )",
            "        else:",
            "            logger.warning(",
            "                \"didn't receive checking_id from backend, payment may be stuck in\"",
            "                f\" database: {temp_id}\"",
            "            )",
            "",
            "    # credit service fee wallet",
            "    if settings.lnbits_service_fee_wallet and service_fee_msat:",
            "        new_payment = await create_payment(",
            "            wallet_id=settings.lnbits_service_fee_wallet,",
            "            fee=0,",
            "            amount=abs(service_fee_msat),",
            "            memo=\"Service fee\",",
            "            checking_id=\"service_fee\" + temp_id,",
            "            payment_request=payment_request,",
            "            payment_hash=invoice.payment_hash,",
            "            pending=False,",
            "        )",
            "    return invoice.payment_hash",
            "",
            "",
            "async def check_wallet_limits(wallet_id, conn, amount_msat):",
            "    await check_time_limit_between_transactions(conn, wallet_id)",
            "    await check_wallet_daily_withdraw_limit(conn, wallet_id, amount_msat)",
            "",
            "",
            "async def check_time_limit_between_transactions(conn, wallet_id):",
            "    limit = settings.lnbits_wallet_limit_secs_between_trans",
            "    if not limit or limit <= 0:",
            "        return",
            "",
            "    payments = await get_payments(",
            "        since=int(time.time()) - limit,",
            "        wallet_id=wallet_id,",
            "        limit=1,",
            "        conn=conn,",
            "    )",
            "",
            "    if len(payments) == 0:",
            "        return",
            "",
            "    raise PaymentError(",
            "        status=\"failed\",",
            "        message=f\"The time limit of {limit} seconds between payments has been reached.\",",
            "    )",
            "",
            "",
            "async def check_wallet_daily_withdraw_limit(conn, wallet_id, amount_msat):",
            "    limit = settings.lnbits_wallet_limit_daily_max_withdraw",
            "    if not limit or limit <= 0:",
            "        return",
            "",
            "    payments = await get_payments(",
            "        since=int(time.time()) - 60 * 60 * 24,",
            "        outgoing=True,",
            "        wallet_id=wallet_id,",
            "        limit=1,",
            "        conn=conn,",
            "    )",
            "    if len(payments) == 0:",
            "        return",
            "",
            "    total = 0",
            "    for pay in payments:",
            "        total += pay.amount",
            "    total = total - amount_msat",
            "    if limit * 1000 + total < 0:",
            "        raise ValueError(",
            "            \"Daily withdrawal limit of \"",
            "            + str(settings.lnbits_wallet_limit_daily_max_withdraw)",
            "            + \" sats reached.\"",
            "        )",
            "",
            "",
            "async def redeem_lnurl_withdraw(",
            "    wallet_id: str,",
            "    lnurl_request: str,",
            "    memo: Optional[str] = None,",
            "    extra: Optional[Dict] = None,",
            "    wait_seconds: int = 0,",
            "    conn: Optional[Connection] = None,",
            ") -> None:",
            "    if not lnurl_request:",
            "        return None",
            "",
            "    res = {}",
            "",
            "    headers = {\"User-Agent\": settings.user_agent}",
            "    async with httpx.AsyncClient(headers=headers) as client:",
            "        lnurl = decode_lnurl(lnurl_request)",
            "        r = await client.get(str(lnurl))",
            "        res = r.json()",
            "",
            "    try:",
            "        _, payment_request = await create_invoice(",
            "            wallet_id=wallet_id,",
            "            amount=int(res[\"maxWithdrawable\"] / 1000),",
            "            memo=memo or res[\"defaultDescription\"] or \"\",",
            "            extra=extra,",
            "            conn=conn,",
            "        )",
            "    except Exception:",
            "        logger.warning(",
            "            f\"failed to create invoice on redeem_lnurl_withdraw \"",
            "            f\"from {lnurl}. params: {res}\"",
            "        )",
            "        return None",
            "",
            "    if wait_seconds:",
            "        await asyncio.sleep(wait_seconds)",
            "",
            "    params = {\"k1\": res[\"k1\"], \"pr\": payment_request}",
            "",
            "    try:",
            "        params[\"balanceNotify\"] = url_for(",
            "            f\"/withdraw/notify/{urlparse(lnurl_request).netloc}\",",
            "            external=True,",
            "            wal=wallet_id,",
            "        )",
            "    except Exception:",
            "        pass",
            "",
            "    headers = {\"User-Agent\": settings.user_agent}",
            "    async with httpx.AsyncClient(headers=headers) as client:",
            "        try:",
            "            await client.get(res[\"callback\"], params=params)",
            "        except Exception:",
            "            pass",
            "",
            "",
            "async def perform_lnurlauth(",
            "    callback: str,",
            "    wallet: WalletTypeInfo = Depends(require_admin_key),",
            ") -> Optional[LnurlErrorResponse]:",
            "    cb = urlparse(callback)",
            "",
            "    k1 = bytes.fromhex(parse_qs(cb.query)[\"k1\"][0])",
            "",
            "    key = wallet.wallet.lnurlauth_key(cb.netloc)",
            "",
            "    def int_to_bytes_suitable_der(x: int) -> bytes:",
            "        \"\"\"for strict DER we need to encode the integer with some quirks\"\"\"",
            "        b = x.to_bytes((x.bit_length() + 7) // 8, \"big\")",
            "",
            "        if len(b) == 0:",
            "            # ensure there's at least one byte when the int is zero",
            "            return bytes([0])",
            "",
            "        if b[0] & 0x80 != 0:",
            "            # ensure it doesn't start with a 0x80 and so it isn't",
            "            # interpreted as a negative number",
            "            return bytes([0]) + b",
            "",
            "        return b",
            "",
            "    def encode_strict_der(r: int, s: int, order: int):",
            "        # if s > order/2 verification will fail sometimes",
            "        # so we must fix it here see:",
            "        # https://github.com/indutny/elliptic/blob/e71b2d9359c5fe9437fbf46f1f05096de447de57/lib/elliptic/ec/index.js#L146-L147",
            "        if s > order // 2:",
            "            s = order - s",
            "",
            "        # now we do the strict DER encoding copied from",
            "        # https://github.com/KiriKiri/bip66 (without any checks)",
            "        r_temp = int_to_bytes_suitable_der(r)",
            "        s_temp = int_to_bytes_suitable_der(s)",
            "",
            "        r_len = len(r_temp)",
            "        s_len = len(s_temp)",
            "        sign_len = 6 + r_len + s_len",
            "",
            "        signature = BytesIO()",
            "        signature.write(0x30.to_bytes(1, \"big\", signed=False))",
            "        signature.write((sign_len - 2).to_bytes(1, \"big\", signed=False))",
            "        signature.write(0x02.to_bytes(1, \"big\", signed=False))",
            "        signature.write(r_len.to_bytes(1, \"big\", signed=False))",
            "        signature.write(r_temp)",
            "        signature.write(0x02.to_bytes(1, \"big\", signed=False))",
            "        signature.write(s_len.to_bytes(1, \"big\", signed=False))",
            "        signature.write(s_temp)",
            "",
            "        return signature.getvalue()",
            "",
            "    sig = key.sign_digest_deterministic(k1, sigencode=encode_strict_der)",
            "",
            "    headers = {\"User-Agent\": settings.user_agent}",
            "    async with httpx.AsyncClient(headers=headers) as client:",
            "        assert key.verifying_key, \"LNURLauth verifying_key does not exist\"",
            "        r = await client.get(",
            "            callback,",
            "            params={",
            "                \"k1\": k1.hex(),",
            "                \"key\": key.verifying_key.to_string(\"compressed\").hex(),",
            "                \"sig\": sig.hex(),",
            "            },",
            "        )",
            "        try:",
            "            resp = json.loads(r.text)",
            "            if resp[\"status\"] == \"OK\":",
            "                return None",
            "",
            "            return LnurlErrorResponse(reason=resp[\"reason\"])",
            "        except (KeyError, json.decoder.JSONDecodeError):",
            "            return LnurlErrorResponse(",
            "                reason=r.text[:200] + \"...\" if len(r.text) > 200 else r.text",
            "            )",
            "",
            "",
            "async def check_transaction_status(",
            "    wallet_id: str, payment_hash: str, conn: Optional[Connection] = None",
            ") -> PaymentStatus:",
            "    payment: Optional[Payment] = await get_wallet_payment(",
            "        wallet_id, payment_hash, conn=conn",
            "    )",
            "    if not payment:",
            "        return PaymentPendingStatus()",
            "    if not payment.pending:",
            "        # note: before, we still checked the status of the payment again",
            "        return PaymentSuccessStatus(fee_msat=payment.fee)",
            "",
            "    status: PaymentStatus = await payment.check_status()",
            "    return status",
            "",
            "",
            "# WARN: this same value must be used for balance check and passed to",
            "# funding_source.pay_invoice(), it may cause a vulnerability if the values differ",
            "def fee_reserve(amount_msat: int, internal: bool = False) -> int:",
            "    if internal:",
            "        return 0",
            "    reserve_min = settings.lnbits_reserve_fee_min",
            "    reserve_percent = settings.lnbits_reserve_fee_percent",
            "    return max(int(reserve_min), int(amount_msat * reserve_percent / 100.0))",
            "",
            "",
            "def service_fee(amount_msat: int, internal: bool = False) -> int:",
            "    service_fee_percent = settings.lnbits_service_fee",
            "    fee_max = settings.lnbits_service_fee_max * 1000",
            "    if settings.lnbits_service_fee_wallet:",
            "        if internal and settings.lnbits_service_fee_ignore_internal:",
            "            return 0",
            "        fee_percentage = int(amount_msat / 100 * service_fee_percent)",
            "        if fee_max > 0 and fee_percentage > fee_max:",
            "            return fee_max",
            "        else:",
            "            return fee_percentage",
            "    else:",
            "        return 0",
            "",
            "",
            "def fee_reserve_total(amount_msat: int, internal: bool = False) -> int:",
            "    return fee_reserve(amount_msat, internal) + service_fee(amount_msat, internal)",
            "",
            "",
            "async def send_payment_notification(wallet: Wallet, payment: Payment):",
            "    await websocket_updater(",
            "        wallet.id,",
            "        json.dumps(",
            "            {",
            "                \"wallet_balance\": wallet.balance,",
            "                \"payment\": payment.dict(),",
            "            }",
            "        ),",
            "    )",
            "",
            "",
            "async def update_wallet_balance(wallet_id: str, amount: int):",
            "    payment_hash, _ = await create_invoice(",
            "        wallet_id=wallet_id,",
            "        amount=amount,",
            "        memo=\"Admin top up\",",
            "        internal=True,",
            "    )",
            "    async with db.connect() as conn:",
            "        checking_id = await check_internal(payment_hash, conn=conn)",
            "        assert checking_id, \"newly created checking_id cannot be retrieved\"",
            "        await update_payment_status(checking_id=checking_id, pending=False, conn=conn)",
            "        # notify receiver asynchronously",
            "        from lnbits.tasks import internal_invoice_queue",
            "",
            "        await internal_invoice_queue.put(checking_id)",
            "",
            "",
            "async def check_admin_settings():",
            "    if settings.super_user:",
            "        settings.super_user = to_valid_user_id(settings.super_user).hex",
            "",
            "    if settings.lnbits_admin_ui:",
            "        settings_db = await get_super_settings()",
            "        if not settings_db:",
            "            # create new settings if table is empty",
            "            logger.warning(\"Settings DB empty. Inserting default settings.\")",
            "            settings_db = await init_admin_settings(settings.super_user)",
            "            logger.warning(\"Initialized settings from environment variables.\")",
            "",
            "        if settings.super_user and settings.super_user != settings_db.super_user:",
            "            # .env super_user overwrites DB super_user",
            "            settings_db = await update_super_user(settings.super_user)",
            "",
            "        update_cached_settings(settings_db.dict())",
            "",
            "        # saving superuser to {data_dir}/.super_user file",
            "        with open(Path(settings.lnbits_data_folder) / \".super_user\", \"w\") as file:",
            "            file.write(settings.super_user)",
            "",
            "        # callback for saas",
            "        if (",
            "            settings.lnbits_saas_callback",
            "            and settings.lnbits_saas_secret",
            "            and settings.lnbits_saas_instance_id",
            "        ):",
            "            send_admin_user_to_saas()",
            "",
            "        account = await get_account(settings.super_user)",
            "        if account and account.config and account.config.provider == \"env\":",
            "            settings.first_install = True",
            "",
            "        logger.success(",
            "            \"\u2714\ufe0f Admin UI is enabled. run `poetry run lnbits-cli superuser` \"",
            "            \"to get the superuser.\"",
            "        )",
            "",
            "",
            "async def check_webpush_settings():",
            "    if not settings.lnbits_webpush_privkey:",
            "        vapid = Vapid()",
            "        vapid.generate_keys()",
            "        privkey = vapid.private_pem()",
            "        assert vapid.public_key, \"VAPID public key does not exist\"",
            "        pubkey = b64urlencode(",
            "            vapid.public_key.public_bytes(",
            "                serialization.Encoding.X962,",
            "                serialization.PublicFormat.UncompressedPoint,",
            "            )",
            "        )",
            "        push_settings = {",
            "            \"lnbits_webpush_privkey\": privkey.decode(),",
            "            \"lnbits_webpush_pubkey\": pubkey,",
            "        }",
            "        update_cached_settings(push_settings)",
            "        await update_admin_settings(EditableSettings(**push_settings))",
            "",
            "    logger.info(\"Initialized webpush settings with generated VAPID key pair.\")",
            "    logger.info(f\"Pubkey: {settings.lnbits_webpush_pubkey}\")",
            "",
            "",
            "def update_cached_settings(sets_dict: dict):",
            "    for key, value in sets_dict.items():",
            "        if key in readonly_variables:",
            "            continue",
            "        if key not in settings.dict().keys():",
            "            continue",
            "        try:",
            "            setattr(settings, key, value)",
            "        except Exception:",
            "            logger.warning(f\"Failed overriding setting: {key}, value: {value}\")",
            "    if \"super_user\" in sets_dict:",
            "        settings.super_user = sets_dict[\"super_user\"]",
            "",
            "",
            "async def init_admin_settings(super_user: Optional[str] = None) -> SuperSettings:",
            "    account = None",
            "    if super_user:",
            "        account = await get_account(super_user)",
            "    if not account:",
            "        account = await create_account(",
            "            user_id=super_user, user_config=UserConfig(provider=\"env\")",
            "        )",
            "    if not account.wallets or len(account.wallets) == 0:",
            "        await create_wallet(user_id=account.id)",
            "",
            "    editable_settings = EditableSettings.from_dict(settings.dict())",
            "",
            "    return await create_admin_settings(account.id, editable_settings.dict())",
            "",
            "",
            "class WebsocketConnectionManager:",
            "    def __init__(self) -> None:",
            "        self.active_connections: List[WebSocket] = []",
            "",
            "    async def connect(self, websocket: WebSocket, item_id: str):",
            "        logger.debug(f\"Websocket connected to {item_id}\")",
            "        await websocket.accept()",
            "        self.active_connections.append(websocket)",
            "",
            "    def disconnect(self, websocket: WebSocket):",
            "        self.active_connections.remove(websocket)",
            "",
            "    async def send_data(self, message: str, item_id: str):",
            "        for connection in self.active_connections:",
            "            if connection.path_params[\"item_id\"] == item_id:",
            "                await connection.send_text(message)",
            "",
            "",
            "websocket_manager = WebsocketConnectionManager()",
            "",
            "",
            "async def websocket_updater(item_id, data):",
            "    return await websocket_manager.send_data(f\"{data}\", item_id)",
            "",
            "",
            "async def switch_to_voidwallet() -> None:",
            "    funding_source = get_funding_source()",
            "    if funding_source.__class__.__name__ == \"VoidWallet\":",
            "        return",
            "    set_funding_source(\"VoidWallet\")",
            "    settings.lnbits_backend_wallet_class = \"VoidWallet\"",
            "",
            "",
            "async def get_balance_delta() -> Tuple[int, int, int]:",
            "    funding_source = get_funding_source()",
            "    total_balance = await get_total_balance()",
            "    error_message, node_balance = await funding_source.status()",
            "    if error_message:",
            "        raise Exception(error_message)",
            "    return node_balance - total_balance, node_balance, total_balance",
            "",
            "",
            "def get_bolt11_expiry(invoice: Bolt11) -> datetime.datetime:",
            "    if invoice.expiry:",
            "        return datetime.datetime.fromtimestamp(invoice.date + invoice.expiry)",
            "    else:",
            "        # assume maximum bolt11 expiry of 31 days to be on the safe side",
            "        return datetime.datetime.now() + datetime.timedelta(days=31)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "66": [
                "PaymentError"
            ],
            "70": [
                "InvoiceError"
            ],
            "126": [],
            "130": [],
            "145": [],
            "146": [],
            "162": [],
            "205": [],
            "208": [],
            "210": [],
            "245": [],
            "264": [],
            "292": [],
            "305": [],
            "307": [],
            "373": [],
            "416": [],
            "417": []
        },
        "addLocation": []
    },
    "lnbits/core/views/payment_api.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "             assert payment_db is not None, \"payment not found\""
            },
            "1": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "             checking_id = payment_db.checking_id"
            },
            "2": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "         except InvoiceError as exc:"
            },
            "3": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            raise HTTPException(status_code=520, detail=str(exc)) from exc"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+            return JSONResponse("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+                status_code=520,"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+                content={\"detail\": exc.message, \"status\": exc.status},"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+            )"
            },
            "8": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 178,
                "PatchRowcode": "         except Exception as exc:"
            },
            "9": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "             raise exc"
            },
            "10": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 180,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": 220,
                "PatchRowcode": "         payment_hash = await pay_invoice("
            },
            "12": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 221,
                "PatchRowcode": "             wallet_id=wallet.id, payment_request=bolt11, extra=extra"
            },
            "13": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 222,
                "PatchRowcode": "         )"
            },
            "14": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    except ValueError as exc:"
            },
            "15": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise HTTPException("
            },
            "16": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            status_code=HTTPStatus.BAD_REQUEST, detail=str(exc)"
            },
            "17": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        ) from exc"
            },
            "18": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    except PermissionError as exc:"
            },
            "19": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise HTTPException(status_code=HTTPStatus.FORBIDDEN, detail=str(exc)) from exc"
            },
            "20": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 223,
                "PatchRowcode": "     except PaymentError as exc:"
            },
            "21": {
                "beforePatchRowNumber": 227,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        raise HTTPException(status_code=520, detail=str(exc)) from exc"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 224,
                "PatchRowcode": "+        return JSONResponse("
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 225,
                "PatchRowcode": "+            status_code=520,"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 226,
                "PatchRowcode": "+            content={\"detail\": exc.message, \"status\": exc.status},"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 227,
                "PatchRowcode": "+        )"
            },
            "26": {
                "beforePatchRowNumber": 228,
                "afterPatchRowNumber": 228,
                "PatchRowcode": "     except Exception as exc:"
            },
            "27": {
                "beforePatchRowNumber": 229,
                "afterPatchRowNumber": 229,
                "PatchRowcode": "         raise exc"
            },
            "28": {
                "beforePatchRowNumber": 230,
                "afterPatchRowNumber": 230,
                "PatchRowcode": " "
            },
            "29": {
                "beforePatchRowNumber": 434,
                "afterPatchRowNumber": 434,
                "PatchRowcode": "         return {\"paid\": True, \"preimage\": payment.preimage}"
            },
            "30": {
                "beforePatchRowNumber": 435,
                "afterPatchRowNumber": 435,
                "PatchRowcode": " "
            },
            "31": {
                "beforePatchRowNumber": 436,
                "afterPatchRowNumber": 436,
                "PatchRowcode": "     try:"
            },
            "32": {
                "beforePatchRowNumber": 437,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        await payment.check_status()"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 437,
                "PatchRowcode": "+        status = await payment.check_status()"
            },
            "34": {
                "beforePatchRowNumber": 438,
                "afterPatchRowNumber": 438,
                "PatchRowcode": "     except Exception:"
            },
            "35": {
                "beforePatchRowNumber": 439,
                "afterPatchRowNumber": 439,
                "PatchRowcode": "         if wallet and wallet.id == payment.wallet_id:"
            },
            "36": {
                "beforePatchRowNumber": 440,
                "afterPatchRowNumber": 440,
                "PatchRowcode": "             return {\"paid\": False, \"details\": payment}"
            },
            "37": {
                "beforePatchRowNumber": 443,
                "afterPatchRowNumber": 443,
                "PatchRowcode": "     if wallet and wallet.id == payment.wallet_id:"
            },
            "38": {
                "beforePatchRowNumber": 444,
                "afterPatchRowNumber": 444,
                "PatchRowcode": "         return {"
            },
            "39": {
                "beforePatchRowNumber": 445,
                "afterPatchRowNumber": 445,
                "PatchRowcode": "             \"paid\": not payment.pending,"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 446,
                "PatchRowcode": "+            \"status\": f\"{status!s}\","
            },
            "41": {
                "beforePatchRowNumber": 446,
                "afterPatchRowNumber": 447,
                "PatchRowcode": "             \"preimage\": payment.preimage,"
            },
            "42": {
                "beforePatchRowNumber": 447,
                "afterPatchRowNumber": 448,
                "PatchRowcode": "             \"details\": payment,"
            },
            "43": {
                "beforePatchRowNumber": 448,
                "afterPatchRowNumber": 449,
                "PatchRowcode": "         }"
            }
        },
        "frontPatchFile": [
            "import asyncio",
            "import json",
            "import uuid",
            "from http import HTTPStatus",
            "from math import ceil",
            "from typing import List, Optional, Union",
            "from urllib.parse import urlparse",
            "",
            "import httpx",
            "from fastapi import (",
            "    APIRouter,",
            "    Body,",
            "    Depends,",
            "    Header,",
            "    HTTPException,",
            "    Query,",
            "    Request,",
            ")",
            "from fastapi.responses import JSONResponse",
            "from loguru import logger",
            "from sse_starlette.sse import EventSourceResponse",
            "",
            "from lnbits import bolt11",
            "from lnbits.core.db import db",
            "from lnbits.core.models import (",
            "    CreateInvoice,",
            "    CreateLnurl,",
            "    DecodePayment,",
            "    Payment,",
            "    PaymentFilters,",
            "    PaymentHistoryPoint,",
            "    Wallet,",
            "    WalletType,",
            ")",
            "from lnbits.db import Filters, Page",
            "from lnbits.decorators import (",
            "    WalletTypeInfo,",
            "    get_key_type,",
            "    parse_filters,",
            "    require_admin_key,",
            "    require_invoice_key,",
            ")",
            "from lnbits.helpers import generate_filter_params_openapi",
            "from lnbits.lnurl import decode as lnurl_decode",
            "from lnbits.settings import settings",
            "from lnbits.utils.exchange_rates import fiat_amount_as_satoshis",
            "",
            "from ..crud import (",
            "    DateTrunc,",
            "    get_payments,",
            "    get_payments_history,",
            "    get_payments_paginated,",
            "    get_standalone_payment,",
            "    get_wallet_for_key,",
            "    update_pending_payments,",
            ")",
            "from ..services import (",
            "    InvoiceError,",
            "    PaymentError,",
            "    check_transaction_status,",
            "    create_invoice,",
            "    fee_reserve_total,",
            "    pay_invoice,",
            ")",
            "from ..tasks import api_invoice_listeners",
            "",
            "payment_router = APIRouter(prefix=\"/api/v1/payments\", tags=[\"Payments\"])",
            "",
            "",
            "@payment_router.get(",
            "    \"\",",
            "    name=\"Payment List\",",
            "    summary=\"get list of payments\",",
            "    response_description=\"list of payments\",",
            "    response_model=List[Payment],",
            "    openapi_extra=generate_filter_params_openapi(PaymentFilters),",
            ")",
            "async def api_payments(",
            "    wallet: WalletTypeInfo = Depends(get_key_type),",
            "    filters: Filters = Depends(parse_filters(PaymentFilters)),",
            "):",
            "    await update_pending_payments(wallet.wallet.id)",
            "    return await get_payments(",
            "        wallet_id=wallet.wallet.id,",
            "        pending=True,",
            "        complete=True,",
            "        filters=filters,",
            "    )",
            "",
            "",
            "@payment_router.get(",
            "    \"/history\",",
            "    name=\"Get payments history\",",
            "    response_model=List[PaymentHistoryPoint],",
            "    openapi_extra=generate_filter_params_openapi(PaymentFilters),",
            ")",
            "async def api_payments_history(",
            "    wallet: WalletTypeInfo = Depends(get_key_type),",
            "    group: DateTrunc = Query(\"day\"),",
            "    filters: Filters[PaymentFilters] = Depends(parse_filters(PaymentFilters)),",
            "):",
            "    await update_pending_payments(wallet.wallet.id)",
            "    return await get_payments_history(wallet.wallet.id, group, filters)",
            "",
            "",
            "@payment_router.get(",
            "    \"/paginated\",",
            "    name=\"Payment List\",",
            "    summary=\"get paginated list of payments\",",
            "    response_description=\"list of payments\",",
            "    response_model=Page[Payment],",
            "    openapi_extra=generate_filter_params_openapi(PaymentFilters),",
            ")",
            "async def api_payments_paginated(",
            "    wallet: WalletTypeInfo = Depends(get_key_type),",
            "    filters: Filters = Depends(parse_filters(PaymentFilters)),",
            "):",
            "    await update_pending_payments(wallet.wallet.id)",
            "    page = await get_payments_paginated(",
            "        wallet_id=wallet.wallet.id,",
            "        pending=True,",
            "        complete=True,",
            "        filters=filters,",
            "    )",
            "    return page",
            "",
            "",
            "async def api_payments_create_invoice(data: CreateInvoice, wallet: Wallet):",
            "    description_hash = b\"\"",
            "    unhashed_description = b\"\"",
            "    memo = data.memo or settings.lnbits_site_title",
            "    if data.description_hash or data.unhashed_description:",
            "        if data.description_hash:",
            "            try:",
            "                description_hash = bytes.fromhex(data.description_hash)",
            "            except ValueError as exc:",
            "                raise HTTPException(",
            "                    status_code=HTTPStatus.BAD_REQUEST,",
            "                    detail=\"'description_hash' must be a valid hex string\",",
            "                ) from exc",
            "        if data.unhashed_description:",
            "            try:",
            "                unhashed_description = bytes.fromhex(data.unhashed_description)",
            "            except ValueError as exc:",
            "                raise HTTPException(",
            "                    status_code=HTTPStatus.BAD_REQUEST,",
            "                    detail=\"'unhashed_description' must be a valid hex string\",",
            "                ) from exc",
            "        # do not save memo if description_hash or unhashed_description is set",
            "        memo = \"\"",
            "",
            "    async with db.connect() as conn:",
            "        try:",
            "            payment_hash, payment_request = await create_invoice(",
            "                wallet_id=wallet.id,",
            "                amount=data.amount,",
            "                memo=memo,",
            "                currency=data.unit,",
            "                description_hash=description_hash,",
            "                unhashed_description=unhashed_description,",
            "                expiry=data.expiry,",
            "                extra=data.extra,",
            "                webhook=data.webhook,",
            "                internal=data.internal,",
            "                conn=conn,",
            "            )",
            "            # NOTE: we get the checking_id with a seperate query because create_invoice",
            "            # does not return it and it would be a big hustle to change its return type",
            "            # (used across extensions)",
            "            payment_db = await get_standalone_payment(payment_hash, conn=conn)",
            "            assert payment_db is not None, \"payment not found\"",
            "            checking_id = payment_db.checking_id",
            "        except InvoiceError as exc:",
            "            raise HTTPException(status_code=520, detail=str(exc)) from exc",
            "        except Exception as exc:",
            "            raise exc",
            "",
            "    invoice = bolt11.decode(payment_request)",
            "",
            "    lnurl_response: Union[None, bool, str] = None",
            "    if data.lnurl_callback:",
            "        headers = {\"User-Agent\": settings.user_agent}",
            "        async with httpx.AsyncClient(headers=headers) as client:",
            "            try:",
            "                r = await client.get(",
            "                    data.lnurl_callback,",
            "                    params={",
            "                        \"pr\": payment_request,",
            "                    },",
            "                    timeout=10,",
            "                )",
            "                if r.is_error:",
            "                    lnurl_response = r.text",
            "                else:",
            "                    resp = json.loads(r.text)",
            "                    if resp[\"status\"] != \"OK\":",
            "                        lnurl_response = resp[\"reason\"]",
            "                    else:",
            "                        lnurl_response = True",
            "            except (httpx.ConnectError, httpx.RequestError) as ex:",
            "                logger.error(ex)",
            "                lnurl_response = False",
            "",
            "    return {",
            "        \"payment_hash\": invoice.payment_hash,",
            "        \"payment_request\": payment_request,",
            "        \"lnurl_response\": lnurl_response,",
            "        # maintain backwards compatibility with API clients:",
            "        \"checking_id\": checking_id,",
            "    }",
            "",
            "",
            "async def api_payments_pay_invoice(",
            "    bolt11: str, wallet: Wallet, extra: Optional[dict] = None",
            "):",
            "    try:",
            "        payment_hash = await pay_invoice(",
            "            wallet_id=wallet.id, payment_request=bolt11, extra=extra",
            "        )",
            "    except ValueError as exc:",
            "        raise HTTPException(",
            "            status_code=HTTPStatus.BAD_REQUEST, detail=str(exc)",
            "        ) from exc",
            "    except PermissionError as exc:",
            "        raise HTTPException(status_code=HTTPStatus.FORBIDDEN, detail=str(exc)) from exc",
            "    except PaymentError as exc:",
            "        raise HTTPException(status_code=520, detail=str(exc)) from exc",
            "    except Exception as exc:",
            "        raise exc",
            "",
            "    return {",
            "        \"payment_hash\": payment_hash,",
            "        # maintain backwards compatibility with API clients:",
            "        \"checking_id\": payment_hash,",
            "    }",
            "",
            "",
            "@payment_router.post(",
            "    \"\",",
            "    summary=\"Create or pay an invoice\",",
            "    description=\"\"\"",
            "        This endpoint can be used both to generate and pay a BOLT11 invoice.",
            "        To generate a new invoice for receiving funds into the authorized account,",
            "        specify at least the first four fields in the POST body: `out: false`,",
            "        `amount`, `unit`, and `memo`. To pay an arbitrary invoice from the funds",
            "        already in the authorized account, specify `out: true` and use the `bolt11`",
            "        field to supply the BOLT11 invoice to be paid.",
            "    \"\"\",",
            "    status_code=HTTPStatus.CREATED,",
            ")",
            "async def api_payments_create(",
            "    wallet: WalletTypeInfo = Depends(require_invoice_key),",
            "    invoice_data: CreateInvoice = Body(...),",
            "):",
            "    if invoice_data.out is True and wallet.wallet_type == WalletType.admin:",
            "        if not invoice_data.bolt11:",
            "            raise HTTPException(",
            "                status_code=HTTPStatus.BAD_REQUEST,",
            "                detail=\"BOLT11 string is invalid or not given\",",
            "            )",
            "        return await api_payments_pay_invoice(",
            "            invoice_data.bolt11, wallet.wallet, invoice_data.extra",
            "        )  # admin key",
            "    elif not invoice_data.out:",
            "        # invoice key",
            "        return await api_payments_create_invoice(invoice_data, wallet.wallet)",
            "    else:",
            "        raise HTTPException(",
            "            status_code=HTTPStatus.UNAUTHORIZED,",
            "            detail=\"Invoice (or Admin) key required.\",",
            "        )",
            "",
            "",
            "@payment_router.get(\"/fee-reserve\")",
            "async def api_payments_fee_reserve(invoice: str = Query(\"invoice\")) -> JSONResponse:",
            "    invoice_obj = bolt11.decode(invoice)",
            "    if invoice_obj.amount_msat:",
            "        response = {",
            "            \"fee_reserve\": fee_reserve_total(invoice_obj.amount_msat),",
            "        }",
            "        return JSONResponse(response)",
            "    else:",
            "        raise HTTPException(",
            "            status_code=HTTPStatus.BAD_REQUEST,",
            "            detail=\"Invoice has no amount.\",",
            "        )",
            "",
            "",
            "@payment_router.post(\"/lnurl\")",
            "async def api_payments_pay_lnurl(",
            "    data: CreateLnurl, wallet: WalletTypeInfo = Depends(require_admin_key)",
            "):",
            "    domain = urlparse(data.callback).netloc",
            "",
            "    headers = {\"User-Agent\": settings.user_agent}",
            "    async with httpx.AsyncClient(headers=headers, follow_redirects=True) as client:",
            "        try:",
            "            if data.unit and data.unit != \"sat\":",
            "                amount_msat = await fiat_amount_as_satoshis(data.amount, data.unit)",
            "                # no msat precision",
            "                amount_msat = ceil(amount_msat // 1000) * 1000",
            "            else:",
            "                amount_msat = data.amount",
            "            r = await client.get(",
            "                data.callback,",
            "                params={\"amount\": amount_msat, \"comment\": data.comment},",
            "                timeout=40,",
            "            )",
            "            if r.is_error:",
            "                raise httpx.ConnectError(\"LNURL callback connection error\")",
            "            r.raise_for_status()",
            "        except (httpx.ConnectError, httpx.RequestError) as exc:",
            "            raise HTTPException(",
            "                status_code=HTTPStatus.BAD_REQUEST,",
            "                detail=f\"Failed to connect to {domain}.\",",
            "            ) from exc",
            "",
            "    params = json.loads(r.text)",
            "    if params.get(\"status\") == \"ERROR\":",
            "        raise HTTPException(",
            "            status_code=HTTPStatus.BAD_REQUEST,",
            "            detail=f\"{domain} said: '{params.get('reason', '')}'\",",
            "        )",
            "",
            "    if not params.get(\"pr\"):",
            "        raise HTTPException(",
            "            status_code=HTTPStatus.BAD_REQUEST,",
            "            detail=f\"{domain} did not return a payment request.\",",
            "        )",
            "",
            "    invoice = bolt11.decode(params[\"pr\"])",
            "    if invoice.amount_msat != amount_msat:",
            "        raise HTTPException(",
            "            status_code=HTTPStatus.BAD_REQUEST,",
            "            detail=(",
            "                (",
            "                    f\"{domain} returned an invalid invoice. Expected\"",
            "                    f\" {amount_msat} msat, got {invoice.amount_msat}.\"",
            "                ),",
            "            ),",
            "        )",
            "",
            "    extra = {}",
            "",
            "    if params.get(\"successAction\"):",
            "        extra[\"success_action\"] = params[\"successAction\"]",
            "    if data.comment:",
            "        extra[\"comment\"] = data.comment",
            "    if data.unit and data.unit != \"sat\":",
            "        extra[\"fiat_currency\"] = data.unit",
            "        extra[\"fiat_amount\"] = data.amount / 1000",
            "    assert data.description is not None, \"description is required\"",
            "    payment_hash = await pay_invoice(",
            "        wallet_id=wallet.wallet.id,",
            "        payment_request=params[\"pr\"],",
            "        description=data.description,",
            "        extra=extra,",
            "    )",
            "",
            "    return {",
            "        \"success_action\": params.get(\"successAction\"),",
            "        \"payment_hash\": payment_hash,",
            "        # maintain backwards compatibility with API clients:",
            "        \"checking_id\": payment_hash,",
            "    }",
            "",
            "",
            "async def subscribe_wallet_invoices(request: Request, wallet: Wallet):",
            "    \"\"\"",
            "    Subscribe to new invoices for a wallet. Can be wrapped in EventSourceResponse.",
            "    Listenes invoming payments for a wallet and yields jsons with payment details.",
            "    \"\"\"",
            "    this_wallet_id = wallet.id",
            "",
            "    payment_queue: asyncio.Queue[Payment] = asyncio.Queue(0)",
            "",
            "    uid = f\"{this_wallet_id}_{str(uuid.uuid4())[:8]}\"",
            "    logger.debug(f\"adding sse listener for wallet: {uid}\")",
            "    api_invoice_listeners[uid] = payment_queue",
            "",
            "    try:",
            "        while settings.lnbits_running:",
            "            if await request.is_disconnected():",
            "                await request.close()",
            "                break",
            "            payment: Payment = await payment_queue.get()",
            "            if payment.wallet_id == this_wallet_id:",
            "                logger.debug(\"sse listener: payment received\", payment)",
            "                yield {\"data\": payment.json(), \"event\": \"payment-received\"}",
            "    except asyncio.CancelledError:",
            "        logger.debug(f\"removing listener for wallet {uid}\")",
            "    except Exception as exc:",
            "        logger.error(f\"Error in sse: {exc}\")",
            "    finally:",
            "        api_invoice_listeners.pop(uid)",
            "",
            "",
            "@payment_router.get(\"/sse\")",
            "async def api_payments_sse(",
            "    request: Request, wallet: WalletTypeInfo = Depends(get_key_type)",
            "):",
            "    return EventSourceResponse(",
            "        subscribe_wallet_invoices(request, wallet.wallet),",
            "        ping=20,",
            "        media_type=\"text/event-stream\",",
            "    )",
            "",
            "",
            "# TODO: refactor this route into a public and admin one",
            "@payment_router.get(\"/{payment_hash}\")",
            "async def api_payment(payment_hash, x_api_key: Optional[str] = Header(None)):",
            "    # We use X_Api_Key here because we want this call to work with and without keys",
            "    # If a valid key is given, we also return the field \"details\", otherwise not",
            "    wallet = await get_wallet_for_key(x_api_key) if isinstance(x_api_key, str) else None",
            "",
            "    payment = await get_standalone_payment(",
            "        payment_hash, wallet_id=wallet.id if wallet else None",
            "    )",
            "    if payment is None:",
            "        raise HTTPException(",
            "            status_code=HTTPStatus.NOT_FOUND, detail=\"Payment does not exist.\"",
            "        )",
            "    await check_transaction_status(payment.wallet_id, payment_hash)",
            "    payment = await get_standalone_payment(",
            "        payment_hash, wallet_id=wallet.id if wallet else None",
            "    )",
            "    if not payment:",
            "        raise HTTPException(",
            "            status_code=HTTPStatus.NOT_FOUND, detail=\"Payment does not exist.\"",
            "        )",
            "    elif not payment.pending:",
            "        if wallet and wallet.id == payment.wallet_id:",
            "            return {\"paid\": True, \"preimage\": payment.preimage, \"details\": payment}",
            "        return {\"paid\": True, \"preimage\": payment.preimage}",
            "",
            "    try:",
            "        await payment.check_status()",
            "    except Exception:",
            "        if wallet and wallet.id == payment.wallet_id:",
            "            return {\"paid\": False, \"details\": payment}",
            "        return {\"paid\": False}",
            "",
            "    if wallet and wallet.id == payment.wallet_id:",
            "        return {",
            "            \"paid\": not payment.pending,",
            "            \"preimage\": payment.preimage,",
            "            \"details\": payment,",
            "        }",
            "    return {\"paid\": not payment.pending, \"preimage\": payment.preimage}",
            "",
            "",
            "@payment_router.post(\"/decode\", status_code=HTTPStatus.OK)",
            "async def api_payments_decode(data: DecodePayment) -> JSONResponse:",
            "    payment_str = data.data",
            "    try:",
            "        if payment_str[:5] == \"LNURL\":",
            "            url = str(lnurl_decode(payment_str))",
            "            return JSONResponse({\"domain\": url})",
            "        else:",
            "            invoice = bolt11.decode(payment_str)",
            "            return JSONResponse(invoice.data)",
            "    except Exception as exc:",
            "        return JSONResponse(",
            "            {\"message\": f\"Failed to decode: {exc!s}\"},",
            "            status_code=HTTPStatus.BAD_REQUEST,",
            "        )"
        ],
        "afterPatchFile": [
            "import asyncio",
            "import json",
            "import uuid",
            "from http import HTTPStatus",
            "from math import ceil",
            "from typing import List, Optional, Union",
            "from urllib.parse import urlparse",
            "",
            "import httpx",
            "from fastapi import (",
            "    APIRouter,",
            "    Body,",
            "    Depends,",
            "    Header,",
            "    HTTPException,",
            "    Query,",
            "    Request,",
            ")",
            "from fastapi.responses import JSONResponse",
            "from loguru import logger",
            "from sse_starlette.sse import EventSourceResponse",
            "",
            "from lnbits import bolt11",
            "from lnbits.core.db import db",
            "from lnbits.core.models import (",
            "    CreateInvoice,",
            "    CreateLnurl,",
            "    DecodePayment,",
            "    Payment,",
            "    PaymentFilters,",
            "    PaymentHistoryPoint,",
            "    Wallet,",
            "    WalletType,",
            ")",
            "from lnbits.db import Filters, Page",
            "from lnbits.decorators import (",
            "    WalletTypeInfo,",
            "    get_key_type,",
            "    parse_filters,",
            "    require_admin_key,",
            "    require_invoice_key,",
            ")",
            "from lnbits.helpers import generate_filter_params_openapi",
            "from lnbits.lnurl import decode as lnurl_decode",
            "from lnbits.settings import settings",
            "from lnbits.utils.exchange_rates import fiat_amount_as_satoshis",
            "",
            "from ..crud import (",
            "    DateTrunc,",
            "    get_payments,",
            "    get_payments_history,",
            "    get_payments_paginated,",
            "    get_standalone_payment,",
            "    get_wallet_for_key,",
            "    update_pending_payments,",
            ")",
            "from ..services import (",
            "    InvoiceError,",
            "    PaymentError,",
            "    check_transaction_status,",
            "    create_invoice,",
            "    fee_reserve_total,",
            "    pay_invoice,",
            ")",
            "from ..tasks import api_invoice_listeners",
            "",
            "payment_router = APIRouter(prefix=\"/api/v1/payments\", tags=[\"Payments\"])",
            "",
            "",
            "@payment_router.get(",
            "    \"\",",
            "    name=\"Payment List\",",
            "    summary=\"get list of payments\",",
            "    response_description=\"list of payments\",",
            "    response_model=List[Payment],",
            "    openapi_extra=generate_filter_params_openapi(PaymentFilters),",
            ")",
            "async def api_payments(",
            "    wallet: WalletTypeInfo = Depends(get_key_type),",
            "    filters: Filters = Depends(parse_filters(PaymentFilters)),",
            "):",
            "    await update_pending_payments(wallet.wallet.id)",
            "    return await get_payments(",
            "        wallet_id=wallet.wallet.id,",
            "        pending=True,",
            "        complete=True,",
            "        filters=filters,",
            "    )",
            "",
            "",
            "@payment_router.get(",
            "    \"/history\",",
            "    name=\"Get payments history\",",
            "    response_model=List[PaymentHistoryPoint],",
            "    openapi_extra=generate_filter_params_openapi(PaymentFilters),",
            ")",
            "async def api_payments_history(",
            "    wallet: WalletTypeInfo = Depends(get_key_type),",
            "    group: DateTrunc = Query(\"day\"),",
            "    filters: Filters[PaymentFilters] = Depends(parse_filters(PaymentFilters)),",
            "):",
            "    await update_pending_payments(wallet.wallet.id)",
            "    return await get_payments_history(wallet.wallet.id, group, filters)",
            "",
            "",
            "@payment_router.get(",
            "    \"/paginated\",",
            "    name=\"Payment List\",",
            "    summary=\"get paginated list of payments\",",
            "    response_description=\"list of payments\",",
            "    response_model=Page[Payment],",
            "    openapi_extra=generate_filter_params_openapi(PaymentFilters),",
            ")",
            "async def api_payments_paginated(",
            "    wallet: WalletTypeInfo = Depends(get_key_type),",
            "    filters: Filters = Depends(parse_filters(PaymentFilters)),",
            "):",
            "    await update_pending_payments(wallet.wallet.id)",
            "    page = await get_payments_paginated(",
            "        wallet_id=wallet.wallet.id,",
            "        pending=True,",
            "        complete=True,",
            "        filters=filters,",
            "    )",
            "    return page",
            "",
            "",
            "async def api_payments_create_invoice(data: CreateInvoice, wallet: Wallet):",
            "    description_hash = b\"\"",
            "    unhashed_description = b\"\"",
            "    memo = data.memo or settings.lnbits_site_title",
            "    if data.description_hash or data.unhashed_description:",
            "        if data.description_hash:",
            "            try:",
            "                description_hash = bytes.fromhex(data.description_hash)",
            "            except ValueError as exc:",
            "                raise HTTPException(",
            "                    status_code=HTTPStatus.BAD_REQUEST,",
            "                    detail=\"'description_hash' must be a valid hex string\",",
            "                ) from exc",
            "        if data.unhashed_description:",
            "            try:",
            "                unhashed_description = bytes.fromhex(data.unhashed_description)",
            "            except ValueError as exc:",
            "                raise HTTPException(",
            "                    status_code=HTTPStatus.BAD_REQUEST,",
            "                    detail=\"'unhashed_description' must be a valid hex string\",",
            "                ) from exc",
            "        # do not save memo if description_hash or unhashed_description is set",
            "        memo = \"\"",
            "",
            "    async with db.connect() as conn:",
            "        try:",
            "            payment_hash, payment_request = await create_invoice(",
            "                wallet_id=wallet.id,",
            "                amount=data.amount,",
            "                memo=memo,",
            "                currency=data.unit,",
            "                description_hash=description_hash,",
            "                unhashed_description=unhashed_description,",
            "                expiry=data.expiry,",
            "                extra=data.extra,",
            "                webhook=data.webhook,",
            "                internal=data.internal,",
            "                conn=conn,",
            "            )",
            "            # NOTE: we get the checking_id with a seperate query because create_invoice",
            "            # does not return it and it would be a big hustle to change its return type",
            "            # (used across extensions)",
            "            payment_db = await get_standalone_payment(payment_hash, conn=conn)",
            "            assert payment_db is not None, \"payment not found\"",
            "            checking_id = payment_db.checking_id",
            "        except InvoiceError as exc:",
            "            return JSONResponse(",
            "                status_code=520,",
            "                content={\"detail\": exc.message, \"status\": exc.status},",
            "            )",
            "        except Exception as exc:",
            "            raise exc",
            "",
            "    invoice = bolt11.decode(payment_request)",
            "",
            "    lnurl_response: Union[None, bool, str] = None",
            "    if data.lnurl_callback:",
            "        headers = {\"User-Agent\": settings.user_agent}",
            "        async with httpx.AsyncClient(headers=headers) as client:",
            "            try:",
            "                r = await client.get(",
            "                    data.lnurl_callback,",
            "                    params={",
            "                        \"pr\": payment_request,",
            "                    },",
            "                    timeout=10,",
            "                )",
            "                if r.is_error:",
            "                    lnurl_response = r.text",
            "                else:",
            "                    resp = json.loads(r.text)",
            "                    if resp[\"status\"] != \"OK\":",
            "                        lnurl_response = resp[\"reason\"]",
            "                    else:",
            "                        lnurl_response = True",
            "            except (httpx.ConnectError, httpx.RequestError) as ex:",
            "                logger.error(ex)",
            "                lnurl_response = False",
            "",
            "    return {",
            "        \"payment_hash\": invoice.payment_hash,",
            "        \"payment_request\": payment_request,",
            "        \"lnurl_response\": lnurl_response,",
            "        # maintain backwards compatibility with API clients:",
            "        \"checking_id\": checking_id,",
            "    }",
            "",
            "",
            "async def api_payments_pay_invoice(",
            "    bolt11: str, wallet: Wallet, extra: Optional[dict] = None",
            "):",
            "    try:",
            "        payment_hash = await pay_invoice(",
            "            wallet_id=wallet.id, payment_request=bolt11, extra=extra",
            "        )",
            "    except PaymentError as exc:",
            "        return JSONResponse(",
            "            status_code=520,",
            "            content={\"detail\": exc.message, \"status\": exc.status},",
            "        )",
            "    except Exception as exc:",
            "        raise exc",
            "",
            "    return {",
            "        \"payment_hash\": payment_hash,",
            "        # maintain backwards compatibility with API clients:",
            "        \"checking_id\": payment_hash,",
            "    }",
            "",
            "",
            "@payment_router.post(",
            "    \"\",",
            "    summary=\"Create or pay an invoice\",",
            "    description=\"\"\"",
            "        This endpoint can be used both to generate and pay a BOLT11 invoice.",
            "        To generate a new invoice for receiving funds into the authorized account,",
            "        specify at least the first four fields in the POST body: `out: false`,",
            "        `amount`, `unit`, and `memo`. To pay an arbitrary invoice from the funds",
            "        already in the authorized account, specify `out: true` and use the `bolt11`",
            "        field to supply the BOLT11 invoice to be paid.",
            "    \"\"\",",
            "    status_code=HTTPStatus.CREATED,",
            ")",
            "async def api_payments_create(",
            "    wallet: WalletTypeInfo = Depends(require_invoice_key),",
            "    invoice_data: CreateInvoice = Body(...),",
            "):",
            "    if invoice_data.out is True and wallet.wallet_type == WalletType.admin:",
            "        if not invoice_data.bolt11:",
            "            raise HTTPException(",
            "                status_code=HTTPStatus.BAD_REQUEST,",
            "                detail=\"BOLT11 string is invalid or not given\",",
            "            )",
            "        return await api_payments_pay_invoice(",
            "            invoice_data.bolt11, wallet.wallet, invoice_data.extra",
            "        )  # admin key",
            "    elif not invoice_data.out:",
            "        # invoice key",
            "        return await api_payments_create_invoice(invoice_data, wallet.wallet)",
            "    else:",
            "        raise HTTPException(",
            "            status_code=HTTPStatus.UNAUTHORIZED,",
            "            detail=\"Invoice (or Admin) key required.\",",
            "        )",
            "",
            "",
            "@payment_router.get(\"/fee-reserve\")",
            "async def api_payments_fee_reserve(invoice: str = Query(\"invoice\")) -> JSONResponse:",
            "    invoice_obj = bolt11.decode(invoice)",
            "    if invoice_obj.amount_msat:",
            "        response = {",
            "            \"fee_reserve\": fee_reserve_total(invoice_obj.amount_msat),",
            "        }",
            "        return JSONResponse(response)",
            "    else:",
            "        raise HTTPException(",
            "            status_code=HTTPStatus.BAD_REQUEST,",
            "            detail=\"Invoice has no amount.\",",
            "        )",
            "",
            "",
            "@payment_router.post(\"/lnurl\")",
            "async def api_payments_pay_lnurl(",
            "    data: CreateLnurl, wallet: WalletTypeInfo = Depends(require_admin_key)",
            "):",
            "    domain = urlparse(data.callback).netloc",
            "",
            "    headers = {\"User-Agent\": settings.user_agent}",
            "    async with httpx.AsyncClient(headers=headers, follow_redirects=True) as client:",
            "        try:",
            "            if data.unit and data.unit != \"sat\":",
            "                amount_msat = await fiat_amount_as_satoshis(data.amount, data.unit)",
            "                # no msat precision",
            "                amount_msat = ceil(amount_msat // 1000) * 1000",
            "            else:",
            "                amount_msat = data.amount",
            "            r = await client.get(",
            "                data.callback,",
            "                params={\"amount\": amount_msat, \"comment\": data.comment},",
            "                timeout=40,",
            "            )",
            "            if r.is_error:",
            "                raise httpx.ConnectError(\"LNURL callback connection error\")",
            "            r.raise_for_status()",
            "        except (httpx.ConnectError, httpx.RequestError) as exc:",
            "            raise HTTPException(",
            "                status_code=HTTPStatus.BAD_REQUEST,",
            "                detail=f\"Failed to connect to {domain}.\",",
            "            ) from exc",
            "",
            "    params = json.loads(r.text)",
            "    if params.get(\"status\") == \"ERROR\":",
            "        raise HTTPException(",
            "            status_code=HTTPStatus.BAD_REQUEST,",
            "            detail=f\"{domain} said: '{params.get('reason', '')}'\",",
            "        )",
            "",
            "    if not params.get(\"pr\"):",
            "        raise HTTPException(",
            "            status_code=HTTPStatus.BAD_REQUEST,",
            "            detail=f\"{domain} did not return a payment request.\",",
            "        )",
            "",
            "    invoice = bolt11.decode(params[\"pr\"])",
            "    if invoice.amount_msat != amount_msat:",
            "        raise HTTPException(",
            "            status_code=HTTPStatus.BAD_REQUEST,",
            "            detail=(",
            "                (",
            "                    f\"{domain} returned an invalid invoice. Expected\"",
            "                    f\" {amount_msat} msat, got {invoice.amount_msat}.\"",
            "                ),",
            "            ),",
            "        )",
            "",
            "    extra = {}",
            "",
            "    if params.get(\"successAction\"):",
            "        extra[\"success_action\"] = params[\"successAction\"]",
            "    if data.comment:",
            "        extra[\"comment\"] = data.comment",
            "    if data.unit and data.unit != \"sat\":",
            "        extra[\"fiat_currency\"] = data.unit",
            "        extra[\"fiat_amount\"] = data.amount / 1000",
            "    assert data.description is not None, \"description is required\"",
            "    payment_hash = await pay_invoice(",
            "        wallet_id=wallet.wallet.id,",
            "        payment_request=params[\"pr\"],",
            "        description=data.description,",
            "        extra=extra,",
            "    )",
            "",
            "    return {",
            "        \"success_action\": params.get(\"successAction\"),",
            "        \"payment_hash\": payment_hash,",
            "        # maintain backwards compatibility with API clients:",
            "        \"checking_id\": payment_hash,",
            "    }",
            "",
            "",
            "async def subscribe_wallet_invoices(request: Request, wallet: Wallet):",
            "    \"\"\"",
            "    Subscribe to new invoices for a wallet. Can be wrapped in EventSourceResponse.",
            "    Listenes invoming payments for a wallet and yields jsons with payment details.",
            "    \"\"\"",
            "    this_wallet_id = wallet.id",
            "",
            "    payment_queue: asyncio.Queue[Payment] = asyncio.Queue(0)",
            "",
            "    uid = f\"{this_wallet_id}_{str(uuid.uuid4())[:8]}\"",
            "    logger.debug(f\"adding sse listener for wallet: {uid}\")",
            "    api_invoice_listeners[uid] = payment_queue",
            "",
            "    try:",
            "        while settings.lnbits_running:",
            "            if await request.is_disconnected():",
            "                await request.close()",
            "                break",
            "            payment: Payment = await payment_queue.get()",
            "            if payment.wallet_id == this_wallet_id:",
            "                logger.debug(\"sse listener: payment received\", payment)",
            "                yield {\"data\": payment.json(), \"event\": \"payment-received\"}",
            "    except asyncio.CancelledError:",
            "        logger.debug(f\"removing listener for wallet {uid}\")",
            "    except Exception as exc:",
            "        logger.error(f\"Error in sse: {exc}\")",
            "    finally:",
            "        api_invoice_listeners.pop(uid)",
            "",
            "",
            "@payment_router.get(\"/sse\")",
            "async def api_payments_sse(",
            "    request: Request, wallet: WalletTypeInfo = Depends(get_key_type)",
            "):",
            "    return EventSourceResponse(",
            "        subscribe_wallet_invoices(request, wallet.wallet),",
            "        ping=20,",
            "        media_type=\"text/event-stream\",",
            "    )",
            "",
            "",
            "# TODO: refactor this route into a public and admin one",
            "@payment_router.get(\"/{payment_hash}\")",
            "async def api_payment(payment_hash, x_api_key: Optional[str] = Header(None)):",
            "    # We use X_Api_Key here because we want this call to work with and without keys",
            "    # If a valid key is given, we also return the field \"details\", otherwise not",
            "    wallet = await get_wallet_for_key(x_api_key) if isinstance(x_api_key, str) else None",
            "",
            "    payment = await get_standalone_payment(",
            "        payment_hash, wallet_id=wallet.id if wallet else None",
            "    )",
            "    if payment is None:",
            "        raise HTTPException(",
            "            status_code=HTTPStatus.NOT_FOUND, detail=\"Payment does not exist.\"",
            "        )",
            "    await check_transaction_status(payment.wallet_id, payment_hash)",
            "    payment = await get_standalone_payment(",
            "        payment_hash, wallet_id=wallet.id if wallet else None",
            "    )",
            "    if not payment:",
            "        raise HTTPException(",
            "            status_code=HTTPStatus.NOT_FOUND, detail=\"Payment does not exist.\"",
            "        )",
            "    elif not payment.pending:",
            "        if wallet and wallet.id == payment.wallet_id:",
            "            return {\"paid\": True, \"preimage\": payment.preimage, \"details\": payment}",
            "        return {\"paid\": True, \"preimage\": payment.preimage}",
            "",
            "    try:",
            "        status = await payment.check_status()",
            "    except Exception:",
            "        if wallet and wallet.id == payment.wallet_id:",
            "            return {\"paid\": False, \"details\": payment}",
            "        return {\"paid\": False}",
            "",
            "    if wallet and wallet.id == payment.wallet_id:",
            "        return {",
            "            \"paid\": not payment.pending,",
            "            \"status\": f\"{status!s}\",",
            "            \"preimage\": payment.preimage,",
            "            \"details\": payment,",
            "        }",
            "    return {\"paid\": not payment.pending, \"preimage\": payment.preimage}",
            "",
            "",
            "@payment_router.post(\"/decode\", status_code=HTTPStatus.OK)",
            "async def api_payments_decode(data: DecodePayment) -> JSONResponse:",
            "    payment_str = data.data",
            "    try:",
            "        if payment_str[:5] == \"LNURL\":",
            "            url = str(lnurl_decode(payment_str))",
            "            return JSONResponse({\"domain\": url})",
            "        else:",
            "            invoice = bolt11.decode(payment_str)",
            "            return JSONResponse(invoice.data)",
            "    except Exception as exc:",
            "        return JSONResponse(",
            "            {\"message\": f\"Failed to decode: {exc!s}\"},",
            "            status_code=HTTPStatus.BAD_REQUEST,",
            "        )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "174": [],
            "220": [],
            "221": [],
            "222": [],
            "223": [],
            "224": [],
            "225": [],
            "227": [],
            "437": []
        },
        "addLocation": []
    },
    "lnbits/wallets/alby.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 129,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "             if r.is_error:"
            },
            "2": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "                 error_message = data[\"message\"] if \"message\" in data else r.text"
            },
            "3": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                return PaymentResponse(False, None, None, None, error_message)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+                return PaymentResponse(None, None, None, None, error_message)"
            },
            "5": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 134,
                "PatchRowcode": "             checking_id = data[\"payment_hash\"]"
            },
            "7": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 135,
                "PatchRowcode": "             # todo: confirm with bitkarrot that having the minus is fine"
            },
            "8": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "         except KeyError as exc:"
            },
            "9": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 142,
                "PatchRowcode": "             logger.warning(exc)"
            },
            "10": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "             return PaymentResponse("
            },
            "11": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                False, None, None, None, \"Server error: 'missing required fields'\""
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+                None, None, None, None, \"Server error: 'missing required fields'\""
            },
            "13": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "             )"
            },
            "14": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "         except json.JSONDecodeError as exc:"
            },
            "15": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "             logger.warning(exc)"
            },
            "16": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "             return PaymentResponse("
            },
            "17": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                False, None, None, None, \"Server error: 'invalid json response'\""
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+                None, None, None, None, \"Server error: 'invalid json response'\""
            },
            "19": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "             )"
            },
            "20": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "         except Exception as exc:"
            },
            "21": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 152,
                "PatchRowcode": "             logger.info(f\"Failed to pay invoice {bolt11}\")"
            },
            "22": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 153,
                "PatchRowcode": "             logger.warning(exc)"
            },
            "23": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 154,
                "PatchRowcode": "             return PaymentResponse("
            },
            "24": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                False, None, None, None, f\"Unable to connect to {self.endpoint}.\""
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+                None, None, None, None, f\"Unable to connect to {self.endpoint}.\""
            },
            "26": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "             )"
            },
            "27": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 157,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": 158,
                "PatchRowcode": "     async def get_invoice_status(self, checking_id: str) -> PaymentStatus:"
            },
            "29": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 167,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "             data = r.json()"
            },
            "31": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 169,
                "PatchRowcode": " "
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+            # TODO: how can we detect a failed payment?"
            },
            "33": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 171,
                "PatchRowcode": "             statuses = {"
            },
            "34": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "                 \"CREATED\": None,"
            },
            "35": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 173,
                "PatchRowcode": "                 \"SETTLED\": True,"
            }
        },
        "frontPatchFile": [
            "import asyncio",
            "import hashlib",
            "import json",
            "from typing import AsyncGenerator, Dict, Optional",
            "",
            "import httpx",
            "from loguru import logger",
            "",
            "from lnbits.settings import settings",
            "",
            "from .base import (",
            "    InvoiceResponse,",
            "    PaymentPendingStatus,",
            "    PaymentResponse,",
            "    PaymentStatus,",
            "    StatusResponse,",
            "    Wallet,",
            ")",
            "",
            "",
            "class AlbyWallet(Wallet):",
            "    \"\"\"https://guides.getalby.com/alby-wallet-api/reference/api-reference\"\"\"",
            "",
            "    def __init__(self):",
            "        if not settings.alby_api_endpoint:",
            "            raise ValueError(\"cannot initialize AlbyWallet: missing alby_api_endpoint\")",
            "        if not settings.alby_access_token:",
            "            raise ValueError(\"cannot initialize AlbyWallet: missing alby_access_token\")",
            "",
            "        self.endpoint = self.normalize_endpoint(settings.alby_api_endpoint)",
            "        self.auth = {",
            "            \"Authorization\": \"Bearer \" + settings.alby_access_token,",
            "            \"User-Agent\": settings.user_agent,",
            "        }",
            "        self.client = httpx.AsyncClient(base_url=self.endpoint, headers=self.auth)",
            "",
            "    async def cleanup(self):",
            "        try:",
            "            await self.client.aclose()",
            "        except RuntimeError as e:",
            "            logger.warning(f\"Error closing wallet connection: {e}\")",
            "",
            "    async def status(self) -> StatusResponse:",
            "        try:",
            "            r = await self.client.get(\"/balance\", timeout=10)",
            "            r.raise_for_status()",
            "",
            "            data = r.json()",
            "",
            "            if len(data) == 0:",
            "                return StatusResponse(\"no data\", 0)",
            "",
            "            if r.is_error or data[\"unit\"] != \"sat\":",
            "                error_message = data[\"message\"] if \"message\" in data else r.text",
            "                return StatusResponse(f\"Server error: '{error_message}'\", 0)",
            "",
            "            # multiply balance by 1000 to get msats balance",
            "            return StatusResponse(None, data[\"balance\"] * 1000)",
            "        except KeyError as exc:",
            "            logger.warning(exc)",
            "            return StatusResponse(\"Server error: 'missing required fields'\", 0)",
            "        except json.JSONDecodeError as exc:",
            "            logger.warning(exc)",
            "            return StatusResponse(\"Server error: 'invalid json response'\", 0)",
            "        except Exception as exc:",
            "            logger.warning(exc)",
            "            return StatusResponse(f\"Unable to connect to {self.endpoint}.\", 0)",
            "",
            "    async def create_invoice(",
            "        self,",
            "        amount: int,",
            "        memo: Optional[str] = None,",
            "        description_hash: Optional[bytes] = None,",
            "        unhashed_description: Optional[bytes] = None,",
            "        **kwargs,",
            "    ) -> InvoiceResponse:",
            "        # https://api.getalby.com/invoices",
            "        data: Dict = {\"amount\": f\"{amount}\"}",
            "        if description_hash:",
            "            data[\"description_hash\"] = description_hash.hex()",
            "        elif unhashed_description:",
            "            data[\"description_hash\"] = hashlib.sha256(unhashed_description).hexdigest()",
            "        else:",
            "            data[\"memo\"] = memo or \"\"",
            "",
            "        try:",
            "            r = await self.client.post(",
            "                \"/invoices\",",
            "                json=data,",
            "                timeout=40,",
            "            )",
            "            r.raise_for_status()",
            "",
            "            data = r.json()",
            "",
            "            if r.is_error:",
            "                error_message = data[\"message\"] if \"message\" in data else r.text",
            "                return InvoiceResponse(False, None, None, error_message)",
            "",
            "            checking_id = data[\"payment_hash\"]",
            "            payment_request = data[\"payment_request\"]",
            "            return InvoiceResponse(True, checking_id, payment_request, None)",
            "        except KeyError as exc:",
            "            logger.warning(exc)",
            "            return InvoiceResponse(",
            "                False, None, None, \"Server error: 'missing required fields'\"",
            "            )",
            "        except json.JSONDecodeError as exc:",
            "            logger.warning(exc)",
            "            return InvoiceResponse(",
            "                False, None, None, \"Server error: 'invalid json response'\"",
            "            )",
            "        except Exception as exc:",
            "            logger.warning(exc)",
            "            return InvoiceResponse(",
            "                False, None, None, f\"Unable to connect to {self.endpoint}.\"",
            "            )",
            "",
            "    async def pay_invoice(self, bolt11: str, fee_limit_msat: int) -> PaymentResponse:",
            "        try:",
            "            # https://api.getalby.com/payments/bolt11",
            "            r = await self.client.post(",
            "                \"/payments/bolt11\",",
            "                json={\"invoice\": bolt11},  # assume never need amount in body",
            "                timeout=None,",
            "            )",
            "            r.raise_for_status()",
            "            data = r.json()",
            "",
            "            if r.is_error:",
            "                error_message = data[\"message\"] if \"message\" in data else r.text",
            "                return PaymentResponse(False, None, None, None, error_message)",
            "",
            "            checking_id = data[\"payment_hash\"]",
            "            # todo: confirm with bitkarrot that having the minus is fine",
            "            # other funding sources return a positive fee value",
            "            fee_msat = -data[\"fee\"]",
            "            preimage = data[\"payment_preimage\"]",
            "",
            "            return PaymentResponse(True, checking_id, fee_msat, preimage, None)",
            "        except KeyError as exc:",
            "            logger.warning(exc)",
            "            return PaymentResponse(",
            "                False, None, None, None, \"Server error: 'missing required fields'\"",
            "            )",
            "        except json.JSONDecodeError as exc:",
            "            logger.warning(exc)",
            "            return PaymentResponse(",
            "                False, None, None, None, \"Server error: 'invalid json response'\"",
            "            )",
            "        except Exception as exc:",
            "            logger.info(f\"Failed to pay invoice {bolt11}\")",
            "            logger.warning(exc)",
            "            return PaymentResponse(",
            "                False, None, None, None, f\"Unable to connect to {self.endpoint}.\"",
            "            )",
            "",
            "    async def get_invoice_status(self, checking_id: str) -> PaymentStatus:",
            "        return await self.get_payment_status(checking_id)",
            "",
            "    async def get_payment_status(self, checking_id: str) -> PaymentStatus:",
            "        try:",
            "            r = await self.client.get(f\"/invoices/{checking_id}\")",
            "",
            "            if r.is_error:",
            "                return PaymentPendingStatus()",
            "",
            "            data = r.json()",
            "",
            "            statuses = {",
            "                \"CREATED\": None,",
            "                \"SETTLED\": True,",
            "            }",
            "            # todo: extract fee and preimage",
            "            # maybe use the more specific endpoints:",
            "            #  - https://api.getalby.com/invoices/incoming",
            "            #  - https://api.getalby.com/invoices/outgoing",
            "            return PaymentStatus(",
            "                statuses[data.get(\"state\")], fee_msat=None, preimage=None",
            "            )",
            "        except Exception as e:",
            "            logger.error(f\"Error getting invoice status: {e}\")",
            "            return PaymentPendingStatus()",
            "",
            "    async def paid_invoices_stream(self) -> AsyncGenerator[str, None]:",
            "        self.queue: asyncio.Queue = asyncio.Queue(0)",
            "        while settings.lnbits_running:",
            "            value = await self.queue.get()",
            "            yield value"
        ],
        "afterPatchFile": [
            "import asyncio",
            "import hashlib",
            "import json",
            "from typing import AsyncGenerator, Dict, Optional",
            "",
            "import httpx",
            "from loguru import logger",
            "",
            "from lnbits.settings import settings",
            "",
            "from .base import (",
            "    InvoiceResponse,",
            "    PaymentPendingStatus,",
            "    PaymentResponse,",
            "    PaymentStatus,",
            "    StatusResponse,",
            "    Wallet,",
            ")",
            "",
            "",
            "class AlbyWallet(Wallet):",
            "    \"\"\"https://guides.getalby.com/alby-wallet-api/reference/api-reference\"\"\"",
            "",
            "    def __init__(self):",
            "        if not settings.alby_api_endpoint:",
            "            raise ValueError(\"cannot initialize AlbyWallet: missing alby_api_endpoint\")",
            "        if not settings.alby_access_token:",
            "            raise ValueError(\"cannot initialize AlbyWallet: missing alby_access_token\")",
            "",
            "        self.endpoint = self.normalize_endpoint(settings.alby_api_endpoint)",
            "        self.auth = {",
            "            \"Authorization\": \"Bearer \" + settings.alby_access_token,",
            "            \"User-Agent\": settings.user_agent,",
            "        }",
            "        self.client = httpx.AsyncClient(base_url=self.endpoint, headers=self.auth)",
            "",
            "    async def cleanup(self):",
            "        try:",
            "            await self.client.aclose()",
            "        except RuntimeError as e:",
            "            logger.warning(f\"Error closing wallet connection: {e}\")",
            "",
            "    async def status(self) -> StatusResponse:",
            "        try:",
            "            r = await self.client.get(\"/balance\", timeout=10)",
            "            r.raise_for_status()",
            "",
            "            data = r.json()",
            "",
            "            if len(data) == 0:",
            "                return StatusResponse(\"no data\", 0)",
            "",
            "            if r.is_error or data[\"unit\"] != \"sat\":",
            "                error_message = data[\"message\"] if \"message\" in data else r.text",
            "                return StatusResponse(f\"Server error: '{error_message}'\", 0)",
            "",
            "            # multiply balance by 1000 to get msats balance",
            "            return StatusResponse(None, data[\"balance\"] * 1000)",
            "        except KeyError as exc:",
            "            logger.warning(exc)",
            "            return StatusResponse(\"Server error: 'missing required fields'\", 0)",
            "        except json.JSONDecodeError as exc:",
            "            logger.warning(exc)",
            "            return StatusResponse(\"Server error: 'invalid json response'\", 0)",
            "        except Exception as exc:",
            "            logger.warning(exc)",
            "            return StatusResponse(f\"Unable to connect to {self.endpoint}.\", 0)",
            "",
            "    async def create_invoice(",
            "        self,",
            "        amount: int,",
            "        memo: Optional[str] = None,",
            "        description_hash: Optional[bytes] = None,",
            "        unhashed_description: Optional[bytes] = None,",
            "        **kwargs,",
            "    ) -> InvoiceResponse:",
            "        # https://api.getalby.com/invoices",
            "        data: Dict = {\"amount\": f\"{amount}\"}",
            "        if description_hash:",
            "            data[\"description_hash\"] = description_hash.hex()",
            "        elif unhashed_description:",
            "            data[\"description_hash\"] = hashlib.sha256(unhashed_description).hexdigest()",
            "        else:",
            "            data[\"memo\"] = memo or \"\"",
            "",
            "        try:",
            "            r = await self.client.post(",
            "                \"/invoices\",",
            "                json=data,",
            "                timeout=40,",
            "            )",
            "            r.raise_for_status()",
            "",
            "            data = r.json()",
            "",
            "            if r.is_error:",
            "                error_message = data[\"message\"] if \"message\" in data else r.text",
            "                return InvoiceResponse(False, None, None, error_message)",
            "",
            "            checking_id = data[\"payment_hash\"]",
            "            payment_request = data[\"payment_request\"]",
            "            return InvoiceResponse(True, checking_id, payment_request, None)",
            "        except KeyError as exc:",
            "            logger.warning(exc)",
            "            return InvoiceResponse(",
            "                False, None, None, \"Server error: 'missing required fields'\"",
            "            )",
            "        except json.JSONDecodeError as exc:",
            "            logger.warning(exc)",
            "            return InvoiceResponse(",
            "                False, None, None, \"Server error: 'invalid json response'\"",
            "            )",
            "        except Exception as exc:",
            "            logger.warning(exc)",
            "            return InvoiceResponse(",
            "                False, None, None, f\"Unable to connect to {self.endpoint}.\"",
            "            )",
            "",
            "    async def pay_invoice(self, bolt11: str, fee_limit_msat: int) -> PaymentResponse:",
            "        try:",
            "            # https://api.getalby.com/payments/bolt11",
            "            r = await self.client.post(",
            "                \"/payments/bolt11\",",
            "                json={\"invoice\": bolt11},  # assume never need amount in body",
            "                timeout=None,",
            "            )",
            "            r.raise_for_status()",
            "            data = r.json()",
            "",
            "            if r.is_error:",
            "                error_message = data[\"message\"] if \"message\" in data else r.text",
            "                return PaymentResponse(None, None, None, None, error_message)",
            "",
            "            checking_id = data[\"payment_hash\"]",
            "            # todo: confirm with bitkarrot that having the minus is fine",
            "            # other funding sources return a positive fee value",
            "            fee_msat = -data[\"fee\"]",
            "            preimage = data[\"payment_preimage\"]",
            "",
            "            return PaymentResponse(True, checking_id, fee_msat, preimage, None)",
            "        except KeyError as exc:",
            "            logger.warning(exc)",
            "            return PaymentResponse(",
            "                None, None, None, None, \"Server error: 'missing required fields'\"",
            "            )",
            "        except json.JSONDecodeError as exc:",
            "            logger.warning(exc)",
            "            return PaymentResponse(",
            "                None, None, None, None, \"Server error: 'invalid json response'\"",
            "            )",
            "        except Exception as exc:",
            "            logger.info(f\"Failed to pay invoice {bolt11}\")",
            "            logger.warning(exc)",
            "            return PaymentResponse(",
            "                None, None, None, None, f\"Unable to connect to {self.endpoint}.\"",
            "            )",
            "",
            "    async def get_invoice_status(self, checking_id: str) -> PaymentStatus:",
            "        return await self.get_payment_status(checking_id)",
            "",
            "    async def get_payment_status(self, checking_id: str) -> PaymentStatus:",
            "        try:",
            "            r = await self.client.get(f\"/invoices/{checking_id}\")",
            "",
            "            if r.is_error:",
            "                return PaymentPendingStatus()",
            "",
            "            data = r.json()",
            "",
            "            # TODO: how can we detect a failed payment?",
            "            statuses = {",
            "                \"CREATED\": None,",
            "                \"SETTLED\": True,",
            "            }",
            "            # todo: extract fee and preimage",
            "            # maybe use the more specific endpoints:",
            "            #  - https://api.getalby.com/invoices/incoming",
            "            #  - https://api.getalby.com/invoices/outgoing",
            "            return PaymentStatus(",
            "                statuses[data.get(\"state\")], fee_msat=None, preimage=None",
            "            )",
            "        except Exception as e:",
            "            logger.error(f\"Error getting invoice status: {e}\")",
            "            return PaymentPendingStatus()",
            "",
            "    async def paid_invoices_stream(self) -> AsyncGenerator[str, None]:",
            "        self.queue: asyncio.Queue = asyncio.Queue(0)",
            "        while settings.lnbits_running:",
            "            value = await self.queue.get()",
            "            yield value"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "132": [
                "AlbyWallet"
            ],
            "144": [
                "AlbyWallet"
            ],
            "149": [
                "AlbyWallet"
            ],
            "155": [
                "AlbyWallet"
            ]
        },
        "addLocation": []
    },
    "lnbits/wallets/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": 70,
                "PatchRowcode": "         return self.paid is False"
            },
            "1": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 71,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "     def __str__(self) -> str:"
            },
            "3": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if self.paid is True:"
            },
            "4": {
                "beforePatchRowNumber": 74,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return \"settled\""
            },
            "5": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif self.paid is False:"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+        if self.success:"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+            return \"success\""
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+        if self.failed:"
            },
            "9": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 76,
                "PatchRowcode": "             return \"failed\""
            },
            "10": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        elif self.paid is None:"
            },
            "11": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return \"still pending\""
            },
            "12": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        else:"
            },
            "13": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return \"unknown (should never happen)\""
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+        return \"pending\""
            },
            "15": {
                "beforePatchRowNumber": 81,
                "afterPatchRowNumber": 78,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 82,
                "afterPatchRowNumber": 79,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 80,
                "PatchRowcode": " class PaymentSuccessStatus(PaymentStatus):"
            }
        },
        "frontPatchFile": [
            "from __future__ import annotations",
            "",
            "from abc import ABC, abstractmethod",
            "from typing import TYPE_CHECKING, AsyncGenerator, Coroutine, NamedTuple, Optional",
            "",
            "if TYPE_CHECKING:",
            "    from lnbits.nodes.base import Node",
            "",
            "",
            "class StatusResponse(NamedTuple):",
            "    error_message: Optional[str]",
            "    balance_msat: int",
            "",
            "",
            "class InvoiceResponse(NamedTuple):",
            "    ok: bool",
            "    checking_id: Optional[str] = None  # payment_hash, rpc_id",
            "    payment_request: Optional[str] = None",
            "    error_message: Optional[str] = None",
            "",
            "    @property",
            "    def success(self) -> bool:",
            "        return self.ok is True",
            "",
            "    @property",
            "    def pending(self) -> bool:",
            "        return self.ok is None",
            "",
            "    @property",
            "    def failed(self) -> bool:",
            "        return self.ok is False",
            "",
            "",
            "class PaymentResponse(NamedTuple):",
            "    # when ok is None it means we don't know if this succeeded",
            "    ok: Optional[bool] = None",
            "    checking_id: Optional[str] = None  # payment_hash, rcp_id",
            "    fee_msat: Optional[int] = None",
            "    preimage: Optional[str] = None",
            "    error_message: Optional[str] = None",
            "",
            "    @property",
            "    def success(self) -> bool:",
            "        return self.ok is True",
            "",
            "    @property",
            "    def pending(self) -> bool:",
            "        return self.ok is None",
            "",
            "    @property",
            "    def failed(self) -> bool:",
            "        return self.ok is False",
            "",
            "",
            "class PaymentStatus(NamedTuple):",
            "    paid: Optional[bool] = None",
            "    fee_msat: Optional[int] = None",
            "    preimage: Optional[str] = None",
            "",
            "    @property",
            "    def success(self) -> bool:",
            "        return self.paid is True",
            "",
            "    @property",
            "    def pending(self) -> bool:",
            "        return self.paid is not True",
            "",
            "    @property",
            "    def failed(self) -> bool:",
            "        return self.paid is False",
            "",
            "    def __str__(self) -> str:",
            "        if self.paid is True:",
            "            return \"settled\"",
            "        elif self.paid is False:",
            "            return \"failed\"",
            "        elif self.paid is None:",
            "            return \"still pending\"",
            "        else:",
            "            return \"unknown (should never happen)\"",
            "",
            "",
            "class PaymentSuccessStatus(PaymentStatus):",
            "    paid = True",
            "",
            "",
            "class PaymentFailedStatus(PaymentStatus):",
            "    paid = False",
            "",
            "",
            "class PaymentPendingStatus(PaymentStatus):",
            "    paid = None",
            "",
            "",
            "class Wallet(ABC):",
            "",
            "    __node_cls__: Optional[type[Node]] = None",
            "",
            "    @abstractmethod",
            "    async def cleanup(self):",
            "        pass",
            "",
            "    @abstractmethod",
            "    def status(self) -> Coroutine[None, None, StatusResponse]:",
            "        pass",
            "",
            "    @abstractmethod",
            "    def create_invoice(",
            "        self,",
            "        amount: int,",
            "        memo: Optional[str] = None,",
            "        description_hash: Optional[bytes] = None,",
            "        unhashed_description: Optional[bytes] = None,",
            "        **kwargs,",
            "    ) -> Coroutine[None, None, InvoiceResponse]:",
            "        pass",
            "",
            "    @abstractmethod",
            "    def pay_invoice(",
            "        self, bolt11: str, fee_limit_msat: int",
            "    ) -> Coroutine[None, None, PaymentResponse]:",
            "        pass",
            "",
            "    @abstractmethod",
            "    def get_invoice_status(",
            "        self, checking_id: str",
            "    ) -> Coroutine[None, None, PaymentStatus]:",
            "        pass",
            "",
            "    @abstractmethod",
            "    def get_payment_status(",
            "        self, checking_id: str",
            "    ) -> Coroutine[None, None, PaymentStatus]:",
            "        pass",
            "",
            "    @abstractmethod",
            "    def paid_invoices_stream(self) -> AsyncGenerator[str, None]:",
            "        pass",
            "",
            "    def normalize_endpoint(self, endpoint: str, add_proto=True) -> str:",
            "        endpoint = endpoint[:-1] if endpoint.endswith(\"/\") else endpoint",
            "        if add_proto:",
            "            endpoint = (",
            "                f\"https://{endpoint}\" if not endpoint.startswith(\"http\") else endpoint",
            "            )",
            "        return endpoint",
            "",
            "",
            "class UnsupportedError(Exception):",
            "    pass"
        ],
        "afterPatchFile": [
            "from __future__ import annotations",
            "",
            "from abc import ABC, abstractmethod",
            "from typing import TYPE_CHECKING, AsyncGenerator, Coroutine, NamedTuple, Optional",
            "",
            "if TYPE_CHECKING:",
            "    from lnbits.nodes.base import Node",
            "",
            "",
            "class StatusResponse(NamedTuple):",
            "    error_message: Optional[str]",
            "    balance_msat: int",
            "",
            "",
            "class InvoiceResponse(NamedTuple):",
            "    ok: bool",
            "    checking_id: Optional[str] = None  # payment_hash, rpc_id",
            "    payment_request: Optional[str] = None",
            "    error_message: Optional[str] = None",
            "",
            "    @property",
            "    def success(self) -> bool:",
            "        return self.ok is True",
            "",
            "    @property",
            "    def pending(self) -> bool:",
            "        return self.ok is None",
            "",
            "    @property",
            "    def failed(self) -> bool:",
            "        return self.ok is False",
            "",
            "",
            "class PaymentResponse(NamedTuple):",
            "    # when ok is None it means we don't know if this succeeded",
            "    ok: Optional[bool] = None",
            "    checking_id: Optional[str] = None  # payment_hash, rcp_id",
            "    fee_msat: Optional[int] = None",
            "    preimage: Optional[str] = None",
            "    error_message: Optional[str] = None",
            "",
            "    @property",
            "    def success(self) -> bool:",
            "        return self.ok is True",
            "",
            "    @property",
            "    def pending(self) -> bool:",
            "        return self.ok is None",
            "",
            "    @property",
            "    def failed(self) -> bool:",
            "        return self.ok is False",
            "",
            "",
            "class PaymentStatus(NamedTuple):",
            "    paid: Optional[bool] = None",
            "    fee_msat: Optional[int] = None",
            "    preimage: Optional[str] = None",
            "",
            "    @property",
            "    def success(self) -> bool:",
            "        return self.paid is True",
            "",
            "    @property",
            "    def pending(self) -> bool:",
            "        return self.paid is not True",
            "",
            "    @property",
            "    def failed(self) -> bool:",
            "        return self.paid is False",
            "",
            "    def __str__(self) -> str:",
            "        if self.success:",
            "            return \"success\"",
            "        if self.failed:",
            "            return \"failed\"",
            "        return \"pending\"",
            "",
            "",
            "class PaymentSuccessStatus(PaymentStatus):",
            "    paid = True",
            "",
            "",
            "class PaymentFailedStatus(PaymentStatus):",
            "    paid = False",
            "",
            "",
            "class PaymentPendingStatus(PaymentStatus):",
            "    paid = None",
            "",
            "",
            "class Wallet(ABC):",
            "",
            "    __node_cls__: Optional[type[Node]] = None",
            "",
            "    @abstractmethod",
            "    async def cleanup(self):",
            "        pass",
            "",
            "    @abstractmethod",
            "    def status(self) -> Coroutine[None, None, StatusResponse]:",
            "        pass",
            "",
            "    @abstractmethod",
            "    def create_invoice(",
            "        self,",
            "        amount: int,",
            "        memo: Optional[str] = None,",
            "        description_hash: Optional[bytes] = None,",
            "        unhashed_description: Optional[bytes] = None,",
            "        **kwargs,",
            "    ) -> Coroutine[None, None, InvoiceResponse]:",
            "        pass",
            "",
            "    @abstractmethod",
            "    def pay_invoice(",
            "        self, bolt11: str, fee_limit_msat: int",
            "    ) -> Coroutine[None, None, PaymentResponse]:",
            "        pass",
            "",
            "    @abstractmethod",
            "    def get_invoice_status(",
            "        self, checking_id: str",
            "    ) -> Coroutine[None, None, PaymentStatus]:",
            "        pass",
            "",
            "    @abstractmethod",
            "    def get_payment_status(",
            "        self, checking_id: str",
            "    ) -> Coroutine[None, None, PaymentStatus]:",
            "        pass",
            "",
            "    @abstractmethod",
            "    def paid_invoices_stream(self) -> AsyncGenerator[str, None]:",
            "        pass",
            "",
            "    def normalize_endpoint(self, endpoint: str, add_proto=True) -> str:",
            "        endpoint = endpoint[:-1] if endpoint.endswith(\"/\") else endpoint",
            "        if add_proto:",
            "            endpoint = (",
            "                f\"https://{endpoint}\" if not endpoint.startswith(\"http\") else endpoint",
            "            )",
            "        return endpoint",
            "",
            "",
            "class UnsupportedError(Exception):",
            "    pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "73": [
                "PaymentStatus",
                "__str__"
            ],
            "74": [
                "PaymentStatus",
                "__str__"
            ],
            "75": [
                "PaymentStatus",
                "__str__"
            ],
            "77": [
                "PaymentStatus",
                "__str__"
            ],
            "78": [
                "PaymentStatus",
                "__str__"
            ],
            "79": [
                "PaymentStatus",
                "__str__"
            ],
            "80": [
                "PaymentStatus",
                "__str__"
            ]
        },
        "addLocation": []
    },
    "lnbits/wallets/corelightning.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "         command = self.ln.help(\"invoice\")[\"help\"][0][\"command\"]  # type: ignore"
            },
            "1": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 47,
                "PatchRowcode": "         self.supports_description_hash = \"deschashonly\" in command"
            },
            "2": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 48,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+        # https://docs.corelightning.org/reference/lightning-pay"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        # 201: Already paid"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+        # 203: Permanent failure at destination."
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        # 205: Unable to find a route."
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+        # 206: Route too expensive."
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+        # 207: Invoice expired."
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+        # 210: Payment timed out without a payment in progress."
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+        self.pay_failure_error_codes = [201, 203, 205, 206, 207, 210]"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+"
            },
            "12": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 58,
                "PatchRowcode": "         # check last payindex so we can listen from that point on"
            },
            "13": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "         self.last_pay_index = 0"
            },
            "14": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "         invoices: dict = self.ln.listinvoices()  # type: ignore"
            },
            "15": {
                "beforePatchRowNumber": 155,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "         except RpcError as exc:"
            },
            "16": {
                "beforePatchRowNumber": 156,
                "afterPatchRowNumber": 165,
                "PatchRowcode": "             logger.warning(exc)"
            },
            "17": {
                "beforePatchRowNumber": 157,
                "afterPatchRowNumber": 166,
                "PatchRowcode": "             try:"
            },
            "18": {
                "beforePatchRowNumber": 158,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                error_message = exc.error[\"attempts\"][-1][\"fail_reason\"]  # type: ignore"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 167,
                "PatchRowcode": "+                error_code = exc.error.get(\"code\")"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 168,
                "PatchRowcode": "+                if error_code in self.pay_failure_error_codes:  # type: ignore"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 169,
                "PatchRowcode": "+                    error_message = exc.error.get(\"message\", error_code)  # type: ignore"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 170,
                "PatchRowcode": "+                    return PaymentResponse("
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+                        False, None, None, None, f\"Payment failed: {error_message}\""
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 172,
                "PatchRowcode": "+                    )"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 173,
                "PatchRowcode": "+                else:"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 174,
                "PatchRowcode": "+                    error_message = f\"Payment failed: {exc.error}\""
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 175,
                "PatchRowcode": "+                    return PaymentResponse(None, None, None, None, error_message)"
            },
            "28": {
                "beforePatchRowNumber": 159,
                "afterPatchRowNumber": 176,
                "PatchRowcode": "             except Exception:"
            },
            "29": {
                "beforePatchRowNumber": 160,
                "afterPatchRowNumber": 177,
                "PatchRowcode": "                 error_message = f\"RPC '{exc.method}' failed with '{exc.error}'.\""
            },
            "30": {
                "beforePatchRowNumber": 161,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return PaymentResponse(False, None, None, None, error_message)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+                return PaymentResponse(None, None, None, None, error_message)"
            },
            "32": {
                "beforePatchRowNumber": 162,
                "afterPatchRowNumber": 179,
                "PatchRowcode": "         except KeyError as exc:"
            },
            "33": {
                "beforePatchRowNumber": 163,
                "afterPatchRowNumber": 180,
                "PatchRowcode": "             logger.warning(exc)"
            },
            "34": {
                "beforePatchRowNumber": 164,
                "afterPatchRowNumber": 181,
                "PatchRowcode": "             return PaymentResponse("
            },
            "35": {
                "beforePatchRowNumber": 165,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                False, None, None, None, \"Server error: 'missing required fields'\""
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+                None, None, None, None, \"Server error: 'missing required fields'\""
            },
            "37": {
                "beforePatchRowNumber": 166,
                "afterPatchRowNumber": 183,
                "PatchRowcode": "             )"
            },
            "38": {
                "beforePatchRowNumber": 167,
                "afterPatchRowNumber": 184,
                "PatchRowcode": "         except Exception as exc:"
            },
            "39": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 185,
                "PatchRowcode": "             logger.info(f\"Failed to pay invoice {bolt11}\")"
            },
            "40": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 186,
                "PatchRowcode": "             logger.warning(exc)"
            },
            "41": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            return PaymentResponse(False, None, None, None, f\"Payment failed: '{exc}'.\")"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+            return PaymentResponse(None, None, None, None, f\"Payment failed: '{exc}'.\")"
            },
            "43": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 188,
                "PatchRowcode": " "
            },
            "44": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "     async def get_invoice_status(self, checking_id: str) -> PaymentStatus:"
            },
            "45": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "         try:"
            }
        },
        "frontPatchFile": [
            "import asyncio",
            "import random",
            "from typing import Any, AsyncGenerator, Optional",
            "",
            "from bolt11.decode import decode as bolt11_decode",
            "from bolt11.exceptions import Bolt11Exception",
            "from loguru import logger",
            "from pyln.client import LightningRpc, RpcError",
            "",
            "from lnbits.nodes.cln import CoreLightningNode",
            "from lnbits.settings import settings",
            "",
            "from .base import (",
            "    InvoiceResponse,",
            "    PaymentFailedStatus,",
            "    PaymentPendingStatus,",
            "    PaymentResponse,",
            "    PaymentStatus,",
            "    PaymentSuccessStatus,",
            "    StatusResponse,",
            "    UnsupportedError,",
            "    Wallet,",
            ")",
            "",
            "",
            "async def run_sync(func) -> Any:",
            "    loop = asyncio.get_event_loop()",
            "    return await loop.run_in_executor(None, func)",
            "",
            "",
            "class CoreLightningWallet(Wallet):",
            "    __node_cls__ = CoreLightningNode",
            "",
            "    async def cleanup(self):",
            "        pass",
            "",
            "    def __init__(self):",
            "        rpc = settings.corelightning_rpc or settings.clightning_rpc",
            "        if not rpc:",
            "            raise ValueError(",
            "                \"cannot initialize CoreLightningWallet: missing corelightning_rpc\"",
            "            )",
            "        self.pay = settings.corelightning_pay_command",
            "        self.ln = LightningRpc(rpc)",
            "        # check if description_hash is supported (from corelightning>=v0.11.0)",
            "        command = self.ln.help(\"invoice\")[\"help\"][0][\"command\"]  # type: ignore",
            "        self.supports_description_hash = \"deschashonly\" in command",
            "",
            "        # check last payindex so we can listen from that point on",
            "        self.last_pay_index = 0",
            "        invoices: dict = self.ln.listinvoices()  # type: ignore",
            "        for inv in invoices[\"invoices\"][::-1]:",
            "            if \"pay_index\" in inv:",
            "                self.last_pay_index = inv[\"pay_index\"]",
            "                break",
            "",
            "    async def status(self) -> StatusResponse:",
            "        try:",
            "            funds: dict = self.ln.listfunds()  # type: ignore",
            "            if len(funds) == 0:",
            "                return StatusResponse(\"no data\", 0)",
            "",
            "            return StatusResponse(",
            "                None, sum([int(ch[\"our_amount_msat\"]) for ch in funds[\"channels\"]])",
            "            )",
            "        except RpcError as exc:",
            "            logger.warning(exc)",
            "            error_message = f\"RPC '{exc.method}' failed with '{exc.error}'.\"",
            "            return StatusResponse(error_message, 0)",
            "        except Exception as exc:",
            "            logger.warning(f\"Failed to connect, got: '{exc}'\")",
            "            return StatusResponse(f\"Unable to connect, got: '{exc}'\", 0)",
            "",
            "    async def create_invoice(",
            "        self,",
            "        amount: int,",
            "        memo: Optional[str] = None,",
            "        description_hash: Optional[bytes] = None,",
            "        unhashed_description: Optional[bytes] = None,",
            "        **kwargs,",
            "    ) -> InvoiceResponse:",
            "        label = kwargs.get(\"label\", f\"lbl{random.random()}\")",
            "        msat: int = int(amount * 1000)",
            "        try:",
            "            if description_hash and not unhashed_description:",
            "                raise UnsupportedError(",
            "                    \"'description_hash' unsupported by CoreLightning, provide\"",
            "                    \" 'unhashed_description'\"",
            "                )",
            "            if unhashed_description and not self.supports_description_hash:",
            "                raise UnsupportedError(\"unhashed_description\")",
            "            r: dict = self.ln.invoice(  # type: ignore",
            "                msatoshi=msat,",
            "                label=label,",
            "                description=(",
            "                    unhashed_description.decode() if unhashed_description else memo",
            "                ),",
            "                exposeprivatechannels=True,",
            "                deschashonly=(",
            "                    True if unhashed_description else False",
            "                ),  # we can't pass None here",
            "                expiry=kwargs.get(\"expiry\"),",
            "            )",
            "",
            "            if r.get(\"code\") and r.get(\"code\") < 0:  # type: ignore",
            "                raise Exception(r.get(\"message\"))",
            "",
            "            return InvoiceResponse(True, r[\"payment_hash\"], r[\"bolt11\"], None)",
            "        except RpcError as exc:",
            "            logger.warning(exc)",
            "            error_message = f\"RPC '{exc.method}' failed with '{exc.error}'.\"",
            "            return InvoiceResponse(False, None, None, error_message)",
            "        except KeyError as exc:",
            "            logger.warning(exc)",
            "            return InvoiceResponse(",
            "                False, None, None, \"Server error: 'missing required fields'\"",
            "            )",
            "        except Exception as e:",
            "            logger.warning(e)",
            "            return InvoiceResponse(False, None, None, str(e))",
            "",
            "    async def pay_invoice(self, bolt11: str, fee_limit_msat: int) -> PaymentResponse:",
            "        try:",
            "            invoice = bolt11_decode(bolt11)",
            "        except Bolt11Exception as exc:",
            "            return PaymentResponse(False, None, None, None, str(exc))",
            "",
            "        try:",
            "            previous_payment = await self.get_payment_status(invoice.payment_hash)",
            "            if previous_payment.paid:",
            "                return PaymentResponse(False, None, None, None, \"invoice already paid\")",
            "",
            "            if not invoice.amount_msat or invoice.amount_msat <= 0:",
            "                return PaymentResponse(",
            "                    False, None, None, None, \"CLN 0 amount invoice not supported\"",
            "                )",
            "",
            "            # maxfee overrides both maxfeepercent and exemptfee defaults (and",
            "            # if you specify maxfee you cannot specify either of those), and",
            "            # creates an absolute limit on what fee we will pay. This allows you to",
            "            # implement your own heuristics rather than the primitive ones used",
            "            # here.",
            "            payload = {",
            "                \"bolt11\": bolt11,",
            "                \"maxfee\": fee_limit_msat,",
            "                \"description\": invoice.description,",
            "            }",
            "",
            "            r = await run_sync(lambda: self.ln.call(self.pay, payload))",
            "",
            "            fee_msat = -int(r[\"amount_sent_msat\"] - r[\"amount_msat\"])",
            "            return PaymentResponse(",
            "                True, r[\"payment_hash\"], fee_msat, r[\"payment_preimage\"], None",
            "            )",
            "        except RpcError as exc:",
            "            logger.warning(exc)",
            "            try:",
            "                error_message = exc.error[\"attempts\"][-1][\"fail_reason\"]  # type: ignore",
            "            except Exception:",
            "                error_message = f\"RPC '{exc.method}' failed with '{exc.error}'.\"",
            "            return PaymentResponse(False, None, None, None, error_message)",
            "        except KeyError as exc:",
            "            logger.warning(exc)",
            "            return PaymentResponse(",
            "                False, None, None, None, \"Server error: 'missing required fields'\"",
            "            )",
            "        except Exception as exc:",
            "            logger.info(f\"Failed to pay invoice {bolt11}\")",
            "            logger.warning(exc)",
            "            return PaymentResponse(False, None, None, None, f\"Payment failed: '{exc}'.\")",
            "",
            "    async def get_invoice_status(self, checking_id: str) -> PaymentStatus:",
            "        try:",
            "            r: dict = self.ln.listinvoices(payment_hash=checking_id)  # type: ignore",
            "",
            "            if not r[\"invoices\"]:",
            "                return PaymentPendingStatus()",
            "",
            "            invoice_resp = r[\"invoices\"][-1]",
            "",
            "            if invoice_resp[\"payment_hash\"] == checking_id:",
            "                if invoice_resp[\"status\"] == \"paid\":",
            "                    return PaymentSuccessStatus()",
            "                elif invoice_resp[\"status\"] == \"unpaid\":",
            "                    return PaymentPendingStatus()",
            "                elif invoice_resp[\"status\"] == \"expired\":",
            "                    return PaymentFailedStatus()",
            "            else:",
            "                logger.warning(f\"supplied an invalid checking_id: {checking_id}\")",
            "            return PaymentPendingStatus()",
            "        except RpcError as exc:",
            "            logger.warning(exc)",
            "            return PaymentPendingStatus()",
            "        except Exception as exc:",
            "            logger.warning(exc)",
            "            return PaymentPendingStatus()",
            "",
            "    async def get_payment_status(self, checking_id: str) -> PaymentStatus:",
            "        try:",
            "            r: dict = self.ln.listpays(payment_hash=checking_id)  # type: ignore",
            "",
            "            if \"pays\" not in r:",
            "                return PaymentPendingStatus()",
            "            if not r[\"pays\"]:",
            "                # no payment with this payment_hash is found",
            "                return PaymentFailedStatus()",
            "",
            "            payment_resp = r[\"pays\"][-1]",
            "",
            "            if payment_resp[\"payment_hash\"] == checking_id:",
            "                status = payment_resp[\"status\"]",
            "                if status == \"complete\":",
            "                    fee_msat = -int(",
            "                        payment_resp[\"amount_sent_msat\"] - payment_resp[\"amount_msat\"]",
            "                    )",
            "",
            "                    return PaymentSuccessStatus(",
            "                        fee_msat=fee_msat, preimage=payment_resp[\"preimage\"]",
            "                    )",
            "                elif status == \"failed\":",
            "                    return PaymentFailedStatus()",
            "                else:",
            "                    return PaymentPendingStatus()",
            "            else:",
            "                logger.warning(f\"supplied an invalid checking_id: {checking_id}\")",
            "            return PaymentPendingStatus()",
            "",
            "        except Exception as exc:",
            "            logger.warning(exc)",
            "            return PaymentPendingStatus()",
            "",
            "    async def paid_invoices_stream(self) -> AsyncGenerator[str, None]:",
            "        while settings.lnbits_running:",
            "            try:",
            "                paid = await run_sync(",
            "                    lambda: self.ln.waitanyinvoice(self.last_pay_index, timeout=2)",
            "                )",
            "                self.last_pay_index = paid[\"pay_index\"]",
            "                yield paid[\"payment_hash\"]",
            "            except RpcError as exc:",
            "                # only raise if not a timeout",
            "                if exc.error[\"code\"] != 904:  # type: ignore",
            "                    raise",
            "            except Exception as exc:",
            "                logger.error(",
            "                    f\"lost connection to corelightning invoices stream: '{exc}', \"",
            "                    \"retrying in 5 seconds\"",
            "                )",
            "                await asyncio.sleep(5)"
        ],
        "afterPatchFile": [
            "import asyncio",
            "import random",
            "from typing import Any, AsyncGenerator, Optional",
            "",
            "from bolt11.decode import decode as bolt11_decode",
            "from bolt11.exceptions import Bolt11Exception",
            "from loguru import logger",
            "from pyln.client import LightningRpc, RpcError",
            "",
            "from lnbits.nodes.cln import CoreLightningNode",
            "from lnbits.settings import settings",
            "",
            "from .base import (",
            "    InvoiceResponse,",
            "    PaymentFailedStatus,",
            "    PaymentPendingStatus,",
            "    PaymentResponse,",
            "    PaymentStatus,",
            "    PaymentSuccessStatus,",
            "    StatusResponse,",
            "    UnsupportedError,",
            "    Wallet,",
            ")",
            "",
            "",
            "async def run_sync(func) -> Any:",
            "    loop = asyncio.get_event_loop()",
            "    return await loop.run_in_executor(None, func)",
            "",
            "",
            "class CoreLightningWallet(Wallet):",
            "    __node_cls__ = CoreLightningNode",
            "",
            "    async def cleanup(self):",
            "        pass",
            "",
            "    def __init__(self):",
            "        rpc = settings.corelightning_rpc or settings.clightning_rpc",
            "        if not rpc:",
            "            raise ValueError(",
            "                \"cannot initialize CoreLightningWallet: missing corelightning_rpc\"",
            "            )",
            "        self.pay = settings.corelightning_pay_command",
            "        self.ln = LightningRpc(rpc)",
            "        # check if description_hash is supported (from corelightning>=v0.11.0)",
            "        command = self.ln.help(\"invoice\")[\"help\"][0][\"command\"]  # type: ignore",
            "        self.supports_description_hash = \"deschashonly\" in command",
            "",
            "        # https://docs.corelightning.org/reference/lightning-pay",
            "        # 201: Already paid",
            "        # 203: Permanent failure at destination.",
            "        # 205: Unable to find a route.",
            "        # 206: Route too expensive.",
            "        # 207: Invoice expired.",
            "        # 210: Payment timed out without a payment in progress.",
            "        self.pay_failure_error_codes = [201, 203, 205, 206, 207, 210]",
            "",
            "        # check last payindex so we can listen from that point on",
            "        self.last_pay_index = 0",
            "        invoices: dict = self.ln.listinvoices()  # type: ignore",
            "        for inv in invoices[\"invoices\"][::-1]:",
            "            if \"pay_index\" in inv:",
            "                self.last_pay_index = inv[\"pay_index\"]",
            "                break",
            "",
            "    async def status(self) -> StatusResponse:",
            "        try:",
            "            funds: dict = self.ln.listfunds()  # type: ignore",
            "            if len(funds) == 0:",
            "                return StatusResponse(\"no data\", 0)",
            "",
            "            return StatusResponse(",
            "                None, sum([int(ch[\"our_amount_msat\"]) for ch in funds[\"channels\"]])",
            "            )",
            "        except RpcError as exc:",
            "            logger.warning(exc)",
            "            error_message = f\"RPC '{exc.method}' failed with '{exc.error}'.\"",
            "            return StatusResponse(error_message, 0)",
            "        except Exception as exc:",
            "            logger.warning(f\"Failed to connect, got: '{exc}'\")",
            "            return StatusResponse(f\"Unable to connect, got: '{exc}'\", 0)",
            "",
            "    async def create_invoice(",
            "        self,",
            "        amount: int,",
            "        memo: Optional[str] = None,",
            "        description_hash: Optional[bytes] = None,",
            "        unhashed_description: Optional[bytes] = None,",
            "        **kwargs,",
            "    ) -> InvoiceResponse:",
            "        label = kwargs.get(\"label\", f\"lbl{random.random()}\")",
            "        msat: int = int(amount * 1000)",
            "        try:",
            "            if description_hash and not unhashed_description:",
            "                raise UnsupportedError(",
            "                    \"'description_hash' unsupported by CoreLightning, provide\"",
            "                    \" 'unhashed_description'\"",
            "                )",
            "            if unhashed_description and not self.supports_description_hash:",
            "                raise UnsupportedError(\"unhashed_description\")",
            "            r: dict = self.ln.invoice(  # type: ignore",
            "                msatoshi=msat,",
            "                label=label,",
            "                description=(",
            "                    unhashed_description.decode() if unhashed_description else memo",
            "                ),",
            "                exposeprivatechannels=True,",
            "                deschashonly=(",
            "                    True if unhashed_description else False",
            "                ),  # we can't pass None here",
            "                expiry=kwargs.get(\"expiry\"),",
            "            )",
            "",
            "            if r.get(\"code\") and r.get(\"code\") < 0:  # type: ignore",
            "                raise Exception(r.get(\"message\"))",
            "",
            "            return InvoiceResponse(True, r[\"payment_hash\"], r[\"bolt11\"], None)",
            "        except RpcError as exc:",
            "            logger.warning(exc)",
            "            error_message = f\"RPC '{exc.method}' failed with '{exc.error}'.\"",
            "            return InvoiceResponse(False, None, None, error_message)",
            "        except KeyError as exc:",
            "            logger.warning(exc)",
            "            return InvoiceResponse(",
            "                False, None, None, \"Server error: 'missing required fields'\"",
            "            )",
            "        except Exception as e:",
            "            logger.warning(e)",
            "            return InvoiceResponse(False, None, None, str(e))",
            "",
            "    async def pay_invoice(self, bolt11: str, fee_limit_msat: int) -> PaymentResponse:",
            "        try:",
            "            invoice = bolt11_decode(bolt11)",
            "        except Bolt11Exception as exc:",
            "            return PaymentResponse(False, None, None, None, str(exc))",
            "",
            "        try:",
            "            previous_payment = await self.get_payment_status(invoice.payment_hash)",
            "            if previous_payment.paid:",
            "                return PaymentResponse(False, None, None, None, \"invoice already paid\")",
            "",
            "            if not invoice.amount_msat or invoice.amount_msat <= 0:",
            "                return PaymentResponse(",
            "                    False, None, None, None, \"CLN 0 amount invoice not supported\"",
            "                )",
            "",
            "            # maxfee overrides both maxfeepercent and exemptfee defaults (and",
            "            # if you specify maxfee you cannot specify either of those), and",
            "            # creates an absolute limit on what fee we will pay. This allows you to",
            "            # implement your own heuristics rather than the primitive ones used",
            "            # here.",
            "            payload = {",
            "                \"bolt11\": bolt11,",
            "                \"maxfee\": fee_limit_msat,",
            "                \"description\": invoice.description,",
            "            }",
            "",
            "            r = await run_sync(lambda: self.ln.call(self.pay, payload))",
            "",
            "            fee_msat = -int(r[\"amount_sent_msat\"] - r[\"amount_msat\"])",
            "            return PaymentResponse(",
            "                True, r[\"payment_hash\"], fee_msat, r[\"payment_preimage\"], None",
            "            )",
            "        except RpcError as exc:",
            "            logger.warning(exc)",
            "            try:",
            "                error_code = exc.error.get(\"code\")",
            "                if error_code in self.pay_failure_error_codes:  # type: ignore",
            "                    error_message = exc.error.get(\"message\", error_code)  # type: ignore",
            "                    return PaymentResponse(",
            "                        False, None, None, None, f\"Payment failed: {error_message}\"",
            "                    )",
            "                else:",
            "                    error_message = f\"Payment failed: {exc.error}\"",
            "                    return PaymentResponse(None, None, None, None, error_message)",
            "            except Exception:",
            "                error_message = f\"RPC '{exc.method}' failed with '{exc.error}'.\"",
            "                return PaymentResponse(None, None, None, None, error_message)",
            "        except KeyError as exc:",
            "            logger.warning(exc)",
            "            return PaymentResponse(",
            "                None, None, None, None, \"Server error: 'missing required fields'\"",
            "            )",
            "        except Exception as exc:",
            "            logger.info(f\"Failed to pay invoice {bolt11}\")",
            "            logger.warning(exc)",
            "            return PaymentResponse(None, None, None, None, f\"Payment failed: '{exc}'.\")",
            "",
            "    async def get_invoice_status(self, checking_id: str) -> PaymentStatus:",
            "        try:",
            "            r: dict = self.ln.listinvoices(payment_hash=checking_id)  # type: ignore",
            "",
            "            if not r[\"invoices\"]:",
            "                return PaymentPendingStatus()",
            "",
            "            invoice_resp = r[\"invoices\"][-1]",
            "",
            "            if invoice_resp[\"payment_hash\"] == checking_id:",
            "                if invoice_resp[\"status\"] == \"paid\":",
            "                    return PaymentSuccessStatus()",
            "                elif invoice_resp[\"status\"] == \"unpaid\":",
            "                    return PaymentPendingStatus()",
            "                elif invoice_resp[\"status\"] == \"expired\":",
            "                    return PaymentFailedStatus()",
            "            else:",
            "                logger.warning(f\"supplied an invalid checking_id: {checking_id}\")",
            "            return PaymentPendingStatus()",
            "        except RpcError as exc:",
            "            logger.warning(exc)",
            "            return PaymentPendingStatus()",
            "        except Exception as exc:",
            "            logger.warning(exc)",
            "            return PaymentPendingStatus()",
            "",
            "    async def get_payment_status(self, checking_id: str) -> PaymentStatus:",
            "        try:",
            "            r: dict = self.ln.listpays(payment_hash=checking_id)  # type: ignore",
            "",
            "            if \"pays\" not in r:",
            "                return PaymentPendingStatus()",
            "            if not r[\"pays\"]:",
            "                # no payment with this payment_hash is found",
            "                return PaymentFailedStatus()",
            "",
            "            payment_resp = r[\"pays\"][-1]",
            "",
            "            if payment_resp[\"payment_hash\"] == checking_id:",
            "                status = payment_resp[\"status\"]",
            "                if status == \"complete\":",
            "                    fee_msat = -int(",
            "                        payment_resp[\"amount_sent_msat\"] - payment_resp[\"amount_msat\"]",
            "                    )",
            "",
            "                    return PaymentSuccessStatus(",
            "                        fee_msat=fee_msat, preimage=payment_resp[\"preimage\"]",
            "                    )",
            "                elif status == \"failed\":",
            "                    return PaymentFailedStatus()",
            "                else:",
            "                    return PaymentPendingStatus()",
            "            else:",
            "                logger.warning(f\"supplied an invalid checking_id: {checking_id}\")",
            "            return PaymentPendingStatus()",
            "",
            "        except Exception as exc:",
            "            logger.warning(exc)",
            "            return PaymentPendingStatus()",
            "",
            "    async def paid_invoices_stream(self) -> AsyncGenerator[str, None]:",
            "        while settings.lnbits_running:",
            "            try:",
            "                paid = await run_sync(",
            "                    lambda: self.ln.waitanyinvoice(self.last_pay_index, timeout=2)",
            "                )",
            "                self.last_pay_index = paid[\"pay_index\"]",
            "                yield paid[\"payment_hash\"]",
            "            except RpcError as exc:",
            "                # only raise if not a timeout",
            "                if exc.error[\"code\"] != 904:  # type: ignore",
            "                    raise",
            "            except Exception as exc:",
            "                logger.error(",
            "                    f\"lost connection to corelightning invoices stream: '{exc}', \"",
            "                    \"retrying in 5 seconds\"",
            "                )",
            "                await asyncio.sleep(5)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "158": [
                "CoreLightningWallet"
            ],
            "161": [
                "CoreLightningWallet"
            ],
            "165": [
                "CoreLightningWallet"
            ],
            "170": [
                "CoreLightningWallet"
            ]
        },
        "addLocation": [
            "src.pyload.webui.app.blueprints.json_blueprint",
            "lnbits.wallets.corelightning.CoreLightningWallet"
        ]
    }
}