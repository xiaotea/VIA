{
    "kmip/services/server/server.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": 267,
                "PatchRowcode": "         self._logger.info(\"Starting server socket handler.\")"
            },
            "1": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 268,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 269,
                "PatchRowcode": "         # Create a TCP stream socket and configure it for immediate reuse."
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 270,
                "PatchRowcode": "+        socket.setdefaulttimeout(10)"
            },
            "4": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": 271,
                "PatchRowcode": "         self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)"
            },
            "5": {
                "beforePatchRowNumber": 271,
                "afterPatchRowNumber": 272,
                "PatchRowcode": "         self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)"
            },
            "6": {
                "beforePatchRowNumber": 272,
                "afterPatchRowNumber": 273,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 407,
                "afterPatchRowNumber": 408,
                "PatchRowcode": "         while self._is_serving:"
            },
            "8": {
                "beforePatchRowNumber": 408,
                "afterPatchRowNumber": 409,
                "PatchRowcode": "             try:"
            },
            "9": {
                "beforePatchRowNumber": 409,
                "afterPatchRowNumber": 410,
                "PatchRowcode": "                 connection, address = self._socket.accept()"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 411,
                "PatchRowcode": "+            except socket.timeout:"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 412,
                "PatchRowcode": "+                # Setting the default socket timeout to break hung connections"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 413,
                "PatchRowcode": "+                # will cause accept to periodically raise socket.timeout. This"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 414,
                "PatchRowcode": "+                # is expected behavior, so ignore it and retry accept."
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 415,
                "PatchRowcode": "+                pass"
            },
            "15": {
                "beforePatchRowNumber": 410,
                "afterPatchRowNumber": 416,
                "PatchRowcode": "             except socket.error as e:"
            },
            "16": {
                "beforePatchRowNumber": 411,
                "afterPatchRowNumber": 417,
                "PatchRowcode": "                 self._logger.warning("
            },
            "17": {
                "beforePatchRowNumber": 412,
                "afterPatchRowNumber": 418,
                "PatchRowcode": "                     \"Error detected while establishing new connection.\""
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2015 The Johns Hopkins University/Applied Physics Laboratory",
            "# All Rights Reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#    http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import copy",
            "import logging",
            "import logging.handlers as handlers",
            "import multiprocessing",
            "import optparse",
            "import os",
            "import signal",
            "import six",
            "import socket",
            "import ssl",
            "import sys",
            "import threading",
            "",
            "from kmip.core import exceptions",
            "from kmip.core import policy as operation_policy",
            "from kmip.services import auth",
            "from kmip.services.server import config",
            "from kmip.services.server import engine",
            "from kmip.services.server import monitor",
            "from kmip.services.server import session",
            "",
            "",
            "class KmipServer(object):",
            "    \"\"\"",
            "    The public front-end for the entire KmipServer service.",
            "",
            "    The KmipServer manages the server configuration and oversees the creation",
            "    of KmipSessions for all successful client connections. It creates the",
            "    KmipEngine used to process all KMIP requests and is in charge of safely",
            "    shutting down all server components upon receiving a termination signal.",
            "    \"\"\"",
            "",
            "    # TODO (peter-hamilton) Move to using **kwargs for all server parameters.",
            "    def __init__(",
            "            self,",
            "            hostname=None,",
            "            port=None,",
            "            certificate_path=None,",
            "            key_path=None,",
            "            ca_path=None,",
            "            auth_suite=None,",
            "            config_path='/etc/pykmip/server.conf',",
            "            log_path='/var/log/pykmip/server.log',",
            "            policy_path=None,",
            "            enable_tls_client_auth=None,",
            "            tls_cipher_suites=None,",
            "            logging_level=None,",
            "            live_policies=False,",
            "            database_path=None",
            "    ):",
            "        \"\"\"",
            "        Create a KmipServer.",
            "",
            "        Settings are loaded initially from the configuration file located at",
            "        config_path, if specified. All other configuration options listed",
            "        below, if specified, will override the settings loaded from the",
            "        configuration file.",
            "",
            "        A rotating file logger will be set up with the base log file located",
            "        at log_path. The server itself will handle rotating the log files as",
            "        the logs grow. The server process must have permission to read/write",
            "        to the specified log directory.",
            "",
            "        The main KmipEngine request processor is created here, along with all",
            "        information required to manage KMIP client connections and sessions.",
            "",
            "        Args:",
            "            hostname (string): The host address the server will be bound to",
            "                (e.g., '127.0.0.1'). Optional, defaults to None.",
            "            port (int): The port number the server will be bound to",
            "                (e.g., 5696). Optional, defaults to None.",
            "            certificate_path (string): The path to the server certificate file",
            "                (e.g., '/etc/pykmip/certs/server.crt'). Optional, defaults to",
            "                None.",
            "            key_path (string): The path to the server certificate key file",
            "                (e.g., '/etc/pykmip/certs/server.key'). Optional, defaults to",
            "                None.",
            "            ca_path (string): The path to the certificate authority (CA)",
            "                certificate file (e.g., '/etc/pykmip/certs/ca.crt'). Optional,",
            "                defaults to None.",
            "            auth_suite (string): A string value indicating the type of",
            "                authentication suite to use for establishing TLS connections.",
            "                Accepted values are: 'Basic', 'TLS1.2'. Optional, defaults to",
            "                None.",
            "            config_path (string): The path to the server configuration file",
            "                (e.g., '/etc/pykmip/server.conf'). Optional, defaults to",
            "                '/etc/pykmip/server.conf'.",
            "            log_path (string): The path to the base server log file",
            "                (e.g., '/var/log/pykmip/server.log'). Optional, defaults to",
            "                '/var/log/pykmip/server.log'.",
            "            policy_path (string): The path to the filesystem directory",
            "                containing PyKMIP server operation policy JSON files.",
            "                Optional, defaults to None.",
            "            enable_tls_client_auth (boolean): A boolean indicating if the TLS",
            "                certificate client auth flag should be required for client",
            "                certificates when establishing a new client session. Optional,",
            "                defaults to None.",
            "            tls_cipher_suites (string): A comma-delimited list of cipher suite",
            "                names (e.g., TLS_RSA_WITH_AES_256_CBC_SHA256,TLS_RSA_WITH_AES_",
            "                128_CBC_SHA256), indicating which specific cipher suites should",
            "                be used by the server when establishing a TLS connection with",
            "                a client. Optional, defaults to None. If None, the default set",
            "                of TLS cipher suites will be used.",
            "            logging_level (string): A logging level enumeration defined by the",
            "                logging package (e.g., DEBUG, INFO). Sets the base logging",
            "                level for the server. All log messages logged at this level or",
            "                higher in criticality will be logged. All log messages lower",
            "                in criticality will not be logged. Optional, defaults to None.",
            "            live_policies (boolean): A boolean indicating if the operation",
            "                policy directory should be actively monitored to autoload any",
            "                policy changes while the server is running. Optional, defaults",
            "                to False.",
            "            database_path (string): The path to the server's SQLite database",
            "                file. Optional, defaults to None.",
            "        \"\"\"",
            "        self._logger = logging.getLogger('kmip.server')",
            "        self._setup_logging(log_path)",
            "",
            "        self.config = config.KmipServerConfig()",
            "        self._setup_configuration(",
            "            config_path,",
            "            hostname,",
            "            port,",
            "            certificate_path,",
            "            key_path,",
            "            ca_path,",
            "            auth_suite,",
            "            policy_path,",
            "            enable_tls_client_auth,",
            "            tls_cipher_suites,",
            "            logging_level,",
            "            database_path",
            "        )",
            "        self.live_policies = live_policies",
            "        self.policies = {}",
            "",
            "        self._logger.setLevel(self.config.settings.get('logging_level'))",
            "",
            "        cipher_suites = self.config.settings.get('tls_cipher_suites')",
            "        if self.config.settings.get('auth_suite') == 'TLS1.2':",
            "            self.auth_suite = auth.TLS12AuthenticationSuite(cipher_suites)",
            "        else:",
            "            self.auth_suite = auth.BasicAuthenticationSuite(cipher_suites)",
            "",
            "        self._session_id = 1",
            "        self._is_serving = False",
            "",
            "    def _setup_logging(self, path):",
            "        # Create the logging directory/file if it doesn't exist.",
            "        if not os.path.exists(path):",
            "            if not os.path.isdir(os.path.dirname(path)):",
            "                os.makedirs(os.path.dirname(path))",
            "            open(path, 'w').close()",
            "",
            "        handler = handlers.RotatingFileHandler(",
            "            path,",
            "            mode='a',",
            "            maxBytes=1000000,",
            "            backupCount=5",
            "        )",
            "        handler.setFormatter(",
            "            logging.Formatter(",
            "                \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"",
            "            )",
            "        )",
            "        self._logger.addHandler(handler)",
            "        self._logger.setLevel(logging.DEBUG)",
            "",
            "    def _setup_configuration(",
            "            self,",
            "            path=None,",
            "            hostname=None,",
            "            port=None,",
            "            certificate_path=None,",
            "            key_path=None,",
            "            ca_path=None,",
            "            auth_suite=None,",
            "            policy_path=None,",
            "            enable_tls_client_auth=None,",
            "            tls_cipher_suites=None,",
            "            logging_level=None,",
            "            database_path=None",
            "    ):",
            "        if path:",
            "            self.config.load_settings(path)",
            "",
            "        if hostname:",
            "            self.config.set_setting('hostname', hostname)",
            "        if port:",
            "            self.config.set_setting('port', port)",
            "        if certificate_path:",
            "            self.config.set_setting('certificate_path', certificate_path)",
            "        if key_path:",
            "            self.config.set_setting('key_path', key_path)",
            "        if ca_path:",
            "            self.config.set_setting('ca_path', ca_path)",
            "        if auth_suite:",
            "            self.config.set_setting('auth_suite', auth_suite)",
            "        if policy_path:",
            "            self.config.set_setting('policy_path', policy_path)",
            "        if enable_tls_client_auth is not None:",
            "            self.config.set_setting(",
            "                'enable_tls_client_auth',",
            "                enable_tls_client_auth",
            "            )",
            "        if tls_cipher_suites:",
            "            self.config.set_setting(",
            "                'tls_cipher_suites',",
            "                tls_cipher_suites.split(',')",
            "            )",
            "        if logging_level:",
            "            self.config.set_setting('logging_level', logging_level)",
            "        if database_path:",
            "            self.config.set_setting('database_path', database_path)",
            "",
            "    def start(self):",
            "        \"\"\"",
            "        Prepare the server to start serving connections.",
            "",
            "        Configure the server socket handler and establish a TLS wrapping",
            "        socket from which all client connections descend. Bind this TLS",
            "        socket to the specified network address for the server.",
            "",
            "        Raises:",
            "            NetworkingError: Raised if the TLS socket cannot be bound to the",
            "                network address.",
            "        \"\"\"",
            "        self.manager = multiprocessing.Manager()",
            "        self.policies = self.manager.dict()",
            "        policies = copy.deepcopy(operation_policy.policies)",
            "        for policy_name, policy_set in six.iteritems(policies):",
            "            self.policies[policy_name] = policy_set",
            "",
            "        self.policy_monitor = monitor.PolicyDirectoryMonitor(",
            "            self.config.settings.get('policy_path'),",
            "            self.policies,",
            "            self.live_policies",
            "        )",
            "",
            "        def interrupt_handler(trigger, frame):",
            "            self.policy_monitor.stop()",
            "        signal.signal(signal.SIGINT, interrupt_handler)",
            "        signal.signal(signal.SIGTERM, interrupt_handler)",
            "",
            "        self.policy_monitor.start()",
            "",
            "        self._engine = engine.KmipEngine(",
            "            policies=self.policies,",
            "            database_path=self.config.settings.get('database_path')",
            "        )",
            "",
            "        self._logger.info(\"Starting server socket handler.\")",
            "",
            "        # Create a TCP stream socket and configure it for immediate reuse.",
            "        self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
            "        self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)",
            "",
            "        self._logger.debug(",
            "            \"Configured cipher suites: {0}\".format(",
            "                len(self.config.settings.get('tls_cipher_suites'))",
            "            )",
            "        )",
            "        for cipher in self.config.settings.get('tls_cipher_suites'):",
            "            self._logger.debug(cipher)",
            "        auth_suite_ciphers = self.auth_suite.ciphers.split(':')",
            "        self._logger.debug(",
            "            \"Authentication suite ciphers to use: {0}\".format(",
            "                len(auth_suite_ciphers)",
            "            )",
            "        )",
            "        for cipher in auth_suite_ciphers:",
            "            self._logger.debug(cipher)",
            "",
            "        self._socket = ssl.wrap_socket(",
            "            self._socket,",
            "            keyfile=self.config.settings.get('key_path'),",
            "            certfile=self.config.settings.get('certificate_path'),",
            "            server_side=True,",
            "            cert_reqs=ssl.CERT_REQUIRED,",
            "            ssl_version=self.auth_suite.protocol,",
            "            ca_certs=self.config.settings.get('ca_path'),",
            "            do_handshake_on_connect=True,",
            "            suppress_ragged_eofs=True,",
            "            ciphers=self.auth_suite.ciphers",
            "        )",
            "",
            "        try:",
            "            self._socket.bind(",
            "                (",
            "                    self.config.settings.get('hostname'),",
            "                    int(self.config.settings.get('port'))",
            "                )",
            "            )",
            "        except Exception as e:",
            "            self._logger.exception(e)",
            "            raise exceptions.NetworkingError(",
            "                \"Server failed to bind socket handler to {0}:{1}\".format(",
            "                    self.config.settings.get('hostname'),",
            "                    self.config.settings.get('port')",
            "                )",
            "            )",
            "        else:",
            "            self._logger.info(",
            "                \"Server successfully bound socket handler to {0}:{1}\".format(",
            "                    self.config.settings.get('hostname'),",
            "                    self.config.settings.get('port')",
            "                )",
            "            )",
            "            self._is_serving = True",
            "",
            "    def stop(self):",
            "        \"\"\"",
            "        Stop the server.",
            "",
            "        Halt server client connections and clean up any existing connection",
            "        threads.",
            "",
            "        Raises:",
            "            NetworkingError: Raised if a failure occurs while sutting down",
            "                or closing the TLS server socket.",
            "        \"\"\"",
            "        self._logger.info(\"Cleaning up remaining connection threads.\")",
            "",
            "        for thread in threading.enumerate():",
            "            if thread is not threading.current_thread():",
            "                try:",
            "                    thread.join(10.0)",
            "                except Exception as e:",
            "                    self._logger.info(",
            "                        \"Error occurred while attempting to cleanup thread: \"",
            "                        \"{0}\".format(thread.name)",
            "                    )",
            "                    self._logger.exception(e)",
            "                else:",
            "                    if thread.is_alive():",
            "                        self._logger.warning(",
            "                            \"Cleanup failed for thread: {0}. Thread is \"",
            "                            \"still alive\".format(thread.name)",
            "                        )",
            "                    else:",
            "                        self._logger.info(",
            "                            \"Cleanup succeeded for thread: {0}\".format(",
            "                                thread.name",
            "                            )",
            "                        )",
            "",
            "        self._logger.info(\"Shutting down server socket handler.\")",
            "        try:",
            "            self._socket.shutdown(socket.SHUT_RDWR)",
            "            self._socket.close()",
            "        except Exception as e:",
            "            self._logger.exception(e)",
            "            raise exceptions.NetworkingError(",
            "                \"Server failed to shutdown socket handler.\"",
            "            )",
            "",
            "        if hasattr(self, \"policy_monitor\"):",
            "            try:",
            "                self.policy_monitor.stop()",
            "                self.policy_monitor.join()",
            "            except Exception as e:",
            "                self._logger.exception(e)",
            "                raise exceptions.ShutdownError(",
            "                    \"Server failed to clean up the policy monitor.\"",
            "                )",
            "",
            "    def serve(self):",
            "        \"\"\"",
            "        Serve client connections.",
            "",
            "        Begin listening for client connections, spinning off new KmipSessions",
            "        as connections are handled. Set up signal handling to shutdown",
            "        connection service as needed.",
            "        \"\"\"",
            "        self._socket.listen(5)",
            "",
            "        def _signal_handler(signal_number, stack_frame):",
            "            self._is_serving = False",
            "",
            "            # Python3.5+ silently ignores SIGINT and retries system calls if",
            "            # the signal handler does not raise an exception. Explicitly",
            "            # detect SIGINT and raise a KeyboardInterrupt exception to regain",
            "            # old functionality.",
            "            if signal_number == signal.SIGINT:",
            "                raise KeyboardInterrupt(\"SIGINT received\")",
            "",
            "        signal.signal(signal.SIGINT, _signal_handler)",
            "        signal.signal(signal.SIGTERM, _signal_handler)",
            "",
            "        self._logger.info(\"Starting connection service...\")",
            "",
            "        while self._is_serving:",
            "            try:",
            "                connection, address = self._socket.accept()",
            "            except socket.error as e:",
            "                self._logger.warning(",
            "                    \"Error detected while establishing new connection.\"",
            "                )",
            "                self._logger.exception(e)",
            "            except KeyboardInterrupt:",
            "                self._logger.warning(\"Interrupting connection service.\")",
            "                self._is_serving = False",
            "                break",
            "            except Exception as e:",
            "                self._logger.warning(",
            "                    \"Error detected while establishing new connection.\"",
            "                )",
            "                self._logger.exception(e)",
            "            else:",
            "                self._setup_connection_handler(connection, address)",
            "",
            "        self._logger.info(\"Stopping connection service.\")",
            "",
            "    def _setup_connection_handler(self, connection, address):",
            "        self._logger.info(",
            "            \"Receiving incoming connection from: {0}:{1}\".format(",
            "                address[0],",
            "                address[1]",
            "            )",
            "        )",
            "",
            "        session_name = \"{0:08}\".format(self._session_id)",
            "        self._session_id += 1",
            "",
            "        self._logger.info(",
            "            \"Dedicating session {0} to {1}:{2}\".format(",
            "                session_name,",
            "                address[0],",
            "                address[1]",
            "            )",
            "        )",
            "",
            "        try:",
            "            s = session.KmipSession(",
            "                self._engine,",
            "                connection,",
            "                address,",
            "                name=session_name,",
            "                enable_tls_client_auth=self.config.settings.get(",
            "                    'enable_tls_client_auth'",
            "                ),",
            "                auth_settings=self.config.settings.get('auth_plugins')",
            "            )",
            "            s.daemon = True",
            "            s.start()",
            "        except Exception as e:",
            "            self._logger.warning(",
            "                \"Failure occurred while starting session: {0}\".format(",
            "                    session_name",
            "                )",
            "            )",
            "            self._logger.exception(e)",
            "",
            "    def __enter__(self):",
            "        self.start()",
            "        return self",
            "",
            "    def __exit__(self, exc_type, exc_value, traceback):",
            "        self.stop()",
            "",
            "",
            "def build_argument_parser():",
            "    parser = optparse.OptionParser(",
            "        usage=\"%prog [options]\",",
            "        description=\"Run the PyKMIP software server.\")",
            "",
            "    parser.add_option(",
            "        \"-n\",",
            "        \"--hostname\",",
            "        action=\"store\",",
            "        type=\"str\",",
            "        default=None,",
            "        dest=\"hostname\",",
            "        help=(",
            "            \"The host address the server will be bound to. A string \"",
            "            \"representing either a hostname in Internet domain notation or \"",
            "            \"an IPv4 address. Defaults to None.\"",
            "        ),",
            "    )",
            "    parser.add_option(",
            "        \"-p\",",
            "        \"--port\",",
            "        action=\"store\",",
            "        type=\"int\",",
            "        default=None,",
            "        dest=\"port\",",
            "        help=(",
            "            \"The port number the server will be bound to. An integer \"",
            "            \"representing a port number. Recommended to be 5696 according to \"",
            "            \"the KMIP specification. Defaults to None.\"",
            "        ),",
            "    )",
            "    parser.add_option(",
            "        \"-c\",",
            "        \"--certificate_path\",",
            "        action=\"store\",",
            "        type=\"str\",",
            "        default=None,",
            "        dest=\"certificate_path\",",
            "        help=(",
            "            \"A string representing a path to a PEM-encoded server \"",
            "            \"certificate file. Defaults to None.\"",
            "        ),",
            "    )",
            "    parser.add_option(",
            "        \"-k\",",
            "        \"--key_path\",",
            "        action=\"store\",",
            "        type=\"str\",",
            "        default=None,",
            "        dest=\"key_path\",",
            "        help=(",
            "            \"A string representing a path to a PEM-encoded server \"",
            "            \"certificate key file. Defaults to None.\"",
            "        ),",
            "    )",
            "    parser.add_option(",
            "        \"-a\",",
            "        \"--ca_path\",",
            "        action=\"store\",",
            "        type=\"str\",",
            "        default=None,",
            "        dest=\"ca_path\",",
            "        help=(",
            "            \"A string representing a path to a PEM-encoded certificate \"",
            "            \"authority certificate file. Defaults to None.\"",
            "        ),",
            "    )",
            "    parser.add_option(",
            "        \"-s\",",
            "        \"--auth_suite\",",
            "        action=\"store\",",
            "        type=\"str\",",
            "        default=None,",
            "        dest=\"auth_suite\",",
            "        help=(",
            "            \"A string representing the type of authentication suite to use \"",
            "            \"when establishing TLS connections. Options include 'Basic' and \"",
            "            \"'TLS1.2'. Defaults to None.\"",
            "        ),",
            "    )",
            "    parser.add_option(",
            "        \"-f\",",
            "        \"--config_path\",",
            "        action=\"store\",",
            "        type=\"str\",",
            "        default=None,",
            "        dest=\"config_path\",",
            "        help=(",
            "            \"A string representing a path to a server configuration file. \"",
            "            \"Defaults to None.\"",
            "        ),",
            "    )",
            "    parser.add_option(",
            "        \"-l\",",
            "        \"--log_path\",",
            "        action=\"store\",",
            "        type=\"str\",",
            "        default=None,",
            "        dest=\"log_path\",",
            "        help=(",
            "            \"A string representing a path to a log file. Defaults to None.\"",
            "        ),",
            "    )",
            "    parser.add_option(",
            "        \"-o\",",
            "        \"--policy_path\",",
            "        action=\"store\",",
            "        type=\"str\",",
            "        default=None,",
            "        dest=\"policy_path\",",
            "        help=(",
            "            \"A string representing a path to the operation policy filesystem \"",
            "            \"directory. Optional, defaults to None.\"",
            "        ),",
            "    )",
            "    parser.add_option(",
            "        \"-i\",",
            "        \"--ignore_tls_client_auth\",",
            "        action=\"store_true\",",
            "        default=False,",
            "        dest=\"ignore_tls_client_auth\",",
            "        help=(",
            "            \"A boolean indicating whether or not the TLS certificate client \"",
            "            \"auth flag should be ignored when establishing client sessions. \"",
            "            \"Optional, defaults to None.\"",
            "        )",
            "    )",
            "    parser.add_option(",
            "        \"-v\",",
            "        \"--logging_level\",",
            "        action=\"store\",",
            "        type=\"str\",",
            "        default=None,",
            "        dest=\"logging_level\",",
            "        help=(",
            "            \"A string representing the logging level for the server (e.g., \"",
            "            \"DEBUG, INFO). Optional, defaults to None.\"",
            "        )",
            "    )",
            "    parser.add_option(",
            "        \"-d\",",
            "        \"--database_path\",",
            "        action=\"store\",",
            "        type=\"str\",",
            "        default=None,",
            "        dest=\"database_path\",",
            "        help=(",
            "            \"A string representing a path to the server's SQLite database \"",
            "            \"file. Optional, defaults to None.\"",
            "        ),",
            "    )",
            "",
            "    return parser",
            "",
            "",
            "def main(args=None):",
            "    # Build argument parser and parser command-line arguments.",
            "    parser = build_argument_parser()",
            "    opts, args = parser.parse_args(sys.argv[1:])",
            "",
            "    kwargs = {}",
            "    if opts.hostname:",
            "        kwargs['hostname'] = opts.hostname",
            "    if opts.port:",
            "        kwargs['port'] = opts.port",
            "    if opts.certificate_path:",
            "        kwargs['certificate_path'] = opts.certificate_path",
            "    if opts.key_path:",
            "        kwargs['key_path'] = opts.key_path",
            "    if opts.ca_path:",
            "        kwargs['ca_path'] = opts.ca_path",
            "    if opts.auth_suite:",
            "        kwargs['auth_suite'] = opts.auth_suite",
            "    if opts.config_path:",
            "        kwargs['config_path'] = opts.config_path",
            "    if opts.log_path:",
            "        kwargs['log_path'] = opts.log_path",
            "    if opts.policy_path:",
            "        kwargs['policy_path'] = opts.policy_path",
            "    if opts.ignore_tls_client_auth:",
            "        kwargs['enable_tls_client_auth'] = False",
            "    if opts.logging_level:",
            "        kwargs['logging_level'] = opts.logging_level",
            "    if opts.database_path:",
            "        kwargs['database_path'] = opts.database_path",
            "",
            "    kwargs['live_policies'] = True",
            "",
            "    # Create and start the server.",
            "    s = KmipServer(**kwargs)",
            "    with s:",
            "        s.serve()",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2015 The Johns Hopkins University/Applied Physics Laboratory",
            "# All Rights Reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#    http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import copy",
            "import logging",
            "import logging.handlers as handlers",
            "import multiprocessing",
            "import optparse",
            "import os",
            "import signal",
            "import six",
            "import socket",
            "import ssl",
            "import sys",
            "import threading",
            "",
            "from kmip.core import exceptions",
            "from kmip.core import policy as operation_policy",
            "from kmip.services import auth",
            "from kmip.services.server import config",
            "from kmip.services.server import engine",
            "from kmip.services.server import monitor",
            "from kmip.services.server import session",
            "",
            "",
            "class KmipServer(object):",
            "    \"\"\"",
            "    The public front-end for the entire KmipServer service.",
            "",
            "    The KmipServer manages the server configuration and oversees the creation",
            "    of KmipSessions for all successful client connections. It creates the",
            "    KmipEngine used to process all KMIP requests and is in charge of safely",
            "    shutting down all server components upon receiving a termination signal.",
            "    \"\"\"",
            "",
            "    # TODO (peter-hamilton) Move to using **kwargs for all server parameters.",
            "    def __init__(",
            "            self,",
            "            hostname=None,",
            "            port=None,",
            "            certificate_path=None,",
            "            key_path=None,",
            "            ca_path=None,",
            "            auth_suite=None,",
            "            config_path='/etc/pykmip/server.conf',",
            "            log_path='/var/log/pykmip/server.log',",
            "            policy_path=None,",
            "            enable_tls_client_auth=None,",
            "            tls_cipher_suites=None,",
            "            logging_level=None,",
            "            live_policies=False,",
            "            database_path=None",
            "    ):",
            "        \"\"\"",
            "        Create a KmipServer.",
            "",
            "        Settings are loaded initially from the configuration file located at",
            "        config_path, if specified. All other configuration options listed",
            "        below, if specified, will override the settings loaded from the",
            "        configuration file.",
            "",
            "        A rotating file logger will be set up with the base log file located",
            "        at log_path. The server itself will handle rotating the log files as",
            "        the logs grow. The server process must have permission to read/write",
            "        to the specified log directory.",
            "",
            "        The main KmipEngine request processor is created here, along with all",
            "        information required to manage KMIP client connections and sessions.",
            "",
            "        Args:",
            "            hostname (string): The host address the server will be bound to",
            "                (e.g., '127.0.0.1'). Optional, defaults to None.",
            "            port (int): The port number the server will be bound to",
            "                (e.g., 5696). Optional, defaults to None.",
            "            certificate_path (string): The path to the server certificate file",
            "                (e.g., '/etc/pykmip/certs/server.crt'). Optional, defaults to",
            "                None.",
            "            key_path (string): The path to the server certificate key file",
            "                (e.g., '/etc/pykmip/certs/server.key'). Optional, defaults to",
            "                None.",
            "            ca_path (string): The path to the certificate authority (CA)",
            "                certificate file (e.g., '/etc/pykmip/certs/ca.crt'). Optional,",
            "                defaults to None.",
            "            auth_suite (string): A string value indicating the type of",
            "                authentication suite to use for establishing TLS connections.",
            "                Accepted values are: 'Basic', 'TLS1.2'. Optional, defaults to",
            "                None.",
            "            config_path (string): The path to the server configuration file",
            "                (e.g., '/etc/pykmip/server.conf'). Optional, defaults to",
            "                '/etc/pykmip/server.conf'.",
            "            log_path (string): The path to the base server log file",
            "                (e.g., '/var/log/pykmip/server.log'). Optional, defaults to",
            "                '/var/log/pykmip/server.log'.",
            "            policy_path (string): The path to the filesystem directory",
            "                containing PyKMIP server operation policy JSON files.",
            "                Optional, defaults to None.",
            "            enable_tls_client_auth (boolean): A boolean indicating if the TLS",
            "                certificate client auth flag should be required for client",
            "                certificates when establishing a new client session. Optional,",
            "                defaults to None.",
            "            tls_cipher_suites (string): A comma-delimited list of cipher suite",
            "                names (e.g., TLS_RSA_WITH_AES_256_CBC_SHA256,TLS_RSA_WITH_AES_",
            "                128_CBC_SHA256), indicating which specific cipher suites should",
            "                be used by the server when establishing a TLS connection with",
            "                a client. Optional, defaults to None. If None, the default set",
            "                of TLS cipher suites will be used.",
            "            logging_level (string): A logging level enumeration defined by the",
            "                logging package (e.g., DEBUG, INFO). Sets the base logging",
            "                level for the server. All log messages logged at this level or",
            "                higher in criticality will be logged. All log messages lower",
            "                in criticality will not be logged. Optional, defaults to None.",
            "            live_policies (boolean): A boolean indicating if the operation",
            "                policy directory should be actively monitored to autoload any",
            "                policy changes while the server is running. Optional, defaults",
            "                to False.",
            "            database_path (string): The path to the server's SQLite database",
            "                file. Optional, defaults to None.",
            "        \"\"\"",
            "        self._logger = logging.getLogger('kmip.server')",
            "        self._setup_logging(log_path)",
            "",
            "        self.config = config.KmipServerConfig()",
            "        self._setup_configuration(",
            "            config_path,",
            "            hostname,",
            "            port,",
            "            certificate_path,",
            "            key_path,",
            "            ca_path,",
            "            auth_suite,",
            "            policy_path,",
            "            enable_tls_client_auth,",
            "            tls_cipher_suites,",
            "            logging_level,",
            "            database_path",
            "        )",
            "        self.live_policies = live_policies",
            "        self.policies = {}",
            "",
            "        self._logger.setLevel(self.config.settings.get('logging_level'))",
            "",
            "        cipher_suites = self.config.settings.get('tls_cipher_suites')",
            "        if self.config.settings.get('auth_suite') == 'TLS1.2':",
            "            self.auth_suite = auth.TLS12AuthenticationSuite(cipher_suites)",
            "        else:",
            "            self.auth_suite = auth.BasicAuthenticationSuite(cipher_suites)",
            "",
            "        self._session_id = 1",
            "        self._is_serving = False",
            "",
            "    def _setup_logging(self, path):",
            "        # Create the logging directory/file if it doesn't exist.",
            "        if not os.path.exists(path):",
            "            if not os.path.isdir(os.path.dirname(path)):",
            "                os.makedirs(os.path.dirname(path))",
            "            open(path, 'w').close()",
            "",
            "        handler = handlers.RotatingFileHandler(",
            "            path,",
            "            mode='a',",
            "            maxBytes=1000000,",
            "            backupCount=5",
            "        )",
            "        handler.setFormatter(",
            "            logging.Formatter(",
            "                \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"",
            "            )",
            "        )",
            "        self._logger.addHandler(handler)",
            "        self._logger.setLevel(logging.DEBUG)",
            "",
            "    def _setup_configuration(",
            "            self,",
            "            path=None,",
            "            hostname=None,",
            "            port=None,",
            "            certificate_path=None,",
            "            key_path=None,",
            "            ca_path=None,",
            "            auth_suite=None,",
            "            policy_path=None,",
            "            enable_tls_client_auth=None,",
            "            tls_cipher_suites=None,",
            "            logging_level=None,",
            "            database_path=None",
            "    ):",
            "        if path:",
            "            self.config.load_settings(path)",
            "",
            "        if hostname:",
            "            self.config.set_setting('hostname', hostname)",
            "        if port:",
            "            self.config.set_setting('port', port)",
            "        if certificate_path:",
            "            self.config.set_setting('certificate_path', certificate_path)",
            "        if key_path:",
            "            self.config.set_setting('key_path', key_path)",
            "        if ca_path:",
            "            self.config.set_setting('ca_path', ca_path)",
            "        if auth_suite:",
            "            self.config.set_setting('auth_suite', auth_suite)",
            "        if policy_path:",
            "            self.config.set_setting('policy_path', policy_path)",
            "        if enable_tls_client_auth is not None:",
            "            self.config.set_setting(",
            "                'enable_tls_client_auth',",
            "                enable_tls_client_auth",
            "            )",
            "        if tls_cipher_suites:",
            "            self.config.set_setting(",
            "                'tls_cipher_suites',",
            "                tls_cipher_suites.split(',')",
            "            )",
            "        if logging_level:",
            "            self.config.set_setting('logging_level', logging_level)",
            "        if database_path:",
            "            self.config.set_setting('database_path', database_path)",
            "",
            "    def start(self):",
            "        \"\"\"",
            "        Prepare the server to start serving connections.",
            "",
            "        Configure the server socket handler and establish a TLS wrapping",
            "        socket from which all client connections descend. Bind this TLS",
            "        socket to the specified network address for the server.",
            "",
            "        Raises:",
            "            NetworkingError: Raised if the TLS socket cannot be bound to the",
            "                network address.",
            "        \"\"\"",
            "        self.manager = multiprocessing.Manager()",
            "        self.policies = self.manager.dict()",
            "        policies = copy.deepcopy(operation_policy.policies)",
            "        for policy_name, policy_set in six.iteritems(policies):",
            "            self.policies[policy_name] = policy_set",
            "",
            "        self.policy_monitor = monitor.PolicyDirectoryMonitor(",
            "            self.config.settings.get('policy_path'),",
            "            self.policies,",
            "            self.live_policies",
            "        )",
            "",
            "        def interrupt_handler(trigger, frame):",
            "            self.policy_monitor.stop()",
            "        signal.signal(signal.SIGINT, interrupt_handler)",
            "        signal.signal(signal.SIGTERM, interrupt_handler)",
            "",
            "        self.policy_monitor.start()",
            "",
            "        self._engine = engine.KmipEngine(",
            "            policies=self.policies,",
            "            database_path=self.config.settings.get('database_path')",
            "        )",
            "",
            "        self._logger.info(\"Starting server socket handler.\")",
            "",
            "        # Create a TCP stream socket and configure it for immediate reuse.",
            "        socket.setdefaulttimeout(10)",
            "        self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)",
            "        self._socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)",
            "",
            "        self._logger.debug(",
            "            \"Configured cipher suites: {0}\".format(",
            "                len(self.config.settings.get('tls_cipher_suites'))",
            "            )",
            "        )",
            "        for cipher in self.config.settings.get('tls_cipher_suites'):",
            "            self._logger.debug(cipher)",
            "        auth_suite_ciphers = self.auth_suite.ciphers.split(':')",
            "        self._logger.debug(",
            "            \"Authentication suite ciphers to use: {0}\".format(",
            "                len(auth_suite_ciphers)",
            "            )",
            "        )",
            "        for cipher in auth_suite_ciphers:",
            "            self._logger.debug(cipher)",
            "",
            "        self._socket = ssl.wrap_socket(",
            "            self._socket,",
            "            keyfile=self.config.settings.get('key_path'),",
            "            certfile=self.config.settings.get('certificate_path'),",
            "            server_side=True,",
            "            cert_reqs=ssl.CERT_REQUIRED,",
            "            ssl_version=self.auth_suite.protocol,",
            "            ca_certs=self.config.settings.get('ca_path'),",
            "            do_handshake_on_connect=True,",
            "            suppress_ragged_eofs=True,",
            "            ciphers=self.auth_suite.ciphers",
            "        )",
            "",
            "        try:",
            "            self._socket.bind(",
            "                (",
            "                    self.config.settings.get('hostname'),",
            "                    int(self.config.settings.get('port'))",
            "                )",
            "            )",
            "        except Exception as e:",
            "            self._logger.exception(e)",
            "            raise exceptions.NetworkingError(",
            "                \"Server failed to bind socket handler to {0}:{1}\".format(",
            "                    self.config.settings.get('hostname'),",
            "                    self.config.settings.get('port')",
            "                )",
            "            )",
            "        else:",
            "            self._logger.info(",
            "                \"Server successfully bound socket handler to {0}:{1}\".format(",
            "                    self.config.settings.get('hostname'),",
            "                    self.config.settings.get('port')",
            "                )",
            "            )",
            "            self._is_serving = True",
            "",
            "    def stop(self):",
            "        \"\"\"",
            "        Stop the server.",
            "",
            "        Halt server client connections and clean up any existing connection",
            "        threads.",
            "",
            "        Raises:",
            "            NetworkingError: Raised if a failure occurs while sutting down",
            "                or closing the TLS server socket.",
            "        \"\"\"",
            "        self._logger.info(\"Cleaning up remaining connection threads.\")",
            "",
            "        for thread in threading.enumerate():",
            "            if thread is not threading.current_thread():",
            "                try:",
            "                    thread.join(10.0)",
            "                except Exception as e:",
            "                    self._logger.info(",
            "                        \"Error occurred while attempting to cleanup thread: \"",
            "                        \"{0}\".format(thread.name)",
            "                    )",
            "                    self._logger.exception(e)",
            "                else:",
            "                    if thread.is_alive():",
            "                        self._logger.warning(",
            "                            \"Cleanup failed for thread: {0}. Thread is \"",
            "                            \"still alive\".format(thread.name)",
            "                        )",
            "                    else:",
            "                        self._logger.info(",
            "                            \"Cleanup succeeded for thread: {0}\".format(",
            "                                thread.name",
            "                            )",
            "                        )",
            "",
            "        self._logger.info(\"Shutting down server socket handler.\")",
            "        try:",
            "            self._socket.shutdown(socket.SHUT_RDWR)",
            "            self._socket.close()",
            "        except Exception as e:",
            "            self._logger.exception(e)",
            "            raise exceptions.NetworkingError(",
            "                \"Server failed to shutdown socket handler.\"",
            "            )",
            "",
            "        if hasattr(self, \"policy_monitor\"):",
            "            try:",
            "                self.policy_monitor.stop()",
            "                self.policy_monitor.join()",
            "            except Exception as e:",
            "                self._logger.exception(e)",
            "                raise exceptions.ShutdownError(",
            "                    \"Server failed to clean up the policy monitor.\"",
            "                )",
            "",
            "    def serve(self):",
            "        \"\"\"",
            "        Serve client connections.",
            "",
            "        Begin listening for client connections, spinning off new KmipSessions",
            "        as connections are handled. Set up signal handling to shutdown",
            "        connection service as needed.",
            "        \"\"\"",
            "        self._socket.listen(5)",
            "",
            "        def _signal_handler(signal_number, stack_frame):",
            "            self._is_serving = False",
            "",
            "            # Python3.5+ silently ignores SIGINT and retries system calls if",
            "            # the signal handler does not raise an exception. Explicitly",
            "            # detect SIGINT and raise a KeyboardInterrupt exception to regain",
            "            # old functionality.",
            "            if signal_number == signal.SIGINT:",
            "                raise KeyboardInterrupt(\"SIGINT received\")",
            "",
            "        signal.signal(signal.SIGINT, _signal_handler)",
            "        signal.signal(signal.SIGTERM, _signal_handler)",
            "",
            "        self._logger.info(\"Starting connection service...\")",
            "",
            "        while self._is_serving:",
            "            try:",
            "                connection, address = self._socket.accept()",
            "            except socket.timeout:",
            "                # Setting the default socket timeout to break hung connections",
            "                # will cause accept to periodically raise socket.timeout. This",
            "                # is expected behavior, so ignore it and retry accept.",
            "                pass",
            "            except socket.error as e:",
            "                self._logger.warning(",
            "                    \"Error detected while establishing new connection.\"",
            "                )",
            "                self._logger.exception(e)",
            "            except KeyboardInterrupt:",
            "                self._logger.warning(\"Interrupting connection service.\")",
            "                self._is_serving = False",
            "                break",
            "            except Exception as e:",
            "                self._logger.warning(",
            "                    \"Error detected while establishing new connection.\"",
            "                )",
            "                self._logger.exception(e)",
            "            else:",
            "                self._setup_connection_handler(connection, address)",
            "",
            "        self._logger.info(\"Stopping connection service.\")",
            "",
            "    def _setup_connection_handler(self, connection, address):",
            "        self._logger.info(",
            "            \"Receiving incoming connection from: {0}:{1}\".format(",
            "                address[0],",
            "                address[1]",
            "            )",
            "        )",
            "",
            "        session_name = \"{0:08}\".format(self._session_id)",
            "        self._session_id += 1",
            "",
            "        self._logger.info(",
            "            \"Dedicating session {0} to {1}:{2}\".format(",
            "                session_name,",
            "                address[0],",
            "                address[1]",
            "            )",
            "        )",
            "",
            "        try:",
            "            s = session.KmipSession(",
            "                self._engine,",
            "                connection,",
            "                address,",
            "                name=session_name,",
            "                enable_tls_client_auth=self.config.settings.get(",
            "                    'enable_tls_client_auth'",
            "                ),",
            "                auth_settings=self.config.settings.get('auth_plugins')",
            "            )",
            "            s.daemon = True",
            "            s.start()",
            "        except Exception as e:",
            "            self._logger.warning(",
            "                \"Failure occurred while starting session: {0}\".format(",
            "                    session_name",
            "                )",
            "            )",
            "            self._logger.exception(e)",
            "",
            "    def __enter__(self):",
            "        self.start()",
            "        return self",
            "",
            "    def __exit__(self, exc_type, exc_value, traceback):",
            "        self.stop()",
            "",
            "",
            "def build_argument_parser():",
            "    parser = optparse.OptionParser(",
            "        usage=\"%prog [options]\",",
            "        description=\"Run the PyKMIP software server.\")",
            "",
            "    parser.add_option(",
            "        \"-n\",",
            "        \"--hostname\",",
            "        action=\"store\",",
            "        type=\"str\",",
            "        default=None,",
            "        dest=\"hostname\",",
            "        help=(",
            "            \"The host address the server will be bound to. A string \"",
            "            \"representing either a hostname in Internet domain notation or \"",
            "            \"an IPv4 address. Defaults to None.\"",
            "        ),",
            "    )",
            "    parser.add_option(",
            "        \"-p\",",
            "        \"--port\",",
            "        action=\"store\",",
            "        type=\"int\",",
            "        default=None,",
            "        dest=\"port\",",
            "        help=(",
            "            \"The port number the server will be bound to. An integer \"",
            "            \"representing a port number. Recommended to be 5696 according to \"",
            "            \"the KMIP specification. Defaults to None.\"",
            "        ),",
            "    )",
            "    parser.add_option(",
            "        \"-c\",",
            "        \"--certificate_path\",",
            "        action=\"store\",",
            "        type=\"str\",",
            "        default=None,",
            "        dest=\"certificate_path\",",
            "        help=(",
            "            \"A string representing a path to a PEM-encoded server \"",
            "            \"certificate file. Defaults to None.\"",
            "        ),",
            "    )",
            "    parser.add_option(",
            "        \"-k\",",
            "        \"--key_path\",",
            "        action=\"store\",",
            "        type=\"str\",",
            "        default=None,",
            "        dest=\"key_path\",",
            "        help=(",
            "            \"A string representing a path to a PEM-encoded server \"",
            "            \"certificate key file. Defaults to None.\"",
            "        ),",
            "    )",
            "    parser.add_option(",
            "        \"-a\",",
            "        \"--ca_path\",",
            "        action=\"store\",",
            "        type=\"str\",",
            "        default=None,",
            "        dest=\"ca_path\",",
            "        help=(",
            "            \"A string representing a path to a PEM-encoded certificate \"",
            "            \"authority certificate file. Defaults to None.\"",
            "        ),",
            "    )",
            "    parser.add_option(",
            "        \"-s\",",
            "        \"--auth_suite\",",
            "        action=\"store\",",
            "        type=\"str\",",
            "        default=None,",
            "        dest=\"auth_suite\",",
            "        help=(",
            "            \"A string representing the type of authentication suite to use \"",
            "            \"when establishing TLS connections. Options include 'Basic' and \"",
            "            \"'TLS1.2'. Defaults to None.\"",
            "        ),",
            "    )",
            "    parser.add_option(",
            "        \"-f\",",
            "        \"--config_path\",",
            "        action=\"store\",",
            "        type=\"str\",",
            "        default=None,",
            "        dest=\"config_path\",",
            "        help=(",
            "            \"A string representing a path to a server configuration file. \"",
            "            \"Defaults to None.\"",
            "        ),",
            "    )",
            "    parser.add_option(",
            "        \"-l\",",
            "        \"--log_path\",",
            "        action=\"store\",",
            "        type=\"str\",",
            "        default=None,",
            "        dest=\"log_path\",",
            "        help=(",
            "            \"A string representing a path to a log file. Defaults to None.\"",
            "        ),",
            "    )",
            "    parser.add_option(",
            "        \"-o\",",
            "        \"--policy_path\",",
            "        action=\"store\",",
            "        type=\"str\",",
            "        default=None,",
            "        dest=\"policy_path\",",
            "        help=(",
            "            \"A string representing a path to the operation policy filesystem \"",
            "            \"directory. Optional, defaults to None.\"",
            "        ),",
            "    )",
            "    parser.add_option(",
            "        \"-i\",",
            "        \"--ignore_tls_client_auth\",",
            "        action=\"store_true\",",
            "        default=False,",
            "        dest=\"ignore_tls_client_auth\",",
            "        help=(",
            "            \"A boolean indicating whether or not the TLS certificate client \"",
            "            \"auth flag should be ignored when establishing client sessions. \"",
            "            \"Optional, defaults to None.\"",
            "        )",
            "    )",
            "    parser.add_option(",
            "        \"-v\",",
            "        \"--logging_level\",",
            "        action=\"store\",",
            "        type=\"str\",",
            "        default=None,",
            "        dest=\"logging_level\",",
            "        help=(",
            "            \"A string representing the logging level for the server (e.g., \"",
            "            \"DEBUG, INFO). Optional, defaults to None.\"",
            "        )",
            "    )",
            "    parser.add_option(",
            "        \"-d\",",
            "        \"--database_path\",",
            "        action=\"store\",",
            "        type=\"str\",",
            "        default=None,",
            "        dest=\"database_path\",",
            "        help=(",
            "            \"A string representing a path to the server's SQLite database \"",
            "            \"file. Optional, defaults to None.\"",
            "        ),",
            "    )",
            "",
            "    return parser",
            "",
            "",
            "def main(args=None):",
            "    # Build argument parser and parser command-line arguments.",
            "    parser = build_argument_parser()",
            "    opts, args = parser.parse_args(sys.argv[1:])",
            "",
            "    kwargs = {}",
            "    if opts.hostname:",
            "        kwargs['hostname'] = opts.hostname",
            "    if opts.port:",
            "        kwargs['port'] = opts.port",
            "    if opts.certificate_path:",
            "        kwargs['certificate_path'] = opts.certificate_path",
            "    if opts.key_path:",
            "        kwargs['key_path'] = opts.key_path",
            "    if opts.ca_path:",
            "        kwargs['ca_path'] = opts.ca_path",
            "    if opts.auth_suite:",
            "        kwargs['auth_suite'] = opts.auth_suite",
            "    if opts.config_path:",
            "        kwargs['config_path'] = opts.config_path",
            "    if opts.log_path:",
            "        kwargs['log_path'] = opts.log_path",
            "    if opts.policy_path:",
            "        kwargs['policy_path'] = opts.policy_path",
            "    if opts.ignore_tls_client_auth:",
            "        kwargs['enable_tls_client_auth'] = False",
            "    if opts.logging_level:",
            "        kwargs['logging_level'] = opts.logging_level",
            "    if opts.database_path:",
            "        kwargs['database_path'] = opts.database_path",
            "",
            "    kwargs['live_policies'] = True",
            "",
            "    # Create and start the server.",
            "    s = KmipServer(**kwargs)",
            "    with s:",
            "        s.serve()",
            "",
            "",
            "if __name__ == '__main__':",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "kmip.services.server.server.KmipServer.__enter__",
            "litellm.utils.exception_type"
        ]
    },
    "kmip/tests/unit/services/server/test_server.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 485,
                "afterPatchRowNumber": 485,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 486,
                "afterPatchRowNumber": 486,
                "PatchRowcode": "         # Test the expected behavior for a normal server/interrupt sequence"
            },
            "2": {
                "beforePatchRowNumber": 487,
                "afterPatchRowNumber": 487,
                "PatchRowcode": "         s._socket.accept = mock.MagicMock("
            },
            "3": {
                "beforePatchRowNumber": 488,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            side_effect=[('connection', 'address'), expected_error]"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 488,
                "PatchRowcode": "+            side_effect=["
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 489,
                "PatchRowcode": "+                ('connection', 'address'),"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 490,
                "PatchRowcode": "+                socket.timeout,"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 491,
                "PatchRowcode": "+                expected_error"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 492,
                "PatchRowcode": "+            ]"
            },
            "9": {
                "beforePatchRowNumber": 489,
                "afterPatchRowNumber": 493,
                "PatchRowcode": "         )"
            },
            "10": {
                "beforePatchRowNumber": 490,
                "afterPatchRowNumber": 494,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 491,
                "afterPatchRowNumber": 495,
                "PatchRowcode": "         s.serve()"
            }
        },
        "frontPatchFile": [
            "# Copyright (c) 2016 The Johns Hopkins University/Applied Physics Laboratory",
            "# All Rights Reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#    http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import logging",
            "",
            "try:",
            "    import unittest.mock as mock",
            "except Exception:",
            "    import mock",
            "",
            "import signal",
            "import socket",
            "import testtools",
            "",
            "from kmip.core import exceptions",
            "from kmip.services import auth",
            "from kmip.services.server import server",
            "",
            "",
            "class TestKmipServer(testtools.TestCase):",
            "    \"\"\"",
            "    A test suite for the KmipServer.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        super(TestKmipServer, self).setUp()",
            "",
            "    def tearDown(self):",
            "        super(TestKmipServer, self).tearDown()",
            "",
            "    @mock.patch('kmip.services.server.server.KmipServer._setup_logging')",
            "    @mock.patch('kmip.services.server.server.KmipServer._setup_configuration')",
            "    def test_init(self, config_mock, logging_mock):",
            "        \"\"\"",
            "        Test that a KmipServer can be instantiated without error.",
            "        \"\"\"",
            "        s = server.KmipServer()",
            "        self.assertTrue(config_mock.called)",
            "        self.assertTrue(logging_mock.called)",
            "",
            "        self.assertIsInstance(s.auth_suite, auth.BasicAuthenticationSuite)",
            "        self.assertEqual(1, s._session_id)",
            "        self.assertFalse(s._is_serving)",
            "",
            "    @mock.patch('logging.getLogger', side_effect=mock.MagicMock())",
            "    @mock.patch('logging.handlers.RotatingFileHandler')",
            "    @mock.patch('kmip.services.server.server.KmipServer._setup_configuration')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('os.path.isdir')",
            "    @mock.patch('os.makedirs')",
            "    def test_setup_logging(",
            "            self,",
            "            makedirs_mock,",
            "            isdir_mock,",
            "            path_mock,",
            "            config_mock,",
            "            handler_mock,",
            "            logging_mock):",
            "        \"\"\"",
            "        Verify that the server logger is setup correctly.",
            "        \"\"\"",
            "        path_mock.return_value = False",
            "        isdir_mock.return_value = False",
            "        open_mock = mock.mock_open()",
            "",
            "        # Dynamically mock out the built-in open function. Approach changes",
            "        # across Python versions.",
            "        try:",
            "            # For Python3+",
            "            import builtins  # NOQA",
            "            module = 'builtins'",
            "        except ImportError:",
            "            # For Python2+",
            "            module = '__builtin__'",
            "",
            "        with mock.patch('{0}.open'.format(module), open_mock):",
            "            s = server.KmipServer(log_path='/test/path/server.log')",
            "",
            "        path_mock.assert_called_once_with('/test/path/server.log')",
            "        isdir_mock.assert_called_once_with('/test/path')",
            "        makedirs_mock.assert_called_once_with('/test/path')",
            "        open_mock.assert_called_once_with('/test/path/server.log', 'w')",
            "",
            "        self.assertTrue(s._logger.addHandler.called)",
            "        s._logger.setLevel.assert_any_call(logging.DEBUG)",
            "",
            "    @mock.patch('kmip.services.server.engine.KmipEngine')",
            "    @mock.patch('kmip.services.auth.TLS12AuthenticationSuite')",
            "    @mock.patch('kmip.services.server.server.KmipServer._setup_logging')",
            "    def test_setup_configuration(self, logging_mock, auth_mock, engine_mock):",
            "        \"\"\"",
            "        Test that the server setup configuration works without error.",
            "        \"\"\"",
            "        s = server.KmipServer(",
            "            config_path=None,",
            "            policy_path=None",
            "        )",
            "        s.config = mock.MagicMock()",
            "",
            "        # Test the right calls are made when reinvoking config setup",
            "        s._setup_configuration(",
            "            '/etc/pykmip/server.conf',",
            "            '127.0.0.1',",
            "            5696,",
            "            '/etc/pykmip/certs/server.crt',",
            "            '/etc/pykmip/certs/server.key',",
            "            '/etc/pykmip/certs/ca.crt',",
            "            'Basic',",
            "            '/etc/pykmip/policies',",
            "            False,",
            "            'TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA',",
            "            'DEBUG',",
            "            '/var/pykmip/pykmip.db'",
            "        )",
            "",
            "        s.config.load_settings.assert_called_with('/etc/pykmip/server.conf')",
            "        s.config.set_setting.assert_any_call('hostname', '127.0.0.1')",
            "        s.config.set_setting.assert_any_call('port', 5696)",
            "        s.config.set_setting.assert_any_call(",
            "            'certificate_path',",
            "            '/etc/pykmip/certs/server.crt'",
            "        )",
            "        s.config.set_setting.assert_any_call(",
            "            'key_path',",
            "            '/etc/pykmip/certs/server.key'",
            "        )",
            "        s.config.set_setting.assert_any_call(",
            "            'ca_path',",
            "            '/etc/pykmip/certs/ca.crt'",
            "        )",
            "        s.config.set_setting.assert_any_call('auth_suite', 'Basic')",
            "        s.config.set_setting.assert_any_call(",
            "            'policy_path',",
            "            '/etc/pykmip/policies'",
            "        )",
            "        s.config.set_setting.assert_any_call(",
            "            'enable_tls_client_auth',",
            "            False",
            "        )",
            "        s.config.set_setting.assert_any_call(",
            "            'tls_cipher_suites',",
            "            [",
            "                'TLS_RSA_WITH_AES_128_CBC_SHA',",
            "                'TLS_RSA_WITH_AES_256_CBC_SHA'",
            "            ]",
            "        )",
            "        s.config.set_setting.assert_any_call('logging_level', 'DEBUG')",
            "        s.config.set_setting.assert_any_call(",
            "            'database_path',",
            "            '/var/pykmip/pykmip.db'",
            "        )",
            "",
            "        # Test that an attempt is made to instantiate the TLS 1.2 auth suite",
            "        s = server.KmipServer(",
            "            auth_suite='TLS1.2',",
            "            config_path=None,",
            "            policy_path=None",
            "        )",
            "        self.assertEqual('TLS1.2', s.config.settings.get('auth_suite'))",
            "        self.assertIsNotNone(s.auth_suite)",
            "",
            "    @mock.patch('multiprocessing.Manager')",
            "    @mock.patch('kmip.services.server.monitor.PolicyDirectoryMonitor')",
            "    @mock.patch('kmip.services.server.engine.KmipEngine')",
            "    @mock.patch('kmip.services.server.server.KmipServer._setup_logging')",
            "    def test_start(self,",
            "                   logging_mock,",
            "                   engine_mock,",
            "                   monitor_mock,",
            "                   manager_mock):",
            "        \"\"\"",
            "        Test that starting the KmipServer either runs as expected or generates",
            "        the expected error.",
            "        \"\"\"",
            "        monitor_instance_mock = mock.MagicMock()",
            "        monitor_mock.return_value = monitor_instance_mock",
            "",
            "        dict_mock = mock.MagicMock()",
            "        manager_instance_mock = mock.MagicMock()",
            "        manager_instance_mock.dict.return_value = dict_mock",
            "        manager_mock.return_value = manager_instance_mock",
            "",
            "        a_mock = mock.MagicMock()",
            "        b_mock = mock.MagicMock()",
            "",
            "        s = server.KmipServer(",
            "            hostname='127.0.0.1',",
            "            port=5696,",
            "            auth_suite='Basic',",
            "            config_path=None,",
            "            policy_path=None,",
            "            tls_cipher_suites='TLS_RSA_WITH_AES_128_CBC_SHA'",
            "        )",
            "        s._logger = mock.MagicMock()",
            "",
            "        self.assertFalse(s._is_serving)",
            "",
            "        # Test that in ideal cases no errors are generated and the right",
            "        # log messages are.",
            "        with mock.patch('socket.socket') as socket_mock:",
            "            with mock.patch('ssl.wrap_socket') as ssl_mock:",
            "                socket_mock.return_value = a_mock",
            "                ssl_mock.return_value = b_mock",
            "",
            "                manager_mock.assert_not_called()",
            "                monitor_mock.assert_not_called()",
            "",
            "                s.start()",
            "",
            "                manager_mock.assert_called_once_with()",
            "                monitor_mock.assert_called_once_with(",
            "                    None,",
            "                    dict_mock,",
            "                    False",
            "                )",
            "                self.assertIsNotNone(s._engine)",
            "                s._logger.info.assert_any_call(",
            "                    \"Starting server socket handler.\"",
            "                )",
            "                s._logger.debug.assert_any_call(\"Configured cipher suites: 1\")",
            "                s._logger.debug.assert_any_call(\"TLS_RSA_WITH_AES_128_CBC_SHA\")",
            "                s._logger.debug.assert_any_call(",
            "                    \"Authentication suite ciphers to use: 1\"",
            "                )",
            "                s._logger.debug.assert_any_call(\"AES128-SHA\")",
            "",
            "                socket_mock.assert_called_once_with(",
            "                    socket.AF_INET,",
            "                    socket.SOCK_STREAM",
            "                )",
            "                a_mock.setsockopt.assert_called_once_with(",
            "                    socket.SOL_SOCKET,",
            "                    socket.SO_REUSEADDR,",
            "                    1",
            "                )",
            "                self.assertTrue(ssl_mock.called)",
            "                b_mock.bind.assert_called_once_with(('127.0.0.1', 5696))",
            "                s._logger.info.assert_called_with(",
            "                    \"Server successfully bound socket handler to \"",
            "                    \"127.0.0.1:5696\"",
            "                )",
            "",
            "        monitor_instance_mock.stop.assert_not_called()",
            "        handler = signal.getsignal(signal.SIGINT)",
            "        handler(None, None)",
            "        monitor_instance_mock.stop.assert_called_once_with()",
            "        monitor_instance_mock.stop.reset_mock()",
            "        monitor_instance_mock.stop.assert_not_called()",
            "        handler = signal.getsignal(signal.SIGTERM)",
            "        handler(None, None)",
            "        monitor_instance_mock.stop.assert_called_once_with()",
            "",
            "        self.assertTrue(s._is_serving)",
            "",
            "        manager_mock.reset_mock()",
            "        monitor_mock.reset_mock()",
            "        a_mock.reset_mock()",
            "        b_mock.reset_mock()",
            "",
            "        # Test that a NetworkingError is generated if the socket bind fails.",
            "        with mock.patch('socket.socket') as socket_mock:",
            "            with mock.patch('ssl.wrap_socket') as ssl_mock:",
            "                socket_mock.return_value = a_mock",
            "                ssl_mock.return_value = b_mock",
            "",
            "                test_exception = Exception()",
            "                b_mock.bind.side_effect = test_exception",
            "",
            "                manager_mock.assert_not_called()",
            "                monitor_mock.assert_not_called()",
            "",
            "                regex = (",
            "                    \"Server failed to bind socket handler to 127.0.0.1:5696\"",
            "                )",
            "                self.assertRaisesRegexp(",
            "                    exceptions.NetworkingError,",
            "                    regex,",
            "                    s.start",
            "                )",
            "",
            "                manager_mock.assert_called_once_with()",
            "                monitor_mock.assert_called_once_with(",
            "                    None,",
            "                    dict_mock,",
            "                    False",
            "                )",
            "                s._logger.info.assert_any_call(",
            "                    \"Starting server socket handler.\"",
            "                )",
            "                s._logger.exception.assert_called_once_with(test_exception)",
            "",
            "    @mock.patch('kmip.services.server.engine.KmipEngine')",
            "    @mock.patch('kmip.services.server.server.KmipServer._setup_logging')",
            "    def test_stop(self, logging_mock, engine_mock):",
            "        \"\"\"",
            "        Test that the right calls and log messages are triggered while",
            "        cleaning up the server and any remaining sessions.",
            "        \"\"\"",
            "        s = server.KmipServer(",
            "            hostname='127.0.0.1',",
            "            port=5696,",
            "            config_path=None,",
            "            policy_path=None",
            "        )",
            "        s._logger = mock.MagicMock()",
            "        s._socket = mock.MagicMock()",
            "",
            "        # Test the expected behavior for a normal server stop sequence",
            "        thread_mock = mock.MagicMock()",
            "        thread_mock.join = mock.MagicMock()",
            "        thread_mock.is_alive = mock.MagicMock(return_value=False)",
            "        thread_mock.name = 'TestThread'",
            "",
            "        with mock.patch('threading.enumerate') as threading_mock:",
            "            threading_mock.return_value = [thread_mock]",
            "",
            "            s.stop()",
            "            s._logger.info.assert_any_call(",
            "                \"Cleaning up remaining connection threads.\"",
            "            )",
            "            self.assertTrue(threading_mock.called)",
            "            thread_mock.join.assert_called_once_with(10.0)",
            "            s._logger.info.assert_any_call(",
            "                \"Cleanup succeeded for thread: TestThread\"",
            "            )",
            "            s._logger.info.assert_any_call(",
            "                \"Shutting down server socket handler.\"",
            "            )",
            "            s._socket.shutdown.assert_called_once_with(socket.SHUT_RDWR)",
            "            s._socket.close.assert_called_once_with()",
            "",
            "        # Test the expected behavior when stopping multiple server session",
            "        # threads goes wrong",
            "        thread_mock.reset_mock()",
            "        test_exception = Exception()",
            "        thread_mock.join = mock.MagicMock(side_effect=test_exception)",
            "",
            "        s._logger.reset_mock()",
            "        s._socket.reset_mock()",
            "",
            "        with mock.patch('threading.enumerate') as threading_mock:",
            "            threading_mock.return_value = [thread_mock]",
            "",
            "            s.stop()",
            "            s._logger.info.assert_any_call(",
            "                \"Cleaning up remaining connection threads.\"",
            "            )",
            "            self.assertTrue(threading_mock.called)",
            "            thread_mock.join.assert_called_once_with(10.0)",
            "            s._logger.info.assert_any_call(",
            "                \"Error occurred while attempting to cleanup thread: TestThread\"",
            "            )",
            "            s._logger.exception.assert_called_once_with(test_exception)",
            "            s._logger.info.assert_any_call(",
            "                \"Shutting down server socket handler.\"",
            "            )",
            "            s._socket.shutdown.assert_called_once_with(socket.SHUT_RDWR)",
            "            s._socket.close.assert_called_once_with()",
            "",
            "        thread_mock.reset_mock()",
            "        test_exception = Exception()",
            "        thread_mock.join = mock.MagicMock()",
            "        thread_mock.is_alive = mock.MagicMock(return_value=True)",
            "",
            "        s._logger.reset_mock()",
            "        s._socket.reset_mock()",
            "",
            "        with mock.patch('threading.enumerate') as threading_mock:",
            "            threading_mock.return_value = [thread_mock]",
            "",
            "            s.stop()",
            "            s._logger.info.assert_any_call(",
            "                \"Cleaning up remaining connection threads.\"",
            "            )",
            "            self.assertTrue(threading_mock.called)",
            "            thread_mock.join.assert_called_once_with(10.0)",
            "            s._logger.warning.assert_any_call(",
            "                \"Cleanup failed for thread: TestThread. Thread is still alive\"",
            "            )",
            "            s._logger.info.assert_any_call(",
            "                \"Shutting down server socket handler.\"",
            "            )",
            "            s._socket.shutdown.assert_called_once_with(socket.SHUT_RDWR)",
            "            s._socket.close.assert_called_once_with()",
            "",
            "        # Test that the right errors and log messages are generated when",
            "        # stopping the server goes wrong",
            "        s._logger.reset_mock()",
            "        s._socket.reset_mock()",
            "",
            "        test_exception = Exception()",
            "        s._socket.close = mock.MagicMock(side_effect=test_exception)",
            "",
            "        regex = \"Server failed to shutdown socket handler.\"",
            "        self.assertRaisesRegexp(",
            "            exceptions.NetworkingError,",
            "            regex,",
            "            s.stop",
            "        )",
            "        s._logger.info.assert_any_call(",
            "            \"Cleaning up remaining connection threads.\"",
            "        )",
            "        s._logger.info.assert_any_call(",
            "            \"Shutting down server socket handler.\"",
            "        )",
            "        s._socket.shutdown.assert_called_once_with(socket.SHUT_RDWR)",
            "        s._socket.close.assert_called_once_with()",
            "        s._logger.exception(test_exception)",
            "",
            "    @mock.patch('kmip.services.server.engine.KmipEngine')",
            "    @mock.patch('kmip.services.server.server.KmipServer._setup_logging')",
            "    def test_stop_with_monitor_shutdown_error(self, logging_mock, engine_mock):",
            "        \"\"\"",
            "        Test that the right calls and log messages are triggered when stopping",
            "        the server results in an error while shutting down the policy monitor.",
            "        \"\"\"",
            "        s = server.KmipServer(",
            "            hostname='127.0.0.1',",
            "            port=5696,",
            "            config_path=None,",
            "            policy_path=None",
            "        )",
            "        s._logger = mock.MagicMock()",
            "        s._socket = mock.MagicMock()",
            "        s.policy_monitor = mock.MagicMock()",
            "        test_exception = Exception()",
            "        s.policy_monitor.join.side_effect = test_exception",
            "",
            "        # Test the expected behavior for a normal server stop sequence",
            "        thread_mock = mock.MagicMock()",
            "        thread_mock.join = mock.MagicMock()",
            "        thread_mock.is_alive = mock.MagicMock(return_value=False)",
            "        thread_mock.name = 'TestThread'",
            "",
            "        regex = \"Server failed to clean up the policy monitor.\"",
            "        self.assertRaisesRegexp(",
            "            exceptions.ShutdownError,",
            "            regex,",
            "            s.stop",
            "        )",
            "        s._logger.info.assert_any_call(",
            "            \"Cleaning up remaining connection threads.\"",
            "        )",
            "        s._logger.info.assert_any_call(",
            "            \"Shutting down server socket handler.\"",
            "        )",
            "        s._socket.shutdown.assert_called_once_with(socket.SHUT_RDWR)",
            "        s._socket.close.assert_called_once_with()",
            "",
            "        s.policy_monitor.stop.assert_called_once_with()",
            "        s.policy_monitor.join.assert_called_once_with()",
            "        s._logger.exception(test_exception)",
            "",
            "    @mock.patch('kmip.services.server.engine.KmipEngine')",
            "    @mock.patch('kmip.services.server.server.KmipServer._setup_logging')",
            "    def test_serve(self, logging_mock, engine_mock):",
            "        \"\"\"",
            "        Test that the right calls and log messages are triggered while",
            "        serving connections.",
            "        \"\"\"",
            "        s = server.KmipServer(",
            "            hostname='127.0.0.1',",
            "            port=5696,",
            "            config_path=None,",
            "            policy_path=None",
            "        )",
            "        s._is_serving = True",
            "        s._logger = mock.MagicMock()",
            "        s._socket = mock.MagicMock()",
            "        s._setup_connection_handler = mock.MagicMock()",
            "",
            "        expected_error = KeyboardInterrupt",
            "",
            "        # Test the expected behavior for a normal server/interrupt sequence",
            "        s._socket.accept = mock.MagicMock(",
            "            side_effect=[('connection', 'address'), expected_error]",
            "        )",
            "",
            "        s.serve()",
            "        s._socket.listen.assert_called_once_with(5)",
            "        s._socket.accept.assert_any_call()",
            "        s._setup_connection_handler.assert_called_once_with(",
            "            'connection',",
            "            'address'",
            "        )",
            "        s._logger.warning.assert_called_with(",
            "            \"Interrupting connection service.\"",
            "        )",
            "        s._logger.info.assert_called_with(\"Stopping connection service.\")",
            "",
            "        # Test the behavior for an unexpected socket error.",
            "        unexpected_error = socket.error()",
            "        s._is_serving = True",
            "        s._logger.reset_mock()",
            "        s._socket.accept = mock.MagicMock(",
            "            side_effect=[unexpected_error, expected_error]",
            "        )",
            "",
            "        s.serve()",
            "        s._socket.accept.assert_any_call()",
            "        s._logger.warning.assert_any_call(",
            "            \"Error detected while establishing new connection.\"",
            "        )",
            "        s._logger.exception.assert_called_with(unexpected_error)",
            "        s._logger.info.assert_called_with(\"Stopping connection service.\")",
            "",
            "        # Test the behavior for an unexpected error.",
            "        unexpected_error = Exception()",
            "        s._is_serving = True",
            "        s._logger.reset_mock()",
            "        s._socket.accept = mock.MagicMock(",
            "            side_effect=[unexpected_error, expected_error]",
            "        )",
            "",
            "        s.serve()",
            "        s._socket.accept.assert_any_call()",
            "        s._logger.warning.assert_any_call(",
            "            \"Error detected while establishing new connection.\"",
            "        )",
            "        s._logger.exception.assert_called_with(unexpected_error)",
            "        s._logger.info.assert_called_with(\"Stopping connection service.\")",
            "",
            "        # Test the signal handler for each expected signal",
            "        s._is_serving = True",
            "        handler = signal.getsignal(signal.SIGINT)",
            "        args = (signal.SIGINT, None)",
            "        self.assertRaisesRegex(",
            "            KeyboardInterrupt,",
            "            \"SIGINT received\",",
            "            handler,",
            "            *args",
            "        )",
            "        self.assertFalse(s._is_serving)",
            "",
            "        s._is_serving = True",
            "        handler = signal.getsignal(signal.SIGTERM)",
            "        handler(None, None)",
            "        self.assertFalse(s._is_serving)",
            "",
            "    @mock.patch('kmip.services.server.engine.KmipEngine')",
            "    @mock.patch('kmip.services.server.server.KmipServer._setup_logging')",
            "    def test_setup_connection_handler(self, logging_mock, engine_mock):",
            "        \"\"\"",
            "        Test that a KmipSession can be successfully created and spun off from",
            "        the KmipServer.",
            "        \"\"\"",
            "        s = server.KmipServer(",
            "            hostname='127.0.0.1',",
            "            port=5696,",
            "            config_path=None,",
            "            policy_path=None",
            "        )",
            "        s._logger = mock.MagicMock()",
            "        s._engine = engine_mock",
            "",
            "        # Test that the right calls and log messages are made when",
            "        # starting a new session.",
            "        with mock.patch(",
            "            'kmip.services.server.session.KmipSession.start'",
            "        ) as session_mock:",
            "            address = ('127.0.0.1', 5696)",
            "            s._setup_connection_handler(None, address)",
            "",
            "            s._logger.info.assert_any_call(",
            "                \"Receiving incoming connection from: 127.0.0.1:5696\"",
            "            )",
            "            s._logger.info.assert_any_call(",
            "                \"Dedicating session 00000001 to 127.0.0.1:5696\"",
            "            )",
            "            session_mock.assert_called_once_with()",
            "",
            "        self.assertEqual(2, s._session_id)",
            "",
            "        # Test that the right error messages are logged when the session",
            "        # fails to start.",
            "        test_exception = Exception()",
            "        with mock.patch(",
            "            'kmip.services.server.session.KmipSession.start',",
            "            side_effect=test_exception",
            "        ) as session_mock:",
            "            address = ('127.0.0.1', 5696)",
            "            s._setup_connection_handler(None, address)",
            "",
            "            s._logger.info.assert_any_call(",
            "                \"Receiving incoming connection from: 127.0.0.1:5696\"",
            "            )",
            "            s._logger.info.assert_any_call(",
            "                \"Dedicating session 00000001 to 127.0.0.1:5696\"",
            "            )",
            "            session_mock.assert_called_once_with()",
            "            s._logger.warning.assert_called_once_with(",
            "                \"Failure occurred while starting session: 00000002\"",
            "            )",
            "            s._logger.exception.assert_called_once_with(test_exception)",
            "",
            "        self.assertEqual(3, s._session_id)",
            "",
            "    @mock.patch('kmip.services.server.engine.KmipEngine')",
            "    @mock.patch('kmip.services.server.server.KmipServer._setup_logging')",
            "    def test_as_context_manager(self, logging_mock, engine_mock):",
            "        \"\"\"",
            "        Test that the right methods are called when the KmipServer is used",
            "        as a context manager.",
            "        \"\"\"",
            "        s = server.KmipServer(",
            "            hostname='127.0.0.1',",
            "            port=5696,",
            "            config_path=None,",
            "            policy_path=None",
            "        )",
            "        s._logger = mock.MagicMock()",
            "        s.start = mock.MagicMock()",
            "        s.stop = mock.MagicMock()",
            "",
            "        with s:",
            "            pass",
            "",
            "        self.assertTrue(s.start.called)",
            "        self.assertTrue(s.stop.called)"
        ],
        "afterPatchFile": [
            "# Copyright (c) 2016 The Johns Hopkins University/Applied Physics Laboratory",
            "# All Rights Reserved.",
            "#",
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#    http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "import logging",
            "",
            "try:",
            "    import unittest.mock as mock",
            "except Exception:",
            "    import mock",
            "",
            "import signal",
            "import socket",
            "import testtools",
            "",
            "from kmip.core import exceptions",
            "from kmip.services import auth",
            "from kmip.services.server import server",
            "",
            "",
            "class TestKmipServer(testtools.TestCase):",
            "    \"\"\"",
            "    A test suite for the KmipServer.",
            "    \"\"\"",
            "",
            "    def setUp(self):",
            "        super(TestKmipServer, self).setUp()",
            "",
            "    def tearDown(self):",
            "        super(TestKmipServer, self).tearDown()",
            "",
            "    @mock.patch('kmip.services.server.server.KmipServer._setup_logging')",
            "    @mock.patch('kmip.services.server.server.KmipServer._setup_configuration')",
            "    def test_init(self, config_mock, logging_mock):",
            "        \"\"\"",
            "        Test that a KmipServer can be instantiated without error.",
            "        \"\"\"",
            "        s = server.KmipServer()",
            "        self.assertTrue(config_mock.called)",
            "        self.assertTrue(logging_mock.called)",
            "",
            "        self.assertIsInstance(s.auth_suite, auth.BasicAuthenticationSuite)",
            "        self.assertEqual(1, s._session_id)",
            "        self.assertFalse(s._is_serving)",
            "",
            "    @mock.patch('logging.getLogger', side_effect=mock.MagicMock())",
            "    @mock.patch('logging.handlers.RotatingFileHandler')",
            "    @mock.patch('kmip.services.server.server.KmipServer._setup_configuration')",
            "    @mock.patch('os.path.exists')",
            "    @mock.patch('os.path.isdir')",
            "    @mock.patch('os.makedirs')",
            "    def test_setup_logging(",
            "            self,",
            "            makedirs_mock,",
            "            isdir_mock,",
            "            path_mock,",
            "            config_mock,",
            "            handler_mock,",
            "            logging_mock):",
            "        \"\"\"",
            "        Verify that the server logger is setup correctly.",
            "        \"\"\"",
            "        path_mock.return_value = False",
            "        isdir_mock.return_value = False",
            "        open_mock = mock.mock_open()",
            "",
            "        # Dynamically mock out the built-in open function. Approach changes",
            "        # across Python versions.",
            "        try:",
            "            # For Python3+",
            "            import builtins  # NOQA",
            "            module = 'builtins'",
            "        except ImportError:",
            "            # For Python2+",
            "            module = '__builtin__'",
            "",
            "        with mock.patch('{0}.open'.format(module), open_mock):",
            "            s = server.KmipServer(log_path='/test/path/server.log')",
            "",
            "        path_mock.assert_called_once_with('/test/path/server.log')",
            "        isdir_mock.assert_called_once_with('/test/path')",
            "        makedirs_mock.assert_called_once_with('/test/path')",
            "        open_mock.assert_called_once_with('/test/path/server.log', 'w')",
            "",
            "        self.assertTrue(s._logger.addHandler.called)",
            "        s._logger.setLevel.assert_any_call(logging.DEBUG)",
            "",
            "    @mock.patch('kmip.services.server.engine.KmipEngine')",
            "    @mock.patch('kmip.services.auth.TLS12AuthenticationSuite')",
            "    @mock.patch('kmip.services.server.server.KmipServer._setup_logging')",
            "    def test_setup_configuration(self, logging_mock, auth_mock, engine_mock):",
            "        \"\"\"",
            "        Test that the server setup configuration works without error.",
            "        \"\"\"",
            "        s = server.KmipServer(",
            "            config_path=None,",
            "            policy_path=None",
            "        )",
            "        s.config = mock.MagicMock()",
            "",
            "        # Test the right calls are made when reinvoking config setup",
            "        s._setup_configuration(",
            "            '/etc/pykmip/server.conf',",
            "            '127.0.0.1',",
            "            5696,",
            "            '/etc/pykmip/certs/server.crt',",
            "            '/etc/pykmip/certs/server.key',",
            "            '/etc/pykmip/certs/ca.crt',",
            "            'Basic',",
            "            '/etc/pykmip/policies',",
            "            False,",
            "            'TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA',",
            "            'DEBUG',",
            "            '/var/pykmip/pykmip.db'",
            "        )",
            "",
            "        s.config.load_settings.assert_called_with('/etc/pykmip/server.conf')",
            "        s.config.set_setting.assert_any_call('hostname', '127.0.0.1')",
            "        s.config.set_setting.assert_any_call('port', 5696)",
            "        s.config.set_setting.assert_any_call(",
            "            'certificate_path',",
            "            '/etc/pykmip/certs/server.crt'",
            "        )",
            "        s.config.set_setting.assert_any_call(",
            "            'key_path',",
            "            '/etc/pykmip/certs/server.key'",
            "        )",
            "        s.config.set_setting.assert_any_call(",
            "            'ca_path',",
            "            '/etc/pykmip/certs/ca.crt'",
            "        )",
            "        s.config.set_setting.assert_any_call('auth_suite', 'Basic')",
            "        s.config.set_setting.assert_any_call(",
            "            'policy_path',",
            "            '/etc/pykmip/policies'",
            "        )",
            "        s.config.set_setting.assert_any_call(",
            "            'enable_tls_client_auth',",
            "            False",
            "        )",
            "        s.config.set_setting.assert_any_call(",
            "            'tls_cipher_suites',",
            "            [",
            "                'TLS_RSA_WITH_AES_128_CBC_SHA',",
            "                'TLS_RSA_WITH_AES_256_CBC_SHA'",
            "            ]",
            "        )",
            "        s.config.set_setting.assert_any_call('logging_level', 'DEBUG')",
            "        s.config.set_setting.assert_any_call(",
            "            'database_path',",
            "            '/var/pykmip/pykmip.db'",
            "        )",
            "",
            "        # Test that an attempt is made to instantiate the TLS 1.2 auth suite",
            "        s = server.KmipServer(",
            "            auth_suite='TLS1.2',",
            "            config_path=None,",
            "            policy_path=None",
            "        )",
            "        self.assertEqual('TLS1.2', s.config.settings.get('auth_suite'))",
            "        self.assertIsNotNone(s.auth_suite)",
            "",
            "    @mock.patch('multiprocessing.Manager')",
            "    @mock.patch('kmip.services.server.monitor.PolicyDirectoryMonitor')",
            "    @mock.patch('kmip.services.server.engine.KmipEngine')",
            "    @mock.patch('kmip.services.server.server.KmipServer._setup_logging')",
            "    def test_start(self,",
            "                   logging_mock,",
            "                   engine_mock,",
            "                   monitor_mock,",
            "                   manager_mock):",
            "        \"\"\"",
            "        Test that starting the KmipServer either runs as expected or generates",
            "        the expected error.",
            "        \"\"\"",
            "        monitor_instance_mock = mock.MagicMock()",
            "        monitor_mock.return_value = monitor_instance_mock",
            "",
            "        dict_mock = mock.MagicMock()",
            "        manager_instance_mock = mock.MagicMock()",
            "        manager_instance_mock.dict.return_value = dict_mock",
            "        manager_mock.return_value = manager_instance_mock",
            "",
            "        a_mock = mock.MagicMock()",
            "        b_mock = mock.MagicMock()",
            "",
            "        s = server.KmipServer(",
            "            hostname='127.0.0.1',",
            "            port=5696,",
            "            auth_suite='Basic',",
            "            config_path=None,",
            "            policy_path=None,",
            "            tls_cipher_suites='TLS_RSA_WITH_AES_128_CBC_SHA'",
            "        )",
            "        s._logger = mock.MagicMock()",
            "",
            "        self.assertFalse(s._is_serving)",
            "",
            "        # Test that in ideal cases no errors are generated and the right",
            "        # log messages are.",
            "        with mock.patch('socket.socket') as socket_mock:",
            "            with mock.patch('ssl.wrap_socket') as ssl_mock:",
            "                socket_mock.return_value = a_mock",
            "                ssl_mock.return_value = b_mock",
            "",
            "                manager_mock.assert_not_called()",
            "                monitor_mock.assert_not_called()",
            "",
            "                s.start()",
            "",
            "                manager_mock.assert_called_once_with()",
            "                monitor_mock.assert_called_once_with(",
            "                    None,",
            "                    dict_mock,",
            "                    False",
            "                )",
            "                self.assertIsNotNone(s._engine)",
            "                s._logger.info.assert_any_call(",
            "                    \"Starting server socket handler.\"",
            "                )",
            "                s._logger.debug.assert_any_call(\"Configured cipher suites: 1\")",
            "                s._logger.debug.assert_any_call(\"TLS_RSA_WITH_AES_128_CBC_SHA\")",
            "                s._logger.debug.assert_any_call(",
            "                    \"Authentication suite ciphers to use: 1\"",
            "                )",
            "                s._logger.debug.assert_any_call(\"AES128-SHA\")",
            "",
            "                socket_mock.assert_called_once_with(",
            "                    socket.AF_INET,",
            "                    socket.SOCK_STREAM",
            "                )",
            "                a_mock.setsockopt.assert_called_once_with(",
            "                    socket.SOL_SOCKET,",
            "                    socket.SO_REUSEADDR,",
            "                    1",
            "                )",
            "                self.assertTrue(ssl_mock.called)",
            "                b_mock.bind.assert_called_once_with(('127.0.0.1', 5696))",
            "                s._logger.info.assert_called_with(",
            "                    \"Server successfully bound socket handler to \"",
            "                    \"127.0.0.1:5696\"",
            "                )",
            "",
            "        monitor_instance_mock.stop.assert_not_called()",
            "        handler = signal.getsignal(signal.SIGINT)",
            "        handler(None, None)",
            "        monitor_instance_mock.stop.assert_called_once_with()",
            "        monitor_instance_mock.stop.reset_mock()",
            "        monitor_instance_mock.stop.assert_not_called()",
            "        handler = signal.getsignal(signal.SIGTERM)",
            "        handler(None, None)",
            "        monitor_instance_mock.stop.assert_called_once_with()",
            "",
            "        self.assertTrue(s._is_serving)",
            "",
            "        manager_mock.reset_mock()",
            "        monitor_mock.reset_mock()",
            "        a_mock.reset_mock()",
            "        b_mock.reset_mock()",
            "",
            "        # Test that a NetworkingError is generated if the socket bind fails.",
            "        with mock.patch('socket.socket') as socket_mock:",
            "            with mock.patch('ssl.wrap_socket') as ssl_mock:",
            "                socket_mock.return_value = a_mock",
            "                ssl_mock.return_value = b_mock",
            "",
            "                test_exception = Exception()",
            "                b_mock.bind.side_effect = test_exception",
            "",
            "                manager_mock.assert_not_called()",
            "                monitor_mock.assert_not_called()",
            "",
            "                regex = (",
            "                    \"Server failed to bind socket handler to 127.0.0.1:5696\"",
            "                )",
            "                self.assertRaisesRegexp(",
            "                    exceptions.NetworkingError,",
            "                    regex,",
            "                    s.start",
            "                )",
            "",
            "                manager_mock.assert_called_once_with()",
            "                monitor_mock.assert_called_once_with(",
            "                    None,",
            "                    dict_mock,",
            "                    False",
            "                )",
            "                s._logger.info.assert_any_call(",
            "                    \"Starting server socket handler.\"",
            "                )",
            "                s._logger.exception.assert_called_once_with(test_exception)",
            "",
            "    @mock.patch('kmip.services.server.engine.KmipEngine')",
            "    @mock.patch('kmip.services.server.server.KmipServer._setup_logging')",
            "    def test_stop(self, logging_mock, engine_mock):",
            "        \"\"\"",
            "        Test that the right calls and log messages are triggered while",
            "        cleaning up the server and any remaining sessions.",
            "        \"\"\"",
            "        s = server.KmipServer(",
            "            hostname='127.0.0.1',",
            "            port=5696,",
            "            config_path=None,",
            "            policy_path=None",
            "        )",
            "        s._logger = mock.MagicMock()",
            "        s._socket = mock.MagicMock()",
            "",
            "        # Test the expected behavior for a normal server stop sequence",
            "        thread_mock = mock.MagicMock()",
            "        thread_mock.join = mock.MagicMock()",
            "        thread_mock.is_alive = mock.MagicMock(return_value=False)",
            "        thread_mock.name = 'TestThread'",
            "",
            "        with mock.patch('threading.enumerate') as threading_mock:",
            "            threading_mock.return_value = [thread_mock]",
            "",
            "            s.stop()",
            "            s._logger.info.assert_any_call(",
            "                \"Cleaning up remaining connection threads.\"",
            "            )",
            "            self.assertTrue(threading_mock.called)",
            "            thread_mock.join.assert_called_once_with(10.0)",
            "            s._logger.info.assert_any_call(",
            "                \"Cleanup succeeded for thread: TestThread\"",
            "            )",
            "            s._logger.info.assert_any_call(",
            "                \"Shutting down server socket handler.\"",
            "            )",
            "            s._socket.shutdown.assert_called_once_with(socket.SHUT_RDWR)",
            "            s._socket.close.assert_called_once_with()",
            "",
            "        # Test the expected behavior when stopping multiple server session",
            "        # threads goes wrong",
            "        thread_mock.reset_mock()",
            "        test_exception = Exception()",
            "        thread_mock.join = mock.MagicMock(side_effect=test_exception)",
            "",
            "        s._logger.reset_mock()",
            "        s._socket.reset_mock()",
            "",
            "        with mock.patch('threading.enumerate') as threading_mock:",
            "            threading_mock.return_value = [thread_mock]",
            "",
            "            s.stop()",
            "            s._logger.info.assert_any_call(",
            "                \"Cleaning up remaining connection threads.\"",
            "            )",
            "            self.assertTrue(threading_mock.called)",
            "            thread_mock.join.assert_called_once_with(10.0)",
            "            s._logger.info.assert_any_call(",
            "                \"Error occurred while attempting to cleanup thread: TestThread\"",
            "            )",
            "            s._logger.exception.assert_called_once_with(test_exception)",
            "            s._logger.info.assert_any_call(",
            "                \"Shutting down server socket handler.\"",
            "            )",
            "            s._socket.shutdown.assert_called_once_with(socket.SHUT_RDWR)",
            "            s._socket.close.assert_called_once_with()",
            "",
            "        thread_mock.reset_mock()",
            "        test_exception = Exception()",
            "        thread_mock.join = mock.MagicMock()",
            "        thread_mock.is_alive = mock.MagicMock(return_value=True)",
            "",
            "        s._logger.reset_mock()",
            "        s._socket.reset_mock()",
            "",
            "        with mock.patch('threading.enumerate') as threading_mock:",
            "            threading_mock.return_value = [thread_mock]",
            "",
            "            s.stop()",
            "            s._logger.info.assert_any_call(",
            "                \"Cleaning up remaining connection threads.\"",
            "            )",
            "            self.assertTrue(threading_mock.called)",
            "            thread_mock.join.assert_called_once_with(10.0)",
            "            s._logger.warning.assert_any_call(",
            "                \"Cleanup failed for thread: TestThread. Thread is still alive\"",
            "            )",
            "            s._logger.info.assert_any_call(",
            "                \"Shutting down server socket handler.\"",
            "            )",
            "            s._socket.shutdown.assert_called_once_with(socket.SHUT_RDWR)",
            "            s._socket.close.assert_called_once_with()",
            "",
            "        # Test that the right errors and log messages are generated when",
            "        # stopping the server goes wrong",
            "        s._logger.reset_mock()",
            "        s._socket.reset_mock()",
            "",
            "        test_exception = Exception()",
            "        s._socket.close = mock.MagicMock(side_effect=test_exception)",
            "",
            "        regex = \"Server failed to shutdown socket handler.\"",
            "        self.assertRaisesRegexp(",
            "            exceptions.NetworkingError,",
            "            regex,",
            "            s.stop",
            "        )",
            "        s._logger.info.assert_any_call(",
            "            \"Cleaning up remaining connection threads.\"",
            "        )",
            "        s._logger.info.assert_any_call(",
            "            \"Shutting down server socket handler.\"",
            "        )",
            "        s._socket.shutdown.assert_called_once_with(socket.SHUT_RDWR)",
            "        s._socket.close.assert_called_once_with()",
            "        s._logger.exception(test_exception)",
            "",
            "    @mock.patch('kmip.services.server.engine.KmipEngine')",
            "    @mock.patch('kmip.services.server.server.KmipServer._setup_logging')",
            "    def test_stop_with_monitor_shutdown_error(self, logging_mock, engine_mock):",
            "        \"\"\"",
            "        Test that the right calls and log messages are triggered when stopping",
            "        the server results in an error while shutting down the policy monitor.",
            "        \"\"\"",
            "        s = server.KmipServer(",
            "            hostname='127.0.0.1',",
            "            port=5696,",
            "            config_path=None,",
            "            policy_path=None",
            "        )",
            "        s._logger = mock.MagicMock()",
            "        s._socket = mock.MagicMock()",
            "        s.policy_monitor = mock.MagicMock()",
            "        test_exception = Exception()",
            "        s.policy_monitor.join.side_effect = test_exception",
            "",
            "        # Test the expected behavior for a normal server stop sequence",
            "        thread_mock = mock.MagicMock()",
            "        thread_mock.join = mock.MagicMock()",
            "        thread_mock.is_alive = mock.MagicMock(return_value=False)",
            "        thread_mock.name = 'TestThread'",
            "",
            "        regex = \"Server failed to clean up the policy monitor.\"",
            "        self.assertRaisesRegexp(",
            "            exceptions.ShutdownError,",
            "            regex,",
            "            s.stop",
            "        )",
            "        s._logger.info.assert_any_call(",
            "            \"Cleaning up remaining connection threads.\"",
            "        )",
            "        s._logger.info.assert_any_call(",
            "            \"Shutting down server socket handler.\"",
            "        )",
            "        s._socket.shutdown.assert_called_once_with(socket.SHUT_RDWR)",
            "        s._socket.close.assert_called_once_with()",
            "",
            "        s.policy_monitor.stop.assert_called_once_with()",
            "        s.policy_monitor.join.assert_called_once_with()",
            "        s._logger.exception(test_exception)",
            "",
            "    @mock.patch('kmip.services.server.engine.KmipEngine')",
            "    @mock.patch('kmip.services.server.server.KmipServer._setup_logging')",
            "    def test_serve(self, logging_mock, engine_mock):",
            "        \"\"\"",
            "        Test that the right calls and log messages are triggered while",
            "        serving connections.",
            "        \"\"\"",
            "        s = server.KmipServer(",
            "            hostname='127.0.0.1',",
            "            port=5696,",
            "            config_path=None,",
            "            policy_path=None",
            "        )",
            "        s._is_serving = True",
            "        s._logger = mock.MagicMock()",
            "        s._socket = mock.MagicMock()",
            "        s._setup_connection_handler = mock.MagicMock()",
            "",
            "        expected_error = KeyboardInterrupt",
            "",
            "        # Test the expected behavior for a normal server/interrupt sequence",
            "        s._socket.accept = mock.MagicMock(",
            "            side_effect=[",
            "                ('connection', 'address'),",
            "                socket.timeout,",
            "                expected_error",
            "            ]",
            "        )",
            "",
            "        s.serve()",
            "        s._socket.listen.assert_called_once_with(5)",
            "        s._socket.accept.assert_any_call()",
            "        s._setup_connection_handler.assert_called_once_with(",
            "            'connection',",
            "            'address'",
            "        )",
            "        s._logger.warning.assert_called_with(",
            "            \"Interrupting connection service.\"",
            "        )",
            "        s._logger.info.assert_called_with(\"Stopping connection service.\")",
            "",
            "        # Test the behavior for an unexpected socket error.",
            "        unexpected_error = socket.error()",
            "        s._is_serving = True",
            "        s._logger.reset_mock()",
            "        s._socket.accept = mock.MagicMock(",
            "            side_effect=[unexpected_error, expected_error]",
            "        )",
            "",
            "        s.serve()",
            "        s._socket.accept.assert_any_call()",
            "        s._logger.warning.assert_any_call(",
            "            \"Error detected while establishing new connection.\"",
            "        )",
            "        s._logger.exception.assert_called_with(unexpected_error)",
            "        s._logger.info.assert_called_with(\"Stopping connection service.\")",
            "",
            "        # Test the behavior for an unexpected error.",
            "        unexpected_error = Exception()",
            "        s._is_serving = True",
            "        s._logger.reset_mock()",
            "        s._socket.accept = mock.MagicMock(",
            "            side_effect=[unexpected_error, expected_error]",
            "        )",
            "",
            "        s.serve()",
            "        s._socket.accept.assert_any_call()",
            "        s._logger.warning.assert_any_call(",
            "            \"Error detected while establishing new connection.\"",
            "        )",
            "        s._logger.exception.assert_called_with(unexpected_error)",
            "        s._logger.info.assert_called_with(\"Stopping connection service.\")",
            "",
            "        # Test the signal handler for each expected signal",
            "        s._is_serving = True",
            "        handler = signal.getsignal(signal.SIGINT)",
            "        args = (signal.SIGINT, None)",
            "        self.assertRaisesRegex(",
            "            KeyboardInterrupt,",
            "            \"SIGINT received\",",
            "            handler,",
            "            *args",
            "        )",
            "        self.assertFalse(s._is_serving)",
            "",
            "        s._is_serving = True",
            "        handler = signal.getsignal(signal.SIGTERM)",
            "        handler(None, None)",
            "        self.assertFalse(s._is_serving)",
            "",
            "    @mock.patch('kmip.services.server.engine.KmipEngine')",
            "    @mock.patch('kmip.services.server.server.KmipServer._setup_logging')",
            "    def test_setup_connection_handler(self, logging_mock, engine_mock):",
            "        \"\"\"",
            "        Test that a KmipSession can be successfully created and spun off from",
            "        the KmipServer.",
            "        \"\"\"",
            "        s = server.KmipServer(",
            "            hostname='127.0.0.1',",
            "            port=5696,",
            "            config_path=None,",
            "            policy_path=None",
            "        )",
            "        s._logger = mock.MagicMock()",
            "        s._engine = engine_mock",
            "",
            "        # Test that the right calls and log messages are made when",
            "        # starting a new session.",
            "        with mock.patch(",
            "            'kmip.services.server.session.KmipSession.start'",
            "        ) as session_mock:",
            "            address = ('127.0.0.1', 5696)",
            "            s._setup_connection_handler(None, address)",
            "",
            "            s._logger.info.assert_any_call(",
            "                \"Receiving incoming connection from: 127.0.0.1:5696\"",
            "            )",
            "            s._logger.info.assert_any_call(",
            "                \"Dedicating session 00000001 to 127.0.0.1:5696\"",
            "            )",
            "            session_mock.assert_called_once_with()",
            "",
            "        self.assertEqual(2, s._session_id)",
            "",
            "        # Test that the right error messages are logged when the session",
            "        # fails to start.",
            "        test_exception = Exception()",
            "        with mock.patch(",
            "            'kmip.services.server.session.KmipSession.start',",
            "            side_effect=test_exception",
            "        ) as session_mock:",
            "            address = ('127.0.0.1', 5696)",
            "            s._setup_connection_handler(None, address)",
            "",
            "            s._logger.info.assert_any_call(",
            "                \"Receiving incoming connection from: 127.0.0.1:5696\"",
            "            )",
            "            s._logger.info.assert_any_call(",
            "                \"Dedicating session 00000001 to 127.0.0.1:5696\"",
            "            )",
            "            session_mock.assert_called_once_with()",
            "            s._logger.warning.assert_called_once_with(",
            "                \"Failure occurred while starting session: 00000002\"",
            "            )",
            "            s._logger.exception.assert_called_once_with(test_exception)",
            "",
            "        self.assertEqual(3, s._session_id)",
            "",
            "    @mock.patch('kmip.services.server.engine.KmipEngine')",
            "    @mock.patch('kmip.services.server.server.KmipServer._setup_logging')",
            "    def test_as_context_manager(self, logging_mock, engine_mock):",
            "        \"\"\"",
            "        Test that the right methods are called when the KmipServer is used",
            "        as a context manager.",
            "        \"\"\"",
            "        s = server.KmipServer(",
            "            hostname='127.0.0.1',",
            "            port=5696,",
            "            config_path=None,",
            "            policy_path=None",
            "        )",
            "        s._logger = mock.MagicMock()",
            "        s.start = mock.MagicMock()",
            "        s.stop = mock.MagicMock()",
            "",
            "        with s:",
            "            pass",
            "",
            "        self.assertTrue(s.start.called)",
            "        self.assertTrue(s.stop.called)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "488": [
                "TestKmipServer",
                "test_serve"
            ]
        },
        "addLocation": []
    }
}