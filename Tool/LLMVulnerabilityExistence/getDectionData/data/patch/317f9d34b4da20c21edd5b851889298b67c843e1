{
    "keystone/contrib/revoke/model.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 285,
                "afterPatchRowNumber": 285,
                "PatchRowcode": "         token_values['assignment_domain_id'] = project['domain']['id']"
            },
            "1": {
                "beforePatchRowNumber": 286,
                "afterPatchRowNumber": 286,
                "PatchRowcode": "     else:"
            },
            "2": {
                "beforePatchRowNumber": 287,
                "afterPatchRowNumber": 287,
                "PatchRowcode": "         token_values['project_id'] = None"
            },
            "3": {
                "beforePatchRowNumber": 288,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        token_values['assignment_domain_id'] = None"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 288,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 289,
                "PatchRowcode": "+        domain = token_data.get('domain')"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 290,
                "PatchRowcode": "+        if domain is not None:"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 291,
                "PatchRowcode": "+            token_values['assignment_domain_id'] = domain['id']"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 292,
                "PatchRowcode": "+        else:"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 293,
                "PatchRowcode": "+            token_values['assignment_domain_id'] = None"
            },
            "10": {
                "beforePatchRowNumber": 289,
                "afterPatchRowNumber": 294,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 290,
                "afterPatchRowNumber": 295,
                "PatchRowcode": "     role_list = []"
            },
            "12": {
                "beforePatchRowNumber": 291,
                "afterPatchRowNumber": 296,
                "PatchRowcode": "     roles = token_data.get('roles')"
            }
        },
        "frontPatchFile": [
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "from keystone.openstack.common import timeutils",
            "",
            "# The set of attributes common between the RevokeEvent",
            "# and the dictionaries created from the token Data.",
            "_NAMES = ['trust_id',",
            "          'consumer_id',",
            "          'access_token_id',",
            "          'expires_at',",
            "          'domain_id',",
            "          'project_id',",
            "          'user_id',",
            "          'role_id']",
            "",
            "",
            "# Additional arguments for creating a RevokeEvent",
            "_EVENT_ARGS = ['issued_before', 'revoked_at']",
            "",
            "# Values that will be in the token data but not in the event.",
            "# These will compared with event values that have different names.",
            "# For example: both trustor_id and trustee_id are compared against user_id",
            "_TOKEN_KEYS = ['identity_domain_id',",
            "               'assignment_domain_id',",
            "               'issued_at',",
            "               'trustor_id',",
            "               'trustee_id']",
            "",
            "",
            "REVOKE_KEYS = _NAMES + _EVENT_ARGS",
            "",
            "",
            "def blank_token_data(issued_at):",
            "    token_data = dict()",
            "    for name in _NAMES:",
            "        token_data[name] = None",
            "    for name in _TOKEN_KEYS:",
            "        token_data[name] = None",
            "    # required field",
            "    token_data['issued_at'] = issued_at",
            "    return token_data",
            "",
            "",
            "class RevokeEvent(object):",
            "    def __init__(self, **kwargs):",
            "        for k in REVOKE_KEYS:",
            "            v = kwargs.get(k, None)",
            "            setattr(self, k, v)",
            "        if self.revoked_at is None:",
            "            self.revoked_at = timeutils.utcnow()",
            "        if self.issued_before is None:",
            "            self.issued_before = self.revoked_at",
            "",
            "    def to_dict(self):",
            "        keys = ['user_id',",
            "                'role_id',",
            "                'domain_id',",
            "                'project_id']",
            "        event = dict((key, self.__dict__[key]) for key in keys",
            "                     if self.__dict__[key] is not None)",
            "        if self.trust_id is not None:",
            "            event['OS-TRUST:trust_id'] = self.trust_id",
            "        if self.consumer_id is not None:",
            "            event['OS-OAUTH1:consumer_id'] = self.consumer_id",
            "        if self.consumer_id is not None:",
            "            event['OS-OAUTH1:access_token_id'] = self.access_token_id",
            "        if self.expires_at is not None:",
            "            event['expires_at'] = timeutils.isotime(self.expires_at,",
            "                                                    subsecond=True)",
            "        if self.issued_before is not None:",
            "            event['issued_before'] = timeutils.isotime(self.issued_before,",
            "                                                       subsecond=True)",
            "        return event",
            "",
            "    def key_for_name(self, name):",
            "        return \"%s=%s\" % (name, getattr(self, name) or '*')",
            "",
            "",
            "def attr_keys(event):",
            "    return map(event.key_for_name, _NAMES)",
            "",
            "",
            "class RevokeTree(object):",
            "    \"\"\"Fast Revocation Checking Tree Structure",
            "",
            "    The Tree is an index to quickly match tokens against events.",
            "    Each node is a hashtable of key=value combinations from revocation events.",
            "    The",
            "",
            "    \"\"\"",
            "",
            "    def __init__(self, revoke_events=None):",
            "        self.revoke_map = dict()",
            "        self.add_events(revoke_events)",
            "",
            "    def add_event(self, event):",
            "        \"\"\"Updates the tree based on a revocation event.",
            "",
            "        Creates any necessary internal nodes in the tree corresponding to the",
            "        fields of the revocation event.  The leaf node will always be set to",
            "        the latest 'issued_before' for events that are otherwise identical.",
            "",
            "        :param:  Event to add to the tree",
            "",
            "        :returns:  the event that was passed in.",
            "",
            "        \"\"\"",
            "        revoke_map = self.revoke_map",
            "        for key in attr_keys(event):",
            "            revoke_map = revoke_map.setdefault(key, {})",
            "        revoke_map['issued_before'] = max(",
            "            event.issued_before, revoke_map.get(",
            "                'issued_before', event.issued_before))",
            "        return event",
            "",
            "    def remove_event(self, event):",
            "        \"\"\"Update the tree based on the removal of a Revocation Event",
            "",
            "        Removes empty nodes from the tree from the leaf back to the root.",
            "",
            "        If multiple events trace the same path, but have different",
            "        'issued_before' values, only the last is ever stored in the tree.",
            "        So only an exact match on 'issued_before' ever triggers a removal",
            "",
            "        :param: Event to remove from the tree",
            "",
            "        \"\"\"",
            "        stack = []",
            "        revoke_map = self.revoke_map",
            "        for name in _NAMES:",
            "            key = event.key_for_name(name)",
            "            nxt = revoke_map.get(key)",
            "            if nxt is None:",
            "                break",
            "            stack.append((revoke_map, key, nxt))",
            "            revoke_map = nxt",
            "        else:",
            "            if event.issued_before == revoke_map['issued_before']:",
            "                revoke_map.pop('issued_before')",
            "        for parent, key, child in reversed(stack):",
            "            if not any(child):",
            "                del parent[key]",
            "",
            "    def add_events(self, revoke_events):",
            "        return map(self.add_event, revoke_events or [])",
            "",
            "    def is_revoked(self, token_data):",
            "        \"\"\"Check if a token matches the revocation event",
            "",
            "        Compare the values for each level of the tree with the values from",
            "        the token, accounting for attributes that have alternative",
            "        keys, and for wildcard matches.",
            "        if there is a match, continue down the tree.",
            "        if there is no match, exit early.",
            "",
            "        token_data is a map based on a flattened view of token.",
            "        The required fields are:",
            "",
            "           'expires_at','user_id', 'project_id', 'identity_domain_id',",
            "           'assignment_domain_id', 'trust_id', 'trustor_id', 'trustee_id'",
            "           'consumer_id', 'access_token_id'",
            "",
            "        \"\"\"",
            "        # Alternative names to be checked in token for every field in",
            "        # revoke tree.",
            "        alternatives = {",
            "            'user_id': ['user_id', 'trustor_id', 'trustee_id'],",
            "            'domain_id': ['identity_domain_id', 'assignment_domain_id'],",
            "        }",
            "        # Contains current forest (collection of trees) to be checked.",
            "        partial_matches = [self.revoke_map]",
            "        # We iterate over every layer of our revoke tree (except the last one).",
            "        for name in _NAMES:",
            "            # bundle is the set of partial matches for the next level down",
            "            # the tree",
            "            bundle = []",
            "            wildcard = '%s=*' % (name,)",
            "            # For every tree in current forest.",
            "            for tree in partial_matches:",
            "                # If there is wildcard node on current level we take it.",
            "                bundle.append(tree.get(wildcard))",
            "                if name == 'role_id':",
            "                    # Roles are very special since a token has a list of them.",
            "                    # If the revocation event matches any one of them,",
            "                    # revoke the token.",
            "                    for role_id in token_data.get('roles', []):",
            "                        bundle.append(tree.get('role_id=%s' % role_id))",
            "                else:",
            "                    # For other fields we try to get any branch that concur",
            "                    # with any alternative field in the token.",
            "                    for alt_name in alternatives.get(name, [name]):",
            "                        bundle.append(",
            "                            tree.get('%s=%s' % (name, token_data[alt_name])))",
            "            # tree.get returns `None` if there is no match, so `bundle.append`",
            "            # adds a 'None' entry. This call remoes the `None` entries.",
            "            partial_matches = [x for x in bundle if x is not None]",
            "            if not partial_matches:",
            "                # If we end up with no branches to follow means that the token",
            "                # is definitely not in the revoke tree and all further",
            "                # iterations will be for nothing.",
            "                return False",
            "",
            "        # The last (leaf) level is checked in a special way because we verify",
            "        # issued_at field differently.",
            "        for leaf in partial_matches:",
            "            try:",
            "                if leaf['issued_before'] > token_data['issued_at']:",
            "                    return True",
            "            except KeyError:",
            "                pass",
            "        # If we made it out of the loop then no element in revocation tree",
            "        # corresponds to our token and it is good.",
            "        return False",
            "",
            "",
            "def build_token_values_v2(access, default_domain_id):",
            "    token_data = access['token']",
            "    token_values = {",
            "        'expires_at': timeutils.normalize_time(",
            "            timeutils.parse_isotime(token_data['expires'])),",
            "        'issued_at': timeutils.normalize_time(",
            "            timeutils.parse_isotime(token_data['issued_at']))}",
            "",
            "    token_values['user_id'] = access.get('user', {}).get('id')",
            "",
            "    project = token_data.get('tenant')",
            "    if project is not None:",
            "        token_values['project_id'] = project['id']",
            "    else:",
            "        token_values['project_id'] = None",
            "",
            "    token_values['identity_domain_id'] = default_domain_id",
            "    token_values['assignment_domain_id'] = default_domain_id",
            "",
            "    trust = token_data.get('trust')",
            "    if trust is None:",
            "        token_values['trust_id'] = None",
            "        token_values['trustor_id'] = None",
            "        token_values['trustee_id'] = None",
            "    else:",
            "        token_values['trust_id'] = trust['id']",
            "        token_values['trustor_id'] = trust['trustor_id']",
            "        token_values['trustee_id'] = trust['trustee_id']",
            "",
            "    token_values['consumer_id'] = None",
            "    token_values['access_token_id'] = None",
            "",
            "    role_list = []",
            "    # Roles are by ID in metadata and by name in the user section",
            "    roles = access.get('metadata', {}).get('roles', [])",
            "    for role in roles:",
            "        role_list.append(role)",
            "    token_values['roles'] = role_list",
            "    return token_values",
            "",
            "",
            "def build_token_values(token_data):",
            "    token_values = {",
            "        'expires_at': timeutils.normalize_time(",
            "            timeutils.parse_isotime(token_data['expires_at'])),",
            "        'issued_at': timeutils.normalize_time(",
            "            timeutils.parse_isotime(token_data['issued_at']))}",
            "",
            "    user = token_data.get('user')",
            "    if user is not None:",
            "        token_values['user_id'] = user['id']",
            "        token_values['identity_domain_id'] = user['domain']['id']",
            "    else:",
            "        token_values['user_id'] = None",
            "        token_values['identity_domain_id'] = None",
            "",
            "    project = token_data.get('project', token_data.get('tenant'))",
            "    if project is not None:",
            "        token_values['project_id'] = project['id']",
            "        token_values['assignment_domain_id'] = project['domain']['id']",
            "    else:",
            "        token_values['project_id'] = None",
            "        token_values['assignment_domain_id'] = None",
            "",
            "    role_list = []",
            "    roles = token_data.get('roles')",
            "    if roles is not None:",
            "        for role in roles:",
            "            role_list.append(role['id'])",
            "    token_values['roles'] = role_list",
            "",
            "    trust = token_data.get('OS-TRUST:trust')",
            "    if trust is None:",
            "        token_values['trust_id'] = None",
            "        token_values['trustor_id'] = None",
            "        token_values['trustee_id'] = None",
            "    else:",
            "        token_values['trust_id'] = trust['id']",
            "        token_values['trustor_id'] = trust['trustor_user']['id']",
            "        token_values['trustee_id'] = trust['trustee_user']['id']",
            "",
            "    oauth1 = token_data.get('OS-OAUTH1')",
            "    if oauth1 is None:",
            "        token_values['consumer_id'] = None",
            "        token_values['access_token_id'] = None",
            "    else:",
            "        token_values['consumer_id'] = oauth1['consumer_id']",
            "        token_values['access_token_id'] = oauth1['access_token_id']",
            "    return token_values"
        ],
        "afterPatchFile": [
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "from keystone.openstack.common import timeutils",
            "",
            "# The set of attributes common between the RevokeEvent",
            "# and the dictionaries created from the token Data.",
            "_NAMES = ['trust_id',",
            "          'consumer_id',",
            "          'access_token_id',",
            "          'expires_at',",
            "          'domain_id',",
            "          'project_id',",
            "          'user_id',",
            "          'role_id']",
            "",
            "",
            "# Additional arguments for creating a RevokeEvent",
            "_EVENT_ARGS = ['issued_before', 'revoked_at']",
            "",
            "# Values that will be in the token data but not in the event.",
            "# These will compared with event values that have different names.",
            "# For example: both trustor_id and trustee_id are compared against user_id",
            "_TOKEN_KEYS = ['identity_domain_id',",
            "               'assignment_domain_id',",
            "               'issued_at',",
            "               'trustor_id',",
            "               'trustee_id']",
            "",
            "",
            "REVOKE_KEYS = _NAMES + _EVENT_ARGS",
            "",
            "",
            "def blank_token_data(issued_at):",
            "    token_data = dict()",
            "    for name in _NAMES:",
            "        token_data[name] = None",
            "    for name in _TOKEN_KEYS:",
            "        token_data[name] = None",
            "    # required field",
            "    token_data['issued_at'] = issued_at",
            "    return token_data",
            "",
            "",
            "class RevokeEvent(object):",
            "    def __init__(self, **kwargs):",
            "        for k in REVOKE_KEYS:",
            "            v = kwargs.get(k, None)",
            "            setattr(self, k, v)",
            "        if self.revoked_at is None:",
            "            self.revoked_at = timeutils.utcnow()",
            "        if self.issued_before is None:",
            "            self.issued_before = self.revoked_at",
            "",
            "    def to_dict(self):",
            "        keys = ['user_id',",
            "                'role_id',",
            "                'domain_id',",
            "                'project_id']",
            "        event = dict((key, self.__dict__[key]) for key in keys",
            "                     if self.__dict__[key] is not None)",
            "        if self.trust_id is not None:",
            "            event['OS-TRUST:trust_id'] = self.trust_id",
            "        if self.consumer_id is not None:",
            "            event['OS-OAUTH1:consumer_id'] = self.consumer_id",
            "        if self.consumer_id is not None:",
            "            event['OS-OAUTH1:access_token_id'] = self.access_token_id",
            "        if self.expires_at is not None:",
            "            event['expires_at'] = timeutils.isotime(self.expires_at,",
            "                                                    subsecond=True)",
            "        if self.issued_before is not None:",
            "            event['issued_before'] = timeutils.isotime(self.issued_before,",
            "                                                       subsecond=True)",
            "        return event",
            "",
            "    def key_for_name(self, name):",
            "        return \"%s=%s\" % (name, getattr(self, name) or '*')",
            "",
            "",
            "def attr_keys(event):",
            "    return map(event.key_for_name, _NAMES)",
            "",
            "",
            "class RevokeTree(object):",
            "    \"\"\"Fast Revocation Checking Tree Structure",
            "",
            "    The Tree is an index to quickly match tokens against events.",
            "    Each node is a hashtable of key=value combinations from revocation events.",
            "    The",
            "",
            "    \"\"\"",
            "",
            "    def __init__(self, revoke_events=None):",
            "        self.revoke_map = dict()",
            "        self.add_events(revoke_events)",
            "",
            "    def add_event(self, event):",
            "        \"\"\"Updates the tree based on a revocation event.",
            "",
            "        Creates any necessary internal nodes in the tree corresponding to the",
            "        fields of the revocation event.  The leaf node will always be set to",
            "        the latest 'issued_before' for events that are otherwise identical.",
            "",
            "        :param:  Event to add to the tree",
            "",
            "        :returns:  the event that was passed in.",
            "",
            "        \"\"\"",
            "        revoke_map = self.revoke_map",
            "        for key in attr_keys(event):",
            "            revoke_map = revoke_map.setdefault(key, {})",
            "        revoke_map['issued_before'] = max(",
            "            event.issued_before, revoke_map.get(",
            "                'issued_before', event.issued_before))",
            "        return event",
            "",
            "    def remove_event(self, event):",
            "        \"\"\"Update the tree based on the removal of a Revocation Event",
            "",
            "        Removes empty nodes from the tree from the leaf back to the root.",
            "",
            "        If multiple events trace the same path, but have different",
            "        'issued_before' values, only the last is ever stored in the tree.",
            "        So only an exact match on 'issued_before' ever triggers a removal",
            "",
            "        :param: Event to remove from the tree",
            "",
            "        \"\"\"",
            "        stack = []",
            "        revoke_map = self.revoke_map",
            "        for name in _NAMES:",
            "            key = event.key_for_name(name)",
            "            nxt = revoke_map.get(key)",
            "            if nxt is None:",
            "                break",
            "            stack.append((revoke_map, key, nxt))",
            "            revoke_map = nxt",
            "        else:",
            "            if event.issued_before == revoke_map['issued_before']:",
            "                revoke_map.pop('issued_before')",
            "        for parent, key, child in reversed(stack):",
            "            if not any(child):",
            "                del parent[key]",
            "",
            "    def add_events(self, revoke_events):",
            "        return map(self.add_event, revoke_events or [])",
            "",
            "    def is_revoked(self, token_data):",
            "        \"\"\"Check if a token matches the revocation event",
            "",
            "        Compare the values for each level of the tree with the values from",
            "        the token, accounting for attributes that have alternative",
            "        keys, and for wildcard matches.",
            "        if there is a match, continue down the tree.",
            "        if there is no match, exit early.",
            "",
            "        token_data is a map based on a flattened view of token.",
            "        The required fields are:",
            "",
            "           'expires_at','user_id', 'project_id', 'identity_domain_id',",
            "           'assignment_domain_id', 'trust_id', 'trustor_id', 'trustee_id'",
            "           'consumer_id', 'access_token_id'",
            "",
            "        \"\"\"",
            "        # Alternative names to be checked in token for every field in",
            "        # revoke tree.",
            "        alternatives = {",
            "            'user_id': ['user_id', 'trustor_id', 'trustee_id'],",
            "            'domain_id': ['identity_domain_id', 'assignment_domain_id'],",
            "        }",
            "        # Contains current forest (collection of trees) to be checked.",
            "        partial_matches = [self.revoke_map]",
            "        # We iterate over every layer of our revoke tree (except the last one).",
            "        for name in _NAMES:",
            "            # bundle is the set of partial matches for the next level down",
            "            # the tree",
            "            bundle = []",
            "            wildcard = '%s=*' % (name,)",
            "            # For every tree in current forest.",
            "            for tree in partial_matches:",
            "                # If there is wildcard node on current level we take it.",
            "                bundle.append(tree.get(wildcard))",
            "                if name == 'role_id':",
            "                    # Roles are very special since a token has a list of them.",
            "                    # If the revocation event matches any one of them,",
            "                    # revoke the token.",
            "                    for role_id in token_data.get('roles', []):",
            "                        bundle.append(tree.get('role_id=%s' % role_id))",
            "                else:",
            "                    # For other fields we try to get any branch that concur",
            "                    # with any alternative field in the token.",
            "                    for alt_name in alternatives.get(name, [name]):",
            "                        bundle.append(",
            "                            tree.get('%s=%s' % (name, token_data[alt_name])))",
            "            # tree.get returns `None` if there is no match, so `bundle.append`",
            "            # adds a 'None' entry. This call remoes the `None` entries.",
            "            partial_matches = [x for x in bundle if x is not None]",
            "            if not partial_matches:",
            "                # If we end up with no branches to follow means that the token",
            "                # is definitely not in the revoke tree and all further",
            "                # iterations will be for nothing.",
            "                return False",
            "",
            "        # The last (leaf) level is checked in a special way because we verify",
            "        # issued_at field differently.",
            "        for leaf in partial_matches:",
            "            try:",
            "                if leaf['issued_before'] > token_data['issued_at']:",
            "                    return True",
            "            except KeyError:",
            "                pass",
            "        # If we made it out of the loop then no element in revocation tree",
            "        # corresponds to our token and it is good.",
            "        return False",
            "",
            "",
            "def build_token_values_v2(access, default_domain_id):",
            "    token_data = access['token']",
            "    token_values = {",
            "        'expires_at': timeutils.normalize_time(",
            "            timeutils.parse_isotime(token_data['expires'])),",
            "        'issued_at': timeutils.normalize_time(",
            "            timeutils.parse_isotime(token_data['issued_at']))}",
            "",
            "    token_values['user_id'] = access.get('user', {}).get('id')",
            "",
            "    project = token_data.get('tenant')",
            "    if project is not None:",
            "        token_values['project_id'] = project['id']",
            "    else:",
            "        token_values['project_id'] = None",
            "",
            "    token_values['identity_domain_id'] = default_domain_id",
            "    token_values['assignment_domain_id'] = default_domain_id",
            "",
            "    trust = token_data.get('trust')",
            "    if trust is None:",
            "        token_values['trust_id'] = None",
            "        token_values['trustor_id'] = None",
            "        token_values['trustee_id'] = None",
            "    else:",
            "        token_values['trust_id'] = trust['id']",
            "        token_values['trustor_id'] = trust['trustor_id']",
            "        token_values['trustee_id'] = trust['trustee_id']",
            "",
            "    token_values['consumer_id'] = None",
            "    token_values['access_token_id'] = None",
            "",
            "    role_list = []",
            "    # Roles are by ID in metadata and by name in the user section",
            "    roles = access.get('metadata', {}).get('roles', [])",
            "    for role in roles:",
            "        role_list.append(role)",
            "    token_values['roles'] = role_list",
            "    return token_values",
            "",
            "",
            "def build_token_values(token_data):",
            "    token_values = {",
            "        'expires_at': timeutils.normalize_time(",
            "            timeutils.parse_isotime(token_data['expires_at'])),",
            "        'issued_at': timeutils.normalize_time(",
            "            timeutils.parse_isotime(token_data['issued_at']))}",
            "",
            "    user = token_data.get('user')",
            "    if user is not None:",
            "        token_values['user_id'] = user['id']",
            "        token_values['identity_domain_id'] = user['domain']['id']",
            "    else:",
            "        token_values['user_id'] = None",
            "        token_values['identity_domain_id'] = None",
            "",
            "    project = token_data.get('project', token_data.get('tenant'))",
            "    if project is not None:",
            "        token_values['project_id'] = project['id']",
            "        token_values['assignment_domain_id'] = project['domain']['id']",
            "    else:",
            "        token_values['project_id'] = None",
            "",
            "        domain = token_data.get('domain')",
            "        if domain is not None:",
            "            token_values['assignment_domain_id'] = domain['id']",
            "        else:",
            "            token_values['assignment_domain_id'] = None",
            "",
            "    role_list = []",
            "    roles = token_data.get('roles')",
            "    if roles is not None:",
            "        for role in roles:",
            "            role_list.append(role['id'])",
            "    token_values['roles'] = role_list",
            "",
            "    trust = token_data.get('OS-TRUST:trust')",
            "    if trust is None:",
            "        token_values['trust_id'] = None",
            "        token_values['trustor_id'] = None",
            "        token_values['trustee_id'] = None",
            "    else:",
            "        token_values['trust_id'] = trust['id']",
            "        token_values['trustor_id'] = trust['trustor_user']['id']",
            "        token_values['trustee_id'] = trust['trustee_user']['id']",
            "",
            "    oauth1 = token_data.get('OS-OAUTH1')",
            "    if oauth1 is None:",
            "        token_values['consumer_id'] = None",
            "        token_values['access_token_id'] = None",
            "    else:",
            "        token_values['consumer_id'] = oauth1['consumer_id']",
            "        token_values['access_token_id'] = oauth1['access_token_id']",
            "    return token_values"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "288": [
                "build_token_values"
            ]
        },
        "addLocation": []
    },
    "keystone/tests/test_revoke.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 448,
                "afterPatchRowNumber": 448,
                "PatchRowcode": "     def test_by_domain_domain(self):"
            },
            "1": {
                "beforePatchRowNumber": 449,
                "afterPatchRowNumber": 449,
                "PatchRowcode": "         # If revoke a domain, then a token scoped to the domain is revoked."
            },
            "2": {
                "beforePatchRowNumber": 450,
                "afterPatchRowNumber": 450,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 451,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # FIXME(blk-u): The token translation code doesn't handle domain-scoped"
            },
            "4": {
                "beforePatchRowNumber": 452,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # tokens at this point. See bug #1347318. Replace this with test code"
            },
            "5": {
                "beforePatchRowNumber": 453,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # similar to test_by_domain_project()."
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 451,
                "PatchRowcode": "+        user_id = _new_id()"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 452,
                "PatchRowcode": "+        user_domain_id = _new_id()"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 453,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 454,
                "PatchRowcode": "+        domain_id = _new_id()"
            },
            "10": {
                "beforePatchRowNumber": 454,
                "afterPatchRowNumber": 455,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 455,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        pass"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 456,
                "PatchRowcode": "+        token_data = _sample_blank_token()"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 457,
                "PatchRowcode": "+        token_data['user_id'] = user_id"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 458,
                "PatchRowcode": "+        token_data['identity_domain_id'] = user_domain_id"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 459,
                "PatchRowcode": "+        token_data['assignment_domain_id'] = domain_id"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 460,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 461,
                "PatchRowcode": "+        self._revoke_by_domain(domain_id)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 462,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 463,
                "PatchRowcode": "+        self._assertTokenRevoked(token_data)"
            },
            "20": {
                "beforePatchRowNumber": 456,
                "afterPatchRowNumber": 464,
                "PatchRowcode": " "
            },
            "21": {
                "beforePatchRowNumber": 457,
                "afterPatchRowNumber": 465,
                "PatchRowcode": "     def _assertEmpty(self, collection):"
            },
            "22": {
                "beforePatchRowNumber": 458,
                "afterPatchRowNumber": 466,
                "PatchRowcode": "         return self.assertEqual(0, len(collection), \"collection not empty\")"
            }
        },
        "frontPatchFile": [
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "",
            "import datetime",
            "import uuid",
            "",
            "import mock",
            "",
            "from keystone.common import dependency",
            "from keystone import config",
            "from keystone.contrib.revoke import model",
            "from keystone import exception",
            "from keystone.openstack.common import timeutils",
            "from keystone import tests",
            "from keystone.tests import test_backend_sql",
            "",
            "",
            "CONF = config.CONF",
            "",
            "",
            "def _new_id():",
            "    return uuid.uuid4().hex",
            "",
            "",
            "def _future_time():",
            "    expire_delta = datetime.timedelta(seconds=1000)",
            "    future_time = timeutils.utcnow() + expire_delta",
            "    return future_time",
            "",
            "",
            "def _past_time():",
            "    expire_delta = datetime.timedelta(days=-1000)",
            "    past_time = timeutils.utcnow() + expire_delta",
            "    return past_time",
            "",
            "",
            "def _sample_blank_token():",
            "    issued_delta = datetime.timedelta(minutes=-2)",
            "    issued_at = timeutils.utcnow() + issued_delta",
            "    token_data = model.blank_token_data(issued_at)",
            "    return token_data",
            "",
            "",
            "def _matches(event, token_values):",
            "    \"\"\"See if the token matches the revocation event.",
            "",
            "    Used as a secondary check on the logic to Check",
            "    By Tree Below:  This is abrute force approach to checking.",
            "    Compare each attribute from the event with the corresponding",
            "    value from the token.  If the event does not have a value for",
            "    the attribute, a match is still possible.  If the event has a",
            "    value for the attribute, and it does not match the token, no match",
            "    is possible, so skip the remaining checks.",
            "",
            "    :param event one revocation event to match",
            "    :param token_values dictionary with set of values taken from the",
            "    token",
            "    :returns if the token matches the revocation event, indicating the",
            "    token has been revoked",
            "    \"\"\"",
            "",
            "    # The token has three attributes that can match the user_id",
            "    if event.user_id is not None:",
            "        for attribute_name in ['user_id', 'trustor_id', 'trustee_id']:",
            "            if event.user_id == token_values[attribute_name]:",
            "                break",
            "        else:",
            "            return False",
            "",
            "    # The token has two attributes that can match the domain_id",
            "    if event.domain_id is not None:",
            "        dom_id_matched = False",
            "        for attribute_name in ['identity_domain_id', 'assignment_domain_id']:",
            "            if event.domain_id == token_values[attribute_name]:",
            "                dom_id_matched = True",
            "                break",
            "        if not dom_id_matched:",
            "            return False",
            "",
            "    # If any one check does not match, the while token does",
            "    # not match the event. The numerous return False indicate",
            "    # that the token is still valid and short-circuits the",
            "    # rest of the logic.",
            "    attribute_names = ['project_id',",
            "                       'expires_at', 'trust_id', 'consumer_id',",
            "                       'access_token_id']",
            "    for attribute_name in attribute_names:",
            "        if getattr(event, attribute_name) is not None:",
            "            if (getattr(event, attribute_name) !=",
            "                    token_values[attribute_name]):",
            "                        return False",
            "",
            "    if event.role_id is not None:",
            "        roles = token_values['roles']",
            "        role_found = False",
            "        for role in roles:",
            "            if event.role_id == role:",
            "                role_found = True",
            "                break",
            "        if not role_found:",
            "            return False",
            "    if token_values['issued_at'] > event.issued_before:",
            "        return False",
            "    return True",
            "",
            "",
            "@dependency.requires('revoke_api')",
            "class RevokeTests(object):",
            "    def test_list(self):",
            "        self.revoke_api.revoke_by_user(user_id=1)",
            "        self.assertEqual(1, len(self.revoke_api.get_events()))",
            "",
            "        self.revoke_api.revoke_by_user(user_id=2)",
            "        self.assertEqual(2, len(self.revoke_api.get_events()))",
            "",
            "    def test_list_since(self):",
            "        self.revoke_api.revoke_by_user(user_id=1)",
            "        self.revoke_api.revoke_by_user(user_id=2)",
            "        past = timeutils.utcnow() - datetime.timedelta(seconds=1000)",
            "        self.assertEqual(2, len(self.revoke_api.get_events(past)))",
            "        future = timeutils.utcnow() + datetime.timedelta(seconds=1000)",
            "        self.assertEqual(0, len(self.revoke_api.get_events(future)))",
            "",
            "    def test_past_expiry_are_removed(self):",
            "        user_id = 1",
            "        self.revoke_api.revoke_by_expiration(user_id, _future_time())",
            "        self.assertEqual(1, len(self.revoke_api.get_events()))",
            "        event = model.RevokeEvent()",
            "        event.revoked_at = _past_time()",
            "        self.revoke_api.revoke(event)",
            "        self.assertEqual(1, len(self.revoke_api.get_events()))",
            "",
            "    @mock.patch.object(timeutils, 'utcnow')",
            "    def test_expired_events_removed_validate_token_success(self, mock_utcnow):",
            "        def _sample_token_values():",
            "            token = _sample_blank_token()",
            "            token['expires_at'] = timeutils.isotime(_future_time(),",
            "                                                    subsecond=True)",
            "            return token",
            "",
            "        now = datetime.datetime.utcnow()",
            "        now_plus_2h = now + datetime.timedelta(hours=2)",
            "        mock_utcnow.return_value = now",
            "",
            "        # Build a token and validate it. This will seed the cache for the",
            "        # future 'synchronize' call.",
            "        token_values = _sample_token_values()",
            "",
            "        user_id = _new_id()",
            "        self.revoke_api.revoke_by_user(user_id)",
            "        token_values['user_id'] = user_id",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.revoke_api.check_token,",
            "                          token_values)",
            "",
            "        # Move our clock forward by 2h, build a new token and validate it.",
            "        # 'synchronize' should now be exercised and remove old expired events",
            "        mock_utcnow.return_value = now_plus_2h",
            "        self.revoke_api.revoke_by_expiration(_new_id(), now_plus_2h)",
            "        #should no longer throw an exception",
            "        self.revoke_api.check_token(token_values)",
            "",
            "",
            "class SqlRevokeTests(test_backend_sql.SqlTests, RevokeTests):",
            "    def config_overrides(self):",
            "        super(SqlRevokeTests, self).config_overrides()",
            "        self.config_fixture.config(",
            "            group='revoke',",
            "            driver='keystone.contrib.revoke.backends.sql.Revoke')",
            "        self.config_fixture.config(",
            "            group='token',",
            "            provider='keystone.token.providers.pki.Provider',",
            "            revoke_by_id=False)",
            "",
            "",
            "class KvsRevokeTests(tests.TestCase, RevokeTests):",
            "    def config_overrides(self):",
            "        super(KvsRevokeTests, self).config_overrides()",
            "        self.config_fixture.config(",
            "            group='revoke',",
            "            driver='keystone.contrib.revoke.backends.kvs.Revoke')",
            "        self.config_fixture.config(",
            "            group='token',",
            "            provider='keystone.token.providers.pki.Provider',",
            "            revoke_by_id=False)",
            "",
            "    def setUp(self):",
            "        super(KvsRevokeTests, self).setUp()",
            "        self.load_backends()",
            "",
            "",
            "class RevokeTreeTests(tests.TestCase):",
            "    def setUp(self):",
            "        super(RevokeTreeTests, self).setUp()",
            "        self.events = []",
            "        self.tree = model.RevokeTree()",
            "        self._sample_data()",
            "",
            "    def _sample_data(self):",
            "        user_ids = []",
            "        project_ids = []",
            "        role_ids = []",
            "        for i in range(0, 3):",
            "            user_ids.append(_new_id())",
            "            project_ids.append(_new_id())",
            "            role_ids.append(_new_id())",
            "",
            "        project_tokens = []",
            "        i = len(project_tokens)",
            "        project_tokens.append(_sample_blank_token())",
            "        project_tokens[i]['user_id'] = user_ids[0]",
            "        project_tokens[i]['project_id'] = project_ids[0]",
            "        project_tokens[i]['roles'] = [role_ids[1]]",
            "",
            "        i = len(project_tokens)",
            "        project_tokens.append(_sample_blank_token())",
            "        project_tokens[i]['user_id'] = user_ids[1]",
            "        project_tokens[i]['project_id'] = project_ids[0]",
            "        project_tokens[i]['roles'] = [role_ids[0]]",
            "",
            "        i = len(project_tokens)",
            "        project_tokens.append(_sample_blank_token())",
            "        project_tokens[i]['user_id'] = user_ids[0]",
            "        project_tokens[i]['project_id'] = project_ids[1]",
            "        project_tokens[i]['roles'] = [role_ids[0]]",
            "",
            "        token_to_revoke = _sample_blank_token()",
            "        token_to_revoke['user_id'] = user_ids[0]",
            "        token_to_revoke['project_id'] = project_ids[0]",
            "        token_to_revoke['roles'] = [role_ids[0]]",
            "",
            "        self.project_tokens = project_tokens",
            "        self.user_ids = user_ids",
            "        self.project_ids = project_ids",
            "        self.role_ids = role_ids",
            "        self.token_to_revoke = token_to_revoke",
            "",
            "    def _assertTokenRevoked(self, token_data):",
            "        self.assertTrue(any([_matches(e, token_data) for e in self.events]))",
            "        return self.assertTrue(self.tree.is_revoked(token_data),",
            "                               'Token should be revoked')",
            "",
            "    def _assertTokenNotRevoked(self, token_data):",
            "        self.assertFalse(any([_matches(e, token_data) for e in self.events]))",
            "        return self.assertFalse(self.tree.is_revoked(token_data),",
            "                                'Token should not be revoked')",
            "",
            "    def _revoke_by_user(self, user_id):",
            "        return self.tree.add_event(",
            "            model.RevokeEvent(user_id=user_id))",
            "",
            "    def _revoke_by_expiration(self, user_id, expires_at):",
            "        event = self.tree.add_event(",
            "            model.RevokeEvent(user_id=user_id,",
            "                              expires_at=expires_at))",
            "        self.events.append(event)",
            "        return event",
            "",
            "    def _revoke_by_grant(self, role_id, user_id=None,",
            "                         domain_id=None, project_id=None):",
            "        event = self.tree.add_event(",
            "            model.RevokeEvent(user_id=user_id,",
            "                              role_id=role_id,",
            "                              domain_id=domain_id,",
            "                              project_id=project_id))",
            "        self.events.append(event)",
            "        return event",
            "",
            "    def _revoke_by_user_and_project(self, user_id, project_id):",
            "        event = self.tree.add_event(",
            "            model.RevokeEvent(project_id=project_id,",
            "                              user_id=user_id))",
            "        self.events.append(event)",
            "        return event",
            "",
            "    def _revoke_by_project_role_assignment(self, project_id, role_id):",
            "        event = self.tree.add_event(",
            "            model.RevokeEvent(project_id=project_id,",
            "                              role_id=role_id))",
            "        self.events.append(event)",
            "        return event",
            "",
            "    def _revoke_by_domain_role_assignment(self, domain_id, role_id):",
            "        event = self.tree.add_event(",
            "            model.RevokeEvent(domain_id=domain_id,",
            "                              role_id=role_id))",
            "        self.events.append(event)",
            "        return event",
            "",
            "    def _revoke_by_domain(self, domain_id):",
            "        event = self.tree.add_event(model.RevokeEvent(domain_id=domain_id))",
            "        self.events.append(event)",
            "",
            "    def _user_field_test(self, field_name):",
            "        user_id = _new_id()",
            "        event = self._revoke_by_user(user_id)",
            "        self.events.append(event)",
            "        token_data_u1 = _sample_blank_token()",
            "        token_data_u1[field_name] = user_id",
            "        self._assertTokenRevoked(token_data_u1)",
            "        token_data_u2 = _sample_blank_token()",
            "        token_data_u2[field_name] = _new_id()",
            "        self._assertTokenNotRevoked(token_data_u2)",
            "        self.tree.remove_event(event)",
            "        self.events.remove(event)",
            "        self._assertTokenNotRevoked(token_data_u1)",
            "",
            "    def test_revoke_by_user(self):",
            "        self._user_field_test('user_id')",
            "",
            "    def test_revoke_by_user_matches_trustee(self):",
            "        self._user_field_test('trustee_id')",
            "",
            "    def test_revoke_by_user_matches_trustor(self):",
            "        self._user_field_test('trustor_id')",
            "",
            "    def test_by_user_expiration(self):",
            "        future_time = _future_time()",
            "",
            "        user_id = 1",
            "        event = self._revoke_by_expiration(user_id, future_time)",
            "        token_data_1 = _sample_blank_token()",
            "        token_data_1['user_id'] = user_id",
            "        token_data_1['expires_at'] = future_time",
            "        self._assertTokenRevoked(token_data_1)",
            "",
            "        token_data_2 = _sample_blank_token()",
            "        token_data_2['user_id'] = user_id",
            "        expire_delta = datetime.timedelta(seconds=2000)",
            "        future_time = timeutils.utcnow() + expire_delta",
            "        token_data_2['expires_at'] = future_time",
            "        self._assertTokenNotRevoked(token_data_2)",
            "",
            "        self.removeEvent(event)",
            "        self._assertTokenNotRevoked(token_data_1)",
            "",
            "    def removeEvent(self, event):",
            "        self.events.remove(event)",
            "        self.tree.remove_event(event)",
            "",
            "    def test_by_project_grant(self):",
            "        token_to_revoke = self.token_to_revoke",
            "        tokens = self.project_tokens",
            "",
            "        self._assertTokenNotRevoked(token_to_revoke)",
            "        for token in tokens:",
            "            self._assertTokenNotRevoked(token)",
            "",
            "        event = self._revoke_by_grant(role_id=self.role_ids[0],",
            "                                      user_id=self.user_ids[0],",
            "                                      project_id=self.project_ids[0])",
            "",
            "        self._assertTokenRevoked(token_to_revoke)",
            "        for token in tokens:",
            "            self._assertTokenNotRevoked(token)",
            "",
            "        self.removeEvent(event)",
            "",
            "        self._assertTokenNotRevoked(token_to_revoke)",
            "        for token in tokens:",
            "            self._assertTokenNotRevoked(token)",
            "",
            "        token_to_revoke['roles'] = [self.role_ids[0],",
            "                                    self.role_ids[1],",
            "                                    self.role_ids[2]]",
            "",
            "        event = self._revoke_by_grant(role_id=self.role_ids[0],",
            "                                      user_id=self.user_ids[0],",
            "                                      project_id=self.project_ids[0])",
            "        self._assertTokenRevoked(token_to_revoke)",
            "        self.removeEvent(event)",
            "        self._assertTokenNotRevoked(token_to_revoke)",
            "",
            "        event = self._revoke_by_grant(role_id=self.role_ids[1],",
            "                                      user_id=self.user_ids[0],",
            "                                      project_id=self.project_ids[0])",
            "        self._assertTokenRevoked(token_to_revoke)",
            "        self.removeEvent(event)",
            "        self._assertTokenNotRevoked(token_to_revoke)",
            "",
            "        self._revoke_by_grant(role_id=self.role_ids[0],",
            "                              user_id=self.user_ids[0],",
            "                              project_id=self.project_ids[0])",
            "        self._revoke_by_grant(role_id=self.role_ids[1],",
            "                              user_id=self.user_ids[0],",
            "                              project_id=self.project_ids[0])",
            "        self._revoke_by_grant(role_id=self.role_ids[2],",
            "                              user_id=self.user_ids[0],",
            "                              project_id=self.project_ids[0])",
            "        self._assertTokenRevoked(token_to_revoke)",
            "",
            "    def test_by_project_and_user_and_role(self):",
            "        user_id1 = _new_id()",
            "        user_id2 = _new_id()",
            "        project_id = _new_id()",
            "        self.events.append(self._revoke_by_user(user_id1))",
            "        self.events.append(",
            "            self._revoke_by_user_and_project(user_id2, project_id))",
            "        token_data = _sample_blank_token()",
            "        token_data['user_id'] = user_id2",
            "        token_data['project_id'] = project_id",
            "        self._assertTokenRevoked(token_data)",
            "",
            "    def test_by_domain_user(self):",
            "        # If revoke a domain, then a token for a user in the domain is revoked",
            "",
            "        user_id = _new_id()",
            "        domain_id = _new_id()",
            "",
            "        token_data = _sample_blank_token()",
            "        token_data['user_id'] = user_id",
            "        token_data['identity_domain_id'] = domain_id",
            "",
            "        self._revoke_by_domain(domain_id)",
            "",
            "        self._assertTokenRevoked(token_data)",
            "",
            "    def test_by_domain_project(self):",
            "        # If revoke a domain, then a token scoped to a project in the domain",
            "        # is revoked.",
            "",
            "        user_id = _new_id()",
            "        user_domain_id = _new_id()",
            "",
            "        project_id = _new_id()",
            "        project_domain_id = _new_id()",
            "",
            "        token_data = _sample_blank_token()",
            "        token_data['user_id'] = user_id",
            "        token_data['identity_domain_id'] = user_domain_id",
            "        token_data['project_id'] = project_id",
            "        token_data['assignment_domain_id'] = project_domain_id",
            "",
            "        self._revoke_by_domain(project_domain_id)",
            "",
            "        self._assertTokenRevoked(token_data)",
            "",
            "    def test_by_domain_domain(self):",
            "        # If revoke a domain, then a token scoped to the domain is revoked.",
            "",
            "        # FIXME(blk-u): The token translation code doesn't handle domain-scoped",
            "        # tokens at this point. See bug #1347318. Replace this with test code",
            "        # similar to test_by_domain_project().",
            "",
            "        pass",
            "",
            "    def _assertEmpty(self, collection):",
            "        return self.assertEqual(0, len(collection), \"collection not empty\")",
            "",
            "    def _assertEventsMatchIteration(self, turn):",
            "        self.assertEqual(1, len(self.tree.revoke_map))",
            "        self.assertEqual(turn + 1, len(self.tree.revoke_map",
            "                                       ['trust_id=*']",
            "                                       ['consumer_id=*']",
            "                                       ['access_token_id=*']))",
            "        # two different functions add  domain_ids, +1 for None",
            "        self.assertEqual(2 * turn + 1, len(self.tree.revoke_map",
            "                                           ['trust_id=*']",
            "                                           ['consumer_id=*']",
            "                                           ['access_token_id=*']",
            "                                           ['expires_at=*']))",
            "        # two different functions add  project_ids, +1 for None",
            "        self.assertEqual(2 * turn + 1, len(self.tree.revoke_map",
            "                                           ['trust_id=*']",
            "                                           ['consumer_id=*']",
            "                                           ['access_token_id=*']",
            "                                           ['expires_at=*']",
            "                                           ['domain_id=*']))",
            "        # 10 users added",
            "        self.assertEqual(turn, len(self.tree.revoke_map",
            "                                   ['trust_id=*']",
            "                                   ['consumer_id=*']",
            "                                   ['access_token_id=*']",
            "                                   ['expires_at=*']",
            "                                   ['domain_id=*']",
            "                                   ['project_id=*']))",
            "",
            "    def test_cleanup(self):",
            "        events = self.events",
            "        self._assertEmpty(self.tree.revoke_map)",
            "        for i in range(0, 10):",
            "            events.append(",
            "                self._revoke_by_user(_new_id()))",
            "            events.append(",
            "                self._revoke_by_expiration(_new_id(), _future_time()))",
            "            events.append(",
            "                self._revoke_by_project_role_assignment(_new_id(), _new_id()))",
            "            events.append(",
            "                self._revoke_by_domain_role_assignment(_new_id(), _new_id()))",
            "            events.append(",
            "                self._revoke_by_domain_role_assignment(_new_id(), _new_id()))",
            "            events.append(",
            "                self._revoke_by_user_and_project(_new_id(), _new_id()))",
            "            self._assertEventsMatchIteration(i + 1)",
            "",
            "        for event in self.events:",
            "            self.tree.remove_event(event)",
            "        self._assertEmpty(self.tree.revoke_map)"
        ],
        "afterPatchFile": [
            "# Licensed under the Apache License, Version 2.0 (the \"License\"); you may",
            "# not use this file except in compliance with the License. You may obtain",
            "# a copy of the License at",
            "#",
            "#      http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing, software",
            "# distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT",
            "# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the",
            "# License for the specific language governing permissions and limitations",
            "# under the License.",
            "",
            "",
            "import datetime",
            "import uuid",
            "",
            "import mock",
            "",
            "from keystone.common import dependency",
            "from keystone import config",
            "from keystone.contrib.revoke import model",
            "from keystone import exception",
            "from keystone.openstack.common import timeutils",
            "from keystone import tests",
            "from keystone.tests import test_backend_sql",
            "",
            "",
            "CONF = config.CONF",
            "",
            "",
            "def _new_id():",
            "    return uuid.uuid4().hex",
            "",
            "",
            "def _future_time():",
            "    expire_delta = datetime.timedelta(seconds=1000)",
            "    future_time = timeutils.utcnow() + expire_delta",
            "    return future_time",
            "",
            "",
            "def _past_time():",
            "    expire_delta = datetime.timedelta(days=-1000)",
            "    past_time = timeutils.utcnow() + expire_delta",
            "    return past_time",
            "",
            "",
            "def _sample_blank_token():",
            "    issued_delta = datetime.timedelta(minutes=-2)",
            "    issued_at = timeutils.utcnow() + issued_delta",
            "    token_data = model.blank_token_data(issued_at)",
            "    return token_data",
            "",
            "",
            "def _matches(event, token_values):",
            "    \"\"\"See if the token matches the revocation event.",
            "",
            "    Used as a secondary check on the logic to Check",
            "    By Tree Below:  This is abrute force approach to checking.",
            "    Compare each attribute from the event with the corresponding",
            "    value from the token.  If the event does not have a value for",
            "    the attribute, a match is still possible.  If the event has a",
            "    value for the attribute, and it does not match the token, no match",
            "    is possible, so skip the remaining checks.",
            "",
            "    :param event one revocation event to match",
            "    :param token_values dictionary with set of values taken from the",
            "    token",
            "    :returns if the token matches the revocation event, indicating the",
            "    token has been revoked",
            "    \"\"\"",
            "",
            "    # The token has three attributes that can match the user_id",
            "    if event.user_id is not None:",
            "        for attribute_name in ['user_id', 'trustor_id', 'trustee_id']:",
            "            if event.user_id == token_values[attribute_name]:",
            "                break",
            "        else:",
            "            return False",
            "",
            "    # The token has two attributes that can match the domain_id",
            "    if event.domain_id is not None:",
            "        dom_id_matched = False",
            "        for attribute_name in ['identity_domain_id', 'assignment_domain_id']:",
            "            if event.domain_id == token_values[attribute_name]:",
            "                dom_id_matched = True",
            "                break",
            "        if not dom_id_matched:",
            "            return False",
            "",
            "    # If any one check does not match, the while token does",
            "    # not match the event. The numerous return False indicate",
            "    # that the token is still valid and short-circuits the",
            "    # rest of the logic.",
            "    attribute_names = ['project_id',",
            "                       'expires_at', 'trust_id', 'consumer_id',",
            "                       'access_token_id']",
            "    for attribute_name in attribute_names:",
            "        if getattr(event, attribute_name) is not None:",
            "            if (getattr(event, attribute_name) !=",
            "                    token_values[attribute_name]):",
            "                        return False",
            "",
            "    if event.role_id is not None:",
            "        roles = token_values['roles']",
            "        role_found = False",
            "        for role in roles:",
            "            if event.role_id == role:",
            "                role_found = True",
            "                break",
            "        if not role_found:",
            "            return False",
            "    if token_values['issued_at'] > event.issued_before:",
            "        return False",
            "    return True",
            "",
            "",
            "@dependency.requires('revoke_api')",
            "class RevokeTests(object):",
            "    def test_list(self):",
            "        self.revoke_api.revoke_by_user(user_id=1)",
            "        self.assertEqual(1, len(self.revoke_api.get_events()))",
            "",
            "        self.revoke_api.revoke_by_user(user_id=2)",
            "        self.assertEqual(2, len(self.revoke_api.get_events()))",
            "",
            "    def test_list_since(self):",
            "        self.revoke_api.revoke_by_user(user_id=1)",
            "        self.revoke_api.revoke_by_user(user_id=2)",
            "        past = timeutils.utcnow() - datetime.timedelta(seconds=1000)",
            "        self.assertEqual(2, len(self.revoke_api.get_events(past)))",
            "        future = timeutils.utcnow() + datetime.timedelta(seconds=1000)",
            "        self.assertEqual(0, len(self.revoke_api.get_events(future)))",
            "",
            "    def test_past_expiry_are_removed(self):",
            "        user_id = 1",
            "        self.revoke_api.revoke_by_expiration(user_id, _future_time())",
            "        self.assertEqual(1, len(self.revoke_api.get_events()))",
            "        event = model.RevokeEvent()",
            "        event.revoked_at = _past_time()",
            "        self.revoke_api.revoke(event)",
            "        self.assertEqual(1, len(self.revoke_api.get_events()))",
            "",
            "    @mock.patch.object(timeutils, 'utcnow')",
            "    def test_expired_events_removed_validate_token_success(self, mock_utcnow):",
            "        def _sample_token_values():",
            "            token = _sample_blank_token()",
            "            token['expires_at'] = timeutils.isotime(_future_time(),",
            "                                                    subsecond=True)",
            "            return token",
            "",
            "        now = datetime.datetime.utcnow()",
            "        now_plus_2h = now + datetime.timedelta(hours=2)",
            "        mock_utcnow.return_value = now",
            "",
            "        # Build a token and validate it. This will seed the cache for the",
            "        # future 'synchronize' call.",
            "        token_values = _sample_token_values()",
            "",
            "        user_id = _new_id()",
            "        self.revoke_api.revoke_by_user(user_id)",
            "        token_values['user_id'] = user_id",
            "        self.assertRaises(exception.TokenNotFound,",
            "                          self.revoke_api.check_token,",
            "                          token_values)",
            "",
            "        # Move our clock forward by 2h, build a new token and validate it.",
            "        # 'synchronize' should now be exercised and remove old expired events",
            "        mock_utcnow.return_value = now_plus_2h",
            "        self.revoke_api.revoke_by_expiration(_new_id(), now_plus_2h)",
            "        #should no longer throw an exception",
            "        self.revoke_api.check_token(token_values)",
            "",
            "",
            "class SqlRevokeTests(test_backend_sql.SqlTests, RevokeTests):",
            "    def config_overrides(self):",
            "        super(SqlRevokeTests, self).config_overrides()",
            "        self.config_fixture.config(",
            "            group='revoke',",
            "            driver='keystone.contrib.revoke.backends.sql.Revoke')",
            "        self.config_fixture.config(",
            "            group='token',",
            "            provider='keystone.token.providers.pki.Provider',",
            "            revoke_by_id=False)",
            "",
            "",
            "class KvsRevokeTests(tests.TestCase, RevokeTests):",
            "    def config_overrides(self):",
            "        super(KvsRevokeTests, self).config_overrides()",
            "        self.config_fixture.config(",
            "            group='revoke',",
            "            driver='keystone.contrib.revoke.backends.kvs.Revoke')",
            "        self.config_fixture.config(",
            "            group='token',",
            "            provider='keystone.token.providers.pki.Provider',",
            "            revoke_by_id=False)",
            "",
            "    def setUp(self):",
            "        super(KvsRevokeTests, self).setUp()",
            "        self.load_backends()",
            "",
            "",
            "class RevokeTreeTests(tests.TestCase):",
            "    def setUp(self):",
            "        super(RevokeTreeTests, self).setUp()",
            "        self.events = []",
            "        self.tree = model.RevokeTree()",
            "        self._sample_data()",
            "",
            "    def _sample_data(self):",
            "        user_ids = []",
            "        project_ids = []",
            "        role_ids = []",
            "        for i in range(0, 3):",
            "            user_ids.append(_new_id())",
            "            project_ids.append(_new_id())",
            "            role_ids.append(_new_id())",
            "",
            "        project_tokens = []",
            "        i = len(project_tokens)",
            "        project_tokens.append(_sample_blank_token())",
            "        project_tokens[i]['user_id'] = user_ids[0]",
            "        project_tokens[i]['project_id'] = project_ids[0]",
            "        project_tokens[i]['roles'] = [role_ids[1]]",
            "",
            "        i = len(project_tokens)",
            "        project_tokens.append(_sample_blank_token())",
            "        project_tokens[i]['user_id'] = user_ids[1]",
            "        project_tokens[i]['project_id'] = project_ids[0]",
            "        project_tokens[i]['roles'] = [role_ids[0]]",
            "",
            "        i = len(project_tokens)",
            "        project_tokens.append(_sample_blank_token())",
            "        project_tokens[i]['user_id'] = user_ids[0]",
            "        project_tokens[i]['project_id'] = project_ids[1]",
            "        project_tokens[i]['roles'] = [role_ids[0]]",
            "",
            "        token_to_revoke = _sample_blank_token()",
            "        token_to_revoke['user_id'] = user_ids[0]",
            "        token_to_revoke['project_id'] = project_ids[0]",
            "        token_to_revoke['roles'] = [role_ids[0]]",
            "",
            "        self.project_tokens = project_tokens",
            "        self.user_ids = user_ids",
            "        self.project_ids = project_ids",
            "        self.role_ids = role_ids",
            "        self.token_to_revoke = token_to_revoke",
            "",
            "    def _assertTokenRevoked(self, token_data):",
            "        self.assertTrue(any([_matches(e, token_data) for e in self.events]))",
            "        return self.assertTrue(self.tree.is_revoked(token_data),",
            "                               'Token should be revoked')",
            "",
            "    def _assertTokenNotRevoked(self, token_data):",
            "        self.assertFalse(any([_matches(e, token_data) for e in self.events]))",
            "        return self.assertFalse(self.tree.is_revoked(token_data),",
            "                                'Token should not be revoked')",
            "",
            "    def _revoke_by_user(self, user_id):",
            "        return self.tree.add_event(",
            "            model.RevokeEvent(user_id=user_id))",
            "",
            "    def _revoke_by_expiration(self, user_id, expires_at):",
            "        event = self.tree.add_event(",
            "            model.RevokeEvent(user_id=user_id,",
            "                              expires_at=expires_at))",
            "        self.events.append(event)",
            "        return event",
            "",
            "    def _revoke_by_grant(self, role_id, user_id=None,",
            "                         domain_id=None, project_id=None):",
            "        event = self.tree.add_event(",
            "            model.RevokeEvent(user_id=user_id,",
            "                              role_id=role_id,",
            "                              domain_id=domain_id,",
            "                              project_id=project_id))",
            "        self.events.append(event)",
            "        return event",
            "",
            "    def _revoke_by_user_and_project(self, user_id, project_id):",
            "        event = self.tree.add_event(",
            "            model.RevokeEvent(project_id=project_id,",
            "                              user_id=user_id))",
            "        self.events.append(event)",
            "        return event",
            "",
            "    def _revoke_by_project_role_assignment(self, project_id, role_id):",
            "        event = self.tree.add_event(",
            "            model.RevokeEvent(project_id=project_id,",
            "                              role_id=role_id))",
            "        self.events.append(event)",
            "        return event",
            "",
            "    def _revoke_by_domain_role_assignment(self, domain_id, role_id):",
            "        event = self.tree.add_event(",
            "            model.RevokeEvent(domain_id=domain_id,",
            "                              role_id=role_id))",
            "        self.events.append(event)",
            "        return event",
            "",
            "    def _revoke_by_domain(self, domain_id):",
            "        event = self.tree.add_event(model.RevokeEvent(domain_id=domain_id))",
            "        self.events.append(event)",
            "",
            "    def _user_field_test(self, field_name):",
            "        user_id = _new_id()",
            "        event = self._revoke_by_user(user_id)",
            "        self.events.append(event)",
            "        token_data_u1 = _sample_blank_token()",
            "        token_data_u1[field_name] = user_id",
            "        self._assertTokenRevoked(token_data_u1)",
            "        token_data_u2 = _sample_blank_token()",
            "        token_data_u2[field_name] = _new_id()",
            "        self._assertTokenNotRevoked(token_data_u2)",
            "        self.tree.remove_event(event)",
            "        self.events.remove(event)",
            "        self._assertTokenNotRevoked(token_data_u1)",
            "",
            "    def test_revoke_by_user(self):",
            "        self._user_field_test('user_id')",
            "",
            "    def test_revoke_by_user_matches_trustee(self):",
            "        self._user_field_test('trustee_id')",
            "",
            "    def test_revoke_by_user_matches_trustor(self):",
            "        self._user_field_test('trustor_id')",
            "",
            "    def test_by_user_expiration(self):",
            "        future_time = _future_time()",
            "",
            "        user_id = 1",
            "        event = self._revoke_by_expiration(user_id, future_time)",
            "        token_data_1 = _sample_blank_token()",
            "        token_data_1['user_id'] = user_id",
            "        token_data_1['expires_at'] = future_time",
            "        self._assertTokenRevoked(token_data_1)",
            "",
            "        token_data_2 = _sample_blank_token()",
            "        token_data_2['user_id'] = user_id",
            "        expire_delta = datetime.timedelta(seconds=2000)",
            "        future_time = timeutils.utcnow() + expire_delta",
            "        token_data_2['expires_at'] = future_time",
            "        self._assertTokenNotRevoked(token_data_2)",
            "",
            "        self.removeEvent(event)",
            "        self._assertTokenNotRevoked(token_data_1)",
            "",
            "    def removeEvent(self, event):",
            "        self.events.remove(event)",
            "        self.tree.remove_event(event)",
            "",
            "    def test_by_project_grant(self):",
            "        token_to_revoke = self.token_to_revoke",
            "        tokens = self.project_tokens",
            "",
            "        self._assertTokenNotRevoked(token_to_revoke)",
            "        for token in tokens:",
            "            self._assertTokenNotRevoked(token)",
            "",
            "        event = self._revoke_by_grant(role_id=self.role_ids[0],",
            "                                      user_id=self.user_ids[0],",
            "                                      project_id=self.project_ids[0])",
            "",
            "        self._assertTokenRevoked(token_to_revoke)",
            "        for token in tokens:",
            "            self._assertTokenNotRevoked(token)",
            "",
            "        self.removeEvent(event)",
            "",
            "        self._assertTokenNotRevoked(token_to_revoke)",
            "        for token in tokens:",
            "            self._assertTokenNotRevoked(token)",
            "",
            "        token_to_revoke['roles'] = [self.role_ids[0],",
            "                                    self.role_ids[1],",
            "                                    self.role_ids[2]]",
            "",
            "        event = self._revoke_by_grant(role_id=self.role_ids[0],",
            "                                      user_id=self.user_ids[0],",
            "                                      project_id=self.project_ids[0])",
            "        self._assertTokenRevoked(token_to_revoke)",
            "        self.removeEvent(event)",
            "        self._assertTokenNotRevoked(token_to_revoke)",
            "",
            "        event = self._revoke_by_grant(role_id=self.role_ids[1],",
            "                                      user_id=self.user_ids[0],",
            "                                      project_id=self.project_ids[0])",
            "        self._assertTokenRevoked(token_to_revoke)",
            "        self.removeEvent(event)",
            "        self._assertTokenNotRevoked(token_to_revoke)",
            "",
            "        self._revoke_by_grant(role_id=self.role_ids[0],",
            "                              user_id=self.user_ids[0],",
            "                              project_id=self.project_ids[0])",
            "        self._revoke_by_grant(role_id=self.role_ids[1],",
            "                              user_id=self.user_ids[0],",
            "                              project_id=self.project_ids[0])",
            "        self._revoke_by_grant(role_id=self.role_ids[2],",
            "                              user_id=self.user_ids[0],",
            "                              project_id=self.project_ids[0])",
            "        self._assertTokenRevoked(token_to_revoke)",
            "",
            "    def test_by_project_and_user_and_role(self):",
            "        user_id1 = _new_id()",
            "        user_id2 = _new_id()",
            "        project_id = _new_id()",
            "        self.events.append(self._revoke_by_user(user_id1))",
            "        self.events.append(",
            "            self._revoke_by_user_and_project(user_id2, project_id))",
            "        token_data = _sample_blank_token()",
            "        token_data['user_id'] = user_id2",
            "        token_data['project_id'] = project_id",
            "        self._assertTokenRevoked(token_data)",
            "",
            "    def test_by_domain_user(self):",
            "        # If revoke a domain, then a token for a user in the domain is revoked",
            "",
            "        user_id = _new_id()",
            "        domain_id = _new_id()",
            "",
            "        token_data = _sample_blank_token()",
            "        token_data['user_id'] = user_id",
            "        token_data['identity_domain_id'] = domain_id",
            "",
            "        self._revoke_by_domain(domain_id)",
            "",
            "        self._assertTokenRevoked(token_data)",
            "",
            "    def test_by_domain_project(self):",
            "        # If revoke a domain, then a token scoped to a project in the domain",
            "        # is revoked.",
            "",
            "        user_id = _new_id()",
            "        user_domain_id = _new_id()",
            "",
            "        project_id = _new_id()",
            "        project_domain_id = _new_id()",
            "",
            "        token_data = _sample_blank_token()",
            "        token_data['user_id'] = user_id",
            "        token_data['identity_domain_id'] = user_domain_id",
            "        token_data['project_id'] = project_id",
            "        token_data['assignment_domain_id'] = project_domain_id",
            "",
            "        self._revoke_by_domain(project_domain_id)",
            "",
            "        self._assertTokenRevoked(token_data)",
            "",
            "    def test_by_domain_domain(self):",
            "        # If revoke a domain, then a token scoped to the domain is revoked.",
            "",
            "        user_id = _new_id()",
            "        user_domain_id = _new_id()",
            "",
            "        domain_id = _new_id()",
            "",
            "        token_data = _sample_blank_token()",
            "        token_data['user_id'] = user_id",
            "        token_data['identity_domain_id'] = user_domain_id",
            "        token_data['assignment_domain_id'] = domain_id",
            "",
            "        self._revoke_by_domain(domain_id)",
            "",
            "        self._assertTokenRevoked(token_data)",
            "",
            "    def _assertEmpty(self, collection):",
            "        return self.assertEqual(0, len(collection), \"collection not empty\")",
            "",
            "    def _assertEventsMatchIteration(self, turn):",
            "        self.assertEqual(1, len(self.tree.revoke_map))",
            "        self.assertEqual(turn + 1, len(self.tree.revoke_map",
            "                                       ['trust_id=*']",
            "                                       ['consumer_id=*']",
            "                                       ['access_token_id=*']))",
            "        # two different functions add  domain_ids, +1 for None",
            "        self.assertEqual(2 * turn + 1, len(self.tree.revoke_map",
            "                                           ['trust_id=*']",
            "                                           ['consumer_id=*']",
            "                                           ['access_token_id=*']",
            "                                           ['expires_at=*']))",
            "        # two different functions add  project_ids, +1 for None",
            "        self.assertEqual(2 * turn + 1, len(self.tree.revoke_map",
            "                                           ['trust_id=*']",
            "                                           ['consumer_id=*']",
            "                                           ['access_token_id=*']",
            "                                           ['expires_at=*']",
            "                                           ['domain_id=*']))",
            "        # 10 users added",
            "        self.assertEqual(turn, len(self.tree.revoke_map",
            "                                   ['trust_id=*']",
            "                                   ['consumer_id=*']",
            "                                   ['access_token_id=*']",
            "                                   ['expires_at=*']",
            "                                   ['domain_id=*']",
            "                                   ['project_id=*']))",
            "",
            "    def test_cleanup(self):",
            "        events = self.events",
            "        self._assertEmpty(self.tree.revoke_map)",
            "        for i in range(0, 10):",
            "            events.append(",
            "                self._revoke_by_user(_new_id()))",
            "            events.append(",
            "                self._revoke_by_expiration(_new_id(), _future_time()))",
            "            events.append(",
            "                self._revoke_by_project_role_assignment(_new_id(), _new_id()))",
            "            events.append(",
            "                self._revoke_by_domain_role_assignment(_new_id(), _new_id()))",
            "            events.append(",
            "                self._revoke_by_domain_role_assignment(_new_id(), _new_id()))",
            "            events.append(",
            "                self._revoke_by_user_and_project(_new_id(), _new_id()))",
            "            self._assertEventsMatchIteration(i + 1)",
            "",
            "        for event in self.events:",
            "            self.tree.remove_event(event)",
            "        self._assertEmpty(self.tree.revoke_map)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "451": [
                "RevokeTreeTests",
                "test_by_domain_domain"
            ],
            "452": [
                "RevokeTreeTests",
                "test_by_domain_domain"
            ],
            "453": [
                "RevokeTreeTests",
                "test_by_domain_domain"
            ],
            "455": [
                "RevokeTreeTests",
                "test_by_domain_domain"
            ]
        },
        "addLocation": []
    }
}