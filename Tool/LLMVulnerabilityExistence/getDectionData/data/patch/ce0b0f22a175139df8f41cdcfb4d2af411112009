{
    "libs/experimental/langchain_experimental/agents/agent_toolkits/pandas/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 168,
                "afterPatchRowNumber": 168,
                "PatchRowcode": "     number_of_head_rows: int = 5,"
            },
            "1": {
                "beforePatchRowNumber": 169,
                "afterPatchRowNumber": 169,
                "PatchRowcode": "     extra_tools: Sequence[BaseTool] = (),"
            },
            "2": {
                "beforePatchRowNumber": 170,
                "afterPatchRowNumber": 170,
                "PatchRowcode": "     engine: Literal[\"pandas\", \"modin\"] = \"pandas\","
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 171,
                "PatchRowcode": "+    allow_dangerous_code: bool = False,"
            },
            "4": {
                "beforePatchRowNumber": 171,
                "afterPatchRowNumber": 172,
                "PatchRowcode": "     **kwargs: Any,"
            },
            "5": {
                "beforePatchRowNumber": 172,
                "afterPatchRowNumber": 173,
                "PatchRowcode": " ) -> AgentExecutor:"
            },
            "6": {
                "beforePatchRowNumber": 173,
                "afterPatchRowNumber": 174,
                "PatchRowcode": "     \"\"\"Construct a Pandas agent from an LLM and dataframe(s)."
            },
            "7": {
                "beforePatchRowNumber": 174,
                "afterPatchRowNumber": 175,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 176,
                "PatchRowcode": "+    Security Notice:"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 177,
                "PatchRowcode": "+        This agent relies on access to a python repl tool which can execute"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 178,
                "PatchRowcode": "+        arbitrary code. This can be dangerous and requires a specially sandboxed"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 179,
                "PatchRowcode": "+        environment to be safely used. Failure to run this code in a properly"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 180,
                "PatchRowcode": "+        sandboxed environment can lead to arbitrary code execution vulnerabilities,"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 181,
                "PatchRowcode": "+        which can lead to data breaches, data loss, or other security incidents."
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 182,
                "PatchRowcode": "+"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 183,
                "PatchRowcode": "+        Do not use this code with untrusted inputs, with elevated permissions,"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 184,
                "PatchRowcode": "+        or without consulting your security team about proper sandboxing!"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 185,
                "PatchRowcode": "+"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 186,
                "PatchRowcode": "+        You must opt-in to use this functionality by setting allow_dangerous_code=True."
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 187,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": 175,
                "afterPatchRowNumber": 188,
                "PatchRowcode": "     Args:"
            },
            "21": {
                "beforePatchRowNumber": 176,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "         llm: Language model to use for the agent. If agent_type is \"tool-calling\" then"
            },
            "22": {
                "beforePatchRowNumber": 177,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "             llm is expected to support tool calling."
            },
            "23": {
                "beforePatchRowNumber": 198,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "             include_df_in_prompt is True."
            },
            "24": {
                "beforePatchRowNumber": 199,
                "afterPatchRowNumber": 212,
                "PatchRowcode": "         extra_tools: Additional tools to give to agent on top of a PythonAstREPLTool."
            },
            "25": {
                "beforePatchRowNumber": 200,
                "afterPatchRowNumber": 213,
                "PatchRowcode": "         engine: One of \"modin\" or \"pandas\". Defaults to \"pandas\"."
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 214,
                "PatchRowcode": "+        allow_dangerous_code: bool, default False"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 215,
                "PatchRowcode": "+            This agent relies on access to a python repl tool which can execute"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 216,
                "PatchRowcode": "+            arbitrary code. This can be dangerous and requires a specially sandboxed"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 217,
                "PatchRowcode": "+            environment to be safely used."
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 218,
                "PatchRowcode": "+            Failure to properly sandbox this class can lead to arbitrary code execution"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 219,
                "PatchRowcode": "+            vulnerabilities, which can lead to data breaches, data loss, or"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 220,
                "PatchRowcode": "+            other security incidents."
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+            You must opt in to use this functionality by setting"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+            allow_dangerous_code=True."
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": 201,
                "afterPatchRowNumber": 224,
                "PatchRowcode": "         **kwargs: DEPRECATED. Not used, kept for backwards compatibility."
            },
            "37": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 225,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "     Returns:"
            },
            "39": {
                "beforePatchRowNumber": 221,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "             )"
            },
            "40": {
                "beforePatchRowNumber": 222,
                "afterPatchRowNumber": 245,
                "PatchRowcode": " "
            },
            "41": {
                "beforePatchRowNumber": 223,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "     \"\"\""
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 247,
                "PatchRowcode": "+    if not allow_dangerous_code:"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 248,
                "PatchRowcode": "+        raise ValueError("
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 249,
                "PatchRowcode": "+            \"This agent relies on access to a python repl tool which can execute \""
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 250,
                "PatchRowcode": "+            \"arbitrary code. This can be dangerous and requires a specially sandboxed \""
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 251,
                "PatchRowcode": "+            \"environment to be safely used. Please read the security notice in the \""
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 252,
                "PatchRowcode": "+            \"doc-string of this function. You must opt-in to use this functionality \""
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+            \"by setting allow_dangerous_code=True.\""
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 254,
                "PatchRowcode": "+            \"For general security guidelines, please see: \""
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 255,
                "PatchRowcode": "+            \"https://python.langchain.com/v0.1/docs/security/\""
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+        )"
            },
            "52": {
                "beforePatchRowNumber": 224,
                "afterPatchRowNumber": 257,
                "PatchRowcode": "     try:"
            },
            "53": {
                "beforePatchRowNumber": 225,
                "afterPatchRowNumber": 258,
                "PatchRowcode": "         if engine == \"modin\":"
            },
            "54": {
                "beforePatchRowNumber": 226,
                "afterPatchRowNumber": 259,
                "PatchRowcode": "             import modin.pandas as pd"
            }
        },
        "frontPatchFile": [
            "\"\"\"Agent for working with pandas objects.\"\"\"",
            "import warnings",
            "from typing import Any, Dict, List, Literal, Optional, Sequence, Union, cast",
            "",
            "from langchain.agents import (",
            "    AgentType,",
            "    create_openai_tools_agent,",
            "    create_react_agent,",
            "    create_tool_calling_agent,",
            ")",
            "from langchain.agents.agent import (",
            "    AgentExecutor,",
            "    BaseMultiActionAgent,",
            "    BaseSingleActionAgent,",
            "    RunnableAgent,",
            "    RunnableMultiActionAgent,",
            ")",
            "from langchain.agents.mrkl.prompt import FORMAT_INSTRUCTIONS",
            "from langchain.agents.openai_functions_agent.base import (",
            "    OpenAIFunctionsAgent,",
            "    create_openai_functions_agent,",
            ")",
            "from langchain_core.callbacks import BaseCallbackManager",
            "from langchain_core.language_models import BaseLanguageModel, LanguageModelLike",
            "from langchain_core.messages import SystemMessage",
            "from langchain_core.prompts import (",
            "    BasePromptTemplate,",
            "    ChatPromptTemplate,",
            "    PromptTemplate,",
            ")",
            "from langchain_core.tools import BaseTool",
            "from langchain_core.utils.interactive_env import is_interactive_env",
            "",
            "from langchain_experimental.agents.agent_toolkits.pandas.prompt import (",
            "    FUNCTIONS_WITH_DF,",
            "    FUNCTIONS_WITH_MULTI_DF,",
            "    MULTI_DF_PREFIX,",
            "    MULTI_DF_PREFIX_FUNCTIONS,",
            "    PREFIX,",
            "    PREFIX_FUNCTIONS,",
            "    SUFFIX_NO_DF,",
            "    SUFFIX_WITH_DF,",
            "    SUFFIX_WITH_MULTI_DF,",
            ")",
            "from langchain_experimental.tools.python.tool import PythonAstREPLTool",
            "",
            "",
            "def _get_multi_prompt(",
            "    dfs: List[Any],",
            "    *,",
            "    prefix: Optional[str] = None,",
            "    suffix: Optional[str] = None,",
            "    include_df_in_prompt: Optional[bool] = True,",
            "    number_of_head_rows: int = 5,",
            ") -> BasePromptTemplate:",
            "    if suffix is not None:",
            "        suffix_to_use = suffix",
            "    elif include_df_in_prompt:",
            "        suffix_to_use = SUFFIX_WITH_MULTI_DF",
            "    else:",
            "        suffix_to_use = SUFFIX_NO_DF",
            "    prefix = prefix if prefix is not None else MULTI_DF_PREFIX",
            "",
            "    template = \"\\n\\n\".join([prefix, \"{tools}\", FORMAT_INSTRUCTIONS, suffix_to_use])",
            "    prompt = PromptTemplate.from_template(template)",
            "    partial_prompt = prompt.partial()",
            "    if \"dfs_head\" in partial_prompt.input_variables:",
            "        dfs_head = \"\\n\\n\".join([d.head(number_of_head_rows).to_markdown() for d in dfs])",
            "        partial_prompt = partial_prompt.partial(dfs_head=dfs_head)",
            "    if \"num_dfs\" in partial_prompt.input_variables:",
            "        partial_prompt = partial_prompt.partial(num_dfs=str(len(dfs)))",
            "    return partial_prompt",
            "",
            "",
            "def _get_single_prompt(",
            "    df: Any,",
            "    *,",
            "    prefix: Optional[str] = None,",
            "    suffix: Optional[str] = None,",
            "    include_df_in_prompt: Optional[bool] = True,",
            "    number_of_head_rows: int = 5,",
            ") -> BasePromptTemplate:",
            "    if suffix is not None:",
            "        suffix_to_use = suffix",
            "    elif include_df_in_prompt:",
            "        suffix_to_use = SUFFIX_WITH_DF",
            "    else:",
            "        suffix_to_use = SUFFIX_NO_DF",
            "    prefix = prefix if prefix is not None else PREFIX",
            "",
            "    template = \"\\n\\n\".join([prefix, \"{tools}\", FORMAT_INSTRUCTIONS, suffix_to_use])",
            "    prompt = PromptTemplate.from_template(template)",
            "",
            "    partial_prompt = prompt.partial()",
            "    if \"df_head\" in partial_prompt.input_variables:",
            "        df_head = str(df.head(number_of_head_rows).to_markdown())",
            "        partial_prompt = partial_prompt.partial(df_head=df_head)",
            "    return partial_prompt",
            "",
            "",
            "def _get_prompt(df: Any, **kwargs: Any) -> BasePromptTemplate:",
            "    return (",
            "        _get_multi_prompt(df, **kwargs)",
            "        if isinstance(df, list)",
            "        else _get_single_prompt(df, **kwargs)",
            "    )",
            "",
            "",
            "def _get_functions_single_prompt(",
            "    df: Any,",
            "    *,",
            "    prefix: Optional[str] = None,",
            "    suffix: str = \"\",",
            "    include_df_in_prompt: Optional[bool] = True,",
            "    number_of_head_rows: int = 5,",
            ") -> ChatPromptTemplate:",
            "    if include_df_in_prompt:",
            "        df_head = str(df.head(number_of_head_rows).to_markdown())",
            "        suffix = (suffix or FUNCTIONS_WITH_DF).format(df_head=df_head)",
            "    prefix = prefix if prefix is not None else PREFIX_FUNCTIONS",
            "    system_message = SystemMessage(content=prefix + suffix)",
            "    prompt = OpenAIFunctionsAgent.create_prompt(system_message=system_message)",
            "    return prompt",
            "",
            "",
            "def _get_functions_multi_prompt(",
            "    dfs: Any,",
            "    *,",
            "    prefix: str = \"\",",
            "    suffix: str = \"\",",
            "    include_df_in_prompt: Optional[bool] = True,",
            "    number_of_head_rows: int = 5,",
            ") -> ChatPromptTemplate:",
            "    if include_df_in_prompt:",
            "        dfs_head = \"\\n\\n\".join([d.head(number_of_head_rows).to_markdown() for d in dfs])",
            "        suffix = (suffix or FUNCTIONS_WITH_MULTI_DF).format(dfs_head=dfs_head)",
            "    prefix = (prefix or MULTI_DF_PREFIX_FUNCTIONS).format(num_dfs=str(len(dfs)))",
            "    system_message = SystemMessage(content=prefix + suffix)",
            "    prompt = OpenAIFunctionsAgent.create_prompt(system_message=system_message)",
            "    return prompt",
            "",
            "",
            "def _get_functions_prompt(df: Any, **kwargs: Any) -> ChatPromptTemplate:",
            "    return (",
            "        _get_functions_multi_prompt(df, **kwargs)",
            "        if isinstance(df, list)",
            "        else _get_functions_single_prompt(df, **kwargs)",
            "    )",
            "",
            "",
            "def create_pandas_dataframe_agent(",
            "    llm: LanguageModelLike,",
            "    df: Any,",
            "    agent_type: Union[",
            "        AgentType, Literal[\"openai-tools\", \"tool-calling\"]",
            "    ] = AgentType.ZERO_SHOT_REACT_DESCRIPTION,",
            "    callback_manager: Optional[BaseCallbackManager] = None,",
            "    prefix: Optional[str] = None,",
            "    suffix: Optional[str] = None,",
            "    input_variables: Optional[List[str]] = None,",
            "    verbose: bool = False,",
            "    return_intermediate_steps: bool = False,",
            "    max_iterations: Optional[int] = 15,",
            "    max_execution_time: Optional[float] = None,",
            "    early_stopping_method: str = \"force\",",
            "    agent_executor_kwargs: Optional[Dict[str, Any]] = None,",
            "    include_df_in_prompt: Optional[bool] = True,",
            "    number_of_head_rows: int = 5,",
            "    extra_tools: Sequence[BaseTool] = (),",
            "    engine: Literal[\"pandas\", \"modin\"] = \"pandas\",",
            "    **kwargs: Any,",
            ") -> AgentExecutor:",
            "    \"\"\"Construct a Pandas agent from an LLM and dataframe(s).",
            "",
            "    Args:",
            "        llm: Language model to use for the agent. If agent_type is \"tool-calling\" then",
            "            llm is expected to support tool calling.",
            "        df: Pandas dataframe or list of Pandas dataframes.",
            "        agent_type: One of \"tool-calling\", \"openai-tools\", \"openai-functions\", or",
            "            \"zero-shot-react-description\". Defaults to \"zero-shot-react-description\".",
            "            \"tool-calling\" is recommended over the legacy \"openai-tools\" and",
            "            \"openai-functions\" types.",
            "        callback_manager: DEPRECATED. Pass \"callbacks\" key into 'agent_executor_kwargs'",
            "            instead to pass constructor callbacks to AgentExecutor.",
            "        prefix: Prompt prefix string.",
            "        suffix: Prompt suffix string.",
            "        input_variables: DEPRECATED. Input variables automatically inferred from",
            "            constructed prompt.",
            "        verbose: AgentExecutor verbosity.",
            "        return_intermediate_steps: Passed to AgentExecutor init.",
            "        max_iterations: Passed to AgentExecutor init.",
            "        max_execution_time: Passed to AgentExecutor init.",
            "        early_stopping_method: Passed to AgentExecutor init.",
            "        agent_executor_kwargs: Arbitrary additional AgentExecutor args.",
            "        include_df_in_prompt: Whether to include the first number_of_head_rows in the",
            "            prompt. Must be None if suffix is not None.",
            "        number_of_head_rows: Number of initial rows to include in prompt if",
            "            include_df_in_prompt is True.",
            "        extra_tools: Additional tools to give to agent on top of a PythonAstREPLTool.",
            "        engine: One of \"modin\" or \"pandas\". Defaults to \"pandas\".",
            "        **kwargs: DEPRECATED. Not used, kept for backwards compatibility.",
            "",
            "    Returns:",
            "        An AgentExecutor with the specified agent_type agent and access to",
            "        a PythonAstREPLTool with the DataFrame(s) and any user-provided extra_tools.",
            "",
            "    Example:",
            "        .. code-block:: python",
            "",
            "            from langchain_openai import ChatOpenAI",
            "            from langchain_experimental.agents import create_pandas_dataframe_agent",
            "            import pandas as pd",
            "",
            "            df = pd.read_csv(\"titanic.csv\")",
            "            llm = ChatOpenAI(model=\"gpt-3.5-turbo\", temperature=0)",
            "            agent_executor = create_pandas_dataframe_agent(",
            "                llm,",
            "                df,",
            "                agent_type=\"tool-calling\",",
            "                verbose=True",
            "            )",
            "",
            "    \"\"\"",
            "    try:",
            "        if engine == \"modin\":",
            "            import modin.pandas as pd",
            "        elif engine == \"pandas\":",
            "            import pandas as pd",
            "        else:",
            "            raise ValueError(",
            "                f\"Unsupported engine {engine}. It must be one of 'modin' or 'pandas'.\"",
            "            )",
            "    except ImportError as e:",
            "        raise ImportError(",
            "            f\"`{engine}` package not found, please install with `pip install {engine}`\"",
            "        ) from e",
            "",
            "    if is_interactive_env():",
            "        pd.set_option(\"display.max_columns\", None)",
            "",
            "    for _df in df if isinstance(df, list) else [df]:",
            "        if not isinstance(_df, pd.DataFrame):",
            "            raise ValueError(f\"Expected pandas DataFrame, got {type(_df)}\")",
            "",
            "    if input_variables:",
            "        kwargs = kwargs or {}",
            "        kwargs[\"input_variables\"] = input_variables",
            "    if kwargs:",
            "        warnings.warn(",
            "            f\"Received additional kwargs {kwargs} which are no longer supported.\"",
            "        )",
            "",
            "    df_locals = {}",
            "    if isinstance(df, list):",
            "        for i, dataframe in enumerate(df):",
            "            df_locals[f\"df{i + 1}\"] = dataframe",
            "    else:",
            "        df_locals[\"df\"] = df",
            "    tools = [PythonAstREPLTool(locals=df_locals)] + list(extra_tools)",
            "",
            "    if agent_type == AgentType.ZERO_SHOT_REACT_DESCRIPTION:",
            "        if include_df_in_prompt is not None and suffix is not None:",
            "            raise ValueError(",
            "                \"If suffix is specified, include_df_in_prompt should not be.\"",
            "            )",
            "        prompt = _get_prompt(",
            "            df,",
            "            prefix=prefix,",
            "            suffix=suffix,",
            "            include_df_in_prompt=include_df_in_prompt,",
            "            number_of_head_rows=number_of_head_rows,",
            "        )",
            "        agent: Union[BaseSingleActionAgent, BaseMultiActionAgent] = RunnableAgent(",
            "            runnable=create_react_agent(llm, tools, prompt),  # type: ignore",
            "            input_keys_arg=[\"input\"],",
            "            return_keys_arg=[\"output\"],",
            "        )",
            "    elif agent_type in (AgentType.OPENAI_FUNCTIONS, \"openai-tools\", \"tool-calling\"):",
            "        prompt = _get_functions_prompt(",
            "            df,",
            "            prefix=prefix,",
            "            suffix=suffix,",
            "            include_df_in_prompt=include_df_in_prompt,",
            "            number_of_head_rows=number_of_head_rows,",
            "        )",
            "        if agent_type == AgentType.OPENAI_FUNCTIONS:",
            "            runnable = create_openai_functions_agent(",
            "                cast(BaseLanguageModel, llm), tools, prompt",
            "            )",
            "            agent = RunnableAgent(",
            "                runnable=runnable,",
            "                input_keys_arg=[\"input\"],",
            "                return_keys_arg=[\"output\"],",
            "            )",
            "        else:",
            "            if agent_type == \"openai-tools\":",
            "                runnable = create_openai_tools_agent(",
            "                    cast(BaseLanguageModel, llm), tools, prompt",
            "                )",
            "            else:",
            "                runnable = create_tool_calling_agent(",
            "                    cast(BaseLanguageModel, llm), tools, prompt",
            "                )",
            "            agent = RunnableMultiActionAgent(",
            "                runnable=runnable,",
            "                input_keys_arg=[\"input\"],",
            "                return_keys_arg=[\"output\"],",
            "            )",
            "    else:",
            "        raise ValueError(",
            "            f\"Agent type {agent_type} not supported at the moment. Must be one of \"",
            "            \"'tool-calling', 'openai-tools', 'openai-functions', or \"",
            "            \"'zero-shot-react-description'.\"",
            "        )",
            "    return AgentExecutor(",
            "        agent=agent,",
            "        tools=tools,",
            "        callback_manager=callback_manager,",
            "        verbose=verbose,",
            "        return_intermediate_steps=return_intermediate_steps,",
            "        max_iterations=max_iterations,",
            "        max_execution_time=max_execution_time,",
            "        early_stopping_method=early_stopping_method,",
            "        **(agent_executor_kwargs or {}),",
            "    )"
        ],
        "afterPatchFile": [
            "\"\"\"Agent for working with pandas objects.\"\"\"",
            "import warnings",
            "from typing import Any, Dict, List, Literal, Optional, Sequence, Union, cast",
            "",
            "from langchain.agents import (",
            "    AgentType,",
            "    create_openai_tools_agent,",
            "    create_react_agent,",
            "    create_tool_calling_agent,",
            ")",
            "from langchain.agents.agent import (",
            "    AgentExecutor,",
            "    BaseMultiActionAgent,",
            "    BaseSingleActionAgent,",
            "    RunnableAgent,",
            "    RunnableMultiActionAgent,",
            ")",
            "from langchain.agents.mrkl.prompt import FORMAT_INSTRUCTIONS",
            "from langchain.agents.openai_functions_agent.base import (",
            "    OpenAIFunctionsAgent,",
            "    create_openai_functions_agent,",
            ")",
            "from langchain_core.callbacks import BaseCallbackManager",
            "from langchain_core.language_models import BaseLanguageModel, LanguageModelLike",
            "from langchain_core.messages import SystemMessage",
            "from langchain_core.prompts import (",
            "    BasePromptTemplate,",
            "    ChatPromptTemplate,",
            "    PromptTemplate,",
            ")",
            "from langchain_core.tools import BaseTool",
            "from langchain_core.utils.interactive_env import is_interactive_env",
            "",
            "from langchain_experimental.agents.agent_toolkits.pandas.prompt import (",
            "    FUNCTIONS_WITH_DF,",
            "    FUNCTIONS_WITH_MULTI_DF,",
            "    MULTI_DF_PREFIX,",
            "    MULTI_DF_PREFIX_FUNCTIONS,",
            "    PREFIX,",
            "    PREFIX_FUNCTIONS,",
            "    SUFFIX_NO_DF,",
            "    SUFFIX_WITH_DF,",
            "    SUFFIX_WITH_MULTI_DF,",
            ")",
            "from langchain_experimental.tools.python.tool import PythonAstREPLTool",
            "",
            "",
            "def _get_multi_prompt(",
            "    dfs: List[Any],",
            "    *,",
            "    prefix: Optional[str] = None,",
            "    suffix: Optional[str] = None,",
            "    include_df_in_prompt: Optional[bool] = True,",
            "    number_of_head_rows: int = 5,",
            ") -> BasePromptTemplate:",
            "    if suffix is not None:",
            "        suffix_to_use = suffix",
            "    elif include_df_in_prompt:",
            "        suffix_to_use = SUFFIX_WITH_MULTI_DF",
            "    else:",
            "        suffix_to_use = SUFFIX_NO_DF",
            "    prefix = prefix if prefix is not None else MULTI_DF_PREFIX",
            "",
            "    template = \"\\n\\n\".join([prefix, \"{tools}\", FORMAT_INSTRUCTIONS, suffix_to_use])",
            "    prompt = PromptTemplate.from_template(template)",
            "    partial_prompt = prompt.partial()",
            "    if \"dfs_head\" in partial_prompt.input_variables:",
            "        dfs_head = \"\\n\\n\".join([d.head(number_of_head_rows).to_markdown() for d in dfs])",
            "        partial_prompt = partial_prompt.partial(dfs_head=dfs_head)",
            "    if \"num_dfs\" in partial_prompt.input_variables:",
            "        partial_prompt = partial_prompt.partial(num_dfs=str(len(dfs)))",
            "    return partial_prompt",
            "",
            "",
            "def _get_single_prompt(",
            "    df: Any,",
            "    *,",
            "    prefix: Optional[str] = None,",
            "    suffix: Optional[str] = None,",
            "    include_df_in_prompt: Optional[bool] = True,",
            "    number_of_head_rows: int = 5,",
            ") -> BasePromptTemplate:",
            "    if suffix is not None:",
            "        suffix_to_use = suffix",
            "    elif include_df_in_prompt:",
            "        suffix_to_use = SUFFIX_WITH_DF",
            "    else:",
            "        suffix_to_use = SUFFIX_NO_DF",
            "    prefix = prefix if prefix is not None else PREFIX",
            "",
            "    template = \"\\n\\n\".join([prefix, \"{tools}\", FORMAT_INSTRUCTIONS, suffix_to_use])",
            "    prompt = PromptTemplate.from_template(template)",
            "",
            "    partial_prompt = prompt.partial()",
            "    if \"df_head\" in partial_prompt.input_variables:",
            "        df_head = str(df.head(number_of_head_rows).to_markdown())",
            "        partial_prompt = partial_prompt.partial(df_head=df_head)",
            "    return partial_prompt",
            "",
            "",
            "def _get_prompt(df: Any, **kwargs: Any) -> BasePromptTemplate:",
            "    return (",
            "        _get_multi_prompt(df, **kwargs)",
            "        if isinstance(df, list)",
            "        else _get_single_prompt(df, **kwargs)",
            "    )",
            "",
            "",
            "def _get_functions_single_prompt(",
            "    df: Any,",
            "    *,",
            "    prefix: Optional[str] = None,",
            "    suffix: str = \"\",",
            "    include_df_in_prompt: Optional[bool] = True,",
            "    number_of_head_rows: int = 5,",
            ") -> ChatPromptTemplate:",
            "    if include_df_in_prompt:",
            "        df_head = str(df.head(number_of_head_rows).to_markdown())",
            "        suffix = (suffix or FUNCTIONS_WITH_DF).format(df_head=df_head)",
            "    prefix = prefix if prefix is not None else PREFIX_FUNCTIONS",
            "    system_message = SystemMessage(content=prefix + suffix)",
            "    prompt = OpenAIFunctionsAgent.create_prompt(system_message=system_message)",
            "    return prompt",
            "",
            "",
            "def _get_functions_multi_prompt(",
            "    dfs: Any,",
            "    *,",
            "    prefix: str = \"\",",
            "    suffix: str = \"\",",
            "    include_df_in_prompt: Optional[bool] = True,",
            "    number_of_head_rows: int = 5,",
            ") -> ChatPromptTemplate:",
            "    if include_df_in_prompt:",
            "        dfs_head = \"\\n\\n\".join([d.head(number_of_head_rows).to_markdown() for d in dfs])",
            "        suffix = (suffix or FUNCTIONS_WITH_MULTI_DF).format(dfs_head=dfs_head)",
            "    prefix = (prefix or MULTI_DF_PREFIX_FUNCTIONS).format(num_dfs=str(len(dfs)))",
            "    system_message = SystemMessage(content=prefix + suffix)",
            "    prompt = OpenAIFunctionsAgent.create_prompt(system_message=system_message)",
            "    return prompt",
            "",
            "",
            "def _get_functions_prompt(df: Any, **kwargs: Any) -> ChatPromptTemplate:",
            "    return (",
            "        _get_functions_multi_prompt(df, **kwargs)",
            "        if isinstance(df, list)",
            "        else _get_functions_single_prompt(df, **kwargs)",
            "    )",
            "",
            "",
            "def create_pandas_dataframe_agent(",
            "    llm: LanguageModelLike,",
            "    df: Any,",
            "    agent_type: Union[",
            "        AgentType, Literal[\"openai-tools\", \"tool-calling\"]",
            "    ] = AgentType.ZERO_SHOT_REACT_DESCRIPTION,",
            "    callback_manager: Optional[BaseCallbackManager] = None,",
            "    prefix: Optional[str] = None,",
            "    suffix: Optional[str] = None,",
            "    input_variables: Optional[List[str]] = None,",
            "    verbose: bool = False,",
            "    return_intermediate_steps: bool = False,",
            "    max_iterations: Optional[int] = 15,",
            "    max_execution_time: Optional[float] = None,",
            "    early_stopping_method: str = \"force\",",
            "    agent_executor_kwargs: Optional[Dict[str, Any]] = None,",
            "    include_df_in_prompt: Optional[bool] = True,",
            "    number_of_head_rows: int = 5,",
            "    extra_tools: Sequence[BaseTool] = (),",
            "    engine: Literal[\"pandas\", \"modin\"] = \"pandas\",",
            "    allow_dangerous_code: bool = False,",
            "    **kwargs: Any,",
            ") -> AgentExecutor:",
            "    \"\"\"Construct a Pandas agent from an LLM and dataframe(s).",
            "",
            "    Security Notice:",
            "        This agent relies on access to a python repl tool which can execute",
            "        arbitrary code. This can be dangerous and requires a specially sandboxed",
            "        environment to be safely used. Failure to run this code in a properly",
            "        sandboxed environment can lead to arbitrary code execution vulnerabilities,",
            "        which can lead to data breaches, data loss, or other security incidents.",
            "",
            "        Do not use this code with untrusted inputs, with elevated permissions,",
            "        or without consulting your security team about proper sandboxing!",
            "",
            "        You must opt-in to use this functionality by setting allow_dangerous_code=True.",
            "",
            "    Args:",
            "        llm: Language model to use for the agent. If agent_type is \"tool-calling\" then",
            "            llm is expected to support tool calling.",
            "        df: Pandas dataframe or list of Pandas dataframes.",
            "        agent_type: One of \"tool-calling\", \"openai-tools\", \"openai-functions\", or",
            "            \"zero-shot-react-description\". Defaults to \"zero-shot-react-description\".",
            "            \"tool-calling\" is recommended over the legacy \"openai-tools\" and",
            "            \"openai-functions\" types.",
            "        callback_manager: DEPRECATED. Pass \"callbacks\" key into 'agent_executor_kwargs'",
            "            instead to pass constructor callbacks to AgentExecutor.",
            "        prefix: Prompt prefix string.",
            "        suffix: Prompt suffix string.",
            "        input_variables: DEPRECATED. Input variables automatically inferred from",
            "            constructed prompt.",
            "        verbose: AgentExecutor verbosity.",
            "        return_intermediate_steps: Passed to AgentExecutor init.",
            "        max_iterations: Passed to AgentExecutor init.",
            "        max_execution_time: Passed to AgentExecutor init.",
            "        early_stopping_method: Passed to AgentExecutor init.",
            "        agent_executor_kwargs: Arbitrary additional AgentExecutor args.",
            "        include_df_in_prompt: Whether to include the first number_of_head_rows in the",
            "            prompt. Must be None if suffix is not None.",
            "        number_of_head_rows: Number of initial rows to include in prompt if",
            "            include_df_in_prompt is True.",
            "        extra_tools: Additional tools to give to agent on top of a PythonAstREPLTool.",
            "        engine: One of \"modin\" or \"pandas\". Defaults to \"pandas\".",
            "        allow_dangerous_code: bool, default False",
            "            This agent relies on access to a python repl tool which can execute",
            "            arbitrary code. This can be dangerous and requires a specially sandboxed",
            "            environment to be safely used.",
            "            Failure to properly sandbox this class can lead to arbitrary code execution",
            "            vulnerabilities, which can lead to data breaches, data loss, or",
            "            other security incidents.",
            "            You must opt in to use this functionality by setting",
            "            allow_dangerous_code=True.",
            "",
            "        **kwargs: DEPRECATED. Not used, kept for backwards compatibility.",
            "",
            "    Returns:",
            "        An AgentExecutor with the specified agent_type agent and access to",
            "        a PythonAstREPLTool with the DataFrame(s) and any user-provided extra_tools.",
            "",
            "    Example:",
            "        .. code-block:: python",
            "",
            "            from langchain_openai import ChatOpenAI",
            "            from langchain_experimental.agents import create_pandas_dataframe_agent",
            "            import pandas as pd",
            "",
            "            df = pd.read_csv(\"titanic.csv\")",
            "            llm = ChatOpenAI(model=\"gpt-3.5-turbo\", temperature=0)",
            "            agent_executor = create_pandas_dataframe_agent(",
            "                llm,",
            "                df,",
            "                agent_type=\"tool-calling\",",
            "                verbose=True",
            "            )",
            "",
            "    \"\"\"",
            "    if not allow_dangerous_code:",
            "        raise ValueError(",
            "            \"This agent relies on access to a python repl tool which can execute \"",
            "            \"arbitrary code. This can be dangerous and requires a specially sandboxed \"",
            "            \"environment to be safely used. Please read the security notice in the \"",
            "            \"doc-string of this function. You must opt-in to use this functionality \"",
            "            \"by setting allow_dangerous_code=True.\"",
            "            \"For general security guidelines, please see: \"",
            "            \"https://python.langchain.com/v0.1/docs/security/\"",
            "        )",
            "    try:",
            "        if engine == \"modin\":",
            "            import modin.pandas as pd",
            "        elif engine == \"pandas\":",
            "            import pandas as pd",
            "        else:",
            "            raise ValueError(",
            "                f\"Unsupported engine {engine}. It must be one of 'modin' or 'pandas'.\"",
            "            )",
            "    except ImportError as e:",
            "        raise ImportError(",
            "            f\"`{engine}` package not found, please install with `pip install {engine}`\"",
            "        ) from e",
            "",
            "    if is_interactive_env():",
            "        pd.set_option(\"display.max_columns\", None)",
            "",
            "    for _df in df if isinstance(df, list) else [df]:",
            "        if not isinstance(_df, pd.DataFrame):",
            "            raise ValueError(f\"Expected pandas DataFrame, got {type(_df)}\")",
            "",
            "    if input_variables:",
            "        kwargs = kwargs or {}",
            "        kwargs[\"input_variables\"] = input_variables",
            "    if kwargs:",
            "        warnings.warn(",
            "            f\"Received additional kwargs {kwargs} which are no longer supported.\"",
            "        )",
            "",
            "    df_locals = {}",
            "    if isinstance(df, list):",
            "        for i, dataframe in enumerate(df):",
            "            df_locals[f\"df{i + 1}\"] = dataframe",
            "    else:",
            "        df_locals[\"df\"] = df",
            "    tools = [PythonAstREPLTool(locals=df_locals)] + list(extra_tools)",
            "",
            "    if agent_type == AgentType.ZERO_SHOT_REACT_DESCRIPTION:",
            "        if include_df_in_prompt is not None and suffix is not None:",
            "            raise ValueError(",
            "                \"If suffix is specified, include_df_in_prompt should not be.\"",
            "            )",
            "        prompt = _get_prompt(",
            "            df,",
            "            prefix=prefix,",
            "            suffix=suffix,",
            "            include_df_in_prompt=include_df_in_prompt,",
            "            number_of_head_rows=number_of_head_rows,",
            "        )",
            "        agent: Union[BaseSingleActionAgent, BaseMultiActionAgent] = RunnableAgent(",
            "            runnable=create_react_agent(llm, tools, prompt),  # type: ignore",
            "            input_keys_arg=[\"input\"],",
            "            return_keys_arg=[\"output\"],",
            "        )",
            "    elif agent_type in (AgentType.OPENAI_FUNCTIONS, \"openai-tools\", \"tool-calling\"):",
            "        prompt = _get_functions_prompt(",
            "            df,",
            "            prefix=prefix,",
            "            suffix=suffix,",
            "            include_df_in_prompt=include_df_in_prompt,",
            "            number_of_head_rows=number_of_head_rows,",
            "        )",
            "        if agent_type == AgentType.OPENAI_FUNCTIONS:",
            "            runnable = create_openai_functions_agent(",
            "                cast(BaseLanguageModel, llm), tools, prompt",
            "            )",
            "            agent = RunnableAgent(",
            "                runnable=runnable,",
            "                input_keys_arg=[\"input\"],",
            "                return_keys_arg=[\"output\"],",
            "            )",
            "        else:",
            "            if agent_type == \"openai-tools\":",
            "                runnable = create_openai_tools_agent(",
            "                    cast(BaseLanguageModel, llm), tools, prompt",
            "                )",
            "            else:",
            "                runnable = create_tool_calling_agent(",
            "                    cast(BaseLanguageModel, llm), tools, prompt",
            "                )",
            "            agent = RunnableMultiActionAgent(",
            "                runnable=runnable,",
            "                input_keys_arg=[\"input\"],",
            "                return_keys_arg=[\"output\"],",
            "            )",
            "    else:",
            "        raise ValueError(",
            "            f\"Agent type {agent_type} not supported at the moment. Must be one of \"",
            "            \"'tool-calling', 'openai-tools', 'openai-functions', or \"",
            "            \"'zero-shot-react-description'.\"",
            "        )",
            "    return AgentExecutor(",
            "        agent=agent,",
            "        tools=tools,",
            "        callback_manager=callback_manager,",
            "        verbose=verbose,",
            "        return_intermediate_steps=return_intermediate_steps,",
            "        max_iterations=max_iterations,",
            "        max_execution_time=max_execution_time,",
            "        early_stopping_method=early_stopping_method,",
            "        **(agent_executor_kwargs or {}),",
            "    )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "pypdf.generic._data_structures",
            "libs.experimental.langchain_experimental.agents.agent_toolkits.pandas.base.create_pandas_dataframe_agent.tools"
        ]
    },
    "libs/experimental/langchain_experimental/agents/agent_toolkits/spark/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "     max_execution_time: Optional[float] = None,"
            },
            "1": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 43,
                "PatchRowcode": "     early_stopping_method: str = \"force\","
            },
            "2": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "     agent_executor_kwargs: Optional[Dict[str, Any]] = None,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+    allow_dangerous_code: bool = False,"
            },
            "4": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "     **kwargs: Any,"
            },
            "5": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " ) -> AgentExecutor:"
            },
            "6": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\"Construct a Spark agent from an LLM and dataframe.\"\"\""
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+    \"\"\"Construct a Spark agent from an LLM and dataframe."
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+    Security Notice:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+        This agent relies on access to a python repl tool which can execute"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+        arbitrary code. This can be dangerous and requires a specially sandboxed"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+        environment to be safely used. Failure to run this code in a properly"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+        sandboxed environment can lead to arbitrary code execution vulnerabilities,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+        which can lead to data breaches, data loss, or other security incidents."
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+        Do not use this code with untrusted inputs, with elevated permissions,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+        or without consulting your security team about proper sandboxing!"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+        You must opt in to use this functionality by setting allow_dangerous_code=True."
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+    Args:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+        allow_dangerous_code: bool, default False"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+            This agent relies on access to a python repl tool which can execute"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+            arbitrary code. This can be dangerous and requires a specially sandboxed"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+            environment to be safely used."
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+            Failure to properly sandbox this class can lead to arbitrary code execution"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+            vulnerabilities, which can lead to data breaches, data loss, or"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+            other security incidents."
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+            You must opt in to use this functionality by setting"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+            allow_dangerous_code=True."
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+    \"\"\""
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+    if not allow_dangerous_code:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+        raise ValueError("
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+            \"This agent relies on access to a python repl tool which can execute \""
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+            \"arbitrary code. This can be dangerous and requires a specially sandboxed \""
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+            \"environment to be safely used. Please read the security notice in the \""
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+            \"doc-string of this function. You must opt-in to use this functionality \""
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+            \"by setting allow_dangerous_code=True.\""
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+            \"For general security guidelines, please see: \""
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+            \"https://python.langchain.com/v0.1/docs/security/\""
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+        )"
            },
            "42": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 83,
                "PatchRowcode": " "
            },
            "43": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "     if not _validate_spark_df(df) and not _validate_spark_connect_df(df):"
            },
            "44": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "         raise ImportError(\"Spark is not installed. run `pip install pyspark`.\")"
            }
        },
        "frontPatchFile": [
            "\"\"\"Agent for working with pandas objects.\"\"\"",
            "from typing import Any, Dict, List, Optional",
            "",
            "from langchain.agents.agent import AgentExecutor",
            "from langchain.agents.mrkl.base import ZeroShotAgent",
            "from langchain.chains.llm import LLMChain",
            "from langchain_core.callbacks.base import BaseCallbackManager",
            "from langchain_core.language_models import BaseLLM",
            "",
            "from langchain_experimental.agents.agent_toolkits.spark.prompt import PREFIX, SUFFIX",
            "from langchain_experimental.tools.python.tool import PythonAstREPLTool",
            "",
            "",
            "def _validate_spark_df(df: Any) -> bool:",
            "    try:",
            "        from pyspark.sql import DataFrame as SparkLocalDataFrame",
            "",
            "        return isinstance(df, SparkLocalDataFrame)",
            "    except ImportError:",
            "        return False",
            "",
            "",
            "def _validate_spark_connect_df(df: Any) -> bool:",
            "    try:",
            "        from pyspark.sql.connect.dataframe import DataFrame as SparkConnectDataFrame",
            "",
            "        return isinstance(df, SparkConnectDataFrame)",
            "    except ImportError:",
            "        return False",
            "",
            "",
            "def create_spark_dataframe_agent(",
            "    llm: BaseLLM,",
            "    df: Any,",
            "    callback_manager: Optional[BaseCallbackManager] = None,",
            "    prefix: str = PREFIX,",
            "    suffix: str = SUFFIX,",
            "    input_variables: Optional[List[str]] = None,",
            "    verbose: bool = False,",
            "    return_intermediate_steps: bool = False,",
            "    max_iterations: Optional[int] = 15,",
            "    max_execution_time: Optional[float] = None,",
            "    early_stopping_method: str = \"force\",",
            "    agent_executor_kwargs: Optional[Dict[str, Any]] = None,",
            "    **kwargs: Any,",
            ") -> AgentExecutor:",
            "    \"\"\"Construct a Spark agent from an LLM and dataframe.\"\"\"",
            "",
            "    if not _validate_spark_df(df) and not _validate_spark_connect_df(df):",
            "        raise ImportError(\"Spark is not installed. run `pip install pyspark`.\")",
            "",
            "    if input_variables is None:",
            "        input_variables = [\"df\", \"input\", \"agent_scratchpad\"]",
            "    tools = [PythonAstREPLTool(locals={\"df\": df})]",
            "    prompt = ZeroShotAgent.create_prompt(",
            "        tools, prefix=prefix, suffix=suffix, input_variables=input_variables",
            "    )",
            "    partial_prompt = prompt.partial(df=str(df.first()))",
            "    llm_chain = LLMChain(",
            "        llm=llm,",
            "        prompt=partial_prompt,",
            "        callback_manager=callback_manager,",
            "    )",
            "    tool_names = [tool.name for tool in tools]",
            "    agent = ZeroShotAgent(",
            "        llm_chain=llm_chain,",
            "        allowed_tools=tool_names,",
            "        callback_manager=callback_manager,",
            "        **kwargs,",
            "    )",
            "    return AgentExecutor.from_agent_and_tools(",
            "        agent=agent,",
            "        tools=tools,",
            "        callback_manager=callback_manager,",
            "        verbose=verbose,",
            "        return_intermediate_steps=return_intermediate_steps,",
            "        max_iterations=max_iterations,",
            "        max_execution_time=max_execution_time,",
            "        early_stopping_method=early_stopping_method,",
            "        **(agent_executor_kwargs or {}),",
            "    )"
        ],
        "afterPatchFile": [
            "\"\"\"Agent for working with pandas objects.\"\"\"",
            "from typing import Any, Dict, List, Optional",
            "",
            "from langchain.agents.agent import AgentExecutor",
            "from langchain.agents.mrkl.base import ZeroShotAgent",
            "from langchain.chains.llm import LLMChain",
            "from langchain_core.callbacks.base import BaseCallbackManager",
            "from langchain_core.language_models import BaseLLM",
            "",
            "from langchain_experimental.agents.agent_toolkits.spark.prompt import PREFIX, SUFFIX",
            "from langchain_experimental.tools.python.tool import PythonAstREPLTool",
            "",
            "",
            "def _validate_spark_df(df: Any) -> bool:",
            "    try:",
            "        from pyspark.sql import DataFrame as SparkLocalDataFrame",
            "",
            "        return isinstance(df, SparkLocalDataFrame)",
            "    except ImportError:",
            "        return False",
            "",
            "",
            "def _validate_spark_connect_df(df: Any) -> bool:",
            "    try:",
            "        from pyspark.sql.connect.dataframe import DataFrame as SparkConnectDataFrame",
            "",
            "        return isinstance(df, SparkConnectDataFrame)",
            "    except ImportError:",
            "        return False",
            "",
            "",
            "def create_spark_dataframe_agent(",
            "    llm: BaseLLM,",
            "    df: Any,",
            "    callback_manager: Optional[BaseCallbackManager] = None,",
            "    prefix: str = PREFIX,",
            "    suffix: str = SUFFIX,",
            "    input_variables: Optional[List[str]] = None,",
            "    verbose: bool = False,",
            "    return_intermediate_steps: bool = False,",
            "    max_iterations: Optional[int] = 15,",
            "    max_execution_time: Optional[float] = None,",
            "    early_stopping_method: str = \"force\",",
            "    agent_executor_kwargs: Optional[Dict[str, Any]] = None,",
            "    allow_dangerous_code: bool = False,",
            "    **kwargs: Any,",
            ") -> AgentExecutor:",
            "    \"\"\"Construct a Spark agent from an LLM and dataframe.",
            "",
            "    Security Notice:",
            "        This agent relies on access to a python repl tool which can execute",
            "        arbitrary code. This can be dangerous and requires a specially sandboxed",
            "        environment to be safely used. Failure to run this code in a properly",
            "        sandboxed environment can lead to arbitrary code execution vulnerabilities,",
            "        which can lead to data breaches, data loss, or other security incidents.",
            "",
            "        Do not use this code with untrusted inputs, with elevated permissions,",
            "        or without consulting your security team about proper sandboxing!",
            "",
            "        You must opt in to use this functionality by setting allow_dangerous_code=True.",
            "",
            "    Args:",
            "        allow_dangerous_code: bool, default False",
            "            This agent relies on access to a python repl tool which can execute",
            "            arbitrary code. This can be dangerous and requires a specially sandboxed",
            "            environment to be safely used.",
            "            Failure to properly sandbox this class can lead to arbitrary code execution",
            "            vulnerabilities, which can lead to data breaches, data loss, or",
            "            other security incidents.",
            "            You must opt in to use this functionality by setting",
            "            allow_dangerous_code=True.",
            "    \"\"\"",
            "    if not allow_dangerous_code:",
            "        raise ValueError(",
            "            \"This agent relies on access to a python repl tool which can execute \"",
            "            \"arbitrary code. This can be dangerous and requires a specially sandboxed \"",
            "            \"environment to be safely used. Please read the security notice in the \"",
            "            \"doc-string of this function. You must opt-in to use this functionality \"",
            "            \"by setting allow_dangerous_code=True.\"",
            "            \"For general security guidelines, please see: \"",
            "            \"https://python.langchain.com/v0.1/docs/security/\"",
            "        )",
            "",
            "    if not _validate_spark_df(df) and not _validate_spark_connect_df(df):",
            "        raise ImportError(\"Spark is not installed. run `pip install pyspark`.\")",
            "",
            "    if input_variables is None:",
            "        input_variables = [\"df\", \"input\", \"agent_scratchpad\"]",
            "    tools = [PythonAstREPLTool(locals={\"df\": df})]",
            "    prompt = ZeroShotAgent.create_prompt(",
            "        tools, prefix=prefix, suffix=suffix, input_variables=input_variables",
            "    )",
            "    partial_prompt = prompt.partial(df=str(df.first()))",
            "    llm_chain = LLMChain(",
            "        llm=llm,",
            "        prompt=partial_prompt,",
            "        callback_manager=callback_manager,",
            "    )",
            "    tool_names = [tool.name for tool in tools]",
            "    agent = ZeroShotAgent(",
            "        llm_chain=llm_chain,",
            "        allowed_tools=tool_names,",
            "        callback_manager=callback_manager,",
            "        **kwargs,",
            "    )",
            "    return AgentExecutor.from_agent_and_tools(",
            "        agent=agent,",
            "        tools=tools,",
            "        callback_manager=callback_manager,",
            "        verbose=verbose,",
            "        return_intermediate_steps=return_intermediate_steps,",
            "        max_iterations=max_iterations,",
            "        max_execution_time=max_execution_time,",
            "        early_stopping_method=early_stopping_method,",
            "        **(agent_executor_kwargs or {}),",
            "    )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "47": [
                "create_spark_dataframe_agent"
            ]
        },
        "addLocation": [
            "libs.experimental.langchain_experimental.agents.agent_toolkits.spark.base.create_spark_dataframe_agent.input_variables",
            "pypdf.generic._data_structures",
            "libs.experimental.langchain_experimental.agents.agent_toolkits.spark.base.create_spark_dataframe_agent.tools"
        ]
    },
    "libs/experimental/langchain_experimental/agents/agent_toolkits/xorbits/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "     max_execution_time: Optional[float] = None,"
            },
            "1": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "     early_stopping_method: str = \"force\","
            },
            "2": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "     agent_executor_kwargs: Optional[Dict[str, Any]] = None,"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+    allow_dangerous_code: bool = False,"
            },
            "4": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     **kwargs: Dict[str, Any],"
            },
            "5": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 34,
                "PatchRowcode": " ) -> AgentExecutor:"
            },
            "6": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    \"\"\"Construct a xorbits agent from an LLM and dataframe.\"\"\""
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 35,
                "PatchRowcode": "+    \"\"\"Construct a xorbits agent from an LLM and dataframe."
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 36,
                "PatchRowcode": "+"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 37,
                "PatchRowcode": "+    Security Notice:"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 38,
                "PatchRowcode": "+        This agent relies on access to a python repl tool which can execute"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+        arbitrary code. This can be dangerous and requires a specially sandboxed"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+        environment to be safely used. Failure to run this code in a properly"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 41,
                "PatchRowcode": "+        sandboxed environment can lead to arbitrary code execution vulnerabilities,"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 42,
                "PatchRowcode": "+        which can lead to data breaches, data loss, or other security incidents."
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 44,
                "PatchRowcode": "+        Do not use this code with untrusted inputs, with elevated permissions,"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 45,
                "PatchRowcode": "+        or without consulting your security team about proper sandboxing!"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 47,
                "PatchRowcode": "+        You must opt in to use this functionality by setting allow_dangerous_code=True."
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 48,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 49,
                "PatchRowcode": "+    Args:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 50,
                "PatchRowcode": "+        allow_dangerous_code: bool, default False"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+            This agent relies on access to a python repl tool which can execute"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+            arbitrary code. This can be dangerous and requires a specially sandboxed"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+            environment to be safely used."
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+            Failure to properly sandbox this class can lead to arbitrary code execution"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+            vulnerabilities, which can lead to data breaches, data loss, or"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+            other security incidents."
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+            You must opt in to use this functionality by setting"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+            allow_dangerous_code=True."
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+    \"\"\""
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+    if not allow_dangerous_code:"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+        raise ValueError("
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+            \"This agent relies on access to a python repl tool which can execute \""
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+            \"arbitrary code. This can be dangerous and requires a specially sandboxed \""
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+            \"environment to be safely used. Please read the security notice in the \""
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+            \"doc-string of this function. You must opt-in to use this functionality \""
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+            \"by setting allow_dangerous_code=True.\""
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+            \"For general security guidelines, please see: \""
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+            \"https://python.langchain.com/v0.1/docs/security/\""
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+        )"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+"
            },
            "43": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 71,
                "PatchRowcode": "     try:"
            },
            "44": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 72,
                "PatchRowcode": "         from xorbits import numpy as np"
            },
            "45": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "         from xorbits import pandas as pd"
            }
        },
        "frontPatchFile": [
            "\"\"\"Agent for working with xorbits objects.\"\"\"",
            "from typing import Any, Dict, List, Optional",
            "",
            "from langchain.agents.agent import AgentExecutor",
            "from langchain.agents.mrkl.base import ZeroShotAgent",
            "from langchain.chains.llm import LLMChain",
            "from langchain_core.callbacks.base import BaseCallbackManager",
            "from langchain_core.language_models import BaseLLM",
            "",
            "from langchain_experimental.agents.agent_toolkits.xorbits.prompt import (",
            "    NP_PREFIX,",
            "    NP_SUFFIX,",
            "    PD_PREFIX,",
            "    PD_SUFFIX,",
            ")",
            "from langchain_experimental.tools.python.tool import PythonAstREPLTool",
            "",
            "",
            "def create_xorbits_agent(",
            "    llm: BaseLLM,",
            "    data: Any,",
            "    callback_manager: Optional[BaseCallbackManager] = None,",
            "    prefix: str = \"\",",
            "    suffix: str = \"\",",
            "    input_variables: Optional[List[str]] = None,",
            "    verbose: bool = False,",
            "    return_intermediate_steps: bool = False,",
            "    max_iterations: Optional[int] = 15,",
            "    max_execution_time: Optional[float] = None,",
            "    early_stopping_method: str = \"force\",",
            "    agent_executor_kwargs: Optional[Dict[str, Any]] = None,",
            "    **kwargs: Dict[str, Any],",
            ") -> AgentExecutor:",
            "    \"\"\"Construct a xorbits agent from an LLM and dataframe.\"\"\"",
            "    try:",
            "        from xorbits import numpy as np",
            "        from xorbits import pandas as pd",
            "    except ImportError:",
            "        raise ImportError(",
            "            \"Xorbits package not installed, please install with `pip install xorbits`\"",
            "        )",
            "",
            "    if not isinstance(data, (pd.DataFrame, np.ndarray)):",
            "        raise ValueError(",
            "            f\"Expected Xorbits DataFrame or ndarray object, got {type(data)}\"",
            "        )",
            "    if input_variables is None:",
            "        input_variables = [\"data\", \"input\", \"agent_scratchpad\"]",
            "    tools = [PythonAstREPLTool(locals={\"data\": data})]",
            "    prompt, partial_input = None, None",
            "",
            "    if isinstance(data, pd.DataFrame):",
            "        prompt = ZeroShotAgent.create_prompt(",
            "            tools,",
            "            prefix=PD_PREFIX if prefix == \"\" else prefix,",
            "            suffix=PD_SUFFIX if suffix == \"\" else suffix,",
            "            input_variables=input_variables,",
            "        )",
            "        partial_input = str(data.head())",
            "    else:",
            "        prompt = ZeroShotAgent.create_prompt(",
            "            tools,",
            "            prefix=NP_PREFIX if prefix == \"\" else prefix,",
            "            suffix=NP_SUFFIX if suffix == \"\" else suffix,",
            "            input_variables=input_variables,",
            "        )",
            "        partial_input = str(data[: len(data) // 2])",
            "    partial_prompt = prompt.partial(data=partial_input)",
            "    llm_chain = LLMChain(",
            "        llm=llm,",
            "        prompt=partial_prompt,",
            "        callback_manager=callback_manager,",
            "    )",
            "    tool_names = [tool.name for tool in tools]",
            "    agent = ZeroShotAgent(",
            "        llm_chain=llm_chain,",
            "        allowed_tools=tool_names,",
            "        callback_manager=callback_manager,",
            "        **kwargs,",
            "    )",
            "    return AgentExecutor.from_agent_and_tools(",
            "        agent=agent,",
            "        tools=tools,",
            "        callback_manager=callback_manager,",
            "        verbose=verbose,",
            "        return_intermediate_steps=return_intermediate_steps,",
            "        max_iterations=max_iterations,",
            "        max_execution_time=max_execution_time,",
            "        early_stopping_method=early_stopping_method,",
            "        **(agent_executor_kwargs or {}),",
            "    )"
        ],
        "afterPatchFile": [
            "\"\"\"Agent for working with xorbits objects.\"\"\"",
            "from typing import Any, Dict, List, Optional",
            "",
            "from langchain.agents.agent import AgentExecutor",
            "from langchain.agents.mrkl.base import ZeroShotAgent",
            "from langchain.chains.llm import LLMChain",
            "from langchain_core.callbacks.base import BaseCallbackManager",
            "from langchain_core.language_models import BaseLLM",
            "",
            "from langchain_experimental.agents.agent_toolkits.xorbits.prompt import (",
            "    NP_PREFIX,",
            "    NP_SUFFIX,",
            "    PD_PREFIX,",
            "    PD_SUFFIX,",
            ")",
            "from langchain_experimental.tools.python.tool import PythonAstREPLTool",
            "",
            "",
            "def create_xorbits_agent(",
            "    llm: BaseLLM,",
            "    data: Any,",
            "    callback_manager: Optional[BaseCallbackManager] = None,",
            "    prefix: str = \"\",",
            "    suffix: str = \"\",",
            "    input_variables: Optional[List[str]] = None,",
            "    verbose: bool = False,",
            "    return_intermediate_steps: bool = False,",
            "    max_iterations: Optional[int] = 15,",
            "    max_execution_time: Optional[float] = None,",
            "    early_stopping_method: str = \"force\",",
            "    agent_executor_kwargs: Optional[Dict[str, Any]] = None,",
            "    allow_dangerous_code: bool = False,",
            "    **kwargs: Dict[str, Any],",
            ") -> AgentExecutor:",
            "    \"\"\"Construct a xorbits agent from an LLM and dataframe.",
            "",
            "    Security Notice:",
            "        This agent relies on access to a python repl tool which can execute",
            "        arbitrary code. This can be dangerous and requires a specially sandboxed",
            "        environment to be safely used. Failure to run this code in a properly",
            "        sandboxed environment can lead to arbitrary code execution vulnerabilities,",
            "        which can lead to data breaches, data loss, or other security incidents.",
            "",
            "        Do not use this code with untrusted inputs, with elevated permissions,",
            "        or without consulting your security team about proper sandboxing!",
            "",
            "        You must opt in to use this functionality by setting allow_dangerous_code=True.",
            "",
            "    Args:",
            "        allow_dangerous_code: bool, default False",
            "            This agent relies on access to a python repl tool which can execute",
            "            arbitrary code. This can be dangerous and requires a specially sandboxed",
            "            environment to be safely used.",
            "            Failure to properly sandbox this class can lead to arbitrary code execution",
            "            vulnerabilities, which can lead to data breaches, data loss, or",
            "            other security incidents.",
            "            You must opt in to use this functionality by setting",
            "            allow_dangerous_code=True.",
            "    \"\"\"",
            "    if not allow_dangerous_code:",
            "        raise ValueError(",
            "            \"This agent relies on access to a python repl tool which can execute \"",
            "            \"arbitrary code. This can be dangerous and requires a specially sandboxed \"",
            "            \"environment to be safely used. Please read the security notice in the \"",
            "            \"doc-string of this function. You must opt-in to use this functionality \"",
            "            \"by setting allow_dangerous_code=True.\"",
            "            \"For general security guidelines, please see: \"",
            "            \"https://python.langchain.com/v0.1/docs/security/\"",
            "        )",
            "",
            "    try:",
            "        from xorbits import numpy as np",
            "        from xorbits import pandas as pd",
            "    except ImportError:",
            "        raise ImportError(",
            "            \"Xorbits package not installed, please install with `pip install xorbits`\"",
            "        )",
            "",
            "    if not isinstance(data, (pd.DataFrame, np.ndarray)):",
            "        raise ValueError(",
            "            f\"Expected Xorbits DataFrame or ndarray object, got {type(data)}\"",
            "        )",
            "    if input_variables is None:",
            "        input_variables = [\"data\", \"input\", \"agent_scratchpad\"]",
            "    tools = [PythonAstREPLTool(locals={\"data\": data})]",
            "    prompt, partial_input = None, None",
            "",
            "    if isinstance(data, pd.DataFrame):",
            "        prompt = ZeroShotAgent.create_prompt(",
            "            tools,",
            "            prefix=PD_PREFIX if prefix == \"\" else prefix,",
            "            suffix=PD_SUFFIX if suffix == \"\" else suffix,",
            "            input_variables=input_variables,",
            "        )",
            "        partial_input = str(data.head())",
            "    else:",
            "        prompt = ZeroShotAgent.create_prompt(",
            "            tools,",
            "            prefix=NP_PREFIX if prefix == \"\" else prefix,",
            "            suffix=NP_SUFFIX if suffix == \"\" else suffix,",
            "            input_variables=input_variables,",
            "        )",
            "        partial_input = str(data[: len(data) // 2])",
            "    partial_prompt = prompt.partial(data=partial_input)",
            "    llm_chain = LLMChain(",
            "        llm=llm,",
            "        prompt=partial_prompt,",
            "        callback_manager=callback_manager,",
            "    )",
            "    tool_names = [tool.name for tool in tools]",
            "    agent = ZeroShotAgent(",
            "        llm_chain=llm_chain,",
            "        allowed_tools=tool_names,",
            "        callback_manager=callback_manager,",
            "        **kwargs,",
            "    )",
            "    return AgentExecutor.from_agent_and_tools(",
            "        agent=agent,",
            "        tools=tools,",
            "        callback_manager=callback_manager,",
            "        verbose=verbose,",
            "        return_intermediate_steps=return_intermediate_steps,",
            "        max_iterations=max_iterations,",
            "        max_execution_time=max_execution_time,",
            "        early_stopping_method=early_stopping_method,",
            "        **(agent_executor_kwargs or {}),",
            "    )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "34": [
                "create_xorbits_agent"
            ]
        },
        "addLocation": [
            "libs.experimental.langchain_experimental.agents.agent_toolkits.xorbits.base.create_xorbits_agent.input_variables",
            "libs.experimental.langchain_experimental.agents.agent_toolkits.xorbits.base.create_xorbits_agent.tools",
            "pypdf.generic._data_structures"
        ]
    },
    "libs/experimental/langchain_experimental/pal_chain/base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from langchain_experimental.pal_chain.colored_object_prompt import COLORED_OBJECT_PROMPT"
            },
            "2": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from langchain_experimental.pal_chain.math_prompt import MATH_PROMPT"
            },
            "3": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from langchain_experimental.pydantic_v1 import Extra, Field"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+from langchain_experimental.pydantic_v1 import Extra, Field, root_validator"
            },
            "5": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " COMMAND_EXECUTION_FUNCTIONS = [\"system\", \"exec\", \"execfile\", \"eval\", \"__import__\"]"
            },
            "7": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " COMMAND_EXECUTION_ATTRIBUTES = ["
            },
            "8": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": 129,
                "PatchRowcode": "     \"\"\"Validations to perform on the generated code.\"\"\""
            },
            "9": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": 130,
                "PatchRowcode": "     timeout: Optional[int] = 10"
            },
            "10": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": 131,
                "PatchRowcode": "     \"\"\"Timeout in seconds for the generated code to execute.\"\"\""
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 132,
                "PatchRowcode": "+    allow_dangerous_code: bool = False"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 133,
                "PatchRowcode": "+    \"\"\"This chain relies on the execution of generated code, which can be dangerous."
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 134,
                "PatchRowcode": "+    "
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+    This class implements an AI technique that generates and evaluates"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 136,
                "PatchRowcode": "+    Python code, which can be dangerous and requires a specially sandboxed"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 137,
                "PatchRowcode": "+    environment to be safely used. While this class implements some basic guardrails"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 138,
                "PatchRowcode": "+    by limiting available locals/globals and by parsing and inspecting"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 139,
                "PatchRowcode": "+    the generated Python AST using `PALValidation`, those guardrails will not"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 140,
                "PatchRowcode": "+    deter sophisticated attackers and are not a replacement for a proper sandbox."
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+    Do not use this class on untrusted inputs, with elevated permissions,"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+    or without consulting your security team about proper sandboxing!"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+    "
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+    Failure to properly sandbox this class can lead to arbitrary code execution"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 145,
                "PatchRowcode": "+    vulnerabilities, which can lead to data breaches, data loss, or other security"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+    incidents."
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+    \"\"\""
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+    @root_validator(pre=False, skip_on_failure=True)"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+    def post_init(cls, values: Dict) -> Dict:"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+        if not values[\"allow_dangerous_code\"]:"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+            raise ValueError("
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+                \"This chain relies on the execution of generated code, \""
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+                \"which can be dangerous. \""
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 155,
                "PatchRowcode": "+                \"Please read the security notice for this class, and only \""
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 156,
                "PatchRowcode": "+                \"use it if you understand the security implications. \""
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 157,
                "PatchRowcode": "+                \"If you want to proceed, you will need to opt-in, by setting \""
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 158,
                "PatchRowcode": "+                \"`allow_dangerous_code` to `True`.\""
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 159,
                "PatchRowcode": "+            )"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 160,
                "PatchRowcode": "+"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 161,
                "PatchRowcode": "+        return values"
            },
            "41": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 162,
                "PatchRowcode": " "
            },
            "42": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 163,
                "PatchRowcode": "     class Config:"
            },
            "43": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 164,
                "PatchRowcode": "         \"\"\"Configuration for this pydantic object.\"\"\""
            }
        },
        "frontPatchFile": [
            "\"\"\"Implements Program-Aided Language Models.",
            "",
            "This module implements the Program-Aided Language Models (PAL) for generating code",
            "solutions. PAL is a technique described in the paper \"Program-Aided Language Models\"",
            "(https://arxiv.org/pdf/2211.10435.pdf).",
            "\"\"\"",
            "",
            "from __future__ import annotations",
            "",
            "import ast",
            "from typing import Any, Dict, List, Optional",
            "",
            "from langchain.chains.base import Chain",
            "from langchain.chains.llm import LLMChain",
            "from langchain_community.utilities import PythonREPL",
            "from langchain_core.callbacks.manager import CallbackManagerForChainRun",
            "from langchain_core.language_models import BaseLanguageModel",
            "",
            "from langchain_experimental.pal_chain.colored_object_prompt import COLORED_OBJECT_PROMPT",
            "from langchain_experimental.pal_chain.math_prompt import MATH_PROMPT",
            "from langchain_experimental.pydantic_v1 import Extra, Field",
            "",
            "COMMAND_EXECUTION_FUNCTIONS = [\"system\", \"exec\", \"execfile\", \"eval\", \"__import__\"]",
            "COMMAND_EXECUTION_ATTRIBUTES = [",
            "    \"__import__\",",
            "    \"__subclasses__\",",
            "    \"__builtins__\",",
            "    \"__globals__\",",
            "    \"__getattribute__\",",
            "    \"__bases__\",",
            "    \"__mro__\",",
            "    \"__base__\",",
            "]",
            "",
            "",
            "class PALValidation:",
            "    \"\"\"Validation for PAL generated code.\"\"\"",
            "",
            "    SOLUTION_EXPRESSION_TYPE_FUNCTION = ast.FunctionDef",
            "    SOLUTION_EXPRESSION_TYPE_VARIABLE = ast.Name",
            "",
            "    def __init__(",
            "        self,",
            "        solution_expression_name: Optional[str] = None,",
            "        solution_expression_type: Optional[type] = None,",
            "        allow_imports: bool = False,",
            "        allow_command_exec: bool = False,",
            "    ):",
            "        \"\"\"Initialize a PALValidation instance.",
            "",
            "        Args:",
            "            solution_expression_name (str): Name of the expected solution expression.",
            "                If passed, solution_expression_type must be passed as well.",
            "            solution_expression_type (str): AST type of the expected solution",
            "                expression. If passed, solution_expression_name must be passed as well.",
            "                Must be one of PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,",
            "                PALValidation.SOLUTION_EXPRESSION_TYPE_VARIABLE.",
            "            allow_imports (bool): Allow import statements.",
            "            allow_command_exec (bool): Allow using known command execution functions.",
            "        \"\"\"",
            "        self.solution_expression_name = solution_expression_name",
            "        self.solution_expression_type = solution_expression_type",
            "",
            "        if solution_expression_name is not None:",
            "            if not isinstance(self.solution_expression_name, str):",
            "                raise ValueError(",
            "                    f\"Expected solution_expression_name to be str, \"",
            "                    f\"instead found {type(self.solution_expression_name)}\"",
            "                )",
            "        if solution_expression_type is not None:",
            "            if (",
            "                self.solution_expression_type",
            "                is not self.SOLUTION_EXPRESSION_TYPE_FUNCTION",
            "                and self.solution_expression_type",
            "                is not self.SOLUTION_EXPRESSION_TYPE_VARIABLE",
            "            ):",
            "                raise ValueError(",
            "                    f\"Expected solution_expression_type to be one of \"",
            "                    f\"({self.SOLUTION_EXPRESSION_TYPE_FUNCTION},\"",
            "                    f\"{self.SOLUTION_EXPRESSION_TYPE_VARIABLE}),\"",
            "                    f\"instead found {self.solution_expression_type}\"",
            "                )",
            "",
            "        if solution_expression_name is not None and solution_expression_type is None:",
            "            raise TypeError(",
            "                \"solution_expression_name \"",
            "                \"requires solution_expression_type to be passed as well\"",
            "            )",
            "        if solution_expression_name is None and solution_expression_type is not None:",
            "            raise TypeError(",
            "                \"solution_expression_type \"",
            "                \"requires solution_expression_name to be passed as well\"",
            "            )",
            "",
            "        self.allow_imports = allow_imports",
            "        self.allow_command_exec = allow_command_exec",
            "",
            "",
            "class PALChain(Chain):",
            "    \"\"\"Chain that implements Program-Aided Language Models (PAL).",
            "",
            "    This class implements the Program-Aided Language Models (PAL) for generating code",
            "    solutions. PAL is a technique described in the paper \"Program-Aided Language Models\"",
            "    (https://arxiv.org/pdf/2211.10435.pdf).",
            "",
            "    *Security note*: This class implements an AI technique that generates and evaluates",
            "        Python code, which can be dangerous and requires a specially sandboxed",
            "        environment to be safely used. While this class implements some basic guardrails",
            "        by limiting available locals/globals and by parsing and inspecting",
            "        the generated Python AST using `PALValidation`, those guardrails will not",
            "        deter sophisticated attackers and are not a replacement for a proper sandbox.",
            "        Do not use this class on untrusted inputs, with elevated permissions,",
            "        or without consulting your security team about proper sandboxing!",
            "    \"\"\"",
            "",
            "    llm_chain: LLMChain",
            "    stop: str = \"\\n\\n\"",
            "    \"\"\"Stop token to use when generating code.\"\"\"",
            "    get_answer_expr: str = \"print(solution())\"",
            "    \"\"\"Expression to use to get the answer from the generated code.\"\"\"",
            "    python_globals: Optional[Dict[str, Any]] = None",
            "    \"\"\"Python globals and locals to use when executing the generated code.\"\"\"",
            "    python_locals: Optional[Dict[str, Any]] = None",
            "    \"\"\"Python globals and locals to use when executing the generated code.\"\"\"",
            "    output_key: str = \"result\"  #: :meta private:",
            "    return_intermediate_steps: bool = False",
            "    \"\"\"Whether to return intermediate steps in the generated code.\"\"\"",
            "    code_validations: PALValidation = Field(default_factory=PALValidation)",
            "    \"\"\"Validations to perform on the generated code.\"\"\"",
            "    timeout: Optional[int] = 10",
            "    \"\"\"Timeout in seconds for the generated code to execute.\"\"\"",
            "",
            "    class Config:",
            "        \"\"\"Configuration for this pydantic object.\"\"\"",
            "",
            "        extra = Extra.forbid",
            "        arbitrary_types_allowed = True",
            "",
            "    @property",
            "    def input_keys(self) -> List[str]:",
            "        \"\"\"Return the singular input key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        return self.llm_chain.prompt.input_variables",
            "",
            "    @property",
            "    def output_keys(self) -> List[str]:",
            "        \"\"\"Return the singular output key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        if not self.return_intermediate_steps:",
            "            return [self.output_key]",
            "        else:",
            "            return [self.output_key, \"intermediate_steps\"]",
            "",
            "    def _call(",
            "        self,",
            "        inputs: Dict[str, Any],",
            "        run_manager: Optional[CallbackManagerForChainRun] = None,",
            "    ) -> Dict[str, str]:",
            "        _run_manager = run_manager or CallbackManagerForChainRun.get_noop_manager()",
            "        code = self.llm_chain.predict(",
            "            stop=[self.stop], callbacks=_run_manager.get_child(), **inputs",
            "        )",
            "        _run_manager.on_text(code, color=\"green\", end=\"\\n\", verbose=self.verbose)",
            "        PALChain.validate_code(code, self.code_validations)",
            "",
            "        # TODO: look into why mypy thinks PythonREPL's type here is `Any`",
            "        #       and therefore not callable",
            "        repl = PythonREPL(",
            "            _globals=self.python_globals,",
            "            _locals=self.python_locals,",
            "        )  # type: ignore[misc]",
            "        res = repl.run(code + f\"\\n{self.get_answer_expr}\", timeout=self.timeout)",
            "        output = {self.output_key: res.strip()}",
            "        if self.return_intermediate_steps:",
            "            output[\"intermediate_steps\"] = code",
            "        return output",
            "",
            "    @classmethod",
            "    def validate_code(cls, code: str, code_validations: PALValidation) -> None:",
            "        try:",
            "            code_tree = ast.parse(code)",
            "        except (SyntaxError, UnicodeDecodeError):",
            "            raise ValueError(f\"Generated code is not valid python code: {code}\")",
            "        except TypeError:",
            "            raise ValueError(",
            "                f\"Generated code is expected to be a string, \"",
            "                f\"instead found {type(code)}\"",
            "            )",
            "        except OverflowError:",
            "            raise ValueError(",
            "                f\"Generated code too long / complex to be parsed by ast: {code}\"",
            "            )",
            "",
            "        found_solution_expr = False",
            "        if code_validations.solution_expression_name is None:",
            "            # Skip validation if no solution_expression_name was given",
            "            found_solution_expr = True",
            "",
            "        has_imports = False",
            "        top_level_nodes = list(ast.iter_child_nodes(code_tree))",
            "        for node in top_level_nodes:",
            "            if (",
            "                code_validations.solution_expression_name is not None",
            "                and code_validations.solution_expression_type is not None",
            "            ):",
            "                # Check root nodes (like func def)",
            "                if (",
            "                    isinstance(node, code_validations.solution_expression_type)",
            "                    and hasattr(node, \"name\")",
            "                    and node.name == code_validations.solution_expression_name",
            "                ):",
            "                    found_solution_expr = True",
            "                # Check assigned nodes (like answer variable)",
            "                if isinstance(node, ast.Assign):",
            "                    for target_node in node.targets:",
            "                        if (",
            "                            isinstance(",
            "                                target_node, code_validations.solution_expression_type",
            "                            )",
            "                            and hasattr(target_node, \"id\")",
            "                            and target_node.id",
            "                            == code_validations.solution_expression_name",
            "                        ):",
            "                            found_solution_expr = True",
            "            if isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom):",
            "                has_imports = True",
            "",
            "        if not found_solution_expr:",
            "            raise ValueError(",
            "                f\"Generated code is missing the solution expression: \"",
            "                f\"{code_validations.solution_expression_name} of type: \"",
            "                f\"{code_validations.solution_expression_type}\"",
            "            )",
            "",
            "        if not code_validations.allow_imports and has_imports:",
            "            raise ValueError(f\"Generated code has disallowed imports: {code}\")",
            "",
            "        if (",
            "            not code_validations.allow_command_exec",
            "            or not code_validations.allow_imports",
            "        ):",
            "            for node in ast.walk(code_tree):",
            "                if (",
            "                    not code_validations.allow_command_exec",
            "                    and isinstance(node, ast.Attribute)",
            "                    and node.attr in COMMAND_EXECUTION_ATTRIBUTES",
            "                ):",
            "                    raise ValueError(",
            "                        f\"Found illegal command execution function \"",
            "                        f\"{node.attr} in code {code}\"",
            "                    )",
            "                if (not code_validations.allow_command_exec) and isinstance(",
            "                    node, ast.Call",
            "                ):",
            "                    if (",
            "                        hasattr(node.func, \"id\")",
            "                        and node.func.id in COMMAND_EXECUTION_FUNCTIONS",
            "                    ):",
            "                        raise ValueError(",
            "                            f\"Found illegal command execution function \"",
            "                            f\"{node.func.id} in code {code}\"",
            "                        )",
            "",
            "                    if (",
            "                        isinstance(node.func, ast.Attribute)",
            "                        and node.func.attr in COMMAND_EXECUTION_FUNCTIONS",
            "                    ):",
            "                        raise ValueError(",
            "                            f\"Found illegal command execution function \"",
            "                            f\"{node.func.attr} in code {code}\"",
            "                        )",
            "",
            "                if (not code_validations.allow_imports) and (",
            "                    isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom)",
            "                ):",
            "                    raise ValueError(f\"Generated code has disallowed imports: {code}\")",
            "",
            "    @classmethod",
            "    def from_math_prompt(cls, llm: BaseLanguageModel, **kwargs: Any) -> PALChain:",
            "        \"\"\"Load PAL from math prompt.",
            "",
            "        Args:",
            "            llm (BaseLanguageModel): The language model to use for generating code.",
            "",
            "        Returns:",
            "            PALChain: An instance of PALChain.",
            "        \"\"\"",
            "        llm_chain = LLMChain(llm=llm, prompt=MATH_PROMPT)",
            "        code_validations = PALValidation(",
            "            solution_expression_name=\"solution\",",
            "            solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,",
            "        )",
            "",
            "        return cls(",
            "            llm_chain=llm_chain,",
            "            stop=\"\\n\\n\",",
            "            get_answer_expr=\"print(solution())\",",
            "            code_validations=code_validations,",
            "            **kwargs,",
            "        )",
            "",
            "    @classmethod",
            "    def from_colored_object_prompt(",
            "        cls, llm: BaseLanguageModel, **kwargs: Any",
            "    ) -> PALChain:",
            "        \"\"\"Load PAL from colored object prompt.",
            "",
            "        Args:",
            "            llm (BaseLanguageModel): The language model to use for generating code.",
            "",
            "        Returns:",
            "            PALChain: An instance of PALChain.",
            "        \"\"\"",
            "        llm_chain = LLMChain(llm=llm, prompt=COLORED_OBJECT_PROMPT)",
            "        code_validations = PALValidation(",
            "            solution_expression_name=\"answer\",",
            "            solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_VARIABLE,",
            "        )",
            "        return cls(",
            "            llm_chain=llm_chain,",
            "            stop=\"\\n\\n\\n\",",
            "            get_answer_expr=\"print(answer)\",",
            "            code_validations=code_validations,",
            "            **kwargs,",
            "        )",
            "",
            "    @property",
            "    def _chain_type(self) -> str:",
            "        return \"pal_chain\""
        ],
        "afterPatchFile": [
            "\"\"\"Implements Program-Aided Language Models.",
            "",
            "This module implements the Program-Aided Language Models (PAL) for generating code",
            "solutions. PAL is a technique described in the paper \"Program-Aided Language Models\"",
            "(https://arxiv.org/pdf/2211.10435.pdf).",
            "\"\"\"",
            "",
            "from __future__ import annotations",
            "",
            "import ast",
            "from typing import Any, Dict, List, Optional",
            "",
            "from langchain.chains.base import Chain",
            "from langchain.chains.llm import LLMChain",
            "from langchain_community.utilities import PythonREPL",
            "from langchain_core.callbacks.manager import CallbackManagerForChainRun",
            "from langchain_core.language_models import BaseLanguageModel",
            "",
            "from langchain_experimental.pal_chain.colored_object_prompt import COLORED_OBJECT_PROMPT",
            "from langchain_experimental.pal_chain.math_prompt import MATH_PROMPT",
            "from langchain_experimental.pydantic_v1 import Extra, Field, root_validator",
            "",
            "COMMAND_EXECUTION_FUNCTIONS = [\"system\", \"exec\", \"execfile\", \"eval\", \"__import__\"]",
            "COMMAND_EXECUTION_ATTRIBUTES = [",
            "    \"__import__\",",
            "    \"__subclasses__\",",
            "    \"__builtins__\",",
            "    \"__globals__\",",
            "    \"__getattribute__\",",
            "    \"__bases__\",",
            "    \"__mro__\",",
            "    \"__base__\",",
            "]",
            "",
            "",
            "class PALValidation:",
            "    \"\"\"Validation for PAL generated code.\"\"\"",
            "",
            "    SOLUTION_EXPRESSION_TYPE_FUNCTION = ast.FunctionDef",
            "    SOLUTION_EXPRESSION_TYPE_VARIABLE = ast.Name",
            "",
            "    def __init__(",
            "        self,",
            "        solution_expression_name: Optional[str] = None,",
            "        solution_expression_type: Optional[type] = None,",
            "        allow_imports: bool = False,",
            "        allow_command_exec: bool = False,",
            "    ):",
            "        \"\"\"Initialize a PALValidation instance.",
            "",
            "        Args:",
            "            solution_expression_name (str): Name of the expected solution expression.",
            "                If passed, solution_expression_type must be passed as well.",
            "            solution_expression_type (str): AST type of the expected solution",
            "                expression. If passed, solution_expression_name must be passed as well.",
            "                Must be one of PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,",
            "                PALValidation.SOLUTION_EXPRESSION_TYPE_VARIABLE.",
            "            allow_imports (bool): Allow import statements.",
            "            allow_command_exec (bool): Allow using known command execution functions.",
            "        \"\"\"",
            "        self.solution_expression_name = solution_expression_name",
            "        self.solution_expression_type = solution_expression_type",
            "",
            "        if solution_expression_name is not None:",
            "            if not isinstance(self.solution_expression_name, str):",
            "                raise ValueError(",
            "                    f\"Expected solution_expression_name to be str, \"",
            "                    f\"instead found {type(self.solution_expression_name)}\"",
            "                )",
            "        if solution_expression_type is not None:",
            "            if (",
            "                self.solution_expression_type",
            "                is not self.SOLUTION_EXPRESSION_TYPE_FUNCTION",
            "                and self.solution_expression_type",
            "                is not self.SOLUTION_EXPRESSION_TYPE_VARIABLE",
            "            ):",
            "                raise ValueError(",
            "                    f\"Expected solution_expression_type to be one of \"",
            "                    f\"({self.SOLUTION_EXPRESSION_TYPE_FUNCTION},\"",
            "                    f\"{self.SOLUTION_EXPRESSION_TYPE_VARIABLE}),\"",
            "                    f\"instead found {self.solution_expression_type}\"",
            "                )",
            "",
            "        if solution_expression_name is not None and solution_expression_type is None:",
            "            raise TypeError(",
            "                \"solution_expression_name \"",
            "                \"requires solution_expression_type to be passed as well\"",
            "            )",
            "        if solution_expression_name is None and solution_expression_type is not None:",
            "            raise TypeError(",
            "                \"solution_expression_type \"",
            "                \"requires solution_expression_name to be passed as well\"",
            "            )",
            "",
            "        self.allow_imports = allow_imports",
            "        self.allow_command_exec = allow_command_exec",
            "",
            "",
            "class PALChain(Chain):",
            "    \"\"\"Chain that implements Program-Aided Language Models (PAL).",
            "",
            "    This class implements the Program-Aided Language Models (PAL) for generating code",
            "    solutions. PAL is a technique described in the paper \"Program-Aided Language Models\"",
            "    (https://arxiv.org/pdf/2211.10435.pdf).",
            "",
            "    *Security note*: This class implements an AI technique that generates and evaluates",
            "        Python code, which can be dangerous and requires a specially sandboxed",
            "        environment to be safely used. While this class implements some basic guardrails",
            "        by limiting available locals/globals and by parsing and inspecting",
            "        the generated Python AST using `PALValidation`, those guardrails will not",
            "        deter sophisticated attackers and are not a replacement for a proper sandbox.",
            "        Do not use this class on untrusted inputs, with elevated permissions,",
            "        or without consulting your security team about proper sandboxing!",
            "    \"\"\"",
            "",
            "    llm_chain: LLMChain",
            "    stop: str = \"\\n\\n\"",
            "    \"\"\"Stop token to use when generating code.\"\"\"",
            "    get_answer_expr: str = \"print(solution())\"",
            "    \"\"\"Expression to use to get the answer from the generated code.\"\"\"",
            "    python_globals: Optional[Dict[str, Any]] = None",
            "    \"\"\"Python globals and locals to use when executing the generated code.\"\"\"",
            "    python_locals: Optional[Dict[str, Any]] = None",
            "    \"\"\"Python globals and locals to use when executing the generated code.\"\"\"",
            "    output_key: str = \"result\"  #: :meta private:",
            "    return_intermediate_steps: bool = False",
            "    \"\"\"Whether to return intermediate steps in the generated code.\"\"\"",
            "    code_validations: PALValidation = Field(default_factory=PALValidation)",
            "    \"\"\"Validations to perform on the generated code.\"\"\"",
            "    timeout: Optional[int] = 10",
            "    \"\"\"Timeout in seconds for the generated code to execute.\"\"\"",
            "    allow_dangerous_code: bool = False",
            "    \"\"\"This chain relies on the execution of generated code, which can be dangerous.",
            "    ",
            "    This class implements an AI technique that generates and evaluates",
            "    Python code, which can be dangerous and requires a specially sandboxed",
            "    environment to be safely used. While this class implements some basic guardrails",
            "    by limiting available locals/globals and by parsing and inspecting",
            "    the generated Python AST using `PALValidation`, those guardrails will not",
            "    deter sophisticated attackers and are not a replacement for a proper sandbox.",
            "    Do not use this class on untrusted inputs, with elevated permissions,",
            "    or without consulting your security team about proper sandboxing!",
            "    ",
            "    Failure to properly sandbox this class can lead to arbitrary code execution",
            "    vulnerabilities, which can lead to data breaches, data loss, or other security",
            "    incidents.",
            "    \"\"\"",
            "",
            "    @root_validator(pre=False, skip_on_failure=True)",
            "    def post_init(cls, values: Dict) -> Dict:",
            "        if not values[\"allow_dangerous_code\"]:",
            "            raise ValueError(",
            "                \"This chain relies on the execution of generated code, \"",
            "                \"which can be dangerous. \"",
            "                \"Please read the security notice for this class, and only \"",
            "                \"use it if you understand the security implications. \"",
            "                \"If you want to proceed, you will need to opt-in, by setting \"",
            "                \"`allow_dangerous_code` to `True`.\"",
            "            )",
            "",
            "        return values",
            "",
            "    class Config:",
            "        \"\"\"Configuration for this pydantic object.\"\"\"",
            "",
            "        extra = Extra.forbid",
            "        arbitrary_types_allowed = True",
            "",
            "    @property",
            "    def input_keys(self) -> List[str]:",
            "        \"\"\"Return the singular input key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        return self.llm_chain.prompt.input_variables",
            "",
            "    @property",
            "    def output_keys(self) -> List[str]:",
            "        \"\"\"Return the singular output key.",
            "",
            "        :meta private:",
            "        \"\"\"",
            "        if not self.return_intermediate_steps:",
            "            return [self.output_key]",
            "        else:",
            "            return [self.output_key, \"intermediate_steps\"]",
            "",
            "    def _call(",
            "        self,",
            "        inputs: Dict[str, Any],",
            "        run_manager: Optional[CallbackManagerForChainRun] = None,",
            "    ) -> Dict[str, str]:",
            "        _run_manager = run_manager or CallbackManagerForChainRun.get_noop_manager()",
            "        code = self.llm_chain.predict(",
            "            stop=[self.stop], callbacks=_run_manager.get_child(), **inputs",
            "        )",
            "        _run_manager.on_text(code, color=\"green\", end=\"\\n\", verbose=self.verbose)",
            "        PALChain.validate_code(code, self.code_validations)",
            "",
            "        # TODO: look into why mypy thinks PythonREPL's type here is `Any`",
            "        #       and therefore not callable",
            "        repl = PythonREPL(",
            "            _globals=self.python_globals,",
            "            _locals=self.python_locals,",
            "        )  # type: ignore[misc]",
            "        res = repl.run(code + f\"\\n{self.get_answer_expr}\", timeout=self.timeout)",
            "        output = {self.output_key: res.strip()}",
            "        if self.return_intermediate_steps:",
            "            output[\"intermediate_steps\"] = code",
            "        return output",
            "",
            "    @classmethod",
            "    def validate_code(cls, code: str, code_validations: PALValidation) -> None:",
            "        try:",
            "            code_tree = ast.parse(code)",
            "        except (SyntaxError, UnicodeDecodeError):",
            "            raise ValueError(f\"Generated code is not valid python code: {code}\")",
            "        except TypeError:",
            "            raise ValueError(",
            "                f\"Generated code is expected to be a string, \"",
            "                f\"instead found {type(code)}\"",
            "            )",
            "        except OverflowError:",
            "            raise ValueError(",
            "                f\"Generated code too long / complex to be parsed by ast: {code}\"",
            "            )",
            "",
            "        found_solution_expr = False",
            "        if code_validations.solution_expression_name is None:",
            "            # Skip validation if no solution_expression_name was given",
            "            found_solution_expr = True",
            "",
            "        has_imports = False",
            "        top_level_nodes = list(ast.iter_child_nodes(code_tree))",
            "        for node in top_level_nodes:",
            "            if (",
            "                code_validations.solution_expression_name is not None",
            "                and code_validations.solution_expression_type is not None",
            "            ):",
            "                # Check root nodes (like func def)",
            "                if (",
            "                    isinstance(node, code_validations.solution_expression_type)",
            "                    and hasattr(node, \"name\")",
            "                    and node.name == code_validations.solution_expression_name",
            "                ):",
            "                    found_solution_expr = True",
            "                # Check assigned nodes (like answer variable)",
            "                if isinstance(node, ast.Assign):",
            "                    for target_node in node.targets:",
            "                        if (",
            "                            isinstance(",
            "                                target_node, code_validations.solution_expression_type",
            "                            )",
            "                            and hasattr(target_node, \"id\")",
            "                            and target_node.id",
            "                            == code_validations.solution_expression_name",
            "                        ):",
            "                            found_solution_expr = True",
            "            if isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom):",
            "                has_imports = True",
            "",
            "        if not found_solution_expr:",
            "            raise ValueError(",
            "                f\"Generated code is missing the solution expression: \"",
            "                f\"{code_validations.solution_expression_name} of type: \"",
            "                f\"{code_validations.solution_expression_type}\"",
            "            )",
            "",
            "        if not code_validations.allow_imports and has_imports:",
            "            raise ValueError(f\"Generated code has disallowed imports: {code}\")",
            "",
            "        if (",
            "            not code_validations.allow_command_exec",
            "            or not code_validations.allow_imports",
            "        ):",
            "            for node in ast.walk(code_tree):",
            "                if (",
            "                    not code_validations.allow_command_exec",
            "                    and isinstance(node, ast.Attribute)",
            "                    and node.attr in COMMAND_EXECUTION_ATTRIBUTES",
            "                ):",
            "                    raise ValueError(",
            "                        f\"Found illegal command execution function \"",
            "                        f\"{node.attr} in code {code}\"",
            "                    )",
            "                if (not code_validations.allow_command_exec) and isinstance(",
            "                    node, ast.Call",
            "                ):",
            "                    if (",
            "                        hasattr(node.func, \"id\")",
            "                        and node.func.id in COMMAND_EXECUTION_FUNCTIONS",
            "                    ):",
            "                        raise ValueError(",
            "                            f\"Found illegal command execution function \"",
            "                            f\"{node.func.id} in code {code}\"",
            "                        )",
            "",
            "                    if (",
            "                        isinstance(node.func, ast.Attribute)",
            "                        and node.func.attr in COMMAND_EXECUTION_FUNCTIONS",
            "                    ):",
            "                        raise ValueError(",
            "                            f\"Found illegal command execution function \"",
            "                            f\"{node.func.attr} in code {code}\"",
            "                        )",
            "",
            "                if (not code_validations.allow_imports) and (",
            "                    isinstance(node, ast.Import) or isinstance(node, ast.ImportFrom)",
            "                ):",
            "                    raise ValueError(f\"Generated code has disallowed imports: {code}\")",
            "",
            "    @classmethod",
            "    def from_math_prompt(cls, llm: BaseLanguageModel, **kwargs: Any) -> PALChain:",
            "        \"\"\"Load PAL from math prompt.",
            "",
            "        Args:",
            "            llm (BaseLanguageModel): The language model to use for generating code.",
            "",
            "        Returns:",
            "            PALChain: An instance of PALChain.",
            "        \"\"\"",
            "        llm_chain = LLMChain(llm=llm, prompt=MATH_PROMPT)",
            "        code_validations = PALValidation(",
            "            solution_expression_name=\"solution\",",
            "            solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,",
            "        )",
            "",
            "        return cls(",
            "            llm_chain=llm_chain,",
            "            stop=\"\\n\\n\",",
            "            get_answer_expr=\"print(solution())\",",
            "            code_validations=code_validations,",
            "            **kwargs,",
            "        )",
            "",
            "    @classmethod",
            "    def from_colored_object_prompt(",
            "        cls, llm: BaseLanguageModel, **kwargs: Any",
            "    ) -> PALChain:",
            "        \"\"\"Load PAL from colored object prompt.",
            "",
            "        Args:",
            "            llm (BaseLanguageModel): The language model to use for generating code.",
            "",
            "        Returns:",
            "            PALChain: An instance of PALChain.",
            "        \"\"\"",
            "        llm_chain = LLMChain(llm=llm, prompt=COLORED_OBJECT_PROMPT)",
            "        code_validations = PALValidation(",
            "            solution_expression_name=\"answer\",",
            "            solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_VARIABLE,",
            "        )",
            "        return cls(",
            "            llm_chain=llm_chain,",
            "            stop=\"\\n\\n\\n\",",
            "            get_answer_expr=\"print(answer)\",",
            "            code_validations=code_validations,",
            "            **kwargs,",
            "        )",
            "",
            "    @property",
            "    def _chain_type(self) -> str:",
            "        return \"pal_chain\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "21": []
        },
        "addLocation": []
    },
    "libs/experimental/tests/integration_tests/chains/test_pal.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " def test_math_prompt() -> None:"
            },
            "1": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": "     \"\"\"Test math prompt.\"\"\""
            },
            "2": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": "     llm = OpenAI(temperature=0, max_tokens=512)"
            },
            "3": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    pal_chain = PALChain.from_math_prompt(llm, timeout=None)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+    pal_chain = PALChain.from_math_prompt(llm, timeout=None, allow_dangerous_code=False)"
            },
            "5": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": "     question = ("
            },
            "6": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": "         \"Jan has three times the number of pets as Marcia. \""
            },
            "7": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": "         \"Marcia has two more pets than Cindy. \""
            },
            "8": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " def test_colored_object_prompt() -> None:"
            },
            "9": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     \"\"\"Test colored object prompt.\"\"\""
            },
            "10": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "     llm = OpenAI(temperature=0, max_tokens=512)"
            },
            "11": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    pal_chain = PALChain.from_colored_object_prompt(llm, timeout=None)"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+    pal_chain = PALChain.from_colored_object_prompt("
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 25,
                "PatchRowcode": "+        llm, timeout=None, allow_dangerous_code=False"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 26,
                "PatchRowcode": "+    )"
            },
            "15": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "     question = ("
            },
            "16": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "         \"On the desk, you see two blue booklets, \""
            },
            "17": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "         \"two purple booklets, and two yellow pairs of sunglasses. \""
            }
        },
        "frontPatchFile": [
            "\"\"\"Test PAL chain.\"\"\"",
            "",
            "from langchain_community.llms import OpenAI",
            "",
            "from langchain_experimental.pal_chain.base import PALChain",
            "",
            "",
            "def test_math_prompt() -> None:",
            "    \"\"\"Test math prompt.\"\"\"",
            "    llm = OpenAI(temperature=0, max_tokens=512)",
            "    pal_chain = PALChain.from_math_prompt(llm, timeout=None)",
            "    question = (",
            "        \"Jan has three times the number of pets as Marcia. \"",
            "        \"Marcia has two more pets than Cindy. \"",
            "        \"If Cindy has four pets, how many total pets do the three have?\"",
            "    )",
            "    output = pal_chain.run(question)",
            "    assert output == \"28\"",
            "",
            "",
            "def test_colored_object_prompt() -> None:",
            "    \"\"\"Test colored object prompt.\"\"\"",
            "    llm = OpenAI(temperature=0, max_tokens=512)",
            "    pal_chain = PALChain.from_colored_object_prompt(llm, timeout=None)",
            "    question = (",
            "        \"On the desk, you see two blue booklets, \"",
            "        \"two purple booklets, and two yellow pairs of sunglasses. \"",
            "        \"If I remove all the pairs of sunglasses from the desk, \"",
            "        \"how many purple items remain on it?\"",
            "    )",
            "    output = pal_chain.run(question)",
            "    assert output == \"2\""
        ],
        "afterPatchFile": [
            "\"\"\"Test PAL chain.\"\"\"",
            "",
            "from langchain_community.llms import OpenAI",
            "",
            "from langchain_experimental.pal_chain.base import PALChain",
            "",
            "",
            "def test_math_prompt() -> None:",
            "    \"\"\"Test math prompt.\"\"\"",
            "    llm = OpenAI(temperature=0, max_tokens=512)",
            "    pal_chain = PALChain.from_math_prompt(llm, timeout=None, allow_dangerous_code=False)",
            "    question = (",
            "        \"Jan has three times the number of pets as Marcia. \"",
            "        \"Marcia has two more pets than Cindy. \"",
            "        \"If Cindy has four pets, how many total pets do the three have?\"",
            "    )",
            "    output = pal_chain.run(question)",
            "    assert output == \"28\"",
            "",
            "",
            "def test_colored_object_prompt() -> None:",
            "    \"\"\"Test colored object prompt.\"\"\"",
            "    llm = OpenAI(temperature=0, max_tokens=512)",
            "    pal_chain = PALChain.from_colored_object_prompt(",
            "        llm, timeout=None, allow_dangerous_code=False",
            "    )",
            "    question = (",
            "        \"On the desk, you see two blue booklets, \"",
            "        \"two purple booklets, and two yellow pairs of sunglasses. \"",
            "        \"If I remove all the pairs of sunglasses from the desk, \"",
            "        \"how many purple items remain on it?\"",
            "    )",
            "    output = pal_chain.run(question)",
            "    assert output == \"2\""
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "11": [
                "test_math_prompt"
            ],
            "24": [
                "test_colored_object_prompt"
            ]
        },
        "addLocation": []
    },
    "libs/experimental/tests/unit_tests/agents/agent_toolkits/pandas/test_base.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " def test_create_pandas_dataframe_agent() -> None:"
            },
            "1": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": "     import pandas as pd"
            },
            "2": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    create_pandas_dataframe_agent(FakeLLM(), pd.DataFrame())"
            },
            "4": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    create_pandas_dataframe_agent(FakeLLM(), [pd.DataFrame(), pd.DataFrame()])"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+    with pytest.raises(ValueError):"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+        create_pandas_dataframe_agent("
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+            FakeLLM(), pd.DataFrame(), allow_dangerous_code=False"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+        )"
            },
            "9": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 18,
                "PatchRowcode": "+"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+    create_pandas_dataframe_agent(FakeLLM(), pd.DataFrame(), allow_dangerous_code=True)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+    create_pandas_dataframe_agent("
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 21,
                "PatchRowcode": "+        FakeLLM(), [pd.DataFrame(), pd.DataFrame()], allow_dangerous_code=True"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 22,
                "PatchRowcode": "+    )"
            }
        },
        "frontPatchFile": [
            "import sys",
            "",
            "import pytest",
            "",
            "from langchain_experimental.agents import create_pandas_dataframe_agent",
            "from tests.unit_tests.fake_llm import FakeLLM",
            "",
            "",
            "@pytest.mark.requires(\"pandas\", \"tabulate\")",
            "@pytest.mark.skipif(sys.version_info < (3, 9), reason=\"requires python3.9 or higher\")",
            "def test_create_pandas_dataframe_agent() -> None:",
            "    import pandas as pd",
            "",
            "    create_pandas_dataframe_agent(FakeLLM(), pd.DataFrame())",
            "    create_pandas_dataframe_agent(FakeLLM(), [pd.DataFrame(), pd.DataFrame()])"
        ],
        "afterPatchFile": [
            "import sys",
            "",
            "import pytest",
            "",
            "from langchain_experimental.agents import create_pandas_dataframe_agent",
            "from tests.unit_tests.fake_llm import FakeLLM",
            "",
            "",
            "@pytest.mark.requires(\"pandas\", \"tabulate\")",
            "@pytest.mark.skipif(sys.version_info < (3, 9), reason=\"requires python3.9 or higher\")",
            "def test_create_pandas_dataframe_agent() -> None:",
            "    import pandas as pd",
            "",
            "    with pytest.raises(ValueError):",
            "        create_pandas_dataframe_agent(",
            "            FakeLLM(), pd.DataFrame(), allow_dangerous_code=False",
            "        )",
            "",
            "    create_pandas_dataframe_agent(FakeLLM(), pd.DataFrame(), allow_dangerous_code=True)",
            "    create_pandas_dataframe_agent(",
            "        FakeLLM(), [pd.DataFrame(), pd.DataFrame()], allow_dangerous_code=True",
            "    )"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "14": [
                "test_create_pandas_dataframe_agent"
            ],
            "15": [
                "test_create_pandas_dataframe_agent"
            ]
        },
        "addLocation": []
    },
    "libs/experimental/tests/unit_tests/test_pal.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 189,
                "afterPatchRowNumber": 189,
                "PatchRowcode": "     prompt = MATH_PROMPT.format(question=question)"
            },
            "1": {
                "beforePatchRowNumber": 190,
                "afterPatchRowNumber": 190,
                "PatchRowcode": "     queries = {prompt: _MATH_SOLUTION_1}"
            },
            "2": {
                "beforePatchRowNumber": 191,
                "afterPatchRowNumber": 191,
                "PatchRowcode": "     fake_llm = FakeLLM(queries=queries)"
            },
            "3": {
                "beforePatchRowNumber": 192,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    fake_pal_chain = PALChain.from_math_prompt(fake_llm, timeout=None)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 192,
                "PatchRowcode": "+    fake_pal_chain = PALChain.from_math_prompt("
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 193,
                "PatchRowcode": "+        fake_llm, timeout=None, allow_dangerous_code=True"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 194,
                "PatchRowcode": "+    )"
            },
            "7": {
                "beforePatchRowNumber": 193,
                "afterPatchRowNumber": 195,
                "PatchRowcode": "     output = fake_pal_chain.run(question)"
            },
            "8": {
                "beforePatchRowNumber": 194,
                "afterPatchRowNumber": 196,
                "PatchRowcode": "     assert output == \"8\""
            },
            "9": {
                "beforePatchRowNumber": 195,
                "afterPatchRowNumber": 197,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 202,
                "afterPatchRowNumber": 204,
                "PatchRowcode": "     prompt = MATH_PROMPT.format(question=question)"
            },
            "11": {
                "beforePatchRowNumber": 203,
                "afterPatchRowNumber": 205,
                "PatchRowcode": "     queries = {prompt: _MATH_SOLUTION_2}"
            },
            "12": {
                "beforePatchRowNumber": 204,
                "afterPatchRowNumber": 206,
                "PatchRowcode": "     fake_llm = FakeLLM(queries=queries)"
            },
            "13": {
                "beforePatchRowNumber": 205,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    fake_pal_chain = PALChain.from_math_prompt(fake_llm, timeout=None)"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 207,
                "PatchRowcode": "+    fake_pal_chain = PALChain.from_math_prompt("
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 208,
                "PatchRowcode": "+        fake_llm, timeout=None, allow_dangerous_code=True"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 209,
                "PatchRowcode": "+    )"
            },
            "17": {
                "beforePatchRowNumber": 206,
                "afterPatchRowNumber": 210,
                "PatchRowcode": "     output = fake_pal_chain.run(question)"
            },
            "18": {
                "beforePatchRowNumber": 207,
                "afterPatchRowNumber": 211,
                "PatchRowcode": "     assert output == \"33\""
            },
            "19": {
                "beforePatchRowNumber": 208,
                "afterPatchRowNumber": 212,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 214,
                "afterPatchRowNumber": 218,
                "PatchRowcode": "     prompt = MATH_PROMPT.format(question=question)"
            },
            "21": {
                "beforePatchRowNumber": 215,
                "afterPatchRowNumber": 219,
                "PatchRowcode": "     queries = {prompt: _MATH_SOLUTION_3}"
            },
            "22": {
                "beforePatchRowNumber": 216,
                "afterPatchRowNumber": 220,
                "PatchRowcode": "     fake_llm = FakeLLM(queries=queries)"
            },
            "23": {
                "beforePatchRowNumber": 217,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    fake_pal_chain = PALChain.from_math_prompt(fake_llm, timeout=None)"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 221,
                "PatchRowcode": "+    fake_pal_chain = PALChain.from_math_prompt("
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 222,
                "PatchRowcode": "+        fake_llm, timeout=None, allow_dangerous_code=True"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 223,
                "PatchRowcode": "+    )"
            },
            "27": {
                "beforePatchRowNumber": 218,
                "afterPatchRowNumber": 224,
                "PatchRowcode": "     with pytest.raises(ValueError) as exc_info:"
            },
            "28": {
                "beforePatchRowNumber": 219,
                "afterPatchRowNumber": 225,
                "PatchRowcode": "         fake_pal_chain.run(question)"
            },
            "29": {
                "beforePatchRowNumber": 220,
                "afterPatchRowNumber": 226,
                "PatchRowcode": "     assert ("
            },
            "30": {
                "beforePatchRowNumber": 231,
                "afterPatchRowNumber": 237,
                "PatchRowcode": "     prompt = MATH_PROMPT.format(question=question)"
            },
            "31": {
                "beforePatchRowNumber": 232,
                "afterPatchRowNumber": 238,
                "PatchRowcode": "     queries = {prompt: _MATH_SOLUTION_INFINITE_LOOP}"
            },
            "32": {
                "beforePatchRowNumber": 233,
                "afterPatchRowNumber": 239,
                "PatchRowcode": "     fake_llm = FakeLLM(queries=queries)"
            },
            "33": {
                "beforePatchRowNumber": 234,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    fake_pal_chain = PALChain.from_math_prompt(fake_llm, timeout=1)"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 240,
                "PatchRowcode": "+    fake_pal_chain = PALChain.from_math_prompt("
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 241,
                "PatchRowcode": "+        fake_llm, timeout=1, allow_dangerous_code=True"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 242,
                "PatchRowcode": "+    )"
            },
            "37": {
                "beforePatchRowNumber": 235,
                "afterPatchRowNumber": 243,
                "PatchRowcode": "     output = fake_pal_chain.run(question)"
            },
            "38": {
                "beforePatchRowNumber": 236,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "     assert output == \"Execution timed out\""
            },
            "39": {
                "beforePatchRowNumber": 237,
                "afterPatchRowNumber": 245,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 253,
                "PatchRowcode": "     prompt = COLORED_OBJECT_PROMPT.format(question=question)"
            },
            "41": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "     queries = {prompt: _COLORED_OBJECT_SOLUTION_1}"
            },
            "42": {
                "beforePatchRowNumber": 247,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "     fake_llm = FakeLLM(queries=queries)"
            },
            "43": {
                "beforePatchRowNumber": 248,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    fake_pal_chain = PALChain.from_colored_object_prompt(fake_llm, timeout=None)"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 256,
                "PatchRowcode": "+    fake_pal_chain = PALChain.from_colored_object_prompt("
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 257,
                "PatchRowcode": "+        fake_llm, timeout=None, allow_dangerous_code=True"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 258,
                "PatchRowcode": "+    )"
            },
            "47": {
                "beforePatchRowNumber": 249,
                "afterPatchRowNumber": 259,
                "PatchRowcode": "     output = fake_pal_chain.run(question)"
            },
            "48": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 260,
                "PatchRowcode": "     assert output == \"0\""
            },
            "49": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 261,
                "PatchRowcode": " "
            },
            "50": {
                "beforePatchRowNumber": 260,
                "afterPatchRowNumber": 270,
                "PatchRowcode": "     prompt = COLORED_OBJECT_PROMPT.format(question=question)"
            },
            "51": {
                "beforePatchRowNumber": 261,
                "afterPatchRowNumber": 271,
                "PatchRowcode": "     queries = {prompt: _COLORED_OBJECT_SOLUTION_2}"
            },
            "52": {
                "beforePatchRowNumber": 262,
                "afterPatchRowNumber": 272,
                "PatchRowcode": "     fake_llm = FakeLLM(queries=queries)"
            },
            "53": {
                "beforePatchRowNumber": 263,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    fake_pal_chain = PALChain.from_colored_object_prompt(fake_llm, timeout=None)"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 273,
                "PatchRowcode": "+    fake_pal_chain = PALChain.from_colored_object_prompt("
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 274,
                "PatchRowcode": "+        fake_llm, timeout=None, allow_dangerous_code=True"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 275,
                "PatchRowcode": "+    )"
            },
            "57": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 276,
                "PatchRowcode": "     output = fake_pal_chain.run(question)"
            },
            "58": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 277,
                "PatchRowcode": "     assert output == \"brown\""
            },
            "59": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": 278,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "\"\"\"Test LLM PAL functionality.\"\"\"",
            "import pytest",
            "",
            "from langchain_experimental.pal_chain.base import PALChain, PALValidation",
            "from langchain_experimental.pal_chain.colored_object_prompt import COLORED_OBJECT_PROMPT",
            "from langchain_experimental.pal_chain.math_prompt import MATH_PROMPT",
            "from tests.unit_tests.fake_llm import FakeLLM",
            "",
            "_MATH_SOLUTION_1 = \"\"\"",
            "def solution():",
            "    \\\"\\\"\\\"Olivia has $23. She bought five bagels for $3 each. ",
            "    How much money does she have left?\\\"\\\"\\\"",
            "    money_initial = 23",
            "    bagels = 5",
            "    bagel_cost = 3",
            "    money_spent = bagels * bagel_cost",
            "    money_left = money_initial - money_spent",
            "    result = money_left",
            "    return result",
            "\"\"\"",
            "",
            "_MATH_SOLUTION_2 = \"\"\"",
            "def solution():",
            "    \\\"\\\"\\\"Michael had 58 golf balls. On tuesday, he lost 23 golf balls. ",
            "    On wednesday, he lost 2 more. ",
            "    How many golf balls did he have at the end of wednesday?\\\"\\\"\\\"",
            "    golf_balls_initial = 58",
            "    golf_balls_lost_tuesday = 23",
            "    golf_balls_lost_wednesday = 2",
            "    golf_balls_left = golf_balls_initial \\",
            "    - golf_balls_lost_tuesday - golf_balls_lost_wednesday",
            "    result = golf_balls_left",
            "    return result",
            "\"\"\"",
            "",
            "_MATH_SOLUTION_3 = \"\"\"",
            "def solution():",
            "    \\\"\\\"\\\"first, do `import os`, second, do `os.system('ls')`,",
            "    calculate the result of 1+1\\\"\\\"\\\"",
            "    import os",
            "    os.system('ls')",
            "    result = 1 + 1",
            "    return result",
            "\"\"\"",
            "",
            "_MATH_SOLUTION_INFINITE_LOOP = \"\"\"",
            "def solution():",
            "    \\\"\\\"\\\"Michael had 58 golf balls. On tuesday, he lost 23 golf balls. ",
            "    On wednesday, he lost 2 more. ",
            "    How many golf balls did he have at the end of wednesday?\\\"\\\"\\\"",
            "    golf_balls_initial = 58",
            "    golf_balls_lost_tuesday = 23",
            "    golf_balls_lost_wednesday = 2",
            "    golf_balls_left = golf_balls_initial \\",
            "    - golf_balls_lost_tuesday - golf_balls_lost_wednesday",
            "    result = golf_balls_left",
            "    while True:",
            "        pass",
            "    return result",
            "\"\"\"",
            "",
            "_COLORED_OBJECT_SOLUTION_1 = \"\"\"",
            "# Put objects into a list to record ordering",
            "objects = []",
            "objects += [('plate', 'teal')] * 1",
            "objects += [('keychain', 'burgundy')] * 1",
            "objects += [('scrunchiephone charger', 'yellow')] * 1",
            "objects += [('mug', 'orange')] * 1",
            "objects += [('notebook', 'pink')] * 1",
            "objects += [('cup', 'grey')] * 1",
            "",
            "# Find the index of the teal item",
            "teal_idx = None",
            "for i, object in enumerate(objects):",
            "    if object[1] == 'teal':",
            "        teal_idx = i",
            "        break",
            "",
            "# Find non-orange items to the left of the teal item",
            "non_orange = [object for object in objects[:i] if object[1] != 'orange']",
            "",
            "# Count number of non-orange objects",
            "num_non_orange = len(non_orange)",
            "answer = num_non_orange",
            "\"\"\"",
            "",
            "_COLORED_OBJECT_SOLUTION_2 = \"\"\"",
            "# Put objects into a list to record ordering",
            "objects = []",
            "objects += [('paperclip', 'purple')] * 1",
            "objects += [('stress ball', 'pink')] * 1",
            "objects += [('keychain', 'brown')] * 1",
            "objects += [('scrunchiephone charger', 'green')] * 1",
            "objects += [('fidget spinner', 'mauve')] * 1",
            "objects += [('pen', 'burgundy')] * 1",
            "",
            "# Find the index of the stress ball",
            "stress_ball_idx = None",
            "for i, object in enumerate(objects):",
            "    if object[0] == 'stress ball':",
            "        stress_ball_idx = i",
            "        break",
            "",
            "# Find the directly right object",
            "direct_right = objects[i+1]",
            "",
            "# Check the directly right object's color",
            "direct_right_color = direct_right[1]",
            "answer = direct_right_color",
            "\"\"\"",
            "",
            "_SAMPLE_CODE_1 = \"\"\"",
            "def solution():",
            "    \\\"\\\"\\\"Olivia has $23. She bought five bagels for $3 each. ",
            "    How much money does she have left?\\\"\\\"\\\"",
            "    money_initial = 23",
            "    bagels = 5",
            "    bagel_cost = 3",
            "    money_spent = bagels * bagel_cost",
            "    money_left = money_initial - money_spent",
            "    result = money_left",
            "    return result",
            "\"\"\"",
            "",
            "_SAMPLE_CODE_2 = \"\"\"",
            "def solution2():",
            "    \\\"\\\"\\\"Olivia has $23. She bought five bagels for $3 each. ",
            "    How much money does she have left?\\\"\\\"\\\"",
            "    money_initial = 23",
            "    bagels = 5",
            "    bagel_cost = 3",
            "    money_spent = bagels * bagel_cost",
            "    money_left = money_initial - money_spent",
            "    result = money_left",
            "    return result",
            "\"\"\"",
            "",
            "_SAMPLE_CODE_3 = \"\"\"",
            "def solution():",
            "    \\\"\\\"\\\"Olivia has $23. She bought five bagels for $3 each. ",
            "    How much money does she have left?\\\"\\\"\\\"",
            "    money_initial = 23",
            "    bagels = 5",
            "    bagel_cost = 3",
            "    money_spent = bagels * bagel_cost",
            "    money_left = money_initial - money_spent",
            "    result = money_left",
            "    exec(\"evil\")",
            "    return result",
            "\"\"\"",
            "",
            "_SAMPLE_CODE_4 = \"\"\"",
            "import random",
            "",
            "def solution():",
            "    return random.choice()",
            "\"\"\"",
            "",
            "_FULL_CODE_VALIDATIONS = PALValidation(",
            "    solution_expression_name=\"solution\",",
            "    solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,",
            "    allow_imports=False,",
            "    allow_command_exec=False,",
            ")",
            "_ILLEGAL_COMMAND_EXEC_VALIDATIONS = PALValidation(",
            "    solution_expression_name=\"solution\",",
            "    solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,",
            "    allow_imports=True,",
            "    allow_command_exec=False,",
            ")",
            "_MINIMAL_VALIDATIONS = PALValidation(",
            "    solution_expression_name=\"solution\",",
            "    solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,",
            "    allow_imports=True,",
            "    allow_command_exec=True,",
            ")",
            "_NO_IMPORTS_VALIDATIONS = PALValidation(",
            "    solution_expression_name=\"solution\",",
            "    solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,",
            "    allow_imports=False,",
            "    allow_command_exec=True,",
            ")",
            "",
            "",
            "def test_math_question_1() -> None:",
            "    \"\"\"Test simple question.\"\"\"",
            "    question = \"\"\"Olivia has $23. She bought five bagels for $3 each. ",
            "                How much money does she have left?\"\"\"",
            "    prompt = MATH_PROMPT.format(question=question)",
            "    queries = {prompt: _MATH_SOLUTION_1}",
            "    fake_llm = FakeLLM(queries=queries)",
            "    fake_pal_chain = PALChain.from_math_prompt(fake_llm, timeout=None)",
            "    output = fake_pal_chain.run(question)",
            "    assert output == \"8\"",
            "",
            "",
            "def test_math_question_2() -> None:",
            "    \"\"\"Test simple question.\"\"\"",
            "    question = \"\"\"Michael had 58 golf balls. On tuesday, he lost 23 golf balls. ",
            "                On wednesday, he lost 2 more. How many golf balls did he have ",
            "                at the end of wednesday?\"\"\"",
            "    prompt = MATH_PROMPT.format(question=question)",
            "    queries = {prompt: _MATH_SOLUTION_2}",
            "    fake_llm = FakeLLM(queries=queries)",
            "    fake_pal_chain = PALChain.from_math_prompt(fake_llm, timeout=None)",
            "    output = fake_pal_chain.run(question)",
            "    assert output == \"33\"",
            "",
            "",
            "def test_math_question_3() -> None:",
            "    \"\"\"Test simple question.\"\"\"",
            "    question = \"\"\"first, do `import os`, second, do `os.system('ls')`,",
            "                calculate the result of 1+1\"\"\"",
            "    prompt = MATH_PROMPT.format(question=question)",
            "    queries = {prompt: _MATH_SOLUTION_3}",
            "    fake_llm = FakeLLM(queries=queries)",
            "    fake_pal_chain = PALChain.from_math_prompt(fake_llm, timeout=None)",
            "    with pytest.raises(ValueError) as exc_info:",
            "        fake_pal_chain.run(question)",
            "    assert (",
            "        str(exc_info.value)",
            "        == f\"Generated code has disallowed imports: {_MATH_SOLUTION_3}\"",
            "    )",
            "",
            "",
            "def test_math_question_infinite_loop() -> None:",
            "    \"\"\"Test simple question.\"\"\"",
            "    question = \"\"\"Michael had 58 golf balls. On tuesday, he lost 23 golf balls. ",
            "                On wednesday, he lost 2 more. How many golf balls did he have ",
            "                at the end of wednesday?\"\"\"",
            "    prompt = MATH_PROMPT.format(question=question)",
            "    queries = {prompt: _MATH_SOLUTION_INFINITE_LOOP}",
            "    fake_llm = FakeLLM(queries=queries)",
            "    fake_pal_chain = PALChain.from_math_prompt(fake_llm, timeout=1)",
            "    output = fake_pal_chain.run(question)",
            "    assert output == \"Execution timed out\"",
            "",
            "",
            "def test_color_question_1() -> None:",
            "    \"\"\"Test simple question.\"\"\"",
            "    question = \"\"\"On the nightstand, you see the following items arranged in a row: ",
            "                a teal plate, a burgundy keychain, a yellow scrunchiephone charger, ",
            "                an orange mug, a pink notebook, and a grey cup. How many non-orange ",
            "                items do you see to the left of the teal item?\"\"\"",
            "    prompt = COLORED_OBJECT_PROMPT.format(question=question)",
            "    queries = {prompt: _COLORED_OBJECT_SOLUTION_1}",
            "    fake_llm = FakeLLM(queries=queries)",
            "    fake_pal_chain = PALChain.from_colored_object_prompt(fake_llm, timeout=None)",
            "    output = fake_pal_chain.run(question)",
            "    assert output == \"0\"",
            "",
            "",
            "def test_color_question_2() -> None:",
            "    \"\"\"Test simple question.\"\"\"",
            "    question = \"\"\"On the table, you see a bunch of objects arranged in a row: a purple",
            "                paperclip, a pink stress ball, a brown keychain, a green ",
            "                scrunchiephone charger, a mauve fidget spinner, and a burgundy pen.",
            "                What is the color of the object directly to the right of ",
            "                the stress ball?\"\"\"",
            "    prompt = COLORED_OBJECT_PROMPT.format(question=question)",
            "    queries = {prompt: _COLORED_OBJECT_SOLUTION_2}",
            "    fake_llm = FakeLLM(queries=queries)",
            "    fake_pal_chain = PALChain.from_colored_object_prompt(fake_llm, timeout=None)",
            "    output = fake_pal_chain.run(question)",
            "    assert output == \"brown\"",
            "",
            "",
            "def test_valid_code_validation() -> None:",
            "    \"\"\"Test the validator.\"\"\"",
            "    PALChain.validate_code(_SAMPLE_CODE_1, _FULL_CODE_VALIDATIONS)",
            "",
            "",
            "def test_different_solution_expr_code_validation() -> None:",
            "    \"\"\"Test the validator.\"\"\"",
            "    with pytest.raises(ValueError):",
            "        PALChain.validate_code(_SAMPLE_CODE_2, _FULL_CODE_VALIDATIONS)",
            "",
            "",
            "def test_illegal_command_exec_disallowed_code_validation() -> None:",
            "    \"\"\"Test the validator.\"\"\"",
            "    with pytest.raises(ValueError):",
            "        PALChain.validate_code(_SAMPLE_CODE_3, _ILLEGAL_COMMAND_EXEC_VALIDATIONS)",
            "",
            "",
            "def test_illegal_command_exec_allowed_code_validation() -> None:",
            "    \"\"\"Test the validator.\"\"\"",
            "    PALChain.validate_code(_SAMPLE_CODE_3, _MINIMAL_VALIDATIONS)",
            "",
            "",
            "def test_no_imports_code_validation() -> None:",
            "    \"\"\"Test the validator.\"\"\"",
            "    PALChain.validate_code(_SAMPLE_CODE_4, _MINIMAL_VALIDATIONS)",
            "",
            "",
            "def test_no_imports_disallowed_code_validation() -> None:",
            "    \"\"\"Test the validator.\"\"\"",
            "    with pytest.raises(ValueError):",
            "        PALChain.validate_code(_SAMPLE_CODE_4, _NO_IMPORTS_VALIDATIONS)"
        ],
        "afterPatchFile": [
            "\"\"\"Test LLM PAL functionality.\"\"\"",
            "import pytest",
            "",
            "from langchain_experimental.pal_chain.base import PALChain, PALValidation",
            "from langchain_experimental.pal_chain.colored_object_prompt import COLORED_OBJECT_PROMPT",
            "from langchain_experimental.pal_chain.math_prompt import MATH_PROMPT",
            "from tests.unit_tests.fake_llm import FakeLLM",
            "",
            "_MATH_SOLUTION_1 = \"\"\"",
            "def solution():",
            "    \\\"\\\"\\\"Olivia has $23. She bought five bagels for $3 each. ",
            "    How much money does she have left?\\\"\\\"\\\"",
            "    money_initial = 23",
            "    bagels = 5",
            "    bagel_cost = 3",
            "    money_spent = bagels * bagel_cost",
            "    money_left = money_initial - money_spent",
            "    result = money_left",
            "    return result",
            "\"\"\"",
            "",
            "_MATH_SOLUTION_2 = \"\"\"",
            "def solution():",
            "    \\\"\\\"\\\"Michael had 58 golf balls. On tuesday, he lost 23 golf balls. ",
            "    On wednesday, he lost 2 more. ",
            "    How many golf balls did he have at the end of wednesday?\\\"\\\"\\\"",
            "    golf_balls_initial = 58",
            "    golf_balls_lost_tuesday = 23",
            "    golf_balls_lost_wednesday = 2",
            "    golf_balls_left = golf_balls_initial \\",
            "    - golf_balls_lost_tuesday - golf_balls_lost_wednesday",
            "    result = golf_balls_left",
            "    return result",
            "\"\"\"",
            "",
            "_MATH_SOLUTION_3 = \"\"\"",
            "def solution():",
            "    \\\"\\\"\\\"first, do `import os`, second, do `os.system('ls')`,",
            "    calculate the result of 1+1\\\"\\\"\\\"",
            "    import os",
            "    os.system('ls')",
            "    result = 1 + 1",
            "    return result",
            "\"\"\"",
            "",
            "_MATH_SOLUTION_INFINITE_LOOP = \"\"\"",
            "def solution():",
            "    \\\"\\\"\\\"Michael had 58 golf balls. On tuesday, he lost 23 golf balls. ",
            "    On wednesday, he lost 2 more. ",
            "    How many golf balls did he have at the end of wednesday?\\\"\\\"\\\"",
            "    golf_balls_initial = 58",
            "    golf_balls_lost_tuesday = 23",
            "    golf_balls_lost_wednesday = 2",
            "    golf_balls_left = golf_balls_initial \\",
            "    - golf_balls_lost_tuesday - golf_balls_lost_wednesday",
            "    result = golf_balls_left",
            "    while True:",
            "        pass",
            "    return result",
            "\"\"\"",
            "",
            "_COLORED_OBJECT_SOLUTION_1 = \"\"\"",
            "# Put objects into a list to record ordering",
            "objects = []",
            "objects += [('plate', 'teal')] * 1",
            "objects += [('keychain', 'burgundy')] * 1",
            "objects += [('scrunchiephone charger', 'yellow')] * 1",
            "objects += [('mug', 'orange')] * 1",
            "objects += [('notebook', 'pink')] * 1",
            "objects += [('cup', 'grey')] * 1",
            "",
            "# Find the index of the teal item",
            "teal_idx = None",
            "for i, object in enumerate(objects):",
            "    if object[1] == 'teal':",
            "        teal_idx = i",
            "        break",
            "",
            "# Find non-orange items to the left of the teal item",
            "non_orange = [object for object in objects[:i] if object[1] != 'orange']",
            "",
            "# Count number of non-orange objects",
            "num_non_orange = len(non_orange)",
            "answer = num_non_orange",
            "\"\"\"",
            "",
            "_COLORED_OBJECT_SOLUTION_2 = \"\"\"",
            "# Put objects into a list to record ordering",
            "objects = []",
            "objects += [('paperclip', 'purple')] * 1",
            "objects += [('stress ball', 'pink')] * 1",
            "objects += [('keychain', 'brown')] * 1",
            "objects += [('scrunchiephone charger', 'green')] * 1",
            "objects += [('fidget spinner', 'mauve')] * 1",
            "objects += [('pen', 'burgundy')] * 1",
            "",
            "# Find the index of the stress ball",
            "stress_ball_idx = None",
            "for i, object in enumerate(objects):",
            "    if object[0] == 'stress ball':",
            "        stress_ball_idx = i",
            "        break",
            "",
            "# Find the directly right object",
            "direct_right = objects[i+1]",
            "",
            "# Check the directly right object's color",
            "direct_right_color = direct_right[1]",
            "answer = direct_right_color",
            "\"\"\"",
            "",
            "_SAMPLE_CODE_1 = \"\"\"",
            "def solution():",
            "    \\\"\\\"\\\"Olivia has $23. She bought five bagels for $3 each. ",
            "    How much money does she have left?\\\"\\\"\\\"",
            "    money_initial = 23",
            "    bagels = 5",
            "    bagel_cost = 3",
            "    money_spent = bagels * bagel_cost",
            "    money_left = money_initial - money_spent",
            "    result = money_left",
            "    return result",
            "\"\"\"",
            "",
            "_SAMPLE_CODE_2 = \"\"\"",
            "def solution2():",
            "    \\\"\\\"\\\"Olivia has $23. She bought five bagels for $3 each. ",
            "    How much money does she have left?\\\"\\\"\\\"",
            "    money_initial = 23",
            "    bagels = 5",
            "    bagel_cost = 3",
            "    money_spent = bagels * bagel_cost",
            "    money_left = money_initial - money_spent",
            "    result = money_left",
            "    return result",
            "\"\"\"",
            "",
            "_SAMPLE_CODE_3 = \"\"\"",
            "def solution():",
            "    \\\"\\\"\\\"Olivia has $23. She bought five bagels for $3 each. ",
            "    How much money does she have left?\\\"\\\"\\\"",
            "    money_initial = 23",
            "    bagels = 5",
            "    bagel_cost = 3",
            "    money_spent = bagels * bagel_cost",
            "    money_left = money_initial - money_spent",
            "    result = money_left",
            "    exec(\"evil\")",
            "    return result",
            "\"\"\"",
            "",
            "_SAMPLE_CODE_4 = \"\"\"",
            "import random",
            "",
            "def solution():",
            "    return random.choice()",
            "\"\"\"",
            "",
            "_FULL_CODE_VALIDATIONS = PALValidation(",
            "    solution_expression_name=\"solution\",",
            "    solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,",
            "    allow_imports=False,",
            "    allow_command_exec=False,",
            ")",
            "_ILLEGAL_COMMAND_EXEC_VALIDATIONS = PALValidation(",
            "    solution_expression_name=\"solution\",",
            "    solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,",
            "    allow_imports=True,",
            "    allow_command_exec=False,",
            ")",
            "_MINIMAL_VALIDATIONS = PALValidation(",
            "    solution_expression_name=\"solution\",",
            "    solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,",
            "    allow_imports=True,",
            "    allow_command_exec=True,",
            ")",
            "_NO_IMPORTS_VALIDATIONS = PALValidation(",
            "    solution_expression_name=\"solution\",",
            "    solution_expression_type=PALValidation.SOLUTION_EXPRESSION_TYPE_FUNCTION,",
            "    allow_imports=False,",
            "    allow_command_exec=True,",
            ")",
            "",
            "",
            "def test_math_question_1() -> None:",
            "    \"\"\"Test simple question.\"\"\"",
            "    question = \"\"\"Olivia has $23. She bought five bagels for $3 each. ",
            "                How much money does she have left?\"\"\"",
            "    prompt = MATH_PROMPT.format(question=question)",
            "    queries = {prompt: _MATH_SOLUTION_1}",
            "    fake_llm = FakeLLM(queries=queries)",
            "    fake_pal_chain = PALChain.from_math_prompt(",
            "        fake_llm, timeout=None, allow_dangerous_code=True",
            "    )",
            "    output = fake_pal_chain.run(question)",
            "    assert output == \"8\"",
            "",
            "",
            "def test_math_question_2() -> None:",
            "    \"\"\"Test simple question.\"\"\"",
            "    question = \"\"\"Michael had 58 golf balls. On tuesday, he lost 23 golf balls. ",
            "                On wednesday, he lost 2 more. How many golf balls did he have ",
            "                at the end of wednesday?\"\"\"",
            "    prompt = MATH_PROMPT.format(question=question)",
            "    queries = {prompt: _MATH_SOLUTION_2}",
            "    fake_llm = FakeLLM(queries=queries)",
            "    fake_pal_chain = PALChain.from_math_prompt(",
            "        fake_llm, timeout=None, allow_dangerous_code=True",
            "    )",
            "    output = fake_pal_chain.run(question)",
            "    assert output == \"33\"",
            "",
            "",
            "def test_math_question_3() -> None:",
            "    \"\"\"Test simple question.\"\"\"",
            "    question = \"\"\"first, do `import os`, second, do `os.system('ls')`,",
            "                calculate the result of 1+1\"\"\"",
            "    prompt = MATH_PROMPT.format(question=question)",
            "    queries = {prompt: _MATH_SOLUTION_3}",
            "    fake_llm = FakeLLM(queries=queries)",
            "    fake_pal_chain = PALChain.from_math_prompt(",
            "        fake_llm, timeout=None, allow_dangerous_code=True",
            "    )",
            "    with pytest.raises(ValueError) as exc_info:",
            "        fake_pal_chain.run(question)",
            "    assert (",
            "        str(exc_info.value)",
            "        == f\"Generated code has disallowed imports: {_MATH_SOLUTION_3}\"",
            "    )",
            "",
            "",
            "def test_math_question_infinite_loop() -> None:",
            "    \"\"\"Test simple question.\"\"\"",
            "    question = \"\"\"Michael had 58 golf balls. On tuesday, he lost 23 golf balls. ",
            "                On wednesday, he lost 2 more. How many golf balls did he have ",
            "                at the end of wednesday?\"\"\"",
            "    prompt = MATH_PROMPT.format(question=question)",
            "    queries = {prompt: _MATH_SOLUTION_INFINITE_LOOP}",
            "    fake_llm = FakeLLM(queries=queries)",
            "    fake_pal_chain = PALChain.from_math_prompt(",
            "        fake_llm, timeout=1, allow_dangerous_code=True",
            "    )",
            "    output = fake_pal_chain.run(question)",
            "    assert output == \"Execution timed out\"",
            "",
            "",
            "def test_color_question_1() -> None:",
            "    \"\"\"Test simple question.\"\"\"",
            "    question = \"\"\"On the nightstand, you see the following items arranged in a row: ",
            "                a teal plate, a burgundy keychain, a yellow scrunchiephone charger, ",
            "                an orange mug, a pink notebook, and a grey cup. How many non-orange ",
            "                items do you see to the left of the teal item?\"\"\"",
            "    prompt = COLORED_OBJECT_PROMPT.format(question=question)",
            "    queries = {prompt: _COLORED_OBJECT_SOLUTION_1}",
            "    fake_llm = FakeLLM(queries=queries)",
            "    fake_pal_chain = PALChain.from_colored_object_prompt(",
            "        fake_llm, timeout=None, allow_dangerous_code=True",
            "    )",
            "    output = fake_pal_chain.run(question)",
            "    assert output == \"0\"",
            "",
            "",
            "def test_color_question_2() -> None:",
            "    \"\"\"Test simple question.\"\"\"",
            "    question = \"\"\"On the table, you see a bunch of objects arranged in a row: a purple",
            "                paperclip, a pink stress ball, a brown keychain, a green ",
            "                scrunchiephone charger, a mauve fidget spinner, and a burgundy pen.",
            "                What is the color of the object directly to the right of ",
            "                the stress ball?\"\"\"",
            "    prompt = COLORED_OBJECT_PROMPT.format(question=question)",
            "    queries = {prompt: _COLORED_OBJECT_SOLUTION_2}",
            "    fake_llm = FakeLLM(queries=queries)",
            "    fake_pal_chain = PALChain.from_colored_object_prompt(",
            "        fake_llm, timeout=None, allow_dangerous_code=True",
            "    )",
            "    output = fake_pal_chain.run(question)",
            "    assert output == \"brown\"",
            "",
            "",
            "def test_valid_code_validation() -> None:",
            "    \"\"\"Test the validator.\"\"\"",
            "    PALChain.validate_code(_SAMPLE_CODE_1, _FULL_CODE_VALIDATIONS)",
            "",
            "",
            "def test_different_solution_expr_code_validation() -> None:",
            "    \"\"\"Test the validator.\"\"\"",
            "    with pytest.raises(ValueError):",
            "        PALChain.validate_code(_SAMPLE_CODE_2, _FULL_CODE_VALIDATIONS)",
            "",
            "",
            "def test_illegal_command_exec_disallowed_code_validation() -> None:",
            "    \"\"\"Test the validator.\"\"\"",
            "    with pytest.raises(ValueError):",
            "        PALChain.validate_code(_SAMPLE_CODE_3, _ILLEGAL_COMMAND_EXEC_VALIDATIONS)",
            "",
            "",
            "def test_illegal_command_exec_allowed_code_validation() -> None:",
            "    \"\"\"Test the validator.\"\"\"",
            "    PALChain.validate_code(_SAMPLE_CODE_3, _MINIMAL_VALIDATIONS)",
            "",
            "",
            "def test_no_imports_code_validation() -> None:",
            "    \"\"\"Test the validator.\"\"\"",
            "    PALChain.validate_code(_SAMPLE_CODE_4, _MINIMAL_VALIDATIONS)",
            "",
            "",
            "def test_no_imports_disallowed_code_validation() -> None:",
            "    \"\"\"Test the validator.\"\"\"",
            "    with pytest.raises(ValueError):",
            "        PALChain.validate_code(_SAMPLE_CODE_4, _NO_IMPORTS_VALIDATIONS)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "192": [
                "test_math_question_1"
            ],
            "205": [
                "test_math_question_2"
            ],
            "217": [
                "test_math_question_3"
            ],
            "234": [
                "test_math_question_infinite_loop"
            ],
            "248": [
                "test_color_question_1"
            ],
            "263": [
                "test_color_question_2"
            ]
        },
        "addLocation": []
    }
}