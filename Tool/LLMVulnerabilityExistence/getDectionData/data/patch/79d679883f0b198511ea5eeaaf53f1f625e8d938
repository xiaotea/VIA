{
    "src/saml2/aes.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " POSTFIX_MODE = {"
            },
            "1": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": "     'cbc': modes.CBC,"
            },
            "2": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": "     'cfb': modes.CFB,"
            },
            "3": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    'ecb': modes.ECB,"
            },
            "4": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " }"
            },
            "5": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " AES_BLOCK_SIZE = int(algorithms.AES.block_size / 8)"
            },
            "7": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " class AESCipher(object):"
            },
            "10": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def __init__(self, key, iv=None):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 20,
                "PatchRowcode": "+    def __init__(self, key):"
            },
            "12": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 21,
                "PatchRowcode": "         \"\"\""
            },
            "13": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "         :param key: The encryption key"
            },
            "14": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        :param iv: Init vector"
            },
            "15": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "         :return: AESCipher instance"
            },
            "16": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "         \"\"\""
            },
            "17": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "         self.key = key"
            },
            "18": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.iv = iv"
            },
            "19": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "20": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def build_cipher(self, iv=None, alg='aes_128_cbc'):"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+    def build_cipher(self, alg='aes_128_cbc'):"
            },
            "22": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "         \"\"\""
            },
            "23": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        :param iv: init vector"
            },
            "24": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "         :param alg: cipher algorithm"
            },
            "25": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "         :return: A Cipher instance"
            },
            "26": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "         \"\"\""
            },
            "27": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "         typ, bits, cmode = alg.lower().split('_')"
            },
            "28": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "         bits = int(bits)"
            },
            "29": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "30": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not iv:"
            },
            "31": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if self.iv:"
            },
            "32": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                iv = self.iv"
            },
            "33": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            else:"
            },
            "34": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                iv = os.urandom(AES_BLOCK_SIZE)"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 34,
                "PatchRowcode": "+        iv = os.urandom(AES_BLOCK_SIZE)"
            },
            "36": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": 35,
                "PatchRowcode": " "
            },
            "37": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         if len(iv) != AES_BLOCK_SIZE:"
            },
            "38": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "             raise Exception('Wrong iv size: {}'.format(len(iv)))"
            },
            "39": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " "
            },
            "40": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 55,
                "PatchRowcode": "         return cipher, iv"
            },
            "41": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " "
            },
            "42": {
                "beforePatchRowNumber": 66,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def encrypt(self, msg, iv=None, alg='aes_128_cbc', padding='PKCS#7',"
            },
            "43": {
                "beforePatchRowNumber": 67,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                b64enc=True, block_size=AES_BLOCK_SIZE):"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+    def encrypt(self, msg, alg='aes_128_cbc', padding='PKCS#7', b64enc=True,"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+                block_size=AES_BLOCK_SIZE):"
            },
            "46": {
                "beforePatchRowNumber": 68,
                "afterPatchRowNumber": 59,
                "PatchRowcode": "         \"\"\""
            },
            "47": {
                "beforePatchRowNumber": 69,
                "afterPatchRowNumber": 60,
                "PatchRowcode": "         :param key: The encryption key"
            },
            "48": {
                "beforePatchRowNumber": 70,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        :param iv: init vector"
            },
            "49": {
                "beforePatchRowNumber": 71,
                "afterPatchRowNumber": 61,
                "PatchRowcode": "         :param msg: Message to be encrypted"
            },
            "50": {
                "beforePatchRowNumber": 72,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "         :param padding: Which padding that should be used"
            },
            "51": {
                "beforePatchRowNumber": 73,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "         :param b64enc: Whether the result should be base64encoded"
            },
            "52": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 77,
                "PatchRowcode": "             c = chr(plen).encode()"
            },
            "53": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": 78,
                "PatchRowcode": "             msg += c * plen"
            },
            "54": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 79,
                "PatchRowcode": " "
            },
            "55": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        cipher, iv = self.build_cipher(iv, alg)"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+        cipher, iv = self.build_cipher(alg)"
            },
            "57": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": 81,
                "PatchRowcode": "         encryptor = cipher.encryptor()"
            },
            "58": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 82,
                "PatchRowcode": "         cmsg = iv + encryptor.update(msg) + encryptor.finalize()"
            },
            "59": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 83,
                "PatchRowcode": " "
            },
            "60": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 88,
                "PatchRowcode": " "
            },
            "61": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "         return enc_msg"
            },
            "62": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": 90,
                "PatchRowcode": " "
            },
            "63": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    def decrypt(self, msg, iv=None, alg='aes_128_cbc', padding='PKCS#7',"
            },
            "64": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                b64dec=True):"
            },
            "65": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+    def decrypt(self, msg, alg='aes_128_cbc', padding='PKCS#7', b64dec=True):"
            },
            "66": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": 92,
                "PatchRowcode": "         \"\"\""
            },
            "67": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": 93,
                "PatchRowcode": "         :param key: The encryption key"
            },
            "68": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        :param iv: init vector"
            },
            "69": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "         :param msg: Base64 encoded message to be decrypted"
            },
            "70": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "         :return: The decrypted message"
            },
            "71": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "         \"\"\""
            },
            "72": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "         data = b64decode(msg) if b64dec else msg"
            },
            "73": {
                "beforePatchRowNumber": 110,
                "afterPatchRowNumber": 98,
                "PatchRowcode": " "
            },
            "74": {
                "beforePatchRowNumber": 111,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        _iv = data[:AES_BLOCK_SIZE]"
            },
            "75": {
                "beforePatchRowNumber": 112,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if iv:"
            },
            "76": {
                "beforePatchRowNumber": 113,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            assert iv == _iv"
            },
            "77": {
                "beforePatchRowNumber": 114,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        cipher, iv = self.build_cipher(iv, alg=alg)"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+        cipher, iv = self.build_cipher(alg=alg)"
            },
            "79": {
                "beforePatchRowNumber": 115,
                "afterPatchRowNumber": 100,
                "PatchRowcode": "         decryptor = cipher.decryptor()"
            },
            "80": {
                "beforePatchRowNumber": 116,
                "afterPatchRowNumber": 101,
                "PatchRowcode": "         res = decryptor.update(data)[AES_BLOCK_SIZE:] + decryptor.finalize()"
            },
            "81": {
                "beforePatchRowNumber": 117,
                "afterPatchRowNumber": 102,
                "PatchRowcode": "         if padding in ['PKCS#5', 'PKCS#7']:"
            },
            "82": {
                "beforePatchRowNumber": 118,
                "afterPatchRowNumber": 103,
                "PatchRowcode": "             idx = bytearray(res)[-1]"
            },
            "83": {
                "beforePatchRowNumber": 119,
                "afterPatchRowNumber": 104,
                "PatchRowcode": "             res = res[:-idx]"
            },
            "84": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 105,
                "PatchRowcode": "         return res"
            },
            "85": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "86": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "87": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-def run_test():"
            },
            "88": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    key = b'1234523451234545'  # 16 byte key"
            },
            "89": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    iv = os.urandom(AES_BLOCK_SIZE)"
            },
            "90": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    # Iff padded, the message doesn't have to be multiple of 16 in length"
            },
            "91": {
                "beforePatchRowNumber": 127,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    original_msg = b'ToBeOrNotTobe W.S.'"
            },
            "92": {
                "beforePatchRowNumber": 128,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    aes = AESCipher(key)"
            },
            "93": {
                "beforePatchRowNumber": 129,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "94": {
                "beforePatchRowNumber": 130,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    encrypted_msg = aes.encrypt(original_msg, iv)"
            },
            "95": {
                "beforePatchRowNumber": 131,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    decrypted_msg = aes.decrypt(encrypted_msg, iv)"
            },
            "96": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert decrypted_msg == original_msg"
            },
            "97": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "98": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    encrypted_msg = aes.encrypt(original_msg)"
            },
            "99": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    decrypted_msg = aes.decrypt(encrypted_msg)"
            },
            "100": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert decrypted_msg == original_msg"
            },
            "101": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "102": {
                "beforePatchRowNumber": 138,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    aes = AESCipher(key, iv)"
            },
            "103": {
                "beforePatchRowNumber": 139,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    encrypted_msg = aes.encrypt(original_msg)"
            },
            "104": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    decrypted_msg = aes.decrypt(encrypted_msg)"
            },
            "105": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    assert decrypted_msg == original_msg"
            },
            "106": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "107": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "108": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-if __name__ == '__main__':"
            },
            "109": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    run_test()"
            }
        },
        "frontPatchFile": [
            "import os",
            "from base64 import b64decode",
            "from base64 import b64encode",
            "",
            "from cryptography.hazmat.backends import default_backend",
            "from cryptography.hazmat.primitives.ciphers import Cipher",
            "from cryptography.hazmat.primitives.ciphers import algorithms",
            "from cryptography.hazmat.primitives.ciphers import modes",
            "",
            "",
            "POSTFIX_MODE = {",
            "    'cbc': modes.CBC,",
            "    'cfb': modes.CFB,",
            "    'ecb': modes.ECB,",
            "}",
            "",
            "AES_BLOCK_SIZE = int(algorithms.AES.block_size / 8)",
            "",
            "",
            "class AESCipher(object):",
            "    def __init__(self, key, iv=None):",
            "        \"\"\"",
            "        :param key: The encryption key",
            "        :param iv: Init vector",
            "        :return: AESCipher instance",
            "        \"\"\"",
            "        self.key = key",
            "        self.iv = iv",
            "",
            "    def build_cipher(self, iv=None, alg='aes_128_cbc'):",
            "        \"\"\"",
            "        :param iv: init vector",
            "        :param alg: cipher algorithm",
            "        :return: A Cipher instance",
            "        \"\"\"",
            "        typ, bits, cmode = alg.lower().split('_')",
            "        bits = int(bits)",
            "",
            "        if not iv:",
            "            if self.iv:",
            "                iv = self.iv",
            "            else:",
            "                iv = os.urandom(AES_BLOCK_SIZE)",
            "",
            "        if len(iv) != AES_BLOCK_SIZE:",
            "            raise Exception('Wrong iv size: {}'.format(len(iv)))",
            "",
            "        if bits not in algorithms.AES.key_sizes:",
            "            raise Exception('Unsupported key length: {}'.format(bits))",
            "",
            "        if len(self.key) != bits / 8:",
            "            raise Exception('Wrong Key length: {}'.format(len(self.key)))",
            "",
            "        try:",
            "            mode = POSTFIX_MODE[cmode]",
            "        except KeyError:",
            "            raise Exception('Unsupported chaining mode: {}'.format(cmode))",
            "",
            "        cipher = Cipher(",
            "                algorithms.AES(self.key),",
            "                mode(iv),",
            "                backend=default_backend())",
            "",
            "        return cipher, iv",
            "",
            "    def encrypt(self, msg, iv=None, alg='aes_128_cbc', padding='PKCS#7',",
            "                b64enc=True, block_size=AES_BLOCK_SIZE):",
            "        \"\"\"",
            "        :param key: The encryption key",
            "        :param iv: init vector",
            "        :param msg: Message to be encrypted",
            "        :param padding: Which padding that should be used",
            "        :param b64enc: Whether the result should be base64encoded",
            "        :param block_size: If PKCS#7 padding which block size to use",
            "        :return: The encrypted message",
            "        \"\"\"",
            "",
            "        if padding == 'PKCS#7':",
            "            _block_size = block_size",
            "        elif padding == 'PKCS#5':",
            "            _block_size = 8",
            "        else:",
            "            _block_size = 0",
            "",
            "        if _block_size:",
            "            plen = _block_size - (len(msg) % _block_size)",
            "            c = chr(plen).encode()",
            "            msg += c * plen",
            "",
            "        cipher, iv = self.build_cipher(iv, alg)",
            "        encryptor = cipher.encryptor()",
            "        cmsg = iv + encryptor.update(msg) + encryptor.finalize()",
            "",
            "        if b64enc:",
            "            enc_msg = b64encode(cmsg)",
            "        else:",
            "            enc_msg = cmsg",
            "",
            "        return enc_msg",
            "",
            "    def decrypt(self, msg, iv=None, alg='aes_128_cbc', padding='PKCS#7',",
            "                b64dec=True):",
            "        \"\"\"",
            "        :param key: The encryption key",
            "        :param iv: init vector",
            "        :param msg: Base64 encoded message to be decrypted",
            "        :return: The decrypted message",
            "        \"\"\"",
            "        data = b64decode(msg) if b64dec else msg",
            "",
            "        _iv = data[:AES_BLOCK_SIZE]",
            "        if iv:",
            "            assert iv == _iv",
            "        cipher, iv = self.build_cipher(iv, alg=alg)",
            "        decryptor = cipher.decryptor()",
            "        res = decryptor.update(data)[AES_BLOCK_SIZE:] + decryptor.finalize()",
            "        if padding in ['PKCS#5', 'PKCS#7']:",
            "            idx = bytearray(res)[-1]",
            "            res = res[:-idx]",
            "        return res",
            "",
            "",
            "def run_test():",
            "    key = b'1234523451234545'  # 16 byte key",
            "    iv = os.urandom(AES_BLOCK_SIZE)",
            "    # Iff padded, the message doesn't have to be multiple of 16 in length",
            "    original_msg = b'ToBeOrNotTobe W.S.'",
            "    aes = AESCipher(key)",
            "",
            "    encrypted_msg = aes.encrypt(original_msg, iv)",
            "    decrypted_msg = aes.decrypt(encrypted_msg, iv)",
            "    assert decrypted_msg == original_msg",
            "",
            "    encrypted_msg = aes.encrypt(original_msg)",
            "    decrypted_msg = aes.decrypt(encrypted_msg)",
            "    assert decrypted_msg == original_msg",
            "",
            "    aes = AESCipher(key, iv)",
            "    encrypted_msg = aes.encrypt(original_msg)",
            "    decrypted_msg = aes.decrypt(encrypted_msg)",
            "    assert decrypted_msg == original_msg",
            "",
            "",
            "if __name__ == '__main__':",
            "    run_test()"
        ],
        "afterPatchFile": [
            "import os",
            "from base64 import b64decode",
            "from base64 import b64encode",
            "",
            "from cryptography.hazmat.backends import default_backend",
            "from cryptography.hazmat.primitives.ciphers import Cipher",
            "from cryptography.hazmat.primitives.ciphers import algorithms",
            "from cryptography.hazmat.primitives.ciphers import modes",
            "",
            "",
            "POSTFIX_MODE = {",
            "    'cbc': modes.CBC,",
            "    'cfb': modes.CFB,",
            "}",
            "",
            "AES_BLOCK_SIZE = int(algorithms.AES.block_size / 8)",
            "",
            "",
            "class AESCipher(object):",
            "    def __init__(self, key):",
            "        \"\"\"",
            "        :param key: The encryption key",
            "        :return: AESCipher instance",
            "        \"\"\"",
            "        self.key = key",
            "",
            "    def build_cipher(self, alg='aes_128_cbc'):",
            "        \"\"\"",
            "        :param alg: cipher algorithm",
            "        :return: A Cipher instance",
            "        \"\"\"",
            "        typ, bits, cmode = alg.lower().split('_')",
            "        bits = int(bits)",
            "        iv = os.urandom(AES_BLOCK_SIZE)",
            "",
            "        if len(iv) != AES_BLOCK_SIZE:",
            "            raise Exception('Wrong iv size: {}'.format(len(iv)))",
            "",
            "        if bits not in algorithms.AES.key_sizes:",
            "            raise Exception('Unsupported key length: {}'.format(bits))",
            "",
            "        if len(self.key) != bits / 8:",
            "            raise Exception('Wrong Key length: {}'.format(len(self.key)))",
            "",
            "        try:",
            "            mode = POSTFIX_MODE[cmode]",
            "        except KeyError:",
            "            raise Exception('Unsupported chaining mode: {}'.format(cmode))",
            "",
            "        cipher = Cipher(",
            "                algorithms.AES(self.key),",
            "                mode(iv),",
            "                backend=default_backend())",
            "",
            "        return cipher, iv",
            "",
            "    def encrypt(self, msg, alg='aes_128_cbc', padding='PKCS#7', b64enc=True,",
            "                block_size=AES_BLOCK_SIZE):",
            "        \"\"\"",
            "        :param key: The encryption key",
            "        :param msg: Message to be encrypted",
            "        :param padding: Which padding that should be used",
            "        :param b64enc: Whether the result should be base64encoded",
            "        :param block_size: If PKCS#7 padding which block size to use",
            "        :return: The encrypted message",
            "        \"\"\"",
            "",
            "        if padding == 'PKCS#7':",
            "            _block_size = block_size",
            "        elif padding == 'PKCS#5':",
            "            _block_size = 8",
            "        else:",
            "            _block_size = 0",
            "",
            "        if _block_size:",
            "            plen = _block_size - (len(msg) % _block_size)",
            "            c = chr(plen).encode()",
            "            msg += c * plen",
            "",
            "        cipher, iv = self.build_cipher(alg)",
            "        encryptor = cipher.encryptor()",
            "        cmsg = iv + encryptor.update(msg) + encryptor.finalize()",
            "",
            "        if b64enc:",
            "            enc_msg = b64encode(cmsg)",
            "        else:",
            "            enc_msg = cmsg",
            "",
            "        return enc_msg",
            "",
            "    def decrypt(self, msg, alg='aes_128_cbc', padding='PKCS#7', b64dec=True):",
            "        \"\"\"",
            "        :param key: The encryption key",
            "        :param msg: Base64 encoded message to be decrypted",
            "        :return: The decrypted message",
            "        \"\"\"",
            "        data = b64decode(msg) if b64dec else msg",
            "",
            "        cipher, iv = self.build_cipher(alg=alg)",
            "        decryptor = cipher.decryptor()",
            "        res = decryptor.update(data)[AES_BLOCK_SIZE:] + decryptor.finalize()",
            "        if padding in ['PKCS#5', 'PKCS#7']:",
            "            idx = bytearray(res)[-1]",
            "            res = res[:-idx]",
            "        return res"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "2",
            "0",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2"
        ],
        "dele_reviseLocation": {
            "14": [],
            "21": [
                "AESCipher",
                "__init__"
            ],
            "24": [
                "AESCipher",
                "__init__"
            ],
            "28": [
                "AESCipher",
                "__init__"
            ],
            "30": [
                "AESCipher",
                "build_cipher"
            ],
            "32": [
                "AESCipher",
                "build_cipher"
            ],
            "38": [
                "AESCipher",
                "build_cipher"
            ],
            "39": [
                "AESCipher",
                "build_cipher"
            ],
            "40": [
                "AESCipher",
                "build_cipher"
            ],
            "41": [
                "AESCipher",
                "build_cipher"
            ],
            "42": [
                "AESCipher",
                "build_cipher"
            ],
            "43": [
                "AESCipher",
                "build_cipher"
            ],
            "66": [
                "AESCipher",
                "encrypt"
            ],
            "67": [
                "AESCipher",
                "encrypt"
            ],
            "70": [
                "AESCipher",
                "encrypt"
            ],
            "90": [
                "AESCipher",
                "encrypt"
            ],
            "101": [
                "AESCipher",
                "decrypt"
            ],
            "102": [
                "AESCipher",
                "decrypt"
            ],
            "105": [
                "AESCipher",
                "decrypt"
            ],
            "111": [
                "AESCipher",
                "decrypt"
            ],
            "112": [
                "AESCipher",
                "decrypt"
            ],
            "113": [
                "AESCipher",
                "decrypt"
            ],
            "114": [
                "AESCipher",
                "decrypt"
            ],
            "121": [],
            "122": [],
            "123": [
                "run_test"
            ],
            "124": [
                "run_test"
            ],
            "125": [
                "run_test"
            ],
            "126": [
                "run_test"
            ],
            "127": [
                "run_test"
            ],
            "128": [
                "run_test"
            ],
            "129": [
                "run_test"
            ],
            "130": [
                "run_test"
            ],
            "131": [
                "run_test"
            ],
            "132": [
                "run_test"
            ],
            "133": [
                "run_test"
            ],
            "134": [
                "run_test"
            ],
            "135": [
                "run_test"
            ],
            "136": [
                "run_test"
            ],
            "137": [
                "run_test"
            ],
            "138": [
                "run_test"
            ],
            "139": [
                "run_test"
            ],
            "140": [
                "run_test"
            ],
            "141": [
                "run_test"
            ],
            "142": [],
            "143": [],
            "144": [],
            "145": []
        },
        "addLocation": []
    },
    "src/saml2/authn.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 120,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "         self.return_to = return_to"
            },
            "1": {
                "beforePatchRowNumber": 121,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "         self.active = {}"
            },
            "2": {
                "beforePatchRowNumber": 122,
                "afterPatchRowNumber": 122,
                "PatchRowcode": "         self.query_param = \"upm_answer\""
            },
            "3": {
                "beforePatchRowNumber": 123,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.aes = AESCipher(self.srv.symkey.encode(), srv.iv)"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 123,
                "PatchRowcode": "+        self.aes = AESCipher(self.srv.symkey.encode())"
            },
            "5": {
                "beforePatchRowNumber": 124,
                "afterPatchRowNumber": 124,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 125,
                "afterPatchRowNumber": 125,
                "PatchRowcode": "     def __call__(self, cookie=None, policy_url=None, logo_url=None,"
            },
            "7": {
                "beforePatchRowNumber": 126,
                "afterPatchRowNumber": 126,
                "PatchRowcode": "                  query=\"\", **kwargs):"
            }
        },
        "frontPatchFile": [
            "import logging",
            "import six",
            "import time",
            "from saml2 import SAMLError",
            "from saml2.aes import AESCipher",
            "from saml2.httputil import Response",
            "from saml2.httputil import make_cookie",
            "from saml2.httputil import Redirect",
            "from saml2.httputil import Unauthorized",
            "from saml2.httputil import parse_cookie",
            "",
            "from six.moves.urllib.parse import urlencode, parse_qs, urlsplit",
            "",
            "__author__ = 'rolandh'",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class AuthnFailure(SAMLError):",
            "    pass",
            "",
            "",
            "class EncodeError(SAMLError):",
            "    pass",
            "",
            "",
            "class UserAuthnMethod(object):",
            "    def __init__(self, srv):",
            "        self.srv = srv",
            "",
            "    def __call__(self, *args, **kwargs):",
            "        raise NotImplemented",
            "",
            "    def authenticated_as(self, **kwargs):",
            "        raise NotImplemented",
            "",
            "    def verify(self, **kwargs):",
            "        raise NotImplemented",
            "",
            "",
            "def is_equal(a, b):",
            "    if len(a) != len(b):",
            "        return False",
            "",
            "    result = 0",
            "    for x, y in zip(a, b):",
            "        result |= x ^ y",
            "    return result == 0",
            "",
            "",
            "def url_encode_params(params=None):",
            "    if not isinstance(params, dict):",
            "        raise EncodeError(\"You must pass in a dictionary!\")",
            "    params_list = []",
            "    for k, v in params.items():",
            "        if isinstance(v, list):",
            "            params_list.extend([(k, x) for x in v])",
            "        else:",
            "            params_list.append((k, v))",
            "    return urlencode(params_list)",
            "",
            "",
            "def create_return_url(base, query, **kwargs):",
            "    \"\"\"",
            "    Add a query string plus extra parameters to a base URL which may contain",
            "    a query part already.",
            "",
            "    :param base: redirect_uri may contain a query part, no fragment allowed.",
            "    :param query: Old query part as a string",
            "    :param kwargs: extra query parameters",
            "    :return:",
            "    \"\"\"",
            "    part = urlsplit(base)",
            "    if part.fragment:",
            "        raise ValueError(\"Base URL contained parts it shouldn't\")",
            "",
            "    for key, values in parse_qs(query).items():",
            "        if key in kwargs:",
            "            if isinstance(kwargs[key], six.string_types):",
            "                kwargs[key] = [kwargs[key]]",
            "            kwargs[key].extend(values)",
            "        else:",
            "            kwargs[key] = values",
            "",
            "    if part.query:",
            "        for key, values in parse_qs(part.query).items():",
            "            if key in kwargs:",
            "                if isinstance(kwargs[key], six.string_types):",
            "                    kwargs[key] = [kwargs[key]]",
            "                kwargs[key].extend(values)",
            "            else:",
            "                kwargs[key] = values",
            "",
            "        _pre = base.split(\"?\")[0]",
            "    else:",
            "        _pre = base",
            "",
            "    logger.debug(\"kwargs: %s\" % kwargs)",
            "",
            "    return \"%s?%s\" % (_pre, url_encode_params(kwargs))",
            "",
            "",
            "class UsernamePasswordMako(UserAuthnMethod):",
            "    \"\"\"Do user authentication using the normal username password form",
            "    using Mako as template system\"\"\"",
            "    cookie_name = \"userpassmako\"",
            "",
            "    def __init__(self, srv, mako_template, template_lookup, pwd, return_to):",
            "        \"\"\"",
            "        :param srv: The server instance",
            "        :param mako_template: Which Mako template to use",
            "        :param pwd: Username/password dictionary like database",
            "        :param return_to: Where to send the user after authentication",
            "        :return:",
            "        \"\"\"",
            "        UserAuthnMethod.__init__(self, srv)",
            "        self.mako_template = mako_template",
            "        self.template_lookup = template_lookup",
            "        self.passwd = pwd",
            "        self.return_to = return_to",
            "        self.active = {}",
            "        self.query_param = \"upm_answer\"",
            "        self.aes = AESCipher(self.srv.symkey.encode(), srv.iv)",
            "",
            "    def __call__(self, cookie=None, policy_url=None, logo_url=None,",
            "                 query=\"\", **kwargs):",
            "        \"\"\"",
            "        Put up the login form",
            "        \"\"\"",
            "        if cookie:",
            "            headers = [cookie]",
            "        else:",
            "            headers = []",
            "",
            "        resp = Response(headers=headers)",
            "",
            "        argv = {\"login\": \"\",",
            "                \"password\": \"\",",
            "                \"action\": \"verify\",",
            "                \"policy_url\": policy_url,",
            "                \"logo_url\": logo_url,",
            "                \"query\": query}",
            "        logger.info(\"do_authentication argv: %s\" % argv)",
            "        mte = self.template_lookup.get_template(self.mako_template)",
            "        resp.message = mte.render(**argv)",
            "        return resp",
            "",
            "    def _verify(self, pwd, user):",
            "        if not is_equal(pwd, self.passwd[user]):",
            "            raise ValueError(\"Wrong password\")",
            "",
            "    def verify(self, request, **kwargs):",
            "        \"\"\"",
            "        Verifies that the given username and password was correct",
            "        :param request: Either the query part of a URL a urlencoded",
            "            body of a HTTP message or a parse such.",
            "        :param kwargs: Catch whatever else is sent.",
            "        :return: redirect back to where ever the base applications",
            "            wants the user after authentication.",
            "        \"\"\"",
            "",
            "        #logger.debug(\"verify(%s)\" % request)",
            "        if isinstance(request, six.string_types):",
            "            _dict = parse_qs(request)",
            "        elif isinstance(request, dict):",
            "            _dict = request",
            "        else:",
            "            raise ValueError(\"Wrong type of input\")",
            "",
            "        # verify username and password",
            "        try:",
            "            self._verify(_dict[\"password\"][0], _dict[\"login\"][0])",
            "            timestamp = str(int(time.mktime(time.gmtime())))",
            "            msg = \"::\".join([_dict[\"login\"][0], timestamp])",
            "            info = self.aes.encrypt(msg.encode())",
            "            self.active[info] = timestamp",
            "            cookie = make_cookie(self.cookie_name, info, self.srv.seed)",
            "            return_to = create_return_url(self.return_to, _dict[\"query\"][0],",
            "                                          **{self.query_param: \"true\"})",
            "            resp = Redirect(return_to, headers=[cookie])",
            "        except (ValueError, KeyError):",
            "            resp = Unauthorized(\"Unknown user or wrong password\")",
            "",
            "        return resp",
            "",
            "    def authenticated_as(self, cookie=None, **kwargs):",
            "        if cookie is None:",
            "            return None",
            "        else:",
            "            logger.debug(\"kwargs: %s\" % kwargs)",
            "            try:",
            "                info, timestamp = parse_cookie(self.cookie_name,",
            "                                               self.srv.seed, cookie)",
            "                if self.active[info] == timestamp:",
            "                    msg = self.aes.decrypt(info).decode()",
            "                    uid, _ts = msg.split(\"::\")",
            "                    if timestamp == _ts:",
            "                        return {\"uid\": uid}",
            "            except Exception:",
            "                pass",
            "",
            "        return None",
            "",
            "    def done(self, areq):",
            "        try:",
            "            _ = areq[self.query_param]",
            "            return False",
            "        except KeyError:",
            "            return True",
            "",
            "",
            "class SocialService(UserAuthnMethod):",
            "    def __init__(self, social):",
            "        UserAuthnMethod.__init__(self, None)",
            "        self.social = social",
            "",
            "    def __call__(self, server_env, cookie=None, sid=\"\", query=\"\", **kwargs):",
            "        return self.social.begin(server_env, cookie, sid, query)",
            "",
            "    def callback(self, server_env, cookie=None, sid=\"\", query=\"\", **kwargs):",
            "        return self.social.callback(server_env, cookie, sid, query, **kwargs)",
            "",
            "",
            "class AuthnMethodChooser(object):",
            "    def __init__(self, methods=None):",
            "        self.methods = methods",
            "",
            "    def __call__(self, **kwargs):",
            "        if not self.methods:",
            "            raise SAMLError(\"No authentication methods defined\")",
            "        elif len(self.methods) == 1:",
            "            return self.methods[0]",
            "        else:",
            "            pass  # TODO",
            "",
            "try:",
            "    import ldap",
            "",
            "    class LDAPAuthn(UsernamePasswordMako):",
            "        def __init__(self, srv, ldapsrv, return_to,",
            "                     dn_pattern, mako_template, template_lookup):",
            "            \"\"\"",
            "            :param srv: The server instance",
            "            :param ldapsrv: Which LDAP server to us",
            "            :param return_to: Where to send the user after authentication",
            "            :return:",
            "            \"\"\"",
            "            UsernamePasswordMako.__init__(self, srv, mako_template, template_lookup,",
            "                                          None, return_to)",
            "",
            "            self.ldap = ldap.initialize(ldapsrv)",
            "            self.ldap.protocol_version = 3",
            "            self.ldap.set_option(ldap.OPT_REFERRALS, 0)",
            "            self.dn_pattern = dn_pattern",
            "",
            "        def _verify(self, pwd, user):",
            "            \"\"\"",
            "            Verifies the username and password agains a LDAP server",
            "            :param pwd: The password",
            "            :param user: The username",
            "            :return: AssertionError if the LDAP verification failed.",
            "            \"\"\"",
            "            _dn = self.dn_pattern % user",
            "            try:",
            "                self.ldap.simple_bind_s(_dn, pwd)",
            "            except Exception:",
            "                raise AssertionError()",
            "except ImportError:",
            "    class LDAPAuthn(UserAuthnMethod):",
            "        pass"
        ],
        "afterPatchFile": [
            "import logging",
            "import six",
            "import time",
            "from saml2 import SAMLError",
            "from saml2.aes import AESCipher",
            "from saml2.httputil import Response",
            "from saml2.httputil import make_cookie",
            "from saml2.httputil import Redirect",
            "from saml2.httputil import Unauthorized",
            "from saml2.httputil import parse_cookie",
            "",
            "from six.moves.urllib.parse import urlencode, parse_qs, urlsplit",
            "",
            "__author__ = 'rolandh'",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "",
            "class AuthnFailure(SAMLError):",
            "    pass",
            "",
            "",
            "class EncodeError(SAMLError):",
            "    pass",
            "",
            "",
            "class UserAuthnMethod(object):",
            "    def __init__(self, srv):",
            "        self.srv = srv",
            "",
            "    def __call__(self, *args, **kwargs):",
            "        raise NotImplemented",
            "",
            "    def authenticated_as(self, **kwargs):",
            "        raise NotImplemented",
            "",
            "    def verify(self, **kwargs):",
            "        raise NotImplemented",
            "",
            "",
            "def is_equal(a, b):",
            "    if len(a) != len(b):",
            "        return False",
            "",
            "    result = 0",
            "    for x, y in zip(a, b):",
            "        result |= x ^ y",
            "    return result == 0",
            "",
            "",
            "def url_encode_params(params=None):",
            "    if not isinstance(params, dict):",
            "        raise EncodeError(\"You must pass in a dictionary!\")",
            "    params_list = []",
            "    for k, v in params.items():",
            "        if isinstance(v, list):",
            "            params_list.extend([(k, x) for x in v])",
            "        else:",
            "            params_list.append((k, v))",
            "    return urlencode(params_list)",
            "",
            "",
            "def create_return_url(base, query, **kwargs):",
            "    \"\"\"",
            "    Add a query string plus extra parameters to a base URL which may contain",
            "    a query part already.",
            "",
            "    :param base: redirect_uri may contain a query part, no fragment allowed.",
            "    :param query: Old query part as a string",
            "    :param kwargs: extra query parameters",
            "    :return:",
            "    \"\"\"",
            "    part = urlsplit(base)",
            "    if part.fragment:",
            "        raise ValueError(\"Base URL contained parts it shouldn't\")",
            "",
            "    for key, values in parse_qs(query).items():",
            "        if key in kwargs:",
            "            if isinstance(kwargs[key], six.string_types):",
            "                kwargs[key] = [kwargs[key]]",
            "            kwargs[key].extend(values)",
            "        else:",
            "            kwargs[key] = values",
            "",
            "    if part.query:",
            "        for key, values in parse_qs(part.query).items():",
            "            if key in kwargs:",
            "                if isinstance(kwargs[key], six.string_types):",
            "                    kwargs[key] = [kwargs[key]]",
            "                kwargs[key].extend(values)",
            "            else:",
            "                kwargs[key] = values",
            "",
            "        _pre = base.split(\"?\")[0]",
            "    else:",
            "        _pre = base",
            "",
            "    logger.debug(\"kwargs: %s\" % kwargs)",
            "",
            "    return \"%s?%s\" % (_pre, url_encode_params(kwargs))",
            "",
            "",
            "class UsernamePasswordMako(UserAuthnMethod):",
            "    \"\"\"Do user authentication using the normal username password form",
            "    using Mako as template system\"\"\"",
            "    cookie_name = \"userpassmako\"",
            "",
            "    def __init__(self, srv, mako_template, template_lookup, pwd, return_to):",
            "        \"\"\"",
            "        :param srv: The server instance",
            "        :param mako_template: Which Mako template to use",
            "        :param pwd: Username/password dictionary like database",
            "        :param return_to: Where to send the user after authentication",
            "        :return:",
            "        \"\"\"",
            "        UserAuthnMethod.__init__(self, srv)",
            "        self.mako_template = mako_template",
            "        self.template_lookup = template_lookup",
            "        self.passwd = pwd",
            "        self.return_to = return_to",
            "        self.active = {}",
            "        self.query_param = \"upm_answer\"",
            "        self.aes = AESCipher(self.srv.symkey.encode())",
            "",
            "    def __call__(self, cookie=None, policy_url=None, logo_url=None,",
            "                 query=\"\", **kwargs):",
            "        \"\"\"",
            "        Put up the login form",
            "        \"\"\"",
            "        if cookie:",
            "            headers = [cookie]",
            "        else:",
            "            headers = []",
            "",
            "        resp = Response(headers=headers)",
            "",
            "        argv = {\"login\": \"\",",
            "                \"password\": \"\",",
            "                \"action\": \"verify\",",
            "                \"policy_url\": policy_url,",
            "                \"logo_url\": logo_url,",
            "                \"query\": query}",
            "        logger.info(\"do_authentication argv: %s\" % argv)",
            "        mte = self.template_lookup.get_template(self.mako_template)",
            "        resp.message = mte.render(**argv)",
            "        return resp",
            "",
            "    def _verify(self, pwd, user):",
            "        if not is_equal(pwd, self.passwd[user]):",
            "            raise ValueError(\"Wrong password\")",
            "",
            "    def verify(self, request, **kwargs):",
            "        \"\"\"",
            "        Verifies that the given username and password was correct",
            "        :param request: Either the query part of a URL a urlencoded",
            "            body of a HTTP message or a parse such.",
            "        :param kwargs: Catch whatever else is sent.",
            "        :return: redirect back to where ever the base applications",
            "            wants the user after authentication.",
            "        \"\"\"",
            "",
            "        #logger.debug(\"verify(%s)\" % request)",
            "        if isinstance(request, six.string_types):",
            "            _dict = parse_qs(request)",
            "        elif isinstance(request, dict):",
            "            _dict = request",
            "        else:",
            "            raise ValueError(\"Wrong type of input\")",
            "",
            "        # verify username and password",
            "        try:",
            "            self._verify(_dict[\"password\"][0], _dict[\"login\"][0])",
            "            timestamp = str(int(time.mktime(time.gmtime())))",
            "            msg = \"::\".join([_dict[\"login\"][0], timestamp])",
            "            info = self.aes.encrypt(msg.encode())",
            "            self.active[info] = timestamp",
            "            cookie = make_cookie(self.cookie_name, info, self.srv.seed)",
            "            return_to = create_return_url(self.return_to, _dict[\"query\"][0],",
            "                                          **{self.query_param: \"true\"})",
            "            resp = Redirect(return_to, headers=[cookie])",
            "        except (ValueError, KeyError):",
            "            resp = Unauthorized(\"Unknown user or wrong password\")",
            "",
            "        return resp",
            "",
            "    def authenticated_as(self, cookie=None, **kwargs):",
            "        if cookie is None:",
            "            return None",
            "        else:",
            "            logger.debug(\"kwargs: %s\" % kwargs)",
            "            try:",
            "                info, timestamp = parse_cookie(self.cookie_name,",
            "                                               self.srv.seed, cookie)",
            "                if self.active[info] == timestamp:",
            "                    msg = self.aes.decrypt(info).decode()",
            "                    uid, _ts = msg.split(\"::\")",
            "                    if timestamp == _ts:",
            "                        return {\"uid\": uid}",
            "            except Exception:",
            "                pass",
            "",
            "        return None",
            "",
            "    def done(self, areq):",
            "        try:",
            "            _ = areq[self.query_param]",
            "            return False",
            "        except KeyError:",
            "            return True",
            "",
            "",
            "class SocialService(UserAuthnMethod):",
            "    def __init__(self, social):",
            "        UserAuthnMethod.__init__(self, None)",
            "        self.social = social",
            "",
            "    def __call__(self, server_env, cookie=None, sid=\"\", query=\"\", **kwargs):",
            "        return self.social.begin(server_env, cookie, sid, query)",
            "",
            "    def callback(self, server_env, cookie=None, sid=\"\", query=\"\", **kwargs):",
            "        return self.social.callback(server_env, cookie, sid, query, **kwargs)",
            "",
            "",
            "class AuthnMethodChooser(object):",
            "    def __init__(self, methods=None):",
            "        self.methods = methods",
            "",
            "    def __call__(self, **kwargs):",
            "        if not self.methods:",
            "            raise SAMLError(\"No authentication methods defined\")",
            "        elif len(self.methods) == 1:",
            "            return self.methods[0]",
            "        else:",
            "            pass  # TODO",
            "",
            "try:",
            "    import ldap",
            "",
            "    class LDAPAuthn(UsernamePasswordMako):",
            "        def __init__(self, srv, ldapsrv, return_to,",
            "                     dn_pattern, mako_template, template_lookup):",
            "            \"\"\"",
            "            :param srv: The server instance",
            "            :param ldapsrv: Which LDAP server to us",
            "            :param return_to: Where to send the user after authentication",
            "            :return:",
            "            \"\"\"",
            "            UsernamePasswordMako.__init__(self, srv, mako_template, template_lookup,",
            "                                          None, return_to)",
            "",
            "            self.ldap = ldap.initialize(ldapsrv)",
            "            self.ldap.protocol_version = 3",
            "            self.ldap.set_option(ldap.OPT_REFERRALS, 0)",
            "            self.dn_pattern = dn_pattern",
            "",
            "        def _verify(self, pwd, user):",
            "            \"\"\"",
            "            Verifies the username and password agains a LDAP server",
            "            :param pwd: The password",
            "            :param user: The username",
            "            :return: AssertionError if the LDAP verification failed.",
            "            \"\"\"",
            "            _dn = self.dn_pattern % user",
            "            try:",
            "                self.ldap.simple_bind_s(_dn, pwd)",
            "            except Exception:",
            "                raise AssertionError()",
            "except ImportError:",
            "    class LDAPAuthn(UserAuthnMethod):",
            "        pass"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "123": [
                "UsernamePasswordMako",
                "__init__"
            ]
        },
        "addLocation": []
    },
    "src/saml2/server.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 83,
                "afterPatchRowNumber": 83,
                "PatchRowcode": "         self.init_config(stype)"
            },
            "1": {
                "beforePatchRowNumber": 84,
                "afterPatchRowNumber": 84,
                "PatchRowcode": "         self.cache = cache"
            },
            "2": {
                "beforePatchRowNumber": 85,
                "afterPatchRowNumber": 85,
                "PatchRowcode": "         self.ticket = {}"
            },
            "3": {
                "beforePatchRowNumber": 86,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        #"
            },
            "4": {
                "beforePatchRowNumber": 87,
                "afterPatchRowNumber": 86,
                "PatchRowcode": "         self.session_db = self.choose_session_storage()"
            },
            "5": {
                "beforePatchRowNumber": 88,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # Needed for"
            },
            "6": {
                "beforePatchRowNumber": 89,
                "afterPatchRowNumber": 87,
                "PatchRowcode": "         self.symkey = symkey"
            },
            "7": {
                "beforePatchRowNumber": 90,
                "afterPatchRowNumber": 88,
                "PatchRowcode": "         self.seed = rndstr()"
            },
            "8": {
                "beforePatchRowNumber": 91,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        self.iv = os.urandom(16)"
            },
            "9": {
                "beforePatchRowNumber": 92,
                "afterPatchRowNumber": 89,
                "PatchRowcode": "         self.lock = threading.Lock()"
            },
            "10": {
                "beforePatchRowNumber": 93,
                "afterPatchRowNumber": 90,
                "PatchRowcode": " "
            },
            "11": {
                "beforePatchRowNumber": 94,
                "afterPatchRowNumber": 91,
                "PatchRowcode": "     def getvalid_certificate_str(self):"
            }
        },
        "frontPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf-8 -*-",
            "#",
            "",
            "\"\"\"Contains classes and functions that a SAML2.0 Identity provider (IdP)",
            "or attribute authority (AA) may use to conclude its tasks.",
            "\"\"\"",
            "import logging",
            "import os",
            "",
            "import importlib",
            "import dbm",
            "import shelve",
            "import six",
            "import threading",
            "",
            "from saml2 import saml",
            "from saml2 import element_to_extension_element",
            "from saml2 import class_name",
            "from saml2 import BINDING_HTTP_REDIRECT",
            "from saml2.argtree import add_path, is_set",
            "",
            "from saml2.entity import Entity",
            "from saml2.eptid import Eptid",
            "from saml2.eptid import EptidShelve",
            "from saml2.samlp import NameIDMappingResponse",
            "from saml2.sdb import SessionStorage",
            "from saml2.schema import soapenv",
            "",
            "from saml2.request import AuthnRequest",
            "from saml2.request import AssertionIDRequest",
            "from saml2.request import AttributeQuery",
            "from saml2.request import NameIDMappingRequest",
            "from saml2.request import AuthzDecisionQuery",
            "from saml2.request import AuthnQuery",
            "",
            "from saml2.s_utils import MissingValue",
            "from saml2.s_utils import rndstr",
            "from saml2.s_utils import Unknown",
            "",
            "from saml2.sigver import pre_signature_part",
            "from saml2.sigver import signed_instance_factory",
            "from saml2.sigver import CertificateError",
            "",
            "from saml2.assertion import Assertion",
            "from saml2.assertion import Policy",
            "from saml2.assertion import restriction_from_attribute_spec",
            "from saml2.assertion import filter_attribute_value_assertions",
            "",
            "from saml2.ident import IdentDB, decode",
            "from saml2.profile import ecp",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "AUTHN_DICT_MAP = {",
            "    \"decl\": \"authn_decl\",",
            "    \"authn_auth\": \"authn_auth\",",
            "    \"class_ref\": \"authn_class\",",
            "    \"authn_instant\": \"authn_instant\",",
            "    \"subject_locality\": \"subject_locality\"",
            "}",
            "",
            "",
            "def _shelve_compat(name, *args, **kwargs):",
            "    try:",
            "        return shelve.open(name, *args, **kwargs)",
            "    except dbm.error[0]:",
            "        # Python 3 whichdb needs to try .db to determine type",
            "        if name.endswith('.db'):",
            "            name = name.rsplit('.db', 1)[0]",
            "            return shelve.open(name, *args, **kwargs)",
            "        else:",
            "            raise",
            "",
            "",
            "class Server(Entity):",
            "    \"\"\" A class that does things that IdPs or AAs do \"\"\"",
            "",
            "    def __init__(self, config_file=\"\", config=None, cache=None, stype=\"idp\",",
            "                 symkey=\"\", msg_cb=None):",
            "        Entity.__init__(self, stype, config, config_file, msg_cb=msg_cb)",
            "        self.eptid = None",
            "        self.init_config(stype)",
            "        self.cache = cache",
            "        self.ticket = {}",
            "        #",
            "        self.session_db = self.choose_session_storage()",
            "        # Needed for",
            "        self.symkey = symkey",
            "        self.seed = rndstr()",
            "        self.iv = os.urandom(16)",
            "        self.lock = threading.Lock()",
            "",
            "    def getvalid_certificate_str(self):",
            "        if self.sec.cert_handler is not None:",
            "            return self.sec.cert_handler._last_validated_cert",
            "        return None",
            "",
            "    def support_AssertionIDRequest(self):",
            "        return True",
            "",
            "    def support_AuthnQuery(self):",
            "        return True",
            "",
            "    def choose_session_storage(self):",
            "        _spec = self.config.getattr(\"session_storage\", \"idp\")",
            "        if not _spec:",
            "            return SessionStorage()",
            "        elif isinstance(_spec, six.string_types):",
            "            if _spec.lower() == \"memory\":",
            "                return SessionStorage()",
            "        else:  # Should be tuple",
            "            typ, data = _spec",
            "            if typ.lower() == \"mongodb\":",
            "                from saml2.mongo_store import SessionStorageMDB",
            "                return SessionStorageMDB(database=data, collection=\"session\")",
            "",
            "        raise NotImplementedError(\"No such storage type implemented\")",
            "",
            "    def init_config(self, stype=\"idp\"):",
            "        \"\"\" Remaining init of the server configuration",
            "",
            "        :param stype: The type of Server (\"idp\"/\"aa\")",
            "        \"\"\"",
            "        if stype == \"aa\":",
            "            return",
            "",
            "        # subject information is stored in a database",
            "        # default database is in memory which is OK in some setups",
            "        dbspec = self.config.getattr(\"subject_data\", \"idp\")",
            "        idb = None",
            "        typ = \"\"",
            "        if not dbspec:",
            "            idb = {}",
            "        elif isinstance(dbspec, six.string_types):",
            "            idb = _shelve_compat(dbspec, writeback=True, protocol=2)",
            "        else:  # database spec is a a 2-tuple (type, address)",
            "            # print(>> sys.stderr, \"DBSPEC: %s\" % (dbspec,))",
            "            (typ, addr) = dbspec",
            "            if typ == \"shelve\":",
            "                idb = _shelve_compat(addr, writeback=True, protocol=2)",
            "            elif typ == \"memcached\":",
            "                import memcache",
            "                idb = memcache.Client(addr)",
            "            elif typ == \"dict\":  # in-memory dictionary",
            "                idb = {}",
            "            elif typ == \"mongodb\":",
            "                from saml2.mongo_store import IdentMDB",
            "                self.ident = IdentMDB(database=addr, collection=\"ident\")",
            "            elif typ == \"identdb\":",
            "                mod, clas = addr.rsplit('.', 1)",
            "                mod = importlib.import_module(mod)",
            "                self.ident = getattr(mod, clas)()",
            "",
            "        if typ == \"mongodb\" or typ == \"identdb\":",
            "            pass",
            "        elif idb is not None:",
            "            self.ident = IdentDB(idb)",
            "        elif dbspec:",
            "            raise Exception(\"Couldn't open identity database: %s\" %",
            "                            (dbspec,))",
            "",
            "        try:",
            "            _domain = self.config.getattr(\"domain\", \"idp\")",
            "            if _domain:",
            "                self.ident.domain = _domain",
            "",
            "            self.ident.name_qualifier = self.config.entityid",
            "",
            "            dbspec = self.config.getattr(\"edu_person_targeted_id\", \"idp\")",
            "            if not dbspec:",
            "                pass",
            "            else:",
            "                typ = dbspec[0]",
            "                addr = dbspec[1]",
            "                secret = dbspec[2]",
            "                if typ == \"shelve\":",
            "                    self.eptid = EptidShelve(secret, addr)",
            "                elif typ == \"mongodb\":",
            "                    from saml2.mongo_store import EptidMDB",
            "                    self.eptid = EptidMDB(secret, database=addr,",
            "                                          collection=\"eptid\")",
            "                else:",
            "                    self.eptid = Eptid(secret)",
            "        except Exception:",
            "            self.ident.close()",
            "            raise",
            "",
            "    def wants(self, sp_entity_id, index=None):",
            "        \"\"\" Returns what attributes the SP requires and which are optional",
            "        if any such demands are registered in the Metadata.",
            "",
            "        :param sp_entity_id: The entity id of the SP",
            "        :param index: which of the attribute consumer services its all about",
            "            if index == None then all attribute consumer services are clumped",
            "            together.",
            "        :return: 2-tuple, list of required and list of optional attributes",
            "        \"\"\"",
            "        return self.metadata.attribute_requirement(sp_entity_id, index)",
            "",
            "    def verify_assertion_consumer_service(self, request):",
            "        _acs = request.assertion_consumer_service_url",
            "        _aci = request.assertion_consumer_service_index",
            "        _binding = request.protocol_binding",
            "        _eid = request.issuer.text",
            "        if _acs:",
            "            # look up acs in for that binding in the metadata given the issuer",
            "            # Assuming the format is entity",
            "            for acs in self.metadata.assertion_consumer_service(_eid, _binding):",
            "                if _acs == acs.text:",
            "                    return True",
            "        elif _aci:",
            "            for acs in self.metadata.assertion_consumer_service(_eid, _binding):",
            "                if _aci == acs.index:",
            "                    return True",
            "",
            "        return False",
            "",
            "    # -------------------------------------------------------------------------",
            "    def parse_authn_request(self, enc_request, binding=BINDING_HTTP_REDIRECT):",
            "        \"\"\"Parse a Authentication Request",
            "",
            "        :param enc_request: The request in its transport format",
            "        :param binding: Which binding that was used to transport the message",
            "            to this entity.",
            "        :return: A request instance",
            "        \"\"\"",
            "",
            "        return self._parse_request(enc_request, AuthnRequest,",
            "                                   \"single_sign_on_service\", binding)",
            "",
            "    def parse_attribute_query(self, xml_string, binding):",
            "        \"\"\" Parse an attribute query",
            "",
            "        :param xml_string: The Attribute Query as an XML string",
            "        :param binding: Which binding that was used for the request",
            "        :return: A query instance",
            "        \"\"\"",
            "",
            "        return self._parse_request(xml_string, AttributeQuery,",
            "                                   \"attribute_service\", binding)",
            "",
            "    def parse_authz_decision_query(self, xml_string, binding):",
            "        \"\"\" Parse an authorization decision query",
            "",
            "        :param xml_string: The Authz decision Query as an XML string",
            "        :param binding: Which binding that was used when receiving this query",
            "        :return: Query instance",
            "        \"\"\"",
            "",
            "        return self._parse_request(xml_string, AuthzDecisionQuery,",
            "                                   \"authz_service\", binding)",
            "",
            "    def parse_assertion_id_request(self, xml_string, binding):",
            "        \"\"\" Parse an assertion id query",
            "",
            "        :param xml_string: The AssertionIDRequest as an XML string",
            "        :param binding: Which binding that was used when receiving this request",
            "        :return: Query instance",
            "        \"\"\"",
            "",
            "        return self._parse_request(xml_string, AssertionIDRequest,",
            "                                   \"assertion_id_request_service\", binding)",
            "",
            "    def parse_authn_query(self, xml_string, binding):",
            "        \"\"\" Parse an authn query",
            "",
            "        :param xml_string: The AuthnQuery as an XML string",
            "        :param binding: Which binding that was used when receiving this query",
            "        :return: Query instance",
            "        \"\"\"",
            "",
            "        return self._parse_request(xml_string, AuthnQuery,",
            "                                   \"authn_query_service\", binding)",
            "",
            "    def parse_name_id_mapping_request(self, xml_string, binding):",
            "        \"\"\" Parse a nameid mapping request",
            "",
            "        :param xml_string: The NameIDMappingRequest as an XML string",
            "        :param binding: Which binding that was used when receiving this request",
            "        :return: Query instance",
            "        \"\"\"",
            "",
            "        return self._parse_request(xml_string, NameIDMappingRequest,",
            "                                   \"name_id_mapping_service\", binding)",
            "",
            "    @staticmethod",
            "    def update_farg(in_response_to, consumer_url, farg=None):",
            "        if not farg:",
            "            farg = add_path(",
            "                {},",
            "                ['assertion', 'subject', 'subject_confirmation', 'method',",
            "                 saml.SCM_BEARER])",
            "            add_path(",
            "                farg['assertion']['subject']['subject_confirmation'],",
            "                ['subject_confirmation_data', 'in_response_to', in_response_to])",
            "            add_path(",
            "                farg['assertion']['subject']['subject_confirmation'],",
            "                ['subject_confirmation_data', 'recipient', consumer_url])",
            "        else:",
            "            if not is_set(farg,",
            "                          ['assertion', 'subject', 'subject_confirmation',",
            "                           'method']):",
            "                add_path(farg,",
            "                         ['assertion', 'subject', 'subject_confirmation',",
            "                          'method', saml.SCM_BEARER])",
            "            if not is_set(farg,",
            "                          ['assertion', 'subject', 'subject_confirmation',",
            "                           'subject_confirmation_data', 'in_response_to']):",
            "                add_path(farg,",
            "                         ['assertion', 'subject', 'subject_confirmation',",
            "                          'subject_confirmation_data', 'in_response_to',",
            "                          in_response_to])",
            "            if not is_set(farg, ['assertion', 'subject', 'subject_confirmation',",
            "                                 'subject_confirmation_data', 'recipient']):",
            "                add_path(farg,",
            "                         ['assertion', 'subject', 'subject_confirmation',",
            "                          'subject_confirmation_data', 'recipient',",
            "                          consumer_url])",
            "        return farg",
            "",
            "    def setup_assertion(self, authn, sp_entity_id, in_response_to, consumer_url,",
            "                        name_id, policy, _issuer, authn_statement, identity,",
            "                        best_effort, sign_response, farg=None,",
            "                        session_not_on_or_after=None, **kwargs):",
            "        \"\"\"",
            "        Construct and return the Assertion",
            "",
            "        :param authn: Authentication information",
            "        :param sp_entity_id:",
            "        :param in_response_to: The ID of the request this is an answer to",
            "        :param consumer_url: The recipient of the assertion",
            "        :param name_id: The NameID of the subject",
            "        :param policy: Assertion policies",
            "        :param _issuer: Issuer of the statement",
            "        :param authn_statement: An AuthnStatement instance",
            "        :param identity: Identity information about the Subject",
            "        :param best_effort: Even if not the SPs demands can be met send a",
            "            response.",
            "        :param sign_response: Sign the response, only applicable if",
            "            ErrorResponse",
            "        :param kwargs: Extra keyword arguments",
            "        :return: An Assertion instance",
            "        \"\"\"",
            "",
            "        ast = Assertion(identity)",
            "        ast.acs = self.config.getattr(\"attribute_converters\", \"idp\")",
            "        if policy is None:",
            "            policy = Policy()",
            "        try:",
            "            ast.apply_policy(sp_entity_id, policy, self.metadata)",
            "        except MissingValue as exc:",
            "            if not best_effort:",
            "                return self.create_error_response(in_response_to, consumer_url,",
            "                                                  exc, sign_response)",
            "",
            "        farg = self.update_farg(in_response_to, consumer_url, farg)",
            "",
            "        if authn:  # expected to be a dictionary",
            "            # Would like to use dict comprehension but ...",
            "            authn_args = dict(",
            "                [(AUTHN_DICT_MAP[k], v) for k, v in authn.items() if",
            "                 k in AUTHN_DICT_MAP])",
            "            authn_args.update(kwargs)",
            "",
            "            assertion = ast.construct(",
            "                sp_entity_id, self.config.attribute_converters, policy,",
            "                issuer=_issuer, farg=farg['assertion'], name_id=name_id,",
            "                session_not_on_or_after=session_not_on_or_after,",
            "                **authn_args)",
            "",
            "        elif authn_statement:  # Got a complete AuthnStatement",
            "            assertion = ast.construct(",
            "                sp_entity_id, self.config.attribute_converters, policy,",
            "                issuer=_issuer, authn_statem=authn_statement,",
            "                farg=farg['assertion'], name_id=name_id,",
            "                **kwargs)",
            "        else:",
            "            assertion = ast.construct(",
            "                sp_entity_id, self.config.attribute_converters, policy,",
            "                issuer=_issuer, farg=farg['assertion'], name_id=name_id,",
            "                session_not_on_or_after=session_not_on_or_after,",
            "                **kwargs)",
            "        return assertion",
            "",
            "    def _authn_response(self, in_response_to, consumer_url,",
            "                        sp_entity_id, identity=None, name_id=None,",
            "                        status=None, authn=None, issuer=None, policy=None,",
            "                        sign_assertion=False, sign_response=False,",
            "                        best_effort=False, encrypt_assertion=False,",
            "                        encrypt_cert_advice=None, encrypt_cert_assertion=None,",
            "                        authn_statement=None,",
            "                        encrypt_assertion_self_contained=False,",
            "                        encrypted_advice_attributes=False,",
            "                        pefim=False, sign_alg=None, digest_alg=None,",
            "                        farg=None, session_not_on_or_after=None):",
            "        \"\"\" Create a response. A layer of indirection.",
            "",
            "        :param in_response_to: The session identifier of the request",
            "        :param consumer_url: The URL which should receive the response",
            "        :param sp_entity_id: The entity identifier of the SP",
            "        :param identity: A dictionary with attributes and values that are",
            "            expected to be the bases for the assertion in the response.",
            "        :param name_id: The identifier of the subject",
            "        :param status: The status of the response",
            "        :param authn: A dictionary containing information about the",
            "            authn context.",
            "        :param issuer: The issuer of the response",
            "        :param policy:",
            "        :param sign_assertion: Whether the assertion should be signed or not",
            "        :param sign_response: Whether the response should be signed or not",
            "        :param best_effort: Even if not the SPs demands can be met send a",
            "            response.",
            "        :param encrypt_assertion: True if assertions should be encrypted.",
            "        :param encrypt_assertion_self_contained: True if all encrypted",
            "        assertions should have alla namespaces",
            "        selfcontained.",
            "        :param encrypted_advice_attributes: True if assertions in the advice",
            "        element should be encrypted.",
            "        :param encrypt_cert_advice: Certificate to be used for encryption of",
            "        assertions in the advice element.",
            "        :param encrypt_cert_assertion: Certificate to be used for encryption",
            "        of assertions.",
            "        :param authn_statement: Authentication statement.",
            "        :param sign_assertion: True if assertions should be signed.",
            "        :param pefim: True if a response according to the PEFIM profile",
            "        should be created.",
            "        :param farg: Argument to pass on to the assertion constructor",
            "        :return: A response instance",
            "        \"\"\"",
            "",
            "        if farg is None:",
            "            assertion_args = {}",
            "",
            "        args = {}",
            "        # if identity:",
            "        _issuer = self._issuer(issuer)",
            "",
            "        # if encrypt_assertion and show_nameid:",
            "        #    tmp_name_id = name_id",
            "        #    name_id = None",
            "        #    name_id = None",
            "        #    tmp_authn = authn",
            "        #    authn = None",
            "        #    tmp_authn_statement = authn_statement",
            "        #    authn_statement = None",
            "",
            "        if pefim:",
            "            encrypted_advice_attributes = True",
            "            encrypt_assertion_self_contained = True",
            "            assertion_attributes = self.setup_assertion(",
            "                None, sp_entity_id, None, None, None, policy, None, None,",
            "                identity, best_effort, sign_response, farg=farg)",
            "            assertion = self.setup_assertion(",
            "                authn, sp_entity_id, in_response_to, consumer_url, name_id,",
            "                policy, _issuer, authn_statement, [], True, sign_response,",
            "                farg=farg, session_not_on_or_after=session_not_on_or_after)",
            "            assertion.advice = saml.Advice()",
            "",
            "            # assertion.advice.assertion_id_ref.append(saml.AssertionIDRef())",
            "            # assertion.advice.assertion_uri_ref.append(saml.AssertionURIRef())",
            "            assertion.advice.assertion.append(assertion_attributes)",
            "        else:",
            "            assertion = self.setup_assertion(",
            "                authn, sp_entity_id, in_response_to, consumer_url, name_id,",
            "                policy, _issuer, authn_statement, identity, True,",
            "                sign_response, farg=farg,",
            "                session_not_on_or_after=session_not_on_or_after)",
            "",
            "        to_sign = []",
            "        if not encrypt_assertion:",
            "            if sign_assertion:",
            "                assertion.signature = pre_signature_part(assertion.id,",
            "                                                         self.sec.my_cert, 2,",
            "                                                         sign_alg=sign_alg,",
            "                                                         digest_alg=digest_alg)",
            "                to_sign.append((class_name(assertion), assertion.id))",
            "",
            "        args[\"assertion\"] = assertion",
            "",
            "        if (self.support_AssertionIDRequest() or self.support_AuthnQuery()):",
            "            self.session_db.store_assertion(assertion, to_sign)",
            "",
            "        return self._response(",
            "            in_response_to, consumer_url, status, issuer, sign_response,",
            "            to_sign, sp_entity_id=sp_entity_id,",
            "            encrypt_assertion=encrypt_assertion,",
            "            encrypt_cert_advice=encrypt_cert_advice,",
            "            encrypt_cert_assertion=encrypt_cert_assertion,",
            "            encrypt_assertion_self_contained=encrypt_assertion_self_contained,",
            "            encrypted_advice_attributes=encrypted_advice_attributes,",
            "            sign_assertion=sign_assertion,",
            "            pefim=pefim, sign_alg=sign_alg, digest_alg=digest_alg, **args)",
            "",
            "    # ------------------------------------------------------------------------",
            "",
            "    # noinspection PyUnusedLocal",
            "    def create_attribute_response(self, identity, in_response_to, destination,",
            "                                  sp_entity_id, userid=\"\", name_id=None,",
            "                                  status=None, issuer=None,",
            "                                  sign_assertion=False, sign_response=False,",
            "                                  attributes=None, sign_alg=None,",
            "                                  digest_alg=None, farg=None, **kwargs):",
            "        \"\"\" Create an attribute assertion response.",
            "",
            "        :param identity: A dictionary with attributes and values that are",
            "            expected to be the bases for the assertion in the response.",
            "        :param in_response_to: The session identifier of the request",
            "        :param destination: The URL which should receive the response",
            "        :param sp_entity_id: The entity identifier of the SP",
            "        :param userid: A identifier of the user",
            "        :param name_id: The identifier of the subject",
            "        :param status: The status of the response",
            "        :param issuer: The issuer of the response",
            "        :param sign_assertion: Whether the assertion should be signed or not",
            "        :param sign_response: Whether the whole response should be signed",
            "        :param attributes:",
            "        :param kwargs: To catch extra keyword arguments",
            "        :return: A response instance",
            "        \"\"\"",
            "",
            "        policy = self.config.getattr(\"policy\", \"aa\")",
            "",
            "        if not name_id and userid:",
            "            try:",
            "                name_id = self.ident.construct_nameid(userid, policy,",
            "                                                      sp_entity_id)",
            "                logger.warning(\"Unspecified NameID format\")",
            "            except Exception:",
            "                pass",
            "",
            "        to_sign = []",
            "",
            "        if identity:",
            "            farg = self.update_farg(in_response_to, sp_entity_id, farg=farg)",
            "",
            "            _issuer = self._issuer(issuer)",
            "            ast = Assertion(identity)",
            "            if policy:",
            "                ast.apply_policy(sp_entity_id, policy, self.metadata)",
            "            else:",
            "                policy = Policy()",
            "",
            "            if attributes:",
            "                restr = restriction_from_attribute_spec(attributes)",
            "                ast = filter_attribute_value_assertions(ast)",
            "",
            "            assertion = ast.construct(",
            "                sp_entity_id, self.config.attribute_converters, policy,",
            "                issuer=_issuer, name_id=name_id,",
            "                farg=farg['assertion'])",
            "",
            "            if sign_assertion:",
            "                assertion.signature = pre_signature_part(assertion.id,",
            "                                                         self.sec.my_cert, 1,",
            "                                                         sign_alg=sign_alg,",
            "                                                         digest_alg=digest_alg)",
            "                # Just the assertion or the response and the assertion ?",
            "                to_sign = [(class_name(assertion), assertion.id)]",
            "                kwargs['sign_assertion'] = True",
            "",
            "            kwargs[\"assertion\"] = assertion",
            "",
            "        if sp_entity_id:",
            "            kwargs['sp_entity_id'] = sp_entity_id",
            "",
            "        return self._response(in_response_to, destination, status, issuer,",
            "                              sign_response, to_sign, sign_alg=sign_alg,",
            "                              digest_alg=digest_alg, **kwargs)",
            "",
            "    # ------------------------------------------------------------------------",
            "",
            "    def gather_authn_response_args(self, sp_entity_id, name_id_policy, userid,",
            "                                   **kwargs):",
            "        param_default = {",
            "            'sign_assertion': False,",
            "            'sign_response': False,",
            "            'encrypt_assertion': False,",
            "            'encrypt_assertion_self_contained': True,",
            "            'encrypted_advice_attributes': False,",
            "            'encrypt_cert_advice': None,",
            "            'encrypt_cert_assertion': None",
            "        }",
            "",
            "        args = {}",
            "",
            "        try:",
            "            args[\"policy\"] = kwargs[\"release_policy\"]",
            "        except KeyError:",
            "            args[\"policy\"] = self.config.getattr(\"policy\", \"idp\")",
            "",
            "        try:",
            "            args['best_effort'] = kwargs[\"best_effort\"]",
            "        except KeyError:",
            "            args['best_effort'] = False",
            "",
            "        for param in ['sign_assertion', 'sign_response', 'encrypt_assertion',",
            "                      'encrypt_assertion_self_contained',",
            "                      'encrypted_advice_attributes', 'encrypt_cert_advice',",
            "                      'encrypt_cert_assertion']:",
            "            try:",
            "                _val = kwargs[param]",
            "            except KeyError:",
            "                _val = None",
            "",
            "            if _val is None:",
            "                _val = self.config.getattr(param, \"idp\")",
            "",
            "            if _val is None:",
            "                args[param] = param_default[param]",
            "            else:",
            "                args[param] = _val",
            "",
            "        for arg, attr, eca, pefim in [",
            "            ('encrypted_advice_attributes', 'verify_encrypt_cert_advice',",
            "             'encrypt_cert_advice', kwargs[\"pefim\"]),",
            "            ('encrypt_assertion', 'verify_encrypt_cert_assertion',",
            "             'encrypt_cert_assertion', False)]:",
            "",
            "            if args[arg] or pefim:",
            "                _enc_cert = self.config.getattr(attr, \"idp\")",
            "",
            "                if _enc_cert is not None:",
            "                    if kwargs[eca] is None:",
            "                        raise CertificateError(",
            "                            \"No SPCertEncType certificate for encryption \"",
            "                            \"contained in authentication \"",
            "                            \"request.\")",
            "                    if not _enc_cert(kwargs[eca]):",
            "                        raise CertificateError(",
            "                            \"Invalid certificate for encryption!\")",
            "",
            "        if 'name_id' not in kwargs or not kwargs['name_id']:",
            "            nid_formats = []",
            "            for _sp in self.metadata[sp_entity_id][\"spsso_descriptor\"]:",
            "                if \"name_id_format\" in _sp:",
            "                    nid_formats.extend([n[\"text\"] for n in",
            "                                        _sp[\"name_id_format\"]])",
            "            try:",
            "                snq = name_id_policy.sp_name_qualifier",
            "            except AttributeError:",
            "                snq = sp_entity_id",
            "",
            "            if not snq:",
            "                snq = sp_entity_id",
            "",
            "            kwa = {\"sp_name_qualifier\": snq}",
            "",
            "            try:",
            "                kwa[\"format\"] = name_id_policy.format",
            "            except AttributeError:",
            "                pass",
            "",
            "            _nids = self.ident.find_nameid(userid, **kwa)",
            "            # either none or one",
            "            if _nids:",
            "                args['name_id'] = _nids[0]",
            "            else:",
            "                args['name_id'] = self.ident.construct_nameid(",
            "                    userid, args['policy'], sp_entity_id, name_id_policy)",
            "                logger.debug(\"construct_nameid: %s => %s\", userid,",
            "                             args['name_id'])",
            "        else:",
            "            args['name_id'] = kwargs['name_id']",
            "",
            "        for param in ['status', 'farg']:",
            "            try:",
            "                args[param] = kwargs[param]",
            "            except KeyError:",
            "                pass",
            "",
            "        return args",
            "",
            "    def create_authn_response(self, identity, in_response_to, destination,",
            "                              sp_entity_id, name_id_policy=None, userid=None,",
            "                              name_id=None, authn=None, issuer=None,",
            "                              sign_response=None, sign_assertion=None,",
            "                              encrypt_cert_advice=None,",
            "                              encrypt_cert_assertion=None,",
            "                              encrypt_assertion=None,",
            "                              encrypt_assertion_self_contained=True,",
            "                              encrypted_advice_attributes=False, pefim=False,",
            "                              sign_alg=None, digest_alg=None,",
            "                              session_not_on_or_after=None,",
            "                              **kwargs):",
            "        \"\"\" Constructs an AuthenticationResponse",
            "",
            "        :param identity: Information about an user",
            "        :param in_response_to: The identifier of the authentication request",
            "            this response is an answer to.",
            "        :param destination: Where the response should be sent",
            "        :param sp_entity_id: The entity identifier of the Service Provider",
            "        :param name_id_policy: How the NameID should be constructed",
            "        :param userid: The subject identifier",
            "        :param name_id: The identifier of the subject. A saml.NameID instance.",
            "        :param authn: Dictionary with information about the authentication",
            "            context",
            "        :param issuer: Issuer of the response",
            "        :param sign_assertion: Whether the assertion should be signed or not.",
            "        :param sign_response: Whether the response should be signed or not.",
            "        :param encrypt_assertion: True if assertions should be encrypted.",
            "        :param encrypt_assertion_self_contained: True if all encrypted",
            "        assertions should have alla namespaces",
            "        selfcontained.",
            "        :param encrypted_advice_attributes: True if assertions in the advice",
            "        element should be encrypted.",
            "        :param encrypt_cert_advice: Certificate to be used for encryption of",
            "        assertions in the advice element.",
            "        :param encrypt_cert_assertion: Certificate to be used for encryption",
            "        of assertions.",
            "        :param sign_assertion: True if assertions should be signed.",
            "        :param pefim: True if a response according to the PEFIM profile",
            "        should be created.",
            "        :return: A response instance",
            "        \"\"\"",
            "",
            "        try:",
            "            args = self.gather_authn_response_args(",
            "                sp_entity_id, name_id_policy=name_id_policy, userid=userid,",
            "                name_id=name_id, sign_response=sign_response,",
            "                sign_assertion=sign_assertion,",
            "                encrypt_cert_advice=encrypt_cert_advice,",
            "                encrypt_cert_assertion=encrypt_cert_assertion,",
            "                encrypt_assertion=encrypt_assertion,",
            "                encrypt_assertion_self_contained",
            "                =encrypt_assertion_self_contained,",
            "                encrypted_advice_attributes=encrypted_advice_attributes,",
            "                pefim=pefim, **kwargs)",
            "        except IOError as exc:",
            "            response = self.create_error_response(in_response_to,",
            "                                                  destination,",
            "                                                  sp_entity_id,",
            "                                                  exc, name_id)",
            "            return (\"%s\" % response).split(\"\\n\")",
            "",
            "        try:",
            "            _authn = authn",
            "            if (sign_assertion or sign_response) and \\",
            "                    self.sec.cert_handler.generate_cert():",
            "                with self.lock:",
            "                    self.sec.cert_handler.update_cert(True)",
            "                    return self._authn_response(",
            "                        in_response_to, destination, sp_entity_id, identity,",
            "                        authn=_authn, issuer=issuer, pefim=pefim,",
            "                        sign_alg=sign_alg, digest_alg=digest_alg,",
            "                        session_not_on_or_after=session_not_on_or_after, **args)",
            "            return self._authn_response(",
            "                in_response_to, destination, sp_entity_id, identity,",
            "                authn=_authn, issuer=issuer, pefim=pefim, sign_alg=sign_alg,",
            "                digest_alg=digest_alg,",
            "                session_not_on_or_after=session_not_on_or_after, **args)",
            "",
            "        except MissingValue as exc:",
            "            return self.create_error_response(in_response_to, destination,",
            "                                              sp_entity_id, exc, name_id)",
            "",
            "    def create_authn_request_response(self, identity, in_response_to,",
            "                                      destination, sp_entity_id,",
            "                                      name_id_policy=None, userid=None,",
            "                                      name_id=None, authn=None, authn_decl=None,",
            "                                      issuer=None, sign_response=False,",
            "                                      sign_assertion=False,",
            "                                      session_not_on_or_after=None, **kwargs):",
            "",
            "        return self.create_authn_response(identity, in_response_to, destination,",
            "                                          sp_entity_id, name_id_policy, userid,",
            "                                          name_id, authn, issuer,",
            "                                          sign_response, sign_assertion,",
            "                                          authn_decl=authn_decl,",
            "                                          session_not_on_or_after=session_not_on_or_after)",
            "",
            "    # noinspection PyUnusedLocal",
            "    def create_assertion_id_request_response(self, assertion_id, sign=False,",
            "                                             sign_alg=None,",
            "                                             digest_alg=None, **kwargs):",
            "        \"\"\"",
            "",
            "        :param assertion_id:",
            "        :param sign:",
            "        :return:",
            "        \"\"\"",
            "",
            "        try:",
            "            (assertion, to_sign) = self.session_db.get_assertion(assertion_id)",
            "        except KeyError:",
            "            raise Unknown",
            "",
            "        if to_sign:",
            "            if assertion.signature is None:",
            "                assertion.signature = pre_signature_part(assertion.id,",
            "                                                         self.sec.my_cert, 1,",
            "                                                         sign_alg=sign_alg,",
            "                                                         digest_alg=digest_alg)",
            "",
            "            return signed_instance_factory(assertion, self.sec, to_sign)",
            "        else:",
            "            return assertion",
            "",
            "    # noinspection PyUnusedLocal",
            "    def create_name_id_mapping_response(self, name_id=None, encrypted_id=None,",
            "                                        in_response_to=None,",
            "                                        issuer=None, sign_response=False,",
            "                                        status=None, sign_alg=None,",
            "                                        digest_alg=None, **kwargs):",
            "        \"\"\"",
            "        protocol for mapping a principal's name identifier into a",
            "        different name identifier for the same principal.",
            "        Done over soap.",
            "",
            "        :param name_id:",
            "        :param encrypted_id:",
            "        :param in_response_to:",
            "        :param issuer:",
            "        :param sign_response:",
            "        :param status:",
            "        :return:",
            "        \"\"\"",
            "        # Done over SOAP",
            "",
            "        ms_args = self.message_args()",
            "",
            "        _resp = NameIDMappingResponse(name_id, encrypted_id,",
            "                                      in_response_to=in_response_to, **ms_args)",
            "",
            "        if sign_response:",
            "            return self.sign(_resp, sign_alg=sign_alg, digest_alg=digest_alg)",
            "        else:",
            "            logger.info(\"Message: %s\", _resp)",
            "            return _resp",
            "",
            "    def create_authn_query_response(self, subject, session_index=None,",
            "                                    requested_context=None, in_response_to=None,",
            "                                    issuer=None, sign_response=False,",
            "                                    status=None, sign_alg=None, digest_alg=None,",
            "                                    **kwargs):",
            "        \"\"\"",
            "        A successful <Response> will contain one or more assertions containing",
            "        authentication statements.",
            "",
            "        :return:",
            "        \"\"\"",
            "",
            "        margs = self.message_args()",
            "        asserts = []",
            "        for statement in self.session_db.get_authn_statements(",
            "                subject.name_id, session_index, requested_context):",
            "            asserts.append(saml.Assertion(authn_statement=statement,",
            "                                          subject=subject, **margs))",
            "",
            "        if asserts:",
            "            args = {\"assertion\": asserts}",
            "        else:",
            "            args = {}",
            "",
            "        return self._response(in_response_to, \"\", status, issuer,",
            "                              sign_response, to_sign=[], sign_alg=sign_alg,",
            "                              digest_alg=digest_alg, **args)",
            "",
            "    # ---------",
            "",
            "    def parse_ecp_authn_request(self):",
            "        pass",
            "",
            "    def create_ecp_authn_request_response(self, acs_url, identity,",
            "                                          in_response_to, destination,",
            "                                          sp_entity_id, name_id_policy=None,",
            "                                          userid=None, name_id=None, authn=None,",
            "                                          issuer=None, sign_response=False,",
            "                                          sign_assertion=False, **kwargs):",
            "",
            "        # ----------------------------------------",
            "        # <ecp:Response",
            "        # ----------------------------------------",
            "",
            "        ecp_response = ecp.Response(assertion_consumer_service_url=acs_url)",
            "        header = soapenv.Header()",
            "        header.extension_elements = [element_to_extension_element(ecp_response)]",
            "",
            "        # ----------------------------------------",
            "        # <samlp:Response",
            "        # ----------------------------------------",
            "",
            "        response = self.create_authn_response(identity, in_response_to,",
            "                                              destination, sp_entity_id,",
            "                                              name_id_policy, userid, name_id,",
            "                                              authn, issuer,",
            "                                              sign_response, sign_assertion)",
            "        body = soapenv.Body()",
            "        body.extension_elements = [element_to_extension_element(response)]",
            "",
            "        soap_envelope = soapenv.Envelope(header=header, body=body)",
            "",
            "        return \"%s\" % soap_envelope",
            "",
            "    def close(self):",
            "        self.ident.close()",
            "",
            "    def clean_out_user(self, name_id):",
            "        \"\"\"",
            "        Remove all authentication statements that belongs to a user identified",
            "        by a NameID instance",
            "",
            "        :param name_id: NameID instance",
            "        :return: The local identifier for the user",
            "        \"\"\"",
            "",
            "        lid = self.ident.find_local_id(name_id)",
            "        logger.info(\"Clean out %s\", lid)",
            "",
            "        # remove the authentications",
            "        try:",
            "            for _nid in [decode(x) for x in self.ident.db[lid].split(\" \")]:",
            "                try:",
            "                    self.session_db.remove_authn_statements(_nid)",
            "                except KeyError:",
            "                    pass",
            "        except KeyError:",
            "            pass",
            "",
            "        return lid"
        ],
        "afterPatchFile": [
            "#!/usr/bin/env python",
            "# -*- coding: utf-8 -*-",
            "#",
            "",
            "\"\"\"Contains classes and functions that a SAML2.0 Identity provider (IdP)",
            "or attribute authority (AA) may use to conclude its tasks.",
            "\"\"\"",
            "import logging",
            "import os",
            "",
            "import importlib",
            "import dbm",
            "import shelve",
            "import six",
            "import threading",
            "",
            "from saml2 import saml",
            "from saml2 import element_to_extension_element",
            "from saml2 import class_name",
            "from saml2 import BINDING_HTTP_REDIRECT",
            "from saml2.argtree import add_path, is_set",
            "",
            "from saml2.entity import Entity",
            "from saml2.eptid import Eptid",
            "from saml2.eptid import EptidShelve",
            "from saml2.samlp import NameIDMappingResponse",
            "from saml2.sdb import SessionStorage",
            "from saml2.schema import soapenv",
            "",
            "from saml2.request import AuthnRequest",
            "from saml2.request import AssertionIDRequest",
            "from saml2.request import AttributeQuery",
            "from saml2.request import NameIDMappingRequest",
            "from saml2.request import AuthzDecisionQuery",
            "from saml2.request import AuthnQuery",
            "",
            "from saml2.s_utils import MissingValue",
            "from saml2.s_utils import rndstr",
            "from saml2.s_utils import Unknown",
            "",
            "from saml2.sigver import pre_signature_part",
            "from saml2.sigver import signed_instance_factory",
            "from saml2.sigver import CertificateError",
            "",
            "from saml2.assertion import Assertion",
            "from saml2.assertion import Policy",
            "from saml2.assertion import restriction_from_attribute_spec",
            "from saml2.assertion import filter_attribute_value_assertions",
            "",
            "from saml2.ident import IdentDB, decode",
            "from saml2.profile import ecp",
            "",
            "logger = logging.getLogger(__name__)",
            "",
            "AUTHN_DICT_MAP = {",
            "    \"decl\": \"authn_decl\",",
            "    \"authn_auth\": \"authn_auth\",",
            "    \"class_ref\": \"authn_class\",",
            "    \"authn_instant\": \"authn_instant\",",
            "    \"subject_locality\": \"subject_locality\"",
            "}",
            "",
            "",
            "def _shelve_compat(name, *args, **kwargs):",
            "    try:",
            "        return shelve.open(name, *args, **kwargs)",
            "    except dbm.error[0]:",
            "        # Python 3 whichdb needs to try .db to determine type",
            "        if name.endswith('.db'):",
            "            name = name.rsplit('.db', 1)[0]",
            "            return shelve.open(name, *args, **kwargs)",
            "        else:",
            "            raise",
            "",
            "",
            "class Server(Entity):",
            "    \"\"\" A class that does things that IdPs or AAs do \"\"\"",
            "",
            "    def __init__(self, config_file=\"\", config=None, cache=None, stype=\"idp\",",
            "                 symkey=\"\", msg_cb=None):",
            "        Entity.__init__(self, stype, config, config_file, msg_cb=msg_cb)",
            "        self.eptid = None",
            "        self.init_config(stype)",
            "        self.cache = cache",
            "        self.ticket = {}",
            "        self.session_db = self.choose_session_storage()",
            "        self.symkey = symkey",
            "        self.seed = rndstr()",
            "        self.lock = threading.Lock()",
            "",
            "    def getvalid_certificate_str(self):",
            "        if self.sec.cert_handler is not None:",
            "            return self.sec.cert_handler._last_validated_cert",
            "        return None",
            "",
            "    def support_AssertionIDRequest(self):",
            "        return True",
            "",
            "    def support_AuthnQuery(self):",
            "        return True",
            "",
            "    def choose_session_storage(self):",
            "        _spec = self.config.getattr(\"session_storage\", \"idp\")",
            "        if not _spec:",
            "            return SessionStorage()",
            "        elif isinstance(_spec, six.string_types):",
            "            if _spec.lower() == \"memory\":",
            "                return SessionStorage()",
            "        else:  # Should be tuple",
            "            typ, data = _spec",
            "            if typ.lower() == \"mongodb\":",
            "                from saml2.mongo_store import SessionStorageMDB",
            "                return SessionStorageMDB(database=data, collection=\"session\")",
            "",
            "        raise NotImplementedError(\"No such storage type implemented\")",
            "",
            "    def init_config(self, stype=\"idp\"):",
            "        \"\"\" Remaining init of the server configuration",
            "",
            "        :param stype: The type of Server (\"idp\"/\"aa\")",
            "        \"\"\"",
            "        if stype == \"aa\":",
            "            return",
            "",
            "        # subject information is stored in a database",
            "        # default database is in memory which is OK in some setups",
            "        dbspec = self.config.getattr(\"subject_data\", \"idp\")",
            "        idb = None",
            "        typ = \"\"",
            "        if not dbspec:",
            "            idb = {}",
            "        elif isinstance(dbspec, six.string_types):",
            "            idb = _shelve_compat(dbspec, writeback=True, protocol=2)",
            "        else:  # database spec is a a 2-tuple (type, address)",
            "            # print(>> sys.stderr, \"DBSPEC: %s\" % (dbspec,))",
            "            (typ, addr) = dbspec",
            "            if typ == \"shelve\":",
            "                idb = _shelve_compat(addr, writeback=True, protocol=2)",
            "            elif typ == \"memcached\":",
            "                import memcache",
            "                idb = memcache.Client(addr)",
            "            elif typ == \"dict\":  # in-memory dictionary",
            "                idb = {}",
            "            elif typ == \"mongodb\":",
            "                from saml2.mongo_store import IdentMDB",
            "                self.ident = IdentMDB(database=addr, collection=\"ident\")",
            "            elif typ == \"identdb\":",
            "                mod, clas = addr.rsplit('.', 1)",
            "                mod = importlib.import_module(mod)",
            "                self.ident = getattr(mod, clas)()",
            "",
            "        if typ == \"mongodb\" or typ == \"identdb\":",
            "            pass",
            "        elif idb is not None:",
            "            self.ident = IdentDB(idb)",
            "        elif dbspec:",
            "            raise Exception(\"Couldn't open identity database: %s\" %",
            "                            (dbspec,))",
            "",
            "        try:",
            "            _domain = self.config.getattr(\"domain\", \"idp\")",
            "            if _domain:",
            "                self.ident.domain = _domain",
            "",
            "            self.ident.name_qualifier = self.config.entityid",
            "",
            "            dbspec = self.config.getattr(\"edu_person_targeted_id\", \"idp\")",
            "            if not dbspec:",
            "                pass",
            "            else:",
            "                typ = dbspec[0]",
            "                addr = dbspec[1]",
            "                secret = dbspec[2]",
            "                if typ == \"shelve\":",
            "                    self.eptid = EptidShelve(secret, addr)",
            "                elif typ == \"mongodb\":",
            "                    from saml2.mongo_store import EptidMDB",
            "                    self.eptid = EptidMDB(secret, database=addr,",
            "                                          collection=\"eptid\")",
            "                else:",
            "                    self.eptid = Eptid(secret)",
            "        except Exception:",
            "            self.ident.close()",
            "            raise",
            "",
            "    def wants(self, sp_entity_id, index=None):",
            "        \"\"\" Returns what attributes the SP requires and which are optional",
            "        if any such demands are registered in the Metadata.",
            "",
            "        :param sp_entity_id: The entity id of the SP",
            "        :param index: which of the attribute consumer services its all about",
            "            if index == None then all attribute consumer services are clumped",
            "            together.",
            "        :return: 2-tuple, list of required and list of optional attributes",
            "        \"\"\"",
            "        return self.metadata.attribute_requirement(sp_entity_id, index)",
            "",
            "    def verify_assertion_consumer_service(self, request):",
            "        _acs = request.assertion_consumer_service_url",
            "        _aci = request.assertion_consumer_service_index",
            "        _binding = request.protocol_binding",
            "        _eid = request.issuer.text",
            "        if _acs:",
            "            # look up acs in for that binding in the metadata given the issuer",
            "            # Assuming the format is entity",
            "            for acs in self.metadata.assertion_consumer_service(_eid, _binding):",
            "                if _acs == acs.text:",
            "                    return True",
            "        elif _aci:",
            "            for acs in self.metadata.assertion_consumer_service(_eid, _binding):",
            "                if _aci == acs.index:",
            "                    return True",
            "",
            "        return False",
            "",
            "    # -------------------------------------------------------------------------",
            "    def parse_authn_request(self, enc_request, binding=BINDING_HTTP_REDIRECT):",
            "        \"\"\"Parse a Authentication Request",
            "",
            "        :param enc_request: The request in its transport format",
            "        :param binding: Which binding that was used to transport the message",
            "            to this entity.",
            "        :return: A request instance",
            "        \"\"\"",
            "",
            "        return self._parse_request(enc_request, AuthnRequest,",
            "                                   \"single_sign_on_service\", binding)",
            "",
            "    def parse_attribute_query(self, xml_string, binding):",
            "        \"\"\" Parse an attribute query",
            "",
            "        :param xml_string: The Attribute Query as an XML string",
            "        :param binding: Which binding that was used for the request",
            "        :return: A query instance",
            "        \"\"\"",
            "",
            "        return self._parse_request(xml_string, AttributeQuery,",
            "                                   \"attribute_service\", binding)",
            "",
            "    def parse_authz_decision_query(self, xml_string, binding):",
            "        \"\"\" Parse an authorization decision query",
            "",
            "        :param xml_string: The Authz decision Query as an XML string",
            "        :param binding: Which binding that was used when receiving this query",
            "        :return: Query instance",
            "        \"\"\"",
            "",
            "        return self._parse_request(xml_string, AuthzDecisionQuery,",
            "                                   \"authz_service\", binding)",
            "",
            "    def parse_assertion_id_request(self, xml_string, binding):",
            "        \"\"\" Parse an assertion id query",
            "",
            "        :param xml_string: The AssertionIDRequest as an XML string",
            "        :param binding: Which binding that was used when receiving this request",
            "        :return: Query instance",
            "        \"\"\"",
            "",
            "        return self._parse_request(xml_string, AssertionIDRequest,",
            "                                   \"assertion_id_request_service\", binding)",
            "",
            "    def parse_authn_query(self, xml_string, binding):",
            "        \"\"\" Parse an authn query",
            "",
            "        :param xml_string: The AuthnQuery as an XML string",
            "        :param binding: Which binding that was used when receiving this query",
            "        :return: Query instance",
            "        \"\"\"",
            "",
            "        return self._parse_request(xml_string, AuthnQuery,",
            "                                   \"authn_query_service\", binding)",
            "",
            "    def parse_name_id_mapping_request(self, xml_string, binding):",
            "        \"\"\" Parse a nameid mapping request",
            "",
            "        :param xml_string: The NameIDMappingRequest as an XML string",
            "        :param binding: Which binding that was used when receiving this request",
            "        :return: Query instance",
            "        \"\"\"",
            "",
            "        return self._parse_request(xml_string, NameIDMappingRequest,",
            "                                   \"name_id_mapping_service\", binding)",
            "",
            "    @staticmethod",
            "    def update_farg(in_response_to, consumer_url, farg=None):",
            "        if not farg:",
            "            farg = add_path(",
            "                {},",
            "                ['assertion', 'subject', 'subject_confirmation', 'method',",
            "                 saml.SCM_BEARER])",
            "            add_path(",
            "                farg['assertion']['subject']['subject_confirmation'],",
            "                ['subject_confirmation_data', 'in_response_to', in_response_to])",
            "            add_path(",
            "                farg['assertion']['subject']['subject_confirmation'],",
            "                ['subject_confirmation_data', 'recipient', consumer_url])",
            "        else:",
            "            if not is_set(farg,",
            "                          ['assertion', 'subject', 'subject_confirmation',",
            "                           'method']):",
            "                add_path(farg,",
            "                         ['assertion', 'subject', 'subject_confirmation',",
            "                          'method', saml.SCM_BEARER])",
            "            if not is_set(farg,",
            "                          ['assertion', 'subject', 'subject_confirmation',",
            "                           'subject_confirmation_data', 'in_response_to']):",
            "                add_path(farg,",
            "                         ['assertion', 'subject', 'subject_confirmation',",
            "                          'subject_confirmation_data', 'in_response_to',",
            "                          in_response_to])",
            "            if not is_set(farg, ['assertion', 'subject', 'subject_confirmation',",
            "                                 'subject_confirmation_data', 'recipient']):",
            "                add_path(farg,",
            "                         ['assertion', 'subject', 'subject_confirmation',",
            "                          'subject_confirmation_data', 'recipient',",
            "                          consumer_url])",
            "        return farg",
            "",
            "    def setup_assertion(self, authn, sp_entity_id, in_response_to, consumer_url,",
            "                        name_id, policy, _issuer, authn_statement, identity,",
            "                        best_effort, sign_response, farg=None,",
            "                        session_not_on_or_after=None, **kwargs):",
            "        \"\"\"",
            "        Construct and return the Assertion",
            "",
            "        :param authn: Authentication information",
            "        :param sp_entity_id:",
            "        :param in_response_to: The ID of the request this is an answer to",
            "        :param consumer_url: The recipient of the assertion",
            "        :param name_id: The NameID of the subject",
            "        :param policy: Assertion policies",
            "        :param _issuer: Issuer of the statement",
            "        :param authn_statement: An AuthnStatement instance",
            "        :param identity: Identity information about the Subject",
            "        :param best_effort: Even if not the SPs demands can be met send a",
            "            response.",
            "        :param sign_response: Sign the response, only applicable if",
            "            ErrorResponse",
            "        :param kwargs: Extra keyword arguments",
            "        :return: An Assertion instance",
            "        \"\"\"",
            "",
            "        ast = Assertion(identity)",
            "        ast.acs = self.config.getattr(\"attribute_converters\", \"idp\")",
            "        if policy is None:",
            "            policy = Policy()",
            "        try:",
            "            ast.apply_policy(sp_entity_id, policy, self.metadata)",
            "        except MissingValue as exc:",
            "            if not best_effort:",
            "                return self.create_error_response(in_response_to, consumer_url,",
            "                                                  exc, sign_response)",
            "",
            "        farg = self.update_farg(in_response_to, consumer_url, farg)",
            "",
            "        if authn:  # expected to be a dictionary",
            "            # Would like to use dict comprehension but ...",
            "            authn_args = dict(",
            "                [(AUTHN_DICT_MAP[k], v) for k, v in authn.items() if",
            "                 k in AUTHN_DICT_MAP])",
            "            authn_args.update(kwargs)",
            "",
            "            assertion = ast.construct(",
            "                sp_entity_id, self.config.attribute_converters, policy,",
            "                issuer=_issuer, farg=farg['assertion'], name_id=name_id,",
            "                session_not_on_or_after=session_not_on_or_after,",
            "                **authn_args)",
            "",
            "        elif authn_statement:  # Got a complete AuthnStatement",
            "            assertion = ast.construct(",
            "                sp_entity_id, self.config.attribute_converters, policy,",
            "                issuer=_issuer, authn_statem=authn_statement,",
            "                farg=farg['assertion'], name_id=name_id,",
            "                **kwargs)",
            "        else:",
            "            assertion = ast.construct(",
            "                sp_entity_id, self.config.attribute_converters, policy,",
            "                issuer=_issuer, farg=farg['assertion'], name_id=name_id,",
            "                session_not_on_or_after=session_not_on_or_after,",
            "                **kwargs)",
            "        return assertion",
            "",
            "    def _authn_response(self, in_response_to, consumer_url,",
            "                        sp_entity_id, identity=None, name_id=None,",
            "                        status=None, authn=None, issuer=None, policy=None,",
            "                        sign_assertion=False, sign_response=False,",
            "                        best_effort=False, encrypt_assertion=False,",
            "                        encrypt_cert_advice=None, encrypt_cert_assertion=None,",
            "                        authn_statement=None,",
            "                        encrypt_assertion_self_contained=False,",
            "                        encrypted_advice_attributes=False,",
            "                        pefim=False, sign_alg=None, digest_alg=None,",
            "                        farg=None, session_not_on_or_after=None):",
            "        \"\"\" Create a response. A layer of indirection.",
            "",
            "        :param in_response_to: The session identifier of the request",
            "        :param consumer_url: The URL which should receive the response",
            "        :param sp_entity_id: The entity identifier of the SP",
            "        :param identity: A dictionary with attributes and values that are",
            "            expected to be the bases for the assertion in the response.",
            "        :param name_id: The identifier of the subject",
            "        :param status: The status of the response",
            "        :param authn: A dictionary containing information about the",
            "            authn context.",
            "        :param issuer: The issuer of the response",
            "        :param policy:",
            "        :param sign_assertion: Whether the assertion should be signed or not",
            "        :param sign_response: Whether the response should be signed or not",
            "        :param best_effort: Even if not the SPs demands can be met send a",
            "            response.",
            "        :param encrypt_assertion: True if assertions should be encrypted.",
            "        :param encrypt_assertion_self_contained: True if all encrypted",
            "        assertions should have alla namespaces",
            "        selfcontained.",
            "        :param encrypted_advice_attributes: True if assertions in the advice",
            "        element should be encrypted.",
            "        :param encrypt_cert_advice: Certificate to be used for encryption of",
            "        assertions in the advice element.",
            "        :param encrypt_cert_assertion: Certificate to be used for encryption",
            "        of assertions.",
            "        :param authn_statement: Authentication statement.",
            "        :param sign_assertion: True if assertions should be signed.",
            "        :param pefim: True if a response according to the PEFIM profile",
            "        should be created.",
            "        :param farg: Argument to pass on to the assertion constructor",
            "        :return: A response instance",
            "        \"\"\"",
            "",
            "        if farg is None:",
            "            assertion_args = {}",
            "",
            "        args = {}",
            "        # if identity:",
            "        _issuer = self._issuer(issuer)",
            "",
            "        # if encrypt_assertion and show_nameid:",
            "        #    tmp_name_id = name_id",
            "        #    name_id = None",
            "        #    name_id = None",
            "        #    tmp_authn = authn",
            "        #    authn = None",
            "        #    tmp_authn_statement = authn_statement",
            "        #    authn_statement = None",
            "",
            "        if pefim:",
            "            encrypted_advice_attributes = True",
            "            encrypt_assertion_self_contained = True",
            "            assertion_attributes = self.setup_assertion(",
            "                None, sp_entity_id, None, None, None, policy, None, None,",
            "                identity, best_effort, sign_response, farg=farg)",
            "            assertion = self.setup_assertion(",
            "                authn, sp_entity_id, in_response_to, consumer_url, name_id,",
            "                policy, _issuer, authn_statement, [], True, sign_response,",
            "                farg=farg, session_not_on_or_after=session_not_on_or_after)",
            "            assertion.advice = saml.Advice()",
            "",
            "            # assertion.advice.assertion_id_ref.append(saml.AssertionIDRef())",
            "            # assertion.advice.assertion_uri_ref.append(saml.AssertionURIRef())",
            "            assertion.advice.assertion.append(assertion_attributes)",
            "        else:",
            "            assertion = self.setup_assertion(",
            "                authn, sp_entity_id, in_response_to, consumer_url, name_id,",
            "                policy, _issuer, authn_statement, identity, True,",
            "                sign_response, farg=farg,",
            "                session_not_on_or_after=session_not_on_or_after)",
            "",
            "        to_sign = []",
            "        if not encrypt_assertion:",
            "            if sign_assertion:",
            "                assertion.signature = pre_signature_part(assertion.id,",
            "                                                         self.sec.my_cert, 2,",
            "                                                         sign_alg=sign_alg,",
            "                                                         digest_alg=digest_alg)",
            "                to_sign.append((class_name(assertion), assertion.id))",
            "",
            "        args[\"assertion\"] = assertion",
            "",
            "        if (self.support_AssertionIDRequest() or self.support_AuthnQuery()):",
            "            self.session_db.store_assertion(assertion, to_sign)",
            "",
            "        return self._response(",
            "            in_response_to, consumer_url, status, issuer, sign_response,",
            "            to_sign, sp_entity_id=sp_entity_id,",
            "            encrypt_assertion=encrypt_assertion,",
            "            encrypt_cert_advice=encrypt_cert_advice,",
            "            encrypt_cert_assertion=encrypt_cert_assertion,",
            "            encrypt_assertion_self_contained=encrypt_assertion_self_contained,",
            "            encrypted_advice_attributes=encrypted_advice_attributes,",
            "            sign_assertion=sign_assertion,",
            "            pefim=pefim, sign_alg=sign_alg, digest_alg=digest_alg, **args)",
            "",
            "    # ------------------------------------------------------------------------",
            "",
            "    # noinspection PyUnusedLocal",
            "    def create_attribute_response(self, identity, in_response_to, destination,",
            "                                  sp_entity_id, userid=\"\", name_id=None,",
            "                                  status=None, issuer=None,",
            "                                  sign_assertion=False, sign_response=False,",
            "                                  attributes=None, sign_alg=None,",
            "                                  digest_alg=None, farg=None, **kwargs):",
            "        \"\"\" Create an attribute assertion response.",
            "",
            "        :param identity: A dictionary with attributes and values that are",
            "            expected to be the bases for the assertion in the response.",
            "        :param in_response_to: The session identifier of the request",
            "        :param destination: The URL which should receive the response",
            "        :param sp_entity_id: The entity identifier of the SP",
            "        :param userid: A identifier of the user",
            "        :param name_id: The identifier of the subject",
            "        :param status: The status of the response",
            "        :param issuer: The issuer of the response",
            "        :param sign_assertion: Whether the assertion should be signed or not",
            "        :param sign_response: Whether the whole response should be signed",
            "        :param attributes:",
            "        :param kwargs: To catch extra keyword arguments",
            "        :return: A response instance",
            "        \"\"\"",
            "",
            "        policy = self.config.getattr(\"policy\", \"aa\")",
            "",
            "        if not name_id and userid:",
            "            try:",
            "                name_id = self.ident.construct_nameid(userid, policy,",
            "                                                      sp_entity_id)",
            "                logger.warning(\"Unspecified NameID format\")",
            "            except Exception:",
            "                pass",
            "",
            "        to_sign = []",
            "",
            "        if identity:",
            "            farg = self.update_farg(in_response_to, sp_entity_id, farg=farg)",
            "",
            "            _issuer = self._issuer(issuer)",
            "            ast = Assertion(identity)",
            "            if policy:",
            "                ast.apply_policy(sp_entity_id, policy, self.metadata)",
            "            else:",
            "                policy = Policy()",
            "",
            "            if attributes:",
            "                restr = restriction_from_attribute_spec(attributes)",
            "                ast = filter_attribute_value_assertions(ast)",
            "",
            "            assertion = ast.construct(",
            "                sp_entity_id, self.config.attribute_converters, policy,",
            "                issuer=_issuer, name_id=name_id,",
            "                farg=farg['assertion'])",
            "",
            "            if sign_assertion:",
            "                assertion.signature = pre_signature_part(assertion.id,",
            "                                                         self.sec.my_cert, 1,",
            "                                                         sign_alg=sign_alg,",
            "                                                         digest_alg=digest_alg)",
            "                # Just the assertion or the response and the assertion ?",
            "                to_sign = [(class_name(assertion), assertion.id)]",
            "                kwargs['sign_assertion'] = True",
            "",
            "            kwargs[\"assertion\"] = assertion",
            "",
            "        if sp_entity_id:",
            "            kwargs['sp_entity_id'] = sp_entity_id",
            "",
            "        return self._response(in_response_to, destination, status, issuer,",
            "                              sign_response, to_sign, sign_alg=sign_alg,",
            "                              digest_alg=digest_alg, **kwargs)",
            "",
            "    # ------------------------------------------------------------------------",
            "",
            "    def gather_authn_response_args(self, sp_entity_id, name_id_policy, userid,",
            "                                   **kwargs):",
            "        param_default = {",
            "            'sign_assertion': False,",
            "            'sign_response': False,",
            "            'encrypt_assertion': False,",
            "            'encrypt_assertion_self_contained': True,",
            "            'encrypted_advice_attributes': False,",
            "            'encrypt_cert_advice': None,",
            "            'encrypt_cert_assertion': None",
            "        }",
            "",
            "        args = {}",
            "",
            "        try:",
            "            args[\"policy\"] = kwargs[\"release_policy\"]",
            "        except KeyError:",
            "            args[\"policy\"] = self.config.getattr(\"policy\", \"idp\")",
            "",
            "        try:",
            "            args['best_effort'] = kwargs[\"best_effort\"]",
            "        except KeyError:",
            "            args['best_effort'] = False",
            "",
            "        for param in ['sign_assertion', 'sign_response', 'encrypt_assertion',",
            "                      'encrypt_assertion_self_contained',",
            "                      'encrypted_advice_attributes', 'encrypt_cert_advice',",
            "                      'encrypt_cert_assertion']:",
            "            try:",
            "                _val = kwargs[param]",
            "            except KeyError:",
            "                _val = None",
            "",
            "            if _val is None:",
            "                _val = self.config.getattr(param, \"idp\")",
            "",
            "            if _val is None:",
            "                args[param] = param_default[param]",
            "            else:",
            "                args[param] = _val",
            "",
            "        for arg, attr, eca, pefim in [",
            "            ('encrypted_advice_attributes', 'verify_encrypt_cert_advice',",
            "             'encrypt_cert_advice', kwargs[\"pefim\"]),",
            "            ('encrypt_assertion', 'verify_encrypt_cert_assertion',",
            "             'encrypt_cert_assertion', False)]:",
            "",
            "            if args[arg] or pefim:",
            "                _enc_cert = self.config.getattr(attr, \"idp\")",
            "",
            "                if _enc_cert is not None:",
            "                    if kwargs[eca] is None:",
            "                        raise CertificateError(",
            "                            \"No SPCertEncType certificate for encryption \"",
            "                            \"contained in authentication \"",
            "                            \"request.\")",
            "                    if not _enc_cert(kwargs[eca]):",
            "                        raise CertificateError(",
            "                            \"Invalid certificate for encryption!\")",
            "",
            "        if 'name_id' not in kwargs or not kwargs['name_id']:",
            "            nid_formats = []",
            "            for _sp in self.metadata[sp_entity_id][\"spsso_descriptor\"]:",
            "                if \"name_id_format\" in _sp:",
            "                    nid_formats.extend([n[\"text\"] for n in",
            "                                        _sp[\"name_id_format\"]])",
            "            try:",
            "                snq = name_id_policy.sp_name_qualifier",
            "            except AttributeError:",
            "                snq = sp_entity_id",
            "",
            "            if not snq:",
            "                snq = sp_entity_id",
            "",
            "            kwa = {\"sp_name_qualifier\": snq}",
            "",
            "            try:",
            "                kwa[\"format\"] = name_id_policy.format",
            "            except AttributeError:",
            "                pass",
            "",
            "            _nids = self.ident.find_nameid(userid, **kwa)",
            "            # either none or one",
            "            if _nids:",
            "                args['name_id'] = _nids[0]",
            "            else:",
            "                args['name_id'] = self.ident.construct_nameid(",
            "                    userid, args['policy'], sp_entity_id, name_id_policy)",
            "                logger.debug(\"construct_nameid: %s => %s\", userid,",
            "                             args['name_id'])",
            "        else:",
            "            args['name_id'] = kwargs['name_id']",
            "",
            "        for param in ['status', 'farg']:",
            "            try:",
            "                args[param] = kwargs[param]",
            "            except KeyError:",
            "                pass",
            "",
            "        return args",
            "",
            "    def create_authn_response(self, identity, in_response_to, destination,",
            "                              sp_entity_id, name_id_policy=None, userid=None,",
            "                              name_id=None, authn=None, issuer=None,",
            "                              sign_response=None, sign_assertion=None,",
            "                              encrypt_cert_advice=None,",
            "                              encrypt_cert_assertion=None,",
            "                              encrypt_assertion=None,",
            "                              encrypt_assertion_self_contained=True,",
            "                              encrypted_advice_attributes=False, pefim=False,",
            "                              sign_alg=None, digest_alg=None,",
            "                              session_not_on_or_after=None,",
            "                              **kwargs):",
            "        \"\"\" Constructs an AuthenticationResponse",
            "",
            "        :param identity: Information about an user",
            "        :param in_response_to: The identifier of the authentication request",
            "            this response is an answer to.",
            "        :param destination: Where the response should be sent",
            "        :param sp_entity_id: The entity identifier of the Service Provider",
            "        :param name_id_policy: How the NameID should be constructed",
            "        :param userid: The subject identifier",
            "        :param name_id: The identifier of the subject. A saml.NameID instance.",
            "        :param authn: Dictionary with information about the authentication",
            "            context",
            "        :param issuer: Issuer of the response",
            "        :param sign_assertion: Whether the assertion should be signed or not.",
            "        :param sign_response: Whether the response should be signed or not.",
            "        :param encrypt_assertion: True if assertions should be encrypted.",
            "        :param encrypt_assertion_self_contained: True if all encrypted",
            "        assertions should have alla namespaces",
            "        selfcontained.",
            "        :param encrypted_advice_attributes: True if assertions in the advice",
            "        element should be encrypted.",
            "        :param encrypt_cert_advice: Certificate to be used for encryption of",
            "        assertions in the advice element.",
            "        :param encrypt_cert_assertion: Certificate to be used for encryption",
            "        of assertions.",
            "        :param sign_assertion: True if assertions should be signed.",
            "        :param pefim: True if a response according to the PEFIM profile",
            "        should be created.",
            "        :return: A response instance",
            "        \"\"\"",
            "",
            "        try:",
            "            args = self.gather_authn_response_args(",
            "                sp_entity_id, name_id_policy=name_id_policy, userid=userid,",
            "                name_id=name_id, sign_response=sign_response,",
            "                sign_assertion=sign_assertion,",
            "                encrypt_cert_advice=encrypt_cert_advice,",
            "                encrypt_cert_assertion=encrypt_cert_assertion,",
            "                encrypt_assertion=encrypt_assertion,",
            "                encrypt_assertion_self_contained",
            "                =encrypt_assertion_self_contained,",
            "                encrypted_advice_attributes=encrypted_advice_attributes,",
            "                pefim=pefim, **kwargs)",
            "        except IOError as exc:",
            "            response = self.create_error_response(in_response_to,",
            "                                                  destination,",
            "                                                  sp_entity_id,",
            "                                                  exc, name_id)",
            "            return (\"%s\" % response).split(\"\\n\")",
            "",
            "        try:",
            "            _authn = authn",
            "            if (sign_assertion or sign_response) and \\",
            "                    self.sec.cert_handler.generate_cert():",
            "                with self.lock:",
            "                    self.sec.cert_handler.update_cert(True)",
            "                    return self._authn_response(",
            "                        in_response_to, destination, sp_entity_id, identity,",
            "                        authn=_authn, issuer=issuer, pefim=pefim,",
            "                        sign_alg=sign_alg, digest_alg=digest_alg,",
            "                        session_not_on_or_after=session_not_on_or_after, **args)",
            "            return self._authn_response(",
            "                in_response_to, destination, sp_entity_id, identity,",
            "                authn=_authn, issuer=issuer, pefim=pefim, sign_alg=sign_alg,",
            "                digest_alg=digest_alg,",
            "                session_not_on_or_after=session_not_on_or_after, **args)",
            "",
            "        except MissingValue as exc:",
            "            return self.create_error_response(in_response_to, destination,",
            "                                              sp_entity_id, exc, name_id)",
            "",
            "    def create_authn_request_response(self, identity, in_response_to,",
            "                                      destination, sp_entity_id,",
            "                                      name_id_policy=None, userid=None,",
            "                                      name_id=None, authn=None, authn_decl=None,",
            "                                      issuer=None, sign_response=False,",
            "                                      sign_assertion=False,",
            "                                      session_not_on_or_after=None, **kwargs):",
            "",
            "        return self.create_authn_response(identity, in_response_to, destination,",
            "                                          sp_entity_id, name_id_policy, userid,",
            "                                          name_id, authn, issuer,",
            "                                          sign_response, sign_assertion,",
            "                                          authn_decl=authn_decl,",
            "                                          session_not_on_or_after=session_not_on_or_after)",
            "",
            "    # noinspection PyUnusedLocal",
            "    def create_assertion_id_request_response(self, assertion_id, sign=False,",
            "                                             sign_alg=None,",
            "                                             digest_alg=None, **kwargs):",
            "        \"\"\"",
            "",
            "        :param assertion_id:",
            "        :param sign:",
            "        :return:",
            "        \"\"\"",
            "",
            "        try:",
            "            (assertion, to_sign) = self.session_db.get_assertion(assertion_id)",
            "        except KeyError:",
            "            raise Unknown",
            "",
            "        if to_sign:",
            "            if assertion.signature is None:",
            "                assertion.signature = pre_signature_part(assertion.id,",
            "                                                         self.sec.my_cert, 1,",
            "                                                         sign_alg=sign_alg,",
            "                                                         digest_alg=digest_alg)",
            "",
            "            return signed_instance_factory(assertion, self.sec, to_sign)",
            "        else:",
            "            return assertion",
            "",
            "    # noinspection PyUnusedLocal",
            "    def create_name_id_mapping_response(self, name_id=None, encrypted_id=None,",
            "                                        in_response_to=None,",
            "                                        issuer=None, sign_response=False,",
            "                                        status=None, sign_alg=None,",
            "                                        digest_alg=None, **kwargs):",
            "        \"\"\"",
            "        protocol for mapping a principal's name identifier into a",
            "        different name identifier for the same principal.",
            "        Done over soap.",
            "",
            "        :param name_id:",
            "        :param encrypted_id:",
            "        :param in_response_to:",
            "        :param issuer:",
            "        :param sign_response:",
            "        :param status:",
            "        :return:",
            "        \"\"\"",
            "        # Done over SOAP",
            "",
            "        ms_args = self.message_args()",
            "",
            "        _resp = NameIDMappingResponse(name_id, encrypted_id,",
            "                                      in_response_to=in_response_to, **ms_args)",
            "",
            "        if sign_response:",
            "            return self.sign(_resp, sign_alg=sign_alg, digest_alg=digest_alg)",
            "        else:",
            "            logger.info(\"Message: %s\", _resp)",
            "            return _resp",
            "",
            "    def create_authn_query_response(self, subject, session_index=None,",
            "                                    requested_context=None, in_response_to=None,",
            "                                    issuer=None, sign_response=False,",
            "                                    status=None, sign_alg=None, digest_alg=None,",
            "                                    **kwargs):",
            "        \"\"\"",
            "        A successful <Response> will contain one or more assertions containing",
            "        authentication statements.",
            "",
            "        :return:",
            "        \"\"\"",
            "",
            "        margs = self.message_args()",
            "        asserts = []",
            "        for statement in self.session_db.get_authn_statements(",
            "                subject.name_id, session_index, requested_context):",
            "            asserts.append(saml.Assertion(authn_statement=statement,",
            "                                          subject=subject, **margs))",
            "",
            "        if asserts:",
            "            args = {\"assertion\": asserts}",
            "        else:",
            "            args = {}",
            "",
            "        return self._response(in_response_to, \"\", status, issuer,",
            "                              sign_response, to_sign=[], sign_alg=sign_alg,",
            "                              digest_alg=digest_alg, **args)",
            "",
            "    # ---------",
            "",
            "    def parse_ecp_authn_request(self):",
            "        pass",
            "",
            "    def create_ecp_authn_request_response(self, acs_url, identity,",
            "                                          in_response_to, destination,",
            "                                          sp_entity_id, name_id_policy=None,",
            "                                          userid=None, name_id=None, authn=None,",
            "                                          issuer=None, sign_response=False,",
            "                                          sign_assertion=False, **kwargs):",
            "",
            "        # ----------------------------------------",
            "        # <ecp:Response",
            "        # ----------------------------------------",
            "",
            "        ecp_response = ecp.Response(assertion_consumer_service_url=acs_url)",
            "        header = soapenv.Header()",
            "        header.extension_elements = [element_to_extension_element(ecp_response)]",
            "",
            "        # ----------------------------------------",
            "        # <samlp:Response",
            "        # ----------------------------------------",
            "",
            "        response = self.create_authn_response(identity, in_response_to,",
            "                                              destination, sp_entity_id,",
            "                                              name_id_policy, userid, name_id,",
            "                                              authn, issuer,",
            "                                              sign_response, sign_assertion)",
            "        body = soapenv.Body()",
            "        body.extension_elements = [element_to_extension_element(response)]",
            "",
            "        soap_envelope = soapenv.Envelope(header=header, body=body)",
            "",
            "        return \"%s\" % soap_envelope",
            "",
            "    def close(self):",
            "        self.ident.close()",
            "",
            "    def clean_out_user(self, name_id):",
            "        \"\"\"",
            "        Remove all authentication statements that belongs to a user identified",
            "        by a NameID instance",
            "",
            "        :param name_id: NameID instance",
            "        :return: The local identifier for the user",
            "        \"\"\"",
            "",
            "        lid = self.ident.find_local_id(name_id)",
            "        logger.info(\"Clean out %s\", lid)",
            "",
            "        # remove the authentications",
            "        try:",
            "            for _nid in [decode(x) for x in self.ident.db[lid].split(\" \")]:",
            "                try:",
            "                    self.session_db.remove_authn_statements(_nid)",
            "                except KeyError:",
            "                    pass",
            "        except KeyError:",
            "            pass",
            "",
            "        return lid"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "1",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "86": [
                "Server",
                "__init__"
            ],
            "88": [
                "Server",
                "__init__"
            ],
            "91": [
                "Server",
                "__init__"
            ]
        },
        "addLocation": []
    }
}