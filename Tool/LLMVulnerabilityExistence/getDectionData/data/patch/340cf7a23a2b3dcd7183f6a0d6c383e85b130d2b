{
    "django_filters/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": "     from . import rest_framework"
            },
            "1": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " del pkgutil"
            },
            "2": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-__version__ = '2.3.0'"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+__version__ = '2.4.0'"
            },
            "5": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " def parse_version(version):"
            }
        },
        "frontPatchFile": [
            "# flake8: noqa",
            "import pkgutil",
            "",
            "from .filters import *",
            "from .filterset import FilterSet",
            "",
            "# We make the `rest_framework` module available without an additional import.",
            "#   If DRF is not installed, no-op.",
            "if pkgutil.find_loader('rest_framework') is not None:",
            "    from . import rest_framework",
            "del pkgutil",
            "",
            "__version__ = '2.3.0'",
            "",
            "",
            "def parse_version(version):",
            "    '''",
            "    '0.1.2.dev1' -> (0, 1, 2, 'dev1')",
            "    '0.1.2' -> (0, 1, 2)",
            "    '''",
            "    v = version.split('.')",
            "    ret = []",
            "    for p in v:",
            "        if p.isdigit():",
            "            ret.append(int(p))",
            "        else:",
            "            ret.append(p)",
            "    return tuple(ret)",
            "",
            "VERSION = parse_version(__version__)"
        ],
        "afterPatchFile": [
            "# flake8: noqa",
            "import pkgutil",
            "",
            "from .filters import *",
            "from .filterset import FilterSet",
            "",
            "# We make the `rest_framework` module available without an additional import.",
            "#   If DRF is not installed, no-op.",
            "if pkgutil.find_loader('rest_framework') is not None:",
            "    from . import rest_framework",
            "del pkgutil",
            "",
            "__version__ = '2.4.0'",
            "",
            "",
            "def parse_version(version):",
            "    '''",
            "    '0.1.2.dev1' -> (0, 1, 2, 'dev1')",
            "    '0.1.2' -> (0, 1, 2)",
            "    '''",
            "    v = version.split('.')",
            "    ret = []",
            "    for p in v:",
            "        if p.isdigit():",
            "            ret.append(int(p))",
            "        else:",
            "            ret.append(p)",
            "    return tuple(ret)",
            "",
            "VERSION = parse_version(__version__)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "13": [
                "__version__"
            ]
        },
        "addLocation": []
    },
    "django_filters/filters.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " from datetime import timedelta"
            },
            "1": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " from django import forms"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+from django.core.validators import MaxValueValidator"
            },
            "4": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 6,
                "PatchRowcode": " from django.db.models import Q"
            },
            "5": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 7,
                "PatchRowcode": " from django.db.models.constants import LOOKUP_SEP"
            },
            "6": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " from django.forms.utils import pretty_name"
            },
            "7": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": 358,
                "PatchRowcode": " class NumberFilter(Filter):"
            },
            "8": {
                "beforePatchRowNumber": 358,
                "afterPatchRowNumber": 359,
                "PatchRowcode": "     field_class = forms.DecimalField"
            },
            "9": {
                "beforePatchRowNumber": 359,
                "afterPatchRowNumber": 360,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 361,
                "PatchRowcode": "+    def get_max_validator(self):"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 362,
                "PatchRowcode": "+        \"\"\""
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 363,
                "PatchRowcode": "+        Return a MaxValueValidator for the field, or None to disable."
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 364,
                "PatchRowcode": "+        \"\"\""
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 365,
                "PatchRowcode": "+        return MaxValueValidator(1e50)"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 366,
                "PatchRowcode": "+"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 367,
                "PatchRowcode": "+    @property"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 368,
                "PatchRowcode": "+    def field(self):"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 369,
                "PatchRowcode": "+        if not hasattr(self, '_field'):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 370,
                "PatchRowcode": "+            field = super().field"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 371,
                "PatchRowcode": "+            max_validator = self.get_max_validator()"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 372,
                "PatchRowcode": "+            if max_validator:"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 373,
                "PatchRowcode": "+                field.validators.append(max_validator)"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 374,
                "PatchRowcode": "+"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 375,
                "PatchRowcode": "+            self._field = field"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 376,
                "PatchRowcode": "+        return self._field"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 377,
                "PatchRowcode": "+"
            },
            "27": {
                "beforePatchRowNumber": 360,
                "afterPatchRowNumber": 378,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": 361,
                "afterPatchRowNumber": 379,
                "PatchRowcode": " class NumericRangeFilter(Filter):"
            },
            "29": {
                "beforePatchRowNumber": 362,
                "afterPatchRowNumber": 380,
                "PatchRowcode": "     field_class = RangeField"
            }
        },
        "frontPatchFile": [
            "from collections import OrderedDict",
            "from datetime import timedelta",
            "",
            "from django import forms",
            "from django.db.models import Q",
            "from django.db.models.constants import LOOKUP_SEP",
            "from django.forms.utils import pretty_name",
            "from django.utils.itercompat import is_iterable",
            "from django.utils.timezone import now",
            "from django.utils.translation import gettext_lazy as _",
            "",
            "from .conf import settings",
            "from .constants import EMPTY_VALUES",
            "from .fields import (",
            "    BaseCSVField,",
            "    BaseRangeField,",
            "    ChoiceField,",
            "    DateRangeField,",
            "    DateTimeRangeField,",
            "    IsoDateTimeField,",
            "    IsoDateTimeRangeField,",
            "    LookupChoiceField,",
            "    ModelChoiceField,",
            "    ModelMultipleChoiceField,",
            "    MultipleChoiceField,",
            "    RangeField,",
            "    TimeRangeField",
            ")",
            "from .utils import get_model_field, label_for_filter",
            "",
            "__all__ = [",
            "    'AllValuesFilter',",
            "    'AllValuesMultipleFilter',",
            "    'BaseCSVFilter',",
            "    'BaseInFilter',",
            "    'BaseRangeFilter',",
            "    'BooleanFilter',",
            "    'CharFilter',",
            "    'ChoiceFilter',",
            "    'DateFilter',",
            "    'DateFromToRangeFilter',",
            "    'DateRangeFilter',",
            "    'DateTimeFilter',",
            "    'DateTimeFromToRangeFilter',",
            "    'DurationFilter',",
            "    'Filter',",
            "    'IsoDateTimeFilter',",
            "    'IsoDateTimeFromToRangeFilter',",
            "    'LookupChoiceFilter',",
            "    'ModelChoiceFilter',",
            "    'ModelMultipleChoiceFilter',",
            "    'MultipleChoiceFilter',",
            "    'NumberFilter',",
            "    'NumericRangeFilter',",
            "    'OrderingFilter',",
            "    'RangeFilter',",
            "    'TimeFilter',",
            "    'TimeRangeFilter',",
            "    'TypedChoiceFilter',",
            "    'TypedMultipleChoiceFilter',",
            "    'UUIDFilter',",
            "]",
            "",
            "",
            "class Filter:",
            "    creation_counter = 0",
            "    field_class = forms.Field",
            "",
            "    def __init__(self, field_name=None, lookup_expr=None, *, label=None,",
            "                 method=None, distinct=False, exclude=False, **kwargs):",
            "        if lookup_expr is None:",
            "            lookup_expr = settings.DEFAULT_LOOKUP_EXPR",
            "        self.field_name = field_name",
            "        self.lookup_expr = lookup_expr",
            "        self.label = label",
            "        self.method = method",
            "        self.distinct = distinct",
            "        self.exclude = exclude",
            "",
            "        self.extra = kwargs",
            "        self.extra.setdefault('required', False)",
            "",
            "        self.creation_counter = Filter.creation_counter",
            "        Filter.creation_counter += 1",
            "",
            "    def get_method(self, qs):",
            "        \"\"\"Return filter method based on whether we're excluding",
            "           or simply filtering.",
            "        \"\"\"",
            "        return qs.exclude if self.exclude else qs.filter",
            "",
            "    def method():",
            "        \"\"\"",
            "        Filter method needs to be lazily resolved, as it may be dependent on",
            "        the 'parent' FilterSet.",
            "        \"\"\"",
            "        def fget(self):",
            "            return self._method",
            "",
            "        def fset(self, value):",
            "            self._method = value",
            "",
            "            # clear existing FilterMethod",
            "            if isinstance(self.filter, FilterMethod):",
            "                del self.filter",
            "",
            "            # override filter w/ FilterMethod.",
            "            if value is not None:",
            "                self.filter = FilterMethod(self)",
            "",
            "        return locals()",
            "    method = property(**method())",
            "",
            "    def label():",
            "        def fget(self):",
            "            if self._label is None and hasattr(self, 'model'):",
            "                self._label = label_for_filter(",
            "                    self.model, self.field_name, self.lookup_expr, self.exclude",
            "                )",
            "            return self._label",
            "",
            "        def fset(self, value):",
            "            self._label = value",
            "",
            "        return locals()",
            "    label = property(**label())",
            "",
            "    @property",
            "    def field(self):",
            "        if not hasattr(self, '_field'):",
            "            field_kwargs = self.extra.copy()",
            "",
            "            if settings.DISABLE_HELP_TEXT:",
            "                field_kwargs.pop('help_text', None)",
            "",
            "            self._field = self.field_class(label=self.label, **field_kwargs)",
            "        return self._field",
            "",
            "    def filter(self, qs, value):",
            "        if value in EMPTY_VALUES:",
            "            return qs",
            "        if self.distinct:",
            "            qs = qs.distinct()",
            "        lookup = '%s__%s' % (self.field_name, self.lookup_expr)",
            "        qs = self.get_method(qs)(**{lookup: value})",
            "        return qs",
            "",
            "",
            "class CharFilter(Filter):",
            "    field_class = forms.CharField",
            "",
            "",
            "class BooleanFilter(Filter):",
            "    field_class = forms.NullBooleanField",
            "",
            "",
            "class ChoiceFilter(Filter):",
            "    field_class = ChoiceField",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        self.null_value = kwargs.get('null_value', settings.NULL_CHOICE_VALUE)",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def filter(self, qs, value):",
            "        if value != self.null_value:",
            "            return super().filter(qs, value)",
            "",
            "        qs = self.get_method(qs)(**{'%s__%s' % (self.field_name, self.lookup_expr): None})",
            "        return qs.distinct() if self.distinct else qs",
            "",
            "",
            "class TypedChoiceFilter(Filter):",
            "    field_class = forms.TypedChoiceField",
            "",
            "",
            "class UUIDFilter(Filter):",
            "    field_class = forms.UUIDField",
            "",
            "",
            "class MultipleChoiceFilter(Filter):",
            "    \"\"\"",
            "    This filter performs OR(by default) or AND(using conjoined=True) query",
            "    on the selected options.",
            "",
            "    Advanced usage",
            "    --------------",
            "    Depending on your application logic, when all or no choices are selected,",
            "    filtering may be a no-operation. In this case you may wish to avoid the",
            "    filtering overhead, particularly if using a `distinct` call.",
            "",
            "    You can override `get_filter_predicate` to use a custom filter.",
            "    By default it will use the filter's name for the key, and the value will",
            "    be the model object - or in case of passing in `to_field_name` the",
            "    value of that attribute on the model.",
            "",
            "    Set `always_filter` to `False` after instantiation to enable the default",
            "    `is_noop` test. You can override `is_noop` if you need a different test",
            "    for your application.",
            "",
            "    `distinct` defaults to `True` as to-many relationships will generally",
            "    require this.",
            "    \"\"\"",
            "    field_class = MultipleChoiceField",
            "",
            "    always_filter = True",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        kwargs.setdefault('distinct', True)",
            "        self.conjoined = kwargs.pop('conjoined', False)",
            "        self.null_value = kwargs.get('null_value', settings.NULL_CHOICE_VALUE)",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def is_noop(self, qs, value):",
            "        \"\"\"",
            "        Return `True` to short-circuit unnecessary and potentially slow",
            "        filtering.",
            "        \"\"\"",
            "        if self.always_filter:",
            "            return False",
            "",
            "        # A reasonable default for being a noop...",
            "        if self.extra.get('required') and len(value) == len(self.field.choices):",
            "            return True",
            "",
            "        return False",
            "",
            "    def filter(self, qs, value):",
            "        if not value:",
            "            # Even though not a noop, no point filtering if empty.",
            "            return qs",
            "",
            "        if self.is_noop(qs, value):",
            "            return qs",
            "",
            "        if not self.conjoined:",
            "            q = Q()",
            "        for v in set(value):",
            "            if v == self.null_value:",
            "                v = None",
            "            predicate = self.get_filter_predicate(v)",
            "            if self.conjoined:",
            "                qs = self.get_method(qs)(**predicate)",
            "            else:",
            "                q |= Q(**predicate)",
            "",
            "        if not self.conjoined:",
            "            qs = self.get_method(qs)(q)",
            "",
            "        return qs.distinct() if self.distinct else qs",
            "",
            "    def get_filter_predicate(self, v):",
            "        name = self.field_name",
            "        if name and self.lookup_expr != settings.DEFAULT_LOOKUP_EXPR:",
            "            name = LOOKUP_SEP.join([name, self.lookup_expr])",
            "        try:",
            "            return {name: getattr(v, self.field.to_field_name)}",
            "        except (AttributeError, TypeError):",
            "            return {name: v}",
            "",
            "",
            "class TypedMultipleChoiceFilter(MultipleChoiceFilter):",
            "    field_class = forms.TypedMultipleChoiceField",
            "",
            "",
            "class DateFilter(Filter):",
            "    field_class = forms.DateField",
            "",
            "",
            "class DateTimeFilter(Filter):",
            "    field_class = forms.DateTimeField",
            "",
            "",
            "class IsoDateTimeFilter(DateTimeFilter):",
            "    \"\"\"",
            "    Uses IsoDateTimeField to support filtering on ISO 8601 formatted datetimes.",
            "",
            "    For context see:",
            "",
            "    * https://code.djangoproject.com/ticket/23448",
            "    * https://github.com/encode/django-rest-framework/issues/1338",
            "    * https://github.com/carltongibson/django-filter/pull/264",
            "    \"\"\"",
            "    field_class = IsoDateTimeField",
            "",
            "",
            "class TimeFilter(Filter):",
            "    field_class = forms.TimeField",
            "",
            "",
            "class DurationFilter(Filter):",
            "    field_class = forms.DurationField",
            "",
            "",
            "class QuerySetRequestMixin:",
            "    \"\"\"",
            "    Add callable functionality to filters that support the ``queryset``",
            "    argument. If the ``queryset`` is callable, then it **must** accept the",
            "    ``request`` object as a single argument.",
            "",
            "    This is useful for filtering querysets by properties on the ``request``",
            "    object, such as the user.",
            "",
            "    Example::",
            "",
            "        def departments(request):",
            "            company = request.user.company",
            "            return company.department_set.all()",
            "",
            "        class EmployeeFilter(filters.FilterSet):",
            "            department = filters.ModelChoiceFilter(queryset=departments)",
            "            ...",
            "",
            "    The above example restricts the set of departments to those in the logged-in",
            "    user's associated company.",
            "",
            "    \"\"\"",
            "    def __init__(self, *args, **kwargs):",
            "        self.queryset = kwargs.get('queryset')",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def get_request(self):",
            "        try:",
            "            return self.parent.request",
            "        except AttributeError:",
            "            return None",
            "",
            "    def get_queryset(self, request):",
            "        queryset = self.queryset",
            "",
            "        if callable(queryset):",
            "            return queryset(request)",
            "        return queryset",
            "",
            "    @property",
            "    def field(self):",
            "        request = self.get_request()",
            "        queryset = self.get_queryset(request)",
            "",
            "        if queryset is not None:",
            "            self.extra['queryset'] = queryset",
            "",
            "        return super().field",
            "",
            "",
            "class ModelChoiceFilter(QuerySetRequestMixin, ChoiceFilter):",
            "    field_class = ModelChoiceField",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        kwargs.setdefault('empty_label', settings.EMPTY_CHOICE_LABEL)",
            "        super().__init__(*args, **kwargs)",
            "",
            "",
            "class ModelMultipleChoiceFilter(QuerySetRequestMixin, MultipleChoiceFilter):",
            "    field_class = ModelMultipleChoiceField",
            "",
            "",
            "class NumberFilter(Filter):",
            "    field_class = forms.DecimalField",
            "",
            "",
            "class NumericRangeFilter(Filter):",
            "    field_class = RangeField",
            "",
            "    def filter(self, qs, value):",
            "        if value:",
            "            if value.start is not None and value.stop is not None:",
            "                value = (value.start, value.stop)",
            "            elif value.start is not None:",
            "                self.lookup_expr = 'startswith'",
            "                value = value.start",
            "            elif value.stop is not None:",
            "                self.lookup_expr = 'endswith'",
            "                value = value.stop",
            "",
            "        return super().filter(qs, value)",
            "",
            "",
            "class RangeFilter(Filter):",
            "    field_class = RangeField",
            "",
            "    def filter(self, qs, value):",
            "        if value:",
            "            if value.start is not None and value.stop is not None:",
            "                self.lookup_expr = 'range'",
            "                value = (value.start, value.stop)",
            "            elif value.start is not None:",
            "                self.lookup_expr = 'gte'",
            "                value = value.start",
            "            elif value.stop is not None:",
            "                self.lookup_expr = 'lte'",
            "                value = value.stop",
            "",
            "        return super().filter(qs, value)",
            "",
            "",
            "def _truncate(dt):",
            "    return dt.date()",
            "",
            "",
            "class DateRangeFilter(ChoiceFilter):",
            "    choices = [",
            "        ('today', _('Today')),",
            "        ('yesterday', _('Yesterday')),",
            "        ('week', _('Past 7 days')),",
            "        ('month', _('This month')),",
            "        ('year', _('This year')),",
            "    ]",
            "",
            "    filters = {",
            "        'today': lambda qs, name: qs.filter(**{",
            "            '%s__year' % name: now().year,",
            "            '%s__month' % name: now().month,",
            "            '%s__day' % name: now().day",
            "        }),",
            "        'yesterday': lambda qs, name: qs.filter(**{",
            "            '%s__year' % name: (now() - timedelta(days=1)).year,",
            "            '%s__month' % name: (now() - timedelta(days=1)).month,",
            "            '%s__day' % name: (now() - timedelta(days=1)).day,",
            "        }),",
            "        'week': lambda qs, name: qs.filter(**{",
            "            '%s__gte' % name: _truncate(now() - timedelta(days=7)),",
            "            '%s__lt' % name: _truncate(now() + timedelta(days=1)),",
            "        }),",
            "        'month': lambda qs, name: qs.filter(**{",
            "            '%s__year' % name: now().year,",
            "            '%s__month' % name: now().month",
            "        }),",
            "        'year': lambda qs, name: qs.filter(**{",
            "            '%s__year' % name: now().year,",
            "        }),",
            "    }",
            "",
            "    def __init__(self, choices=None, filters=None, *args, **kwargs):",
            "        if choices is not None:",
            "            self.choices = choices",
            "        if filters is not None:",
            "            self.filters = filters",
            "",
            "        unique = set([x[0] for x in self.choices]) ^ set(self.filters)",
            "        assert not unique, \\",
            "            \"Keys must be present in both 'choices' and 'filters'. Missing keys: \" \\",
            "            \"'%s'\" % ', '.join(sorted(unique))",
            "",
            "        # TODO: remove assertion in 2.1",
            "        assert not hasattr(self, 'options'), \\",
            "            \"The 'options' attribute has been replaced by 'choices' and 'filters'. \" \\",
            "            \"See: https://django-filter.readthedocs.io/en/master/guide/migration.html\"",
            "",
            "        # null choice not relevant",
            "        kwargs.setdefault('null_label', None)",
            "        super().__init__(choices=self.choices, *args, **kwargs)",
            "",
            "    def filter(self, qs, value):",
            "        if not value:",
            "            return qs",
            "",
            "        assert value in self.filters",
            "",
            "        qs = self.filters[value](qs, self.field_name)",
            "        return qs.distinct() if self.distinct else qs",
            "",
            "",
            "class DateFromToRangeFilter(RangeFilter):",
            "    field_class = DateRangeField",
            "",
            "",
            "class DateTimeFromToRangeFilter(RangeFilter):",
            "    field_class = DateTimeRangeField",
            "",
            "",
            "class IsoDateTimeFromToRangeFilter(RangeFilter):",
            "    field_class = IsoDateTimeRangeField",
            "",
            "",
            "class TimeRangeFilter(RangeFilter):",
            "    field_class = TimeRangeField",
            "",
            "",
            "class AllValuesFilter(ChoiceFilter):",
            "    @property",
            "    def field(self):",
            "        qs = self.model._default_manager.distinct()",
            "        qs = qs.order_by(self.field_name).values_list(self.field_name, flat=True)",
            "        self.extra['choices'] = [(o, o) for o in qs]",
            "        return super().field",
            "",
            "",
            "class AllValuesMultipleFilter(MultipleChoiceFilter):",
            "    @property",
            "    def field(self):",
            "        qs = self.model._default_manager.distinct()",
            "        qs = qs.order_by(self.field_name).values_list(self.field_name, flat=True)",
            "        self.extra['choices'] = [(o, o) for o in qs]",
            "        return super().field",
            "",
            "",
            "class BaseCSVFilter(Filter):",
            "    \"\"\"",
            "    Base class for CSV type filters, such as IN and RANGE.",
            "    \"\"\"",
            "    base_field_class = BaseCSVField",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        kwargs.setdefault('help_text', _('Multiple values may be separated by commas.'))",
            "        super().__init__(*args, **kwargs)",
            "",
            "        class ConcreteCSVField(self.base_field_class, self.field_class):",
            "            pass",
            "        ConcreteCSVField.__name__ = self._field_class_name(",
            "            self.field_class, self.lookup_expr",
            "        )",
            "",
            "        self.field_class = ConcreteCSVField",
            "",
            "    @classmethod",
            "    def _field_class_name(cls, field_class, lookup_expr):",
            "        \"\"\"",
            "        Generate a suitable class name for the concrete field class. This is not",
            "        completely reliable, as not all field class names are of the format",
            "        <Type>Field.",
            "",
            "        ex::",
            "",
            "            BaseCSVFilter._field_class_name(DateTimeField, 'year__in')",
            "",
            "            returns 'DateTimeYearInField'",
            "",
            "        \"\"\"",
            "        # DateTimeField => DateTime",
            "        type_name = field_class.__name__",
            "        if type_name.endswith('Field'):",
            "            type_name = type_name[:-5]",
            "",
            "        # year__in => YearIn",
            "        parts = lookup_expr.split(LOOKUP_SEP)",
            "        expression_name = ''.join(p.capitalize() for p in parts)",
            "",
            "        # DateTimeYearInField",
            "        return str('%s%sField' % (type_name, expression_name))",
            "",
            "",
            "class BaseInFilter(BaseCSVFilter):",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        kwargs.setdefault('lookup_expr', 'in')",
            "        super().__init__(*args, **kwargs)",
            "",
            "",
            "class BaseRangeFilter(BaseCSVFilter):",
            "    base_field_class = BaseRangeField",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        kwargs.setdefault('lookup_expr', 'range')",
            "        super().__init__(*args, **kwargs)",
            "",
            "",
            "class LookupChoiceFilter(Filter):",
            "    \"\"\"",
            "    A combined filter that allows users to select the lookup expression from a dropdown.",
            "",
            "    * ``lookup_choices`` is an optional argument that accepts multiple input",
            "      formats, and is ultimately normlized as the choices used in the lookup",
            "      dropdown. See ``.get_lookup_choices()`` for more information.",
            "",
            "    * ``field_class`` is an optional argument that allows you to set the inner",
            "      form field class used to validate the value. Default: ``forms.CharField``",
            "",
            "    ex::",
            "",
            "        price = django_filters.LookupChoiceFilter(",
            "            field_class=forms.DecimalField,",
            "            lookup_choices=[",
            "                ('exact', 'Equals'),",
            "                ('gt', 'Greater than'),",
            "                ('lt', 'Less than'),",
            "            ]",
            "        )",
            "",
            "    \"\"\"",
            "    field_class = forms.CharField",
            "    outer_class = LookupChoiceField",
            "",
            "    def __init__(self, field_name=None, lookup_choices=None, field_class=None, **kwargs):",
            "        self.empty_label = kwargs.pop('empty_label', settings.EMPTY_CHOICE_LABEL)",
            "",
            "        super(LookupChoiceFilter, self).__init__(field_name=field_name, **kwargs)",
            "",
            "        self.lookup_choices = lookup_choices",
            "        if field_class is not None:",
            "            self.field_class = field_class",
            "",
            "    @classmethod",
            "    def normalize_lookup(cls, lookup):",
            "        \"\"\"",
            "        Normalize the lookup into a tuple of ``(lookup expression, display value)``",
            "",
            "        If the ``lookup`` is already a tuple, the tuple is not altered.",
            "        If the ``lookup`` is a string, a tuple is returned with the lookup",
            "        expression used as the basis for the display value.",
            "",
            "        ex::",
            "",
            "            >>> LookupChoiceFilter.normalize_lookup(('exact', 'Equals'))",
            "            ('exact', 'Equals')",
            "",
            "            >>> LookupChoiceFilter.normalize_lookup('has_key')",
            "            ('has_key', 'Has key')",
            "",
            "        \"\"\"",
            "        if isinstance(lookup, str):",
            "            return (lookup, pretty_name(lookup))",
            "        return (lookup[0], lookup[1])",
            "",
            "    def get_lookup_choices(self):",
            "        \"\"\"",
            "        Get the lookup choices in a format suitable for ``django.forms.ChoiceField``.",
            "        If the filter is initialized with ``lookup_choices``, this value is normalized",
            "        and passed to the underlying ``LookupChoiceField``. If no choices are provided,",
            "        they are generated from the corresponding model field's registered lookups.",
            "        \"\"\"",
            "        lookups = self.lookup_choices",
            "        if lookups is None:",
            "            field = get_model_field(self.model, self.field_name)",
            "            lookups = field.get_lookups()",
            "",
            "        return [self.normalize_lookup(lookup) for lookup in lookups]",
            "",
            "    @property",
            "    def field(self):",
            "        if not hasattr(self, '_field'):",
            "            inner_field = super().field",
            "            lookups = self.get_lookup_choices()",
            "",
            "            self._field = self.outer_class(",
            "                inner_field, lookups,",
            "                label=self.label,",
            "                empty_label=self.empty_label,",
            "                required=self.extra['required'],",
            "            )",
            "",
            "        return self._field",
            "",
            "    def filter(self, qs, lookup):",
            "        if not lookup:",
            "            return super().filter(qs, None)",
            "",
            "        self.lookup_expr = lookup.lookup_expr",
            "        return super().filter(qs, lookup.value)",
            "",
            "",
            "class OrderingFilter(BaseCSVFilter, ChoiceFilter):",
            "    \"\"\"",
            "    Enable queryset ordering. As an extension of ``ChoiceFilter`` it accepts",
            "    two additional arguments that are used to build the ordering choices.",
            "",
            "    * ``fields`` is a mapping of {model field name: parameter name}. The",
            "      parameter names are exposed in the choices and mask/alias the field",
            "      names used in the ``order_by()`` call. Similar to field ``choices``,",
            "      ``fields`` accepts the 'list of two-tuples' syntax that retains order.",
            "      ``fields`` may also just be an iterable of strings. In this case, the",
            "      field names simply double as the exposed parameter names.",
            "",
            "    * ``field_labels`` is an optional argument that allows you to customize",
            "      the display label for the corresponding parameter. It accepts a mapping",
            "      of {field name: human readable label}. Keep in mind that the key is the",
            "      field name, and not the exposed parameter name.",
            "",
            "    Additionally, you can just provide your own ``choices`` if you require",
            "    explicit control over the exposed options. For example, when you might",
            "    want to disable descending sort options.",
            "",
            "    This filter is also CSV-based, and accepts multiple ordering params. The",
            "    default select widget does not enable the use of this, but it is useful",
            "    for APIs.",
            "",
            "    \"\"\"",
            "    descending_fmt = _('%s (descending)')",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        \"\"\"",
            "        ``fields`` may be either a mapping or an iterable.",
            "        ``field_labels`` must be a map of field names to display labels",
            "        \"\"\"",
            "        fields = kwargs.pop('fields', {})",
            "        fields = self.normalize_fields(fields)",
            "        field_labels = kwargs.pop('field_labels', {})",
            "",
            "        self.param_map = {v: k for k, v in fields.items()}",
            "",
            "        if 'choices' not in kwargs:",
            "            kwargs['choices'] = self.build_choices(fields, field_labels)",
            "",
            "        kwargs.setdefault('label', _('Ordering'))",
            "        kwargs.setdefault('help_text', '')",
            "        kwargs.setdefault('null_label', None)",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def get_ordering_value(self, param):",
            "        descending = param.startswith('-')",
            "        param = param[1:] if descending else param",
            "        field_name = self.param_map.get(param, param)",
            "",
            "        return \"-%s\" % field_name if descending else field_name",
            "",
            "    def filter(self, qs, value):",
            "        if value in EMPTY_VALUES:",
            "            return qs",
            "",
            "        ordering = [self.get_ordering_value(param) for param in value]",
            "        return qs.order_by(*ordering)",
            "",
            "    @classmethod",
            "    def normalize_fields(cls, fields):",
            "        \"\"\"",
            "        Normalize the fields into an ordered map of {field name: param name}",
            "        \"\"\"",
            "        # fields is a mapping, copy into new OrderedDict",
            "        if isinstance(fields, dict):",
            "            return OrderedDict(fields)",
            "",
            "        # convert iterable of values => iterable of pairs (field name, param name)",
            "        assert is_iterable(fields), \\",
            "            \"'fields' must be an iterable (e.g., a list, tuple, or mapping).\"",
            "",
            "        # fields is an iterable of field names",
            "        assert all(isinstance(field, str) or",
            "                   is_iterable(field) and len(field) == 2  # may need to be wrapped in parens",
            "                   for field in fields), \\",
            "            \"'fields' must contain strings or (field name, param name) pairs.\"",
            "",
            "        return OrderedDict([",
            "            (f, f) if isinstance(f, str) else f for f in fields",
            "        ])",
            "",
            "    def build_choices(self, fields, labels):",
            "        ascending = [",
            "            (param, labels.get(field, _(pretty_name(param))))",
            "            for field, param in fields.items()",
            "        ]",
            "        descending = [",
            "            ('-%s' % param, labels.get('-%s' % param, self.descending_fmt % label))",
            "            for param, label in ascending",
            "        ]",
            "",
            "        # interleave the ascending and descending choices",
            "        return [val for pair in zip(ascending, descending) for val in pair]",
            "",
            "",
            "class FilterMethod:",
            "    \"\"\"",
            "    This helper is used to override Filter.filter() when a 'method' argument",
            "    is passed. It proxies the call to the actual method on the filter's parent.",
            "    \"\"\"",
            "    def __init__(self, filter_instance):",
            "        self.f = filter_instance",
            "",
            "    def __call__(self, qs, value):",
            "        if value in EMPTY_VALUES:",
            "            return qs",
            "",
            "        return self.method(qs, self.f.field_name, value)",
            "",
            "    @property",
            "    def method(self):",
            "        \"\"\"",
            "        Resolve the method on the parent filterset.",
            "        \"\"\"",
            "        instance = self.f",
            "",
            "        # noop if 'method' is a function",
            "        if callable(instance.method):",
            "            return instance.method",
            "",
            "        # otherwise, method is the name of a method on the parent FilterSet.",
            "        assert hasattr(instance, 'parent'), \\",
            "            \"Filter '%s' must have a parent FilterSet to find '.%s()'\" %  \\",
            "            (instance.field_name, instance.method)",
            "",
            "        parent = instance.parent",
            "        method = getattr(parent, instance.method, None)",
            "",
            "        assert callable(method), \\",
            "            \"Expected parent FilterSet '%s.%s' to have a '.%s()' method.\" % \\",
            "            (parent.__class__.__module__, parent.__class__.__name__, instance.method)",
            "",
            "        return method"
        ],
        "afterPatchFile": [
            "from collections import OrderedDict",
            "from datetime import timedelta",
            "",
            "from django import forms",
            "from django.core.validators import MaxValueValidator",
            "from django.db.models import Q",
            "from django.db.models.constants import LOOKUP_SEP",
            "from django.forms.utils import pretty_name",
            "from django.utils.itercompat import is_iterable",
            "from django.utils.timezone import now",
            "from django.utils.translation import gettext_lazy as _",
            "",
            "from .conf import settings",
            "from .constants import EMPTY_VALUES",
            "from .fields import (",
            "    BaseCSVField,",
            "    BaseRangeField,",
            "    ChoiceField,",
            "    DateRangeField,",
            "    DateTimeRangeField,",
            "    IsoDateTimeField,",
            "    IsoDateTimeRangeField,",
            "    LookupChoiceField,",
            "    ModelChoiceField,",
            "    ModelMultipleChoiceField,",
            "    MultipleChoiceField,",
            "    RangeField,",
            "    TimeRangeField",
            ")",
            "from .utils import get_model_field, label_for_filter",
            "",
            "__all__ = [",
            "    'AllValuesFilter',",
            "    'AllValuesMultipleFilter',",
            "    'BaseCSVFilter',",
            "    'BaseInFilter',",
            "    'BaseRangeFilter',",
            "    'BooleanFilter',",
            "    'CharFilter',",
            "    'ChoiceFilter',",
            "    'DateFilter',",
            "    'DateFromToRangeFilter',",
            "    'DateRangeFilter',",
            "    'DateTimeFilter',",
            "    'DateTimeFromToRangeFilter',",
            "    'DurationFilter',",
            "    'Filter',",
            "    'IsoDateTimeFilter',",
            "    'IsoDateTimeFromToRangeFilter',",
            "    'LookupChoiceFilter',",
            "    'ModelChoiceFilter',",
            "    'ModelMultipleChoiceFilter',",
            "    'MultipleChoiceFilter',",
            "    'NumberFilter',",
            "    'NumericRangeFilter',",
            "    'OrderingFilter',",
            "    'RangeFilter',",
            "    'TimeFilter',",
            "    'TimeRangeFilter',",
            "    'TypedChoiceFilter',",
            "    'TypedMultipleChoiceFilter',",
            "    'UUIDFilter',",
            "]",
            "",
            "",
            "class Filter:",
            "    creation_counter = 0",
            "    field_class = forms.Field",
            "",
            "    def __init__(self, field_name=None, lookup_expr=None, *, label=None,",
            "                 method=None, distinct=False, exclude=False, **kwargs):",
            "        if lookup_expr is None:",
            "            lookup_expr = settings.DEFAULT_LOOKUP_EXPR",
            "        self.field_name = field_name",
            "        self.lookup_expr = lookup_expr",
            "        self.label = label",
            "        self.method = method",
            "        self.distinct = distinct",
            "        self.exclude = exclude",
            "",
            "        self.extra = kwargs",
            "        self.extra.setdefault('required', False)",
            "",
            "        self.creation_counter = Filter.creation_counter",
            "        Filter.creation_counter += 1",
            "",
            "    def get_method(self, qs):",
            "        \"\"\"Return filter method based on whether we're excluding",
            "           or simply filtering.",
            "        \"\"\"",
            "        return qs.exclude if self.exclude else qs.filter",
            "",
            "    def method():",
            "        \"\"\"",
            "        Filter method needs to be lazily resolved, as it may be dependent on",
            "        the 'parent' FilterSet.",
            "        \"\"\"",
            "        def fget(self):",
            "            return self._method",
            "",
            "        def fset(self, value):",
            "            self._method = value",
            "",
            "            # clear existing FilterMethod",
            "            if isinstance(self.filter, FilterMethod):",
            "                del self.filter",
            "",
            "            # override filter w/ FilterMethod.",
            "            if value is not None:",
            "                self.filter = FilterMethod(self)",
            "",
            "        return locals()",
            "    method = property(**method())",
            "",
            "    def label():",
            "        def fget(self):",
            "            if self._label is None and hasattr(self, 'model'):",
            "                self._label = label_for_filter(",
            "                    self.model, self.field_name, self.lookup_expr, self.exclude",
            "                )",
            "            return self._label",
            "",
            "        def fset(self, value):",
            "            self._label = value",
            "",
            "        return locals()",
            "    label = property(**label())",
            "",
            "    @property",
            "    def field(self):",
            "        if not hasattr(self, '_field'):",
            "            field_kwargs = self.extra.copy()",
            "",
            "            if settings.DISABLE_HELP_TEXT:",
            "                field_kwargs.pop('help_text', None)",
            "",
            "            self._field = self.field_class(label=self.label, **field_kwargs)",
            "        return self._field",
            "",
            "    def filter(self, qs, value):",
            "        if value in EMPTY_VALUES:",
            "            return qs",
            "        if self.distinct:",
            "            qs = qs.distinct()",
            "        lookup = '%s__%s' % (self.field_name, self.lookup_expr)",
            "        qs = self.get_method(qs)(**{lookup: value})",
            "        return qs",
            "",
            "",
            "class CharFilter(Filter):",
            "    field_class = forms.CharField",
            "",
            "",
            "class BooleanFilter(Filter):",
            "    field_class = forms.NullBooleanField",
            "",
            "",
            "class ChoiceFilter(Filter):",
            "    field_class = ChoiceField",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        self.null_value = kwargs.get('null_value', settings.NULL_CHOICE_VALUE)",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def filter(self, qs, value):",
            "        if value != self.null_value:",
            "            return super().filter(qs, value)",
            "",
            "        qs = self.get_method(qs)(**{'%s__%s' % (self.field_name, self.lookup_expr): None})",
            "        return qs.distinct() if self.distinct else qs",
            "",
            "",
            "class TypedChoiceFilter(Filter):",
            "    field_class = forms.TypedChoiceField",
            "",
            "",
            "class UUIDFilter(Filter):",
            "    field_class = forms.UUIDField",
            "",
            "",
            "class MultipleChoiceFilter(Filter):",
            "    \"\"\"",
            "    This filter performs OR(by default) or AND(using conjoined=True) query",
            "    on the selected options.",
            "",
            "    Advanced usage",
            "    --------------",
            "    Depending on your application logic, when all or no choices are selected,",
            "    filtering may be a no-operation. In this case you may wish to avoid the",
            "    filtering overhead, particularly if using a `distinct` call.",
            "",
            "    You can override `get_filter_predicate` to use a custom filter.",
            "    By default it will use the filter's name for the key, and the value will",
            "    be the model object - or in case of passing in `to_field_name` the",
            "    value of that attribute on the model.",
            "",
            "    Set `always_filter` to `False` after instantiation to enable the default",
            "    `is_noop` test. You can override `is_noop` if you need a different test",
            "    for your application.",
            "",
            "    `distinct` defaults to `True` as to-many relationships will generally",
            "    require this.",
            "    \"\"\"",
            "    field_class = MultipleChoiceField",
            "",
            "    always_filter = True",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        kwargs.setdefault('distinct', True)",
            "        self.conjoined = kwargs.pop('conjoined', False)",
            "        self.null_value = kwargs.get('null_value', settings.NULL_CHOICE_VALUE)",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def is_noop(self, qs, value):",
            "        \"\"\"",
            "        Return `True` to short-circuit unnecessary and potentially slow",
            "        filtering.",
            "        \"\"\"",
            "        if self.always_filter:",
            "            return False",
            "",
            "        # A reasonable default for being a noop...",
            "        if self.extra.get('required') and len(value) == len(self.field.choices):",
            "            return True",
            "",
            "        return False",
            "",
            "    def filter(self, qs, value):",
            "        if not value:",
            "            # Even though not a noop, no point filtering if empty.",
            "            return qs",
            "",
            "        if self.is_noop(qs, value):",
            "            return qs",
            "",
            "        if not self.conjoined:",
            "            q = Q()",
            "        for v in set(value):",
            "            if v == self.null_value:",
            "                v = None",
            "            predicate = self.get_filter_predicate(v)",
            "            if self.conjoined:",
            "                qs = self.get_method(qs)(**predicate)",
            "            else:",
            "                q |= Q(**predicate)",
            "",
            "        if not self.conjoined:",
            "            qs = self.get_method(qs)(q)",
            "",
            "        return qs.distinct() if self.distinct else qs",
            "",
            "    def get_filter_predicate(self, v):",
            "        name = self.field_name",
            "        if name and self.lookup_expr != settings.DEFAULT_LOOKUP_EXPR:",
            "            name = LOOKUP_SEP.join([name, self.lookup_expr])",
            "        try:",
            "            return {name: getattr(v, self.field.to_field_name)}",
            "        except (AttributeError, TypeError):",
            "            return {name: v}",
            "",
            "",
            "class TypedMultipleChoiceFilter(MultipleChoiceFilter):",
            "    field_class = forms.TypedMultipleChoiceField",
            "",
            "",
            "class DateFilter(Filter):",
            "    field_class = forms.DateField",
            "",
            "",
            "class DateTimeFilter(Filter):",
            "    field_class = forms.DateTimeField",
            "",
            "",
            "class IsoDateTimeFilter(DateTimeFilter):",
            "    \"\"\"",
            "    Uses IsoDateTimeField to support filtering on ISO 8601 formatted datetimes.",
            "",
            "    For context see:",
            "",
            "    * https://code.djangoproject.com/ticket/23448",
            "    * https://github.com/encode/django-rest-framework/issues/1338",
            "    * https://github.com/carltongibson/django-filter/pull/264",
            "    \"\"\"",
            "    field_class = IsoDateTimeField",
            "",
            "",
            "class TimeFilter(Filter):",
            "    field_class = forms.TimeField",
            "",
            "",
            "class DurationFilter(Filter):",
            "    field_class = forms.DurationField",
            "",
            "",
            "class QuerySetRequestMixin:",
            "    \"\"\"",
            "    Add callable functionality to filters that support the ``queryset``",
            "    argument. If the ``queryset`` is callable, then it **must** accept the",
            "    ``request`` object as a single argument.",
            "",
            "    This is useful for filtering querysets by properties on the ``request``",
            "    object, such as the user.",
            "",
            "    Example::",
            "",
            "        def departments(request):",
            "            company = request.user.company",
            "            return company.department_set.all()",
            "",
            "        class EmployeeFilter(filters.FilterSet):",
            "            department = filters.ModelChoiceFilter(queryset=departments)",
            "            ...",
            "",
            "    The above example restricts the set of departments to those in the logged-in",
            "    user's associated company.",
            "",
            "    \"\"\"",
            "    def __init__(self, *args, **kwargs):",
            "        self.queryset = kwargs.get('queryset')",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def get_request(self):",
            "        try:",
            "            return self.parent.request",
            "        except AttributeError:",
            "            return None",
            "",
            "    def get_queryset(self, request):",
            "        queryset = self.queryset",
            "",
            "        if callable(queryset):",
            "            return queryset(request)",
            "        return queryset",
            "",
            "    @property",
            "    def field(self):",
            "        request = self.get_request()",
            "        queryset = self.get_queryset(request)",
            "",
            "        if queryset is not None:",
            "            self.extra['queryset'] = queryset",
            "",
            "        return super().field",
            "",
            "",
            "class ModelChoiceFilter(QuerySetRequestMixin, ChoiceFilter):",
            "    field_class = ModelChoiceField",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        kwargs.setdefault('empty_label', settings.EMPTY_CHOICE_LABEL)",
            "        super().__init__(*args, **kwargs)",
            "",
            "",
            "class ModelMultipleChoiceFilter(QuerySetRequestMixin, MultipleChoiceFilter):",
            "    field_class = ModelMultipleChoiceField",
            "",
            "",
            "class NumberFilter(Filter):",
            "    field_class = forms.DecimalField",
            "",
            "    def get_max_validator(self):",
            "        \"\"\"",
            "        Return a MaxValueValidator for the field, or None to disable.",
            "        \"\"\"",
            "        return MaxValueValidator(1e50)",
            "",
            "    @property",
            "    def field(self):",
            "        if not hasattr(self, '_field'):",
            "            field = super().field",
            "            max_validator = self.get_max_validator()",
            "            if max_validator:",
            "                field.validators.append(max_validator)",
            "",
            "            self._field = field",
            "        return self._field",
            "",
            "",
            "class NumericRangeFilter(Filter):",
            "    field_class = RangeField",
            "",
            "    def filter(self, qs, value):",
            "        if value:",
            "            if value.start is not None and value.stop is not None:",
            "                value = (value.start, value.stop)",
            "            elif value.start is not None:",
            "                self.lookup_expr = 'startswith'",
            "                value = value.start",
            "            elif value.stop is not None:",
            "                self.lookup_expr = 'endswith'",
            "                value = value.stop",
            "",
            "        return super().filter(qs, value)",
            "",
            "",
            "class RangeFilter(Filter):",
            "    field_class = RangeField",
            "",
            "    def filter(self, qs, value):",
            "        if value:",
            "            if value.start is not None and value.stop is not None:",
            "                self.lookup_expr = 'range'",
            "                value = (value.start, value.stop)",
            "            elif value.start is not None:",
            "                self.lookup_expr = 'gte'",
            "                value = value.start",
            "            elif value.stop is not None:",
            "                self.lookup_expr = 'lte'",
            "                value = value.stop",
            "",
            "        return super().filter(qs, value)",
            "",
            "",
            "def _truncate(dt):",
            "    return dt.date()",
            "",
            "",
            "class DateRangeFilter(ChoiceFilter):",
            "    choices = [",
            "        ('today', _('Today')),",
            "        ('yesterday', _('Yesterday')),",
            "        ('week', _('Past 7 days')),",
            "        ('month', _('This month')),",
            "        ('year', _('This year')),",
            "    ]",
            "",
            "    filters = {",
            "        'today': lambda qs, name: qs.filter(**{",
            "            '%s__year' % name: now().year,",
            "            '%s__month' % name: now().month,",
            "            '%s__day' % name: now().day",
            "        }),",
            "        'yesterday': lambda qs, name: qs.filter(**{",
            "            '%s__year' % name: (now() - timedelta(days=1)).year,",
            "            '%s__month' % name: (now() - timedelta(days=1)).month,",
            "            '%s__day' % name: (now() - timedelta(days=1)).day,",
            "        }),",
            "        'week': lambda qs, name: qs.filter(**{",
            "            '%s__gte' % name: _truncate(now() - timedelta(days=7)),",
            "            '%s__lt' % name: _truncate(now() + timedelta(days=1)),",
            "        }),",
            "        'month': lambda qs, name: qs.filter(**{",
            "            '%s__year' % name: now().year,",
            "            '%s__month' % name: now().month",
            "        }),",
            "        'year': lambda qs, name: qs.filter(**{",
            "            '%s__year' % name: now().year,",
            "        }),",
            "    }",
            "",
            "    def __init__(self, choices=None, filters=None, *args, **kwargs):",
            "        if choices is not None:",
            "            self.choices = choices",
            "        if filters is not None:",
            "            self.filters = filters",
            "",
            "        unique = set([x[0] for x in self.choices]) ^ set(self.filters)",
            "        assert not unique, \\",
            "            \"Keys must be present in both 'choices' and 'filters'. Missing keys: \" \\",
            "            \"'%s'\" % ', '.join(sorted(unique))",
            "",
            "        # TODO: remove assertion in 2.1",
            "        assert not hasattr(self, 'options'), \\",
            "            \"The 'options' attribute has been replaced by 'choices' and 'filters'. \" \\",
            "            \"See: https://django-filter.readthedocs.io/en/master/guide/migration.html\"",
            "",
            "        # null choice not relevant",
            "        kwargs.setdefault('null_label', None)",
            "        super().__init__(choices=self.choices, *args, **kwargs)",
            "",
            "    def filter(self, qs, value):",
            "        if not value:",
            "            return qs",
            "",
            "        assert value in self.filters",
            "",
            "        qs = self.filters[value](qs, self.field_name)",
            "        return qs.distinct() if self.distinct else qs",
            "",
            "",
            "class DateFromToRangeFilter(RangeFilter):",
            "    field_class = DateRangeField",
            "",
            "",
            "class DateTimeFromToRangeFilter(RangeFilter):",
            "    field_class = DateTimeRangeField",
            "",
            "",
            "class IsoDateTimeFromToRangeFilter(RangeFilter):",
            "    field_class = IsoDateTimeRangeField",
            "",
            "",
            "class TimeRangeFilter(RangeFilter):",
            "    field_class = TimeRangeField",
            "",
            "",
            "class AllValuesFilter(ChoiceFilter):",
            "    @property",
            "    def field(self):",
            "        qs = self.model._default_manager.distinct()",
            "        qs = qs.order_by(self.field_name).values_list(self.field_name, flat=True)",
            "        self.extra['choices'] = [(o, o) for o in qs]",
            "        return super().field",
            "",
            "",
            "class AllValuesMultipleFilter(MultipleChoiceFilter):",
            "    @property",
            "    def field(self):",
            "        qs = self.model._default_manager.distinct()",
            "        qs = qs.order_by(self.field_name).values_list(self.field_name, flat=True)",
            "        self.extra['choices'] = [(o, o) for o in qs]",
            "        return super().field",
            "",
            "",
            "class BaseCSVFilter(Filter):",
            "    \"\"\"",
            "    Base class for CSV type filters, such as IN and RANGE.",
            "    \"\"\"",
            "    base_field_class = BaseCSVField",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        kwargs.setdefault('help_text', _('Multiple values may be separated by commas.'))",
            "        super().__init__(*args, **kwargs)",
            "",
            "        class ConcreteCSVField(self.base_field_class, self.field_class):",
            "            pass",
            "        ConcreteCSVField.__name__ = self._field_class_name(",
            "            self.field_class, self.lookup_expr",
            "        )",
            "",
            "        self.field_class = ConcreteCSVField",
            "",
            "    @classmethod",
            "    def _field_class_name(cls, field_class, lookup_expr):",
            "        \"\"\"",
            "        Generate a suitable class name for the concrete field class. This is not",
            "        completely reliable, as not all field class names are of the format",
            "        <Type>Field.",
            "",
            "        ex::",
            "",
            "            BaseCSVFilter._field_class_name(DateTimeField, 'year__in')",
            "",
            "            returns 'DateTimeYearInField'",
            "",
            "        \"\"\"",
            "        # DateTimeField => DateTime",
            "        type_name = field_class.__name__",
            "        if type_name.endswith('Field'):",
            "            type_name = type_name[:-5]",
            "",
            "        # year__in => YearIn",
            "        parts = lookup_expr.split(LOOKUP_SEP)",
            "        expression_name = ''.join(p.capitalize() for p in parts)",
            "",
            "        # DateTimeYearInField",
            "        return str('%s%sField' % (type_name, expression_name))",
            "",
            "",
            "class BaseInFilter(BaseCSVFilter):",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        kwargs.setdefault('lookup_expr', 'in')",
            "        super().__init__(*args, **kwargs)",
            "",
            "",
            "class BaseRangeFilter(BaseCSVFilter):",
            "    base_field_class = BaseRangeField",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        kwargs.setdefault('lookup_expr', 'range')",
            "        super().__init__(*args, **kwargs)",
            "",
            "",
            "class LookupChoiceFilter(Filter):",
            "    \"\"\"",
            "    A combined filter that allows users to select the lookup expression from a dropdown.",
            "",
            "    * ``lookup_choices`` is an optional argument that accepts multiple input",
            "      formats, and is ultimately normlized as the choices used in the lookup",
            "      dropdown. See ``.get_lookup_choices()`` for more information.",
            "",
            "    * ``field_class`` is an optional argument that allows you to set the inner",
            "      form field class used to validate the value. Default: ``forms.CharField``",
            "",
            "    ex::",
            "",
            "        price = django_filters.LookupChoiceFilter(",
            "            field_class=forms.DecimalField,",
            "            lookup_choices=[",
            "                ('exact', 'Equals'),",
            "                ('gt', 'Greater than'),",
            "                ('lt', 'Less than'),",
            "            ]",
            "        )",
            "",
            "    \"\"\"",
            "    field_class = forms.CharField",
            "    outer_class = LookupChoiceField",
            "",
            "    def __init__(self, field_name=None, lookup_choices=None, field_class=None, **kwargs):",
            "        self.empty_label = kwargs.pop('empty_label', settings.EMPTY_CHOICE_LABEL)",
            "",
            "        super(LookupChoiceFilter, self).__init__(field_name=field_name, **kwargs)",
            "",
            "        self.lookup_choices = lookup_choices",
            "        if field_class is not None:",
            "            self.field_class = field_class",
            "",
            "    @classmethod",
            "    def normalize_lookup(cls, lookup):",
            "        \"\"\"",
            "        Normalize the lookup into a tuple of ``(lookup expression, display value)``",
            "",
            "        If the ``lookup`` is already a tuple, the tuple is not altered.",
            "        If the ``lookup`` is a string, a tuple is returned with the lookup",
            "        expression used as the basis for the display value.",
            "",
            "        ex::",
            "",
            "            >>> LookupChoiceFilter.normalize_lookup(('exact', 'Equals'))",
            "            ('exact', 'Equals')",
            "",
            "            >>> LookupChoiceFilter.normalize_lookup('has_key')",
            "            ('has_key', 'Has key')",
            "",
            "        \"\"\"",
            "        if isinstance(lookup, str):",
            "            return (lookup, pretty_name(lookup))",
            "        return (lookup[0], lookup[1])",
            "",
            "    def get_lookup_choices(self):",
            "        \"\"\"",
            "        Get the lookup choices in a format suitable for ``django.forms.ChoiceField``.",
            "        If the filter is initialized with ``lookup_choices``, this value is normalized",
            "        and passed to the underlying ``LookupChoiceField``. If no choices are provided,",
            "        they are generated from the corresponding model field's registered lookups.",
            "        \"\"\"",
            "        lookups = self.lookup_choices",
            "        if lookups is None:",
            "            field = get_model_field(self.model, self.field_name)",
            "            lookups = field.get_lookups()",
            "",
            "        return [self.normalize_lookup(lookup) for lookup in lookups]",
            "",
            "    @property",
            "    def field(self):",
            "        if not hasattr(self, '_field'):",
            "            inner_field = super().field",
            "            lookups = self.get_lookup_choices()",
            "",
            "            self._field = self.outer_class(",
            "                inner_field, lookups,",
            "                label=self.label,",
            "                empty_label=self.empty_label,",
            "                required=self.extra['required'],",
            "            )",
            "",
            "        return self._field",
            "",
            "    def filter(self, qs, lookup):",
            "        if not lookup:",
            "            return super().filter(qs, None)",
            "",
            "        self.lookup_expr = lookup.lookup_expr",
            "        return super().filter(qs, lookup.value)",
            "",
            "",
            "class OrderingFilter(BaseCSVFilter, ChoiceFilter):",
            "    \"\"\"",
            "    Enable queryset ordering. As an extension of ``ChoiceFilter`` it accepts",
            "    two additional arguments that are used to build the ordering choices.",
            "",
            "    * ``fields`` is a mapping of {model field name: parameter name}. The",
            "      parameter names are exposed in the choices and mask/alias the field",
            "      names used in the ``order_by()`` call. Similar to field ``choices``,",
            "      ``fields`` accepts the 'list of two-tuples' syntax that retains order.",
            "      ``fields`` may also just be an iterable of strings. In this case, the",
            "      field names simply double as the exposed parameter names.",
            "",
            "    * ``field_labels`` is an optional argument that allows you to customize",
            "      the display label for the corresponding parameter. It accepts a mapping",
            "      of {field name: human readable label}. Keep in mind that the key is the",
            "      field name, and not the exposed parameter name.",
            "",
            "    Additionally, you can just provide your own ``choices`` if you require",
            "    explicit control over the exposed options. For example, when you might",
            "    want to disable descending sort options.",
            "",
            "    This filter is also CSV-based, and accepts multiple ordering params. The",
            "    default select widget does not enable the use of this, but it is useful",
            "    for APIs.",
            "",
            "    \"\"\"",
            "    descending_fmt = _('%s (descending)')",
            "",
            "    def __init__(self, *args, **kwargs):",
            "        \"\"\"",
            "        ``fields`` may be either a mapping or an iterable.",
            "        ``field_labels`` must be a map of field names to display labels",
            "        \"\"\"",
            "        fields = kwargs.pop('fields', {})",
            "        fields = self.normalize_fields(fields)",
            "        field_labels = kwargs.pop('field_labels', {})",
            "",
            "        self.param_map = {v: k for k, v in fields.items()}",
            "",
            "        if 'choices' not in kwargs:",
            "            kwargs['choices'] = self.build_choices(fields, field_labels)",
            "",
            "        kwargs.setdefault('label', _('Ordering'))",
            "        kwargs.setdefault('help_text', '')",
            "        kwargs.setdefault('null_label', None)",
            "        super().__init__(*args, **kwargs)",
            "",
            "    def get_ordering_value(self, param):",
            "        descending = param.startswith('-')",
            "        param = param[1:] if descending else param",
            "        field_name = self.param_map.get(param, param)",
            "",
            "        return \"-%s\" % field_name if descending else field_name",
            "",
            "    def filter(self, qs, value):",
            "        if value in EMPTY_VALUES:",
            "            return qs",
            "",
            "        ordering = [self.get_ordering_value(param) for param in value]",
            "        return qs.order_by(*ordering)",
            "",
            "    @classmethod",
            "    def normalize_fields(cls, fields):",
            "        \"\"\"",
            "        Normalize the fields into an ordered map of {field name: param name}",
            "        \"\"\"",
            "        # fields is a mapping, copy into new OrderedDict",
            "        if isinstance(fields, dict):",
            "            return OrderedDict(fields)",
            "",
            "        # convert iterable of values => iterable of pairs (field name, param name)",
            "        assert is_iterable(fields), \\",
            "            \"'fields' must be an iterable (e.g., a list, tuple, or mapping).\"",
            "",
            "        # fields is an iterable of field names",
            "        assert all(isinstance(field, str) or",
            "                   is_iterable(field) and len(field) == 2  # may need to be wrapped in parens",
            "                   for field in fields), \\",
            "            \"'fields' must contain strings or (field name, param name) pairs.\"",
            "",
            "        return OrderedDict([",
            "            (f, f) if isinstance(f, str) else f for f in fields",
            "        ])",
            "",
            "    def build_choices(self, fields, labels):",
            "        ascending = [",
            "            (param, labels.get(field, _(pretty_name(param))))",
            "            for field, param in fields.items()",
            "        ]",
            "        descending = [",
            "            ('-%s' % param, labels.get('-%s' % param, self.descending_fmt % label))",
            "            for param, label in ascending",
            "        ]",
            "",
            "        # interleave the ascending and descending choices",
            "        return [val for pair in zip(ascending, descending) for val in pair]",
            "",
            "",
            "class FilterMethod:",
            "    \"\"\"",
            "    This helper is used to override Filter.filter() when a 'method' argument",
            "    is passed. It proxies the call to the actual method on the filter's parent.",
            "    \"\"\"",
            "    def __init__(self, filter_instance):",
            "        self.f = filter_instance",
            "",
            "    def __call__(self, qs, value):",
            "        if value in EMPTY_VALUES:",
            "            return qs",
            "",
            "        return self.method(qs, self.f.field_name, value)",
            "",
            "    @property",
            "    def method(self):",
            "        \"\"\"",
            "        Resolve the method on the parent filterset.",
            "        \"\"\"",
            "        instance = self.f",
            "",
            "        # noop if 'method' is a function",
            "        if callable(instance.method):",
            "            return instance.method",
            "",
            "        # otherwise, method is the name of a method on the parent FilterSet.",
            "        assert hasattr(instance, 'parent'), \\",
            "            \"Filter '%s' must have a parent FilterSet to find '.%s()'\" %  \\",
            "            (instance.field_name, instance.method)",
            "",
            "        parent = instance.parent",
            "        method = getattr(parent, instance.method, None)",
            "",
            "        assert callable(method), \\",
            "            \"Expected parent FilterSet '%s.%s' to have a '.%s()' method.\" % \\",
            "            (parent.__class__.__module__, parent.__class__.__name__, instance.method)",
            "",
            "        return method"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": []
    },
    "docs/conf.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " import sys, os"
            },
            "2": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+from django_filters import __version__"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 17,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " # If extensions (or modules to document with autodoc) are in another directory,"
            },
            "6": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " # add these directories to sys.path here. If the directory is relative to the"
            },
            "7": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " # documentation root, use os.path.abspath to make it absolute, like shown here."
            },
            "8": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 43,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 44,
                "PatchRowcode": " # General information about the project."
            },
            "10": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 45,
                "PatchRowcode": " project = u'django-filter'"
            },
            "11": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-copyright = u'2019, Alex Gaynor, Carlton Gibson and others.'"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 46,
                "PatchRowcode": "+copyright = u'2020, Alex Gaynor, Carlton Gibson and others.'"
            },
            "13": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 47,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 48,
                "PatchRowcode": " # The version info for the project you're documenting, acts as replacement for"
            },
            "15": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 49,
                "PatchRowcode": " # |version| and |release|, also used in various other places throughout the"
            },
            "16": {
                "beforePatchRowNumber": 48,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " # built documents."
            },
            "17": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 51,
                "PatchRowcode": " #"
            },
            "18": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 52,
                "PatchRowcode": " # The short X.Y version."
            },
            "19": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-version = '2.3'"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+version = __version__"
            },
            "21": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 54,
                "PatchRowcode": " # The full version, including alpha/beta/rc tags."
            },
            "22": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-release = '2.3.0'"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+release = __version__"
            },
            "24": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 56,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 55,
                "afterPatchRowNumber": 57,
                "PatchRowcode": " # The language for content autogenerated by Sphinx. Refer to documentation"
            },
            "26": {
                "beforePatchRowNumber": 56,
                "afterPatchRowNumber": 58,
                "PatchRowcode": " # for a list of supported languages."
            }
        },
        "frontPatchFile": [
            "# -*- coding: utf-8 -*-",
            "#",
            "# django-filter documentation build configuration file, created by",
            "# sphinx-quickstart on Mon Sep 17 11:25:20 2012.",
            "#",
            "# This file is execfile()d with the current directory set to its containing dir.",
            "#",
            "# Note that not all possible configuration values are present in this",
            "# autogenerated file.",
            "#",
            "# All configuration values have a default; values that are commented out",
            "# serve to show the default.",
            "",
            "import sys, os",
            "",
            "# If extensions (or modules to document with autodoc) are in another directory,",
            "# add these directories to sys.path here. If the directory is relative to the",
            "# documentation root, use os.path.abspath to make it absolute, like shown here.",
            "#sys.path.insert(0, os.path.abspath('.'))",
            "",
            "# -- General configuration -----------------------------------------------------",
            "",
            "# If your documentation needs a minimal Sphinx version, state it here.",
            "#needs_sphinx = '1.0'",
            "",
            "# Add any Sphinx extension module names here, as strings. They can be extensions",
            "# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.",
            "extensions = []",
            "",
            "# Add any paths that contain templates here, relative to this directory.",
            "templates_path = ['_templates']",
            "",
            "# The suffix of source filenames.",
            "source_suffix = '.txt'",
            "",
            "# The encoding of source files.",
            "#source_encoding = 'utf-8-sig'",
            "",
            "# The master toctree document.",
            "master_doc = 'index'",
            "",
            "# General information about the project.",
            "project = u'django-filter'",
            "copyright = u'2019, Alex Gaynor, Carlton Gibson and others.'",
            "",
            "# The version info for the project you're documenting, acts as replacement for",
            "# |version| and |release|, also used in various other places throughout the",
            "# built documents.",
            "#",
            "# The short X.Y version.",
            "version = '2.3'",
            "# The full version, including alpha/beta/rc tags.",
            "release = '2.3.0'",
            "",
            "# The language for content autogenerated by Sphinx. Refer to documentation",
            "# for a list of supported languages.",
            "#language = None",
            "",
            "# There are two options for replacing |today|: either, you set today to some",
            "# non-false value, then it is used:",
            "#today = ''",
            "# Else, today_fmt is used as the format for a strftime call.",
            "#today_fmt = '%B %d, %Y'",
            "",
            "# List of patterns, relative to source directory, that match files and",
            "# directories to ignore when looking for source files.",
            "exclude_patterns = ['_build']",
            "",
            "# The reST default role (used for this markup: `text`) to use for all documents.",
            "#default_role = None",
            "",
            "# If true, '()' will be appended to :func: etc. cross-reference text.",
            "#add_function_parentheses = True",
            "",
            "# If true, the current module name will be prepended to all description",
            "# unit titles (such as .. function::).",
            "#add_module_names = True",
            "",
            "# If true, sectionauthor and moduleauthor directives will be shown in the",
            "# output. They are ignored by default.",
            "#show_authors = False",
            "",
            "# The name of the Pygments (syntax highlighting) style to use.",
            "pygments_style = 'sphinx'",
            "",
            "# A list of ignored prefixes for module index sorting.",
            "#modindex_common_prefix = []",
            "",
            "",
            "# -- Options for HTML output ---------------------------------------------------",
            "",
            "# The theme to use for HTML and HTML Help pages.  See the documentation for",
            "# a list of builtin themes.",
            "html_theme = 'default'",
            "",
            "# Theme options are theme-specific and customize the look and feel of a theme",
            "# further.  For a list of options available for each theme, see the",
            "# documentation.",
            "#html_theme_options = {}",
            "",
            "# Add any paths that contain custom themes here, relative to this directory.",
            "#html_theme_path = []",
            "",
            "# The name for this set of Sphinx documents.  If None, it defaults to",
            "# \"<project> v<release> documentation\".",
            "#html_title = None",
            "",
            "# A shorter title for the navigation bar.  Default is the same as html_title.",
            "#html_short_title = None",
            "",
            "# The name of an image file (relative to this directory) to place at the top",
            "# of the sidebar.",
            "#html_logo = None",
            "",
            "# The name of an image file (within the static path) to use as favicon of the",
            "# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32",
            "# pixels large.",
            "#html_favicon = None",
            "",
            "# Add any paths that contain custom static files (such as style sheets) here,",
            "# relative to this directory. They are copied after the builtin static files,",
            "# so a file named \"default.css\" will overwrite the builtin \"default.css\".",
            "#html_static_path = ['_static']",
            "",
            "# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,",
            "# using the given strftime format.",
            "#html_last_updated_fmt = '%b %d, %Y'",
            "",
            "# If true, SmartyPants will be used to convert quotes and dashes to",
            "# typographically correct entities.",
            "#html_use_smartypants = True",
            "",
            "# Custom sidebar templates, maps document names to template names.",
            "#html_sidebars = {}",
            "",
            "# Additional templates that should be rendered to pages, maps page names to",
            "# template names.",
            "#html_additional_pages = {}",
            "",
            "# If false, no module index is generated.",
            "#html_domain_indices = True",
            "",
            "# If false, no index is generated.",
            "#html_use_index = True",
            "",
            "# If true, the index is split into individual pages for each letter.",
            "#html_split_index = False",
            "",
            "# If true, links to the reST sources are added to the pages.",
            "#html_show_sourcelink = True",
            "",
            "# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.",
            "#html_show_sphinx = True",
            "",
            "# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.",
            "#html_show_copyright = True",
            "",
            "# If true, an OpenSearch description file will be output, and all pages will",
            "# contain a <link> tag referring to it.  The value of this option must be the",
            "# base URL from which the finished HTML is served.",
            "#html_use_opensearch = ''",
            "",
            "# This is the file name suffix for HTML files (e.g. \".xhtml\").",
            "#html_file_suffix = None",
            "",
            "# Output file base name for HTML help builder.",
            "htmlhelp_basename = 'django-filterdoc'",
            "",
            "",
            "# -- Options for LaTeX output --------------------------------------------------",
            "",
            "latex_elements = {",
            "# The paper size ('letterpaper' or 'a4paper').",
            "#'papersize': 'letterpaper',",
            "",
            "# The font size ('10pt', '11pt' or '12pt').",
            "#'pointsize': '10pt',",
            "",
            "# Additional stuff for the LaTeX preamble.",
            "#'preamble': '',",
            "}",
            "",
            "# Grouping the document tree into LaTeX files. List of tuples",
            "# (source start file, target name, title, author, documentclass [howto/manual]).",
            "latex_documents = [",
            "  ('index', 'django-filter.tex', u'django-filter Documentation',",
            "   u'Alex Gaynor and others.', 'manual'),",
            "]",
            "",
            "# The name of an image file (relative to this directory) to place at the top of",
            "# the title page.",
            "#latex_logo = None",
            "",
            "# For \"manual\" documents, if this is true, then toplevel headings are parts,",
            "# not chapters.",
            "#latex_use_parts = False",
            "",
            "# If true, show page references after internal links.",
            "#latex_show_pagerefs = False",
            "",
            "# If true, show URL addresses after external links.",
            "#latex_show_urls = False",
            "",
            "# Documents to append as an appendix to all manuals.",
            "#latex_appendices = []",
            "",
            "# If false, no module index is generated.",
            "#latex_domain_indices = True",
            "",
            "",
            "# -- Options for manual page output --------------------------------------------",
            "",
            "# One entry per manual page. List of tuples",
            "# (source start file, name, description, authors, manual section).",
            "man_pages = [",
            "    ('index', 'django-filter', u'django-filter Documentation',",
            "     [u'Alex Gaynor and others.'], 1)",
            "]",
            "",
            "# If true, show URL addresses after external links.",
            "#man_show_urls = False",
            "",
            "",
            "# -- Options for Texinfo output ------------------------------------------------",
            "",
            "# Grouping the document tree into Texinfo files. List of tuples",
            "# (source start file, target name, title, author,",
            "#  dir menu entry, description, category)",
            "texinfo_documents = [",
            "  ('index', 'django-filter', u'django-filter Documentation',",
            "   u'Alex Gaynor and others.', 'django-filter', 'One line description of project.',",
            "   'Miscellaneous'),",
            "]",
            "",
            "# Documents to append as an appendix to all manuals.",
            "#texinfo_appendices = []",
            "",
            "# If false, no module index is generated.",
            "#texinfo_domain_indices = True",
            "",
            "# How to display URL addresses: 'footnote', 'no', or 'inline'.",
            "#texinfo_show_urls = 'footnote'",
            "",
            "",
            "# see:",
            "# https://github.com/snide/sphinx_rtd_theme#using-this-theme-locally-then-building-on-read-the-docs",
            "on_rtd = os.environ.get('READTHEDOCS', None) == 'True'",
            "",
            "# only import and set the theme if we're building docs locally",
            "if not on_rtd:",
            "    import sphinx_rtd_theme",
            "",
            "    html_theme = 'sphinx_rtd_theme'",
            "    html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]"
        ],
        "afterPatchFile": [
            "# -*- coding: utf-8 -*-",
            "#",
            "# django-filter documentation build configuration file, created by",
            "# sphinx-quickstart on Mon Sep 17 11:25:20 2012.",
            "#",
            "# This file is execfile()d with the current directory set to its containing dir.",
            "#",
            "# Note that not all possible configuration values are present in this",
            "# autogenerated file.",
            "#",
            "# All configuration values have a default; values that are commented out",
            "# serve to show the default.",
            "",
            "import sys, os",
            "",
            "from django_filters import __version__",
            "",
            "# If extensions (or modules to document with autodoc) are in another directory,",
            "# add these directories to sys.path here. If the directory is relative to the",
            "# documentation root, use os.path.abspath to make it absolute, like shown here.",
            "#sys.path.insert(0, os.path.abspath('.'))",
            "",
            "# -- General configuration -----------------------------------------------------",
            "",
            "# If your documentation needs a minimal Sphinx version, state it here.",
            "#needs_sphinx = '1.0'",
            "",
            "# Add any Sphinx extension module names here, as strings. They can be extensions",
            "# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.",
            "extensions = []",
            "",
            "# Add any paths that contain templates here, relative to this directory.",
            "templates_path = ['_templates']",
            "",
            "# The suffix of source filenames.",
            "source_suffix = '.txt'",
            "",
            "# The encoding of source files.",
            "#source_encoding = 'utf-8-sig'",
            "",
            "# The master toctree document.",
            "master_doc = 'index'",
            "",
            "# General information about the project.",
            "project = u'django-filter'",
            "copyright = u'2020, Alex Gaynor, Carlton Gibson and others.'",
            "",
            "# The version info for the project you're documenting, acts as replacement for",
            "# |version| and |release|, also used in various other places throughout the",
            "# built documents.",
            "#",
            "# The short X.Y version.",
            "version = __version__",
            "# The full version, including alpha/beta/rc tags.",
            "release = __version__",
            "",
            "# The language for content autogenerated by Sphinx. Refer to documentation",
            "# for a list of supported languages.",
            "#language = None",
            "",
            "# There are two options for replacing |today|: either, you set today to some",
            "# non-false value, then it is used:",
            "#today = ''",
            "# Else, today_fmt is used as the format for a strftime call.",
            "#today_fmt = '%B %d, %Y'",
            "",
            "# List of patterns, relative to source directory, that match files and",
            "# directories to ignore when looking for source files.",
            "exclude_patterns = ['_build']",
            "",
            "# The reST default role (used for this markup: `text`) to use for all documents.",
            "#default_role = None",
            "",
            "# If true, '()' will be appended to :func: etc. cross-reference text.",
            "#add_function_parentheses = True",
            "",
            "# If true, the current module name will be prepended to all description",
            "# unit titles (such as .. function::).",
            "#add_module_names = True",
            "",
            "# If true, sectionauthor and moduleauthor directives will be shown in the",
            "# output. They are ignored by default.",
            "#show_authors = False",
            "",
            "# The name of the Pygments (syntax highlighting) style to use.",
            "pygments_style = 'sphinx'",
            "",
            "# A list of ignored prefixes for module index sorting.",
            "#modindex_common_prefix = []",
            "",
            "",
            "# -- Options for HTML output ---------------------------------------------------",
            "",
            "# The theme to use for HTML and HTML Help pages.  See the documentation for",
            "# a list of builtin themes.",
            "html_theme = 'default'",
            "",
            "# Theme options are theme-specific and customize the look and feel of a theme",
            "# further.  For a list of options available for each theme, see the",
            "# documentation.",
            "#html_theme_options = {}",
            "",
            "# Add any paths that contain custom themes here, relative to this directory.",
            "#html_theme_path = []",
            "",
            "# The name for this set of Sphinx documents.  If None, it defaults to",
            "# \"<project> v<release> documentation\".",
            "#html_title = None",
            "",
            "# A shorter title for the navigation bar.  Default is the same as html_title.",
            "#html_short_title = None",
            "",
            "# The name of an image file (relative to this directory) to place at the top",
            "# of the sidebar.",
            "#html_logo = None",
            "",
            "# The name of an image file (within the static path) to use as favicon of the",
            "# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32",
            "# pixels large.",
            "#html_favicon = None",
            "",
            "# Add any paths that contain custom static files (such as style sheets) here,",
            "# relative to this directory. They are copied after the builtin static files,",
            "# so a file named \"default.css\" will overwrite the builtin \"default.css\".",
            "#html_static_path = ['_static']",
            "",
            "# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,",
            "# using the given strftime format.",
            "#html_last_updated_fmt = '%b %d, %Y'",
            "",
            "# If true, SmartyPants will be used to convert quotes and dashes to",
            "# typographically correct entities.",
            "#html_use_smartypants = True",
            "",
            "# Custom sidebar templates, maps document names to template names.",
            "#html_sidebars = {}",
            "",
            "# Additional templates that should be rendered to pages, maps page names to",
            "# template names.",
            "#html_additional_pages = {}",
            "",
            "# If false, no module index is generated.",
            "#html_domain_indices = True",
            "",
            "# If false, no index is generated.",
            "#html_use_index = True",
            "",
            "# If true, the index is split into individual pages for each letter.",
            "#html_split_index = False",
            "",
            "# If true, links to the reST sources are added to the pages.",
            "#html_show_sourcelink = True",
            "",
            "# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.",
            "#html_show_sphinx = True",
            "",
            "# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.",
            "#html_show_copyright = True",
            "",
            "# If true, an OpenSearch description file will be output, and all pages will",
            "# contain a <link> tag referring to it.  The value of this option must be the",
            "# base URL from which the finished HTML is served.",
            "#html_use_opensearch = ''",
            "",
            "# This is the file name suffix for HTML files (e.g. \".xhtml\").",
            "#html_file_suffix = None",
            "",
            "# Output file base name for HTML help builder.",
            "htmlhelp_basename = 'django-filterdoc'",
            "",
            "",
            "# -- Options for LaTeX output --------------------------------------------------",
            "",
            "latex_elements = {",
            "# The paper size ('letterpaper' or 'a4paper').",
            "#'papersize': 'letterpaper',",
            "",
            "# The font size ('10pt', '11pt' or '12pt').",
            "#'pointsize': '10pt',",
            "",
            "# Additional stuff for the LaTeX preamble.",
            "#'preamble': '',",
            "}",
            "",
            "# Grouping the document tree into LaTeX files. List of tuples",
            "# (source start file, target name, title, author, documentclass [howto/manual]).",
            "latex_documents = [",
            "  ('index', 'django-filter.tex', u'django-filter Documentation',",
            "   u'Alex Gaynor and others.', 'manual'),",
            "]",
            "",
            "# The name of an image file (relative to this directory) to place at the top of",
            "# the title page.",
            "#latex_logo = None",
            "",
            "# For \"manual\" documents, if this is true, then toplevel headings are parts,",
            "# not chapters.",
            "#latex_use_parts = False",
            "",
            "# If true, show page references after internal links.",
            "#latex_show_pagerefs = False",
            "",
            "# If true, show URL addresses after external links.",
            "#latex_show_urls = False",
            "",
            "# Documents to append as an appendix to all manuals.",
            "#latex_appendices = []",
            "",
            "# If false, no module index is generated.",
            "#latex_domain_indices = True",
            "",
            "",
            "# -- Options for manual page output --------------------------------------------",
            "",
            "# One entry per manual page. List of tuples",
            "# (source start file, name, description, authors, manual section).",
            "man_pages = [",
            "    ('index', 'django-filter', u'django-filter Documentation',",
            "     [u'Alex Gaynor and others.'], 1)",
            "]",
            "",
            "# If true, show URL addresses after external links.",
            "#man_show_urls = False",
            "",
            "",
            "# -- Options for Texinfo output ------------------------------------------------",
            "",
            "# Grouping the document tree into Texinfo files. List of tuples",
            "# (source start file, target name, title, author,",
            "#  dir menu entry, description, category)",
            "texinfo_documents = [",
            "  ('index', 'django-filter', u'django-filter Documentation',",
            "   u'Alex Gaynor and others.', 'django-filter', 'One line description of project.',",
            "   'Miscellaneous'),",
            "]",
            "",
            "# Documents to append as an appendix to all manuals.",
            "#texinfo_appendices = []",
            "",
            "# If false, no module index is generated.",
            "#texinfo_domain_indices = True",
            "",
            "# How to display URL addresses: 'footnote', 'no', or 'inline'.",
            "#texinfo_show_urls = 'footnote'",
            "",
            "",
            "# see:",
            "# https://github.com/snide/sphinx_rtd_theme#using-this-theme-locally-then-building-on-read-the-docs",
            "on_rtd = os.environ.get('READTHEDOCS', None) == 'True'",
            "",
            "# only import and set the theme if we're building docs locally",
            "if not on_rtd:",
            "    import sphinx_rtd_theme",
            "",
            "    html_theme = 'sphinx_rtd_theme'",
            "    html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "44": [
                "copyright"
            ],
            "51": [
                "version"
            ],
            "53": [
                "release"
            ]
        },
        "addLocation": []
    },
    "setup.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 2,
                "afterPatchRowNumber": 2,
                "PatchRowcode": " import sys"
            },
            "1": {
                "beforePatchRowNumber": 3,
                "afterPatchRowNumber": 3,
                "PatchRowcode": " from setuptools import setup, find_packages"
            },
            "2": {
                "beforePatchRowNumber": 4,
                "afterPatchRowNumber": 4,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 5,
                "PatchRowcode": "+# FIXME: Main module requires django to be present, so cannot run setup.py in"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 6,
                "PatchRowcode": "+# clean environment."
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 7,
                "PatchRowcode": "+# from django_filters import __version__"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 8,
                "PatchRowcode": "+__version__ = '2.4.0'"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 9,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": 5,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " f = open('README.rst')"
            },
            "9": {
                "beforePatchRowNumber": 6,
                "afterPatchRowNumber": 11,
                "PatchRowcode": " readme = f.read()"
            },
            "10": {
                "beforePatchRowNumber": 7,
                "afterPatchRowNumber": 12,
                "PatchRowcode": " f.close()"
            },
            "11": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "12": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-version = '2.3.0'"
            },
            "13": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "14": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " if sys.argv[-1] == 'publish':"
            },
            "15": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 15,
                "PatchRowcode": "     if os.system(\"pip freeze | grep wheel\"):"
            },
            "16": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 16,
                "PatchRowcode": "         print(\"wheel not installed.\\nUse `pip install wheel`.\\nExiting.\")"
            },
            "17": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 21,
                "PatchRowcode": "     os.system(\"python setup.py sdist bdist_wheel\")"
            },
            "18": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 22,
                "PatchRowcode": "     os.system(\"twine upload dist/*\")"
            },
            "19": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "     print(\"You probably want to also tag the version now:\")"
            },
            "20": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    print(\"  git tag -a %s -m 'version %s'\" % (version, version))"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 24,
                "PatchRowcode": "+    print(\"  git tag -a %s -m 'version %s'\" % (__version__, __version__))"
            },
            "22": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "     print(\"  git push --tags\")"
            },
            "23": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "     sys.exit()"
            },
            "24": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 27,
                "PatchRowcode": " "
            },
            "25": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " setup("
            },
            "26": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "     name='django-filter',"
            },
            "27": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    version=version,"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 30,
                "PatchRowcode": "+    version=__version__,"
            },
            "29": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "     description=('Django-filter is a reusable Django application for allowing'"
            },
            "30": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 32,
                "PatchRowcode": "                  ' users to filter querysets dynamically.'),"
            },
            "31": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 33,
                "PatchRowcode": "     long_description=readme,"
            }
        },
        "frontPatchFile": [
            "import os",
            "import sys",
            "from setuptools import setup, find_packages",
            "",
            "f = open('README.rst')",
            "readme = f.read()",
            "f.close()",
            "",
            "version = '2.3.0'",
            "",
            "if sys.argv[-1] == 'publish':",
            "    if os.system(\"pip freeze | grep wheel\"):",
            "        print(\"wheel not installed.\\nUse `pip install wheel`.\\nExiting.\")",
            "        sys.exit()",
            "    if os.system(\"pip freeze | grep twine\"):",
            "        print(\"twine not installed.\\nUse `pip install twine`.\\nExiting.\")",
            "        sys.exit()",
            "    os.system(\"python setup.py sdist bdist_wheel\")",
            "    os.system(\"twine upload dist/*\")",
            "    print(\"You probably want to also tag the version now:\")",
            "    print(\"  git tag -a %s -m 'version %s'\" % (version, version))",
            "    print(\"  git push --tags\")",
            "    sys.exit()",
            "",
            "setup(",
            "    name='django-filter',",
            "    version=version,",
            "    description=('Django-filter is a reusable Django application for allowing'",
            "                 ' users to filter querysets dynamically.'),",
            "    long_description=readme,",
            "    author='Alex Gaynor',",
            "    author_email='alex.gaynor@gmail.com',",
            "    maintainer='Carlton Gibson',",
            "    maintainer_email='carlton.gibson@noumenal.es',",
            "    url='https://github.com/carltongibson/django-filter/tree/master',",
            "    packages=find_packages(exclude=['tests*']),",
            "    include_package_data=True,",
            "    license='BSD',",
            "    classifiers=[",
            "        'Development Status :: 5 - Production/Stable',",
            "        'Environment :: Web Environment',",
            "        'Intended Audience :: Developers',",
            "        'License :: OSI Approved :: BSD License',",
            "        'Operating System :: OS Independent',",
            "        'Framework :: Django',",
            "        'Framework :: Django :: 2.2',",
            "        'Framework :: Django :: 3.0',",
            "        'Framework :: Django :: 3.1',",
            "        'Programming Language :: Python',",
            "        'Programming Language :: Python :: 3',",
            "        'Programming Language :: Python :: 3.5',",
            "        'Programming Language :: Python :: 3.6',",
            "        'Programming Language :: Python :: 3.7',",
            "        'Programming Language :: Python :: 3.8',",
            "        'Programming Language :: Python :: 3.9',",
            "        'Framework :: Django',",
            "    ],",
            "    zip_safe=False,",
            "    python_requires='>=3.5',",
            "    install_requires=[",
            "        'Django>=2.2',",
            "    ],",
            ")"
        ],
        "afterPatchFile": [
            "import os",
            "import sys",
            "from setuptools import setup, find_packages",
            "",
            "# FIXME: Main module requires django to be present, so cannot run setup.py in",
            "# clean environment.",
            "# from django_filters import __version__",
            "__version__ = '2.4.0'",
            "",
            "f = open('README.rst')",
            "readme = f.read()",
            "f.close()",
            "",
            "if sys.argv[-1] == 'publish':",
            "    if os.system(\"pip freeze | grep wheel\"):",
            "        print(\"wheel not installed.\\nUse `pip install wheel`.\\nExiting.\")",
            "        sys.exit()",
            "    if os.system(\"pip freeze | grep twine\"):",
            "        print(\"twine not installed.\\nUse `pip install twine`.\\nExiting.\")",
            "        sys.exit()",
            "    os.system(\"python setup.py sdist bdist_wheel\")",
            "    os.system(\"twine upload dist/*\")",
            "    print(\"You probably want to also tag the version now:\")",
            "    print(\"  git tag -a %s -m 'version %s'\" % (__version__, __version__))",
            "    print(\"  git push --tags\")",
            "    sys.exit()",
            "",
            "setup(",
            "    name='django-filter',",
            "    version=__version__,",
            "    description=('Django-filter is a reusable Django application for allowing'",
            "                 ' users to filter querysets dynamically.'),",
            "    long_description=readme,",
            "    author='Alex Gaynor',",
            "    author_email='alex.gaynor@gmail.com',",
            "    maintainer='Carlton Gibson',",
            "    maintainer_email='carlton.gibson@noumenal.es',",
            "    url='https://github.com/carltongibson/django-filter/tree/master',",
            "    packages=find_packages(exclude=['tests*']),",
            "    include_package_data=True,",
            "    license='BSD',",
            "    classifiers=[",
            "        'Development Status :: 5 - Production/Stable',",
            "        'Environment :: Web Environment',",
            "        'Intended Audience :: Developers',",
            "        'License :: OSI Approved :: BSD License',",
            "        'Operating System :: OS Independent',",
            "        'Framework :: Django',",
            "        'Framework :: Django :: 2.2',",
            "        'Framework :: Django :: 3.0',",
            "        'Framework :: Django :: 3.1',",
            "        'Programming Language :: Python',",
            "        'Programming Language :: Python :: 3',",
            "        'Programming Language :: Python :: 3.5',",
            "        'Programming Language :: Python :: 3.6',",
            "        'Programming Language :: Python :: 3.7',",
            "        'Programming Language :: Python :: 3.8',",
            "        'Programming Language :: Python :: 3.9',",
            "        'Framework :: Django',",
            "    ],",
            "    zip_safe=False,",
            "    python_requires='>=3.5',",
            "    install_requires=[",
            "        'Django>=2.2',",
            "    ],",
            ")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "9": [
                "version"
            ],
            "10": [],
            "21": [],
            "27": []
        },
        "addLocation": []
    }
}