{
    "remarshal.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " import yaml.parser"
            },
            "1": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": " import yaml.scanner"
            },
            "2": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "3": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-__version__ = \"0.17.0\""
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 27,
                "PatchRowcode": "+__version__ = \"0.17.1\""
            },
            "5": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 28,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 29,
                "PatchRowcode": "+DEFAULT_MAX_NODES = 100000"
            },
            "7": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " FORMATS = [\"cbor\", \"json\", \"msgpack\", \"toml\", \"yaml\"]"
            },
            "8": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 31,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 32,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 143,
                "PatchRowcode": "             ),"
            },
            "11": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "         )"
            },
            "12": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 145,
                "PatchRowcode": " "
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 146,
                "PatchRowcode": "+    parser.add_argument("
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+        \"--max-nodes\","
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 148,
                "PatchRowcode": "+        dest=\"max_nodes\","
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 149,
                "PatchRowcode": "+        metavar=\"n\","
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 150,
                "PatchRowcode": "+        type=int,"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 151,
                "PatchRowcode": "+        default=DEFAULT_MAX_NODES,"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 152,
                "PatchRowcode": "+        help=\"maximum number of nodes in input data (default %(default)s)\","
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 153,
                "PatchRowcode": "+    )"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+"
            },
            "22": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "     output_group = parser.add_mutually_exclusive_group()"
            },
            "23": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "     output_group.add_argument(\"output\", nargs=\"?\", default=\"-\", help=\"output file\")"
            },
            "24": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "     output_group.add_argument("
            },
            "25": {
                "beforePatchRowNumber": 431,
                "afterPatchRowNumber": 441,
                "PatchRowcode": "     return decoder[input_format](input_data)"
            },
            "26": {
                "beforePatchRowNumber": 432,
                "afterPatchRowNumber": 442,
                "PatchRowcode": " "
            },
            "27": {
                "beforePatchRowNumber": 433,
                "afterPatchRowNumber": 443,
                "PatchRowcode": " "
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 444,
                "PatchRowcode": "+class TooManyNodesError(BaseException):"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 445,
                "PatchRowcode": "+    def __init__(self, msg: str = \"document has too many nodes\", *args, **kwargs):"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 446,
                "PatchRowcode": "+        super().__init__(msg, *args, **kwargs)"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 447,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 448,
                "PatchRowcode": "+"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 449,
                "PatchRowcode": "+def validate_node_count(doc: Document, *, limit: int) -> None:"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 450,
                "PatchRowcode": "+    count = 0"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 451,
                "PatchRowcode": "+"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 452,
                "PatchRowcode": "+    def count_callback(x: Any) -> Any:"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 453,
                "PatchRowcode": "+        nonlocal count"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 454,
                "PatchRowcode": "+        nonlocal limit"
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 455,
                "PatchRowcode": "+"
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 456,
                "PatchRowcode": "+        count += 1"
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 457,
                "PatchRowcode": "+        if count > limit:"
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 458,
                "PatchRowcode": "+            raise TooManyNodesError"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 459,
                "PatchRowcode": "+"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 460,
                "PatchRowcode": "+        return x"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 461,
                "PatchRowcode": "+"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 462,
                "PatchRowcode": "+    traverse(doc, instance_callbacks={(object, count_callback)})"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 463,
                "PatchRowcode": "+"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 464,
                "PatchRowcode": "+"
            },
            "49": {
                "beforePatchRowNumber": 434,
                "afterPatchRowNumber": 465,
                "PatchRowcode": " def reject_special_keys(key: Any) -> Any:"
            },
            "50": {
                "beforePatchRowNumber": 435,
                "afterPatchRowNumber": 466,
                "PatchRowcode": "     if isinstance(key, bool):"
            },
            "51": {
                "beforePatchRowNumber": 436,
                "afterPatchRowNumber": 467,
                "PatchRowcode": "         msg = \"boolean key\""
            },
            "52": {
                "beforePatchRowNumber": 627,
                "afterPatchRowNumber": 658,
                "PatchRowcode": "         args.input_format,"
            },
            "53": {
                "beforePatchRowNumber": 628,
                "afterPatchRowNumber": 659,
                "PatchRowcode": "         args.output_format,"
            },
            "54": {
                "beforePatchRowNumber": 629,
                "afterPatchRowNumber": 660,
                "PatchRowcode": "         json_indent=args.json_indent,"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 661,
                "PatchRowcode": "+        max_nodes=args.max_nodes,"
            },
            "56": {
                "beforePatchRowNumber": 630,
                "afterPatchRowNumber": 662,
                "PatchRowcode": "         ordered=args.ordered,"
            },
            "57": {
                "beforePatchRowNumber": 631,
                "afterPatchRowNumber": 663,
                "PatchRowcode": "         stringify=args.stringify,"
            },
            "58": {
                "beforePatchRowNumber": 632,
                "afterPatchRowNumber": 664,
                "PatchRowcode": "         unwrap=args.unwrap,"
            },
            "59": {
                "beforePatchRowNumber": 642,
                "afterPatchRowNumber": 674,
                "PatchRowcode": "     output_format: str,"
            },
            "60": {
                "beforePatchRowNumber": 643,
                "afterPatchRowNumber": 675,
                "PatchRowcode": "     *,"
            },
            "61": {
                "beforePatchRowNumber": 644,
                "afterPatchRowNumber": 676,
                "PatchRowcode": "     json_indent: Union[int, None] = None,"
            },
            "62": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 677,
                "PatchRowcode": "+    max_nodes: int = DEFAULT_MAX_NODES,"
            },
            "63": {
                "beforePatchRowNumber": 645,
                "afterPatchRowNumber": 678,
                "PatchRowcode": "     ordered: bool = True,"
            },
            "64": {
                "beforePatchRowNumber": 646,
                "afterPatchRowNumber": 679,
                "PatchRowcode": "     stringify: bool = False,"
            },
            "65": {
                "beforePatchRowNumber": 647,
                "afterPatchRowNumber": 680,
                "PatchRowcode": "     transform: Union[Callable[[Document], Document], None] = None,"
            },
            "66": {
                "beforePatchRowNumber": 663,
                "afterPatchRowNumber": 696,
                "PatchRowcode": " "
            },
            "67": {
                "beforePatchRowNumber": 664,
                "afterPatchRowNumber": 697,
                "PatchRowcode": "         parsed = decode(input_format, input_data)"
            },
            "68": {
                "beforePatchRowNumber": 665,
                "afterPatchRowNumber": 698,
                "PatchRowcode": " "
            },
            "69": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 699,
                "PatchRowcode": "+        validate_node_count(parsed, limit=max_nodes)"
            },
            "70": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 700,
                "PatchRowcode": "+"
            },
            "71": {
                "beforePatchRowNumber": 666,
                "afterPatchRowNumber": 701,
                "PatchRowcode": "         if unwrap is not None:"
            },
            "72": {
                "beforePatchRowNumber": 667,
                "afterPatchRowNumber": 702,
                "PatchRowcode": "             if not isinstance(parsed, Mapping):"
            },
            "73": {
                "beforePatchRowNumber": 668,
                "afterPatchRowNumber": 703,
                "PatchRowcode": "                 msg = ("
            },
            "74": {
                "beforePatchRowNumber": 701,
                "afterPatchRowNumber": 736,
                "PatchRowcode": "         run(sys.argv)"
            },
            "75": {
                "beforePatchRowNumber": 702,
                "afterPatchRowNumber": 737,
                "PatchRowcode": "     except KeyboardInterrupt:"
            },
            "76": {
                "beforePatchRowNumber": 703,
                "afterPatchRowNumber": 738,
                "PatchRowcode": "         pass"
            },
            "77": {
                "beforePatchRowNumber": 704,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-    except (OSError, TypeError, ValueError) as e:"
            },
            "78": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 739,
                "PatchRowcode": "+    except (OSError, TooManyNodesError, TypeError, ValueError) as e:"
            },
            "79": {
                "beforePatchRowNumber": 705,
                "afterPatchRowNumber": 740,
                "PatchRowcode": "         print(f\"Error: {e}\", file=sys.stderr)  # noqa: T201"
            },
            "80": {
                "beforePatchRowNumber": 706,
                "afterPatchRowNumber": 741,
                "PatchRowcode": "         sys.exit(1)"
            },
            "81": {
                "beforePatchRowNumber": 707,
                "afterPatchRowNumber": 742,
                "PatchRowcode": " "
            }
        },
        "frontPatchFile": [
            "#! /usr/bin/env python3",
            "# Remarshal, a utility to convert between serialization formats.",
            "# Copyright (c) 2014-2020, 2023 D. Bohdan",
            "# License: MIT",
            "",
            "",
            "from __future__ import annotations",
            "",
            "import argparse",
            "import datetime",
            "import json",
            "import re",
            "import sys",
            "from pathlib import Path",
            "from typing import Any, Callable, Dict, List, Mapping, Sequence, Set, Tuple, Union, cast",
            "",
            "import cbor2  # type: ignore",
            "import dateutil.parser",
            "import tomlkit",
            "import tomlkit.exceptions",
            "import tomlkit.items",
            "import umsgpack  # type: ignore",
            "import yaml",
            "import yaml.parser",
            "import yaml.scanner",
            "",
            "__version__ = \"0.17.0\"",
            "",
            "FORMATS = [\"cbor\", \"json\", \"msgpack\", \"toml\", \"yaml\"]",
            "",
            "",
            "# === YAML ===",
            "",
            "",
            "# An ordered dumper for PyYAML.",
            "class OrderedDumper(yaml.SafeDumper):",
            "    pass",
            "",
            "",
            "def mapping_representer(dumper: Any, data: Any) -> Any:",
            "    return dumper.represent_mapping(",
            "        yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, data.items()",
            "    )",
            "",
            "",
            "OrderedDumper.add_representer(dict, mapping_representer)",
            "",
            "",
            "# Fix loss of time zone information in PyYAML.",
            "# http://stackoverflow.com/questions/13294186/can-pyyaml-parse-iso8601-dates",
            "class TimezoneLoader(yaml.SafeLoader):",
            "    pass",
            "",
            "",
            "def timestamp_constructor(loader: Any, node: Any) -> datetime.datetime:",
            "    return dateutil.parser.parse(node.value)",
            "",
            "",
            "loaders = [TimezoneLoader]",
            "for loader in loaders:",
            "    loader.add_constructor(\"tag:yaml.org,2002:timestamp\", timestamp_constructor)",
            "",
            "",
            "# === CLI ===",
            "",
            "",
            "def argv0_to_format(argv0: str) -> Tuple[str, str]:",
            "    possible_format = \"(\" + \"|\".join(FORMATS) + \")\"",
            "    match = re.search(\"^\" + possible_format + \"2\" + possible_format, argv0)",
            "    from_, to = match.groups() if match else (\"\", \"\")",
            "    return from_, to",
            "",
            "",
            "def extension_to_format(path: str) -> str:",
            "    ext = Path(path).suffix[1:]",
            "",
            "    if ext == \"yml\":",
            "        ext = \"yaml\"",
            "",
            "    return ext if ext in FORMATS else \"\"",
            "",
            "",
            "def parse_command_line(argv: List[str]) -> argparse.Namespace:  # noqa: C901.",
            "    defaults: Dict[str, Any] = {",
            "        \"json_indent\": None,",
            "        \"ordered\": True,",
            "        \"stringify\": False,",
            "        \"yaml_options\": {},",
            "    }",
            "",
            "    me = Path(argv[0]).name",
            "    argv0_from, argv0_to = argv0_to_format(me)",
            "    format_from_argv0 = argv0_to != \"\"",
            "",
            "    parser = argparse.ArgumentParser(",
            "        description=\"Convert between CBOR, JSON, MessagePack, TOML, and YAML.\"",
            "    )",
            "    parser.add_argument(\"-v\", \"--version\", action=\"version\", version=__version__)",
            "",
            "    input_group = parser.add_mutually_exclusive_group()",
            "    input_group.add_argument(\"input\", nargs=\"?\", default=\"-\", help=\"input file\")",
            "    input_group.add_argument(",
            "        \"-i\",",
            "        \"--input\",",
            "        dest=\"input_flag\",",
            "        metavar=\"input\",",
            "        default=None,",
            "        help=\"input file\",",
            "    )",
            "",
            "    if not format_from_argv0:",
            "        parser.add_argument(",
            "            \"--if\",",
            "            \"-if\",",
            "            \"--input-format\",",
            "            dest=\"input_format\",",
            "            default=\"\",",
            "            help=\"input format\",",
            "            choices=FORMATS,",
            "        )",
            "",
            "    if not format_from_argv0 or argv0_to == \"json\":",
            "        parser.add_argument(",
            "            \"--json-indent\",",
            "            \"--indent-json\",",
            "            dest=\"json_indent\",",
            "            metavar=\"n\",",
            "            type=int,",
            "            default=defaults[\"json_indent\"],",
            "            help=\"JSON indentation\",",
            "        )",
            "",
            "    if not format_from_argv0 or argv0_to in {\"json\", \"toml\"}:",
            "        parser.add_argument(",
            "            \"-k\",",
            "            \"--stringify\",",
            "            dest=\"stringify\",",
            "            action=\"store_true\",",
            "            help=(",
            "                \"Turn into strings boolean, date-time, and null keys for JSON \"",
            "                \"and TOML and null values for TOML\"",
            "            ),",
            "        )",
            "",
            "    output_group = parser.add_mutually_exclusive_group()",
            "    output_group.add_argument(\"output\", nargs=\"?\", default=\"-\", help=\"output file\")",
            "    output_group.add_argument(",
            "        \"-o\",",
            "        \"--output\",",
            "        dest=\"output_flag\",",
            "        metavar=\"output\",",
            "        default=None,",
            "        help=\"output file\",",
            "    )",
            "",
            "    if not format_from_argv0:",
            "        parser.add_argument(",
            "            \"--of\",",
            "            \"-of\",",
            "            \"--output-format\",",
            "            dest=\"output_format\",",
            "            default=\"\",",
            "            help=\"output format\",",
            "            choices=FORMATS,",
            "        )",
            "",
            "    parser.add_argument(",
            "        \"-p\",",
            "        \"--preserve-key-order\",",
            "        help=argparse.SUPPRESS,",
            "    )",
            "",
            "    if not format_from_argv0 or argv0_to in {\"json\", \"toml\", \"yaml\"}:",
            "        parser.add_argument(",
            "            \"-s\",",
            "            \"--sort-keys\",",
            "            dest=\"ordered\",",
            "            action=\"store_false\",",
            "            help=\"sort JSON, TOML, YAML keys instead of preserving key order\",",
            "        )",
            "",
            "    parser.add_argument(",
            "        \"--unwrap\",",
            "        dest=\"unwrap\",",
            "        metavar=\"key\",",
            "        default=None,",
            "        help=\"only output the data stored under the given key\",",
            "    )",
            "    parser.add_argument(",
            "        \"--wrap\",",
            "        dest=\"wrap\",",
            "        metavar=\"key\",",
            "        default=None,",
            "        help=\"wrap the data in a map type with the given key\",",
            "    )",
            "",
            "    if not format_from_argv0 or argv0_to == \"yaml\":",
            "        parser.add_argument(",
            "            \"--yaml-indent\",",
            "            dest=\"yaml_indent\",",
            "            metavar=\"n\",",
            "            type=int,",
            "            default=2,",
            "            help=\"YAML indentation\",",
            "        )",
            "        parser.add_argument(",
            "            \"--yaml-style\",",
            "            dest=\"yaml_style\",",
            "            default=None,",
            "            help=\"YAML formatting style\",",
            "            choices=[\"\", \"'\", '\"', \"|\", \">\"],",
            "        )",
            "",
            "        def yaml_width(value: str) -> int:",
            "            # This is theoretically compatible with LibYAML.",
            "            return (1 << 32) - 1 if value.lower() == \"inf\" else int(value)",
            "",
            "        parser.add_argument(",
            "            \"--yaml-width\",",
            "            dest=\"yaml_width\",",
            "            metavar=\"n\",",
            "            type=yaml_width,  # Allow \"inf\".",
            "            default=80,",
            "            help=\"YAML line width for long strings\",",
            "        )",
            "",
            "    args = parser.parse_args(args=argv[1:])",
            "",
            "    # Use the positional input and output arguments.",
            "    if args.input_flag is not None:",
            "        args.input = args.input_flag",
            "",
            "    if args.output_flag is not None:",
            "        args.output = args.output_flag",
            "",
            "    # Determine the implicit input and output format if possible.",
            "    if format_from_argv0:",
            "        args.input_format = argv0_from",
            "        args.output_format = argv0_to",
            "    else:",
            "        if args.input_format == \"\":",
            "            args.input_format = extension_to_format(args.input)",
            "            if args.input_format == \"\":",
            "                parser.error(\"Need an explicit input format\")",
            "",
            "        if args.output_format == \"\":",
            "            args.output_format = extension_to_format(args.output)",
            "            if args.output_format == \"\":",
            "                parser.error(\"Need an explicit output format\")",
            "",
            "    for key, value in defaults.items():",
            "        vars(args).setdefault(key, value)",
            "",
            "    # Wrap the yaml_* option.",
            "    if \"yaml_indent\" in vars(args):",
            "        vars(args)[\"yaml_options\"] = {",
            "            \"default_style\": args.yaml_style,",
            "            \"indent\": args.yaml_indent,",
            "            \"width\": args.yaml_width,",
            "        }",
            "        for key in [\"yaml_indent\", \"yaml_style\", \"yaml_width\"]:",
            "            del vars(args)[key]",
            "",
            "    return args",
            "",
            "",
            "# === Parser/serializer wrappers ===",
            "",
            "",
            "def identity(x: Any) -> Any:",
            "    return x",
            "",
            "",
            "def traverse(",
            "    col: Any,",
            "    dict_callback: Callable[[List[Tuple[Any, Any]]], Any] = lambda x: dict(x),",
            "    list_callback: Callable[[List[Tuple[Any, Any]]], Any] = identity,",
            "    key_callback: Callable[[Any], Any] = identity,",
            "    instance_callbacks: Set[Tuple[type, Any]] = set(),",
            "    default_callback: Callable[[Any], Any] = identity,",
            ") -> Any:",
            "    if isinstance(col, dict):",
            "        res = dict_callback(",
            "            [",
            "                (",
            "                    key_callback(k),",
            "                    traverse(",
            "                        v,",
            "                        dict_callback,",
            "                        list_callback,",
            "                        key_callback,",
            "                        instance_callbacks,",
            "                        default_callback,",
            "                    ),",
            "                )",
            "                for (k, v) in col.items()",
            "            ]",
            "        )",
            "    elif isinstance(col, list):",
            "        res = list_callback(",
            "            [",
            "                traverse(",
            "                    x,",
            "                    dict_callback,",
            "                    list_callback,",
            "                    key_callback,",
            "                    instance_callbacks,",
            "                    default_callback,",
            "                )",
            "                for x in col",
            "            ]",
            "        )",
            "    else:",
            "        for t, callback in instance_callbacks:",
            "            if isinstance(col, t):",
            "                res = callback(col)",
            "                break",
            "        else:",
            "            res = default_callback(col)",
            "",
            "    return res",
            "",
            "",
            "Document = Union[bool, bytes, datetime.datetime, Mapping, None, Sequence, str]",
            "",
            "",
            "def decode_json(input_data: bytes) -> Document:",
            "    try:",
            "        doc = json.loads(",
            "            input_data.decode(\"utf-8\"),",
            "        )",
            "",
            "        return cast(Document, doc)",
            "    except json.JSONDecodeError as e:",
            "        msg = f\"Cannot parse as JSON ({e})\"",
            "        raise ValueError(msg)",
            "",
            "",
            "def decode_msgpack(input_data: bytes) -> Document:",
            "    try:",
            "        doc = umsgpack.unpackb(input_data)",
            "        return cast(Document, doc)",
            "    except umsgpack.UnpackException as e:",
            "        msg = f\"Cannot parse as MessagePack ({e})\"",
            "        raise ValueError(msg)",
            "",
            "",
            "def decode_cbor(input_data: bytes) -> Document:",
            "    try:",
            "        doc = cbor2.loads(input_data)",
            "        return cast(Document, doc)",
            "    except cbor2.CBORDecodeError as e:",
            "        msg = f\"Cannot parse as CBOR ({e})\"",
            "        raise ValueError(msg)",
            "",
            "",
            "def decode_toml(input_data: bytes) -> Document:",
            "    try:",
            "        # Remove TOML Kit's custom classes.",
            "        # https://github.com/sdispater/tomlkit/issues/43",
            "        doc = traverse(",
            "            tomlkit.loads(input_data),",
            "            instance_callbacks={",
            "                (tomlkit.items.Bool, bool),",
            "                (",
            "                    tomlkit.items.Date,",
            "                    lambda x: datetime.date(",
            "                        x.year,",
            "                        x.month,",
            "                        x.day,",
            "                    ),",
            "                ),",
            "                (",
            "                    tomlkit.items.DateTime,",
            "                    lambda x: datetime.datetime(",
            "                        x.year,",
            "                        x.month,",
            "                        x.day,",
            "                        x.hour,",
            "                        x.minute,",
            "                        x.second,",
            "                        x.microsecond,",
            "                        x.tzinfo,",
            "                    ),",
            "                ),",
            "                (tomlkit.items.Float, float),",
            "                (tomlkit.items.Integer, int),",
            "                (tomlkit.items.String, str),",
            "                (",
            "                    tomlkit.items.Time,",
            "                    lambda x: datetime.time(",
            "                        x.hour,",
            "                        x.minute,",
            "                        x.second,",
            "                        x.microsecond,",
            "                        x.tzinfo,",
            "                    ),",
            "                ),",
            "            },",
            "        )",
            "",
            "        return cast(Document, doc)",
            "    except tomlkit.exceptions.ParseError as e:",
            "        msg = f\"Cannot parse as TOML ({e})\"",
            "        raise ValueError(msg)",
            "",
            "",
            "def decode_yaml(input_data: bytes) -> Document:",
            "    try:",
            "        loader = TimezoneLoader",
            "        doc = yaml.load(input_data, loader)",
            "        return cast(Document, doc)",
            "    except (yaml.scanner.ScannerError, yaml.parser.ParserError) as e:",
            "        msg = f\"Cannot parse as YAML ({e})\"",
            "        raise ValueError(msg)",
            "",
            "",
            "def decode(input_format: str, input_data: bytes) -> Document:",
            "    decoder = {",
            "        \"cbor\": decode_cbor,",
            "        \"json\": decode_json,",
            "        \"msgpack\": decode_msgpack,",
            "        \"toml\": decode_toml,",
            "        \"yaml\": decode_yaml,",
            "    }",
            "",
            "    if input_format not in decoder:",
            "        msg = f\"Unknown input format: {input_format}\"",
            "        raise ValueError(msg)",
            "",
            "    return decoder[input_format](input_data)",
            "",
            "",
            "def reject_special_keys(key: Any) -> Any:",
            "    if isinstance(key, bool):",
            "        msg = \"boolean key\"",
            "        raise TypeError(msg)",
            "    if isinstance(key, datetime.datetime):",
            "        msg = \"date-time key\"",
            "        raise TypeError(msg)",
            "    if key is None:",
            "        msg = \"null key\"",
            "        raise TypeError(msg)",
            "",
            "    return key",
            "",
            "",
            "def stringify_special_keys(key: Any) -> Any:",
            "    if isinstance(key, bool):",
            "        return \"true\" if key else \"false\"",
            "    if isinstance(key, datetime.datetime):",
            "        return key.isoformat()",
            "    if key is None:",
            "        return \"null\"",
            "",
            "    return str(key)",
            "",
            "",
            "def json_default(obj: Any) -> str:",
            "    if isinstance(obj, datetime.datetime):",
            "        return obj.isoformat()",
            "    msg = f\"{obj!r} is not JSON-serializable\"",
            "    raise TypeError(msg)",
            "",
            "",
            "def encode_json(",
            "    data: Document,",
            "    *,",
            "    ordered: bool,",
            "    indent: Union[bool, int, None],",
            "    stringify: bool,",
            ") -> str:",
            "    if indent is True:",
            "        indent = 2",
            "",
            "    separators = (\",\", \": \" if indent else \":\")",
            "    key_callback = stringify_special_keys if stringify else reject_special_keys",
            "",
            "    try:",
            "        return (",
            "            json.dumps(",
            "                traverse(",
            "                    data,",
            "                    key_callback=key_callback,",
            "                ),",
            "                default=json_default,",
            "                ensure_ascii=False,",
            "                indent=indent,",
            "                separators=separators,",
            "                sort_keys=not ordered,",
            "            )",
            "            + \"\\n\"",
            "        )",
            "    except (TypeError, ValueError) as e:",
            "        msg = f\"Cannot convert data to JSON ({e})\"",
            "        raise ValueError(msg)",
            "",
            "",
            "def encode_msgpack(data: Document) -> bytes:",
            "    try:",
            "        return bytes(umsgpack.packb(data))",
            "    except umsgpack.UnsupportedTypeException as e:",
            "        msg = f\"Cannot convert data to MessagePack ({e})\"",
            "        raise ValueError(msg)",
            "",
            "",
            "def encode_cbor(data: Document) -> bytes:",
            "    try:",
            "        return bytes(cbor2.dumps(data))",
            "    except cbor2.CBOREncodeError as e:",
            "        msg = f\"Cannot convert data to CBOR ({e})\"",
            "        raise ValueError(msg)",
            "",
            "",
            "def encode_toml(",
            "    data: Mapping[Any, Any],",
            "    *,",
            "    ordered: bool,",
            "    stringify: bool,",
            ") -> str:",
            "    key_callback = stringify_special_keys if stringify else reject_special_keys",
            "",
            "    def reject_null(x: Any) -> Any:",
            "        if x is None:",
            "            msg = \"null values are not supported\"",
            "            raise TypeError(msg)",
            "",
            "        return x",
            "",
            "    def stringify_null(x: Any) -> Any:",
            "        if x is None:",
            "            return \"null\"",
            "",
            "        return x",
            "",
            "    default_callback = stringify_null if stringify else reject_null",
            "",
            "    try:",
            "        return tomlkit.dumps(",
            "            traverse(",
            "                data,",
            "                key_callback=key_callback,",
            "                default_callback=default_callback,",
            "            ),",
            "            sort_keys=not ordered,",
            "        )",
            "    except AttributeError as e:",
            "        if str(e) == \"'list' object has no attribute 'as_string'\":",
            "            msg = (",
            "                \"Cannot convert non-dictionary data to TOML; \"",
            "                'use \"wrap\" to wrap it in a dictionary'",
            "            )",
            "            raise ValueError(msg)",
            "        else:",
            "            raise e",
            "    except (TypeError, ValueError) as e:",
            "        msg = f\"Cannot convert data to TOML ({e})\"",
            "        raise ValueError(msg)",
            "",
            "",
            "def encode_yaml(data: Document, *, ordered: bool, yaml_options: Dict[Any, Any]) -> str:",
            "    dumper = OrderedDumper if ordered else yaml.SafeDumper",
            "    try:",
            "        return yaml.dump(",
            "            data,",
            "            None,",
            "            dumper,",
            "            allow_unicode=True,",
            "            default_flow_style=False,",
            "            encoding=None,",
            "            **yaml_options,",
            "        )",
            "    except yaml.representer.RepresenterError as e:",
            "        msg = f\"Cannot convert data to YAML ({e})\"",
            "        raise ValueError(msg)",
            "",
            "",
            "def encode(",
            "    output_format: str,",
            "    data: Document,",
            "    *,",
            "    json_indent: Union[int, None],",
            "    ordered: bool,",
            "    stringify: bool,",
            "    yaml_options: Dict[Any, Any],",
            ") -> bytes:",
            "    if output_format == \"json\":",
            "        encoded = encode_json(",
            "            data,",
            "            indent=json_indent,",
            "            ordered=ordered,",
            "            stringify=stringify,",
            "        ).encode(\"utf-8\")",
            "    elif output_format == \"msgpack\":",
            "        encoded = encode_msgpack(data)",
            "    elif output_format == \"toml\":",
            "        if not isinstance(data, Mapping):",
            "            msg = (",
            "                f\"Top-level value of type '{type(data).__name__}' cannot \"",
            "                \"be encoded as TOML\"",
            "            )",
            "            raise TypeError(msg)",
            "        encoded = encode_toml(data, ordered=ordered, stringify=stringify).encode(",
            "            \"utf-8\"",
            "        )",
            "    elif output_format == \"yaml\":",
            "        encoded = encode_yaml(data, ordered=ordered, yaml_options=yaml_options).encode(",
            "            \"utf-8\"",
            "        )",
            "    elif output_format == \"cbor\":",
            "        encoded = encode_cbor(data)",
            "    else:",
            "        msg = f\"Unknown output format: {output_format}\"",
            "        raise ValueError(msg)",
            "",
            "    return encoded",
            "",
            "",
            "# === Main ===",
            "",
            "",
            "def run(argv: List[str]) -> None:",
            "    args = parse_command_line(argv)",
            "    remarshal(",
            "        args.input,",
            "        args.output,",
            "        args.input_format,",
            "        args.output_format,",
            "        json_indent=args.json_indent,",
            "        ordered=args.ordered,",
            "        stringify=args.stringify,",
            "        unwrap=args.unwrap,",
            "        wrap=args.wrap,",
            "        yaml_options=args.yaml_options,",
            "    )",
            "",
            "",
            "def remarshal(",
            "    input: Path | str,",
            "    output: Path | str,",
            "    input_format: str,",
            "    output_format: str,",
            "    *,",
            "    json_indent: Union[int, None] = None,",
            "    ordered: bool = True,",
            "    stringify: bool = False,",
            "    transform: Union[Callable[[Document], Document], None] = None,",
            "    unwrap: Union[str, None] = None,",
            "    wrap: Union[str, None] = None,",
            "    yaml_options: Dict[Any, Any] = {},",
            ") -> None:",
            "    input_file = None",
            "    output_file = None",
            "",
            "    try:",
            "        input_file = sys.stdin.buffer if input == \"-\" else Path(input).open(\"rb\")",
            "        output_file = sys.stdout.buffer if output == \"-\" else Path(output).open(\"wb\")",
            "",
            "        input_data = input_file.read()",
            "        if not isinstance(input_data, bytes):",
            "            msg = \"input_data must be bytes\"",
            "            raise TypeError(msg)",
            "",
            "        parsed = decode(input_format, input_data)",
            "",
            "        if unwrap is not None:",
            "            if not isinstance(parsed, Mapping):",
            "                msg = (",
            "                    f\"Top-level value of type '{type(parsed).__name__}' \"",
            "                    \"cannot be unwrapped\"",
            "                )",
            "                raise TypeError(msg)",
            "            parsed = parsed[unwrap]",
            "        if wrap is not None:",
            "            temp = {}",
            "            temp[wrap] = parsed",
            "            parsed = temp",
            "",
            "        if transform:",
            "            parsed = transform(parsed)",
            "",
            "        encoded = encode(",
            "            output_format,",
            "            parsed,",
            "            json_indent=json_indent,",
            "            ordered=ordered,",
            "            stringify=stringify,",
            "            yaml_options=yaml_options,",
            "        )",
            "",
            "        output_file.write(encoded)",
            "    finally:",
            "        if input_file is not None:",
            "            input_file.close()",
            "        if output != \"-\" and output_file is not None:",
            "            output_file.close()",
            "",
            "",
            "def main() -> None:",
            "    try:",
            "        run(sys.argv)",
            "    except KeyboardInterrupt:",
            "        pass",
            "    except (OSError, TypeError, ValueError) as e:",
            "        print(f\"Error: {e}\", file=sys.stderr)  # noqa: T201",
            "        sys.exit(1)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "afterPatchFile": [
            "#! /usr/bin/env python3",
            "# Remarshal, a utility to convert between serialization formats.",
            "# Copyright (c) 2014-2020, 2023 D. Bohdan",
            "# License: MIT",
            "",
            "",
            "from __future__ import annotations",
            "",
            "import argparse",
            "import datetime",
            "import json",
            "import re",
            "import sys",
            "from pathlib import Path",
            "from typing import Any, Callable, Dict, List, Mapping, Sequence, Set, Tuple, Union, cast",
            "",
            "import cbor2  # type: ignore",
            "import dateutil.parser",
            "import tomlkit",
            "import tomlkit.exceptions",
            "import tomlkit.items",
            "import umsgpack  # type: ignore",
            "import yaml",
            "import yaml.parser",
            "import yaml.scanner",
            "",
            "__version__ = \"0.17.1\"",
            "",
            "DEFAULT_MAX_NODES = 100000",
            "FORMATS = [\"cbor\", \"json\", \"msgpack\", \"toml\", \"yaml\"]",
            "",
            "",
            "# === YAML ===",
            "",
            "",
            "# An ordered dumper for PyYAML.",
            "class OrderedDumper(yaml.SafeDumper):",
            "    pass",
            "",
            "",
            "def mapping_representer(dumper: Any, data: Any) -> Any:",
            "    return dumper.represent_mapping(",
            "        yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG, data.items()",
            "    )",
            "",
            "",
            "OrderedDumper.add_representer(dict, mapping_representer)",
            "",
            "",
            "# Fix loss of time zone information in PyYAML.",
            "# http://stackoverflow.com/questions/13294186/can-pyyaml-parse-iso8601-dates",
            "class TimezoneLoader(yaml.SafeLoader):",
            "    pass",
            "",
            "",
            "def timestamp_constructor(loader: Any, node: Any) -> datetime.datetime:",
            "    return dateutil.parser.parse(node.value)",
            "",
            "",
            "loaders = [TimezoneLoader]",
            "for loader in loaders:",
            "    loader.add_constructor(\"tag:yaml.org,2002:timestamp\", timestamp_constructor)",
            "",
            "",
            "# === CLI ===",
            "",
            "",
            "def argv0_to_format(argv0: str) -> Tuple[str, str]:",
            "    possible_format = \"(\" + \"|\".join(FORMATS) + \")\"",
            "    match = re.search(\"^\" + possible_format + \"2\" + possible_format, argv0)",
            "    from_, to = match.groups() if match else (\"\", \"\")",
            "    return from_, to",
            "",
            "",
            "def extension_to_format(path: str) -> str:",
            "    ext = Path(path).suffix[1:]",
            "",
            "    if ext == \"yml\":",
            "        ext = \"yaml\"",
            "",
            "    return ext if ext in FORMATS else \"\"",
            "",
            "",
            "def parse_command_line(argv: List[str]) -> argparse.Namespace:  # noqa: C901.",
            "    defaults: Dict[str, Any] = {",
            "        \"json_indent\": None,",
            "        \"ordered\": True,",
            "        \"stringify\": False,",
            "        \"yaml_options\": {},",
            "    }",
            "",
            "    me = Path(argv[0]).name",
            "    argv0_from, argv0_to = argv0_to_format(me)",
            "    format_from_argv0 = argv0_to != \"\"",
            "",
            "    parser = argparse.ArgumentParser(",
            "        description=\"Convert between CBOR, JSON, MessagePack, TOML, and YAML.\"",
            "    )",
            "    parser.add_argument(\"-v\", \"--version\", action=\"version\", version=__version__)",
            "",
            "    input_group = parser.add_mutually_exclusive_group()",
            "    input_group.add_argument(\"input\", nargs=\"?\", default=\"-\", help=\"input file\")",
            "    input_group.add_argument(",
            "        \"-i\",",
            "        \"--input\",",
            "        dest=\"input_flag\",",
            "        metavar=\"input\",",
            "        default=None,",
            "        help=\"input file\",",
            "    )",
            "",
            "    if not format_from_argv0:",
            "        parser.add_argument(",
            "            \"--if\",",
            "            \"-if\",",
            "            \"--input-format\",",
            "            dest=\"input_format\",",
            "            default=\"\",",
            "            help=\"input format\",",
            "            choices=FORMATS,",
            "        )",
            "",
            "    if not format_from_argv0 or argv0_to == \"json\":",
            "        parser.add_argument(",
            "            \"--json-indent\",",
            "            \"--indent-json\",",
            "            dest=\"json_indent\",",
            "            metavar=\"n\",",
            "            type=int,",
            "            default=defaults[\"json_indent\"],",
            "            help=\"JSON indentation\",",
            "        )",
            "",
            "    if not format_from_argv0 or argv0_to in {\"json\", \"toml\"}:",
            "        parser.add_argument(",
            "            \"-k\",",
            "            \"--stringify\",",
            "            dest=\"stringify\",",
            "            action=\"store_true\",",
            "            help=(",
            "                \"Turn into strings boolean, date-time, and null keys for JSON \"",
            "                \"and TOML and null values for TOML\"",
            "            ),",
            "        )",
            "",
            "    parser.add_argument(",
            "        \"--max-nodes\",",
            "        dest=\"max_nodes\",",
            "        metavar=\"n\",",
            "        type=int,",
            "        default=DEFAULT_MAX_NODES,",
            "        help=\"maximum number of nodes in input data (default %(default)s)\",",
            "    )",
            "",
            "    output_group = parser.add_mutually_exclusive_group()",
            "    output_group.add_argument(\"output\", nargs=\"?\", default=\"-\", help=\"output file\")",
            "    output_group.add_argument(",
            "        \"-o\",",
            "        \"--output\",",
            "        dest=\"output_flag\",",
            "        metavar=\"output\",",
            "        default=None,",
            "        help=\"output file\",",
            "    )",
            "",
            "    if not format_from_argv0:",
            "        parser.add_argument(",
            "            \"--of\",",
            "            \"-of\",",
            "            \"--output-format\",",
            "            dest=\"output_format\",",
            "            default=\"\",",
            "            help=\"output format\",",
            "            choices=FORMATS,",
            "        )",
            "",
            "    parser.add_argument(",
            "        \"-p\",",
            "        \"--preserve-key-order\",",
            "        help=argparse.SUPPRESS,",
            "    )",
            "",
            "    if not format_from_argv0 or argv0_to in {\"json\", \"toml\", \"yaml\"}:",
            "        parser.add_argument(",
            "            \"-s\",",
            "            \"--sort-keys\",",
            "            dest=\"ordered\",",
            "            action=\"store_false\",",
            "            help=\"sort JSON, TOML, YAML keys instead of preserving key order\",",
            "        )",
            "",
            "    parser.add_argument(",
            "        \"--unwrap\",",
            "        dest=\"unwrap\",",
            "        metavar=\"key\",",
            "        default=None,",
            "        help=\"only output the data stored under the given key\",",
            "    )",
            "    parser.add_argument(",
            "        \"--wrap\",",
            "        dest=\"wrap\",",
            "        metavar=\"key\",",
            "        default=None,",
            "        help=\"wrap the data in a map type with the given key\",",
            "    )",
            "",
            "    if not format_from_argv0 or argv0_to == \"yaml\":",
            "        parser.add_argument(",
            "            \"--yaml-indent\",",
            "            dest=\"yaml_indent\",",
            "            metavar=\"n\",",
            "            type=int,",
            "            default=2,",
            "            help=\"YAML indentation\",",
            "        )",
            "        parser.add_argument(",
            "            \"--yaml-style\",",
            "            dest=\"yaml_style\",",
            "            default=None,",
            "            help=\"YAML formatting style\",",
            "            choices=[\"\", \"'\", '\"', \"|\", \">\"],",
            "        )",
            "",
            "        def yaml_width(value: str) -> int:",
            "            # This is theoretically compatible with LibYAML.",
            "            return (1 << 32) - 1 if value.lower() == \"inf\" else int(value)",
            "",
            "        parser.add_argument(",
            "            \"--yaml-width\",",
            "            dest=\"yaml_width\",",
            "            metavar=\"n\",",
            "            type=yaml_width,  # Allow \"inf\".",
            "            default=80,",
            "            help=\"YAML line width for long strings\",",
            "        )",
            "",
            "    args = parser.parse_args(args=argv[1:])",
            "",
            "    # Use the positional input and output arguments.",
            "    if args.input_flag is not None:",
            "        args.input = args.input_flag",
            "",
            "    if args.output_flag is not None:",
            "        args.output = args.output_flag",
            "",
            "    # Determine the implicit input and output format if possible.",
            "    if format_from_argv0:",
            "        args.input_format = argv0_from",
            "        args.output_format = argv0_to",
            "    else:",
            "        if args.input_format == \"\":",
            "            args.input_format = extension_to_format(args.input)",
            "            if args.input_format == \"\":",
            "                parser.error(\"Need an explicit input format\")",
            "",
            "        if args.output_format == \"\":",
            "            args.output_format = extension_to_format(args.output)",
            "            if args.output_format == \"\":",
            "                parser.error(\"Need an explicit output format\")",
            "",
            "    for key, value in defaults.items():",
            "        vars(args).setdefault(key, value)",
            "",
            "    # Wrap the yaml_* option.",
            "    if \"yaml_indent\" in vars(args):",
            "        vars(args)[\"yaml_options\"] = {",
            "            \"default_style\": args.yaml_style,",
            "            \"indent\": args.yaml_indent,",
            "            \"width\": args.yaml_width,",
            "        }",
            "        for key in [\"yaml_indent\", \"yaml_style\", \"yaml_width\"]:",
            "            del vars(args)[key]",
            "",
            "    return args",
            "",
            "",
            "# === Parser/serializer wrappers ===",
            "",
            "",
            "def identity(x: Any) -> Any:",
            "    return x",
            "",
            "",
            "def traverse(",
            "    col: Any,",
            "    dict_callback: Callable[[List[Tuple[Any, Any]]], Any] = lambda x: dict(x),",
            "    list_callback: Callable[[List[Tuple[Any, Any]]], Any] = identity,",
            "    key_callback: Callable[[Any], Any] = identity,",
            "    instance_callbacks: Set[Tuple[type, Any]] = set(),",
            "    default_callback: Callable[[Any], Any] = identity,",
            ") -> Any:",
            "    if isinstance(col, dict):",
            "        res = dict_callback(",
            "            [",
            "                (",
            "                    key_callback(k),",
            "                    traverse(",
            "                        v,",
            "                        dict_callback,",
            "                        list_callback,",
            "                        key_callback,",
            "                        instance_callbacks,",
            "                        default_callback,",
            "                    ),",
            "                )",
            "                for (k, v) in col.items()",
            "            ]",
            "        )",
            "    elif isinstance(col, list):",
            "        res = list_callback(",
            "            [",
            "                traverse(",
            "                    x,",
            "                    dict_callback,",
            "                    list_callback,",
            "                    key_callback,",
            "                    instance_callbacks,",
            "                    default_callback,",
            "                )",
            "                for x in col",
            "            ]",
            "        )",
            "    else:",
            "        for t, callback in instance_callbacks:",
            "            if isinstance(col, t):",
            "                res = callback(col)",
            "                break",
            "        else:",
            "            res = default_callback(col)",
            "",
            "    return res",
            "",
            "",
            "Document = Union[bool, bytes, datetime.datetime, Mapping, None, Sequence, str]",
            "",
            "",
            "def decode_json(input_data: bytes) -> Document:",
            "    try:",
            "        doc = json.loads(",
            "            input_data.decode(\"utf-8\"),",
            "        )",
            "",
            "        return cast(Document, doc)",
            "    except json.JSONDecodeError as e:",
            "        msg = f\"Cannot parse as JSON ({e})\"",
            "        raise ValueError(msg)",
            "",
            "",
            "def decode_msgpack(input_data: bytes) -> Document:",
            "    try:",
            "        doc = umsgpack.unpackb(input_data)",
            "        return cast(Document, doc)",
            "    except umsgpack.UnpackException as e:",
            "        msg = f\"Cannot parse as MessagePack ({e})\"",
            "        raise ValueError(msg)",
            "",
            "",
            "def decode_cbor(input_data: bytes) -> Document:",
            "    try:",
            "        doc = cbor2.loads(input_data)",
            "        return cast(Document, doc)",
            "    except cbor2.CBORDecodeError as e:",
            "        msg = f\"Cannot parse as CBOR ({e})\"",
            "        raise ValueError(msg)",
            "",
            "",
            "def decode_toml(input_data: bytes) -> Document:",
            "    try:",
            "        # Remove TOML Kit's custom classes.",
            "        # https://github.com/sdispater/tomlkit/issues/43",
            "        doc = traverse(",
            "            tomlkit.loads(input_data),",
            "            instance_callbacks={",
            "                (tomlkit.items.Bool, bool),",
            "                (",
            "                    tomlkit.items.Date,",
            "                    lambda x: datetime.date(",
            "                        x.year,",
            "                        x.month,",
            "                        x.day,",
            "                    ),",
            "                ),",
            "                (",
            "                    tomlkit.items.DateTime,",
            "                    lambda x: datetime.datetime(",
            "                        x.year,",
            "                        x.month,",
            "                        x.day,",
            "                        x.hour,",
            "                        x.minute,",
            "                        x.second,",
            "                        x.microsecond,",
            "                        x.tzinfo,",
            "                    ),",
            "                ),",
            "                (tomlkit.items.Float, float),",
            "                (tomlkit.items.Integer, int),",
            "                (tomlkit.items.String, str),",
            "                (",
            "                    tomlkit.items.Time,",
            "                    lambda x: datetime.time(",
            "                        x.hour,",
            "                        x.minute,",
            "                        x.second,",
            "                        x.microsecond,",
            "                        x.tzinfo,",
            "                    ),",
            "                ),",
            "            },",
            "        )",
            "",
            "        return cast(Document, doc)",
            "    except tomlkit.exceptions.ParseError as e:",
            "        msg = f\"Cannot parse as TOML ({e})\"",
            "        raise ValueError(msg)",
            "",
            "",
            "def decode_yaml(input_data: bytes) -> Document:",
            "    try:",
            "        loader = TimezoneLoader",
            "        doc = yaml.load(input_data, loader)",
            "        return cast(Document, doc)",
            "    except (yaml.scanner.ScannerError, yaml.parser.ParserError) as e:",
            "        msg = f\"Cannot parse as YAML ({e})\"",
            "        raise ValueError(msg)",
            "",
            "",
            "def decode(input_format: str, input_data: bytes) -> Document:",
            "    decoder = {",
            "        \"cbor\": decode_cbor,",
            "        \"json\": decode_json,",
            "        \"msgpack\": decode_msgpack,",
            "        \"toml\": decode_toml,",
            "        \"yaml\": decode_yaml,",
            "    }",
            "",
            "    if input_format not in decoder:",
            "        msg = f\"Unknown input format: {input_format}\"",
            "        raise ValueError(msg)",
            "",
            "    return decoder[input_format](input_data)",
            "",
            "",
            "class TooManyNodesError(BaseException):",
            "    def __init__(self, msg: str = \"document has too many nodes\", *args, **kwargs):",
            "        super().__init__(msg, *args, **kwargs)",
            "",
            "",
            "def validate_node_count(doc: Document, *, limit: int) -> None:",
            "    count = 0",
            "",
            "    def count_callback(x: Any) -> Any:",
            "        nonlocal count",
            "        nonlocal limit",
            "",
            "        count += 1",
            "        if count > limit:",
            "            raise TooManyNodesError",
            "",
            "        return x",
            "",
            "    traverse(doc, instance_callbacks={(object, count_callback)})",
            "",
            "",
            "def reject_special_keys(key: Any) -> Any:",
            "    if isinstance(key, bool):",
            "        msg = \"boolean key\"",
            "        raise TypeError(msg)",
            "    if isinstance(key, datetime.datetime):",
            "        msg = \"date-time key\"",
            "        raise TypeError(msg)",
            "    if key is None:",
            "        msg = \"null key\"",
            "        raise TypeError(msg)",
            "",
            "    return key",
            "",
            "",
            "def stringify_special_keys(key: Any) -> Any:",
            "    if isinstance(key, bool):",
            "        return \"true\" if key else \"false\"",
            "    if isinstance(key, datetime.datetime):",
            "        return key.isoformat()",
            "    if key is None:",
            "        return \"null\"",
            "",
            "    return str(key)",
            "",
            "",
            "def json_default(obj: Any) -> str:",
            "    if isinstance(obj, datetime.datetime):",
            "        return obj.isoformat()",
            "    msg = f\"{obj!r} is not JSON-serializable\"",
            "    raise TypeError(msg)",
            "",
            "",
            "def encode_json(",
            "    data: Document,",
            "    *,",
            "    ordered: bool,",
            "    indent: Union[bool, int, None],",
            "    stringify: bool,",
            ") -> str:",
            "    if indent is True:",
            "        indent = 2",
            "",
            "    separators = (\",\", \": \" if indent else \":\")",
            "    key_callback = stringify_special_keys if stringify else reject_special_keys",
            "",
            "    try:",
            "        return (",
            "            json.dumps(",
            "                traverse(",
            "                    data,",
            "                    key_callback=key_callback,",
            "                ),",
            "                default=json_default,",
            "                ensure_ascii=False,",
            "                indent=indent,",
            "                separators=separators,",
            "                sort_keys=not ordered,",
            "            )",
            "            + \"\\n\"",
            "        )",
            "    except (TypeError, ValueError) as e:",
            "        msg = f\"Cannot convert data to JSON ({e})\"",
            "        raise ValueError(msg)",
            "",
            "",
            "def encode_msgpack(data: Document) -> bytes:",
            "    try:",
            "        return bytes(umsgpack.packb(data))",
            "    except umsgpack.UnsupportedTypeException as e:",
            "        msg = f\"Cannot convert data to MessagePack ({e})\"",
            "        raise ValueError(msg)",
            "",
            "",
            "def encode_cbor(data: Document) -> bytes:",
            "    try:",
            "        return bytes(cbor2.dumps(data))",
            "    except cbor2.CBOREncodeError as e:",
            "        msg = f\"Cannot convert data to CBOR ({e})\"",
            "        raise ValueError(msg)",
            "",
            "",
            "def encode_toml(",
            "    data: Mapping[Any, Any],",
            "    *,",
            "    ordered: bool,",
            "    stringify: bool,",
            ") -> str:",
            "    key_callback = stringify_special_keys if stringify else reject_special_keys",
            "",
            "    def reject_null(x: Any) -> Any:",
            "        if x is None:",
            "            msg = \"null values are not supported\"",
            "            raise TypeError(msg)",
            "",
            "        return x",
            "",
            "    def stringify_null(x: Any) -> Any:",
            "        if x is None:",
            "            return \"null\"",
            "",
            "        return x",
            "",
            "    default_callback = stringify_null if stringify else reject_null",
            "",
            "    try:",
            "        return tomlkit.dumps(",
            "            traverse(",
            "                data,",
            "                key_callback=key_callback,",
            "                default_callback=default_callback,",
            "            ),",
            "            sort_keys=not ordered,",
            "        )",
            "    except AttributeError as e:",
            "        if str(e) == \"'list' object has no attribute 'as_string'\":",
            "            msg = (",
            "                \"Cannot convert non-dictionary data to TOML; \"",
            "                'use \"wrap\" to wrap it in a dictionary'",
            "            )",
            "            raise ValueError(msg)",
            "        else:",
            "            raise e",
            "    except (TypeError, ValueError) as e:",
            "        msg = f\"Cannot convert data to TOML ({e})\"",
            "        raise ValueError(msg)",
            "",
            "",
            "def encode_yaml(data: Document, *, ordered: bool, yaml_options: Dict[Any, Any]) -> str:",
            "    dumper = OrderedDumper if ordered else yaml.SafeDumper",
            "    try:",
            "        return yaml.dump(",
            "            data,",
            "            None,",
            "            dumper,",
            "            allow_unicode=True,",
            "            default_flow_style=False,",
            "            encoding=None,",
            "            **yaml_options,",
            "        )",
            "    except yaml.representer.RepresenterError as e:",
            "        msg = f\"Cannot convert data to YAML ({e})\"",
            "        raise ValueError(msg)",
            "",
            "",
            "def encode(",
            "    output_format: str,",
            "    data: Document,",
            "    *,",
            "    json_indent: Union[int, None],",
            "    ordered: bool,",
            "    stringify: bool,",
            "    yaml_options: Dict[Any, Any],",
            ") -> bytes:",
            "    if output_format == \"json\":",
            "        encoded = encode_json(",
            "            data,",
            "            indent=json_indent,",
            "            ordered=ordered,",
            "            stringify=stringify,",
            "        ).encode(\"utf-8\")",
            "    elif output_format == \"msgpack\":",
            "        encoded = encode_msgpack(data)",
            "    elif output_format == \"toml\":",
            "        if not isinstance(data, Mapping):",
            "            msg = (",
            "                f\"Top-level value of type '{type(data).__name__}' cannot \"",
            "                \"be encoded as TOML\"",
            "            )",
            "            raise TypeError(msg)",
            "        encoded = encode_toml(data, ordered=ordered, stringify=stringify).encode(",
            "            \"utf-8\"",
            "        )",
            "    elif output_format == \"yaml\":",
            "        encoded = encode_yaml(data, ordered=ordered, yaml_options=yaml_options).encode(",
            "            \"utf-8\"",
            "        )",
            "    elif output_format == \"cbor\":",
            "        encoded = encode_cbor(data)",
            "    else:",
            "        msg = f\"Unknown output format: {output_format}\"",
            "        raise ValueError(msg)",
            "",
            "    return encoded",
            "",
            "",
            "# === Main ===",
            "",
            "",
            "def run(argv: List[str]) -> None:",
            "    args = parse_command_line(argv)",
            "    remarshal(",
            "        args.input,",
            "        args.output,",
            "        args.input_format,",
            "        args.output_format,",
            "        json_indent=args.json_indent,",
            "        max_nodes=args.max_nodes,",
            "        ordered=args.ordered,",
            "        stringify=args.stringify,",
            "        unwrap=args.unwrap,",
            "        wrap=args.wrap,",
            "        yaml_options=args.yaml_options,",
            "    )",
            "",
            "",
            "def remarshal(",
            "    input: Path | str,",
            "    output: Path | str,",
            "    input_format: str,",
            "    output_format: str,",
            "    *,",
            "    json_indent: Union[int, None] = None,",
            "    max_nodes: int = DEFAULT_MAX_NODES,",
            "    ordered: bool = True,",
            "    stringify: bool = False,",
            "    transform: Union[Callable[[Document], Document], None] = None,",
            "    unwrap: Union[str, None] = None,",
            "    wrap: Union[str, None] = None,",
            "    yaml_options: Dict[Any, Any] = {},",
            ") -> None:",
            "    input_file = None",
            "    output_file = None",
            "",
            "    try:",
            "        input_file = sys.stdin.buffer if input == \"-\" else Path(input).open(\"rb\")",
            "        output_file = sys.stdout.buffer if output == \"-\" else Path(output).open(\"wb\")",
            "",
            "        input_data = input_file.read()",
            "        if not isinstance(input_data, bytes):",
            "            msg = \"input_data must be bytes\"",
            "            raise TypeError(msg)",
            "",
            "        parsed = decode(input_format, input_data)",
            "",
            "        validate_node_count(parsed, limit=max_nodes)",
            "",
            "        if unwrap is not None:",
            "            if not isinstance(parsed, Mapping):",
            "                msg = (",
            "                    f\"Top-level value of type '{type(parsed).__name__}' \"",
            "                    \"cannot be unwrapped\"",
            "                )",
            "                raise TypeError(msg)",
            "            parsed = parsed[unwrap]",
            "        if wrap is not None:",
            "            temp = {}",
            "            temp[wrap] = parsed",
            "            parsed = temp",
            "",
            "        if transform:",
            "            parsed = transform(parsed)",
            "",
            "        encoded = encode(",
            "            output_format,",
            "            parsed,",
            "            json_indent=json_indent,",
            "            ordered=ordered,",
            "            stringify=stringify,",
            "            yaml_options=yaml_options,",
            "        )",
            "",
            "        output_file.write(encoded)",
            "    finally:",
            "        if input_file is not None:",
            "            input_file.close()",
            "        if output != \"-\" and output_file is not None:",
            "            output_file.close()",
            "",
            "",
            "def main() -> None:",
            "    try:",
            "        run(sys.argv)",
            "    except KeyboardInterrupt:",
            "        pass",
            "    except (OSError, TooManyNodesError, TypeError, ValueError) as e:",
            "        print(f\"Error: {e}\", file=sys.stderr)  # noqa: T201",
            "        sys.exit(1)",
            "",
            "",
            "if __name__ == \"__main__\":",
            "    main()"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "27": [
                "__version__"
            ],
            "704": [
                "main"
            ]
        },
        "addLocation": []
    }
}