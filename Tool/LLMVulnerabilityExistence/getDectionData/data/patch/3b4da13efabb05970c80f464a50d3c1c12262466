{
    "security_monkey/auth/modules.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 240,
                "afterPatchRowNumber": 240,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 241,
                "afterPatchRowNumber": 241,
                "PatchRowcode": "     def _deny_hook(self, resource=None):"
            },
            "2": {
                "beforePatchRowNumber": 242,
                "afterPatchRowNumber": 242,
                "PatchRowcode": "         app = self.get_app()"
            },
            "3": {
                "beforePatchRowNumber": 243,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if current_user.is_authenticated():"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 243,
                "PatchRowcode": "+        if current_user.is_authenticated:"
            },
            "5": {
                "beforePatchRowNumber": 244,
                "afterPatchRowNumber": 244,
                "PatchRowcode": "             status = 403"
            },
            "6": {
                "beforePatchRowNumber": 245,
                "afterPatchRowNumber": 245,
                "PatchRowcode": "         else:"
            },
            "7": {
                "beforePatchRowNumber": 246,
                "afterPatchRowNumber": 246,
                "PatchRowcode": "             status = 401"
            },
            "8": {
                "beforePatchRowNumber": 250,
                "afterPatchRowNumber": 250,
                "PatchRowcode": "                 url = \"https://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('NGINX_PORT'), '/login')"
            },
            "9": {
                "beforePatchRowNumber": 251,
                "afterPatchRowNumber": 251,
                "PatchRowcode": "         else:"
            },
            "10": {
                "beforePatchRowNumber": 252,
                "afterPatchRowNumber": 252,
                "PatchRowcode": "                 url = \"http://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('API_PORT'), '/login')"
            },
            "11": {
                "beforePatchRowNumber": 253,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if current_user.is_authenticated():"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 253,
                "PatchRowcode": "+        if current_user.is_authenticated:"
            },
            "13": {
                "beforePatchRowNumber": 254,
                "afterPatchRowNumber": 254,
                "PatchRowcode": "             auth_dict = {"
            },
            "14": {
                "beforePatchRowNumber": 255,
                "afterPatchRowNumber": 255,
                "PatchRowcode": "                 \"authenticated\": True,"
            },
            "15": {
                "beforePatchRowNumber": 256,
                "afterPatchRowNumber": 256,
                "PatchRowcode": "                 \"user\": current_user.email,"
            }
        },
        "frontPatchFile": [
            "import itertools",
            "",
            "from flask import request, abort, _app_ctx_stack, redirect",
            "from flask_security.core import AnonymousUser",
            "from security_monkey.datastore import User",
            "",
            "try:",
            "    from flask.ext.login import current_user",
            "except ImportError:",
            "    current_user = None",
            "",
            "from .models import RBACRole, RBACUserMixin",
            "",
            "from . import anonymous",
            "",
            "from flask import Response",
            "import json",
            "",
            "",
            "class AccessControlList(object):",
            "    \"\"\"",
            "    This class record rules for access controling.",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        self._allowed = []",
            "        self._exempt = []",
            "        self.seted = False",
            "",
            "    def allow(self, role, method, resource, with_children=True):",
            "        \"\"\"Add allowing rules.",
            "",
            "        :param role: Role of this rule.",
            "        :param method: Method to allow in rule, include GET, POST, PUT etc.",
            "        :param resource: Resource also view function.",
            "        :param with_children: Allow role's children in rule as well",
            "                              if with_children is `True`",
            "        \"\"\"",
            "",
            "        if with_children:",
            "            for r in role.get_children():",
            "                permission = (r.name, method, resource)",
            "                if permission not in self._allowed:",
            "                    self._allowed.append(permission)",
            "        permission = (role.name, method, resource)",
            "        if permission not in self._allowed:",
            "            self._allowed.append(permission)",
            "",
            "    def exempt(self, view_func):",
            "        \"\"\"Exempt a view function from being checked permission",
            "",
            "        :param view_func: The view function exempt from checking.",
            "        \"\"\"",
            "        if not view_func in self._exempt:",
            "            self._exempt.append(view_func)",
            "",
            "    def is_allowed(self, role, method, resource):",
            "        \"\"\"Check whether role is allowed to access resource",
            "",
            "        :param role: Role to be checked.",
            "        :param method: Method to be checked.",
            "        :param resource: View function to be checked.",
            "        \"\"\"",
            "        return (role, method, resource) in self._allowed",
            "",
            "    def is_exempt(self, view_func):",
            "        \"\"\"Return whether view_func is exempted.",
            "",
            "        :param view_func: View function to be checked.",
            "        \"\"\"",
            "        return view_func in self._exempt",
            "",
            "",
            "class _RBACState(object):",
            "    \"\"\"Records configuration for Flask-RBAC\"\"\"",
            "    def __init__(self, rbac, app):",
            "        self.rbac = rbac",
            "        self.app = app",
            "",
            "",
            "class RBAC(object):",
            "    \"\"\"",
            "    This class implements role-based access control module in Flask.",
            "    There are two way to initialize Flask-RBAC::",
            "",
            "        app = Flask(__name__)",
            "        rbac = RBAC(app)",
            "",
            "    :param app: the Flask object",
            "    \"\"\"",
            "",
            "    _role_model = RBACRole",
            "    _user_model = RBACUserMixin",
            "",
            "    def __init__(self, app):",
            "        self.acl = AccessControlList()",
            "        self.before_acl = []",
            "",
            "        self.app = app",
            "        self.init_app(app)",
            "",
            "    def init_app(self, app):",
            "        # Add (RBAC, app) to flask extensions.",
            "        # Add hook to authenticate permission before request.",
            "",
            "        if not hasattr(app, 'extensions'):",
            "            app.extensions = {}",
            "        app.extensions['rbac'] = _RBACState(self, app)",
            "",
            "        self.acl.allow(anonymous, 'GET', app.view_functions['static'].__name__)",
            "        app.before_first_request(self._setup_acl)",
            "        app.before_request(self._authenticate)",
            "",
            "    def has_permission(self, method, endpoint, user=None):",
            "        \"\"\"Return whether the current user can access the resource.",
            "        Example::",
            "",
            "            @app.route('/some_url', methods=['GET', 'POST'])",
            "            @rbac.allow(['anonymous'], ['GET'])",
            "            def a_view_func():",
            "                return Response('Blah Blah...')",
            "",
            "        If you are not logged.",
            "",
            "        `rbac.has_permission('GET', 'a_view_func')` return True.",
            "        `rbac.has_permission('POST', 'a_view_func')` return False.",
            "",
            "        :param method: The method wait to check.",
            "        :param endpoint: The application endpoint.",
            "        :param user: user who you need to check. Current user by default.",
            "        \"\"\"",
            "        app = self.get_app()",
            "        _user = user or current_user",
            "        roles = _user.get_roles()",
            "        view_func = app.view_functions[endpoint]",
            "        return self._check_permission(roles, method, view_func)",
            "",
            "    def check_perm(self, role, method, callback=None):",
            "        def decorator(view_func):",
            "            if not self._check_permission([role], method, view_func):",
            "                if callable(callback):",
            "                    callback()",
            "                else:",
            "                    self._deny_hook()",
            "            return view_func",
            "        return decorator",
            "",
            "    def allow(self, roles, methods, with_children=True):",
            "        \"\"\"Decorator: allow roles to access the view func with it.",
            "",
            "        :param roles: List, each name of roles. Please note that,",
            "                      `anonymous` is refered to anonymous.",
            "                      If you add `anonymous` to the rule,",
            "                      everyone can access the resource,",
            "                      unless you deny other roles.",
            "        :param methods: List, each name of methods.",
            "                        methods is valid in ['GET', 'POST', 'PUT', 'DELETE']",
            "        :param with_children: Whether allow children of roles as well.",
            "                              True by default.",
            "        \"\"\"",
            "        def decorator(view_func):",
            "            _methods = [m.upper() for m in methods]",
            "            for r, m, v in itertools.product(roles, _methods, [view_func.__name__]):",
            "                self.before_acl.append((r, m, v, with_children))",
            "            return view_func",
            "        return decorator",
            "",
            "    def exempt(self, view_func):",
            "        \"\"\"",
            "        Decorator function",
            "        Exempt a view function from being checked permission.",
            "        \"\"\"",
            "        self.acl.exempt(view_func.__name__)",
            "        return view_func",
            "",
            "    def get_app(self, reference_app=None):",
            "        \"\"\"",
            "        Helper to look up an app.",
            "        \"\"\"",
            "        if reference_app is not None:",
            "            return reference_app",
            "        if self.app is not None:",
            "            return self.app",
            "        ctx = _app_ctx_stack.top",
            "        if ctx is not None:",
            "            return ctx.app",
            "        raise RuntimeError('application not registered on rbac '",
            "                           'instance and no application bound '",
            "                           'to current context')",
            "",
            "    def _authenticate(self):",
            "        app = self.get_app()",
            "        assert app, \"Please initialize your application into Flask-RBAC.\"",
            "        assert self._role_model, \"Please set role model before authenticate.\"",
            "        assert self._user_model, \"Please set user model before authenticate.\"",
            "        user = current_user",
            "        if not isinstance(user._get_current_object(), self._user_model) and not isinstance(user._get_current_object(), AnonymousUser):",
            "            raise TypeError(",
            "                \"%s is not an instance of %s\" %",
            "                (user, self._user_model.__class__))",
            "",
            "        endpoint = request.endpoint",
            "        resource = app.view_functions.get(endpoint, None)",
            "",
            "        if not resource:",
            "            abort(404)",
            "",
            "        method = request.method",
            "        if not hasattr(user, 'get_roles'):",
            "            roles = [anonymous]",
            "        else:",
            "            roles = user.get_roles()",
            "",
            "        permit = self._check_permission(roles, method, resource)",
            "        if not permit:",
            "            return self._deny_hook(resource=resource)",
            "",
            "    def _check_permission(self, roles, method, resource):",
            "",
            "        resource = resource.__name__",
            "        if self.acl.is_exempt(resource):",
            "            return True",
            "",
            "        if not self.acl.seted:",
            "            self._setup_acl()",
            "",
            "        _roles = set()",
            "        _methods = {'*', method}",
            "        _resources = {None, resource}",
            "",
            "        _roles.add(anonymous)",
            "",
            "        _roles.update(roles)",
            "",
            "        for r, m, res in itertools.product(_roles, _methods, _resources):",
            "            if self.acl.is_allowed(r.name, m, res):",
            "                return True",
            "",
            "        return False",
            "",
            "    def _deny_hook(self, resource=None):",
            "        app = self.get_app()",
            "        if current_user.is_authenticated():",
            "            status = 403",
            "        else:",
            "            status = 401",
            "        #abort(status)",
            "",
            "        if app.config.get('FRONTED_BY_NGINX'):",
            "                url = \"https://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('NGINX_PORT'), '/login')",
            "        else:",
            "                url = \"http://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('API_PORT'), '/login')",
            "        if current_user.is_authenticated():",
            "            auth_dict = {",
            "                \"authenticated\": True,",
            "                \"user\": current_user.email,",
            "                \"roles\": current_user.role,",
            "            }",
            "        else:",
            "            auth_dict = {",
            "                \"authenticated\": False,",
            "                \"user\": None,",
            "                \"url\": url",
            "            }",
            "",
            "        return Response(response=json.dumps({\"auth\": auth_dict}), status=status, mimetype=\"application/json\")",
            "",
            "",
            "    def _setup_acl(self):",
            "        for rn, method, resource, with_children in self.before_acl:",
            "            role = self._role_model.get_by_name(rn)",
            "            self.acl.allow(role, method, resource, with_children)",
            "        self.acl.seted = True"
        ],
        "afterPatchFile": [
            "import itertools",
            "",
            "from flask import request, abort, _app_ctx_stack, redirect",
            "from flask_security.core import AnonymousUser",
            "from security_monkey.datastore import User",
            "",
            "try:",
            "    from flask.ext.login import current_user",
            "except ImportError:",
            "    current_user = None",
            "",
            "from .models import RBACRole, RBACUserMixin",
            "",
            "from . import anonymous",
            "",
            "from flask import Response",
            "import json",
            "",
            "",
            "class AccessControlList(object):",
            "    \"\"\"",
            "    This class record rules for access controling.",
            "    \"\"\"",
            "",
            "    def __init__(self):",
            "        self._allowed = []",
            "        self._exempt = []",
            "        self.seted = False",
            "",
            "    def allow(self, role, method, resource, with_children=True):",
            "        \"\"\"Add allowing rules.",
            "",
            "        :param role: Role of this rule.",
            "        :param method: Method to allow in rule, include GET, POST, PUT etc.",
            "        :param resource: Resource also view function.",
            "        :param with_children: Allow role's children in rule as well",
            "                              if with_children is `True`",
            "        \"\"\"",
            "",
            "        if with_children:",
            "            for r in role.get_children():",
            "                permission = (r.name, method, resource)",
            "                if permission not in self._allowed:",
            "                    self._allowed.append(permission)",
            "        permission = (role.name, method, resource)",
            "        if permission not in self._allowed:",
            "            self._allowed.append(permission)",
            "",
            "    def exempt(self, view_func):",
            "        \"\"\"Exempt a view function from being checked permission",
            "",
            "        :param view_func: The view function exempt from checking.",
            "        \"\"\"",
            "        if not view_func in self._exempt:",
            "            self._exempt.append(view_func)",
            "",
            "    def is_allowed(self, role, method, resource):",
            "        \"\"\"Check whether role is allowed to access resource",
            "",
            "        :param role: Role to be checked.",
            "        :param method: Method to be checked.",
            "        :param resource: View function to be checked.",
            "        \"\"\"",
            "        return (role, method, resource) in self._allowed",
            "",
            "    def is_exempt(self, view_func):",
            "        \"\"\"Return whether view_func is exempted.",
            "",
            "        :param view_func: View function to be checked.",
            "        \"\"\"",
            "        return view_func in self._exempt",
            "",
            "",
            "class _RBACState(object):",
            "    \"\"\"Records configuration for Flask-RBAC\"\"\"",
            "    def __init__(self, rbac, app):",
            "        self.rbac = rbac",
            "        self.app = app",
            "",
            "",
            "class RBAC(object):",
            "    \"\"\"",
            "    This class implements role-based access control module in Flask.",
            "    There are two way to initialize Flask-RBAC::",
            "",
            "        app = Flask(__name__)",
            "        rbac = RBAC(app)",
            "",
            "    :param app: the Flask object",
            "    \"\"\"",
            "",
            "    _role_model = RBACRole",
            "    _user_model = RBACUserMixin",
            "",
            "    def __init__(self, app):",
            "        self.acl = AccessControlList()",
            "        self.before_acl = []",
            "",
            "        self.app = app",
            "        self.init_app(app)",
            "",
            "    def init_app(self, app):",
            "        # Add (RBAC, app) to flask extensions.",
            "        # Add hook to authenticate permission before request.",
            "",
            "        if not hasattr(app, 'extensions'):",
            "            app.extensions = {}",
            "        app.extensions['rbac'] = _RBACState(self, app)",
            "",
            "        self.acl.allow(anonymous, 'GET', app.view_functions['static'].__name__)",
            "        app.before_first_request(self._setup_acl)",
            "        app.before_request(self._authenticate)",
            "",
            "    def has_permission(self, method, endpoint, user=None):",
            "        \"\"\"Return whether the current user can access the resource.",
            "        Example::",
            "",
            "            @app.route('/some_url', methods=['GET', 'POST'])",
            "            @rbac.allow(['anonymous'], ['GET'])",
            "            def a_view_func():",
            "                return Response('Blah Blah...')",
            "",
            "        If you are not logged.",
            "",
            "        `rbac.has_permission('GET', 'a_view_func')` return True.",
            "        `rbac.has_permission('POST', 'a_view_func')` return False.",
            "",
            "        :param method: The method wait to check.",
            "        :param endpoint: The application endpoint.",
            "        :param user: user who you need to check. Current user by default.",
            "        \"\"\"",
            "        app = self.get_app()",
            "        _user = user or current_user",
            "        roles = _user.get_roles()",
            "        view_func = app.view_functions[endpoint]",
            "        return self._check_permission(roles, method, view_func)",
            "",
            "    def check_perm(self, role, method, callback=None):",
            "        def decorator(view_func):",
            "            if not self._check_permission([role], method, view_func):",
            "                if callable(callback):",
            "                    callback()",
            "                else:",
            "                    self._deny_hook()",
            "            return view_func",
            "        return decorator",
            "",
            "    def allow(self, roles, methods, with_children=True):",
            "        \"\"\"Decorator: allow roles to access the view func with it.",
            "",
            "        :param roles: List, each name of roles. Please note that,",
            "                      `anonymous` is refered to anonymous.",
            "                      If you add `anonymous` to the rule,",
            "                      everyone can access the resource,",
            "                      unless you deny other roles.",
            "        :param methods: List, each name of methods.",
            "                        methods is valid in ['GET', 'POST', 'PUT', 'DELETE']",
            "        :param with_children: Whether allow children of roles as well.",
            "                              True by default.",
            "        \"\"\"",
            "        def decorator(view_func):",
            "            _methods = [m.upper() for m in methods]",
            "            for r, m, v in itertools.product(roles, _methods, [view_func.__name__]):",
            "                self.before_acl.append((r, m, v, with_children))",
            "            return view_func",
            "        return decorator",
            "",
            "    def exempt(self, view_func):",
            "        \"\"\"",
            "        Decorator function",
            "        Exempt a view function from being checked permission.",
            "        \"\"\"",
            "        self.acl.exempt(view_func.__name__)",
            "        return view_func",
            "",
            "    def get_app(self, reference_app=None):",
            "        \"\"\"",
            "        Helper to look up an app.",
            "        \"\"\"",
            "        if reference_app is not None:",
            "            return reference_app",
            "        if self.app is not None:",
            "            return self.app",
            "        ctx = _app_ctx_stack.top",
            "        if ctx is not None:",
            "            return ctx.app",
            "        raise RuntimeError('application not registered on rbac '",
            "                           'instance and no application bound '",
            "                           'to current context')",
            "",
            "    def _authenticate(self):",
            "        app = self.get_app()",
            "        assert app, \"Please initialize your application into Flask-RBAC.\"",
            "        assert self._role_model, \"Please set role model before authenticate.\"",
            "        assert self._user_model, \"Please set user model before authenticate.\"",
            "        user = current_user",
            "        if not isinstance(user._get_current_object(), self._user_model) and not isinstance(user._get_current_object(), AnonymousUser):",
            "            raise TypeError(",
            "                \"%s is not an instance of %s\" %",
            "                (user, self._user_model.__class__))",
            "",
            "        endpoint = request.endpoint",
            "        resource = app.view_functions.get(endpoint, None)",
            "",
            "        if not resource:",
            "            abort(404)",
            "",
            "        method = request.method",
            "        if not hasattr(user, 'get_roles'):",
            "            roles = [anonymous]",
            "        else:",
            "            roles = user.get_roles()",
            "",
            "        permit = self._check_permission(roles, method, resource)",
            "        if not permit:",
            "            return self._deny_hook(resource=resource)",
            "",
            "    def _check_permission(self, roles, method, resource):",
            "",
            "        resource = resource.__name__",
            "        if self.acl.is_exempt(resource):",
            "            return True",
            "",
            "        if not self.acl.seted:",
            "            self._setup_acl()",
            "",
            "        _roles = set()",
            "        _methods = {'*', method}",
            "        _resources = {None, resource}",
            "",
            "        _roles.add(anonymous)",
            "",
            "        _roles.update(roles)",
            "",
            "        for r, m, res in itertools.product(_roles, _methods, _resources):",
            "            if self.acl.is_allowed(r.name, m, res):",
            "                return True",
            "",
            "        return False",
            "",
            "    def _deny_hook(self, resource=None):",
            "        app = self.get_app()",
            "        if current_user.is_authenticated:",
            "            status = 403",
            "        else:",
            "            status = 401",
            "        #abort(status)",
            "",
            "        if app.config.get('FRONTED_BY_NGINX'):",
            "                url = \"https://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('NGINX_PORT'), '/login')",
            "        else:",
            "                url = \"http://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('API_PORT'), '/login')",
            "        if current_user.is_authenticated:",
            "            auth_dict = {",
            "                \"authenticated\": True,",
            "                \"user\": current_user.email,",
            "                \"roles\": current_user.role,",
            "            }",
            "        else:",
            "            auth_dict = {",
            "                \"authenticated\": False,",
            "                \"user\": None,",
            "                \"url\": url",
            "            }",
            "",
            "        return Response(response=json.dumps({\"auth\": auth_dict}), status=status, mimetype=\"application/json\")",
            "",
            "",
            "    def _setup_acl(self):",
            "        for rn, method, resource, with_children in self.before_acl:",
            "            role = self._role_model.get_by_name(rn)",
            "            self.acl.allow(role, method, resource, with_children)",
            "        self.acl.seted = True"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "243": [
                "RBAC",
                "_deny_hook"
            ],
            "253": [
                "RBAC",
                "_deny_hook"
            ]
        },
        "addLocation": []
    },
    "security_monkey/sso/views.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 13,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 14,
                "afterPatchRowNumber": 14,
                "PatchRowcode": " from flask.ext.restful import reqparse, Resource, Api"
            },
            "2": {
                "beforePatchRowNumber": 15,
                "afterPatchRowNumber": 15,
                "PatchRowcode": " from flask.ext.principal import Identity, identity_changed"
            },
            "3": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from flask_login import login_user"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+from flask_security.utils import login_user"
            },
            "5": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "6": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " try:"
            },
            "7": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": "     from onelogin.saml2.auth import OneLogin_Saml2_Auth"
            },
            "8": {
                "beforePatchRowNumber": 264,
                "afterPatchRowNumber": 264,
                "PatchRowcode": "         auth.process_response()"
            },
            "9": {
                "beforePatchRowNumber": 265,
                "afterPatchRowNumber": 265,
                "PatchRowcode": "         errors = auth.get_errors()"
            },
            "10": {
                "beforePatchRowNumber": 266,
                "afterPatchRowNumber": 266,
                "PatchRowcode": "         if not errors:"
            },
            "11": {
                "beforePatchRowNumber": 267,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if auth.is_authenticated():"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 267,
                "PatchRowcode": "+            if auth.is_authenticated:"
            },
            "13": {
                "beforePatchRowNumber": 268,
                "afterPatchRowNumber": 268,
                "PatchRowcode": "                 return True"
            },
            "14": {
                "beforePatchRowNumber": 269,
                "afterPatchRowNumber": 269,
                "PatchRowcode": "             else:"
            },
            "15": {
                "beforePatchRowNumber": 270,
                "afterPatchRowNumber": 270,
                "PatchRowcode": "                 return False"
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            ".. module: security_monkey.sso.views",
            "    :platform: Unix",
            "    :copyright: (c) 2015 by Netflix Inc., see AUTHORS for more",
            "    :license: Apache, see LICENSE for more details.",
            ".. moduleauthor:: Patrick Kelley <patrick@netflix.com>",
            "\"\"\"",
            "import jwt",
            "import base64",
            "import requests",
            "",
            "from flask import Blueprint, current_app, redirect, request",
            "",
            "from flask.ext.restful import reqparse, Resource, Api",
            "from flask.ext.principal import Identity, identity_changed",
            "from flask_login import login_user",
            "",
            "try:",
            "    from onelogin.saml2.auth import OneLogin_Saml2_Auth",
            "    from onelogin.saml2.utils import OneLogin_Saml2_Utils",
            "    onelogin_import_success = True",
            "except ImportError:",
            "    onelogin_import_success = False",
            "",
            "from .service import fetch_token_header_payload, get_rsa_public_key",
            "",
            "from security_monkey.datastore import User",
            "from security_monkey import db, rbac",
            "",
            "from urlparse import urlparse",
            "",
            "mod = Blueprint('sso', __name__)",
            "api = Api(mod)",
            "",
            "",
            "from flask_security.utils import validate_redirect_url",
            "",
            "",
            "class Ping(Resource):",
            "    \"\"\"",
            "    This class serves as an example of how one might implement an SSO provider for use with Security Monkey. In",
            "    this example we use a OpenIDConnect authentication flow, that is essentially OAuth2 underneath.",
            "    \"\"\"",
            "    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]",
            "    def __init__(self):",
            "        self.reqparse = reqparse.RequestParser()",
            "        super(Ping, self).__init__()",
            "",
            "    def get(self):",
            "        return self.post()",
            "",
            "    def post(self):",
            "        if \"ping\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):",
            "            return \"Ping is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404",
            "",
            "        default_state = 'clientId,{client_id},redirectUri,{redirectUri},return_to,{return_to}'.format(",
            "            client_id=current_app.config.get('PING_CLIENT_ID'),",
            "            redirectUri=current_app.config.get('PING_REDIRECT_URI'),",
            "            return_to=current_app.config.get('WEB_PATH')",
            "        )",
            "        self.reqparse.add_argument('code', type=str, required=True)",
            "        self.reqparse.add_argument('state', type=str, required=False, default=default_state)",
            "",
            "        args = self.reqparse.parse_args()",
            "        client_id = args['state'].split(',')[1]",
            "        redirect_uri = args['state'].split(',')[3]",
            "        return_to = args['state'].split(',')[5]",
            "",
            "        if not validate_redirect_url(return_to):",
            "            return_to = current_app.config.get('WEB_PATH')",
            "",
            "        # take the information we have received from the provider to create a new request",
            "        params = {",
            "            'client_id': client_id,",
            "            'grant_type': 'authorization_code',",
            "            'scope': 'openid email profile address',",
            "            'redirect_uri': redirect_uri,",
            "            'code': args['code']",
            "        }",
            "",
            "        # you can either discover these dynamically or simply configure them",
            "        access_token_url = current_app.config.get('PING_ACCESS_TOKEN_URL')",
            "        user_api_url = current_app.config.get('PING_USER_API_URL')",
            "",
            "        # the secret and cliendId will be given to you when you signup for the provider",
            "        basic = base64.b64encode(bytes('{0}:{1}'.format(client_id, current_app.config.get(\"PING_SECRET\"))))",
            "        headers = {'Authorization': 'Basic {0}'.format(basic.decode('utf-8'))}",
            "",
            "        # exchange authorization code for access token.",
            "        r = requests.post(access_token_url, headers=headers, params=params)",
            "        id_token = r.json()['id_token']",
            "        access_token = r.json()['access_token']",
            "",
            "        # fetch token public key",
            "        header_data = fetch_token_header_payload(id_token)[0]",
            "        jwks_url = current_app.config.get('PING_JWKS_URL')",
            "",
            "        # retrieve the key material as specified by the token header",
            "        r = requests.get(jwks_url)",
            "        for key in r.json()['keys']:",
            "            if key['kid'] == header_data['kid']:",
            "                secret = get_rsa_public_key(key['n'], key['e'])",
            "                algo = header_data['alg']",
            "                break",
            "        else:",
            "            return dict(message='Key not found'), 403",
            "",
            "        # validate your token based on the key it was signed with",
            "        try:",
            "            current_app.logger.debug(id_token)",
            "            current_app.logger.debug(secret)",
            "            current_app.logger.debug(algo)",
            "            jwt.decode(id_token, secret.decode('utf-8'), algorithms=[algo], audience=client_id)",
            "        except jwt.DecodeError:",
            "            return dict(message='Token is invalid'), 403",
            "        except jwt.ExpiredSignatureError:",
            "            return dict(message='Token has expired'), 403",
            "        except jwt.InvalidTokenError:",
            "            return dict(message='Token is invalid'), 403",
            "",
            "        user_params = dict(access_token=access_token, schema='profile')",
            "",
            "        # retrieve information about the current user.",
            "        r = requests.get(user_api_url, params=user_params)",
            "        profile = r.json()",
            "",
            "        user = User.query.filter(User.email==profile['email']).first()",
            "",
            "        # if we get an sso user create them an account",
            "        if not user:",
            "            user = User(",
            "                email=profile['email'],",
            "                active=True,",
            "                role='View'",
            "                # profile_picture=profile.get('thumbnailPhotoUrl')",
            "            )",
            "            db.session.add(user)",
            "            db.session.commit()",
            "            db.session.refresh(user)",
            "",
            "        # Tell Flask-Principal the identity changed",
            "        identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))",
            "        login_user(user)",
            "",
            "        return redirect(return_to, code=302)",
            "",
            "",
            "class Google(Resource):",
            "    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]",
            "    def __init__(self):",
            "        self.reqparse = reqparse.RequestParser()",
            "        super(Google, self).__init__()",
            "",
            "    def get(self):",
            "        return self.post()",
            "",
            "    def post(self):",
            "        if \"google\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):",
            "            return \"Google is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404",
            "",
            "        default_state = 'clientId,{client_id},redirectUri,{redirectUri},return_to,{return_to}'.format(",
            "            client_id=current_app.config.get(\"GOOGLE_CLIENT_ID\"),",
            "            redirectUri=api.url_for(Google),",
            "            return_to=current_app.config.get('WEB_PATH')",
            "        )",
            "        self.reqparse.add_argument('code', type=str, required=True)",
            "        self.reqparse.add_argument('state', type=str, required=False, default=default_state)",
            "",
            "        args = self.reqparse.parse_args()",
            "        client_id = args['state'].split(',')[1]",
            "        redirect_uri = args['state'].split(',')[3]",
            "        return_to = args['state'].split(',')[5]",
            "",
            "        if not validate_redirect_url(return_to):",
            "            return_to = current_app.config.get('WEB_PATH')",
            "",
            "        access_token_url = 'https://accounts.google.com/o/oauth2/token'",
            "        people_api_url = 'https://www.googleapis.com/plus/v1/people/me/openIdConnect'",
            "",
            "        args = self.reqparse.parse_args()",
            "",
            "        # Step 1. Exchange authorization code for access token",
            "        payload = {",
            "            'client_id': client_id,",
            "            'grant_type': 'authorization_code',",
            "            'redirect_uri': redirect_uri,",
            "            'code': args['code'],",
            "            'client_secret': current_app.config.get('GOOGLE_SECRET')",
            "        }",
            "",
            "        r = requests.post(access_token_url, data=payload)",
            "        token = r.json()",
            "",
            "        # Step 1bis. Validate (some information of) the id token (if necessary)",
            "        google_hosted_domain = current_app.config.get(\"GOOGLE_HOSTED_DOMAIN\")",
            "        if google_hosted_domain is not None:",
            "            current_app.logger.debug('We need to verify that the token was issued for this hosted domain: %s ' % (google_hosted_domain))",
            "",
            "\t    # Get the JSON Web Token",
            "            id_token = r.json()['id_token']",
            "            current_app.logger.debug('The id_token is: %s' % (id_token))",
            "",
            "            # Extract the payload",
            "            (header_data, payload_data) = fetch_token_header_payload(id_token)",
            "            current_app.logger.debug('id_token.header_data: %s' % (header_data))",
            "            current_app.logger.debug('id_token.payload_data: %s' % (payload_data))",
            "",
            "            token_hd = payload_data.get('hd')",
            "            if token_hd != google_hosted_domain:",
            "                current_app.logger.debug('Verification failed: %s != %s' % (token_hd, google_hosted_domain))",
            "                return dict(message='Token is invalid %s' % token), 403",
            "            current_app.logger.debug('Verification passed')",
            "",
            "        # Step 2. Retrieve information about the current user",
            "        headers = {'Authorization': 'Bearer {0}'.format(token['access_token'])}",
            "",
            "        r = requests.get(people_api_url, headers=headers)",
            "        profile = r.json()",
            "",
            "        user = User.query.filter(User.email == profile['email']).first()",
            "",
            "        # if we get an sso user create them an account",
            "        if not user:",
            "            user = User(",
            "                email=profile['email'],",
            "                active=True,",
            "                role='View'",
            "                # profile_picture=profile.get('thumbnailPhotoUrl')",
            "            )",
            "            db.session.add(user)",
            "            db.session.commit()",
            "            db.session.refresh(user)",
            "",
            "        # Tell Flask-Principal the identity changed",
            "        identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))",
            "        login_user(user)",
            "",
            "        return redirect(return_to, code=302)",
            "",
            "",
            "class OneLogin(Resource):",
            "    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]",
            "    def __init__(self):",
            "        self.reqparse = reqparse.RequestParser()",
            "        self.req = OneLogin.prepare_from_flask_request(request)",
            "        super(OneLogin, self).__init__()",
            "",
            "    @staticmethod",
            "    def prepare_from_flask_request(req):",
            "        url_data = urlparse(req.url)",
            "        return {",
            "            'http_host': req.host,",
            "            'server_port': url_data.port,",
            "            'script_name': req.path,",
            "            'get_data': req.args.copy(),",
            "            'post_data': req.form.copy(),",
            "            'https': (\"on\" if current_app.config.get(\"ONELOGIN_HTTPS\") else \"off\")",
            "    }",
            "",
            "    def get(self):",
            "        return self.post()",
            "",
            "    def _consumer(self, auth):",
            "        auth.process_response()",
            "        errors = auth.get_errors()",
            "        if not errors:",
            "            if auth.is_authenticated():",
            "                return True",
            "            else:",
            "                return False",
            "        else:",
            "            current_app.logger.error('Error processing %s' % (', '.join(errors)))",
            "            return False",
            "",
            "    def post(self):",
            "        if \"onelogin\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):",
            "            return \"Onelogin is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404",
            "        auth = OneLogin_Saml2_Auth(self.req, current_app.config.get(\"ONELOGIN_SETTINGS\"))",
            "",
            "        self.reqparse.add_argument('return_to', required=False, default=current_app.config.get('WEB_PATH'))",
            "        self.reqparse.add_argument('acs', required=False)",
            "        self.reqparse.add_argument('sls', required=False)",
            "",
            "        args = self.reqparse.parse_args()",
            "",
            "        return_to = args['return_to']",
            "",
            "        if args['acs'] != None:",
            "            # valids the SAML response and checks if successfully authenticated",
            "            if self._consumer(auth):",
            "                email = auth.get_attribute(current_app.config.get(\"ONELOGIN_EMAIL_FIELD\"))[0]",
            "                user = User.query.filter(User.email == email).first()",
            "",
            "                # if we get an sso user create them an account",
            "                if not user:",
            "                    user = User(",
            "                        email=email,",
            "                        active=True,",
            "                        role=current_app.config.get('ONELOGIN_DEFAULT_ROLE')",
            "                        # profile_picture=profile.get('thumbnailPhotoUrl')",
            "                    )",
            "                    db.session.add(user)",
            "                    db.session.commit()",
            "                    db.session.refresh(user)",
            "",
            "                # Tell Flask-Principal the identity changed",
            "                identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))",
            "                login_user(user)",
            "",
            "                self_url = OneLogin_Saml2_Utils.get_self_url(self.req)",
            "                if 'RelayState' in request.form and self_url != request.form['RelayState']:",
            "                    return redirect(auth.redirect_to(request.form['RelayState']), code=302)",
            "                else:  ",
            "                    return redirect(current_app.config.get('BASE_URL'), code=302)",
            "            else:",
            "                return dict(message='OneLogin authentication failed.'), 403",
            "        elif args['sls'] != None:",
            "            return dict(message='OneLogin SLS not implemented yet.'), 405",
            "        else:",
            "            return redirect(auth.login(return_to=return_to))",
            "",
            "",
            "class Providers(Resource):",
            "    decorators = [rbac.allow([\"anonymous\"], [\"GET\"])]",
            "    def __init__(self):",
            "        super(Providers, self).__init__()",
            "",
            "    def get(self):",
            "        active_providers = []",
            "",
            "        for provider in current_app.config.get(\"ACTIVE_PROVIDERS\"):",
            "            provider = provider.lower()",
            "",
            "            if provider == \"ping\":",
            "                active_providers.append({",
            "                    'name': current_app.config.get(\"PING_NAME\"),",
            "                    'url': current_app.config.get('PING_REDIRECT_URI'),",
            "                    'redirectUri': current_app.config.get(\"PING_REDIRECT_URI\"),",
            "                    'clientId': current_app.config.get(\"PING_CLIENT_ID\"),",
            "                    'responseType': 'code',",
            "                    'scope': ['openid', 'profile', 'email'],",
            "                    'scopeDelimiter': ' ',",
            "                    'authorizationEndpoint': current_app.config.get(\"PING_AUTH_ENDPOINT\"),",
            "                    'requiredUrlParams': ['scope'],",
            "                    'type': '2.0'",
            "                })",
            "            elif provider == \"google\":",
            "                google_provider = {",
            "                    'name': 'google',",
            "                    'clientId': current_app.config.get(\"GOOGLE_CLIENT_ID\"),",
            "                    'url': api.url_for(Google, _external=True, _scheme='https'),",
            "                    'redirectUri': api.url_for(Google, _external=True, _scheme='https'),",
            "                    'authorizationEndpoint': current_app.config.get(\"GOOGLE_AUTH_ENDPOINT\"),",
            "                    'scope': ['openid email'],",
            "                    'responseType': 'code'",
            "                }",
            "                google_hosted_domain = current_app.config.get(\"GOOGLE_HOSTED_DOMAIN\")",
            "                if google_hosted_domain is not None:",
            "                    google_provider['hd'] = google_hosted_domain",
            "                active_providers.append(google_provider)",
            "            elif provider == \"onelogin\":",
            "                active_providers.append({",
            "                    'name': 'OneLogin',",
            "                    'authorizationEndpoint': api.url_for(OneLogin)",
            "                })",
            "            else:",
            "                raise Exception(\"Unknown authentication provider: {0}\".format(provider))",
            "",
            "        return active_providers",
            "",
            "",
            "api.add_resource(Ping, '/auth/ping', endpoint='ping')",
            "api.add_resource(Google, '/auth/google', endpoint='google')",
            "api.add_resource(Providers, '/auth/providers', endpoint='providers')",
            "",
            "if onelogin_import_success:",
            "    api.add_resource(OneLogin, '/auth/onelogin', endpoint='onelogin')"
        ],
        "afterPatchFile": [
            "\"\"\"",
            ".. module: security_monkey.sso.views",
            "    :platform: Unix",
            "    :copyright: (c) 2015 by Netflix Inc., see AUTHORS for more",
            "    :license: Apache, see LICENSE for more details.",
            ".. moduleauthor:: Patrick Kelley <patrick@netflix.com>",
            "\"\"\"",
            "import jwt",
            "import base64",
            "import requests",
            "",
            "from flask import Blueprint, current_app, redirect, request",
            "",
            "from flask.ext.restful import reqparse, Resource, Api",
            "from flask.ext.principal import Identity, identity_changed",
            "from flask_security.utils import login_user",
            "",
            "try:",
            "    from onelogin.saml2.auth import OneLogin_Saml2_Auth",
            "    from onelogin.saml2.utils import OneLogin_Saml2_Utils",
            "    onelogin_import_success = True",
            "except ImportError:",
            "    onelogin_import_success = False",
            "",
            "from .service import fetch_token_header_payload, get_rsa_public_key",
            "",
            "from security_monkey.datastore import User",
            "from security_monkey import db, rbac",
            "",
            "from urlparse import urlparse",
            "",
            "mod = Blueprint('sso', __name__)",
            "api = Api(mod)",
            "",
            "",
            "from flask_security.utils import validate_redirect_url",
            "",
            "",
            "class Ping(Resource):",
            "    \"\"\"",
            "    This class serves as an example of how one might implement an SSO provider for use with Security Monkey. In",
            "    this example we use a OpenIDConnect authentication flow, that is essentially OAuth2 underneath.",
            "    \"\"\"",
            "    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]",
            "    def __init__(self):",
            "        self.reqparse = reqparse.RequestParser()",
            "        super(Ping, self).__init__()",
            "",
            "    def get(self):",
            "        return self.post()",
            "",
            "    def post(self):",
            "        if \"ping\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):",
            "            return \"Ping is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404",
            "",
            "        default_state = 'clientId,{client_id},redirectUri,{redirectUri},return_to,{return_to}'.format(",
            "            client_id=current_app.config.get('PING_CLIENT_ID'),",
            "            redirectUri=current_app.config.get('PING_REDIRECT_URI'),",
            "            return_to=current_app.config.get('WEB_PATH')",
            "        )",
            "        self.reqparse.add_argument('code', type=str, required=True)",
            "        self.reqparse.add_argument('state', type=str, required=False, default=default_state)",
            "",
            "        args = self.reqparse.parse_args()",
            "        client_id = args['state'].split(',')[1]",
            "        redirect_uri = args['state'].split(',')[3]",
            "        return_to = args['state'].split(',')[5]",
            "",
            "        if not validate_redirect_url(return_to):",
            "            return_to = current_app.config.get('WEB_PATH')",
            "",
            "        # take the information we have received from the provider to create a new request",
            "        params = {",
            "            'client_id': client_id,",
            "            'grant_type': 'authorization_code',",
            "            'scope': 'openid email profile address',",
            "            'redirect_uri': redirect_uri,",
            "            'code': args['code']",
            "        }",
            "",
            "        # you can either discover these dynamically or simply configure them",
            "        access_token_url = current_app.config.get('PING_ACCESS_TOKEN_URL')",
            "        user_api_url = current_app.config.get('PING_USER_API_URL')",
            "",
            "        # the secret and cliendId will be given to you when you signup for the provider",
            "        basic = base64.b64encode(bytes('{0}:{1}'.format(client_id, current_app.config.get(\"PING_SECRET\"))))",
            "        headers = {'Authorization': 'Basic {0}'.format(basic.decode('utf-8'))}",
            "",
            "        # exchange authorization code for access token.",
            "        r = requests.post(access_token_url, headers=headers, params=params)",
            "        id_token = r.json()['id_token']",
            "        access_token = r.json()['access_token']",
            "",
            "        # fetch token public key",
            "        header_data = fetch_token_header_payload(id_token)[0]",
            "        jwks_url = current_app.config.get('PING_JWKS_URL')",
            "",
            "        # retrieve the key material as specified by the token header",
            "        r = requests.get(jwks_url)",
            "        for key in r.json()['keys']:",
            "            if key['kid'] == header_data['kid']:",
            "                secret = get_rsa_public_key(key['n'], key['e'])",
            "                algo = header_data['alg']",
            "                break",
            "        else:",
            "            return dict(message='Key not found'), 403",
            "",
            "        # validate your token based on the key it was signed with",
            "        try:",
            "            current_app.logger.debug(id_token)",
            "            current_app.logger.debug(secret)",
            "            current_app.logger.debug(algo)",
            "            jwt.decode(id_token, secret.decode('utf-8'), algorithms=[algo], audience=client_id)",
            "        except jwt.DecodeError:",
            "            return dict(message='Token is invalid'), 403",
            "        except jwt.ExpiredSignatureError:",
            "            return dict(message='Token has expired'), 403",
            "        except jwt.InvalidTokenError:",
            "            return dict(message='Token is invalid'), 403",
            "",
            "        user_params = dict(access_token=access_token, schema='profile')",
            "",
            "        # retrieve information about the current user.",
            "        r = requests.get(user_api_url, params=user_params)",
            "        profile = r.json()",
            "",
            "        user = User.query.filter(User.email==profile['email']).first()",
            "",
            "        # if we get an sso user create them an account",
            "        if not user:",
            "            user = User(",
            "                email=profile['email'],",
            "                active=True,",
            "                role='View'",
            "                # profile_picture=profile.get('thumbnailPhotoUrl')",
            "            )",
            "            db.session.add(user)",
            "            db.session.commit()",
            "            db.session.refresh(user)",
            "",
            "        # Tell Flask-Principal the identity changed",
            "        identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))",
            "        login_user(user)",
            "",
            "        return redirect(return_to, code=302)",
            "",
            "",
            "class Google(Resource):",
            "    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]",
            "    def __init__(self):",
            "        self.reqparse = reqparse.RequestParser()",
            "        super(Google, self).__init__()",
            "",
            "    def get(self):",
            "        return self.post()",
            "",
            "    def post(self):",
            "        if \"google\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):",
            "            return \"Google is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404",
            "",
            "        default_state = 'clientId,{client_id},redirectUri,{redirectUri},return_to,{return_to}'.format(",
            "            client_id=current_app.config.get(\"GOOGLE_CLIENT_ID\"),",
            "            redirectUri=api.url_for(Google),",
            "            return_to=current_app.config.get('WEB_PATH')",
            "        )",
            "        self.reqparse.add_argument('code', type=str, required=True)",
            "        self.reqparse.add_argument('state', type=str, required=False, default=default_state)",
            "",
            "        args = self.reqparse.parse_args()",
            "        client_id = args['state'].split(',')[1]",
            "        redirect_uri = args['state'].split(',')[3]",
            "        return_to = args['state'].split(',')[5]",
            "",
            "        if not validate_redirect_url(return_to):",
            "            return_to = current_app.config.get('WEB_PATH')",
            "",
            "        access_token_url = 'https://accounts.google.com/o/oauth2/token'",
            "        people_api_url = 'https://www.googleapis.com/plus/v1/people/me/openIdConnect'",
            "",
            "        args = self.reqparse.parse_args()",
            "",
            "        # Step 1. Exchange authorization code for access token",
            "        payload = {",
            "            'client_id': client_id,",
            "            'grant_type': 'authorization_code',",
            "            'redirect_uri': redirect_uri,",
            "            'code': args['code'],",
            "            'client_secret': current_app.config.get('GOOGLE_SECRET')",
            "        }",
            "",
            "        r = requests.post(access_token_url, data=payload)",
            "        token = r.json()",
            "",
            "        # Step 1bis. Validate (some information of) the id token (if necessary)",
            "        google_hosted_domain = current_app.config.get(\"GOOGLE_HOSTED_DOMAIN\")",
            "        if google_hosted_domain is not None:",
            "            current_app.logger.debug('We need to verify that the token was issued for this hosted domain: %s ' % (google_hosted_domain))",
            "",
            "\t    # Get the JSON Web Token",
            "            id_token = r.json()['id_token']",
            "            current_app.logger.debug('The id_token is: %s' % (id_token))",
            "",
            "            # Extract the payload",
            "            (header_data, payload_data) = fetch_token_header_payload(id_token)",
            "            current_app.logger.debug('id_token.header_data: %s' % (header_data))",
            "            current_app.logger.debug('id_token.payload_data: %s' % (payload_data))",
            "",
            "            token_hd = payload_data.get('hd')",
            "            if token_hd != google_hosted_domain:",
            "                current_app.logger.debug('Verification failed: %s != %s' % (token_hd, google_hosted_domain))",
            "                return dict(message='Token is invalid %s' % token), 403",
            "            current_app.logger.debug('Verification passed')",
            "",
            "        # Step 2. Retrieve information about the current user",
            "        headers = {'Authorization': 'Bearer {0}'.format(token['access_token'])}",
            "",
            "        r = requests.get(people_api_url, headers=headers)",
            "        profile = r.json()",
            "",
            "        user = User.query.filter(User.email == profile['email']).first()",
            "",
            "        # if we get an sso user create them an account",
            "        if not user:",
            "            user = User(",
            "                email=profile['email'],",
            "                active=True,",
            "                role='View'",
            "                # profile_picture=profile.get('thumbnailPhotoUrl')",
            "            )",
            "            db.session.add(user)",
            "            db.session.commit()",
            "            db.session.refresh(user)",
            "",
            "        # Tell Flask-Principal the identity changed",
            "        identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))",
            "        login_user(user)",
            "",
            "        return redirect(return_to, code=302)",
            "",
            "",
            "class OneLogin(Resource):",
            "    decorators = [rbac.allow([\"anonymous\"], [\"GET\", \"POST\"])]",
            "    def __init__(self):",
            "        self.reqparse = reqparse.RequestParser()",
            "        self.req = OneLogin.prepare_from_flask_request(request)",
            "        super(OneLogin, self).__init__()",
            "",
            "    @staticmethod",
            "    def prepare_from_flask_request(req):",
            "        url_data = urlparse(req.url)",
            "        return {",
            "            'http_host': req.host,",
            "            'server_port': url_data.port,",
            "            'script_name': req.path,",
            "            'get_data': req.args.copy(),",
            "            'post_data': req.form.copy(),",
            "            'https': (\"on\" if current_app.config.get(\"ONELOGIN_HTTPS\") else \"off\")",
            "    }",
            "",
            "    def get(self):",
            "        return self.post()",
            "",
            "    def _consumer(self, auth):",
            "        auth.process_response()",
            "        errors = auth.get_errors()",
            "        if not errors:",
            "            if auth.is_authenticated:",
            "                return True",
            "            else:",
            "                return False",
            "        else:",
            "            current_app.logger.error('Error processing %s' % (', '.join(errors)))",
            "            return False",
            "",
            "    def post(self):",
            "        if \"onelogin\" not in current_app.config.get(\"ACTIVE_PROVIDERS\"):",
            "            return \"Onelogin is not enabled in the config.  See the ACTIVE_PROVIDERS section.\", 404",
            "        auth = OneLogin_Saml2_Auth(self.req, current_app.config.get(\"ONELOGIN_SETTINGS\"))",
            "",
            "        self.reqparse.add_argument('return_to', required=False, default=current_app.config.get('WEB_PATH'))",
            "        self.reqparse.add_argument('acs', required=False)",
            "        self.reqparse.add_argument('sls', required=False)",
            "",
            "        args = self.reqparse.parse_args()",
            "",
            "        return_to = args['return_to']",
            "",
            "        if args['acs'] != None:",
            "            # valids the SAML response and checks if successfully authenticated",
            "            if self._consumer(auth):",
            "                email = auth.get_attribute(current_app.config.get(\"ONELOGIN_EMAIL_FIELD\"))[0]",
            "                user = User.query.filter(User.email == email).first()",
            "",
            "                # if we get an sso user create them an account",
            "                if not user:",
            "                    user = User(",
            "                        email=email,",
            "                        active=True,",
            "                        role=current_app.config.get('ONELOGIN_DEFAULT_ROLE')",
            "                        # profile_picture=profile.get('thumbnailPhotoUrl')",
            "                    )",
            "                    db.session.add(user)",
            "                    db.session.commit()",
            "                    db.session.refresh(user)",
            "",
            "                # Tell Flask-Principal the identity changed",
            "                identity_changed.send(current_app._get_current_object(), identity=Identity(user.id))",
            "                login_user(user)",
            "",
            "                self_url = OneLogin_Saml2_Utils.get_self_url(self.req)",
            "                if 'RelayState' in request.form and self_url != request.form['RelayState']:",
            "                    return redirect(auth.redirect_to(request.form['RelayState']), code=302)",
            "                else:  ",
            "                    return redirect(current_app.config.get('BASE_URL'), code=302)",
            "            else:",
            "                return dict(message='OneLogin authentication failed.'), 403",
            "        elif args['sls'] != None:",
            "            return dict(message='OneLogin SLS not implemented yet.'), 405",
            "        else:",
            "            return redirect(auth.login(return_to=return_to))",
            "",
            "",
            "class Providers(Resource):",
            "    decorators = [rbac.allow([\"anonymous\"], [\"GET\"])]",
            "    def __init__(self):",
            "        super(Providers, self).__init__()",
            "",
            "    def get(self):",
            "        active_providers = []",
            "",
            "        for provider in current_app.config.get(\"ACTIVE_PROVIDERS\"):",
            "            provider = provider.lower()",
            "",
            "            if provider == \"ping\":",
            "                active_providers.append({",
            "                    'name': current_app.config.get(\"PING_NAME\"),",
            "                    'url': current_app.config.get('PING_REDIRECT_URI'),",
            "                    'redirectUri': current_app.config.get(\"PING_REDIRECT_URI\"),",
            "                    'clientId': current_app.config.get(\"PING_CLIENT_ID\"),",
            "                    'responseType': 'code',",
            "                    'scope': ['openid', 'profile', 'email'],",
            "                    'scopeDelimiter': ' ',",
            "                    'authorizationEndpoint': current_app.config.get(\"PING_AUTH_ENDPOINT\"),",
            "                    'requiredUrlParams': ['scope'],",
            "                    'type': '2.0'",
            "                })",
            "            elif provider == \"google\":",
            "                google_provider = {",
            "                    'name': 'google',",
            "                    'clientId': current_app.config.get(\"GOOGLE_CLIENT_ID\"),",
            "                    'url': api.url_for(Google, _external=True, _scheme='https'),",
            "                    'redirectUri': api.url_for(Google, _external=True, _scheme='https'),",
            "                    'authorizationEndpoint': current_app.config.get(\"GOOGLE_AUTH_ENDPOINT\"),",
            "                    'scope': ['openid email'],",
            "                    'responseType': 'code'",
            "                }",
            "                google_hosted_domain = current_app.config.get(\"GOOGLE_HOSTED_DOMAIN\")",
            "                if google_hosted_domain is not None:",
            "                    google_provider['hd'] = google_hosted_domain",
            "                active_providers.append(google_provider)",
            "            elif provider == \"onelogin\":",
            "                active_providers.append({",
            "                    'name': 'OneLogin',",
            "                    'authorizationEndpoint': api.url_for(OneLogin)",
            "                })",
            "            else:",
            "                raise Exception(\"Unknown authentication provider: {0}\".format(provider))",
            "",
            "        return active_providers",
            "",
            "",
            "api.add_resource(Ping, '/auth/ping', endpoint='ping')",
            "api.add_resource(Google, '/auth/google', endpoint='google')",
            "api.add_resource(Providers, '/auth/providers', endpoint='providers')",
            "",
            "if onelogin_import_success:",
            "    api.add_resource(OneLogin, '/auth/onelogin', endpoint='onelogin')"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "16": [],
            "267": [
                "OneLogin",
                "_consumer"
            ]
        },
        "addLocation": []
    },
    "security_monkey/views/__init__.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 144,
                "PatchRowcode": "         self.reqparse = reqparse.RequestParser()"
            },
            "1": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "         super(AuthenticatedService, self).__init__()"
            },
            "2": {
                "beforePatchRowNumber": 146,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "         self.auth_dict = dict()"
            },
            "3": {
                "beforePatchRowNumber": 147,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if current_user.is_authenticated():"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 147,
                "PatchRowcode": "+        if current_user.is_authenticated:"
            },
            "5": {
                "beforePatchRowNumber": 148,
                "afterPatchRowNumber": 148,
                "PatchRowcode": "             roles_marshal = []"
            },
            "6": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 149,
                "PatchRowcode": "             for role in current_user.roles:"
            },
            "7": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 150,
                "PatchRowcode": "                 roles_marshal.append(marshal(role.__dict__, ROLE_FIELDS))"
            }
        },
        "frontPatchFile": [
            "#     Copyright 2014 Netflix, Inc.",
            "#",
            "#     Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#     you may not use this file except in compliance with the License.",
            "#     You may obtain a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#     Unless required by applicable law or agreed to in writing, software",
            "#     distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "#     See the License for the specific language governing permissions and",
            "#     limitations under the License.",
            "",
            "from security_monkey import app, db",
            "from flask_wtf.csrf import generate_csrf",
            "from security_monkey.auth.models import RBACRole",
            "from security_monkey.decorators import crossdomain",
            "",
            "from flask_restful import fields, marshal, Resource, reqparse",
            "from flask_login import current_user",
            "",
            "ORIGINS = [",
            "    'https://{}:{}'.format(app.config.get('FQDN'), app.config.get('WEB_PORT')),",
            "    # Adding this next one so you can also access the dart UI by prepending /static to the path.",
            "    'https://{}:{}'.format(app.config.get('FQDN'), app.config.get('API_PORT')),",
            "    'https://{}:{}'.format(app.config.get('FQDN'), app.config.get('NGINX_PORT')),",
            "    'https://{}:80'.format(app.config.get('FQDN'))",
            "]",
            "",
            "##### Marshal Datastructures #####",
            "",
            "# Used by RevisionGet, RevisionList, ItemList",
            "REVISION_FIELDS = {",
            "    'id': fields.Integer,",
            "    'date_created': fields.String,",
            "    'date_last_ephemeral_change': fields.String,",
            "    'active': fields.Boolean,",
            "    'item_id': fields.Integer",
            "}",
            "",
            "# Used by RevisionList, ItemGet, ItemList",
            "ITEM_FIELDS = {",
            "    'id': fields.Integer,",
            "    'region': fields.String,",
            "    'name': fields.String",
            "}",
            "",
            "# Used by ItemList, Justify",
            "AUDIT_FIELDS = {",
            "    'id': fields.Integer,",
            "    'score': fields.Integer,",
            "    'issue': fields.String,",
            "    'notes': fields.String,",
            "    'justified': fields.Boolean,",
            "    'justification': fields.String,",
            "    'justified_date': fields.String,",
            "    'item_id': fields.Integer",
            "}",
            "",
            "## Single Use Marshal Objects ##",
            "",
            "# SINGLE USE - RevisionGet",
            "REVISION_COMMENT_FIELDS = {",
            "    'id': fields.Integer,",
            "    'revision_id': fields.Integer,",
            "    'date_created': fields.String,",
            "    'text': fields.String",
            "}",
            "",
            "# SINGLE USE - ItemGet",
            "ITEM_COMMENT_FIELDS = {",
            "    'id': fields.Integer,",
            "    'date_created': fields.String,",
            "    'text': fields.String,",
            "    'item_id': fields.Integer",
            "}",
            "",
            "# SINGLE USE - UserSettings",
            "USER_SETTINGS_FIELDS = {",
            "    # 'id': fields.Integer,",
            "    'daily_audit_email': fields.Boolean,",
            "    'change_reports': fields.String",
            "}",
            "",
            "# SINGLE USE - AccountGet",
            "ACCOUNT_FIELDS = {",
            "    'id': fields.Integer,",
            "    'name': fields.String,",
            "    'identifier': fields.String,",
            "    'notes': fields.String,",
            "    'active': fields.Boolean,",
            "    'third_party': fields.Boolean,",
            "    'account_type': fields.String",
            "}",
            "",
            "USER_FIELDS = {",
            "    'id': fields.Integer,",
            "    'active': fields.Boolean,",
            "    'email': fields.String,",
            "    'role': fields.String,",
            "    'confirmed_at': fields.String,",
            "    'daily_audit_email': fields.Boolean,",
            "    'change_reports': fields.String,",
            "    'last_login_at': fields.String,",
            "    'current_login_at': fields.String,",
            "    'login_count': fields.Integer,",
            "    'last_login_ip': fields.String,",
            "    'current_login_ip': fields.String",
            "}",
            "",
            "ROLE_FIELDS = {",
            "    'id': fields.Integer,",
            "    'name': fields.String,",
            "    'description': fields.String,",
            "}",
            "",
            "WHITELIST_FIELDS = {",
            "    'id': fields.Integer,",
            "    'name': fields.String,",
            "    'notes': fields.String,",
            "    'cidr': fields.String",
            "}",
            "",
            "IGNORELIST_FIELDS = {",
            "    'id': fields.Integer,",
            "    'prefix': fields.String,",
            "    'notes': fields.String,",
            "}",
            "",
            "AUDITORSETTING_FIELDS = {",
            "    'id': fields.Integer,",
            "    'disabled': fields.Boolean,",
            "    'issue_text': fields.String",
            "}",
            "",
            "ITEM_LINK_FIELDS = {",
            "    'id': fields.Integer,",
            "    'name': fields.String",
            "}",
            "",
            "class AuthenticatedService(Resource):",
            "    def __init__(self):",
            "        self.reqparse = reqparse.RequestParser()",
            "        super(AuthenticatedService, self).__init__()",
            "        self.auth_dict = dict()",
            "        if current_user.is_authenticated():",
            "            roles_marshal = []",
            "            for role in current_user.roles:",
            "                roles_marshal.append(marshal(role.__dict__, ROLE_FIELDS))",
            "",
            "            roles_marshal.append({\"name\": current_user.role})",
            "",
            "            for role in RBACRole.roles[current_user.role].get_parents():",
            "                roles_marshal.append({\"name\": role.name})",
            "",
            "            self.auth_dict = {",
            "                \"authenticated\": True,",
            "                \"user\": current_user.email,",
            "                \"roles\": roles_marshal",
            "            }",
            "        else:",
            "            if app.config.get('FRONTED_BY_NGINX'):",
            "                url = \"https://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('NGINX_PORT'), '/login')",
            "            else:",
            "                url = \"http://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('API_PORT'), '/login')",
            "            self.auth_dict = {",
            "                \"authenticated\": False,",
            "                \"user\": None,",
            "                \"url\": url",
            "            }",
            "",
            "",
            "@app.after_request",
            "@crossdomain(allowed_origins=ORIGINS)",
            "def after(response):",
            "    response.set_cookie('XSRF-COOKIE', generate_csrf())",
            "    return response"
        ],
        "afterPatchFile": [
            "#     Copyright 2014 Netflix, Inc.",
            "#",
            "#     Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#     you may not use this file except in compliance with the License.",
            "#     You may obtain a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#     Unless required by applicable law or agreed to in writing, software",
            "#     distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "#     See the License for the specific language governing permissions and",
            "#     limitations under the License.",
            "",
            "from security_monkey import app, db",
            "from flask_wtf.csrf import generate_csrf",
            "from security_monkey.auth.models import RBACRole",
            "from security_monkey.decorators import crossdomain",
            "",
            "from flask_restful import fields, marshal, Resource, reqparse",
            "from flask_login import current_user",
            "",
            "ORIGINS = [",
            "    'https://{}:{}'.format(app.config.get('FQDN'), app.config.get('WEB_PORT')),",
            "    # Adding this next one so you can also access the dart UI by prepending /static to the path.",
            "    'https://{}:{}'.format(app.config.get('FQDN'), app.config.get('API_PORT')),",
            "    'https://{}:{}'.format(app.config.get('FQDN'), app.config.get('NGINX_PORT')),",
            "    'https://{}:80'.format(app.config.get('FQDN'))",
            "]",
            "",
            "##### Marshal Datastructures #####",
            "",
            "# Used by RevisionGet, RevisionList, ItemList",
            "REVISION_FIELDS = {",
            "    'id': fields.Integer,",
            "    'date_created': fields.String,",
            "    'date_last_ephemeral_change': fields.String,",
            "    'active': fields.Boolean,",
            "    'item_id': fields.Integer",
            "}",
            "",
            "# Used by RevisionList, ItemGet, ItemList",
            "ITEM_FIELDS = {",
            "    'id': fields.Integer,",
            "    'region': fields.String,",
            "    'name': fields.String",
            "}",
            "",
            "# Used by ItemList, Justify",
            "AUDIT_FIELDS = {",
            "    'id': fields.Integer,",
            "    'score': fields.Integer,",
            "    'issue': fields.String,",
            "    'notes': fields.String,",
            "    'justified': fields.Boolean,",
            "    'justification': fields.String,",
            "    'justified_date': fields.String,",
            "    'item_id': fields.Integer",
            "}",
            "",
            "## Single Use Marshal Objects ##",
            "",
            "# SINGLE USE - RevisionGet",
            "REVISION_COMMENT_FIELDS = {",
            "    'id': fields.Integer,",
            "    'revision_id': fields.Integer,",
            "    'date_created': fields.String,",
            "    'text': fields.String",
            "}",
            "",
            "# SINGLE USE - ItemGet",
            "ITEM_COMMENT_FIELDS = {",
            "    'id': fields.Integer,",
            "    'date_created': fields.String,",
            "    'text': fields.String,",
            "    'item_id': fields.Integer",
            "}",
            "",
            "# SINGLE USE - UserSettings",
            "USER_SETTINGS_FIELDS = {",
            "    # 'id': fields.Integer,",
            "    'daily_audit_email': fields.Boolean,",
            "    'change_reports': fields.String",
            "}",
            "",
            "# SINGLE USE - AccountGet",
            "ACCOUNT_FIELDS = {",
            "    'id': fields.Integer,",
            "    'name': fields.String,",
            "    'identifier': fields.String,",
            "    'notes': fields.String,",
            "    'active': fields.Boolean,",
            "    'third_party': fields.Boolean,",
            "    'account_type': fields.String",
            "}",
            "",
            "USER_FIELDS = {",
            "    'id': fields.Integer,",
            "    'active': fields.Boolean,",
            "    'email': fields.String,",
            "    'role': fields.String,",
            "    'confirmed_at': fields.String,",
            "    'daily_audit_email': fields.Boolean,",
            "    'change_reports': fields.String,",
            "    'last_login_at': fields.String,",
            "    'current_login_at': fields.String,",
            "    'login_count': fields.Integer,",
            "    'last_login_ip': fields.String,",
            "    'current_login_ip': fields.String",
            "}",
            "",
            "ROLE_FIELDS = {",
            "    'id': fields.Integer,",
            "    'name': fields.String,",
            "    'description': fields.String,",
            "}",
            "",
            "WHITELIST_FIELDS = {",
            "    'id': fields.Integer,",
            "    'name': fields.String,",
            "    'notes': fields.String,",
            "    'cidr': fields.String",
            "}",
            "",
            "IGNORELIST_FIELDS = {",
            "    'id': fields.Integer,",
            "    'prefix': fields.String,",
            "    'notes': fields.String,",
            "}",
            "",
            "AUDITORSETTING_FIELDS = {",
            "    'id': fields.Integer,",
            "    'disabled': fields.Boolean,",
            "    'issue_text': fields.String",
            "}",
            "",
            "ITEM_LINK_FIELDS = {",
            "    'id': fields.Integer,",
            "    'name': fields.String",
            "}",
            "",
            "class AuthenticatedService(Resource):",
            "    def __init__(self):",
            "        self.reqparse = reqparse.RequestParser()",
            "        super(AuthenticatedService, self).__init__()",
            "        self.auth_dict = dict()",
            "        if current_user.is_authenticated:",
            "            roles_marshal = []",
            "            for role in current_user.roles:",
            "                roles_marshal.append(marshal(role.__dict__, ROLE_FIELDS))",
            "",
            "            roles_marshal.append({\"name\": current_user.role})",
            "",
            "            for role in RBACRole.roles[current_user.role].get_parents():",
            "                roles_marshal.append({\"name\": role.name})",
            "",
            "            self.auth_dict = {",
            "                \"authenticated\": True,",
            "                \"user\": current_user.email,",
            "                \"roles\": roles_marshal",
            "            }",
            "        else:",
            "            if app.config.get('FRONTED_BY_NGINX'):",
            "                url = \"https://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('NGINX_PORT'), '/login')",
            "            else:",
            "                url = \"http://{}:{}{}\".format(app.config.get('FQDN'), app.config.get('API_PORT'), '/login')",
            "            self.auth_dict = {",
            "                \"authenticated\": False,",
            "                \"user\": None,",
            "                \"url\": url",
            "            }",
            "",
            "",
            "@app.after_request",
            "@crossdomain(allowed_origins=ORIGINS)",
            "def after(response):",
            "    response.set_cookie('XSRF-COOKIE', generate_csrf())",
            "    return response"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "147": [
                "AuthenticatedService",
                "__init__"
            ]
        },
        "addLocation": []
    },
    "security_monkey/views/logout.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "     decorators = [rbac.exempt]"
            },
            "1": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": 26,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "     def get(self):"
            },
            "3": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if not current_user.is_authenticated():"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 28,
                "PatchRowcode": "+        if not current_user.is_authenticated:"
            },
            "5": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "             return \"Must be logged in to log out\", 200"
            },
            "6": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 30,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "         logout_user()"
            }
        },
        "frontPatchFile": [
            "#     Copyright 2014 Netflix, Inc.",
            "#",
            "#     Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#     you may not use this file except in compliance with the License.",
            "#     You may obtain a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#     Unless required by applicable law or agreed to in writing, software",
            "#     distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "#     See the License for the specific language governing permissions and",
            "#     limitations under the License.",
            "",
            "from flask_login import current_user, logout_user",
            "from flask_restful import Resource",
            "",
            "",
            "# End the Flask-Logins session",
            "from security_monkey import rbac",
            "",
            "",
            "class Logout(Resource):",
            "",
            "    decorators = [rbac.exempt]",
            "",
            "    def get(self):",
            "        if not current_user.is_authenticated():",
            "            return \"Must be logged in to log out\", 200",
            "",
            "        logout_user()",
            "        return \"Logged Out\", 200"
        ],
        "afterPatchFile": [
            "#     Copyright 2014 Netflix, Inc.",
            "#",
            "#     Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#     you may not use this file except in compliance with the License.",
            "#     You may obtain a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#     Unless required by applicable law or agreed to in writing, software",
            "#     distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "#     See the License for the specific language governing permissions and",
            "#     limitations under the License.",
            "",
            "from flask_login import current_user, logout_user",
            "from flask_restful import Resource",
            "",
            "",
            "# End the Flask-Logins session",
            "from security_monkey import rbac",
            "",
            "",
            "class Logout(Resource):",
            "",
            "    decorators = [rbac.exempt]",
            "",
            "    def get(self):",
            "        if not current_user.is_authenticated:",
            "            return \"Must be logged in to log out\", 200",
            "",
            "        logout_user()",
            "        return \"Logged Out\", 200"
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "28": [
                "Logout",
                "get"
            ]
        },
        "addLocation": []
    },
    "setup.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 23,
                "PatchRowcode": "     install_requires=["
            },
            "1": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 24,
                "PatchRowcode": "         'APScheduler==2.1.2',"
            },
            "2": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 25,
                "PatchRowcode": "         'Flask==0.10.1',"
            },
            "3": {
                "beforePatchRowNumber": 26,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        'Flask-Login==0.2.10',"
            },
            "4": {
                "beforePatchRowNumber": 27,
                "afterPatchRowNumber": 26,
                "PatchRowcode": "         'Flask-Mail==0.9.0',"
            },
            "5": {
                "beforePatchRowNumber": 28,
                "afterPatchRowNumber": 27,
                "PatchRowcode": "         'Flask-Migrate==1.3.1',"
            },
            "6": {
                "beforePatchRowNumber": 29,
                "afterPatchRowNumber": 28,
                "PatchRowcode": "         'Flask-Principal==0.4.0',"
            },
            "7": {
                "beforePatchRowNumber": 30,
                "afterPatchRowNumber": 29,
                "PatchRowcode": "         'Flask-RESTful==0.3.3',"
            },
            "8": {
                "beforePatchRowNumber": 31,
                "afterPatchRowNumber": 30,
                "PatchRowcode": "         'Flask-SQLAlchemy==1.0',"
            },
            "9": {
                "beforePatchRowNumber": 32,
                "afterPatchRowNumber": 31,
                "PatchRowcode": "         'Flask-Script==0.6.3',"
            },
            "10": {
                "beforePatchRowNumber": 33,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        'Flask-Security==1.7.4',"
            },
            "11": {
                "beforePatchRowNumber": 34,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        'Flask-WTF==0.9.5',"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 32,
                "PatchRowcode": "+        # 'Flask-Security==1.7.4',"
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 33,
                "PatchRowcode": "+        'Flask-Security-Fork==1.8.2',"
            },
            "14": {
                "beforePatchRowNumber": 35,
                "afterPatchRowNumber": 34,
                "PatchRowcode": "         'Jinja2==2.8',"
            },
            "15": {
                "beforePatchRowNumber": 36,
                "afterPatchRowNumber": 35,
                "PatchRowcode": "         'SQLAlchemy==0.9.2',"
            },
            "16": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 36,
                "PatchRowcode": "         'boto>=2.41.0',"
            },
            "17": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 37,
                "PatchRowcode": "         'ipaddr==2.1.11',"
            },
            "18": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 38,
                "PatchRowcode": "         'itsdangerous==0.23',"
            },
            "19": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        'psycopg2==2.5.2',"
            },
            "20": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        'bcrypt==2.0.0',"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 39,
                "PatchRowcode": "+        'psycopg2==2.6.2',"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 40,
                "PatchRowcode": "+        'bcrypt==3.1.2',"
            },
            "23": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 41,
                "PatchRowcode": "         'Sphinx==1.2.2',"
            },
            "24": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 42,
                "PatchRowcode": "         'gunicorn==18.0',"
            },
            "25": {
                "beforePatchRowNumber": 44,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        'cryptography==1.3.2',"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 43,
                "PatchRowcode": "+        'cryptography==1.7.1',"
            },
            "27": {
                "beforePatchRowNumber": 45,
                "afterPatchRowNumber": 44,
                "PatchRowcode": "         'boto3>=1.4.2',"
            },
            "28": {
                "beforePatchRowNumber": 46,
                "afterPatchRowNumber": 45,
                "PatchRowcode": "         'botocore>=1.4.81',"
            },
            "29": {
                "beforePatchRowNumber": 47,
                "afterPatchRowNumber": 46,
                "PatchRowcode": "         'dpath==1.3.2',"
            }
        },
        "frontPatchFile": [
            "#     Copyright 2014 Netflix, Inc.",
            "#",
            "#     Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#     you may not use this file except in compliance with the License.",
            "#     You may obtain a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#     Unless required by applicable law or agreed to in writing, software",
            "#     distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "#     See the License for the specific language governing permissions and",
            "#     limitations under the License.",
            "from setuptools import setup",
            "",
            "setup(",
            "    name='security_monkey',",
            "    version='0.8.0',",
            "    long_description=__doc__,",
            "    packages=['security_monkey'],",
            "    include_package_data=True,",
            "    zip_safe=False,",
            "    install_requires=[",
            "        'APScheduler==2.1.2',",
            "        'Flask==0.10.1',",
            "        'Flask-Login==0.2.10',",
            "        'Flask-Mail==0.9.0',",
            "        'Flask-Migrate==1.3.1',",
            "        'Flask-Principal==0.4.0',",
            "        'Flask-RESTful==0.3.3',",
            "        'Flask-SQLAlchemy==1.0',",
            "        'Flask-Script==0.6.3',",
            "        'Flask-Security==1.7.4',",
            "        'Flask-WTF==0.9.5',",
            "        'Jinja2==2.8',",
            "        'SQLAlchemy==0.9.2',",
            "        'boto>=2.41.0',",
            "        'ipaddr==2.1.11',",
            "        'itsdangerous==0.23',",
            "        'psycopg2==2.5.2',",
            "        'bcrypt==2.0.0',",
            "        'Sphinx==1.2.2',",
            "        'gunicorn==18.0',",
            "        'cryptography==1.3.2',",
            "        'boto3>=1.4.2',",
            "        'botocore>=1.4.81',",
            "        'dpath==1.3.2',",
            "        'pyyaml==3.11',",
            "        'jira==0.32',",
            "        'cloudaux>=1.0.6',",
            "        'joblib>=0.9.4',",
            "        'pyjwt>=1.01',",
            "    ],",
            "    extras_require = {",
            "        'onelogin': ['python-saml>=2.2.0'],",
            "        'tests': [",
            "            'nose==1.3.0',",
            "            'mock==1.0.1',",
            "            'moto==0.4.30',",
            "            'freezegun>=0.3.7'",
            "        ]",
            "    }",
            ")"
        ],
        "afterPatchFile": [
            "#     Copyright 2014 Netflix, Inc.",
            "#",
            "#     Licensed under the Apache License, Version 2.0 (the \"License\");",
            "#     you may not use this file except in compliance with the License.",
            "#     You may obtain a copy of the License at",
            "#",
            "#         http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "#     Unless required by applicable law or agreed to in writing, software",
            "#     distributed under the License is distributed on an \"AS IS\" BASIS,",
            "#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "#     See the License for the specific language governing permissions and",
            "#     limitations under the License.",
            "from setuptools import setup",
            "",
            "setup(",
            "    name='security_monkey',",
            "    version='0.8.0',",
            "    long_description=__doc__,",
            "    packages=['security_monkey'],",
            "    include_package_data=True,",
            "    zip_safe=False,",
            "    install_requires=[",
            "        'APScheduler==2.1.2',",
            "        'Flask==0.10.1',",
            "        'Flask-Mail==0.9.0',",
            "        'Flask-Migrate==1.3.1',",
            "        'Flask-Principal==0.4.0',",
            "        'Flask-RESTful==0.3.3',",
            "        'Flask-SQLAlchemy==1.0',",
            "        'Flask-Script==0.6.3',",
            "        # 'Flask-Security==1.7.4',",
            "        'Flask-Security-Fork==1.8.2',",
            "        'Jinja2==2.8',",
            "        'SQLAlchemy==0.9.2',",
            "        'boto>=2.41.0',",
            "        'ipaddr==2.1.11',",
            "        'itsdangerous==0.23',",
            "        'psycopg2==2.6.2',",
            "        'bcrypt==3.1.2',",
            "        'Sphinx==1.2.2',",
            "        'gunicorn==18.0',",
            "        'cryptography==1.7.1',",
            "        'boto3>=1.4.2',",
            "        'botocore>=1.4.81',",
            "        'dpath==1.3.2',",
            "        'pyyaml==3.11',",
            "        'jira==0.32',",
            "        'cloudaux>=1.0.6',",
            "        'joblib>=0.9.4',",
            "        'pyjwt>=1.01',",
            "    ],",
            "    extras_require = {",
            "        'onelogin': ['python-saml>=2.2.0'],",
            "        'tests': [",
            "            'nose==1.3.0',",
            "            'mock==1.0.1',",
            "            'moto==0.4.30',",
            "            'freezegun>=0.3.7'",
            "        ]",
            "    }",
            ")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "26": [],
            "33": [],
            "34": [],
            "40": [],
            "41": [],
            "44": []
        },
        "addLocation": []
    }
}