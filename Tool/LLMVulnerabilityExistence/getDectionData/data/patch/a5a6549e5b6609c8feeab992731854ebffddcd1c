{
    "airflow/providers/mongo/hooks/mongo.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": 19,
                "PatchRowcode": " from __future__ import annotations"
            },
            "1": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " "
            },
            "2": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " import warnings"
            },
            "3": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from ssl import CERT_NONE"
            },
            "4": {
                "beforePatchRowNumber": 23,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " from typing import TYPE_CHECKING, Any, overload"
            },
            "5": {
                "beforePatchRowNumber": 24,
                "afterPatchRowNumber": 23,
                "PatchRowcode": " from urllib.parse import quote_plus, urlunsplit"
            },
            "6": {
                "beforePatchRowNumber": 25,
                "afterPatchRowNumber": 24,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 49,
                "afterPatchRowNumber": 48,
                "PatchRowcode": "     ex."
            },
            "8": {
                "beforePatchRowNumber": 50,
                "afterPatchRowNumber": 49,
                "PatchRowcode": "         {\"srv\": true, \"replicaSet\": \"test\", \"ssl\": true, \"connectTimeoutMS\": 30000}"
            },
            "9": {
                "beforePatchRowNumber": 51,
                "afterPatchRowNumber": 50,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 51,
                "PatchRowcode": "+    For enabling SSL, the `\"ssl\": true` option can be used within the connection string options, under extra."
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 52,
                "PatchRowcode": "+    In scenarios where SSL is enabled, `allow_insecure` option is not included by default in the connection"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 53,
                "PatchRowcode": "+    unless specified. This is so that we ensure a secure medium while handling connections to MongoDB."
            },
            "13": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 54,
                "PatchRowcode": "+"
            },
            "14": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 55,
                "PatchRowcode": "+    The `allow_insecure` only makes sense in ssl context and is configurable and can be used in one of"
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 56,
                "PatchRowcode": "+    the following scenarios:"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 57,
                "PatchRowcode": "+"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 58,
                "PatchRowcode": "+    HTTP (ssl = False)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 59,
                "PatchRowcode": "+    Here, `ssl` is disabled and using `allow_insecure` doesn't make sense."
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 60,
                "PatchRowcode": "+    Example connection extra: {\"ssl\": false}"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 62,
                "PatchRowcode": "+    HTTPS, but insecure (ssl = True, allow_insecure = True)"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 63,
                "PatchRowcode": "+    Here, `ssl` is enabled, and the connection allows insecure connections."
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 64,
                "PatchRowcode": "+    Example connection extra: {\"ssl\": true, \"allow_insecure\": true}"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 65,
                "PatchRowcode": "+"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 66,
                "PatchRowcode": "+    HTTPS, but secure (ssl = True, allow_insecure = False - default when SSL enabled):"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 67,
                "PatchRowcode": "+    Here, `ssl` is enabled, and the connection does not allow insecure connections (default behavior when"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 68,
                "PatchRowcode": "+    SSL is enabled). Example connection extra: {\"ssl\": true} or {\"ssl\": true, \"allow_insecure\": false}"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+    Note: `tls` is an alias to `ssl` and can be used in place of `ssl`. Example: {\"ssl\": false} or"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+    {\"tls\": false}."
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": 52,
                "afterPatchRowNumber": 73,
                "PatchRowcode": "     :param mongo_conn_id: The :ref:`Mongo connection id <howto/connection:mongo>` to use"
            },
            "33": {
                "beforePatchRowNumber": 53,
                "afterPatchRowNumber": 74,
                "PatchRowcode": "         when connecting to MongoDB."
            },
            "34": {
                "beforePatchRowNumber": 54,
                "afterPatchRowNumber": 75,
                "PatchRowcode": "     \"\"\""
            },
            "35": {
                "beforePatchRowNumber": 75,
                "afterPatchRowNumber": 96,
                "PatchRowcode": "         self.client: MongoClient | None = None"
            },
            "36": {
                "beforePatchRowNumber": 76,
                "afterPatchRowNumber": 97,
                "PatchRowcode": "         self.uri = self._create_uri()"
            },
            "37": {
                "beforePatchRowNumber": 77,
                "afterPatchRowNumber": 98,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 99,
                "PatchRowcode": "+        self.allow_insecure = self.extras.pop(\"allow_insecure\", \"false\").lower() == \"true\""
            },
            "39": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 100,
                "PatchRowcode": "+        self.ssl_enabled = ("
            },
            "40": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 101,
                "PatchRowcode": "+            self.extras.get(\"ssl\", \"false\").lower() == \"true\""
            },
            "41": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 102,
                "PatchRowcode": "+            or self.extras.get(\"tls\", \"false\").lower() == \"true\""
            },
            "42": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 103,
                "PatchRowcode": "+        )"
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 104,
                "PatchRowcode": "+"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 105,
                "PatchRowcode": "+        if self.ssl_enabled and not self.allow_insecure:"
            },
            "45": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 106,
                "PatchRowcode": "+            # Case: HTTPS"
            },
            "46": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 107,
                "PatchRowcode": "+            self.allow_insecure = False"
            },
            "47": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 108,
                "PatchRowcode": "+        elif self.ssl_enabled and self.allow_insecure:"
            },
            "48": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 109,
                "PatchRowcode": "+            # Case: HTTPS + allow_insecure"
            },
            "49": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 110,
                "PatchRowcode": "+            self.allow_insecure = True"
            },
            "50": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 111,
                "PatchRowcode": "+            self.extras.pop(\"ssl\", None)"
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 112,
                "PatchRowcode": "+        elif not self.ssl_enabled and \"allow_insecure\" in self.extras:"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 113,
                "PatchRowcode": "+            # Case: HTTP (ssl=False) with allow_insecure specified"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 114,
                "PatchRowcode": "+            self.log.warning(\"allow_insecure is only applicable when ssl is set\")"
            },
            "54": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 115,
                "PatchRowcode": "+            self.extras.pop(\"allow_insecure\", None)"
            },
            "55": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 116,
                "PatchRowcode": "+        elif not self.ssl_enabled:"
            },
            "56": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 117,
                "PatchRowcode": "+            # Case: HTTP (ssl=False) with allow_insecure not specified"
            },
            "57": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 118,
                "PatchRowcode": "+            self.allow_insecure = False"
            },
            "58": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 119,
                "PatchRowcode": "+"
            },
            "59": {
                "beforePatchRowNumber": 78,
                "afterPatchRowNumber": 120,
                "PatchRowcode": "     def __enter__(self):"
            },
            "60": {
                "beforePatchRowNumber": 79,
                "afterPatchRowNumber": 121,
                "PatchRowcode": "         return self"
            },
            "61": {
                "beforePatchRowNumber": 80,
                "afterPatchRowNumber": 122,
                "PatchRowcode": " "
            },
            "62": {
                "beforePatchRowNumber": 96,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "         # Mongo Connection Options dict that is unpacked when passed to MongoClient"
            },
            "63": {
                "beforePatchRowNumber": 97,
                "afterPatchRowNumber": 139,
                "PatchRowcode": "         options = self.extras"
            },
            "64": {
                "beforePatchRowNumber": 98,
                "afterPatchRowNumber": 140,
                "PatchRowcode": " "
            },
            "65": {
                "beforePatchRowNumber": 99,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        # If we are using SSL disable requiring certs from specific hostname"
            },
            "66": {
                "beforePatchRowNumber": 100,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-        if options.get(\"ssl\", False):"
            },
            "67": {
                "beforePatchRowNumber": 101,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            if pymongo.__version__ >= \"4.0.0\":"
            },
            "68": {
                "beforePatchRowNumber": 102,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # In pymongo 4.0.0+ `tlsAllowInvalidCertificates=True`"
            },
            "69": {
                "beforePatchRowNumber": 103,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                # replaces `ssl_cert_reqs=CERT_NONE`"
            },
            "70": {
                "beforePatchRowNumber": 104,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                options.update({\"tlsAllowInvalidCertificates\": True})"
            },
            "71": {
                "beforePatchRowNumber": 105,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-            else:"
            },
            "72": {
                "beforePatchRowNumber": 106,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-                options.update({\"ssl_cert_reqs\": CERT_NONE})"
            },
            "73": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 141,
                "PatchRowcode": "+        # Set tlsAllowInvalidCertificates based on allow_insecure"
            },
            "74": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 142,
                "PatchRowcode": "+        if self.allow_insecure:"
            },
            "75": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 143,
                "PatchRowcode": "+            options[\"tlsAllowInvalidCertificates\"] = True"
            },
            "76": {
                "beforePatchRowNumber": 107,
                "afterPatchRowNumber": 144,
                "PatchRowcode": " "
            },
            "77": {
                "beforePatchRowNumber": 108,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "         self.client = MongoClient(self.uri, **options)"
            },
            "78": {
                "beforePatchRowNumber": 109,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "         return self.client"
            }
        },
        "frontPatchFile": [
            "#",
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "\"\"\"Hook for Mongo DB.\"\"\"",
            "from __future__ import annotations",
            "",
            "import warnings",
            "from ssl import CERT_NONE",
            "from typing import TYPE_CHECKING, Any, overload",
            "from urllib.parse import quote_plus, urlunsplit",
            "",
            "import pymongo",
            "from pymongo import MongoClient, ReplaceOne",
            "",
            "from airflow.exceptions import AirflowProviderDeprecationWarning",
            "from airflow.hooks.base import BaseHook",
            "",
            "if TYPE_CHECKING:",
            "    from types import TracebackType",
            "",
            "    from typing_extensions import Literal",
            "",
            "",
            "class MongoHook(BaseHook):",
            "    \"\"\"",
            "    PyMongo wrapper to interact with MongoDB.",
            "",
            "    Mongo Connection Documentation",
            "    https://docs.mongodb.com/manual/reference/connection-string/index.html",
            "    You can specify connection string options in extra field of your connection",
            "    https://docs.mongodb.com/manual/reference/connection-string/index.html#connection-string-options",
            "",
            "    If you want use DNS seedlist, set `srv` to True.",
            "",
            "    ex.",
            "        {\"srv\": true, \"replicaSet\": \"test\", \"ssl\": true, \"connectTimeoutMS\": 30000}",
            "",
            "    :param mongo_conn_id: The :ref:`Mongo connection id <howto/connection:mongo>` to use",
            "        when connecting to MongoDB.",
            "    \"\"\"",
            "",
            "    conn_name_attr = \"mongo_conn_id\"",
            "    default_conn_name = \"mongo_default\"",
            "    conn_type = \"mongo\"",
            "    hook_name = \"MongoDB\"",
            "",
            "    def __init__(self, mongo_conn_id: str = default_conn_name, *args, **kwargs) -> None:",
            "        super().__init__()",
            "        if conn_id := kwargs.pop(\"conn_id\", None):",
            "            warnings.warn(",
            "                \"Parameter `conn_id` is deprecated and will be removed in a future releases. \"",
            "                \"Please use `mongo_conn_id` instead.\",",
            "                AirflowProviderDeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            mongo_conn_id = conn_id",
            "",
            "        self.mongo_conn_id = mongo_conn_id",
            "        self.connection = self.get_connection(self.mongo_conn_id)",
            "        self.extras = self.connection.extra_dejson.copy()",
            "        self.client: MongoClient | None = None",
            "        self.uri = self._create_uri()",
            "",
            "    def __enter__(self):",
            "        return self",
            "",
            "    def __exit__(",
            "        self,",
            "        exc_type: type[BaseException] | None,",
            "        exc_val: BaseException | None,",
            "        exc_tb: TracebackType | None,",
            "    ) -> None:",
            "        if self.client is not None:",
            "            self.client.close()",
            "            self.client = None",
            "",
            "    def get_conn(self) -> MongoClient:",
            "        \"\"\"Fetches PyMongo Client.\"\"\"",
            "        if self.client is not None:",
            "            return self.client",
            "",
            "        # Mongo Connection Options dict that is unpacked when passed to MongoClient",
            "        options = self.extras",
            "",
            "        # If we are using SSL disable requiring certs from specific hostname",
            "        if options.get(\"ssl\", False):",
            "            if pymongo.__version__ >= \"4.0.0\":",
            "                # In pymongo 4.0.0+ `tlsAllowInvalidCertificates=True`",
            "                # replaces `ssl_cert_reqs=CERT_NONE`",
            "                options.update({\"tlsAllowInvalidCertificates\": True})",
            "            else:",
            "                options.update({\"ssl_cert_reqs\": CERT_NONE})",
            "",
            "        self.client = MongoClient(self.uri, **options)",
            "        return self.client",
            "",
            "    def _create_uri(self) -> str:",
            "        \"\"\"",
            "        Create URI string from the given credentials.",
            "",
            "        :return: URI string.",
            "        \"\"\"",
            "        srv = self.extras.pop(\"srv\", False)",
            "        scheme = \"mongodb+srv\" if srv else \"mongodb\"",
            "        login = self.connection.login",
            "        password = self.connection.password",
            "        netloc = self.connection.host",
            "        if login is not None and password is not None:",
            "            netloc = f\"{quote_plus(login)}:{quote_plus(password)}@{netloc}\"",
            "        if self.connection.port:",
            "            netloc = f\"{netloc}:{self.connection.port}\"",
            "        path = f\"/{self.connection.schema}\"",
            "        return urlunsplit((scheme, netloc, path, \"\", \"\"))",
            "",
            "    def get_collection(",
            "        self, mongo_collection: str, mongo_db: str | None = None",
            "    ) -> pymongo.collection.Collection:",
            "        \"\"\"",
            "        Fetches a mongo collection object for querying.",
            "",
            "        Uses connection schema as DB unless specified.",
            "        \"\"\"",
            "        mongo_db = mongo_db or self.connection.schema",
            "        mongo_conn: MongoClient = self.get_conn()",
            "",
            "        return mongo_conn.get_database(mongo_db).get_collection(mongo_collection)",
            "",
            "    def aggregate(",
            "        self, mongo_collection: str, aggregate_query: list, mongo_db: str | None = None, **kwargs",
            "    ) -> pymongo.command_cursor.CommandCursor:",
            "        \"\"\"",
            "        Runs an aggregation pipeline and returns the results.",
            "",
            "        https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.aggregate",
            "        https://pymongo.readthedocs.io/en/stable/examples/aggregation.html",
            "        \"\"\"",
            "        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)",
            "",
            "        return collection.aggregate(aggregate_query, **kwargs)",
            "",
            "    @overload",
            "    def find(",
            "        self,",
            "        mongo_collection: str,",
            "        query: dict,",
            "        find_one: Literal[False],",
            "        mongo_db: str | None = None,",
            "        projection: list | dict | None = None,",
            "        **kwargs,",
            "    ) -> pymongo.cursor.Cursor:",
            "        ...",
            "",
            "    @overload",
            "    def find(",
            "        self,",
            "        mongo_collection: str,",
            "        query: dict,",
            "        find_one: Literal[True],",
            "        mongo_db: str | None = None,",
            "        projection: list | dict | None = None,",
            "        **kwargs,",
            "    ) -> Any | None:",
            "        ...",
            "",
            "    def find(",
            "        self,",
            "        mongo_collection: str,",
            "        query: dict,",
            "        find_one: bool = False,",
            "        mongo_db: str | None = None,",
            "        projection: list | dict | None = None,",
            "        **kwargs,",
            "    ) -> pymongo.cursor.Cursor | Any | None:",
            "        \"\"\"",
            "        Runs a mongo find query and returns the results.",
            "",
            "        https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.find",
            "        \"\"\"",
            "        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)",
            "",
            "        if find_one:",
            "            return collection.find_one(query, projection, **kwargs)",
            "        else:",
            "            return collection.find(query, projection, **kwargs)",
            "",
            "    def insert_one(",
            "        self, mongo_collection: str, doc: dict, mongo_db: str | None = None, **kwargs",
            "    ) -> pymongo.results.InsertOneResult:",
            "        \"\"\"",
            "        Inserts a single document into a mongo collection.",
            "",
            "        https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.insert_one",
            "        \"\"\"",
            "        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)",
            "",
            "        return collection.insert_one(doc, **kwargs)",
            "",
            "    def insert_many(",
            "        self, mongo_collection: str, docs: dict, mongo_db: str | None = None, **kwargs",
            "    ) -> pymongo.results.InsertManyResult:",
            "        \"\"\"",
            "        Inserts many docs into a mongo collection.",
            "",
            "        https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.insert_many",
            "        \"\"\"",
            "        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)",
            "",
            "        return collection.insert_many(docs, **kwargs)",
            "",
            "    def update_one(",
            "        self,",
            "        mongo_collection: str,",
            "        filter_doc: dict,",
            "        update_doc: dict,",
            "        mongo_db: str | None = None,",
            "        **kwargs,",
            "    ) -> pymongo.results.UpdateResult:",
            "        \"\"\"",
            "        Updates a single document in a mongo collection.",
            "",
            "        https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.update_one",
            "",
            "        :param mongo_collection: The name of the collection to update.",
            "        :param filter_doc: A query that matches the documents to update.",
            "        :param update_doc: The modifications to apply.",
            "        :param mongo_db: The name of the database to use.",
            "            Can be omitted; then the database from the connection string is used.",
            "",
            "        \"\"\"",
            "        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)",
            "",
            "        return collection.update_one(filter_doc, update_doc, **kwargs)",
            "",
            "    def update_many(",
            "        self,",
            "        mongo_collection: str,",
            "        filter_doc: dict,",
            "        update_doc: dict,",
            "        mongo_db: str | None = None,",
            "        **kwargs,",
            "    ) -> pymongo.results.UpdateResult:",
            "        \"\"\"",
            "        Updates one or more documents in a mongo collection.",
            "",
            "        https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.update_many",
            "",
            "        :param mongo_collection: The name of the collection to update.",
            "        :param filter_doc: A query that matches the documents to update.",
            "        :param update_doc: The modifications to apply.",
            "        :param mongo_db: The name of the database to use.",
            "            Can be omitted; then the database from the connection string is used.",
            "        \"\"\"",
            "        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)",
            "",
            "        return collection.update_many(filter_doc, update_doc, **kwargs)",
            "",
            "    def replace_one(",
            "        self,",
            "        mongo_collection: str,",
            "        doc: dict,",
            "        filter_doc: dict | None = None,",
            "        mongo_db: str | None = None,",
            "        **kwargs,",
            "    ) -> pymongo.results.UpdateResult:",
            "        \"\"\"",
            "        Replaces a single document in a mongo collection.",
            "",
            "        https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.replace_one",
            "",
            "        .. note::",
            "            If no ``filter_doc`` is given, it is assumed that the replacement",
            "            document contain the ``_id`` field which is then used as filters.",
            "",
            "        :param mongo_collection: The name of the collection to update.",
            "        :param doc: The new document.",
            "        :param filter_doc: A query that matches the documents to replace.",
            "            Can be omitted; then the _id field from doc will be used.",
            "        :param mongo_db: The name of the database to use.",
            "            Can be omitted; then the database from the connection string is used.",
            "        \"\"\"",
            "        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)",
            "",
            "        if not filter_doc:",
            "            filter_doc = {\"_id\": doc[\"_id\"]}",
            "",
            "        return collection.replace_one(filter_doc, doc, **kwargs)",
            "",
            "    def replace_many(",
            "        self,",
            "        mongo_collection: str,",
            "        docs: list[dict],",
            "        filter_docs: list[dict] | None = None,",
            "        mongo_db: str | None = None,",
            "        upsert: bool = False,",
            "        collation: pymongo.collation.Collation | None = None,",
            "        **kwargs,",
            "    ) -> pymongo.results.BulkWriteResult:",
            "        \"\"\"",
            "        Replaces many documents in a mongo collection.",
            "",
            "        Uses bulk_write with multiple ReplaceOne operations",
            "        https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.bulk_write",
            "",
            "        .. note::",
            "            If no ``filter_docs``are given, it is assumed that all",
            "            replacement documents contain the ``_id`` field which are then",
            "            used as filters.",
            "",
            "        :param mongo_collection: The name of the collection to update.",
            "        :param docs: The new documents.",
            "        :param filter_docs: A list of queries that match the documents to replace.",
            "            Can be omitted; then the _id fields from airflow.docs will be used.",
            "        :param mongo_db: The name of the database to use.",
            "            Can be omitted; then the database from the connection string is used.",
            "        :param upsert: If ``True``, perform an insert if no documents",
            "            match the filters for the replace operation.",
            "        :param collation: An instance of",
            "            :class:`~pymongo.collation.Collation`. This option is only",
            "            supported on MongoDB 3.4 and above.",
            "        \"\"\"",
            "        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)",
            "",
            "        if not filter_docs:",
            "            filter_docs = [{\"_id\": doc[\"_id\"]} for doc in docs]",
            "",
            "        requests = [",
            "            ReplaceOne(filter_docs[i], docs[i], upsert=upsert, collation=collation) for i in range(len(docs))",
            "        ]",
            "",
            "        return collection.bulk_write(requests, **kwargs)",
            "",
            "    def delete_one(",
            "        self, mongo_collection: str, filter_doc: dict, mongo_db: str | None = None, **kwargs",
            "    ) -> pymongo.results.DeleteResult:",
            "        \"\"\"",
            "        Deletes a single document in a mongo collection.",
            "",
            "        https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.delete_one",
            "",
            "        :param mongo_collection: The name of the collection to delete from.",
            "        :param filter_doc: A query that matches the document to delete.",
            "        :param mongo_db: The name of the database to use.",
            "            Can be omitted; then the database from the connection string is used.",
            "        \"\"\"",
            "        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)",
            "",
            "        return collection.delete_one(filter_doc, **kwargs)",
            "",
            "    def delete_many(",
            "        self, mongo_collection: str, filter_doc: dict, mongo_db: str | None = None, **kwargs",
            "    ) -> pymongo.results.DeleteResult:",
            "        \"\"\"",
            "        Deletes one or more documents in a mongo collection.",
            "",
            "        https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.delete_many",
            "",
            "        :param mongo_collection: The name of the collection to delete from.",
            "        :param filter_doc: A query that matches the documents to delete.",
            "        :param mongo_db: The name of the database to use.",
            "            Can be omitted; then the database from the connection string is used.",
            "        \"\"\"",
            "        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)",
            "",
            "        return collection.delete_many(filter_doc, **kwargs)",
            "",
            "    def distinct(",
            "        self,",
            "        mongo_collection: str,",
            "        distinct_key: str,",
            "        filter_doc: dict | None = None,",
            "        mongo_db: str | None = None,",
            "        **kwargs,",
            "    ) -> list[Any]:",
            "        \"\"\"",
            "        Returns a list of distinct values for the given key across a collection.",
            "",
            "        https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.distinct",
            "",
            "        :param mongo_collection: The name of the collection to perform distinct on.",
            "        :param distinct_key: The field to return distinct values from.",
            "        :param filter_doc: A query that matches the documents get distinct values from.",
            "            Can be omitted; then will cover the entire collection.",
            "        :param mongo_db: The name of the database to use.",
            "            Can be omitted; then the database from the connection string is used.",
            "        \"\"\"",
            "        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)",
            "",
            "        return collection.distinct(distinct_key, filter=filter_doc, **kwargs)"
        ],
        "afterPatchFile": [
            "#",
            "# Licensed to the Apache Software Foundation (ASF) under one",
            "# or more contributor license agreements.  See the NOTICE file",
            "# distributed with this work for additional information",
            "# regarding copyright ownership.  The ASF licenses this file",
            "# to you under the Apache License, Version 2.0 (the",
            "# \"License\"); you may not use this file except in compliance",
            "# with the License.  You may obtain a copy of the License at",
            "#",
            "#   http://www.apache.org/licenses/LICENSE-2.0",
            "#",
            "# Unless required by applicable law or agreed to in writing,",
            "# software distributed under the License is distributed on an",
            "# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY",
            "# KIND, either express or implied.  See the License for the",
            "# specific language governing permissions and limitations",
            "# under the License.",
            "\"\"\"Hook for Mongo DB.\"\"\"",
            "from __future__ import annotations",
            "",
            "import warnings",
            "from typing import TYPE_CHECKING, Any, overload",
            "from urllib.parse import quote_plus, urlunsplit",
            "",
            "import pymongo",
            "from pymongo import MongoClient, ReplaceOne",
            "",
            "from airflow.exceptions import AirflowProviderDeprecationWarning",
            "from airflow.hooks.base import BaseHook",
            "",
            "if TYPE_CHECKING:",
            "    from types import TracebackType",
            "",
            "    from typing_extensions import Literal",
            "",
            "",
            "class MongoHook(BaseHook):",
            "    \"\"\"",
            "    PyMongo wrapper to interact with MongoDB.",
            "",
            "    Mongo Connection Documentation",
            "    https://docs.mongodb.com/manual/reference/connection-string/index.html",
            "    You can specify connection string options in extra field of your connection",
            "    https://docs.mongodb.com/manual/reference/connection-string/index.html#connection-string-options",
            "",
            "    If you want use DNS seedlist, set `srv` to True.",
            "",
            "    ex.",
            "        {\"srv\": true, \"replicaSet\": \"test\", \"ssl\": true, \"connectTimeoutMS\": 30000}",
            "",
            "    For enabling SSL, the `\"ssl\": true` option can be used within the connection string options, under extra.",
            "    In scenarios where SSL is enabled, `allow_insecure` option is not included by default in the connection",
            "    unless specified. This is so that we ensure a secure medium while handling connections to MongoDB.",
            "",
            "    The `allow_insecure` only makes sense in ssl context and is configurable and can be used in one of",
            "    the following scenarios:",
            "",
            "    HTTP (ssl = False)",
            "    Here, `ssl` is disabled and using `allow_insecure` doesn't make sense.",
            "    Example connection extra: {\"ssl\": false}",
            "",
            "    HTTPS, but insecure (ssl = True, allow_insecure = True)",
            "    Here, `ssl` is enabled, and the connection allows insecure connections.",
            "    Example connection extra: {\"ssl\": true, \"allow_insecure\": true}",
            "",
            "    HTTPS, but secure (ssl = True, allow_insecure = False - default when SSL enabled):",
            "    Here, `ssl` is enabled, and the connection does not allow insecure connections (default behavior when",
            "    SSL is enabled). Example connection extra: {\"ssl\": true} or {\"ssl\": true, \"allow_insecure\": false}",
            "",
            "    Note: `tls` is an alias to `ssl` and can be used in place of `ssl`. Example: {\"ssl\": false} or",
            "    {\"tls\": false}.",
            "",
            "    :param mongo_conn_id: The :ref:`Mongo connection id <howto/connection:mongo>` to use",
            "        when connecting to MongoDB.",
            "    \"\"\"",
            "",
            "    conn_name_attr = \"mongo_conn_id\"",
            "    default_conn_name = \"mongo_default\"",
            "    conn_type = \"mongo\"",
            "    hook_name = \"MongoDB\"",
            "",
            "    def __init__(self, mongo_conn_id: str = default_conn_name, *args, **kwargs) -> None:",
            "        super().__init__()",
            "        if conn_id := kwargs.pop(\"conn_id\", None):",
            "            warnings.warn(",
            "                \"Parameter `conn_id` is deprecated and will be removed in a future releases. \"",
            "                \"Please use `mongo_conn_id` instead.\",",
            "                AirflowProviderDeprecationWarning,",
            "                stacklevel=2,",
            "            )",
            "            mongo_conn_id = conn_id",
            "",
            "        self.mongo_conn_id = mongo_conn_id",
            "        self.connection = self.get_connection(self.mongo_conn_id)",
            "        self.extras = self.connection.extra_dejson.copy()",
            "        self.client: MongoClient | None = None",
            "        self.uri = self._create_uri()",
            "",
            "        self.allow_insecure = self.extras.pop(\"allow_insecure\", \"false\").lower() == \"true\"",
            "        self.ssl_enabled = (",
            "            self.extras.get(\"ssl\", \"false\").lower() == \"true\"",
            "            or self.extras.get(\"tls\", \"false\").lower() == \"true\"",
            "        )",
            "",
            "        if self.ssl_enabled and not self.allow_insecure:",
            "            # Case: HTTPS",
            "            self.allow_insecure = False",
            "        elif self.ssl_enabled and self.allow_insecure:",
            "            # Case: HTTPS + allow_insecure",
            "            self.allow_insecure = True",
            "            self.extras.pop(\"ssl\", None)",
            "        elif not self.ssl_enabled and \"allow_insecure\" in self.extras:",
            "            # Case: HTTP (ssl=False) with allow_insecure specified",
            "            self.log.warning(\"allow_insecure is only applicable when ssl is set\")",
            "            self.extras.pop(\"allow_insecure\", None)",
            "        elif not self.ssl_enabled:",
            "            # Case: HTTP (ssl=False) with allow_insecure not specified",
            "            self.allow_insecure = False",
            "",
            "    def __enter__(self):",
            "        return self",
            "",
            "    def __exit__(",
            "        self,",
            "        exc_type: type[BaseException] | None,",
            "        exc_val: BaseException | None,",
            "        exc_tb: TracebackType | None,",
            "    ) -> None:",
            "        if self.client is not None:",
            "            self.client.close()",
            "            self.client = None",
            "",
            "    def get_conn(self) -> MongoClient:",
            "        \"\"\"Fetches PyMongo Client.\"\"\"",
            "        if self.client is not None:",
            "            return self.client",
            "",
            "        # Mongo Connection Options dict that is unpacked when passed to MongoClient",
            "        options = self.extras",
            "",
            "        # Set tlsAllowInvalidCertificates based on allow_insecure",
            "        if self.allow_insecure:",
            "            options[\"tlsAllowInvalidCertificates\"] = True",
            "",
            "        self.client = MongoClient(self.uri, **options)",
            "        return self.client",
            "",
            "    def _create_uri(self) -> str:",
            "        \"\"\"",
            "        Create URI string from the given credentials.",
            "",
            "        :return: URI string.",
            "        \"\"\"",
            "        srv = self.extras.pop(\"srv\", False)",
            "        scheme = \"mongodb+srv\" if srv else \"mongodb\"",
            "        login = self.connection.login",
            "        password = self.connection.password",
            "        netloc = self.connection.host",
            "        if login is not None and password is not None:",
            "            netloc = f\"{quote_plus(login)}:{quote_plus(password)}@{netloc}\"",
            "        if self.connection.port:",
            "            netloc = f\"{netloc}:{self.connection.port}\"",
            "        path = f\"/{self.connection.schema}\"",
            "        return urlunsplit((scheme, netloc, path, \"\", \"\"))",
            "",
            "    def get_collection(",
            "        self, mongo_collection: str, mongo_db: str | None = None",
            "    ) -> pymongo.collection.Collection:",
            "        \"\"\"",
            "        Fetches a mongo collection object for querying.",
            "",
            "        Uses connection schema as DB unless specified.",
            "        \"\"\"",
            "        mongo_db = mongo_db or self.connection.schema",
            "        mongo_conn: MongoClient = self.get_conn()",
            "",
            "        return mongo_conn.get_database(mongo_db).get_collection(mongo_collection)",
            "",
            "    def aggregate(",
            "        self, mongo_collection: str, aggregate_query: list, mongo_db: str | None = None, **kwargs",
            "    ) -> pymongo.command_cursor.CommandCursor:",
            "        \"\"\"",
            "        Runs an aggregation pipeline and returns the results.",
            "",
            "        https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.aggregate",
            "        https://pymongo.readthedocs.io/en/stable/examples/aggregation.html",
            "        \"\"\"",
            "        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)",
            "",
            "        return collection.aggregate(aggregate_query, **kwargs)",
            "",
            "    @overload",
            "    def find(",
            "        self,",
            "        mongo_collection: str,",
            "        query: dict,",
            "        find_one: Literal[False],",
            "        mongo_db: str | None = None,",
            "        projection: list | dict | None = None,",
            "        **kwargs,",
            "    ) -> pymongo.cursor.Cursor:",
            "        ...",
            "",
            "    @overload",
            "    def find(",
            "        self,",
            "        mongo_collection: str,",
            "        query: dict,",
            "        find_one: Literal[True],",
            "        mongo_db: str | None = None,",
            "        projection: list | dict | None = None,",
            "        **kwargs,",
            "    ) -> Any | None:",
            "        ...",
            "",
            "    def find(",
            "        self,",
            "        mongo_collection: str,",
            "        query: dict,",
            "        find_one: bool = False,",
            "        mongo_db: str | None = None,",
            "        projection: list | dict | None = None,",
            "        **kwargs,",
            "    ) -> pymongo.cursor.Cursor | Any | None:",
            "        \"\"\"",
            "        Runs a mongo find query and returns the results.",
            "",
            "        https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.find",
            "        \"\"\"",
            "        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)",
            "",
            "        if find_one:",
            "            return collection.find_one(query, projection, **kwargs)",
            "        else:",
            "            return collection.find(query, projection, **kwargs)",
            "",
            "    def insert_one(",
            "        self, mongo_collection: str, doc: dict, mongo_db: str | None = None, **kwargs",
            "    ) -> pymongo.results.InsertOneResult:",
            "        \"\"\"",
            "        Inserts a single document into a mongo collection.",
            "",
            "        https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.insert_one",
            "        \"\"\"",
            "        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)",
            "",
            "        return collection.insert_one(doc, **kwargs)",
            "",
            "    def insert_many(",
            "        self, mongo_collection: str, docs: dict, mongo_db: str | None = None, **kwargs",
            "    ) -> pymongo.results.InsertManyResult:",
            "        \"\"\"",
            "        Inserts many docs into a mongo collection.",
            "",
            "        https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.insert_many",
            "        \"\"\"",
            "        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)",
            "",
            "        return collection.insert_many(docs, **kwargs)",
            "",
            "    def update_one(",
            "        self,",
            "        mongo_collection: str,",
            "        filter_doc: dict,",
            "        update_doc: dict,",
            "        mongo_db: str | None = None,",
            "        **kwargs,",
            "    ) -> pymongo.results.UpdateResult:",
            "        \"\"\"",
            "        Updates a single document in a mongo collection.",
            "",
            "        https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.update_one",
            "",
            "        :param mongo_collection: The name of the collection to update.",
            "        :param filter_doc: A query that matches the documents to update.",
            "        :param update_doc: The modifications to apply.",
            "        :param mongo_db: The name of the database to use.",
            "            Can be omitted; then the database from the connection string is used.",
            "",
            "        \"\"\"",
            "        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)",
            "",
            "        return collection.update_one(filter_doc, update_doc, **kwargs)",
            "",
            "    def update_many(",
            "        self,",
            "        mongo_collection: str,",
            "        filter_doc: dict,",
            "        update_doc: dict,",
            "        mongo_db: str | None = None,",
            "        **kwargs,",
            "    ) -> pymongo.results.UpdateResult:",
            "        \"\"\"",
            "        Updates one or more documents in a mongo collection.",
            "",
            "        https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.update_many",
            "",
            "        :param mongo_collection: The name of the collection to update.",
            "        :param filter_doc: A query that matches the documents to update.",
            "        :param update_doc: The modifications to apply.",
            "        :param mongo_db: The name of the database to use.",
            "            Can be omitted; then the database from the connection string is used.",
            "        \"\"\"",
            "        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)",
            "",
            "        return collection.update_many(filter_doc, update_doc, **kwargs)",
            "",
            "    def replace_one(",
            "        self,",
            "        mongo_collection: str,",
            "        doc: dict,",
            "        filter_doc: dict | None = None,",
            "        mongo_db: str | None = None,",
            "        **kwargs,",
            "    ) -> pymongo.results.UpdateResult:",
            "        \"\"\"",
            "        Replaces a single document in a mongo collection.",
            "",
            "        https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.replace_one",
            "",
            "        .. note::",
            "            If no ``filter_doc`` is given, it is assumed that the replacement",
            "            document contain the ``_id`` field which is then used as filters.",
            "",
            "        :param mongo_collection: The name of the collection to update.",
            "        :param doc: The new document.",
            "        :param filter_doc: A query that matches the documents to replace.",
            "            Can be omitted; then the _id field from doc will be used.",
            "        :param mongo_db: The name of the database to use.",
            "            Can be omitted; then the database from the connection string is used.",
            "        \"\"\"",
            "        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)",
            "",
            "        if not filter_doc:",
            "            filter_doc = {\"_id\": doc[\"_id\"]}",
            "",
            "        return collection.replace_one(filter_doc, doc, **kwargs)",
            "",
            "    def replace_many(",
            "        self,",
            "        mongo_collection: str,",
            "        docs: list[dict],",
            "        filter_docs: list[dict] | None = None,",
            "        mongo_db: str | None = None,",
            "        upsert: bool = False,",
            "        collation: pymongo.collation.Collation | None = None,",
            "        **kwargs,",
            "    ) -> pymongo.results.BulkWriteResult:",
            "        \"\"\"",
            "        Replaces many documents in a mongo collection.",
            "",
            "        Uses bulk_write with multiple ReplaceOne operations",
            "        https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.bulk_write",
            "",
            "        .. note::",
            "            If no ``filter_docs``are given, it is assumed that all",
            "            replacement documents contain the ``_id`` field which are then",
            "            used as filters.",
            "",
            "        :param mongo_collection: The name of the collection to update.",
            "        :param docs: The new documents.",
            "        :param filter_docs: A list of queries that match the documents to replace.",
            "            Can be omitted; then the _id fields from airflow.docs will be used.",
            "        :param mongo_db: The name of the database to use.",
            "            Can be omitted; then the database from the connection string is used.",
            "        :param upsert: If ``True``, perform an insert if no documents",
            "            match the filters for the replace operation.",
            "        :param collation: An instance of",
            "            :class:`~pymongo.collation.Collation`. This option is only",
            "            supported on MongoDB 3.4 and above.",
            "        \"\"\"",
            "        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)",
            "",
            "        if not filter_docs:",
            "            filter_docs = [{\"_id\": doc[\"_id\"]} for doc in docs]",
            "",
            "        requests = [",
            "            ReplaceOne(filter_docs[i], docs[i], upsert=upsert, collation=collation) for i in range(len(docs))",
            "        ]",
            "",
            "        return collection.bulk_write(requests, **kwargs)",
            "",
            "    def delete_one(",
            "        self, mongo_collection: str, filter_doc: dict, mongo_db: str | None = None, **kwargs",
            "    ) -> pymongo.results.DeleteResult:",
            "        \"\"\"",
            "        Deletes a single document in a mongo collection.",
            "",
            "        https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.delete_one",
            "",
            "        :param mongo_collection: The name of the collection to delete from.",
            "        :param filter_doc: A query that matches the document to delete.",
            "        :param mongo_db: The name of the database to use.",
            "            Can be omitted; then the database from the connection string is used.",
            "        \"\"\"",
            "        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)",
            "",
            "        return collection.delete_one(filter_doc, **kwargs)",
            "",
            "    def delete_many(",
            "        self, mongo_collection: str, filter_doc: dict, mongo_db: str | None = None, **kwargs",
            "    ) -> pymongo.results.DeleteResult:",
            "        \"\"\"",
            "        Deletes one or more documents in a mongo collection.",
            "",
            "        https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.delete_many",
            "",
            "        :param mongo_collection: The name of the collection to delete from.",
            "        :param filter_doc: A query that matches the documents to delete.",
            "        :param mongo_db: The name of the database to use.",
            "            Can be omitted; then the database from the connection string is used.",
            "        \"\"\"",
            "        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)",
            "",
            "        return collection.delete_many(filter_doc, **kwargs)",
            "",
            "    def distinct(",
            "        self,",
            "        mongo_collection: str,",
            "        distinct_key: str,",
            "        filter_doc: dict | None = None,",
            "        mongo_db: str | None = None,",
            "        **kwargs,",
            "    ) -> list[Any]:",
            "        \"\"\"",
            "        Returns a list of distinct values for the given key across a collection.",
            "",
            "        https://pymongo.readthedocs.io/en/stable/api/pymongo/collection.html#pymongo.collection.Collection.distinct",
            "",
            "        :param mongo_collection: The name of the collection to perform distinct on.",
            "        :param distinct_key: The field to return distinct values from.",
            "        :param filter_doc: A query that matches the documents get distinct values from.",
            "            Can be omitted; then will cover the entire collection.",
            "        :param mongo_db: The name of the database to use.",
            "            Can be omitted; then the database from the connection string is used.",
            "        \"\"\"",
            "        collection = self.get_collection(mongo_collection, mongo_db=mongo_db)",
            "",
            "        return collection.distinct(distinct_key, filter=filter_doc, **kwargs)"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "22": [],
            "99": [
                "MongoHook",
                "get_conn"
            ],
            "100": [
                "MongoHook",
                "get_conn"
            ],
            "101": [
                "MongoHook",
                "get_conn"
            ],
            "102": [
                "MongoHook",
                "get_conn"
            ],
            "103": [
                "MongoHook",
                "get_conn"
            ],
            "104": [
                "MongoHook",
                "get_conn"
            ],
            "105": [
                "MongoHook",
                "get_conn"
            ],
            "106": [
                "MongoHook",
                "get_conn"
            ]
        },
        "addLocation": []
    }
}