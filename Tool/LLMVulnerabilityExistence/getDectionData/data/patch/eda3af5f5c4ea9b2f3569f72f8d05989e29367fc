{
    "lollms/security.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 8,
                "afterPatchRowNumber": 8,
                "PatchRowcode": " import re"
            },
            "1": {
                "beforePatchRowNumber": 9,
                "afterPatchRowNumber": 9,
                "PatchRowcode": " import platform"
            },
            "2": {
                "beforePatchRowNumber": 10,
                "afterPatchRowNumber": 10,
                "PatchRowcode": " import string"
            },
            "3": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 11,
                "PatchRowcode": "+from lollms.utilities import PackageManager"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 12,
                "PatchRowcode": "+"
            },
            "5": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 13,
                "PatchRowcode": "+if not PackageManager.check_package_installed(\"lxml\"):"
            },
            "6": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 14,
                "PatchRowcode": "+    PackageManager.install_package(\"lxml\")"
            },
            "7": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 15,
                "PatchRowcode": "+"
            },
            "8": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 16,
                "PatchRowcode": "+import lxml.etree as ET"
            },
            "9": {
                "beforePatchRowNumber": 11,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " "
            },
            "10": {
                "beforePatchRowNumber": 12,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " def check_access(lollmsElfServer, client_id):"
            },
            "11": {
                "beforePatchRowNumber": 13,
                "afterPatchRowNumber": 19,
                "PatchRowcode": "     client = lollmsElfServer.session.get_client(client_id)"
            },
            "12": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 66,
                "PatchRowcode": "         return line[:command_end_index + len(sanitized_rest)].strip()"
            },
            "13": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 67,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 68,
                "PatchRowcode": " "
            },
            "15": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 69,
                "PatchRowcode": "+def sanitize_svg(svg_content):"
            },
            "16": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 70,
                "PatchRowcode": "+    try:"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 71,
                "PatchRowcode": "+        parser = ET.XMLParser(remove_comments=True, remove_pis=True)"
            },
            "18": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 72,
                "PatchRowcode": "+        tree = ET.fromstring(svg_content, parser=parser)"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 73,
                "PatchRowcode": "+"
            },
            "20": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 74,
                "PatchRowcode": "+        # Remove any script elements"
            },
            "21": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 75,
                "PatchRowcode": "+        for script in tree.xpath('//svg:script', namespaces={'svg': 'http://www.w3.org/2000/svg'}):"
            },
            "22": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 76,
                "PatchRowcode": "+            parent = script.getparent()"
            },
            "23": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 77,
                "PatchRowcode": "+            if parent is not None:"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 78,
                "PatchRowcode": "+                parent.remove(script)"
            },
            "25": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 79,
                "PatchRowcode": "+"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 80,
                "PatchRowcode": "+        # Remove any 'on*' event attributes"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 81,
                "PatchRowcode": "+        for element in tree.xpath('//*[@*[starts-with(name(), \"on\")]]'):"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 82,
                "PatchRowcode": "+            for attr in list(element.attrib):"
            },
            "29": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 83,
                "PatchRowcode": "+                if attr.startswith('on'):"
            },
            "30": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 84,
                "PatchRowcode": "+                    del element.attrib[attr]"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 85,
                "PatchRowcode": "+"
            },
            "32": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 86,
                "PatchRowcode": "+        # Convert the tree back to an SVG string"
            },
            "33": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 87,
                "PatchRowcode": "+        sanitized_svg = ET.tostring(tree, encoding='unicode', method='xml')"
            },
            "34": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 88,
                "PatchRowcode": "+        return sanitized_svg"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 89,
                "PatchRowcode": "+    except ET.XMLSyntaxError as e:"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 90,
                "PatchRowcode": "+        raise ValueError(\"Invalid SVG content\") from e"
            },
            "37": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 91,
                "PatchRowcode": "+"
            },
            "38": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 92,
                "PatchRowcode": "+"
            },
            "39": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 93,
                "PatchRowcode": " def sanitize_shell_code(code, whitelist=None):"
            },
            "40": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 94,
                "PatchRowcode": "     \"\"\""
            },
            "41": {
                "beforePatchRowNumber": 65,
                "afterPatchRowNumber": 95,
                "PatchRowcode": "     Securely sanitizes a block of code by allowing commands from a provided whitelist,"
            }
        },
        "frontPatchFile": [
            "from fastapi import HTTPException",
            "from ascii_colors import ASCIIColors",
            "from urllib.parse import urlparse",
            "import socket",
            "from pathlib import Path",
            "from typing import List",
            "import os",
            "import re",
            "import platform",
            "import string",
            "",
            "def check_access(lollmsElfServer, client_id):",
            "    client = lollmsElfServer.session.get_client(client_id)",
            "    if not client:",
            "        raise HTTPException(status_code=400, detail=f\"Not accessible without id\")",
            "    return client",
            "",
            "",
            "def sanitize_based_on_separators(line):",
            "    \"\"\"",
            "    Sanitizes a line of code based on common command separators.",
            "",
            "    Parameters:",
            "    - line (str): The line of code to be sanitized.",
            "",
            "    Returns:",
            "    - str: The sanitized line of code.",
            "    \"\"\"",
            "    separators = ['&', '|', ';']",
            "    for sep in separators:",
            "        if sep in line:",
            "            line = line.split(sep)[0]  # Keep only the first command before the separator",
            "            break",
            "    return line.strip()",
            "",
            "def sanitize_after_whitelisted_command(line, command):",
            "    \"\"\"",
            "    Sanitizes the line after a whitelisted command, removing any following commands",
            "    if a command separator is present.",
            "",
            "    Parameters:",
            "    - line (str): The line of code containing the whitelisted command.",
            "    - command (str): The whitelisted command.",
            "",
            "    Returns:",
            "    - str: The sanitized line of code, ensuring only the whitelisted command is executed.",
            "    \"\"\"",
            "    # Find the end of the whitelisted command in the line",
            "    command_end_index = line.find(command) + len(command)",
            "    # Extract the rest of the line after the whitelisted command",
            "    rest_of_line = line[command_end_index:]",
            "    # Sanitize the rest of the line based on separators",
            "    sanitized_rest = sanitize_based_on_separators(rest_of_line)",
            "    # If anything malicious was removed, sanitized_rest will be empty, so only return the whitelisted command part",
            "    if not sanitized_rest:",
            "        return line[:command_end_index].strip()",
            "    else:",
            "        # If rest_of_line starts directly with separators followed by malicious commands, sanitized_rest will be empty",
            "        # This means we should only return the part up to the whitelisted command",
            "        return line[:command_end_index + len(sanitized_rest)].strip()",
            "",
            "",
            "def sanitize_shell_code(code, whitelist=None):",
            "    \"\"\"",
            "    Securely sanitizes a block of code by allowing commands from a provided whitelist,",
            "    but only up to the first command separator if followed by other commands.",
            "    Sanitizes based on common command separators if no whitelist is provided.",
            "",
            "    Parameters:",
            "    - code (str): The input code to be sanitized.",
            "    - whitelist (list): Optional. A list of whitelisted commands that are allowed.",
            "",
            "    Returns:",
            "    - str: The securely sanitized code.",
            "    \"\"\"",
            "    ",
            "    # Split the code by newline characters",
            "    lines = code.split('\\n')",
            "    ",
            "    # Initialize the sanitized code variable",
            "    sanitized_code = \"\"",
            "    ",
            "    for line in lines:",
            "        if line.strip():  # Check if the line is not empty",
            "            if whitelist:",
            "                for command in whitelist:",
            "                    if line.strip().startswith(command):",
            "                        # Check for command separators after the whitelisted command",
            "                        sanitized_code = sanitize_after_whitelisted_command(line, command)",
            "                        break",
            "            else:",
            "                # Sanitize based on separators if no whitelist is provided",
            "                sanitized_code = sanitize_based_on_separators(line)",
            "            break  # Only process the first non-empty line",
            "    ",
            "    return sanitized_code",
            "",
            "",
            "class InvalidFilePathError(Exception):",
            "    pass",
            "",
            "",
            "def sanitize_path(path: str, allow_absolute_path: bool = False, error_text=\"Absolute database path detected\", exception_text=\"Detected an attempt of path traversal or command injection. Are you kidding me?\"):",
            "    \"\"\"",
            "    Sanitize a given file path by checking for potentially dangerous patterns and unauthorized characters.",
            "",
            "    Args:",
            "    -----",
            "    path (str): The file path to sanitize.",
            "    allow_absolute_path (bool, optional): Whether to allow absolute paths. Default is False.",
            "    error_text (str, optional): The error message to display if an absolute path is detected. Default is \"Absolute database path detected\".",
            "    exception_text (str, optional): The exception message to display if a path traversal, command injection, or unauthorized character is detected. Default is \"Detected an attempt of path traversal or command injection. Are you kidding me?\".",
            "",
            "    Raises:",
            "    ------",
            "    HTTPException: If an absolute path, path traversal, command injection, or unauthorized character is detected.",
            "",
            "    Returns:",
            "    -------",
            "    str: The sanitized file path.",
            "",
            "    Note:",
            "    -----",
            "    This function checks for patterns like \"....\", multiple forward slashes, and command injection attempts like $(whoami). It also checks for unauthorized punctuation characters, excluding the dot (.) character.",
            "    \"\"\"    ",
            "    if path is None:",
            "        return path",
            "",
            "    # Normalize path to use forward slashes",
            "    path = path.replace('\\\\', '/')",
            "",
            "    if not allow_absolute_path and path.strip().startswith(\"/\"):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    # Regular expression to detect patterns like \"....\", multiple forward slashes, and command injection attempts like $(whoami)",
            "    suspicious_patterns = re.compile(r'(\\.\\.+)|(/+/)|(\\$\\(.*\\))')",
            "",
            "    if suspicious_patterns.search(str(path)) or ((not allow_absolute_path) and Path(path).is_absolute()):",
            "        ASCIIColors.error(error_text)",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    # Detect if any unauthorized characters, excluding the dot character, are present in the path",
            "    unauthorized_chars = set('!\"#$%&\\'()*+,;<=>?@[]^`{|}~')",
            "    if any(char in unauthorized_chars for char in path):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    if not allow_absolute_path:",
            "        path = path.lstrip('/')",
            "",
            "    return path",
            "",
            "    ",
            "def sanitize_path_from_endpoint(path: str, error_text: str = \"A suspected LFI attack detected. The path sent to the server has suspicious elements in it!\", exception_text: str = \"Invalid path!\") -> str:",
            "    \"\"\"",
            "    Sanitize a given file path from an endpoint by checking for potentially dangerous patterns and unauthorized characters,",
            "    and standardizing path separators to prevent directory traversal attacks.",
            "",
            "    Args:",
            "    -----",
            "    path (str): The file path to sanitize.",
            "    error_text (str, optional): Error message to display if a path traversal or unauthorized character is detected. Default is a warning about a suspected LFI attack.",
            "    exception_text (str, optional): Exception message to display if an absolute path or invalid character is detected. Default is \"Invalid path!\".",
            "",
            "    Raises:",
            "    ------",
            "    HTTPException: If an absolute path, path traversal, or unauthorized character is detected.",
            "",
            "    Returns:",
            "    -------",
            "    str: The sanitized file path.",
            "    \"\"\"",
            "",
            "    if path is None:",
            "        return path",
            "",
            "    # Normalize path to use forward slashes",
            "    path = path.replace('\\\\', '/')",
            "",
            "    if path.strip().startswith(\"/\"):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    # Regular expression to detect patterns like \"....\" and multiple forward slashes",
            "    suspicious_patterns = re.compile(r'(\\.\\.+)|(/+/)')",
            "",
            "    # Detect if any unauthorized characters, excluding the dot character, are present in the path",
            "    unauthorized_chars = set('!\"#$%&\\'()*+,;<=>?@[]^`{|}~')",
            "    if any(char in unauthorized_chars for char in path):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    if suspicious_patterns.search(path) or Path(path).is_absolute():",
            "        raise HTTPException(status_code=400, detail=error_text)",
            "",
            "    path = path.lstrip('/')",
            "    return path",
            "",
            "",
            "",
            "def forbid_remote_access(lollmsElfServer, exception_text = \"This functionality is forbidden if the server is exposed\"):",
            "    if not lollmsElfServer.config.force_accept_remote_access and lollmsElfServer.config.host!=\"localhost\" and lollmsElfServer.config.host!=\"127.0.0.1\":",
            "        raise Exception(exception_text)",
            "",
            "def validate_path(path, allowed_paths:List[str|Path]):",
            "    # Convert the path to an absolute path",
            "    abs_path = os.path.realpath(str(path))",
            "",
            "    # Iterate over the allowed paths",
            "    for allowed_path in allowed_paths:",
            "        # Convert the allowed path to an absolute path",
            "        abs_allowed_path = os.path.realpath(allowed_path)",
            "",
            "        # Check if the absolute path starts with the absolute allowed path",
            "        if abs_path.startswith(abs_allowed_path):",
            "            return True",
            "",
            "    # If the path is not within any of the allowed paths, return False",
            "    return False",
            "",
            "def is_allowed_url(url):",
            "    # Check if url is legit",
            "    parsed_url = urlparse(url)        ",
            "    # Check if scheme is not http or https, return False",
            "    if parsed_url.scheme not in ['http', 'https']:",
            "        return False",
            "    ",
            "    hostname = parsed_url.hostname",
            "    ",
            "    try:",
            "        ip_address = socket.gethostbyname(hostname)",
            "    except socket.gaierror:",
            "        return False",
            "    ",
            "    return not ip_address.startswith('127.') or ip_address.startswith('192.168.') or ip_address.startswith('10.') or ip_address.startswith('172.')",
            "",
            "",
            "if __name__==\"__main__\":",
            "    sanitize_path_from_endpoint(\"main\")",
            "    sanitize_path_from_endpoint(\"cat/main\")",
            "    print(\"Main passed\")",
            "    sanitize_path_from_endpoint(\".../user\")",
            "    print(\"hi\")"
        ],
        "afterPatchFile": [
            "from fastapi import HTTPException",
            "from ascii_colors import ASCIIColors",
            "from urllib.parse import urlparse",
            "import socket",
            "from pathlib import Path",
            "from typing import List",
            "import os",
            "import re",
            "import platform",
            "import string",
            "from lollms.utilities import PackageManager",
            "",
            "if not PackageManager.check_package_installed(\"lxml\"):",
            "    PackageManager.install_package(\"lxml\")",
            "",
            "import lxml.etree as ET",
            "",
            "def check_access(lollmsElfServer, client_id):",
            "    client = lollmsElfServer.session.get_client(client_id)",
            "    if not client:",
            "        raise HTTPException(status_code=400, detail=f\"Not accessible without id\")",
            "    return client",
            "",
            "",
            "def sanitize_based_on_separators(line):",
            "    \"\"\"",
            "    Sanitizes a line of code based on common command separators.",
            "",
            "    Parameters:",
            "    - line (str): The line of code to be sanitized.",
            "",
            "    Returns:",
            "    - str: The sanitized line of code.",
            "    \"\"\"",
            "    separators = ['&', '|', ';']",
            "    for sep in separators:",
            "        if sep in line:",
            "            line = line.split(sep)[0]  # Keep only the first command before the separator",
            "            break",
            "    return line.strip()",
            "",
            "def sanitize_after_whitelisted_command(line, command):",
            "    \"\"\"",
            "    Sanitizes the line after a whitelisted command, removing any following commands",
            "    if a command separator is present.",
            "",
            "    Parameters:",
            "    - line (str): The line of code containing the whitelisted command.",
            "    - command (str): The whitelisted command.",
            "",
            "    Returns:",
            "    - str: The sanitized line of code, ensuring only the whitelisted command is executed.",
            "    \"\"\"",
            "    # Find the end of the whitelisted command in the line",
            "    command_end_index = line.find(command) + len(command)",
            "    # Extract the rest of the line after the whitelisted command",
            "    rest_of_line = line[command_end_index:]",
            "    # Sanitize the rest of the line based on separators",
            "    sanitized_rest = sanitize_based_on_separators(rest_of_line)",
            "    # If anything malicious was removed, sanitized_rest will be empty, so only return the whitelisted command part",
            "    if not sanitized_rest:",
            "        return line[:command_end_index].strip()",
            "    else:",
            "        # If rest_of_line starts directly with separators followed by malicious commands, sanitized_rest will be empty",
            "        # This means we should only return the part up to the whitelisted command",
            "        return line[:command_end_index + len(sanitized_rest)].strip()",
            "",
            "",
            "def sanitize_svg(svg_content):",
            "    try:",
            "        parser = ET.XMLParser(remove_comments=True, remove_pis=True)",
            "        tree = ET.fromstring(svg_content, parser=parser)",
            "",
            "        # Remove any script elements",
            "        for script in tree.xpath('//svg:script', namespaces={'svg': 'http://www.w3.org/2000/svg'}):",
            "            parent = script.getparent()",
            "            if parent is not None:",
            "                parent.remove(script)",
            "",
            "        # Remove any 'on*' event attributes",
            "        for element in tree.xpath('//*[@*[starts-with(name(), \"on\")]]'):",
            "            for attr in list(element.attrib):",
            "                if attr.startswith('on'):",
            "                    del element.attrib[attr]",
            "",
            "        # Convert the tree back to an SVG string",
            "        sanitized_svg = ET.tostring(tree, encoding='unicode', method='xml')",
            "        return sanitized_svg",
            "    except ET.XMLSyntaxError as e:",
            "        raise ValueError(\"Invalid SVG content\") from e",
            "",
            "",
            "def sanitize_shell_code(code, whitelist=None):",
            "    \"\"\"",
            "    Securely sanitizes a block of code by allowing commands from a provided whitelist,",
            "    but only up to the first command separator if followed by other commands.",
            "    Sanitizes based on common command separators if no whitelist is provided.",
            "",
            "    Parameters:",
            "    - code (str): The input code to be sanitized.",
            "    - whitelist (list): Optional. A list of whitelisted commands that are allowed.",
            "",
            "    Returns:",
            "    - str: The securely sanitized code.",
            "    \"\"\"",
            "    ",
            "    # Split the code by newline characters",
            "    lines = code.split('\\n')",
            "    ",
            "    # Initialize the sanitized code variable",
            "    sanitized_code = \"\"",
            "    ",
            "    for line in lines:",
            "        if line.strip():  # Check if the line is not empty",
            "            if whitelist:",
            "                for command in whitelist:",
            "                    if line.strip().startswith(command):",
            "                        # Check for command separators after the whitelisted command",
            "                        sanitized_code = sanitize_after_whitelisted_command(line, command)",
            "                        break",
            "            else:",
            "                # Sanitize based on separators if no whitelist is provided",
            "                sanitized_code = sanitize_based_on_separators(line)",
            "            break  # Only process the first non-empty line",
            "    ",
            "    return sanitized_code",
            "",
            "",
            "class InvalidFilePathError(Exception):",
            "    pass",
            "",
            "",
            "def sanitize_path(path: str, allow_absolute_path: bool = False, error_text=\"Absolute database path detected\", exception_text=\"Detected an attempt of path traversal or command injection. Are you kidding me?\"):",
            "    \"\"\"",
            "    Sanitize a given file path by checking for potentially dangerous patterns and unauthorized characters.",
            "",
            "    Args:",
            "    -----",
            "    path (str): The file path to sanitize.",
            "    allow_absolute_path (bool, optional): Whether to allow absolute paths. Default is False.",
            "    error_text (str, optional): The error message to display if an absolute path is detected. Default is \"Absolute database path detected\".",
            "    exception_text (str, optional): The exception message to display if a path traversal, command injection, or unauthorized character is detected. Default is \"Detected an attempt of path traversal or command injection. Are you kidding me?\".",
            "",
            "    Raises:",
            "    ------",
            "    HTTPException: If an absolute path, path traversal, command injection, or unauthorized character is detected.",
            "",
            "    Returns:",
            "    -------",
            "    str: The sanitized file path.",
            "",
            "    Note:",
            "    -----",
            "    This function checks for patterns like \"....\", multiple forward slashes, and command injection attempts like $(whoami). It also checks for unauthorized punctuation characters, excluding the dot (.) character.",
            "    \"\"\"    ",
            "    if path is None:",
            "        return path",
            "",
            "    # Normalize path to use forward slashes",
            "    path = path.replace('\\\\', '/')",
            "",
            "    if not allow_absolute_path and path.strip().startswith(\"/\"):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    # Regular expression to detect patterns like \"....\", multiple forward slashes, and command injection attempts like $(whoami)",
            "    suspicious_patterns = re.compile(r'(\\.\\.+)|(/+/)|(\\$\\(.*\\))')",
            "",
            "    if suspicious_patterns.search(str(path)) or ((not allow_absolute_path) and Path(path).is_absolute()):",
            "        ASCIIColors.error(error_text)",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    # Detect if any unauthorized characters, excluding the dot character, are present in the path",
            "    unauthorized_chars = set('!\"#$%&\\'()*+,;<=>?@[]^`{|}~')",
            "    if any(char in unauthorized_chars for char in path):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    if not allow_absolute_path:",
            "        path = path.lstrip('/')",
            "",
            "    return path",
            "",
            "    ",
            "def sanitize_path_from_endpoint(path: str, error_text: str = \"A suspected LFI attack detected. The path sent to the server has suspicious elements in it!\", exception_text: str = \"Invalid path!\") -> str:",
            "    \"\"\"",
            "    Sanitize a given file path from an endpoint by checking for potentially dangerous patterns and unauthorized characters,",
            "    and standardizing path separators to prevent directory traversal attacks.",
            "",
            "    Args:",
            "    -----",
            "    path (str): The file path to sanitize.",
            "    error_text (str, optional): Error message to display if a path traversal or unauthorized character is detected. Default is a warning about a suspected LFI attack.",
            "    exception_text (str, optional): Exception message to display if an absolute path or invalid character is detected. Default is \"Invalid path!\".",
            "",
            "    Raises:",
            "    ------",
            "    HTTPException: If an absolute path, path traversal, or unauthorized character is detected.",
            "",
            "    Returns:",
            "    -------",
            "    str: The sanitized file path.",
            "    \"\"\"",
            "",
            "    if path is None:",
            "        return path",
            "",
            "    # Normalize path to use forward slashes",
            "    path = path.replace('\\\\', '/')",
            "",
            "    if path.strip().startswith(\"/\"):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    # Regular expression to detect patterns like \"....\" and multiple forward slashes",
            "    suspicious_patterns = re.compile(r'(\\.\\.+)|(/+/)')",
            "",
            "    # Detect if any unauthorized characters, excluding the dot character, are present in the path",
            "    unauthorized_chars = set('!\"#$%&\\'()*+,;<=>?@[]^`{|}~')",
            "    if any(char in unauthorized_chars for char in path):",
            "        raise HTTPException(status_code=400, detail=exception_text)",
            "",
            "    if suspicious_patterns.search(path) or Path(path).is_absolute():",
            "        raise HTTPException(status_code=400, detail=error_text)",
            "",
            "    path = path.lstrip('/')",
            "    return path",
            "",
            "",
            "",
            "def forbid_remote_access(lollmsElfServer, exception_text = \"This functionality is forbidden if the server is exposed\"):",
            "    if not lollmsElfServer.config.force_accept_remote_access and lollmsElfServer.config.host!=\"localhost\" and lollmsElfServer.config.host!=\"127.0.0.1\":",
            "        raise Exception(exception_text)",
            "",
            "def validate_path(path, allowed_paths:List[str|Path]):",
            "    # Convert the path to an absolute path",
            "    abs_path = os.path.realpath(str(path))",
            "",
            "    # Iterate over the allowed paths",
            "    for allowed_path in allowed_paths:",
            "        # Convert the allowed path to an absolute path",
            "        abs_allowed_path = os.path.realpath(allowed_path)",
            "",
            "        # Check if the absolute path starts with the absolute allowed path",
            "        if abs_path.startswith(abs_allowed_path):",
            "            return True",
            "",
            "    # If the path is not within any of the allowed paths, return False",
            "    return False",
            "",
            "def is_allowed_url(url):",
            "    # Check if url is legit",
            "    parsed_url = urlparse(url)        ",
            "    # Check if scheme is not http or https, return False",
            "    if parsed_url.scheme not in ['http', 'https']:",
            "        return False",
            "    ",
            "    hostname = parsed_url.hostname",
            "    ",
            "    try:",
            "        ip_address = socket.gethostbyname(hostname)",
            "    except socket.gaierror:",
            "        return False",
            "    ",
            "    return not ip_address.startswith('127.') or ip_address.startswith('192.168.') or ip_address.startswith('10.') or ip_address.startswith('172.')",
            "",
            "",
            "if __name__==\"__main__\":",
            "    sanitize_path_from_endpoint(\"main\")",
            "    sanitize_path_from_endpoint(\"cat/main\")",
            "    print(\"Main passed\")",
            "    sanitize_path_from_endpoint(\".../user\")",
            "    print(\"hi\")"
        ],
        "action": [
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "-1",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {},
        "addLocation": [
            "ckan.tests.logic.action.test_create.TestResourceCreate.test_mimetype_by_upload_by_filename"
        ]
    },
    "lollms/server/endpoints/lollms_personalities_infos.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 16,
                "afterPatchRowNumber": 16,
                "PatchRowcode": " from lollms.personality import AIPersonality, InstallOption"
            },
            "1": {
                "beforePatchRowNumber": 17,
                "afterPatchRowNumber": 17,
                "PatchRowcode": " from ascii_colors import ASCIIColors"
            },
            "2": {
                "beforePatchRowNumber": 18,
                "afterPatchRowNumber": 18,
                "PatchRowcode": " from lollms.utilities import load_config, trace_exception, gc, show_yes_no_dialog"
            },
            "3": {
                "beforePatchRowNumber": 19,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from lollms.security import check_access"
            },
            "4": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 19,
                "PatchRowcode": "+from lollms.security import check_access, forbid_remote_access"
            },
            "5": {
                "beforePatchRowNumber": 20,
                "afterPatchRowNumber": 20,
                "PatchRowcode": " from pathlib import Path"
            },
            "6": {
                "beforePatchRowNumber": 21,
                "afterPatchRowNumber": 21,
                "PatchRowcode": " from typing import List, Optional"
            },
            "7": {
                "beforePatchRowNumber": 22,
                "afterPatchRowNumber": 22,
                "PatchRowcode": " import psutil"
            },
            "8": {
                "beforePatchRowNumber": 329,
                "afterPatchRowNumber": 329,
                "PatchRowcode": "     print(\"- Recovering personality config\")"
            },
            "9": {
                "beforePatchRowNumber": 330,
                "afterPatchRowNumber": 330,
                "PatchRowcode": "     category = sanitize_path(data.category)"
            },
            "10": {
                "beforePatchRowNumber": 331,
                "afterPatchRowNumber": 331,
                "PatchRowcode": "     name = sanitize_path(data.name)"
            },
            "11": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 332,
                "PatchRowcode": "+    if category==\"\":"
            },
            "12": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 333,
                "PatchRowcode": "+        return {\"status\":False, \"error\":\"category must not be empty.\"}"
            },
            "13": {
                "beforePatchRowNumber": 332,
                "afterPatchRowNumber": 334,
                "PatchRowcode": " "
            },
            "14": {
                "beforePatchRowNumber": 333,
                "afterPatchRowNumber": 335,
                "PatchRowcode": "     package_path = f\"{category}/{name}\""
            },
            "15": {
                "beforePatchRowNumber": 334,
                "afterPatchRowNumber": 336,
                "PatchRowcode": "     if category==\"custom_personalities\":"
            },
            "16": {
                "beforePatchRowNumber": 352,
                "afterPatchRowNumber": 354,
                "PatchRowcode": " "
            },
            "17": {
                "beforePatchRowNumber": 353,
                "afterPatchRowNumber": 355,
                "PatchRowcode": " @router.post(\"/set_personality_config\")"
            },
            "18": {
                "beforePatchRowNumber": 354,
                "afterPatchRowNumber": 356,
                "PatchRowcode": " def set_personality_config(data:PersonalityConfig):"
            },
            "19": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 357,
                "PatchRowcode": "+    forbid_remote_access(lollmsElfServer)"
            },
            "20": {
                "beforePatchRowNumber": 355,
                "afterPatchRowNumber": 358,
                "PatchRowcode": "     check_access(lollmsElfServer, data.client_id)"
            },
            "21": {
                "beforePatchRowNumber": 356,
                "afterPatchRowNumber": 359,
                "PatchRowcode": "     print(\"- Recovering personality config\")"
            },
            "22": {
                "beforePatchRowNumber": 357,
                "afterPatchRowNumber": 360,
                "PatchRowcode": "     category = sanitize_path(data.category)"
            },
            "23": {
                "beforePatchRowNumber": 358,
                "afterPatchRowNumber": 361,
                "PatchRowcode": "     name = sanitize_path(data.name)"
            },
            "24": {
                "beforePatchRowNumber": 359,
                "afterPatchRowNumber": 362,
                "PatchRowcode": "     config = data.config"
            },
            "25": {
                "beforePatchRowNumber": 360,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-"
            },
            "26": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 363,
                "PatchRowcode": "+    if category==\"\":"
            },
            "27": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 364,
                "PatchRowcode": "+        return {\"status\":False, \"error\":\"category must not be empty.\"}"
            },
            "28": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 365,
                "PatchRowcode": "+    "
            },
            "29": {
                "beforePatchRowNumber": 361,
                "afterPatchRowNumber": 366,
                "PatchRowcode": "     package_path = f\"{category}/{name}\""
            },
            "30": {
                "beforePatchRowNumber": 362,
                "afterPatchRowNumber": 367,
                "PatchRowcode": "     if category==\"custom_personalities\":"
            },
            "31": {
                "beforePatchRowNumber": 363,
                "afterPatchRowNumber": 368,
                "PatchRowcode": "         package_full_path = lollmsElfServer.lollms_paths.custom_personalities_path/f\"{name}\""
            },
            "32": {
                "beforePatchRowNumber": 388,
                "afterPatchRowNumber": 393,
                "PatchRowcode": "     category = sanitize_path(data.category)"
            },
            "33": {
                "beforePatchRowNumber": 389,
                "afterPatchRowNumber": 394,
                "PatchRowcode": "     name = sanitize_path(data.folder)"
            },
            "34": {
                "beforePatchRowNumber": 390,
                "afterPatchRowNumber": 395,
                "PatchRowcode": "     language = data.language #.get('language', None)"
            },
            "35": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 396,
                "PatchRowcode": "+    if category==\"\":"
            },
            "36": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 397,
                "PatchRowcode": "+        return {\"status\":False, \"error\":\"category must not be empty.\"}"
            },
            "37": {
                "beforePatchRowNumber": 391,
                "afterPatchRowNumber": 398,
                "PatchRowcode": " "
            },
            "38": {
                "beforePatchRowNumber": 392,
                "afterPatchRowNumber": 399,
                "PatchRowcode": "     package_path = f\"{category}/{name}\""
            },
            "39": {
                "beforePatchRowNumber": 393,
                "afterPatchRowNumber": 400,
                "PatchRowcode": "     if category==\"custom_personalities\":"
            },
            "40": {
                "beforePatchRowNumber": 443,
                "afterPatchRowNumber": 450,
                "PatchRowcode": "     name = sanitize_path(data.folder)"
            },
            "41": {
                "beforePatchRowNumber": 444,
                "afterPatchRowNumber": 451,
                "PatchRowcode": "     language = data.language #.get('language', None)"
            },
            "42": {
                "beforePatchRowNumber": 445,
                "afterPatchRowNumber": 452,
                "PatchRowcode": " "
            },
            "43": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 453,
                "PatchRowcode": "+    if category==\"\":"
            },
            "44": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 454,
                "PatchRowcode": "+        return {\"status\":False, \"error\":\"category must not be empty.\"}"
            },
            "45": {
                "beforePatchRowNumber": 446,
                "afterPatchRowNumber": 455,
                "PatchRowcode": " "
            },
            "46": {
                "beforePatchRowNumber": 447,
                "afterPatchRowNumber": 456,
                "PatchRowcode": "     package_path = f\"{category}/{name}\""
            },
            "47": {
                "beforePatchRowNumber": 448,
                "afterPatchRowNumber": 457,
                "PatchRowcode": "     if category==\"custom_personalities\":"
            },
            "48": {
                "beforePatchRowNumber": 497,
                "afterPatchRowNumber": 506,
                "PatchRowcode": "     name = sanitize_path(data.folder)"
            },
            "49": {
                "beforePatchRowNumber": 498,
                "afterPatchRowNumber": 507,
                "PatchRowcode": "     language = data.language #.get('language', None)"
            },
            "50": {
                "beforePatchRowNumber": 499,
                "afterPatchRowNumber": 508,
                "PatchRowcode": " "
            },
            "51": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 509,
                "PatchRowcode": "+    if category==\"\":"
            },
            "52": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 510,
                "PatchRowcode": "+        return {\"status\":False, \"error\":\"category must not be empty.\"}"
            },
            "53": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 511,
                "PatchRowcode": "+"
            },
            "54": {
                "beforePatchRowNumber": 500,
                "afterPatchRowNumber": 512,
                "PatchRowcode": "     try:"
            },
            "55": {
                "beforePatchRowNumber": 501,
                "afterPatchRowNumber": 513,
                "PatchRowcode": "         personality_id = f\"{category}/{name}\" if language is None or language==\"\" else f\"{category}/{name}:{language}\""
            },
            "56": {
                "beforePatchRowNumber": 502,
                "afterPatchRowNumber": 514,
                "PatchRowcode": "         index = lollmsElfServer.config[\"personalities\"].index(personality_id)"
            },
            "57": {
                "beforePatchRowNumber": 595,
                "afterPatchRowNumber": 607,
                "PatchRowcode": "     print(\"- Retreiving personality settings\")"
            },
            "58": {
                "beforePatchRowNumber": 596,
                "afterPatchRowNumber": 608,
                "PatchRowcode": "     category = sanitize_path(data.category)"
            },
            "59": {
                "beforePatchRowNumber": 597,
                "afterPatchRowNumber": 609,
                "PatchRowcode": "     name = sanitize_path(data.folder)"
            },
            "60": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 610,
                "PatchRowcode": "+    if category==\"\":"
            },
            "61": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 611,
                "PatchRowcode": "+        return {\"status\":False, \"error\":\"category must not be empty.\"}"
            },
            "62": {
                "beforePatchRowNumber": 598,
                "afterPatchRowNumber": 612,
                "PatchRowcode": " "
            },
            "63": {
                "beforePatchRowNumber": 599,
                "afterPatchRowNumber": 613,
                "PatchRowcode": "     if category == \"custom_personalities\":"
            },
            "64": {
                "beforePatchRowNumber": 600,
                "afterPatchRowNumber": 614,
                "PatchRowcode": "         personality_folder = lollmsElfServer.lollms_paths.personal_personalities_path/f\"{name}\""
            }
        },
        "frontPatchFile": [
            "\"\"\"",
            "project: lollms",
            "file: lollms_personalities_infos.py ",
            "author: ParisNeo",
            "description: ",
            "    This module contains a set of FastAPI routes that provide information about the Lord of Large Language and Multimodal Systems (LoLLMs) Web UI",
            "    application. These routes are specific to handling personalities related operations.",
            "",
            "\"\"\"",
            "from fastapi import APIRouter, Request",
            "from fastapi import HTTPException",
            "from fastapi.responses import FileResponse",
            "from pydantic import BaseModel, Field",
            "import pkg_resources",
            "from lollms.server.elf_server import LOLLMSElfServer",
            "from lollms.personality import AIPersonality, InstallOption",
            "from ascii_colors import ASCIIColors",
            "from lollms.utilities import load_config, trace_exception, gc, show_yes_no_dialog",
            "from lollms.security import check_access",
            "from pathlib import Path",
            "from typing import List, Optional",
            "import psutil",
            "import yaml",
            "from lollms.security import sanitize_path",
            "",
            "# --------------------- Parameter Classes -------------------------------",
            "",
            "class PersonalityListingInfos(BaseModel):",
            "    category:str",
            "",
            "",
            "class PersonalitySelectionInfos(BaseModel):",
            "    client_id:str",
            "    id:int",
            "",
            "# ----------------------- Defining router and main class ------------------------------",
            "router = APIRouter()",
            "lollmsElfServer = LOLLMSElfServer.get_instance()",
            "",
            "# --------------------- Listing -------------------------------",
            "",
            "@router.get(\"/list_personalities_categories\")",
            "def list_personalities_categories():",
            "    personalities_categories_dir = lollmsElfServer.lollms_paths.personalities_zoo_path  # replace with the actual path to the models folder",
            "    personalities_categories = [\"custom_personalities\"]+[f.stem for f in personalities_categories_dir.iterdir() if f.is_dir() and not f.name.startswith(\".\")]",
            "    return personalities_categories",
            "",
            "@router.get(\"/list_personalities\")",
            "def list_personalities(category:str):",
            "    category = sanitize_path(category)",
            "    if not category:",
            "        return []",
            "    try:",
            "        if category==\"custom_personalities\":",
            "            personalities_dir = lollmsElfServer.lollms_paths.custom_personalities_path  # replace with the actual path to the models folder",
            "        else:",
            "            personalities_dir = lollmsElfServer.lollms_paths.personalities_zoo_path/f'{category}'  # replace with the actual path to the models folder",
            "        personalities = [f.stem for f in personalities_dir.iterdir() if f.is_dir() and not f.name.startswith(\".\")]",
            "    except Exception as ex:",
            "        personalities=[]",
            "        ASCIIColors.error(f\"No personalities found. Using default one {ex}\")",
            "    return personalities",
            "",
            "@router.get(\"/get_all_personalities\")",
            "def get_all_personalities():",
            "    ASCIIColors.yellow(\"Listing all personalities\")",
            "    personalities_folder = lollmsElfServer.lollms_paths.personalities_zoo_path",
            "    personalities = {}",
            "",
            "    for category_folder in  [lollmsElfServer.lollms_paths.custom_personalities_path] + list(personalities_folder.iterdir()):",
            "        cat = category_folder.stem",
            "        if category_folder.is_dir() and not category_folder.stem.startswith('.'):",
            "            personalities[cat if category_folder!=lollmsElfServer.lollms_paths.custom_personalities_path else \"custom_personalities\"] = []",
            "            for personality_folder in category_folder.iterdir():",
            "                pers = personality_folder.stem",
            "                if personality_folder.is_dir() and not personality_folder.stem.startswith('.'):",
            "                    personality_info = {\"folder\":personality_folder.stem}",
            "                    config_path = personality_folder / 'config.yaml'",
            "                    if not config_path.exists():",
            "                        \"\"\"",
            "                        try:",
            "                            shutil.rmtree(str(config_path.parent))",
            "                            ASCIIColors.warning(f\"Deleted useless personality: {config_path.parent}\")",
            "                        except Exception as ex:",
            "                            ASCIIColors.warning(f\"Couldn't delete personality ({ex})\")",
            "                        \"\"\"",
            "                        continue                                    ",
            "                    try:",
            "                        scripts_path = personality_folder / 'scripts'",
            "                        personality_info['has_scripts'] = scripts_path.exists()",
            "                        with open(config_path, \"r\", encoding=\"utf8\") as config_file:",
            "                            config_data = yaml.load(config_file, Loader=yaml.FullLoader)",
            "                            personality_info['name'] = config_data.get('name',\"No Name\")",
            "                            personality_info['description'] = config_data.get('personality_description',\"\")",
            "                            personality_info['disclaimer'] = config_data.get('disclaimer',\"\")",
            "                            ",
            "                            personality_info['author'] = config_data.get('author', 'ParisNeo')",
            "                            personality_info['version'] = config_data.get('version', '1.0.0')",
            "                            personality_info['installed'] = (lollmsElfServer.lollms_paths.personal_configuration_path/f\"personality_{personality_folder.stem}.yaml\").exists() or personality_info['has_scripts']",
            "                            personality_info['help'] = config_data.get('help', '')",
            "                            personality_info['commands'] = config_data.get('commands', '')",
            "                        languages_path = personality_folder/ 'languages'",
            "",
            "                        real_assets_path = personality_folder/ 'assets'",
            "                        assets_path = Path(\"personalities\") / cat / pers / 'assets'",
            "                        gif_logo_path = assets_path / 'logo.gif'",
            "                        webp_logo_path = assets_path / 'logo.webp'",
            "                        png_logo_path = assets_path / 'logo.png'",
            "                        jpg_logo_path = assets_path / 'logo.jpg'",
            "                        jpeg_logo_path = assets_path / 'logo.jpeg'",
            "                        svg_logo_path = assets_path / 'logo.svg'",
            "                        bmp_logo_path = assets_path / 'logo.bmp'",
            "",
            "                        gif_logo_path_ = real_assets_path / 'logo.gif'",
            "                        webp_logo_path_ = real_assets_path / 'logo.webp'",
            "                        png_logo_path_ = real_assets_path / 'logo.png'",
            "                        jpg_logo_path_ = real_assets_path / 'logo.jpg'",
            "                        jpeg_logo_path_ = real_assets_path / 'logo.jpeg'",
            "                        svg_logo_path_ = real_assets_path / 'logo.svg'",
            "                        bmp_logo_path_ = real_assets_path / 'logo.bmp'",
            "",
            "                        if languages_path.exists():",
            "                            personality_info['languages']= [\"\"]+[f.stem for f in languages_path.iterdir() if f.suffix==\".yaml\"]",
            "                        else:",
            "                            personality_info['languages']=None",
            "                            ",
            "                        personality_info['has_logo'] = png_logo_path.is_file() or gif_logo_path.is_file()",
            "                        ",
            "                        if gif_logo_path_.exists():",
            "                            personality_info['avatar'] = str(gif_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif webp_logo_path_.exists():",
            "                            personality_info['avatar'] = str(webp_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif png_logo_path_.exists():",
            "                            personality_info['avatar'] = str(png_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif jpg_logo_path_.exists():",
            "                            personality_info['avatar'] = str(jpg_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif jpeg_logo_path_.exists():",
            "                            personality_info['avatar'] = str(jpeg_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif svg_logo_path_.exists():",
            "                            personality_info['avatar'] = str(svg_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif bmp_logo_path_.exists():",
            "                            personality_info['avatar'] = str(bmp_logo_path).replace(\"\\\\\",\"/\")",
            "                        else:",
            "                            personality_info['avatar'] = \"\"",
            "                        ",
            "                        personalities[cat if category_folder!=lollmsElfServer.lollms_paths.custom_personalities_path else \"custom_personalities\"].append(personality_info)",
            "                    except Exception as ex:",
            "                        ASCIIColors.warning(f\"Couldn't load personality from {personality_folder} [{ex}]\")",
            "                        trace_exception(ex)",
            "    ASCIIColors.green(\"OK\")",
            "",
            "    return personalities",
            "",
            "",
            "@router.get(\"/list_mounted_personalities\")",
            "def list_mounted_personalities():",
            "    ASCIIColors.yellow(\"- Listing mounted personalities\")",
            "    return {\"status\": True,",
            "            \"personalities\":lollmsElfServer.config[\"personalities\"],",
            "            \"active_personality_id\":lollmsElfServer.config[\"active_personality_id\"]",
            "            }   ",
            "",
            "",
            "",
            "",
            "@router.get(\"/get_current_personality_path_infos\")",
            "def get_current_personality_path_infos():",
            "    if lollmsElfServer.personality is None:",
            "        return {",
            "            \"personality_category\":\"\", ",
            "            \"personality_name\":\"\"",
            "        }",
            "    else:",
            "        return {",
            "            \"personality_category\":lollmsElfServer.personality_category, ",
            "            \"personality_name\":lollmsElfServer.personality_name",
            "        }",
            "",
            "# ----------------------------------- Installation/Uninstallation/Reinstallation ----------------------------------------",
            "",
            "",
            "class PersonalityIn(BaseModel):",
            "    client_id:str",
            "    name: str = Field(None)",
            "",
            "@router.post(\"/reinstall_personality\")",
            "async def reinstall_personality(personality_in: PersonalityIn):",
            "    \"\"\"",
            "    Endpoint to reinstall personality",
            "",
            "    :param personality_in: PersonalityIn contans personality name.",
            "    :return: A JSON response with the status of the operation.",
            "    \"\"\"",
            "    check_access(lollmsElfServer, personality_in.client_id)",
            "    try:",
            "        sanitize_path(personality_in.name)",
            "        if not personality_in.name:",
            "            personality_in.name=lollmsElfServer.config.personalities[lollmsElfServer.config[\"active_personality_id\"]]",
            "        personality_path = lollmsElfServer.lollms_paths.personalities_zoo_path / personality_in.name",
            "        ASCIIColors.info(f\"- Reinstalling personality {personality_in.name}...\")",
            "        ASCIIColors.info(\"Unmounting personality\")",
            "        idx = lollmsElfServer.config.personalities.index(personality_in.name)",
            "        print(f\"index = {idx}\")",
            "        lollmsElfServer.mounted_personalities[idx] = None",
            "        gc.collect()",
            "        try:",
            "            lollmsElfServer.mounted_personalities[idx] = AIPersonality(personality_path,",
            "                                        lollmsElfServer.lollms_paths, ",
            "                                        lollmsElfServer.config,",
            "                                        model=lollmsElfServer.model,",
            "                                        app=lollmsElfServer,",
            "                                        run_scripts=True,installation_option=InstallOption.FORCE_INSTALL)",
            "            return {\"status\":True}",
            "        except Exception as ex:",
            "            ASCIIColors.error(f\"Personality file not found or is corrupted ({personality_in.name}).\\nReturned the following exception:{ex}\\nPlease verify that the personality you have selected exists or select another personality. Some updates may lead to change in personality name or category, so check the personality selection in settings to be sure.\")",
            "            ASCIIColors.info(\"Trying to force reinstall\")",
            "            return {\"status\":False, 'error':str(e)}",
            "",
            "    except Exception as e:",
            "        return {\"status\":False, 'error':str(e)}",
            "",
            "",
            "# ------------------------------------------- Files manipulation -----------------------------------------------------",
            "class Identification(BaseModel):",
            "    client_id:str",
            "",
            "@router.post(\"/get_current_personality_files_list\")",
            "def get_current_personality_files_list(data:Identification):",
            "    check_access(lollmsElfServer, data.client_id)",
            "    if lollmsElfServer.personality is None:",
            "        return {\"state\":False, \"error\":\"No personality selected\"}",
            "    return {\"state\":True, \"files\":[{\"name\":Path(f).name, \"size\":Path(f).stat().st_size} for f in lollmsElfServer.personality.text_files]+[{\"name\":Path(f).name, \"size\":Path(f).stat().st_size} for f in lollmsElfServer.personality.image_files]}",
            "",
            "@router.post(\"/clear_personality_files_list\")",
            "def clear_personality_files_list(data:Identification):",
            "    check_access(lollmsElfServer, data.client_id)",
            "    if lollmsElfServer.personality is None:",
            "        return {\"state\":False, \"error\":\"No personality selected\"}",
            "    lollmsElfServer.personality.remove_all_files()",
            "    return {\"state\":True}",
            "",
            "class RemoveFileData(BaseModel):",
            "    client_id:str",
            "    name:str",
            "    ",
            "@router.post(\"/remove_file\")",
            "def remove_file(data:RemoveFileData):",
            "    \"\"\"",
            "    Removes a file form the personality files",
            "    \"\"\"",
            "    check_access(lollmsElfServer, data.client_id)",
            "    ",
            "    if lollmsElfServer.personality is None:",
            "        return {\"state\":False, \"error\":\"No personality selected\"}",
            "    lollmsElfServer.personality.remove_file(data.name)",
            "    return {\"state\":True}",
            "",
            "",
            "",
            "# ------------------------------------------- Languages endpoints ------------------------------------------------",
            "@router.post(\"/get_personality_languages_list\")",
            "def get_current_personality_files_list(data:Identification):",
            "    check_access(lollmsElfServer, data.client_id)",
            "    languages_list = lollmsElfServer.get_personality_languages()",
            "    ",
            "    # Return the languages list",
            "    return languages_list",
            "",
            "@router.post(\"/get_personality_language\")",
            "def get_personality_language(request: Identification):",
            "    # Access verification",
            "    check_access(lollmsElfServer, request.client_id)",
            "    return lollmsElfServer.config.current_language",
            "",
            "class SetLanguageRequest(BaseModel):",
            "    client_id: str",
            "    language: str",
            "",
            "# Definition of the endpoint for setting the personality language",
            "@router.post(\"/set_personality_language\")",
            "def set_personality_language(request: SetLanguageRequest):",
            "    # Access verification",
            "    check_access(lollmsElfServer, request.client_id)",
            "    sanitize_path(request.language)",
            "",
            "    # Calling the method to set the personality language",
            "    success = lollmsElfServer.set_personality_language(request.language)",
            "    ",
            "    # Returning an appropriate response depending on whether the operation was successful or not",
            "    if success:",
            "        return {\"message\": f\"The personality language has been successfully set to {request.language}.\"}",
            "    else:",
            "        raise HTTPException(status_code=400, detail=\"Failed to set the personality language\")",
            "",
            "# Definition of the endpoint for setting the personality language",
            "@router.post(\"/del_personality_language\")",
            "def del_personality_language(request: SetLanguageRequest):",
            "    # Access verification",
            "    check_access(lollmsElfServer, request.client_id)",
            "    sanitize_path(request.language)",
            "    language = request.language.lower().strip().split()[0]",
            "    default_language = lollmsElfServer.personality.language.lower().strip().split()[0]",
            "",
            "    if language==default_language:",
            "        lollmsElfServer.InfoMessage(\"It is not possible to delete the default language of a personality\")",
            "        return",
            "    # Calling the method to set the personality language",
            "    if lollmsElfServer.config.turn_on_language_validation:",
            "        if not show_yes_no_dialog(\"Language deletion request received\",\"I have received a language deletion request. Are you sure?\"):",
            "            return",
            "    success = lollmsElfServer.del_personality_language(request.language)",
            "    ",
            "    # Returning an appropriate response depending on whether the operation was successful or not",
            "    if success:",
            "        return {\"message\": f\"The personality language has been successfully set to {request.language}.\"}",
            "    else:",
            "        raise HTTPException(status_code=400, detail=\"Failed to set the personality language\")",
            "",
            "# ------------------------------------------- Mounting/Unmounting/Remounting ------------------------------------------------",
            "class PersonalityDataRequest(BaseModel):",
            "    client_id:str",
            "    category:str",
            "    name:str",
            "",
            "",
            "",
            "@router.post(\"/get_personality_config\")",
            "def get_personality_config(data:PersonalityDataRequest):",
            "    print(\"- Recovering personality config\")",
            "    category = sanitize_path(data.category)",
            "    name = sanitize_path(data.name)",
            "",
            "    package_path = f\"{category}/{name}\"",
            "    if category==\"custom_personalities\":",
            "        package_full_path = lollmsElfServer.lollms_paths.custom_personalities_path/f\"{name}\"",
            "    else:            ",
            "        package_full_path = lollmsElfServer.lollms_paths.personalities_zoo_path/package_path",
            "    ",
            "    config_file = package_full_path / \"config.yaml\"",
            "    if config_file.exists():",
            "        with open(config_file,\"r\") as f:",
            "            config = yaml.safe_load(f)",
            "        return {\"status\":True, \"config\":config}",
            "    else:",
            "        return {\"status\":False, \"error\":\"Not found\"}",
            "    ",
            "class PersonalityConfig(BaseModel):",
            "    client_id:str",
            "    category:str",
            "    name:str",
            "    config:dict",
            "",
            "@router.post(\"/set_personality_config\")",
            "def set_personality_config(data:PersonalityConfig):",
            "    check_access(lollmsElfServer, data.client_id)",
            "    print(\"- Recovering personality config\")",
            "    category = sanitize_path(data.category)",
            "    name = sanitize_path(data.name)",
            "    config = data.config",
            "",
            "    package_path = f\"{category}/{name}\"",
            "    if category==\"custom_personalities\":",
            "        package_full_path = lollmsElfServer.lollms_paths.custom_personalities_path/f\"{name}\"",
            "    else:            ",
            "        package_full_path = lollmsElfServer.lollms_paths.personalities_zoo_path/package_path",
            "    ",
            "    config_file = package_full_path / \"config.yaml\"",
            "    if config_file.exists():",
            "        with open(config_file,\"w\") as f:",
            "            yaml.safe_dump(config, f)",
            "",
            "        lollmsElfServer.mounted_personalities = lollmsElfServer.rebuild_personalities(reload_all=True)",
            "        lollmsElfServer.InfoMessage(\"Personality updated\")",
            "        return {\"status\":True}",
            "    else:",
            "        return {\"status\":False, \"error\":\"Not found\"}",
            "",
            "class PersonalityMountingInfos(BaseModel):",
            "    client_id:str",
            "    category:str",
            "    folder:str",
            "    language:Optional[str] = None",
            "",
            "@router.post(\"/mount_personality\")",
            "def mount_personality(data:PersonalityMountingInfos):",
            "    check_access(lollmsElfServer, data.client_id)",
            "    print(\"- Mounting personality\")",
            "    category = sanitize_path(data.category)",
            "    name = sanitize_path(data.folder)",
            "    language = data.language #.get('language', None)",
            "",
            "    package_path = f\"{category}/{name}\"",
            "    if category==\"custom_personalities\":",
            "        package_full_path = lollmsElfServer.lollms_paths.custom_personalities_path/f\"{name}\"",
            "    else:            ",
            "        package_full_path = lollmsElfServer.lollms_paths.personalities_zoo_path/package_path",
            "    ",
            "    config_file = package_full_path / \"config.yaml\"",
            "    if config_file.exists():",
            "        if language:",
            "            package_path += \":\" + language",
            "        \"\"\"",
            "        if package_path in lollmsElfServer.config[\"personalities\"]:",
            "            ASCIIColors.error(\"Can't mount exact same personality twice\")",
            "            return jsonify({\"status\": False,",
            "                            \"error\":\"Can't mount exact same personality twice\",",
            "                            \"personalities\":lollmsElfServer.config[\"personalities\"],",
            "                            \"active_personality_id\":lollmsElfServer.config[\"active_personality_id\"]",
            "                            })                ",
            "        \"\"\"",
            "        lollmsElfServer.config[\"personalities\"].append(package_path)",
            "        lollmsElfServer.mounted_personalities = lollmsElfServer.rebuild_personalities()",
            "        lollmsElfServer.config[\"active_personality_id\"]= len(lollmsElfServer.config[\"personalities\"])-1",
            "        lollmsElfServer.personality = lollmsElfServer.mounted_personalities[lollmsElfServer.config[\"active_personality_id\"]]",
            "        ASCIIColors.success(\"ok\")",
            "        if lollmsElfServer.config[\"active_personality_id\"]<0:",
            "            ASCIIColors.error(\"error:active_personality_id<0\")",
            "            return {\"status\": False,",
            "                            \"error\":\"active_personality_id<0\",",
            "                            \"personalities\":lollmsElfServer.config[\"personalities\"],",
            "                            \"active_personality_id\":lollmsElfServer.config[\"active_personality_id\"]",
            "                            }         ",
            "        else:",
            "            if lollmsElfServer.config.auto_save:",
            "                ASCIIColors.info(\"Saving configuration\")",
            "                lollmsElfServer.config.save_config()",
            "            ASCIIColors.success(f\"Personality {name} mounted successfully\")",
            "            return {\"status\": True,",
            "                            \"personalities\":lollmsElfServer.config[\"personalities\"],",
            "                            \"active_personality_id\":lollmsElfServer.config[\"active_personality_id\"]",
            "                            }    ",
            "    else:",
            "        pth = str(config_file).replace('\\\\','/')",
            "        ASCIIColors.error(f\"nok : Personality not found @ {pth}\")            ",
            "        ASCIIColors.yellow(f\"Available personalities: {[p.name for p in lollmsElfServer.mounted_personalities]}\")",
            "        return {\"status\": False, \"error\":f\"Personality not found @ {pth}\"}",
            "",
            "",
            "@router.post(\"/remount_personality\")",
            "def remount_personality(data:PersonalityMountingInfos):",
            "    check_access(lollmsElfServer, data.client_id)",
            "    category = sanitize_path(data.category)",
            "    name = sanitize_path(data.folder)",
            "    language = data.language #.get('language', None)",
            "",
            "",
            "    package_path = f\"{category}/{name}\"",
            "    if category==\"custom_personalities\":",
            "        package_full_path = lollmsElfServer.lollms_paths.custom_personalities_path/f\"{name}\"",
            "    else:            ",
            "        package_full_path = lollmsElfServer.lollms_paths.personalities_zoo_path/package_path",
            "    ",
            "    config_file = package_full_path / \"config.yaml\"",
            "    if config_file.exists():",
            "        ASCIIColors.info(f\"Unmounting personality {package_path}\")",
            "        index = lollmsElfServer.config[\"personalities\"].index(f\"{category}/{name}\")",
            "        lollmsElfServer.config[\"personalities\"].remove(f\"{category}/{name}\")",
            "        if lollmsElfServer.config[\"active_personality_id\"]>=index:",
            "            lollmsElfServer.config[\"active_personality_id\"]=0",
            "        if len(lollmsElfServer.config[\"personalities\"])>0:",
            "            lollmsElfServer.mounted_personalities = lollmsElfServer.rebuild_personalities()",
            "            lollmsElfServer.personality = lollmsElfServer.mounted_personalities[lollmsElfServer.config[\"active_personality_id\"]]",
            "        else:",
            "            lollmsElfServer.personalities = [\"generic/lollms\"]",
            "            lollmsElfServer.mounted_personalities = lollmsElfServer.rebuild_personalities()",
            "            lollmsElfServer.personality = lollmsElfServer.mounted_personalities[lollmsElfServer.config[\"active_personality_id\"]]",
            "",
            "",
            "        ASCIIColors.info(f\"Mounting personality {package_path}\")",
            "        lollmsElfServer.config[\"personalities\"].append(package_path)",
            "        lollmsElfServer.config[\"active_personality_id\"]= len(lollmsElfServer.config[\"personalities\"])-1",
            "        lollmsElfServer.mounted_personalities = lollmsElfServer.rebuild_personalities()",
            "        lollmsElfServer.personality = lollmsElfServer.mounted_personalities[lollmsElfServer.config[\"active_personality_id\"]]",
            "        ASCIIColors.success(\"ok\")",
            "        if lollmsElfServer.config[\"active_personality_id\"]<0:",
            "            return {\"status\": False,",
            "                            \"personalities\":lollmsElfServer.config[\"personalities\"],",
            "                            \"active_personality_id\":lollmsElfServer.config[\"active_personality_id\"]",
            "                            }      ",
            "        else:",
            "            return {\"status\": True,",
            "                            \"personalities\":lollmsElfServer.config[\"personalities\"],",
            "                            \"active_personality_id\":lollmsElfServer.config[\"active_personality_id\"]",
            "                            }    ",
            "    else:",
            "        pth = str(config_file).replace('\\\\','/')",
            "        ASCIIColors.error(f\"nok : Personality not found @ {pth}\")",
            "        ASCIIColors.yellow(f\"Available personalities: {[p.name for p in lollmsElfServer.mounted_personalities]}\")",
            "        return {\"status\": False, \"error\":f\"Personality not found @ {pth}\"}  ",
            "    ",
            "",
            "@router.post(\"/unmount_personality\")",
            "def unmount_personality(data:PersonalityMountingInfos):",
            "    check_access(lollmsElfServer, data.client_id)",
            "    print(\"- Unmounting personality ...\")",
            "    category = sanitize_path(data.category)",
            "    name = sanitize_path(data.folder)",
            "    language = data.language #.get('language', None)",
            "",
            "    try:",
            "        personality_id = f\"{category}/{name}\" if language is None or language==\"\" else f\"{category}/{name}:{language}\"",
            "        index = lollmsElfServer.config[\"personalities\"].index(personality_id)",
            "        lollmsElfServer.config[\"personalities\"].remove(personality_id)",
            "        if lollmsElfServer.config[\"active_personality_id\"]>=index:",
            "            lollmsElfServer.config[\"active_personality_id\"]=0",
            "        if len(lollmsElfServer.config[\"personalities\"])>0:",
            "            lollmsElfServer.mounted_personalities = lollmsElfServer.rebuild_personalities()",
            "            lollmsElfServer.personality = lollmsElfServer.mounted_personalities[lollmsElfServer.config[\"active_personality_id\"]]",
            "        else:",
            "            lollmsElfServer.personalities = [\"generic/lollms\"]",
            "            lollmsElfServer.mounted_personalities = lollmsElfServer.rebuild_personalities()",
            "            if lollmsElfServer.config[\"active_personality_id\"]<len(lollmsElfServer.mounted_personalities):",
            "                lollmsElfServer.personality = lollmsElfServer.mounted_personalities[lollmsElfServer.config[\"active_personality_id\"]]",
            "            else:",
            "                lollmsElfServer.config[\"active_personality_id\"] = -1",
            "        ASCIIColors.success(\"ok\")",
            "        if lollmsElfServer.config.auto_save:",
            "            ASCIIColors.info(\"Saving configuration\")",
            "            lollmsElfServer.config.save_config()",
            "        return {",
            "                    \"status\": True,",
            "                    \"personalities\":lollmsElfServer.config[\"personalities\"],",
            "                    \"active_personality_id\":lollmsElfServer.config[\"active_personality_id\"]",
            "                    }",
            "    except Exception as ex:",
            "        trace_exception(ex)",
            "        if language:",
            "            ASCIIColors.error(f\"nok : Personality not found @ {category}/{name}:{language}\")",
            "        else:",
            "            ASCIIColors.error(f\"nok : Personality not found @ {category}/{name}\")",
            "            ",
            "        ASCIIColors.yellow(f\"Available personalities: {[p.name for p in lollmsElfServer.mounted_personalities if p is not None]}\")",
            "        return {\"status\": False, \"error\":\"Couldn't unmount personality\"}",
            "    ",
            "",
            "class AuthenticationInfos(BaseModel):",
            "    client_id:str",
            "",
            "@router.post(\"/unmount_all_personalities\")",
            "def unmount_all_personalities(data:AuthenticationInfos):",
            "    check_access(lollmsElfServer, data.client_id)",
            "    lollmsElfServer.config.personalities=[\"generic/lollms\"]",
            "    lollmsElfServer.mounted_personalities=[]",
            "    lollmsElfServer.personality=None",
            "    lollmsElfServer.mount_personality(0)",
            "    lollmsElfServer.config.save_config()",
            "    return {\"status\":True}",
            "",
            "",
            "",
            "# ------------------------------------------- Selecting personality ------------------------------------------------",
            "",
            "@router.post(\"/select_personality\")",
            "def select_personality(data:PersonalitySelectionInfos):",
            "    check_access(lollmsElfServer, data.client_id)",
            "    ASCIIColors.info(\"Selecting personality\")",
            "    id = data.id",
            "    print(f\"- Selecting active personality {id} ...\",end=\"\")",
            "    if id<len(lollmsElfServer.mounted_personalities):",
            "        lollmsElfServer.config[\"active_personality_id\"]=id",
            "        lollmsElfServer.personality:AIPersonality = lollmsElfServer.mounted_personalities[lollmsElfServer.config[\"active_personality_id\"]]",
            "        if lollmsElfServer.personality is None:",
            "            return {\"status\": False, \"error\":\"Something is wrong with the personality\"}",
            "        if lollmsElfServer.personality.processor:",
            "            lollmsElfServer.personality.processor.selected()",
            "        ASCIIColors.success(\"ok\")",
            "        ",
            "        print(f\"Selected {lollmsElfServer.personality.name}\")",
            "",
            "        language = lollmsElfServer.config.current_language",
            "        if lollmsElfServer.personality.language is None:",
            "            lollmsElfServer.personality.language = \"english\"",
            "        default_language = lollmsElfServer.personality.language.lower().strip().split()[0]",
            "",
            "        if language != default_language:",
            "            lollmsElfServer.set_personality_language(language)",
            "",
            "        if lollmsElfServer.config.auto_save:",
            "            ASCIIColors.info(\"Saving configuration\")",
            "            lollmsElfServer.config.save_config()",
            "        return {",
            "            \"status\": True,",
            "            \"personalities\":lollmsElfServer.config[\"personalities\"],",
            "            \"active_personality_id\":lollmsElfServer.config[\"active_personality_id\"]                ",
            "            }",
            "    else:",
            "        ASCIIColors.error(f\"nok : personality id out of bounds @ {id} >= {len(lollmsElfServer.mounted_personalities)}\")",
            "        return {\"status\": False, \"error\":\"Invalid ID\"}",
            "            ",
            "# ------------------------------------------- Personality settings------------------------------------------------",
            "",
            "@router.post(\"/get_personality_settings\")",
            "def get_personality_settings(data:PersonalityMountingInfos):",
            "    check_access(lollmsElfServer, data.client_id)",
            "    print(\"- Retreiving personality settings\")",
            "    category = sanitize_path(data.category)",
            "    name = sanitize_path(data.folder)",
            "",
            "    if category == \"custom_personalities\":",
            "        personality_folder = lollmsElfServer.lollms_paths.personal_personalities_path/f\"{name}\"",
            "    else:",
            "        personality_folder = lollmsElfServer.lollms_paths.personalities_zoo_path/f\"{category}\"/f\"{name}\"",
            "",
            "    personality = AIPersonality(personality_folder,",
            "                                lollmsElfServer.lollms_paths, ",
            "                                lollmsElfServer.config,",
            "                                model=lollmsElfServer.model,",
            "                                app=lollmsElfServer,",
            "                                run_scripts=True)",
            "    if personality.processor is not None:",
            "        if hasattr(personality.processor,\"personality_config\"):",
            "            return personality.processor.personality_config.config_template.template",
            "        else:",
            "            return {}   ",
            "    else:",
            "        return {}  ",
            "",
            "",
            "@router.get(\"/get_active_personality_settings\")",
            "def get_active_personality_settings():",
            "    print(\"- Retreiving personality settings\")",
            "    if lollmsElfServer.personality.processor is not None:",
            "        if hasattr(lollmsElfServer.personality.processor,\"personality_config\"):",
            "            return lollmsElfServer.personality.processor.personality_config.config_template.template",
            "        else:",
            "            return {}",
            "    else:",
            "        return {}",
            "",
            "",
            "@router.post(\"/set_active_personality_settings\")",
            "async def set_active_personality_settings(request: Request):",
            "    \"\"\"",
            "    sets the active personality settings.",
            "",
            "    :param request: The HTTP request object.",
            "    :return: A JSON response with the status of the operation.",
            "    \"\"\"",
            "",
            "    try:",
            "        config_data = (await request.json())",
            "",
            "        print(\"- Setting personality settings\")",
            "        ",
            "        if lollmsElfServer.personality.processor is not None:",
            "            if hasattr(lollmsElfServer.personality.processor,\"personality_config\"):",
            "                lollmsElfServer.personality.processor.personality_config.update_template(config_data)",
            "                lollmsElfServer.personality.processor.personality_config.config.save_config()",
            "                if lollmsElfServer.config.auto_save:",
            "                    ASCIIColors.info(\"Saving configuration\")",
            "                    lollmsElfServer.config.save_config()",
            "                if lollmsElfServer.personality.processor:",
            "                    lollmsElfServer.personality.processor.settings_updated()",
            "                return {'status':True}",
            "            else:",
            "                return {'status':False}",
            "        else:",
            "            return {'status':False}  ",
            "    except Exception as ex:",
            "        trace_exception(ex)",
            "        lollmsElfServer.error(ex)",
            "        return {\"status\":False,\"error\":str(ex)}",
            "",
            "",
            "class PersonalityInfos(BaseModel):",
            "    category:str",
            "    name:str",
            "    language:Optional[str] = None",
            "",
            "@router.post(\"/copy_to_custom_personas\")",
            "async def copy_to_custom_personas(data: PersonalityInfos):",
            "    \"\"\"",
            "    Copies the personality to custom personas so that you can modify it.",
            "",
            "    \"\"\"",
            "    import shutil",
            "    ",
            "    category = sanitize_path(data.category)",
            "    name = sanitize_path(data.name)",
            "",
            "    if category==\"custom_personalities\":",
            "        lollmsElfServer.InfoMessage(\"This persona is already in custom personalities folder\")",
            "        return {\"status\":False}",
            "    else:",
            "        personality_folder = lollmsElfServer.lollms_paths.personalities_zoo_path/f\"{category}\"/f\"{name}\"",
            "        destination_folder = lollmsElfServer.lollms_paths.custom_personalities_path",
            "        shutil.copytree(personality_folder, destination_folder/f\"{name}\")",
            "        return {\"status\":True}",
            "",
            "# ------------------------------------------- Interaction with personas ------------------------------------------------",
            "@router.post(\"/post_to_personality\")",
            "async def post_to_personality(request: Request):",
            "    \"\"\"Post data to a personality\"\"\"",
            "",
            "    try:",
            "        if hasattr(lollmsElfServer.personality.processor,'handle_request'):",
            "            return await lollmsElfServer.personality.processor.handle_request(request)",
            "        else:",
            "            return {}",
            "    except Exception as ex:",
            "        trace_exception(ex)",
            "        lollmsElfServer.error(ex)",
            "        return {\"status\":False,\"error\":str(ex)}",
            "    "
        ],
        "afterPatchFile": [
            "\"\"\"",
            "project: lollms",
            "file: lollms_personalities_infos.py ",
            "author: ParisNeo",
            "description: ",
            "    This module contains a set of FastAPI routes that provide information about the Lord of Large Language and Multimodal Systems (LoLLMs) Web UI",
            "    application. These routes are specific to handling personalities related operations.",
            "",
            "\"\"\"",
            "from fastapi import APIRouter, Request",
            "from fastapi import HTTPException",
            "from fastapi.responses import FileResponse",
            "from pydantic import BaseModel, Field",
            "import pkg_resources",
            "from lollms.server.elf_server import LOLLMSElfServer",
            "from lollms.personality import AIPersonality, InstallOption",
            "from ascii_colors import ASCIIColors",
            "from lollms.utilities import load_config, trace_exception, gc, show_yes_no_dialog",
            "from lollms.security import check_access, forbid_remote_access",
            "from pathlib import Path",
            "from typing import List, Optional",
            "import psutil",
            "import yaml",
            "from lollms.security import sanitize_path",
            "",
            "# --------------------- Parameter Classes -------------------------------",
            "",
            "class PersonalityListingInfos(BaseModel):",
            "    category:str",
            "",
            "",
            "class PersonalitySelectionInfos(BaseModel):",
            "    client_id:str",
            "    id:int",
            "",
            "# ----------------------- Defining router and main class ------------------------------",
            "router = APIRouter()",
            "lollmsElfServer = LOLLMSElfServer.get_instance()",
            "",
            "# --------------------- Listing -------------------------------",
            "",
            "@router.get(\"/list_personalities_categories\")",
            "def list_personalities_categories():",
            "    personalities_categories_dir = lollmsElfServer.lollms_paths.personalities_zoo_path  # replace with the actual path to the models folder",
            "    personalities_categories = [\"custom_personalities\"]+[f.stem for f in personalities_categories_dir.iterdir() if f.is_dir() and not f.name.startswith(\".\")]",
            "    return personalities_categories",
            "",
            "@router.get(\"/list_personalities\")",
            "def list_personalities(category:str):",
            "    category = sanitize_path(category)",
            "    if not category:",
            "        return []",
            "    try:",
            "        if category==\"custom_personalities\":",
            "            personalities_dir = lollmsElfServer.lollms_paths.custom_personalities_path  # replace with the actual path to the models folder",
            "        else:",
            "            personalities_dir = lollmsElfServer.lollms_paths.personalities_zoo_path/f'{category}'  # replace with the actual path to the models folder",
            "        personalities = [f.stem for f in personalities_dir.iterdir() if f.is_dir() and not f.name.startswith(\".\")]",
            "    except Exception as ex:",
            "        personalities=[]",
            "        ASCIIColors.error(f\"No personalities found. Using default one {ex}\")",
            "    return personalities",
            "",
            "@router.get(\"/get_all_personalities\")",
            "def get_all_personalities():",
            "    ASCIIColors.yellow(\"Listing all personalities\")",
            "    personalities_folder = lollmsElfServer.lollms_paths.personalities_zoo_path",
            "    personalities = {}",
            "",
            "    for category_folder in  [lollmsElfServer.lollms_paths.custom_personalities_path] + list(personalities_folder.iterdir()):",
            "        cat = category_folder.stem",
            "        if category_folder.is_dir() and not category_folder.stem.startswith('.'):",
            "            personalities[cat if category_folder!=lollmsElfServer.lollms_paths.custom_personalities_path else \"custom_personalities\"] = []",
            "            for personality_folder in category_folder.iterdir():",
            "                pers = personality_folder.stem",
            "                if personality_folder.is_dir() and not personality_folder.stem.startswith('.'):",
            "                    personality_info = {\"folder\":personality_folder.stem}",
            "                    config_path = personality_folder / 'config.yaml'",
            "                    if not config_path.exists():",
            "                        \"\"\"",
            "                        try:",
            "                            shutil.rmtree(str(config_path.parent))",
            "                            ASCIIColors.warning(f\"Deleted useless personality: {config_path.parent}\")",
            "                        except Exception as ex:",
            "                            ASCIIColors.warning(f\"Couldn't delete personality ({ex})\")",
            "                        \"\"\"",
            "                        continue                                    ",
            "                    try:",
            "                        scripts_path = personality_folder / 'scripts'",
            "                        personality_info['has_scripts'] = scripts_path.exists()",
            "                        with open(config_path, \"r\", encoding=\"utf8\") as config_file:",
            "                            config_data = yaml.load(config_file, Loader=yaml.FullLoader)",
            "                            personality_info['name'] = config_data.get('name',\"No Name\")",
            "                            personality_info['description'] = config_data.get('personality_description',\"\")",
            "                            personality_info['disclaimer'] = config_data.get('disclaimer',\"\")",
            "                            ",
            "                            personality_info['author'] = config_data.get('author', 'ParisNeo')",
            "                            personality_info['version'] = config_data.get('version', '1.0.0')",
            "                            personality_info['installed'] = (lollmsElfServer.lollms_paths.personal_configuration_path/f\"personality_{personality_folder.stem}.yaml\").exists() or personality_info['has_scripts']",
            "                            personality_info['help'] = config_data.get('help', '')",
            "                            personality_info['commands'] = config_data.get('commands', '')",
            "                        languages_path = personality_folder/ 'languages'",
            "",
            "                        real_assets_path = personality_folder/ 'assets'",
            "                        assets_path = Path(\"personalities\") / cat / pers / 'assets'",
            "                        gif_logo_path = assets_path / 'logo.gif'",
            "                        webp_logo_path = assets_path / 'logo.webp'",
            "                        png_logo_path = assets_path / 'logo.png'",
            "                        jpg_logo_path = assets_path / 'logo.jpg'",
            "                        jpeg_logo_path = assets_path / 'logo.jpeg'",
            "                        svg_logo_path = assets_path / 'logo.svg'",
            "                        bmp_logo_path = assets_path / 'logo.bmp'",
            "",
            "                        gif_logo_path_ = real_assets_path / 'logo.gif'",
            "                        webp_logo_path_ = real_assets_path / 'logo.webp'",
            "                        png_logo_path_ = real_assets_path / 'logo.png'",
            "                        jpg_logo_path_ = real_assets_path / 'logo.jpg'",
            "                        jpeg_logo_path_ = real_assets_path / 'logo.jpeg'",
            "                        svg_logo_path_ = real_assets_path / 'logo.svg'",
            "                        bmp_logo_path_ = real_assets_path / 'logo.bmp'",
            "",
            "                        if languages_path.exists():",
            "                            personality_info['languages']= [\"\"]+[f.stem for f in languages_path.iterdir() if f.suffix==\".yaml\"]",
            "                        else:",
            "                            personality_info['languages']=None",
            "                            ",
            "                        personality_info['has_logo'] = png_logo_path.is_file() or gif_logo_path.is_file()",
            "                        ",
            "                        if gif_logo_path_.exists():",
            "                            personality_info['avatar'] = str(gif_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif webp_logo_path_.exists():",
            "                            personality_info['avatar'] = str(webp_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif png_logo_path_.exists():",
            "                            personality_info['avatar'] = str(png_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif jpg_logo_path_.exists():",
            "                            personality_info['avatar'] = str(jpg_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif jpeg_logo_path_.exists():",
            "                            personality_info['avatar'] = str(jpeg_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif svg_logo_path_.exists():",
            "                            personality_info['avatar'] = str(svg_logo_path).replace(\"\\\\\",\"/\")",
            "                        elif bmp_logo_path_.exists():",
            "                            personality_info['avatar'] = str(bmp_logo_path).replace(\"\\\\\",\"/\")",
            "                        else:",
            "                            personality_info['avatar'] = \"\"",
            "                        ",
            "                        personalities[cat if category_folder!=lollmsElfServer.lollms_paths.custom_personalities_path else \"custom_personalities\"].append(personality_info)",
            "                    except Exception as ex:",
            "                        ASCIIColors.warning(f\"Couldn't load personality from {personality_folder} [{ex}]\")",
            "                        trace_exception(ex)",
            "    ASCIIColors.green(\"OK\")",
            "",
            "    return personalities",
            "",
            "",
            "@router.get(\"/list_mounted_personalities\")",
            "def list_mounted_personalities():",
            "    ASCIIColors.yellow(\"- Listing mounted personalities\")",
            "    return {\"status\": True,",
            "            \"personalities\":lollmsElfServer.config[\"personalities\"],",
            "            \"active_personality_id\":lollmsElfServer.config[\"active_personality_id\"]",
            "            }   ",
            "",
            "",
            "",
            "",
            "@router.get(\"/get_current_personality_path_infos\")",
            "def get_current_personality_path_infos():",
            "    if lollmsElfServer.personality is None:",
            "        return {",
            "            \"personality_category\":\"\", ",
            "            \"personality_name\":\"\"",
            "        }",
            "    else:",
            "        return {",
            "            \"personality_category\":lollmsElfServer.personality_category, ",
            "            \"personality_name\":lollmsElfServer.personality_name",
            "        }",
            "",
            "# ----------------------------------- Installation/Uninstallation/Reinstallation ----------------------------------------",
            "",
            "",
            "class PersonalityIn(BaseModel):",
            "    client_id:str",
            "    name: str = Field(None)",
            "",
            "@router.post(\"/reinstall_personality\")",
            "async def reinstall_personality(personality_in: PersonalityIn):",
            "    \"\"\"",
            "    Endpoint to reinstall personality",
            "",
            "    :param personality_in: PersonalityIn contans personality name.",
            "    :return: A JSON response with the status of the operation.",
            "    \"\"\"",
            "    check_access(lollmsElfServer, personality_in.client_id)",
            "    try:",
            "        sanitize_path(personality_in.name)",
            "        if not personality_in.name:",
            "            personality_in.name=lollmsElfServer.config.personalities[lollmsElfServer.config[\"active_personality_id\"]]",
            "        personality_path = lollmsElfServer.lollms_paths.personalities_zoo_path / personality_in.name",
            "        ASCIIColors.info(f\"- Reinstalling personality {personality_in.name}...\")",
            "        ASCIIColors.info(\"Unmounting personality\")",
            "        idx = lollmsElfServer.config.personalities.index(personality_in.name)",
            "        print(f\"index = {idx}\")",
            "        lollmsElfServer.mounted_personalities[idx] = None",
            "        gc.collect()",
            "        try:",
            "            lollmsElfServer.mounted_personalities[idx] = AIPersonality(personality_path,",
            "                                        lollmsElfServer.lollms_paths, ",
            "                                        lollmsElfServer.config,",
            "                                        model=lollmsElfServer.model,",
            "                                        app=lollmsElfServer,",
            "                                        run_scripts=True,installation_option=InstallOption.FORCE_INSTALL)",
            "            return {\"status\":True}",
            "        except Exception as ex:",
            "            ASCIIColors.error(f\"Personality file not found or is corrupted ({personality_in.name}).\\nReturned the following exception:{ex}\\nPlease verify that the personality you have selected exists or select another personality. Some updates may lead to change in personality name or category, so check the personality selection in settings to be sure.\")",
            "            ASCIIColors.info(\"Trying to force reinstall\")",
            "            return {\"status\":False, 'error':str(e)}",
            "",
            "    except Exception as e:",
            "        return {\"status\":False, 'error':str(e)}",
            "",
            "",
            "# ------------------------------------------- Files manipulation -----------------------------------------------------",
            "class Identification(BaseModel):",
            "    client_id:str",
            "",
            "@router.post(\"/get_current_personality_files_list\")",
            "def get_current_personality_files_list(data:Identification):",
            "    check_access(lollmsElfServer, data.client_id)",
            "    if lollmsElfServer.personality is None:",
            "        return {\"state\":False, \"error\":\"No personality selected\"}",
            "    return {\"state\":True, \"files\":[{\"name\":Path(f).name, \"size\":Path(f).stat().st_size} for f in lollmsElfServer.personality.text_files]+[{\"name\":Path(f).name, \"size\":Path(f).stat().st_size} for f in lollmsElfServer.personality.image_files]}",
            "",
            "@router.post(\"/clear_personality_files_list\")",
            "def clear_personality_files_list(data:Identification):",
            "    check_access(lollmsElfServer, data.client_id)",
            "    if lollmsElfServer.personality is None:",
            "        return {\"state\":False, \"error\":\"No personality selected\"}",
            "    lollmsElfServer.personality.remove_all_files()",
            "    return {\"state\":True}",
            "",
            "class RemoveFileData(BaseModel):",
            "    client_id:str",
            "    name:str",
            "    ",
            "@router.post(\"/remove_file\")",
            "def remove_file(data:RemoveFileData):",
            "    \"\"\"",
            "    Removes a file form the personality files",
            "    \"\"\"",
            "    check_access(lollmsElfServer, data.client_id)",
            "    ",
            "    if lollmsElfServer.personality is None:",
            "        return {\"state\":False, \"error\":\"No personality selected\"}",
            "    lollmsElfServer.personality.remove_file(data.name)",
            "    return {\"state\":True}",
            "",
            "",
            "",
            "# ------------------------------------------- Languages endpoints ------------------------------------------------",
            "@router.post(\"/get_personality_languages_list\")",
            "def get_current_personality_files_list(data:Identification):",
            "    check_access(lollmsElfServer, data.client_id)",
            "    languages_list = lollmsElfServer.get_personality_languages()",
            "    ",
            "    # Return the languages list",
            "    return languages_list",
            "",
            "@router.post(\"/get_personality_language\")",
            "def get_personality_language(request: Identification):",
            "    # Access verification",
            "    check_access(lollmsElfServer, request.client_id)",
            "    return lollmsElfServer.config.current_language",
            "",
            "class SetLanguageRequest(BaseModel):",
            "    client_id: str",
            "    language: str",
            "",
            "# Definition of the endpoint for setting the personality language",
            "@router.post(\"/set_personality_language\")",
            "def set_personality_language(request: SetLanguageRequest):",
            "    # Access verification",
            "    check_access(lollmsElfServer, request.client_id)",
            "    sanitize_path(request.language)",
            "",
            "    # Calling the method to set the personality language",
            "    success = lollmsElfServer.set_personality_language(request.language)",
            "    ",
            "    # Returning an appropriate response depending on whether the operation was successful or not",
            "    if success:",
            "        return {\"message\": f\"The personality language has been successfully set to {request.language}.\"}",
            "    else:",
            "        raise HTTPException(status_code=400, detail=\"Failed to set the personality language\")",
            "",
            "# Definition of the endpoint for setting the personality language",
            "@router.post(\"/del_personality_language\")",
            "def del_personality_language(request: SetLanguageRequest):",
            "    # Access verification",
            "    check_access(lollmsElfServer, request.client_id)",
            "    sanitize_path(request.language)",
            "    language = request.language.lower().strip().split()[0]",
            "    default_language = lollmsElfServer.personality.language.lower().strip().split()[0]",
            "",
            "    if language==default_language:",
            "        lollmsElfServer.InfoMessage(\"It is not possible to delete the default language of a personality\")",
            "        return",
            "    # Calling the method to set the personality language",
            "    if lollmsElfServer.config.turn_on_language_validation:",
            "        if not show_yes_no_dialog(\"Language deletion request received\",\"I have received a language deletion request. Are you sure?\"):",
            "            return",
            "    success = lollmsElfServer.del_personality_language(request.language)",
            "    ",
            "    # Returning an appropriate response depending on whether the operation was successful or not",
            "    if success:",
            "        return {\"message\": f\"The personality language has been successfully set to {request.language}.\"}",
            "    else:",
            "        raise HTTPException(status_code=400, detail=\"Failed to set the personality language\")",
            "",
            "# ------------------------------------------- Mounting/Unmounting/Remounting ------------------------------------------------",
            "class PersonalityDataRequest(BaseModel):",
            "    client_id:str",
            "    category:str",
            "    name:str",
            "",
            "",
            "",
            "@router.post(\"/get_personality_config\")",
            "def get_personality_config(data:PersonalityDataRequest):",
            "    print(\"- Recovering personality config\")",
            "    category = sanitize_path(data.category)",
            "    name = sanitize_path(data.name)",
            "    if category==\"\":",
            "        return {\"status\":False, \"error\":\"category must not be empty.\"}",
            "",
            "    package_path = f\"{category}/{name}\"",
            "    if category==\"custom_personalities\":",
            "        package_full_path = lollmsElfServer.lollms_paths.custom_personalities_path/f\"{name}\"",
            "    else:            ",
            "        package_full_path = lollmsElfServer.lollms_paths.personalities_zoo_path/package_path",
            "    ",
            "    config_file = package_full_path / \"config.yaml\"",
            "    if config_file.exists():",
            "        with open(config_file,\"r\") as f:",
            "            config = yaml.safe_load(f)",
            "        return {\"status\":True, \"config\":config}",
            "    else:",
            "        return {\"status\":False, \"error\":\"Not found\"}",
            "    ",
            "class PersonalityConfig(BaseModel):",
            "    client_id:str",
            "    category:str",
            "    name:str",
            "    config:dict",
            "",
            "@router.post(\"/set_personality_config\")",
            "def set_personality_config(data:PersonalityConfig):",
            "    forbid_remote_access(lollmsElfServer)",
            "    check_access(lollmsElfServer, data.client_id)",
            "    print(\"- Recovering personality config\")",
            "    category = sanitize_path(data.category)",
            "    name = sanitize_path(data.name)",
            "    config = data.config",
            "    if category==\"\":",
            "        return {\"status\":False, \"error\":\"category must not be empty.\"}",
            "    ",
            "    package_path = f\"{category}/{name}\"",
            "    if category==\"custom_personalities\":",
            "        package_full_path = lollmsElfServer.lollms_paths.custom_personalities_path/f\"{name}\"",
            "    else:            ",
            "        package_full_path = lollmsElfServer.lollms_paths.personalities_zoo_path/package_path",
            "    ",
            "    config_file = package_full_path / \"config.yaml\"",
            "    if config_file.exists():",
            "        with open(config_file,\"w\") as f:",
            "            yaml.safe_dump(config, f)",
            "",
            "        lollmsElfServer.mounted_personalities = lollmsElfServer.rebuild_personalities(reload_all=True)",
            "        lollmsElfServer.InfoMessage(\"Personality updated\")",
            "        return {\"status\":True}",
            "    else:",
            "        return {\"status\":False, \"error\":\"Not found\"}",
            "",
            "class PersonalityMountingInfos(BaseModel):",
            "    client_id:str",
            "    category:str",
            "    folder:str",
            "    language:Optional[str] = None",
            "",
            "@router.post(\"/mount_personality\")",
            "def mount_personality(data:PersonalityMountingInfos):",
            "    check_access(lollmsElfServer, data.client_id)",
            "    print(\"- Mounting personality\")",
            "    category = sanitize_path(data.category)",
            "    name = sanitize_path(data.folder)",
            "    language = data.language #.get('language', None)",
            "    if category==\"\":",
            "        return {\"status\":False, \"error\":\"category must not be empty.\"}",
            "",
            "    package_path = f\"{category}/{name}\"",
            "    if category==\"custom_personalities\":",
            "        package_full_path = lollmsElfServer.lollms_paths.custom_personalities_path/f\"{name}\"",
            "    else:            ",
            "        package_full_path = lollmsElfServer.lollms_paths.personalities_zoo_path/package_path",
            "    ",
            "    config_file = package_full_path / \"config.yaml\"",
            "    if config_file.exists():",
            "        if language:",
            "            package_path += \":\" + language",
            "        \"\"\"",
            "        if package_path in lollmsElfServer.config[\"personalities\"]:",
            "            ASCIIColors.error(\"Can't mount exact same personality twice\")",
            "            return jsonify({\"status\": False,",
            "                            \"error\":\"Can't mount exact same personality twice\",",
            "                            \"personalities\":lollmsElfServer.config[\"personalities\"],",
            "                            \"active_personality_id\":lollmsElfServer.config[\"active_personality_id\"]",
            "                            })                ",
            "        \"\"\"",
            "        lollmsElfServer.config[\"personalities\"].append(package_path)",
            "        lollmsElfServer.mounted_personalities = lollmsElfServer.rebuild_personalities()",
            "        lollmsElfServer.config[\"active_personality_id\"]= len(lollmsElfServer.config[\"personalities\"])-1",
            "        lollmsElfServer.personality = lollmsElfServer.mounted_personalities[lollmsElfServer.config[\"active_personality_id\"]]",
            "        ASCIIColors.success(\"ok\")",
            "        if lollmsElfServer.config[\"active_personality_id\"]<0:",
            "            ASCIIColors.error(\"error:active_personality_id<0\")",
            "            return {\"status\": False,",
            "                            \"error\":\"active_personality_id<0\",",
            "                            \"personalities\":lollmsElfServer.config[\"personalities\"],",
            "                            \"active_personality_id\":lollmsElfServer.config[\"active_personality_id\"]",
            "                            }         ",
            "        else:",
            "            if lollmsElfServer.config.auto_save:",
            "                ASCIIColors.info(\"Saving configuration\")",
            "                lollmsElfServer.config.save_config()",
            "            ASCIIColors.success(f\"Personality {name} mounted successfully\")",
            "            return {\"status\": True,",
            "                            \"personalities\":lollmsElfServer.config[\"personalities\"],",
            "                            \"active_personality_id\":lollmsElfServer.config[\"active_personality_id\"]",
            "                            }    ",
            "    else:",
            "        pth = str(config_file).replace('\\\\','/')",
            "        ASCIIColors.error(f\"nok : Personality not found @ {pth}\")            ",
            "        ASCIIColors.yellow(f\"Available personalities: {[p.name for p in lollmsElfServer.mounted_personalities]}\")",
            "        return {\"status\": False, \"error\":f\"Personality not found @ {pth}\"}",
            "",
            "",
            "@router.post(\"/remount_personality\")",
            "def remount_personality(data:PersonalityMountingInfos):",
            "    check_access(lollmsElfServer, data.client_id)",
            "    category = sanitize_path(data.category)",
            "    name = sanitize_path(data.folder)",
            "    language = data.language #.get('language', None)",
            "",
            "    if category==\"\":",
            "        return {\"status\":False, \"error\":\"category must not be empty.\"}",
            "",
            "    package_path = f\"{category}/{name}\"",
            "    if category==\"custom_personalities\":",
            "        package_full_path = lollmsElfServer.lollms_paths.custom_personalities_path/f\"{name}\"",
            "    else:            ",
            "        package_full_path = lollmsElfServer.lollms_paths.personalities_zoo_path/package_path",
            "    ",
            "    config_file = package_full_path / \"config.yaml\"",
            "    if config_file.exists():",
            "        ASCIIColors.info(f\"Unmounting personality {package_path}\")",
            "        index = lollmsElfServer.config[\"personalities\"].index(f\"{category}/{name}\")",
            "        lollmsElfServer.config[\"personalities\"].remove(f\"{category}/{name}\")",
            "        if lollmsElfServer.config[\"active_personality_id\"]>=index:",
            "            lollmsElfServer.config[\"active_personality_id\"]=0",
            "        if len(lollmsElfServer.config[\"personalities\"])>0:",
            "            lollmsElfServer.mounted_personalities = lollmsElfServer.rebuild_personalities()",
            "            lollmsElfServer.personality = lollmsElfServer.mounted_personalities[lollmsElfServer.config[\"active_personality_id\"]]",
            "        else:",
            "            lollmsElfServer.personalities = [\"generic/lollms\"]",
            "            lollmsElfServer.mounted_personalities = lollmsElfServer.rebuild_personalities()",
            "            lollmsElfServer.personality = lollmsElfServer.mounted_personalities[lollmsElfServer.config[\"active_personality_id\"]]",
            "",
            "",
            "        ASCIIColors.info(f\"Mounting personality {package_path}\")",
            "        lollmsElfServer.config[\"personalities\"].append(package_path)",
            "        lollmsElfServer.config[\"active_personality_id\"]= len(lollmsElfServer.config[\"personalities\"])-1",
            "        lollmsElfServer.mounted_personalities = lollmsElfServer.rebuild_personalities()",
            "        lollmsElfServer.personality = lollmsElfServer.mounted_personalities[lollmsElfServer.config[\"active_personality_id\"]]",
            "        ASCIIColors.success(\"ok\")",
            "        if lollmsElfServer.config[\"active_personality_id\"]<0:",
            "            return {\"status\": False,",
            "                            \"personalities\":lollmsElfServer.config[\"personalities\"],",
            "                            \"active_personality_id\":lollmsElfServer.config[\"active_personality_id\"]",
            "                            }      ",
            "        else:",
            "            return {\"status\": True,",
            "                            \"personalities\":lollmsElfServer.config[\"personalities\"],",
            "                            \"active_personality_id\":lollmsElfServer.config[\"active_personality_id\"]",
            "                            }    ",
            "    else:",
            "        pth = str(config_file).replace('\\\\','/')",
            "        ASCIIColors.error(f\"nok : Personality not found @ {pth}\")",
            "        ASCIIColors.yellow(f\"Available personalities: {[p.name for p in lollmsElfServer.mounted_personalities]}\")",
            "        return {\"status\": False, \"error\":f\"Personality not found @ {pth}\"}  ",
            "    ",
            "",
            "@router.post(\"/unmount_personality\")",
            "def unmount_personality(data:PersonalityMountingInfos):",
            "    check_access(lollmsElfServer, data.client_id)",
            "    print(\"- Unmounting personality ...\")",
            "    category = sanitize_path(data.category)",
            "    name = sanitize_path(data.folder)",
            "    language = data.language #.get('language', None)",
            "",
            "    if category==\"\":",
            "        return {\"status\":False, \"error\":\"category must not be empty.\"}",
            "",
            "    try:",
            "        personality_id = f\"{category}/{name}\" if language is None or language==\"\" else f\"{category}/{name}:{language}\"",
            "        index = lollmsElfServer.config[\"personalities\"].index(personality_id)",
            "        lollmsElfServer.config[\"personalities\"].remove(personality_id)",
            "        if lollmsElfServer.config[\"active_personality_id\"]>=index:",
            "            lollmsElfServer.config[\"active_personality_id\"]=0",
            "        if len(lollmsElfServer.config[\"personalities\"])>0:",
            "            lollmsElfServer.mounted_personalities = lollmsElfServer.rebuild_personalities()",
            "            lollmsElfServer.personality = lollmsElfServer.mounted_personalities[lollmsElfServer.config[\"active_personality_id\"]]",
            "        else:",
            "            lollmsElfServer.personalities = [\"generic/lollms\"]",
            "            lollmsElfServer.mounted_personalities = lollmsElfServer.rebuild_personalities()",
            "            if lollmsElfServer.config[\"active_personality_id\"]<len(lollmsElfServer.mounted_personalities):",
            "                lollmsElfServer.personality = lollmsElfServer.mounted_personalities[lollmsElfServer.config[\"active_personality_id\"]]",
            "            else:",
            "                lollmsElfServer.config[\"active_personality_id\"] = -1",
            "        ASCIIColors.success(\"ok\")",
            "        if lollmsElfServer.config.auto_save:",
            "            ASCIIColors.info(\"Saving configuration\")",
            "            lollmsElfServer.config.save_config()",
            "        return {",
            "                    \"status\": True,",
            "                    \"personalities\":lollmsElfServer.config[\"personalities\"],",
            "                    \"active_personality_id\":lollmsElfServer.config[\"active_personality_id\"]",
            "                    }",
            "    except Exception as ex:",
            "        trace_exception(ex)",
            "        if language:",
            "            ASCIIColors.error(f\"nok : Personality not found @ {category}/{name}:{language}\")",
            "        else:",
            "            ASCIIColors.error(f\"nok : Personality not found @ {category}/{name}\")",
            "            ",
            "        ASCIIColors.yellow(f\"Available personalities: {[p.name for p in lollmsElfServer.mounted_personalities if p is not None]}\")",
            "        return {\"status\": False, \"error\":\"Couldn't unmount personality\"}",
            "    ",
            "",
            "class AuthenticationInfos(BaseModel):",
            "    client_id:str",
            "",
            "@router.post(\"/unmount_all_personalities\")",
            "def unmount_all_personalities(data:AuthenticationInfos):",
            "    check_access(lollmsElfServer, data.client_id)",
            "    lollmsElfServer.config.personalities=[\"generic/lollms\"]",
            "    lollmsElfServer.mounted_personalities=[]",
            "    lollmsElfServer.personality=None",
            "    lollmsElfServer.mount_personality(0)",
            "    lollmsElfServer.config.save_config()",
            "    return {\"status\":True}",
            "",
            "",
            "",
            "# ------------------------------------------- Selecting personality ------------------------------------------------",
            "",
            "@router.post(\"/select_personality\")",
            "def select_personality(data:PersonalitySelectionInfos):",
            "    check_access(lollmsElfServer, data.client_id)",
            "    ASCIIColors.info(\"Selecting personality\")",
            "    id = data.id",
            "    print(f\"- Selecting active personality {id} ...\",end=\"\")",
            "    if id<len(lollmsElfServer.mounted_personalities):",
            "        lollmsElfServer.config[\"active_personality_id\"]=id",
            "        lollmsElfServer.personality:AIPersonality = lollmsElfServer.mounted_personalities[lollmsElfServer.config[\"active_personality_id\"]]",
            "        if lollmsElfServer.personality is None:",
            "            return {\"status\": False, \"error\":\"Something is wrong with the personality\"}",
            "        if lollmsElfServer.personality.processor:",
            "            lollmsElfServer.personality.processor.selected()",
            "        ASCIIColors.success(\"ok\")",
            "        ",
            "        print(f\"Selected {lollmsElfServer.personality.name}\")",
            "",
            "        language = lollmsElfServer.config.current_language",
            "        if lollmsElfServer.personality.language is None:",
            "            lollmsElfServer.personality.language = \"english\"",
            "        default_language = lollmsElfServer.personality.language.lower().strip().split()[0]",
            "",
            "        if language != default_language:",
            "            lollmsElfServer.set_personality_language(language)",
            "",
            "        if lollmsElfServer.config.auto_save:",
            "            ASCIIColors.info(\"Saving configuration\")",
            "            lollmsElfServer.config.save_config()",
            "        return {",
            "            \"status\": True,",
            "            \"personalities\":lollmsElfServer.config[\"personalities\"],",
            "            \"active_personality_id\":lollmsElfServer.config[\"active_personality_id\"]                ",
            "            }",
            "    else:",
            "        ASCIIColors.error(f\"nok : personality id out of bounds @ {id} >= {len(lollmsElfServer.mounted_personalities)}\")",
            "        return {\"status\": False, \"error\":\"Invalid ID\"}",
            "            ",
            "# ------------------------------------------- Personality settings------------------------------------------------",
            "",
            "@router.post(\"/get_personality_settings\")",
            "def get_personality_settings(data:PersonalityMountingInfos):",
            "    check_access(lollmsElfServer, data.client_id)",
            "    print(\"- Retreiving personality settings\")",
            "    category = sanitize_path(data.category)",
            "    name = sanitize_path(data.folder)",
            "    if category==\"\":",
            "        return {\"status\":False, \"error\":\"category must not be empty.\"}",
            "",
            "    if category == \"custom_personalities\":",
            "        personality_folder = lollmsElfServer.lollms_paths.personal_personalities_path/f\"{name}\"",
            "    else:",
            "        personality_folder = lollmsElfServer.lollms_paths.personalities_zoo_path/f\"{category}\"/f\"{name}\"",
            "",
            "    personality = AIPersonality(personality_folder,",
            "                                lollmsElfServer.lollms_paths, ",
            "                                lollmsElfServer.config,",
            "                                model=lollmsElfServer.model,",
            "                                app=lollmsElfServer,",
            "                                run_scripts=True)",
            "    if personality.processor is not None:",
            "        if hasattr(personality.processor,\"personality_config\"):",
            "            return personality.processor.personality_config.config_template.template",
            "        else:",
            "            return {}   ",
            "    else:",
            "        return {}  ",
            "",
            "",
            "@router.get(\"/get_active_personality_settings\")",
            "def get_active_personality_settings():",
            "    print(\"- Retreiving personality settings\")",
            "    if lollmsElfServer.personality.processor is not None:",
            "        if hasattr(lollmsElfServer.personality.processor,\"personality_config\"):",
            "            return lollmsElfServer.personality.processor.personality_config.config_template.template",
            "        else:",
            "            return {}",
            "    else:",
            "        return {}",
            "",
            "",
            "@router.post(\"/set_active_personality_settings\")",
            "async def set_active_personality_settings(request: Request):",
            "    \"\"\"",
            "    sets the active personality settings.",
            "",
            "    :param request: The HTTP request object.",
            "    :return: A JSON response with the status of the operation.",
            "    \"\"\"",
            "",
            "    try:",
            "        config_data = (await request.json())",
            "",
            "        print(\"- Setting personality settings\")",
            "        ",
            "        if lollmsElfServer.personality.processor is not None:",
            "            if hasattr(lollmsElfServer.personality.processor,\"personality_config\"):",
            "                lollmsElfServer.personality.processor.personality_config.update_template(config_data)",
            "                lollmsElfServer.personality.processor.personality_config.config.save_config()",
            "                if lollmsElfServer.config.auto_save:",
            "                    ASCIIColors.info(\"Saving configuration\")",
            "                    lollmsElfServer.config.save_config()",
            "                if lollmsElfServer.personality.processor:",
            "                    lollmsElfServer.personality.processor.settings_updated()",
            "                return {'status':True}",
            "            else:",
            "                return {'status':False}",
            "        else:",
            "            return {'status':False}  ",
            "    except Exception as ex:",
            "        trace_exception(ex)",
            "        lollmsElfServer.error(ex)",
            "        return {\"status\":False,\"error\":str(ex)}",
            "",
            "",
            "class PersonalityInfos(BaseModel):",
            "    category:str",
            "    name:str",
            "    language:Optional[str] = None",
            "",
            "@router.post(\"/copy_to_custom_personas\")",
            "async def copy_to_custom_personas(data: PersonalityInfos):",
            "    \"\"\"",
            "    Copies the personality to custom personas so that you can modify it.",
            "",
            "    \"\"\"",
            "    import shutil",
            "    ",
            "    category = sanitize_path(data.category)",
            "    name = sanitize_path(data.name)",
            "",
            "    if category==\"custom_personalities\":",
            "        lollmsElfServer.InfoMessage(\"This persona is already in custom personalities folder\")",
            "        return {\"status\":False}",
            "    else:",
            "        personality_folder = lollmsElfServer.lollms_paths.personalities_zoo_path/f\"{category}\"/f\"{name}\"",
            "        destination_folder = lollmsElfServer.lollms_paths.custom_personalities_path",
            "        shutil.copytree(personality_folder, destination_folder/f\"{name}\")",
            "        return {\"status\":True}",
            "",
            "# ------------------------------------------- Interaction with personas ------------------------------------------------",
            "@router.post(\"/post_to_personality\")",
            "async def post_to_personality(request: Request):",
            "    \"\"\"Post data to a personality\"\"\"",
            "",
            "    try:",
            "        if hasattr(lollmsElfServer.personality.processor,'handle_request'):",
            "            return await lollmsElfServer.personality.processor.handle_request(request)",
            "        else:",
            "            return {}",
            "    except Exception as ex:",
            "        trace_exception(ex)",
            "        lollmsElfServer.error(ex)",
            "        return {\"status\":False,\"error\":str(ex)}",
            "    "
        ],
        "action": [
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "19": [],
            "360": [
                "set_personality_config"
            ]
        },
        "addLocation": []
    },
    "lollms/utilities.py": {
        "Patch": {
            "0": {
                "beforePatchRowNumber": 37,
                "afterPatchRowNumber": 37,
                "PatchRowcode": " "
            },
            "1": {
                "beforePatchRowNumber": 38,
                "afterPatchRowNumber": 38,
                "PatchRowcode": " import mimetypes"
            },
            "2": {
                "beforePatchRowNumber": 39,
                "afterPatchRowNumber": 39,
                "PatchRowcode": " import subprocess"
            },
            "3": {
                "beforePatchRowNumber": 40,
                "afterPatchRowNumber": "",
                "PatchRowcode": "-from lollms.security import sanitize_shell_code"
            },
            "4": {
                "beforePatchRowNumber": 41,
                "afterPatchRowNumber": 40,
                "PatchRowcode": " "
            },
            "5": {
                "beforePatchRowNumber": 42,
                "afterPatchRowNumber": 41,
                "PatchRowcode": " from functools import partial"
            },
            "6": {
                "beforePatchRowNumber": 43,
                "afterPatchRowNumber": 42,
                "PatchRowcode": " "
            },
            "7": {
                "beforePatchRowNumber": 59,
                "afterPatchRowNumber": 58,
                "PatchRowcode": " "
            },
            "8": {
                "beforePatchRowNumber": 60,
                "afterPatchRowNumber": 59,
                "PatchRowcode": " "
            },
            "9": {
                "beforePatchRowNumber": 61,
                "afterPatchRowNumber": 60,
                "PatchRowcode": " def create_conda_env(env_name, python_version):"
            },
            "10": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 61,
                "PatchRowcode": "+    from lollms.security import sanitize_shell_code"
            },
            "11": {
                "beforePatchRowNumber": 62,
                "afterPatchRowNumber": 62,
                "PatchRowcode": "     env_name = sanitize_shell_code(env_name)"
            },
            "12": {
                "beforePatchRowNumber": 63,
                "afterPatchRowNumber": 63,
                "PatchRowcode": "     python_version = sanitize_shell_code(python_version)"
            },
            "13": {
                "beforePatchRowNumber": 64,
                "afterPatchRowNumber": 64,
                "PatchRowcode": "     # Activate the Conda environment"
            },
            "14": {
                "beforePatchRowNumber": 132,
                "afterPatchRowNumber": 132,
                "PatchRowcode": "         return Path(sys.executable).parent.parent.parent / \"miniconda3\" / \"bin\" / \"conda\""
            },
            "15": {
                "beforePatchRowNumber": 133,
                "afterPatchRowNumber": 133,
                "PatchRowcode": " "
            },
            "16": {
                "beforePatchRowNumber": 134,
                "afterPatchRowNumber": 134,
                "PatchRowcode": " def environment_exists(env_name):"
            },
            "17": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 135,
                "PatchRowcode": "+    from lollms.security import sanitize_shell_code"
            },
            "18": {
                "beforePatchRowNumber": 135,
                "afterPatchRowNumber": 136,
                "PatchRowcode": "     env_name = sanitize_shell_code(env_name)"
            },
            "19": {
                "beforePatchRowNumber": 136,
                "afterPatchRowNumber": 137,
                "PatchRowcode": "     conda_path = get_conda_path()"
            },
            "20": {
                "beforePatchRowNumber": 137,
                "afterPatchRowNumber": 138,
                "PatchRowcode": "     result = subprocess.run(f'{conda_path} env list --json', shell=True, capture_output=True, text=True)"
            },
            "21": {
                "beforePatchRowNumber": 140,
                "afterPatchRowNumber": 141,
                "PatchRowcode": "     return env_name in env_names"
            },
            "22": {
                "beforePatchRowNumber": 141,
                "afterPatchRowNumber": 142,
                "PatchRowcode": " "
            },
            "23": {
                "beforePatchRowNumber": 142,
                "afterPatchRowNumber": 143,
                "PatchRowcode": " def get_python_version(env_name):"
            },
            "24": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 144,
                "PatchRowcode": "+    from lollms.security import sanitize_shell_code"
            },
            "25": {
                "beforePatchRowNumber": 143,
                "afterPatchRowNumber": 145,
                "PatchRowcode": "     env_name = sanitize_shell_code(env_name)"
            },
            "26": {
                "beforePatchRowNumber": 144,
                "afterPatchRowNumber": 146,
                "PatchRowcode": "     conda_path = get_conda_path()"
            },
            "27": {
                "beforePatchRowNumber": 145,
                "afterPatchRowNumber": 147,
                "PatchRowcode": "     if environment_exists(env_name):"
            },
            "28": {
                "beforePatchRowNumber": 149,
                "afterPatchRowNumber": 151,
                "PatchRowcode": "         return \"Environment does not exist.\""
            },
            "29": {
                "beforePatchRowNumber": 150,
                "afterPatchRowNumber": 152,
                "PatchRowcode": " "
            },
            "30": {
                "beforePatchRowNumber": 151,
                "afterPatchRowNumber": 153,
                "PatchRowcode": " def remove_environment(env_name):"
            },
            "31": {
                "beforePatchRowNumber": "",
                "afterPatchRowNumber": 154,
                "PatchRowcode": "+    from lollms.security import sanitize_shell_code"
            },
            "32": {
                "beforePatchRowNumber": 152,
                "afterPatchRowNumber": 155,
                "PatchRowcode": "     env_name = sanitize_shell_code(env_name)"
            },
            "33": {
                "beforePatchRowNumber": 153,
                "afterPatchRowNumber": 156,
                "PatchRowcode": "     conda_path = get_conda_path()"
            },
            "34": {
                "beforePatchRowNumber": 154,
                "afterPatchRowNumber": 157,
                "PatchRowcode": "     if environment_exists(env_name):"
            }
        },
        "frontPatchFile": [
            "",
            "######",
            "# Project       : lollms",
            "# File          : utilities.py",
            "# Author        : ParisNeo with the help of the community",
            "# license       : Apache 2.0",
            "# Description   : ",
            "# This file contains utilities functions that can be used by any",
            "# module.",
            "######",
            "from ascii_colors import ASCIIColors, trace_exception",
            "import numpy as np",
            "from pathlib import Path",
            "import json",
            "import re",
            "import subprocess",
            "import gc",
            "import shutil",
            "",
            "from typing import List",
            "",
            "from PIL import Image",
            "import requests",
            "from io import BytesIO",
            "import base64",
            "import importlib",
            "import yaml",
            "",
            "import asyncio",
            "",
            "import ctypes",
            "import io",
            "import urllib",
            "import os",
            "import sys",
            "import git",
            "",
            "import mimetypes",
            "import subprocess",
            "from lollms.security import sanitize_shell_code",
            "",
            "from functools import partial",
            "",
            "def install_conda_utility():",
            "    import platform",
            "    if platform.system()==\"Windows\":",
            "        conda_path = Path(sys.executable).parent.parent/\"miniconda3\"/\"condabin\"/\"conda\"",
            "    else:",
            "        conda_path = Path(sys.executable).parent.parent.parent/\"miniconda3\"/\"bin\"/\"conda\"",
            "    ASCIIColors.red(\"Conda path:\")",
            "    ASCIIColors.yellow(conda_path)",
            "    process = subprocess.Popen(f'{conda_path} install conda -y', shell=True)",
            "    ",
            "    # Wait for the process to finish",
            "    process.wait()",
            "    #from conda.cli.python_api import  run_command, Commands",
            "    # Create a new Conda environment with the specified Python version",
            "    #run_command(Commands.CREATE, \"-n\", env_name, f\"python={python_version}\")",
            "",
            "",
            "def create_conda_env(env_name, python_version):",
            "    env_name = sanitize_shell_code(env_name)",
            "    python_version = sanitize_shell_code(python_version)",
            "    # Activate the Conda environment",
            "    import platform",
            "    if platform.system()==\"Windows\":",
            "        conda_path = Path(sys.executable).parent.parent/\"miniconda3\"/\"condabin\"/\"conda\"",
            "    else:",
            "        conda_path = Path(sys.executable).parent.parent.parent/\"miniconda3\"/\"bin\"/\"conda\"",
            "    ASCIIColors.red(\"Conda path:\")",
            "    ASCIIColors.yellow(conda_path)",
            "    process = subprocess.Popen(f'{conda_path} create --name {env_name} python={python_version} -y', shell=True)",
            "    ",
            "    # Wait for the process to finish",
            "    process.wait()",
            "    #from conda.cli.python_api import  run_command, Commands",
            "    # Create a new Conda environment with the specified Python version",
            "    #run_command(Commands.CREATE, \"-n\", env_name, f\"python={python_version}\")",
            "",
            "def run_pip_in_env(env_name, pip_args, cwd=None):",
            "    import platform",
            "    # Set the current working directory if provided, otherwise use the current directory",
            "    if cwd is None:",
            "        cwd = os.getcwd()",
            "    ",
            "    # Activate the Conda environment",
            "    python_path = Path(sys.executable).parent.parent/\"miniconda3\"/\"envs\"/env_name/\"python\"",
            "    process = subprocess.Popen(f'{python_path} -m pip {pip_args}', shell=True)",
            "    ",
            "    # Wait for the process to finish",
            "    process.wait()",
            "",
            "",
            "def run_python_script_in_env(env_name, script_path, cwd=None, wait=True):",
            "    import platform",
            "    # Set the current working directory if provided, otherwise use the current directory",
            "    if cwd is None:",
            "        cwd = os.getcwd()",
            "    ",
            "    # Activate the Conda environment",
            "    python_path = Path(sys.executable).parent.parent/\"miniconda3\"/\"envs\"/env_name/\"python\"",
            "    process = subprocess.Popen(f'{python_path} {script_path}', shell=True)",
            "    ",
            "    # Wait for the process to finish",
            "    if wait:",
            "        process.wait()",
            "    return process",
            "",
            "def run_script_in_env(env_name, script_path, cwd=None):",
            "    import platform",
            "    # Set the current working directory if provided, otherwise use the current directory",
            "    if cwd is None:",
            "        cwd = os.path.dirname(script_path)",
            "    ",
            "    # Activate the Conda environment",
            "    if platform.system()==\"Windows\":",
            "        python_path = Path(sys.executable).parent.parent/\"miniconda3\"/\"condabin\"/\"conda\"",
            "        subprocess.Popen(f'{python_path} activate {env_name} && {script_path}', shell=True, cwd=cwd)",
            "    else:",
            "        python_path = Path(sys.executable).parent.parent.parent/\"miniconda3\"/\"bin\"/\"conda\"",
            "        subprocess.Popen(f'source {python_path} activate {env_name} && {script_path}', shell=True, cwd=cwd)",
            "    # Activate the Conda environment",
            "    ASCIIColors.red(\"Python path:\")",
            "    ASCIIColors.yellow(python_path)",
            "    #run_command(Commands.RUN, \"-n\", env_name, str(script_path), cwd=cwd)",
            "",
            "def get_conda_path():",
            "    import platform",
            "    if platform.system() == \"Windows\":",
            "        return Path(sys.executable).parent.parent / \"miniconda3\" / \"condabin\" / \"conda\"",
            "    else:",
            "        return Path(sys.executable).parent.parent.parent / \"miniconda3\" / \"bin\" / \"conda\"",
            "",
            "def environment_exists(env_name):",
            "    env_name = sanitize_shell_code(env_name)",
            "    conda_path = get_conda_path()",
            "    result = subprocess.run(f'{conda_path} env list --json', shell=True, capture_output=True, text=True)",
            "    envs_info = json.loads(result.stdout)",
            "    env_names = [Path(env).name for env in envs_info['envs']]",
            "    return env_name in env_names",
            "",
            "def get_python_version(env_name):",
            "    env_name = sanitize_shell_code(env_name)",
            "    conda_path = get_conda_path()",
            "    if environment_exists(env_name):",
            "        result = subprocess.run(f'{conda_path} run -n {env_name} python --version', shell=True, capture_output=True, text=True)",
            "        return result.stdout.strip()",
            "    else:",
            "        return \"Environment does not exist.\"",
            "",
            "def remove_environment(env_name):",
            "    env_name = sanitize_shell_code(env_name)",
            "    conda_path = get_conda_path()",
            "    if environment_exists(env_name):",
            "        process = subprocess.Popen(f'{conda_path} env remove --name {env_name} -y', shell=True)",
            "        process.wait()",
            "        return f\"Environment '{env_name}' has been removed.\"",
            "    else:",
            "        return \"Environment does not exist.\"",
            "",
            "def process_ai_output(output, images, output_folder):",
            "    if not PackageManager.check_package_installed(\"cv2\"):",
            "        PackageManager.install_package(\"opencv-python\")",
            "    import cv2",
            "    images = [cv2.imread(str(img)) for img in images]",
            "    # Find all bounding box entries in the output",
            "    bounding_boxes = re.findall(r'boundingbox\\((\\d+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+)\\)', output)",
            "",
            "    # Group bounding boxes by image index",
            "    image_boxes = {}",
            "    for box in bounding_boxes:",
            "        image_index = int(box[0])",
            "        if image_index not in image_boxes:",
            "            image_boxes[image_index] = []",
            "        image_boxes[image_index].append(box[1:])",
            "",
            "    # Process each image and its bounding boxes",
            "    for image_index, boxes in image_boxes.items():",
            "        # Get the corresponding image",
            "        image = images[image_index]",
            "",
            "        # Draw bounding boxes on the image",
            "        for box in boxes:",
            "            label, left, top, width, height = box",
            "            left, top, width, height = float(left), float(top), float(width), float(height)",
            "            x, y, w, h = int(left * image.shape[1]), int(top * image.shape[0]), int(width * image.shape[1]), int(height * image.shape[0])",
            "            cv2.rectangle(image, (x, y), (x + w, y + h), (0, 255, 0), 2)",
            "            cv2.putText(image, label, (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (0, 255, 0), 2)",
            "",
            "        # Save the modified image",
            "        random_stuff = np.random",
            "        output_path = Path(output_folder)/f\"image_{image_index}_{random_stuff}.jpg\"",
            "        cv2.imwrite(str(output_path), image)",
            "",
            "    # Remove bounding box text from the output",
            "    output = re.sub(r'boundingbox\\([^)]+\\)', '', output)",
            "",
            "    # Append img tags for the generated images",
            "    for image_index in image_boxes.keys():",
            "        url = discussion_path_to_url(Path(output_folder)/f\"image_{image_index}.jpg\")",
            "        output += f'\\n<img src=\"{url}\">'",
            "",
            "    return output",
            "",
            "def get_media_type(file_path):",
            "    \"\"\"",
            "    Determines the media type of a file based on its file extension.",
            "",
            "    Args:",
            "        file_path (str): The path to the media file.",
            "",
            "    Returns:",
            "        str: The media type of the file in the format \"type/subtype\".",
            "             Returns \"Unknown\" if the media type cannot be determined.",
            "    \"\"\"",
            "    media_type, _ = mimetypes.guess_type(file_path)",
            "    ",
            "    if media_type is None:",
            "        return \"Unknown\"",
            "    else:",
            "        return media_type",
            "",
            "",
            "def discussion_path_2_url(path:str|Path):",
            "    path = str(path)",
            "    return path[path.index('discussion_databases'):].replace('discussion_databases','discussions')",
            "",
            "",
            "def yes_or_no_input(prompt):",
            "    while True:",
            "        user_input = input(prompt + \" (yes/no): \").lower()",
            "        if user_input == 'yes':",
            "            return True",
            "        elif user_input == 'no':",
            "            return False",
            "        else:",
            "            print(\"Please enter 'yes' or 'no'.\")",
            "",
            "def show_console_custom_dialog(title, text, options):",
            "    print(title)",
            "    print(text)",
            "    for i, option in enumerate(options, 1):",
            "        print(f\"{i}. {option}\")",
            "    while True:",
            "        try:",
            "            choice = int(input(\"Enter the number of your choice: \"))",
            "            if 1 <= choice <= len(options):",
            "                return options[choice - 1]",
            "            else:",
            "                print(\"Invalid choice. Please try again.\")",
            "        except ValueError:",
            "            print(\"Invalid input. Please enter a number.\")",
            "",
            "def show_custom_dialog(title, text, options):",
            "    try:",
            "        import tkinter as tk",
            "        from tkinter import simpledialog        ",
            "        class CustomDialog(simpledialog.Dialog):",
            "            def __init__(self, parent, title, options, root):",
            "                self.options = options",
            "                self.root = root",
            "                self.buttons = []",
            "                self.result_value = \"\"",
            "                super().__init__(parent, title)",
            "            def do_ok(self, option):",
            "                self.result_value = option",
            "                self.ok(option)",
            "                self.root.destroy()",
            "            def body(self, master):",
            "                for option in self.options:",
            "                    button = tk.Button(master, text=option, command=partial(self.do_ok, option))",
            "                    button.pack(side=\"left\", fill=\"x\")",
            "                    self.buttons.append(button)",
            "",
            "            def apply(self):",
            "                self.result = self.options[0]  # Default value",
            "        root = tk.Tk()",
            "        root.withdraw()",
            "        root.attributes('-topmost', True)",
            "        d = CustomDialog(root, title=title, options=options, root=root)",
            "        try:",
            "            d.mainloop()",
            "        except Exception as ex:",
            "            pass",
            "        result = d.result_value",
            "        return result",
            "    except Exception as ex:",
            "        ASCIIColors.error(ex)",
            "        return show_console_custom_dialog(title, text, options)",
            "    ",
            "def show_yes_no_dialog(title, text):",
            "    try:",
            "        import tkinter as tk",
            "        from tkinter import messagebox",
            "        # Create a new Tkinter root window and hide it",
            "        root = tk.Tk()",
            "        root.withdraw()",
            "    ",
            "        # Make the window appear on top",
            "        root.attributes('-topmost', True)",
            "        ",
            "        # Show the dialog box",
            "        result = messagebox.askyesno(title, text)",
            "    ",
            "        # Destroy the root window",
            "        root.destroy()",
            "    ",
            "        return result",
            "    except:",
            "        return yes_or_no_input(text)",
            "        ",
            "def show_message_dialog(title, text):",
            "    import tkinter as tk",
            "    from tkinter import messagebox",
            "    # Create a new Tkinter root window and hide it",
            "    root = tk.Tk()",
            "    root.withdraw()",
            "",
            "    # Make the window appear on top",
            "    root.attributes('-topmost', True)",
            "    ",
            "    # Show the dialog box",
            "    result = messagebox.askquestion(title, text)",
            "",
            "    # Destroy the root window",
            "    root.destroy()",
            "",
            "    return result",
            "",
            "",
            "def is_linux():",
            "    return sys.platform.startswith(\"linux\")",
            "",
            "",
            "def is_windows():",
            "    return sys.platform.startswith(\"win\")",
            "",
            "",
            "def is_macos():",
            "    return sys.platform.startswith(\"darwin\")",
            "",
            "def run_cmd(cmd, assert_success=False, environment=False, capture_output=False, env=None):",
            "    script_dir = os.getcwd()",
            "    conda_env_path = os.path.join(script_dir, \"installer_files\", \"env\")",
            "    # Use the conda environment",
            "    if environment:",
            "        if is_windows():",
            "            conda_bat_path = os.path.join(script_dir, \"installer_files\", \"conda\", \"condabin\", \"conda.bat\")",
            "            cmd = \"\\\"\" + conda_bat_path + \"\\\" activate \\\"\" + conda_env_path + \"\\\" >nul && \" + cmd",
            "        else:",
            "            conda_sh_path = os.path.join(script_dir, \"installer_files\", \"conda\", \"etc\", \"profile.d\", \"conda.sh\")",
            "            cmd = \". \\\"\" + conda_sh_path + \"\\\" && conda activate \\\"\" + conda_env_path + \"\\\" && \" + cmd",
            "",
            "    # Run shell commands",
            "    result = subprocess.run(cmd, shell=True, capture_output=capture_output, env=env)",
            "",
            "    # Assert the command ran successfully",
            "    if assert_success and result.returncode != 0:",
            "        print(\"Command '\" + cmd + \"' failed with exit status code '\" + str(result.returncode) + \"'.\\n\\nExiting now.\\nTry running the start/update script again.\")",
            "        sys.exit(1)",
            "",
            "    return result",
            "",
            "def file_path_to_url(file_path):",
            "    \"\"\"",
            "    This function takes a file path as an argument and converts it into a URL format. It first removes the initial part of the file path until the \"outputs\" string is reached, then replaces backslashes with forward slashes and quotes each segment with urllib.parse.quote() before joining them with forward slashes to form the final URL.",
            "",
            "    :param file_path: str, the file path in the format of a Windows system",
            "    :return: str, the converted URL format of the given file path",
            "    \"\"\"",
            "",
            "    url = \"/\"+file_path[file_path.index(\"outputs\"):].replace(\"\\\\\",\"/\")",
            "    return \"/\".join([urllib.parse.quote(p, safe=\"\") for p in url.split(\"/\")])",
            "",
            "",
            "def discussion_path_to_url(file_path:str|Path)->str:",
            "    \"\"\"",
            "    This function takes a file path as an argument and converts it into a URL format. It first removes the initial part of the file path until the \"outputs\" string is reached, then replaces backslashes with forward slashes and quotes each segment with urllib.parse.quote() before joining them with forward slashes to form the final URL.",
            "",
            "    :param file_path: str, the file path in the format of a Windows system",
            "    :return: str, the converted URL format of the given file path",
            "    \"\"\"",
            "    file_path = str(file_path)",
            "    url = \"/\"+file_path[file_path.index(\"discussion_databases\"):].replace(\"\\\\\",\"/\").replace(\"discussion_databases\",\"discussions\")",
            "    return \"/\".join([urllib.parse.quote(p, safe=\"\") for p in url.split(\"/\")])",
            "",
            "def personality_path_to_url(file_path:str|Path)->str:",
            "    \"\"\"",
            "    This function takes a file path as an argument and converts it into a URL format. It first removes the initial part of the file path until the \"outputs\" string is reached, then replaces backslashes with forward slashes and quotes each segment with urllib.parse.quote() before joining them with forward slashes to form the final URL.",
            "",
            "    :param file_path: str, the file path in the format of a Windows system",
            "    :return: str, the converted URL format of the given file path",
            "    \"\"\"",
            "    file_path = str(file_path)",
            "    url = \"/\"+file_path[file_path.index(\"personalities_zoo\"):].replace(\"\\\\\",\"/\").replace(\"personalities_zoo\",\"personalities\")",
            "    return \"/\".join([urllib.parse.quote(p, safe=\"\") for p in url.split(\"/\")])",
            "",
            "",
            "def url2host_port(url, default_port =8000):",
            "    if \"http\" in url:",
            "        parts = url.split(\":\")",
            "        host = \":\".join(parts[:2])",
            "        host_no_http = parts[1].replace(\"//\",\"\")",
            "        port = url.split(\":\")[2] if len(parts)==3 else default_port",
            "        return host, host_no_http, port",
            "    else:",
            "        parts = url.split(\":\")",
            "        host = parts[0]",
            "        port = url.split(\":\")[1] if len(parts)==2 else default_port",
            "        return host, host, port",
            "",
            "def is_asyncio_loop_running():",
            "    \"\"\"",
            "    # This function checks if an AsyncIO event loop is currently running. If an event loop is running, it returns True. If not, it returns False.",
            "    :return: bool, indicating whether or not an AsyncIO event loop is currently running",
            "    \"\"\"",
            "    try:",
            "        return asyncio.get_event_loop().is_running()",
            "    except RuntimeError:  # This gets raised if there's no running event loop",
            "        return False",
            "",
            "def run_async(func):",
            "    \"\"\"",
            "    run_async(func) -> None",
            "",
            "    Utility function to run async functions in sync environment. Takes an async function as input and runs it within an async context.",
            "",
            "    Parameters:",
            "    func (function): The async function to run.",
            "",
            "    Returns:",
            "    None: Nothing is returned since the function is meant to perform side effects.",
            "    \"\"\"",
            "    if is_asyncio_loop_running():",
            "        # We're in a running event loop, so we can call the function with asyncio.create_task",
            "        #task = asyncio.run_coroutine_threadsafe(func(), asyncio.get_event_loop())",
            "        #task.result()        ",
            "        loop = asyncio.get_running_loop()",
            "        task = loop.create_task(func())",
            "    else:",
            "        # We're not in a running event loop, so we need to create one and run the function in it",
            "        try:",
            "            asyncio.run(func()) ",
            "        except:",
            "            func()",
            "",
            "",
            "def terminate_thread(thread):",
            "    \"\"\" ",
            "    This function is used to terminate a given thread if it's currently running. If the thread is not alive, an informational message will be displayed and the function will return without raising any error. Otherwise, it sets the thread's exception to `SystemExit` using `ctypes`, which causes the thread to exit. The function collects the garbage after terminating the thread, and raises a `SystemError` if it fails to do so.",
            "    :param thread: thread object to be terminated",
            "    :return: None if the thread was successfully terminated or an error is raised",
            "    :raises SystemError: if the thread could not be terminated ",
            "    \"\"\"    ",
            "    if thread:",
            "        if not thread.is_alive():",
            "            ASCIIColors.yellow(\"Thread not alive\")",
            "            return",
            "",
            "        thread_id = thread.ident",
            "        exc = ctypes.py_object(SystemExit)",
            "        res = ctypes.pythonapi.PyThreadState_SetAsyncExc(thread_id, exc)",
            "        if res > 1:",
            "            ctypes.pythonapi.PyThreadState_SetAsyncExc(thread_id, None)",
            "            del thread",
            "            gc.collect()",
            "            raise SystemError(\"Failed to terminate the thread.\")",
            "        else:",
            "            ASCIIColors.yellow(\"Canceled successfully\")",
            "",
            "def convert_language_name(language_name):",
            "    \"\"\"",
            "    Convert a language name string to its corresponding ISO 639-1 code.",
            "    If the given language name is not supported, returns \"unsupported\".",
            "",
            "    Parameters:",
            "    - language_name (str): A lowercase and dot-free string representing the name of a language.",
            "",
            "    Returns:",
            "    - str: The corresponding ISO 639-1 code for the given language name or \"unsupported\" if it's not supported.",
            "    \"\"\"    ",
            "    # Remove leading and trailing spaces",
            "    language_name = language_name.strip()",
            "    ",
            "    # Convert to lowercase",
            "    language_name = language_name.lower().replace(\".\",\"\")",
            "    ",
            "    # Define a dictionary mapping language names to their codes",
            "    language_codes = { ",
            "                      \"english\": \"en\", \"spanish\": \"es\", \"french\": \"fr\", \"german\": \"de\",",
            "                      \"italian\": \"it\", \"portuguese\": \"pt\", \"russian\": \"ru\", \"mandarin\": \"zh-CN\",",
            "                      \"korean\": \"ko\", \"japanese\": \"ja\", \"dutch\": \"nl\", \"polish\": \"pl\",",
            "                      \"hindi\": \"hi\", \"arabic\": \"ar\", \"bengali\": \"bn\", \"swedish\": \"sv\", \"thai\": \"th\", \"vietnamese\": \"vi\"",
            "                    }",
            "    ",
            "    # Return the corresponding language code if found, or None otherwise",
            "    return language_codes.get(language_name,\"en\")",
            "",
            "",
            "# Function to encode the image",
            "def encode_image(image_path, max_image_width=-1):",
            "    image = Image.open(image_path)",
            "    width, height = image.size",
            "",
            "    # Check and convert image format if needed",
            "    if image.format not in ['PNG', 'JPEG', 'GIF', 'WEBP']:",
            "        image = image.convert('JPEG')",
            "",
            "",
            "    if max_image_width != -1 and width > max_image_width:",
            "        ratio = max_image_width / width",
            "        new_width = max_image_width",
            "        new_height = int(height * ratio)",
            "        f = image.format",
            "        image = image.resize((new_width, new_height))",
            "        image.format = f",
            "",
            "",
            "    # Save the image to a BytesIO object",
            "    byte_arr = io.BytesIO()",
            "    image.save(byte_arr, format=image.format)",
            "    byte_arr = byte_arr.getvalue()",
            "",
            "    return base64.b64encode(byte_arr).decode('utf-8')",
            "",
            "def load_config(file_path):",
            "    with open(file_path, 'r', encoding='utf-8') as stream:",
            "        config = yaml.safe_load(stream)",
            "",
            "    return config",
            "",
            "",
            "def save_config(config, filepath):",
            "    with open(filepath, \"w\") as f:",
            "        yaml.dump(config, f)",
            "",
            "",
            "def load_image(image_file):",
            "    s_image_file = str(image_file)",
            "    if s_image_file.startswith('http://') or s_image_file.startswith('https://'):",
            "        response = requests.get(s_image_file)",
            "        image = Image.open(BytesIO(response.content)).convert('RGB')",
            "    else:",
            "        image = Image.open(s_image_file).convert('RGB')",
            "    return image",
            "",
            "def load_image_from_base64(image):",
            "    return Image.open(BytesIO(base64.b64decode(image)))",
            "",
            "",
            "def expand2square(pil_img, background_color):",
            "    width, height = pil_img.size",
            "    if width == height:",
            "        return pil_img",
            "    elif width > height:",
            "        result = Image.new(pil_img.mode, (width, width), background_color)",
            "        result.paste(pil_img, (0, (width - height) // 2))",
            "        return result",
            "    else:",
            "        result = Image.new(pil_img.mode, (height, height), background_color)",
            "        result.paste(pil_img, ((height - width) // 2, 0))",
            "        return result",
            "",
            "",
            "def add_period(text):",
            "    \"\"\"",
            "    Adds a period at the end of each line in the given text, except for empty lines.",
            "",
            "    Args:",
            "        text (str): The input text.",
            "",
            "    Returns:",
            "        str: The preprocessed text with a period added at the end of each line that doesn't already have one.",
            "    \"\"\"",
            "    lines = text.split('\\n')",
            "    processed_lines = []",
            "    ",
            "    for line in lines:",
            "        if line.strip():  # Check if line is not empty",
            "            if line[-1] != '.':",
            "                line += '.'",
            "        processed_lines.append(line)",
            "    ",
            "    processed_text = '\\n'.join(processed_lines)",
            "    return processed_text",
            "",
            "def find_next_available_filename(folder_path, prefix):",
            "    folder = Path(folder_path)",
            "",
            "    if not folder.exists():",
            "        raise FileNotFoundError(f\"The folder '{folder}' does not exist.\")",
            "",
            "    index = 1",
            "    while True:",
            "        next_filename = f\"{prefix}_{index}.png\"",
            "        potential_file = folder / next_filename",
            "        if not potential_file.exists():",
            "            return potential_file",
            "        index += 1",
            "",
            "",
            "def find_first_available_file_index(folder_path, prefix, extension=\"\"):",
            "    \"\"\"",
            "    Finds the first available file index in a folder with files that have a prefix and an optional extension.",
            "    ",
            "    Args:",
            "        folder_path (str): The path to the folder.",
            "        prefix (str): The file prefix.",
            "        extension (str, optional): The file extension (including the dot). Defaults to \"\".",
            "    ",
            "    Returns:",
            "        int: The first available file index.",
            "    \"\"\"",
            "    # Create a Path object for the folder",
            "    folder = Path(folder_path)",
            "    ",
            "    # Get a list of all files in the folder",
            "    files = folder.glob(f'{prefix}*'+extension)",
            "    ",
            "    # Initialize the first available number",
            "    available_number = 1",
            "    ",
            "    # Iterate through the files",
            "    while True:",
            "        f = folder/f\"{prefix}{available_number}{extension}\"",
            "        if f.exists():",
            "            available_number += 1",
            "        # If the file number is greater than the available number, break the loop",
            "        else:",
            "            return available_number",
            "",
            "",
            "",
            "",
            "# Prompting tools",
            "def detect_antiprompt(text:str, anti_prompts=[\"!@>\"]) -> bool:",
            "    \"\"\"",
            "    Detects if any of the antiprompts in self.anti_prompts are present in the given text.",
            "    Used for the Hallucination suppression system",
            "",
            "    Args:",
            "        text (str): The text to check for antiprompts.",
            "",
            "    Returns:",
            "        bool: True if any antiprompt is found in the text (ignoring case), False otherwise.",
            "    \"\"\"",
            "    for prompt in anti_prompts:",
            "        if prompt.lower() in text.lower():",
            "            return prompt.lower()",
            "    return None",
            "",
            "",
            "def remove_text_from_string(string, text_to_find):",
            "    \"\"\"",
            "    Removes everything from the first occurrence of the specified text in the string (case-insensitive).",
            "",
            "    Parameters:",
            "    string (str): The original string.",
            "    text_to_find (str): The text to find in the string.",
            "",
            "    Returns:",
            "    str: The updated string.",
            "    \"\"\"",
            "    index = string.lower().find(text_to_find.lower())",
            "",
            "    if index != -1:",
            "        string = string[:index]",
            "",
            "    return string",
            "",
            "",
            "# Pytorch and cuda tools",
            "def check_torch_version(min_version, min_cuda_versio=12):",
            "    import torch",
            "",
            "    if \"+\" in torch.__version__ and int(torch.__version__.split(\"+\")[-1][2:4])<min_cuda_versio:",
            "        return False",
            "",
            "    # Extract torch version from __version__ attribute with regular expression",
            "    current_version_float = float('.'.join(torch.__version__.split(\".\")[:2]))",
            "    # Check if the current version meets or exceeds the minimum required version",
            "    return current_version_float >= min_version",
            "",
            "def install_ninja():",
            "    import conda.cli",
            "    try:",
            "        ASCIIColors.info(\"Installing ninja\") # -c nvidia/label/cuda-12.3.2 -c nvidia -c conda-forge",
            "        result = conda.cli.main(\"install\", \"-c\", \"nvidia/label/cuda-12.3.2\", \"-c\", \"nvidia\", \"-c\", \"conda-forge\", \"ninja\", \"-y\",\"--force-reinstall\")",
            "    except Exception as ex:",
            "        ASCIIColors.error(ex)",
            "",
            "def install_cuda():",
            "    import conda.cli",
            "    try:",
            "        ASCIIColors.info(\"Installing cuda 12.3.2\") # -c nvidia/label/cuda-12.3.2 -c nvidia -c conda-forge",
            "        result = conda.cli.main(\"install\", \"-c\", \"nvidia/label/cuda-12.3.2\", \"-c\", \"nvidia\", \"-c\", \"conda-forge\", \"cuda-toolkit\",\"-y\",\"--force-reinstall\")",
            "    except Exception as ex:",
            "        ASCIIColors.error(ex)",
            "    try:",
            "        ASCIIColors.info(\"Installing cuda compiler\") # -c nvidia/label/cuda-12.3.2 -c nvidia -c conda-forge",
            "        result = conda.cli.main(\"install\", \"-c\", \"nvidia/label/cuda-12.3.2\", \"-c\", \"nvidia\", \"-c\", \"conda-forge\", \"cuda-compiler\", \"-y\",\"--force-reinstall\")",
            "    except Exception as ex:",
            "        ASCIIColors.error(ex)",
            "        ",
            "def install_cmake():",
            "    import conda.cli",
            "    try:",
            "        ASCIIColors.info(\"Installing cmake\") # -c nvidia/label/cuda-12.3.2 -c nvidia -c conda-forge",
            "        result = conda.cli.main(\"install\", \"-c\", \"nvidia/label/cuda-12.3.2\", \"-c\", \"nvidia\", \"-c\", \"conda-forge\", \"cmake\",\"-y\",\"--force-reinstall\")",
            "    except Exception as ex:",
            "        ASCIIColors.error(ex)",
            "",
            "def reinstall_pytorch_with_cuda():",
            "    try:",
            "        import conda.cli",
            "        ASCIIColors.info(\"Installing cuda 12.3.2\") # -c nvidia/label/cuda-12.3.2 -c nvidia -c conda-forge",
            "        result = conda.cli.main(\"install\", \"-c\", \"nvidia/label/cuda-12.3.2\", \"-c\", \"nvidia\", \"-c\", \"conda-forge\", \"cuda-toolkit\",\"-y\",\"--force-reinstall\")",
            "    except Exception as ex:",
            "        ASCIIColors.error(ex)",
            "    try:",
            "        ASCIIColors.info(\"Installing ninja\") # -c nvidia/label/cuda-12.3.2 -c nvidia -c conda-forge",
            "        result = conda.cli.main(\"install\", \"-c\", \"nvidia/label/cuda-12.3.2\", \"-c\", \"nvidia\", \"-c\", \"conda-forge\", \"ninja\", \"-y\",\"--force-reinstall\")",
            "    except Exception as ex:",
            "        ASCIIColors.error(ex)",
            "    try:",
            "        ASCIIColors.info(\"Installing cuda compiler\") # -c nvidia/label/cuda-12.3.2 -c nvidia -c conda-forge",
            "        result = conda.cli.main(\"install\", \"-c\", \"nvidia/label/cuda-12.3.2\", \"-c\", \"nvidia\", \"-c\", \"conda-forge\", \"cuda-compiler\", \"-y\",\"--force-reinstall\")",
            "    except Exception as ex:",
            "        ASCIIColors.error(ex)",
            "    try:",
            "        ASCIIColors.info(\"Installing pytorch 2.2.1\")",
            "        result = subprocess.run([sys.executable, \"-m\", \"pip\", \"install\", \"--upgrade\", \"torch\", \"torchvision\", \"torchaudio\", \"--no-cache-dir\", \"--index-url\", \"https://download.pytorch.org/whl/cu121\"])",
            "    except Exception as ex:",
            "        ASCIIColors.error(ex)",
            "    if result.returncode != 0:",
            "        ASCIIColors.warning(\"Couldn't find Cuda build tools on your PC. Reverting to CPU.\")",
            "        result = subprocess.run([sys.executable, \"-m\", \"pip\", \"install\", \"--upgrade\", \"torch\", \"torchvision\", \"torchaudio\", \"--no-cache-dir\"])",
            "        if result.returncode != 0:",
            "            ASCIIColors.error(\"Couldn't install pytorch !!\")",
            "        else:",
            "            ASCIIColors.error(\"Pytorch installed successfully!!\")",
            "",
            "",
            "def reinstall_pytorch_with_rocm():",
            "    result = subprocess.run([sys.executable, \"-m\", \"pip\", \"install\", \"--upgrade\", \"torch\", \"torchvision\", \"torchaudio\", \"--no-cache-dir\", \"--index-url\", \"https://download.pytorch.org/whl/rocm5.6\"])",
            "    if result.returncode != 0:",
            "        ASCIIColors.warning(\"Couldn't find Cuda build tools on your PC. Reverting to CPU.\")",
            "        result = subprocess.run([sys.executable, \"-m\", \"pip\", \"install\", \"--upgrade\", \"torch\", \"torchvision\", \"torchaudio\", \"--no-cache-dir\"])",
            "        if result.returncode != 0:",
            "            ASCIIColors.error(\"Couldn't install pytorch !!\")",
            "        else:",
            "            ASCIIColors.error(\"Pytorch installed successfully!!\")",
            "            ",
            "            ",
            "",
            "def reinstall_pytorch_with_cpu():",
            "    result = subprocess.run([sys.executable, \"-m\", \"pip\", \"install\", \"--upgrade\", \"torch\", \"torchvision\", \"torchaudio\", \"--no-cache-dir\"])",
            "    if result.returncode != 0:",
            "        ASCIIColors.warning(\"Couldn't find Cuda build tools on your PC. Reverting to CPU.\")",
            "        result = subprocess.run([sys.executable, \"-m\", \"pip\", \"install\", \"--upgrade\", \"torch\", \"torchvision\", \"torchaudio\", \"--no-cache-dir\"])",
            "        if result.returncode != 0:",
            "            ASCIIColors.error(\"Couldn't install pytorch !!\")",
            "        else:",
            "            ASCIIColors.error(\"Pytorch installed successfully!!\")     ",
            "",
            "",
            "def check_and_install_torch(enable_gpu:bool, version:float=2.2):",
            "    if enable_gpu:",
            "        ASCIIColors.yellow(\"This installation has enabled GPU support. Trying to install with GPU support\")",
            "        ASCIIColors.info(\"Checking pytorch\")",
            "        try:",
            "            import torch",
            "            import torchvision",
            "            if torch.cuda.is_available():",
            "                ASCIIColors.success(f\"CUDA is supported.\\nCurrent version is {torch.__version__}.\")",
            "                if not check_torch_version(version):",
            "                    ASCIIColors.yellow(\"Torch version is old. Installing new version\")",
            "                    reinstall_pytorch_with_cuda()",
            "                else:",
            "                    ASCIIColors.yellow(\"Torch OK\")",
            "            else:",
            "                ASCIIColors.warning(\"CUDA is not supported. Trying to reinstall PyTorch with CUDA support.\")",
            "                reinstall_pytorch_with_cuda()",
            "        except Exception as ex:",
            "            ASCIIColors.info(\"Pytorch not installed. Reinstalling ...\")",
            "            reinstall_pytorch_with_cuda()    ",
            "    else:",
            "        try:",
            "            import torch",
            "            import torchvision",
            "            if check_torch_version(version):",
            "                ASCIIColors.warning(\"Torch version is too old. Trying to reinstall PyTorch with CUDA support.\")",
            "                reinstall_pytorch_with_cpu()",
            "        except Exception as ex:",
            "            ASCIIColors.info(\"Pytorch not installed. Reinstalling ...\")",
            "            reinstall_pytorch_with_cpu() ",
            "    ",
            "",
            "class NumpyEncoderDecoder(json.JSONEncoder):",
            "    def default(self, obj):",
            "        if isinstance(obj, np.ndarray):",
            "            return {'__numpy_array__': True, 'data': obj.tolist()}",
            "        return super(NumpyEncoderDecoder, self).default(obj)",
            "",
            "    @staticmethod",
            "    def as_numpy_array(dct):",
            "        if '__numpy_array__' in dct:",
            "            return np.array(dct['data'])",
            "        return dct",
            "    ",
            "",
            "def clone_repository(repository_url, local_folder:Path|str, exist_ok=False):",
            "    if Path(local_folder).exists():",
            "        if exist_ok:",
            "            shutil.rmtree(str(local_folder))",
            "        else:",
            "            ASCIIColors.success(\"Repository already exists!\")",
            "            return False",
            "",
            "    try:",
            "        # Create a new repository object",
            "        repo = git.Repo.clone_from(repository_url, str(local_folder))",
            "        ASCIIColors.success(\"Repository was cloned successfully\")",
            "        return True",
            "    except:",
            "        ASCIIColors.error(\"Repository cloning failed\")",
            "        return False",
            "    ",
            "def git_pull(folder_path):",
            "    try:",
            "        # Change the current working directory to the desired folder",
            "        subprocess.run([\"git\", \"checkout\", folder_path], check=True, cwd=folder_path)",
            "        # Run 'git pull' in the specified folder",
            "        subprocess.run([\"git\", \"pull\"], check=True, cwd=folder_path)",
            "        print(\"Git pull successful in\", folder_path)",
            "    except subprocess.CalledProcessError as e:",
            "        print(\"Error occurred while executing Git pull:\", e)",
            "        # Handle any specific error handling here if required",
            "class AdvancedGarbageCollector:",
            "    @staticmethod",
            "    def hardCollect(obj):",
            "        \"\"\"",
            "        Remove a reference to the specified object and attempt to collect it.",
            "",
            "        Parameters:",
            "        - obj: The object to be collected.",
            "",
            "        This method first identifies all the referrers (objects referencing the 'obj')",
            "        using Python's garbage collector (gc.get_referrers). It then iterates through",
            "        the referrers and attempts to break their reference to 'obj' by setting them",
            "        to None. Finally, it deletes the 'obj' reference.",
            "",
            "        Note: This method is designed to handle circular references and can be used",
            "        to forcefully collect objects that might not be collected automatically.",
            "",
            "        \"\"\"",
            "        if obj is None:",
            "            return",
            "        all_referrers = gc.get_referrers(obj)",
            "        for referrer in all_referrers:",
            "            try:",
            "                if isinstance(referrer, (list, tuple, dict, set)):",
            "                    if isinstance(referrer, list):",
            "                        if obj in referrer:",
            "                            referrer.remove(obj)",
            "                    elif isinstance(referrer, dict):",
            "                        new_dict = {}",
            "                        for key, value in referrer.items():",
            "                            if value != obj:",
            "                                new_dict[key] = value",
            "                        referrer.clear()",
            "                        referrer.update(new_dict)",
            "                    elif isinstance(referrer, set):",
            "                        if obj in referrer:",
            "                            referrer.remove(obj)",
            "            except:",
            "                ASCIIColors.warning(\"Couldn't remove object from referrer\")",
            "        del obj",
            "",
            "    @staticmethod",
            "    def safeHardCollect(variable_name, instance=None):",
            "        \"\"\"",
            "        Safely remove a reference to a variable and attempt to collect its object.",
            "",
            "        Parameters:",
            "        - variable_name: The name of the variable to be collected.",
            "        - instance: An optional instance (object) to search for the variable if it",
            "          belongs to an object.",
            "",
            "        This method provides a way to safely break references to a variable by name.",
            "        It first checks if the variable exists either in the local or global namespace",
            "        or within the provided instance. If found, it calls the 'hardCollect' method",
            "        to remove the reference and attempt to collect the associated object.",
            "",
            "        \"\"\"",
            "        if instance is not None:",
            "            if hasattr(instance, variable_name):",
            "                obj = getattr(instance, variable_name)",
            "                AdvancedGarbageCollector.hardCollect(obj)",
            "            else:",
            "                print(f\"The variable '{variable_name}' does not exist in the instance.\")",
            "        else:",
            "            if variable_name in locals():",
            "                obj = locals()[variable_name]",
            "                AdvancedGarbageCollector.hardCollect(obj)",
            "            elif variable_name in globals():",
            "                obj = globals()[variable_name]",
            "                AdvancedGarbageCollector.hardCollect(obj)",
            "            else:",
            "                print(f\"The variable '{variable_name}' does not exist in the local or global namespace.\")",
            "",
            "    @staticmethod",
            "    def safeHardCollectMultiple(variable_names, instance=None):",
            "        \"\"\"",
            "        Safely remove references to multiple variables and attempt to collect their objects.",
            "",
            "        Parameters:",
            "        - variable_names: A list of variable names to be collected.",
            "        - instance: An optional instance (object) to search for the variables if they",
            "          belong to an object.",
            "",
            "        This method iterates through a list of variable names and calls 'safeHardCollect'",
            "        for each variable, effectively removing references and attempting to collect",
            "        their associated objects.",
            "",
            "        \"\"\"",
            "        for variable_name in variable_names:",
            "            AdvancedGarbageCollector.safeHardCollect(variable_name, instance)",
            "",
            "    @staticmethod",
            "    def collect():",
            "        \"\"\"",
            "        Perform a manual garbage collection using Python's built-in 'gc.collect' method.",
            "",
            "        This method triggers a manual garbage collection, attempting to clean up",
            "        any unreferenced objects in memory. It can be used to free up memory and",
            "        resources that are no longer in use.",
            "",
            "        \"\"\"",
            "        gc.collect()",
            "",
            "",
            "class PackageManager:",
            "    @staticmethod",
            "    def install_package(package_name):",
            "        import subprocess",
            "        import sys",
            "        subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"--upgrade\", package_name])",
            "        ",
            "    @staticmethod",
            "    def check_package_installed(package_name):",
            "        try:",
            "            importlib.import_module(package_name)",
            "            return True",
            "        except ImportError:",
            "            return False",
            "        except Exception as ex:",
            "            trace_exception(ex)",
            "            ASCIIColors.error(\"Something is wrong with your library.\\nIt looks installed, but I am not able to call it.\\nTry to reinstall it.\")",
            "            return False",
            "        ",
            "    @staticmethod",
            "    def safe_import(module_name, library_name=None):",
            "        if not PackageManager.check_package_installed(module_name):",
            "            print(f\"{module_name} module not found. Installing...\")",
            "            if library_name:",
            "                PackageManager.install_package(library_name)",
            "            else:",
            "                PackageManager.install_package(module_name)",
            "        globals()[module_name] = importlib.import_module(module_name)",
            "        print(f\"{module_name} module imported successfully.\")",
            "",
            "",
            "class GitManager:",
            "    @staticmethod",
            "    def git_pull(folder_path):",
            "        try:",
            "            # Change the current working directory to the desired folder",
            "            subprocess.run([\"git\", \"checkout\", folder_path], check=True, cwd=folder_path)",
            "            # Run 'git pull' in the specified folder",
            "            subprocess.run([\"git\", \"pull\"], check=True, cwd=folder_path)",
            "            print(\"Git pull successful in\", folder_path)",
            "        except subprocess.CalledProcessError as e:",
            "            print(\"Error occurred while executing Git pull:\", e)",
            "            # Handle any specific error handling here if required",
            "",
            "class File64BitsManager:",
            "",
            "    @staticmethod",
            "    def raw_b64_img(image) -> str:",
            "        try:",
            "            from PIL import Image, PngImagePlugin",
            "            import io",
            "            import base64",
            "        except:",
            "            PackageManager.install_package(\"Pillow\")",
            "            from PIL import Image",
            "            import io",
            "            import base64",
            "",
            "        # XXX controlnet only accepts RAW base64 without headers",
            "        with io.BytesIO() as output_bytes:",
            "            metadata = None",
            "            for key, value in image.info.items():",
            "                if isinstance(key, str) and isinstance(value, str):",
            "                    if metadata is None:",
            "                        metadata = PngImagePlugin.PngInfo()",
            "                    metadata.add_text(key, value)",
            "            image.save(output_bytes, format=\"PNG\", pnginfo=metadata)",
            "",
            "            bytes_data = output_bytes.getvalue()",
            "",
            "        return str(base64.b64encode(bytes_data), \"utf-8\")",
            "",
            "",
            "    @staticmethod",
            "    def img2b64(image) -> str:",
            "        return \"data:image/png;base64,\" + File64BitsManager.raw_b64_img(image)    ",
            "",
            "    @staticmethod",
            "    def b642img(b64img) -> str:",
            "        try:",
            "            from PIL import Image, PngImagePlugin",
            "            import io",
            "            import base64",
            "        except:",
            "            PackageManager.install_package(\"Pillow\")",
            "            from PIL import Image",
            "            import io",
            "            import base64        ",
            "        image_data = re.sub('^data:image/.+;base64,', '', b64img)",
            "        return Image.open(io.BytesIO(base64.b64decode(image_data)))  ",
            "",
            "    @staticmethod",
            "    def get_supported_file_extensions_from_base64(b64data):",
            "        # Extract the file extension from the base64 data",
            "        data_match = re.match(r'^data:(.*?);base64,', b64data)",
            "        if data_match:",
            "            mime_type = data_match.group(1)",
            "            extension = mime_type.split('/')[-1]",
            "            return extension",
            "        else:",
            "            raise ValueError(\"Invalid base64 data format.\")",
            "        ",
            "    @staticmethod",
            "    def extract_content_from_base64(b64data):",
            "        # Split the base64 data at the comma separator",
            "        header, content = b64data.split(',', 1)",
            "",
            "        # Extract only the content part and remove any white spaces and newlines",
            "        content = content.strip()",
            "",
            "        return content",
            "",
            "    @staticmethod",
            "    def b642file(b64data, filename):",
            "        import base64   ",
            "        # Extract the file extension from the base64 data",
            "        ",
            "        ",
            "        # Save the file with the determined extension",
            "        with open(filename, 'wb') as file:",
            "            file.write(base64.b64decode(File64BitsManager.extract_content_from_base64(b64data)))",
            "",
            "        return filename",
            "    ",
            "class PromptReshaper:",
            "    def __init__(self, template:str):",
            "        self.template = template",
            "    def replace(self, placeholders:dict)->str:",
            "        template = self.template",
            "        # Calculate the number of tokens for each placeholder",
            "        for placeholder, text in placeholders.items():",
            "            template = template.replace(placeholder, text)",
            "        return template",
            "    def build(self, placeholders:dict, tokenize, detokenize, max_nb_tokens:int, place_holders_to_sacrifice:list=[])->str:",
            "        # Tokenize the template without placeholders",
            "        template_text = self.template",
            "        template_tokens = tokenize(template_text)",
            "        ",
            "        # Calculate the number of tokens in the template without placeholders",
            "        template_tokens_count = len(template_tokens)",
            "        ",
            "        # Calculate the number of tokens for each placeholder",
            "        placeholder_tokens_count = {}",
            "        all_count = template_tokens_count",
            "        for placeholder, text in placeholders.items():",
            "            text_tokens = tokenize(text)",
            "            placeholder_tokens_count[placeholder] = len(text_tokens)",
            "            all_count += placeholder_tokens_count[placeholder]",
            "",
            "        def fill_template(template, data):",
            "            for key, value in data.items():",
            "                placeholder = \"{{\" + key + \"}}\"",
            "                n_text_tokens = len(tokenize(template))",
            "                if key in place_holders_to_sacrifice:",
            "                    n_remaining = max_nb_tokens - n_text_tokens",
            "                    t_value = tokenize(value)",
            "                    n_value = len(t_value)",
            "                    if n_value<n_remaining:",
            "                        template = template.replace(placeholder, value)",
            "                    else:",
            "                        value = detokenize(t_value[-n_remaining:])",
            "                        template = template.replace(placeholder, value)",
            "                        ",
            "                else:",
            "                    template = template.replace(placeholder, value)",
            "            return template",
            "        ",
            "        return fill_template(self.template, placeholders)",
            "",
            "",
            "",
            "class LOLLMSLocalizer:",
            "    def __init__(self, dictionary):",
            "        self.dictionary = dictionary",
            "",
            "    def localize(self, input_string):",
            "        def replace(match):",
            "            key = match.group(1)",
            "            return self.dictionary.get(key, match.group(0))",
            "        ",
            "        import re",
            "        pattern = r'@<([^>]+)>@'",
            "        localized_string = re.sub(pattern, replace, input_string)",
            "        return localized_string",
            "",
            "",
            "class File_Path_Generator:",
            "    @staticmethod",
            "    def generate_unique_file_path(folder_path, file_base_name, file_extension):",
            "        folder_path = Path(folder_path)",
            "        index = 0",
            "        while True:",
            "            # Construct the full file path with the current index",
            "            file_name = f\"{file_base_name}_{index}.{file_extension}\"",
            "            full_file_path = folder_path / file_name",
            "            ",
            "            # Check if the file already exists in the folder",
            "            if not full_file_path.exists():",
            "                return full_file_path",
            "            ",
            "            # If the file exists, increment the index and try again",
            "            index += 1",
            "",
            "",
            "def remove_text_from_string(string: str, text_to_find:str):",
            "    \"\"\"",
            "    Removes everything from the first occurrence of the specified text in the string (case-insensitive).",
            "",
            "    Parameters:",
            "    string (str): The original string.",
            "    text_to_find (str): The text to find in the string.",
            "",
            "    Returns:",
            "    str: The updated string.",
            "    \"\"\"",
            "    index = string.lower().find(text_to_find.lower())",
            "",
            "    if index != -1:",
            "        string = string[:index]",
            "",
            "    return string"
        ],
        "afterPatchFile": [
            "",
            "######",
            "# Project       : lollms",
            "# File          : utilities.py",
            "# Author        : ParisNeo with the help of the community",
            "# license       : Apache 2.0",
            "# Description   : ",
            "# This file contains utilities functions that can be used by any",
            "# module.",
            "######",
            "from ascii_colors import ASCIIColors, trace_exception",
            "import numpy as np",
            "from pathlib import Path",
            "import json",
            "import re",
            "import subprocess",
            "import gc",
            "import shutil",
            "",
            "from typing import List",
            "",
            "from PIL import Image",
            "import requests",
            "from io import BytesIO",
            "import base64",
            "import importlib",
            "import yaml",
            "",
            "import asyncio",
            "",
            "import ctypes",
            "import io",
            "import urllib",
            "import os",
            "import sys",
            "import git",
            "",
            "import mimetypes",
            "import subprocess",
            "",
            "from functools import partial",
            "",
            "def install_conda_utility():",
            "    import platform",
            "    if platform.system()==\"Windows\":",
            "        conda_path = Path(sys.executable).parent.parent/\"miniconda3\"/\"condabin\"/\"conda\"",
            "    else:",
            "        conda_path = Path(sys.executable).parent.parent.parent/\"miniconda3\"/\"bin\"/\"conda\"",
            "    ASCIIColors.red(\"Conda path:\")",
            "    ASCIIColors.yellow(conda_path)",
            "    process = subprocess.Popen(f'{conda_path} install conda -y', shell=True)",
            "    ",
            "    # Wait for the process to finish",
            "    process.wait()",
            "    #from conda.cli.python_api import  run_command, Commands",
            "    # Create a new Conda environment with the specified Python version",
            "    #run_command(Commands.CREATE, \"-n\", env_name, f\"python={python_version}\")",
            "",
            "",
            "def create_conda_env(env_name, python_version):",
            "    from lollms.security import sanitize_shell_code",
            "    env_name = sanitize_shell_code(env_name)",
            "    python_version = sanitize_shell_code(python_version)",
            "    # Activate the Conda environment",
            "    import platform",
            "    if platform.system()==\"Windows\":",
            "        conda_path = Path(sys.executable).parent.parent/\"miniconda3\"/\"condabin\"/\"conda\"",
            "    else:",
            "        conda_path = Path(sys.executable).parent.parent.parent/\"miniconda3\"/\"bin\"/\"conda\"",
            "    ASCIIColors.red(\"Conda path:\")",
            "    ASCIIColors.yellow(conda_path)",
            "    process = subprocess.Popen(f'{conda_path} create --name {env_name} python={python_version} -y', shell=True)",
            "    ",
            "    # Wait for the process to finish",
            "    process.wait()",
            "    #from conda.cli.python_api import  run_command, Commands",
            "    # Create a new Conda environment with the specified Python version",
            "    #run_command(Commands.CREATE, \"-n\", env_name, f\"python={python_version}\")",
            "",
            "def run_pip_in_env(env_name, pip_args, cwd=None):",
            "    import platform",
            "    # Set the current working directory if provided, otherwise use the current directory",
            "    if cwd is None:",
            "        cwd = os.getcwd()",
            "    ",
            "    # Activate the Conda environment",
            "    python_path = Path(sys.executable).parent.parent/\"miniconda3\"/\"envs\"/env_name/\"python\"",
            "    process = subprocess.Popen(f'{python_path} -m pip {pip_args}', shell=True)",
            "    ",
            "    # Wait for the process to finish",
            "    process.wait()",
            "",
            "",
            "def run_python_script_in_env(env_name, script_path, cwd=None, wait=True):",
            "    import platform",
            "    # Set the current working directory if provided, otherwise use the current directory",
            "    if cwd is None:",
            "        cwd = os.getcwd()",
            "    ",
            "    # Activate the Conda environment",
            "    python_path = Path(sys.executable).parent.parent/\"miniconda3\"/\"envs\"/env_name/\"python\"",
            "    process = subprocess.Popen(f'{python_path} {script_path}', shell=True)",
            "    ",
            "    # Wait for the process to finish",
            "    if wait:",
            "        process.wait()",
            "    return process",
            "",
            "def run_script_in_env(env_name, script_path, cwd=None):",
            "    import platform",
            "    # Set the current working directory if provided, otherwise use the current directory",
            "    if cwd is None:",
            "        cwd = os.path.dirname(script_path)",
            "    ",
            "    # Activate the Conda environment",
            "    if platform.system()==\"Windows\":",
            "        python_path = Path(sys.executable).parent.parent/\"miniconda3\"/\"condabin\"/\"conda\"",
            "        subprocess.Popen(f'{python_path} activate {env_name} && {script_path}', shell=True, cwd=cwd)",
            "    else:",
            "        python_path = Path(sys.executable).parent.parent.parent/\"miniconda3\"/\"bin\"/\"conda\"",
            "        subprocess.Popen(f'source {python_path} activate {env_name} && {script_path}', shell=True, cwd=cwd)",
            "    # Activate the Conda environment",
            "    ASCIIColors.red(\"Python path:\")",
            "    ASCIIColors.yellow(python_path)",
            "    #run_command(Commands.RUN, \"-n\", env_name, str(script_path), cwd=cwd)",
            "",
            "def get_conda_path():",
            "    import platform",
            "    if platform.system() == \"Windows\":",
            "        return Path(sys.executable).parent.parent / \"miniconda3\" / \"condabin\" / \"conda\"",
            "    else:",
            "        return Path(sys.executable).parent.parent.parent / \"miniconda3\" / \"bin\" / \"conda\"",
            "",
            "def environment_exists(env_name):",
            "    from lollms.security import sanitize_shell_code",
            "    env_name = sanitize_shell_code(env_name)",
            "    conda_path = get_conda_path()",
            "    result = subprocess.run(f'{conda_path} env list --json', shell=True, capture_output=True, text=True)",
            "    envs_info = json.loads(result.stdout)",
            "    env_names = [Path(env).name for env in envs_info['envs']]",
            "    return env_name in env_names",
            "",
            "def get_python_version(env_name):",
            "    from lollms.security import sanitize_shell_code",
            "    env_name = sanitize_shell_code(env_name)",
            "    conda_path = get_conda_path()",
            "    if environment_exists(env_name):",
            "        result = subprocess.run(f'{conda_path} run -n {env_name} python --version', shell=True, capture_output=True, text=True)",
            "        return result.stdout.strip()",
            "    else:",
            "        return \"Environment does not exist.\"",
            "",
            "def remove_environment(env_name):",
            "    from lollms.security import sanitize_shell_code",
            "    env_name = sanitize_shell_code(env_name)",
            "    conda_path = get_conda_path()",
            "    if environment_exists(env_name):",
            "        process = subprocess.Popen(f'{conda_path} env remove --name {env_name} -y', shell=True)",
            "        process.wait()",
            "        return f\"Environment '{env_name}' has been removed.\"",
            "    else:",
            "        return \"Environment does not exist.\"",
            "",
            "def process_ai_output(output, images, output_folder):",
            "    if not PackageManager.check_package_installed(\"cv2\"):",
            "        PackageManager.install_package(\"opencv-python\")",
            "    import cv2",
            "    images = [cv2.imread(str(img)) for img in images]",
            "    # Find all bounding box entries in the output",
            "    bounding_boxes = re.findall(r'boundingbox\\((\\d+), ([^,]+), ([^,]+), ([^,]+), ([^,]+), ([^,]+)\\)', output)",
            "",
            "    # Group bounding boxes by image index",
            "    image_boxes = {}",
            "    for box in bounding_boxes:",
            "        image_index = int(box[0])",
            "        if image_index not in image_boxes:",
            "            image_boxes[image_index] = []",
            "        image_boxes[image_index].append(box[1:])",
            "",
            "    # Process each image and its bounding boxes",
            "    for image_index, boxes in image_boxes.items():",
            "        # Get the corresponding image",
            "        image = images[image_index]",
            "",
            "        # Draw bounding boxes on the image",
            "        for box in boxes:",
            "            label, left, top, width, height = box",
            "            left, top, width, height = float(left), float(top), float(width), float(height)",
            "            x, y, w, h = int(left * image.shape[1]), int(top * image.shape[0]), int(width * image.shape[1]), int(height * image.shape[0])",
            "            cv2.rectangle(image, (x, y), (x + w, y + h), (0, 255, 0), 2)",
            "            cv2.putText(image, label, (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (0, 255, 0), 2)",
            "",
            "        # Save the modified image",
            "        random_stuff = np.random",
            "        output_path = Path(output_folder)/f\"image_{image_index}_{random_stuff}.jpg\"",
            "        cv2.imwrite(str(output_path), image)",
            "",
            "    # Remove bounding box text from the output",
            "    output = re.sub(r'boundingbox\\([^)]+\\)', '', output)",
            "",
            "    # Append img tags for the generated images",
            "    for image_index in image_boxes.keys():",
            "        url = discussion_path_to_url(Path(output_folder)/f\"image_{image_index}.jpg\")",
            "        output += f'\\n<img src=\"{url}\">'",
            "",
            "    return output",
            "",
            "def get_media_type(file_path):",
            "    \"\"\"",
            "    Determines the media type of a file based on its file extension.",
            "",
            "    Args:",
            "        file_path (str): The path to the media file.",
            "",
            "    Returns:",
            "        str: The media type of the file in the format \"type/subtype\".",
            "             Returns \"Unknown\" if the media type cannot be determined.",
            "    \"\"\"",
            "    media_type, _ = mimetypes.guess_type(file_path)",
            "    ",
            "    if media_type is None:",
            "        return \"Unknown\"",
            "    else:",
            "        return media_type",
            "",
            "",
            "def discussion_path_2_url(path:str|Path):",
            "    path = str(path)",
            "    return path[path.index('discussion_databases'):].replace('discussion_databases','discussions')",
            "",
            "",
            "def yes_or_no_input(prompt):",
            "    while True:",
            "        user_input = input(prompt + \" (yes/no): \").lower()",
            "        if user_input == 'yes':",
            "            return True",
            "        elif user_input == 'no':",
            "            return False",
            "        else:",
            "            print(\"Please enter 'yes' or 'no'.\")",
            "",
            "def show_console_custom_dialog(title, text, options):",
            "    print(title)",
            "    print(text)",
            "    for i, option in enumerate(options, 1):",
            "        print(f\"{i}. {option}\")",
            "    while True:",
            "        try:",
            "            choice = int(input(\"Enter the number of your choice: \"))",
            "            if 1 <= choice <= len(options):",
            "                return options[choice - 1]",
            "            else:",
            "                print(\"Invalid choice. Please try again.\")",
            "        except ValueError:",
            "            print(\"Invalid input. Please enter a number.\")",
            "",
            "def show_custom_dialog(title, text, options):",
            "    try:",
            "        import tkinter as tk",
            "        from tkinter import simpledialog        ",
            "        class CustomDialog(simpledialog.Dialog):",
            "            def __init__(self, parent, title, options, root):",
            "                self.options = options",
            "                self.root = root",
            "                self.buttons = []",
            "                self.result_value = \"\"",
            "                super().__init__(parent, title)",
            "            def do_ok(self, option):",
            "                self.result_value = option",
            "                self.ok(option)",
            "                self.root.destroy()",
            "            def body(self, master):",
            "                for option in self.options:",
            "                    button = tk.Button(master, text=option, command=partial(self.do_ok, option))",
            "                    button.pack(side=\"left\", fill=\"x\")",
            "                    self.buttons.append(button)",
            "",
            "            def apply(self):",
            "                self.result = self.options[0]  # Default value",
            "        root = tk.Tk()",
            "        root.withdraw()",
            "        root.attributes('-topmost', True)",
            "        d = CustomDialog(root, title=title, options=options, root=root)",
            "        try:",
            "            d.mainloop()",
            "        except Exception as ex:",
            "            pass",
            "        result = d.result_value",
            "        return result",
            "    except Exception as ex:",
            "        ASCIIColors.error(ex)",
            "        return show_console_custom_dialog(title, text, options)",
            "    ",
            "def show_yes_no_dialog(title, text):",
            "    try:",
            "        import tkinter as tk",
            "        from tkinter import messagebox",
            "        # Create a new Tkinter root window and hide it",
            "        root = tk.Tk()",
            "        root.withdraw()",
            "    ",
            "        # Make the window appear on top",
            "        root.attributes('-topmost', True)",
            "        ",
            "        # Show the dialog box",
            "        result = messagebox.askyesno(title, text)",
            "    ",
            "        # Destroy the root window",
            "        root.destroy()",
            "    ",
            "        return result",
            "    except:",
            "        return yes_or_no_input(text)",
            "        ",
            "def show_message_dialog(title, text):",
            "    import tkinter as tk",
            "    from tkinter import messagebox",
            "    # Create a new Tkinter root window and hide it",
            "    root = tk.Tk()",
            "    root.withdraw()",
            "",
            "    # Make the window appear on top",
            "    root.attributes('-topmost', True)",
            "    ",
            "    # Show the dialog box",
            "    result = messagebox.askquestion(title, text)",
            "",
            "    # Destroy the root window",
            "    root.destroy()",
            "",
            "    return result",
            "",
            "",
            "def is_linux():",
            "    return sys.platform.startswith(\"linux\")",
            "",
            "",
            "def is_windows():",
            "    return sys.platform.startswith(\"win\")",
            "",
            "",
            "def is_macos():",
            "    return sys.platform.startswith(\"darwin\")",
            "",
            "def run_cmd(cmd, assert_success=False, environment=False, capture_output=False, env=None):",
            "    script_dir = os.getcwd()",
            "    conda_env_path = os.path.join(script_dir, \"installer_files\", \"env\")",
            "    # Use the conda environment",
            "    if environment:",
            "        if is_windows():",
            "            conda_bat_path = os.path.join(script_dir, \"installer_files\", \"conda\", \"condabin\", \"conda.bat\")",
            "            cmd = \"\\\"\" + conda_bat_path + \"\\\" activate \\\"\" + conda_env_path + \"\\\" >nul && \" + cmd",
            "        else:",
            "            conda_sh_path = os.path.join(script_dir, \"installer_files\", \"conda\", \"etc\", \"profile.d\", \"conda.sh\")",
            "            cmd = \". \\\"\" + conda_sh_path + \"\\\" && conda activate \\\"\" + conda_env_path + \"\\\" && \" + cmd",
            "",
            "    # Run shell commands",
            "    result = subprocess.run(cmd, shell=True, capture_output=capture_output, env=env)",
            "",
            "    # Assert the command ran successfully",
            "    if assert_success and result.returncode != 0:",
            "        print(\"Command '\" + cmd + \"' failed with exit status code '\" + str(result.returncode) + \"'.\\n\\nExiting now.\\nTry running the start/update script again.\")",
            "        sys.exit(1)",
            "",
            "    return result",
            "",
            "def file_path_to_url(file_path):",
            "    \"\"\"",
            "    This function takes a file path as an argument and converts it into a URL format. It first removes the initial part of the file path until the \"outputs\" string is reached, then replaces backslashes with forward slashes and quotes each segment with urllib.parse.quote() before joining them with forward slashes to form the final URL.",
            "",
            "    :param file_path: str, the file path in the format of a Windows system",
            "    :return: str, the converted URL format of the given file path",
            "    \"\"\"",
            "",
            "    url = \"/\"+file_path[file_path.index(\"outputs\"):].replace(\"\\\\\",\"/\")",
            "    return \"/\".join([urllib.parse.quote(p, safe=\"\") for p in url.split(\"/\")])",
            "",
            "",
            "def discussion_path_to_url(file_path:str|Path)->str:",
            "    \"\"\"",
            "    This function takes a file path as an argument and converts it into a URL format. It first removes the initial part of the file path until the \"outputs\" string is reached, then replaces backslashes with forward slashes and quotes each segment with urllib.parse.quote() before joining them with forward slashes to form the final URL.",
            "",
            "    :param file_path: str, the file path in the format of a Windows system",
            "    :return: str, the converted URL format of the given file path",
            "    \"\"\"",
            "    file_path = str(file_path)",
            "    url = \"/\"+file_path[file_path.index(\"discussion_databases\"):].replace(\"\\\\\",\"/\").replace(\"discussion_databases\",\"discussions\")",
            "    return \"/\".join([urllib.parse.quote(p, safe=\"\") for p in url.split(\"/\")])",
            "",
            "def personality_path_to_url(file_path:str|Path)->str:",
            "    \"\"\"",
            "    This function takes a file path as an argument and converts it into a URL format. It first removes the initial part of the file path until the \"outputs\" string is reached, then replaces backslashes with forward slashes and quotes each segment with urllib.parse.quote() before joining them with forward slashes to form the final URL.",
            "",
            "    :param file_path: str, the file path in the format of a Windows system",
            "    :return: str, the converted URL format of the given file path",
            "    \"\"\"",
            "    file_path = str(file_path)",
            "    url = \"/\"+file_path[file_path.index(\"personalities_zoo\"):].replace(\"\\\\\",\"/\").replace(\"personalities_zoo\",\"personalities\")",
            "    return \"/\".join([urllib.parse.quote(p, safe=\"\") for p in url.split(\"/\")])",
            "",
            "",
            "def url2host_port(url, default_port =8000):",
            "    if \"http\" in url:",
            "        parts = url.split(\":\")",
            "        host = \":\".join(parts[:2])",
            "        host_no_http = parts[1].replace(\"//\",\"\")",
            "        port = url.split(\":\")[2] if len(parts)==3 else default_port",
            "        return host, host_no_http, port",
            "    else:",
            "        parts = url.split(\":\")",
            "        host = parts[0]",
            "        port = url.split(\":\")[1] if len(parts)==2 else default_port",
            "        return host, host, port",
            "",
            "def is_asyncio_loop_running():",
            "    \"\"\"",
            "    # This function checks if an AsyncIO event loop is currently running. If an event loop is running, it returns True. If not, it returns False.",
            "    :return: bool, indicating whether or not an AsyncIO event loop is currently running",
            "    \"\"\"",
            "    try:",
            "        return asyncio.get_event_loop().is_running()",
            "    except RuntimeError:  # This gets raised if there's no running event loop",
            "        return False",
            "",
            "def run_async(func):",
            "    \"\"\"",
            "    run_async(func) -> None",
            "",
            "    Utility function to run async functions in sync environment. Takes an async function as input and runs it within an async context.",
            "",
            "    Parameters:",
            "    func (function): The async function to run.",
            "",
            "    Returns:",
            "    None: Nothing is returned since the function is meant to perform side effects.",
            "    \"\"\"",
            "    if is_asyncio_loop_running():",
            "        # We're in a running event loop, so we can call the function with asyncio.create_task",
            "        #task = asyncio.run_coroutine_threadsafe(func(), asyncio.get_event_loop())",
            "        #task.result()        ",
            "        loop = asyncio.get_running_loop()",
            "        task = loop.create_task(func())",
            "    else:",
            "        # We're not in a running event loop, so we need to create one and run the function in it",
            "        try:",
            "            asyncio.run(func()) ",
            "        except:",
            "            func()",
            "",
            "",
            "def terminate_thread(thread):",
            "    \"\"\" ",
            "    This function is used to terminate a given thread if it's currently running. If the thread is not alive, an informational message will be displayed and the function will return without raising any error. Otherwise, it sets the thread's exception to `SystemExit` using `ctypes`, which causes the thread to exit. The function collects the garbage after terminating the thread, and raises a `SystemError` if it fails to do so.",
            "    :param thread: thread object to be terminated",
            "    :return: None if the thread was successfully terminated or an error is raised",
            "    :raises SystemError: if the thread could not be terminated ",
            "    \"\"\"    ",
            "    if thread:",
            "        if not thread.is_alive():",
            "            ASCIIColors.yellow(\"Thread not alive\")",
            "            return",
            "",
            "        thread_id = thread.ident",
            "        exc = ctypes.py_object(SystemExit)",
            "        res = ctypes.pythonapi.PyThreadState_SetAsyncExc(thread_id, exc)",
            "        if res > 1:",
            "            ctypes.pythonapi.PyThreadState_SetAsyncExc(thread_id, None)",
            "            del thread",
            "            gc.collect()",
            "            raise SystemError(\"Failed to terminate the thread.\")",
            "        else:",
            "            ASCIIColors.yellow(\"Canceled successfully\")",
            "",
            "def convert_language_name(language_name):",
            "    \"\"\"",
            "    Convert a language name string to its corresponding ISO 639-1 code.",
            "    If the given language name is not supported, returns \"unsupported\".",
            "",
            "    Parameters:",
            "    - language_name (str): A lowercase and dot-free string representing the name of a language.",
            "",
            "    Returns:",
            "    - str: The corresponding ISO 639-1 code for the given language name or \"unsupported\" if it's not supported.",
            "    \"\"\"    ",
            "    # Remove leading and trailing spaces",
            "    language_name = language_name.strip()",
            "    ",
            "    # Convert to lowercase",
            "    language_name = language_name.lower().replace(\".\",\"\")",
            "    ",
            "    # Define a dictionary mapping language names to their codes",
            "    language_codes = { ",
            "                      \"english\": \"en\", \"spanish\": \"es\", \"french\": \"fr\", \"german\": \"de\",",
            "                      \"italian\": \"it\", \"portuguese\": \"pt\", \"russian\": \"ru\", \"mandarin\": \"zh-CN\",",
            "                      \"korean\": \"ko\", \"japanese\": \"ja\", \"dutch\": \"nl\", \"polish\": \"pl\",",
            "                      \"hindi\": \"hi\", \"arabic\": \"ar\", \"bengali\": \"bn\", \"swedish\": \"sv\", \"thai\": \"th\", \"vietnamese\": \"vi\"",
            "                    }",
            "    ",
            "    # Return the corresponding language code if found, or None otherwise",
            "    return language_codes.get(language_name,\"en\")",
            "",
            "",
            "# Function to encode the image",
            "def encode_image(image_path, max_image_width=-1):",
            "    image = Image.open(image_path)",
            "    width, height = image.size",
            "",
            "    # Check and convert image format if needed",
            "    if image.format not in ['PNG', 'JPEG', 'GIF', 'WEBP']:",
            "        image = image.convert('JPEG')",
            "",
            "",
            "    if max_image_width != -1 and width > max_image_width:",
            "        ratio = max_image_width / width",
            "        new_width = max_image_width",
            "        new_height = int(height * ratio)",
            "        f = image.format",
            "        image = image.resize((new_width, new_height))",
            "        image.format = f",
            "",
            "",
            "    # Save the image to a BytesIO object",
            "    byte_arr = io.BytesIO()",
            "    image.save(byte_arr, format=image.format)",
            "    byte_arr = byte_arr.getvalue()",
            "",
            "    return base64.b64encode(byte_arr).decode('utf-8')",
            "",
            "def load_config(file_path):",
            "    with open(file_path, 'r', encoding='utf-8') as stream:",
            "        config = yaml.safe_load(stream)",
            "",
            "    return config",
            "",
            "",
            "def save_config(config, filepath):",
            "    with open(filepath, \"w\") as f:",
            "        yaml.dump(config, f)",
            "",
            "",
            "def load_image(image_file):",
            "    s_image_file = str(image_file)",
            "    if s_image_file.startswith('http://') or s_image_file.startswith('https://'):",
            "        response = requests.get(s_image_file)",
            "        image = Image.open(BytesIO(response.content)).convert('RGB')",
            "    else:",
            "        image = Image.open(s_image_file).convert('RGB')",
            "    return image",
            "",
            "def load_image_from_base64(image):",
            "    return Image.open(BytesIO(base64.b64decode(image)))",
            "",
            "",
            "def expand2square(pil_img, background_color):",
            "    width, height = pil_img.size",
            "    if width == height:",
            "        return pil_img",
            "    elif width > height:",
            "        result = Image.new(pil_img.mode, (width, width), background_color)",
            "        result.paste(pil_img, (0, (width - height) // 2))",
            "        return result",
            "    else:",
            "        result = Image.new(pil_img.mode, (height, height), background_color)",
            "        result.paste(pil_img, ((height - width) // 2, 0))",
            "        return result",
            "",
            "",
            "def add_period(text):",
            "    \"\"\"",
            "    Adds a period at the end of each line in the given text, except for empty lines.",
            "",
            "    Args:",
            "        text (str): The input text.",
            "",
            "    Returns:",
            "        str: The preprocessed text with a period added at the end of each line that doesn't already have one.",
            "    \"\"\"",
            "    lines = text.split('\\n')",
            "    processed_lines = []",
            "    ",
            "    for line in lines:",
            "        if line.strip():  # Check if line is not empty",
            "            if line[-1] != '.':",
            "                line += '.'",
            "        processed_lines.append(line)",
            "    ",
            "    processed_text = '\\n'.join(processed_lines)",
            "    return processed_text",
            "",
            "def find_next_available_filename(folder_path, prefix):",
            "    folder = Path(folder_path)",
            "",
            "    if not folder.exists():",
            "        raise FileNotFoundError(f\"The folder '{folder}' does not exist.\")",
            "",
            "    index = 1",
            "    while True:",
            "        next_filename = f\"{prefix}_{index}.png\"",
            "        potential_file = folder / next_filename",
            "        if not potential_file.exists():",
            "            return potential_file",
            "        index += 1",
            "",
            "",
            "def find_first_available_file_index(folder_path, prefix, extension=\"\"):",
            "    \"\"\"",
            "    Finds the first available file index in a folder with files that have a prefix and an optional extension.",
            "    ",
            "    Args:",
            "        folder_path (str): The path to the folder.",
            "        prefix (str): The file prefix.",
            "        extension (str, optional): The file extension (including the dot). Defaults to \"\".",
            "    ",
            "    Returns:",
            "        int: The first available file index.",
            "    \"\"\"",
            "    # Create a Path object for the folder",
            "    folder = Path(folder_path)",
            "    ",
            "    # Get a list of all files in the folder",
            "    files = folder.glob(f'{prefix}*'+extension)",
            "    ",
            "    # Initialize the first available number",
            "    available_number = 1",
            "    ",
            "    # Iterate through the files",
            "    while True:",
            "        f = folder/f\"{prefix}{available_number}{extension}\"",
            "        if f.exists():",
            "            available_number += 1",
            "        # If the file number is greater than the available number, break the loop",
            "        else:",
            "            return available_number",
            "",
            "",
            "",
            "",
            "# Prompting tools",
            "def detect_antiprompt(text:str, anti_prompts=[\"!@>\"]) -> bool:",
            "    \"\"\"",
            "    Detects if any of the antiprompts in self.anti_prompts are present in the given text.",
            "    Used for the Hallucination suppression system",
            "",
            "    Args:",
            "        text (str): The text to check for antiprompts.",
            "",
            "    Returns:",
            "        bool: True if any antiprompt is found in the text (ignoring case), False otherwise.",
            "    \"\"\"",
            "    for prompt in anti_prompts:",
            "        if prompt.lower() in text.lower():",
            "            return prompt.lower()",
            "    return None",
            "",
            "",
            "def remove_text_from_string(string, text_to_find):",
            "    \"\"\"",
            "    Removes everything from the first occurrence of the specified text in the string (case-insensitive).",
            "",
            "    Parameters:",
            "    string (str): The original string.",
            "    text_to_find (str): The text to find in the string.",
            "",
            "    Returns:",
            "    str: The updated string.",
            "    \"\"\"",
            "    index = string.lower().find(text_to_find.lower())",
            "",
            "    if index != -1:",
            "        string = string[:index]",
            "",
            "    return string",
            "",
            "",
            "# Pytorch and cuda tools",
            "def check_torch_version(min_version, min_cuda_versio=12):",
            "    import torch",
            "",
            "    if \"+\" in torch.__version__ and int(torch.__version__.split(\"+\")[-1][2:4])<min_cuda_versio:",
            "        return False",
            "",
            "    # Extract torch version from __version__ attribute with regular expression",
            "    current_version_float = float('.'.join(torch.__version__.split(\".\")[:2]))",
            "    # Check if the current version meets or exceeds the minimum required version",
            "    return current_version_float >= min_version",
            "",
            "def install_ninja():",
            "    import conda.cli",
            "    try:",
            "        ASCIIColors.info(\"Installing ninja\") # -c nvidia/label/cuda-12.3.2 -c nvidia -c conda-forge",
            "        result = conda.cli.main(\"install\", \"-c\", \"nvidia/label/cuda-12.3.2\", \"-c\", \"nvidia\", \"-c\", \"conda-forge\", \"ninja\", \"-y\",\"--force-reinstall\")",
            "    except Exception as ex:",
            "        ASCIIColors.error(ex)",
            "",
            "def install_cuda():",
            "    import conda.cli",
            "    try:",
            "        ASCIIColors.info(\"Installing cuda 12.3.2\") # -c nvidia/label/cuda-12.3.2 -c nvidia -c conda-forge",
            "        result = conda.cli.main(\"install\", \"-c\", \"nvidia/label/cuda-12.3.2\", \"-c\", \"nvidia\", \"-c\", \"conda-forge\", \"cuda-toolkit\",\"-y\",\"--force-reinstall\")",
            "    except Exception as ex:",
            "        ASCIIColors.error(ex)",
            "    try:",
            "        ASCIIColors.info(\"Installing cuda compiler\") # -c nvidia/label/cuda-12.3.2 -c nvidia -c conda-forge",
            "        result = conda.cli.main(\"install\", \"-c\", \"nvidia/label/cuda-12.3.2\", \"-c\", \"nvidia\", \"-c\", \"conda-forge\", \"cuda-compiler\", \"-y\",\"--force-reinstall\")",
            "    except Exception as ex:",
            "        ASCIIColors.error(ex)",
            "        ",
            "def install_cmake():",
            "    import conda.cli",
            "    try:",
            "        ASCIIColors.info(\"Installing cmake\") # -c nvidia/label/cuda-12.3.2 -c nvidia -c conda-forge",
            "        result = conda.cli.main(\"install\", \"-c\", \"nvidia/label/cuda-12.3.2\", \"-c\", \"nvidia\", \"-c\", \"conda-forge\", \"cmake\",\"-y\",\"--force-reinstall\")",
            "    except Exception as ex:",
            "        ASCIIColors.error(ex)",
            "",
            "def reinstall_pytorch_with_cuda():",
            "    try:",
            "        import conda.cli",
            "        ASCIIColors.info(\"Installing cuda 12.3.2\") # -c nvidia/label/cuda-12.3.2 -c nvidia -c conda-forge",
            "        result = conda.cli.main(\"install\", \"-c\", \"nvidia/label/cuda-12.3.2\", \"-c\", \"nvidia\", \"-c\", \"conda-forge\", \"cuda-toolkit\",\"-y\",\"--force-reinstall\")",
            "    except Exception as ex:",
            "        ASCIIColors.error(ex)",
            "    try:",
            "        ASCIIColors.info(\"Installing ninja\") # -c nvidia/label/cuda-12.3.2 -c nvidia -c conda-forge",
            "        result = conda.cli.main(\"install\", \"-c\", \"nvidia/label/cuda-12.3.2\", \"-c\", \"nvidia\", \"-c\", \"conda-forge\", \"ninja\", \"-y\",\"--force-reinstall\")",
            "    except Exception as ex:",
            "        ASCIIColors.error(ex)",
            "    try:",
            "        ASCIIColors.info(\"Installing cuda compiler\") # -c nvidia/label/cuda-12.3.2 -c nvidia -c conda-forge",
            "        result = conda.cli.main(\"install\", \"-c\", \"nvidia/label/cuda-12.3.2\", \"-c\", \"nvidia\", \"-c\", \"conda-forge\", \"cuda-compiler\", \"-y\",\"--force-reinstall\")",
            "    except Exception as ex:",
            "        ASCIIColors.error(ex)",
            "    try:",
            "        ASCIIColors.info(\"Installing pytorch 2.2.1\")",
            "        result = subprocess.run([sys.executable, \"-m\", \"pip\", \"install\", \"--upgrade\", \"torch\", \"torchvision\", \"torchaudio\", \"--no-cache-dir\", \"--index-url\", \"https://download.pytorch.org/whl/cu121\"])",
            "    except Exception as ex:",
            "        ASCIIColors.error(ex)",
            "    if result.returncode != 0:",
            "        ASCIIColors.warning(\"Couldn't find Cuda build tools on your PC. Reverting to CPU.\")",
            "        result = subprocess.run([sys.executable, \"-m\", \"pip\", \"install\", \"--upgrade\", \"torch\", \"torchvision\", \"torchaudio\", \"--no-cache-dir\"])",
            "        if result.returncode != 0:",
            "            ASCIIColors.error(\"Couldn't install pytorch !!\")",
            "        else:",
            "            ASCIIColors.error(\"Pytorch installed successfully!!\")",
            "",
            "",
            "def reinstall_pytorch_with_rocm():",
            "    result = subprocess.run([sys.executable, \"-m\", \"pip\", \"install\", \"--upgrade\", \"torch\", \"torchvision\", \"torchaudio\", \"--no-cache-dir\", \"--index-url\", \"https://download.pytorch.org/whl/rocm5.6\"])",
            "    if result.returncode != 0:",
            "        ASCIIColors.warning(\"Couldn't find Cuda build tools on your PC. Reverting to CPU.\")",
            "        result = subprocess.run([sys.executable, \"-m\", \"pip\", \"install\", \"--upgrade\", \"torch\", \"torchvision\", \"torchaudio\", \"--no-cache-dir\"])",
            "        if result.returncode != 0:",
            "            ASCIIColors.error(\"Couldn't install pytorch !!\")",
            "        else:",
            "            ASCIIColors.error(\"Pytorch installed successfully!!\")",
            "            ",
            "            ",
            "",
            "def reinstall_pytorch_with_cpu():",
            "    result = subprocess.run([sys.executable, \"-m\", \"pip\", \"install\", \"--upgrade\", \"torch\", \"torchvision\", \"torchaudio\", \"--no-cache-dir\"])",
            "    if result.returncode != 0:",
            "        ASCIIColors.warning(\"Couldn't find Cuda build tools on your PC. Reverting to CPU.\")",
            "        result = subprocess.run([sys.executable, \"-m\", \"pip\", \"install\", \"--upgrade\", \"torch\", \"torchvision\", \"torchaudio\", \"--no-cache-dir\"])",
            "        if result.returncode != 0:",
            "            ASCIIColors.error(\"Couldn't install pytorch !!\")",
            "        else:",
            "            ASCIIColors.error(\"Pytorch installed successfully!!\")     ",
            "",
            "",
            "def check_and_install_torch(enable_gpu:bool, version:float=2.2):",
            "    if enable_gpu:",
            "        ASCIIColors.yellow(\"This installation has enabled GPU support. Trying to install with GPU support\")",
            "        ASCIIColors.info(\"Checking pytorch\")",
            "        try:",
            "            import torch",
            "            import torchvision",
            "            if torch.cuda.is_available():",
            "                ASCIIColors.success(f\"CUDA is supported.\\nCurrent version is {torch.__version__}.\")",
            "                if not check_torch_version(version):",
            "                    ASCIIColors.yellow(\"Torch version is old. Installing new version\")",
            "                    reinstall_pytorch_with_cuda()",
            "                else:",
            "                    ASCIIColors.yellow(\"Torch OK\")",
            "            else:",
            "                ASCIIColors.warning(\"CUDA is not supported. Trying to reinstall PyTorch with CUDA support.\")",
            "                reinstall_pytorch_with_cuda()",
            "        except Exception as ex:",
            "            ASCIIColors.info(\"Pytorch not installed. Reinstalling ...\")",
            "            reinstall_pytorch_with_cuda()    ",
            "    else:",
            "        try:",
            "            import torch",
            "            import torchvision",
            "            if check_torch_version(version):",
            "                ASCIIColors.warning(\"Torch version is too old. Trying to reinstall PyTorch with CUDA support.\")",
            "                reinstall_pytorch_with_cpu()",
            "        except Exception as ex:",
            "            ASCIIColors.info(\"Pytorch not installed. Reinstalling ...\")",
            "            reinstall_pytorch_with_cpu() ",
            "    ",
            "",
            "class NumpyEncoderDecoder(json.JSONEncoder):",
            "    def default(self, obj):",
            "        if isinstance(obj, np.ndarray):",
            "            return {'__numpy_array__': True, 'data': obj.tolist()}",
            "        return super(NumpyEncoderDecoder, self).default(obj)",
            "",
            "    @staticmethod",
            "    def as_numpy_array(dct):",
            "        if '__numpy_array__' in dct:",
            "            return np.array(dct['data'])",
            "        return dct",
            "    ",
            "",
            "def clone_repository(repository_url, local_folder:Path|str, exist_ok=False):",
            "    if Path(local_folder).exists():",
            "        if exist_ok:",
            "            shutil.rmtree(str(local_folder))",
            "        else:",
            "            ASCIIColors.success(\"Repository already exists!\")",
            "            return False",
            "",
            "    try:",
            "        # Create a new repository object",
            "        repo = git.Repo.clone_from(repository_url, str(local_folder))",
            "        ASCIIColors.success(\"Repository was cloned successfully\")",
            "        return True",
            "    except:",
            "        ASCIIColors.error(\"Repository cloning failed\")",
            "        return False",
            "    ",
            "def git_pull(folder_path):",
            "    try:",
            "        # Change the current working directory to the desired folder",
            "        subprocess.run([\"git\", \"checkout\", folder_path], check=True, cwd=folder_path)",
            "        # Run 'git pull' in the specified folder",
            "        subprocess.run([\"git\", \"pull\"], check=True, cwd=folder_path)",
            "        print(\"Git pull successful in\", folder_path)",
            "    except subprocess.CalledProcessError as e:",
            "        print(\"Error occurred while executing Git pull:\", e)",
            "        # Handle any specific error handling here if required",
            "class AdvancedGarbageCollector:",
            "    @staticmethod",
            "    def hardCollect(obj):",
            "        \"\"\"",
            "        Remove a reference to the specified object and attempt to collect it.",
            "",
            "        Parameters:",
            "        - obj: The object to be collected.",
            "",
            "        This method first identifies all the referrers (objects referencing the 'obj')",
            "        using Python's garbage collector (gc.get_referrers). It then iterates through",
            "        the referrers and attempts to break their reference to 'obj' by setting them",
            "        to None. Finally, it deletes the 'obj' reference.",
            "",
            "        Note: This method is designed to handle circular references and can be used",
            "        to forcefully collect objects that might not be collected automatically.",
            "",
            "        \"\"\"",
            "        if obj is None:",
            "            return",
            "        all_referrers = gc.get_referrers(obj)",
            "        for referrer in all_referrers:",
            "            try:",
            "                if isinstance(referrer, (list, tuple, dict, set)):",
            "                    if isinstance(referrer, list):",
            "                        if obj in referrer:",
            "                            referrer.remove(obj)",
            "                    elif isinstance(referrer, dict):",
            "                        new_dict = {}",
            "                        for key, value in referrer.items():",
            "                            if value != obj:",
            "                                new_dict[key] = value",
            "                        referrer.clear()",
            "                        referrer.update(new_dict)",
            "                    elif isinstance(referrer, set):",
            "                        if obj in referrer:",
            "                            referrer.remove(obj)",
            "            except:",
            "                ASCIIColors.warning(\"Couldn't remove object from referrer\")",
            "        del obj",
            "",
            "    @staticmethod",
            "    def safeHardCollect(variable_name, instance=None):",
            "        \"\"\"",
            "        Safely remove a reference to a variable and attempt to collect its object.",
            "",
            "        Parameters:",
            "        - variable_name: The name of the variable to be collected.",
            "        - instance: An optional instance (object) to search for the variable if it",
            "          belongs to an object.",
            "",
            "        This method provides a way to safely break references to a variable by name.",
            "        It first checks if the variable exists either in the local or global namespace",
            "        or within the provided instance. If found, it calls the 'hardCollect' method",
            "        to remove the reference and attempt to collect the associated object.",
            "",
            "        \"\"\"",
            "        if instance is not None:",
            "            if hasattr(instance, variable_name):",
            "                obj = getattr(instance, variable_name)",
            "                AdvancedGarbageCollector.hardCollect(obj)",
            "            else:",
            "                print(f\"The variable '{variable_name}' does not exist in the instance.\")",
            "        else:",
            "            if variable_name in locals():",
            "                obj = locals()[variable_name]",
            "                AdvancedGarbageCollector.hardCollect(obj)",
            "            elif variable_name in globals():",
            "                obj = globals()[variable_name]",
            "                AdvancedGarbageCollector.hardCollect(obj)",
            "            else:",
            "                print(f\"The variable '{variable_name}' does not exist in the local or global namespace.\")",
            "",
            "    @staticmethod",
            "    def safeHardCollectMultiple(variable_names, instance=None):",
            "        \"\"\"",
            "        Safely remove references to multiple variables and attempt to collect their objects.",
            "",
            "        Parameters:",
            "        - variable_names: A list of variable names to be collected.",
            "        - instance: An optional instance (object) to search for the variables if they",
            "          belong to an object.",
            "",
            "        This method iterates through a list of variable names and calls 'safeHardCollect'",
            "        for each variable, effectively removing references and attempting to collect",
            "        their associated objects.",
            "",
            "        \"\"\"",
            "        for variable_name in variable_names:",
            "            AdvancedGarbageCollector.safeHardCollect(variable_name, instance)",
            "",
            "    @staticmethod",
            "    def collect():",
            "        \"\"\"",
            "        Perform a manual garbage collection using Python's built-in 'gc.collect' method.",
            "",
            "        This method triggers a manual garbage collection, attempting to clean up",
            "        any unreferenced objects in memory. It can be used to free up memory and",
            "        resources that are no longer in use.",
            "",
            "        \"\"\"",
            "        gc.collect()",
            "",
            "",
            "class PackageManager:",
            "    @staticmethod",
            "    def install_package(package_name):",
            "        import subprocess",
            "        import sys",
            "        subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"--upgrade\", package_name])",
            "        ",
            "    @staticmethod",
            "    def check_package_installed(package_name):",
            "        try:",
            "            importlib.import_module(package_name)",
            "            return True",
            "        except ImportError:",
            "            return False",
            "        except Exception as ex:",
            "            trace_exception(ex)",
            "            ASCIIColors.error(\"Something is wrong with your library.\\nIt looks installed, but I am not able to call it.\\nTry to reinstall it.\")",
            "            return False",
            "        ",
            "    @staticmethod",
            "    def safe_import(module_name, library_name=None):",
            "        if not PackageManager.check_package_installed(module_name):",
            "            print(f\"{module_name} module not found. Installing...\")",
            "            if library_name:",
            "                PackageManager.install_package(library_name)",
            "            else:",
            "                PackageManager.install_package(module_name)",
            "        globals()[module_name] = importlib.import_module(module_name)",
            "        print(f\"{module_name} module imported successfully.\")",
            "",
            "",
            "class GitManager:",
            "    @staticmethod",
            "    def git_pull(folder_path):",
            "        try:",
            "            # Change the current working directory to the desired folder",
            "            subprocess.run([\"git\", \"checkout\", folder_path], check=True, cwd=folder_path)",
            "            # Run 'git pull' in the specified folder",
            "            subprocess.run([\"git\", \"pull\"], check=True, cwd=folder_path)",
            "            print(\"Git pull successful in\", folder_path)",
            "        except subprocess.CalledProcessError as e:",
            "            print(\"Error occurred while executing Git pull:\", e)",
            "            # Handle any specific error handling here if required",
            "",
            "class File64BitsManager:",
            "",
            "    @staticmethod",
            "    def raw_b64_img(image) -> str:",
            "        try:",
            "            from PIL import Image, PngImagePlugin",
            "            import io",
            "            import base64",
            "        except:",
            "            PackageManager.install_package(\"Pillow\")",
            "            from PIL import Image",
            "            import io",
            "            import base64",
            "",
            "        # XXX controlnet only accepts RAW base64 without headers",
            "        with io.BytesIO() as output_bytes:",
            "            metadata = None",
            "            for key, value in image.info.items():",
            "                if isinstance(key, str) and isinstance(value, str):",
            "                    if metadata is None:",
            "                        metadata = PngImagePlugin.PngInfo()",
            "                    metadata.add_text(key, value)",
            "            image.save(output_bytes, format=\"PNG\", pnginfo=metadata)",
            "",
            "            bytes_data = output_bytes.getvalue()",
            "",
            "        return str(base64.b64encode(bytes_data), \"utf-8\")",
            "",
            "",
            "    @staticmethod",
            "    def img2b64(image) -> str:",
            "        return \"data:image/png;base64,\" + File64BitsManager.raw_b64_img(image)    ",
            "",
            "    @staticmethod",
            "    def b642img(b64img) -> str:",
            "        try:",
            "            from PIL import Image, PngImagePlugin",
            "            import io",
            "            import base64",
            "        except:",
            "            PackageManager.install_package(\"Pillow\")",
            "            from PIL import Image",
            "            import io",
            "            import base64        ",
            "        image_data = re.sub('^data:image/.+;base64,', '', b64img)",
            "        return Image.open(io.BytesIO(base64.b64decode(image_data)))  ",
            "",
            "    @staticmethod",
            "    def get_supported_file_extensions_from_base64(b64data):",
            "        # Extract the file extension from the base64 data",
            "        data_match = re.match(r'^data:(.*?);base64,', b64data)",
            "        if data_match:",
            "            mime_type = data_match.group(1)",
            "            extension = mime_type.split('/')[-1]",
            "            return extension",
            "        else:",
            "            raise ValueError(\"Invalid base64 data format.\")",
            "        ",
            "    @staticmethod",
            "    def extract_content_from_base64(b64data):",
            "        # Split the base64 data at the comma separator",
            "        header, content = b64data.split(',', 1)",
            "",
            "        # Extract only the content part and remove any white spaces and newlines",
            "        content = content.strip()",
            "",
            "        return content",
            "",
            "    @staticmethod",
            "    def b642file(b64data, filename):",
            "        import base64   ",
            "        # Extract the file extension from the base64 data",
            "        ",
            "        ",
            "        # Save the file with the determined extension",
            "        with open(filename, 'wb') as file:",
            "            file.write(base64.b64decode(File64BitsManager.extract_content_from_base64(b64data)))",
            "",
            "        return filename",
            "    ",
            "class PromptReshaper:",
            "    def __init__(self, template:str):",
            "        self.template = template",
            "    def replace(self, placeholders:dict)->str:",
            "        template = self.template",
            "        # Calculate the number of tokens for each placeholder",
            "        for placeholder, text in placeholders.items():",
            "            template = template.replace(placeholder, text)",
            "        return template",
            "    def build(self, placeholders:dict, tokenize, detokenize, max_nb_tokens:int, place_holders_to_sacrifice:list=[])->str:",
            "        # Tokenize the template without placeholders",
            "        template_text = self.template",
            "        template_tokens = tokenize(template_text)",
            "        ",
            "        # Calculate the number of tokens in the template without placeholders",
            "        template_tokens_count = len(template_tokens)",
            "        ",
            "        # Calculate the number of tokens for each placeholder",
            "        placeholder_tokens_count = {}",
            "        all_count = template_tokens_count",
            "        for placeholder, text in placeholders.items():",
            "            text_tokens = tokenize(text)",
            "            placeholder_tokens_count[placeholder] = len(text_tokens)",
            "            all_count += placeholder_tokens_count[placeholder]",
            "",
            "        def fill_template(template, data):",
            "            for key, value in data.items():",
            "                placeholder = \"{{\" + key + \"}}\"",
            "                n_text_tokens = len(tokenize(template))",
            "                if key in place_holders_to_sacrifice:",
            "                    n_remaining = max_nb_tokens - n_text_tokens",
            "                    t_value = tokenize(value)",
            "                    n_value = len(t_value)",
            "                    if n_value<n_remaining:",
            "                        template = template.replace(placeholder, value)",
            "                    else:",
            "                        value = detokenize(t_value[-n_remaining:])",
            "                        template = template.replace(placeholder, value)",
            "                        ",
            "                else:",
            "                    template = template.replace(placeholder, value)",
            "            return template",
            "        ",
            "        return fill_template(self.template, placeholders)",
            "",
            "",
            "",
            "class LOLLMSLocalizer:",
            "    def __init__(self, dictionary):",
            "        self.dictionary = dictionary",
            "",
            "    def localize(self, input_string):",
            "        def replace(match):",
            "            key = match.group(1)",
            "            return self.dictionary.get(key, match.group(0))",
            "        ",
            "        import re",
            "        pattern = r'@<([^>]+)>@'",
            "        localized_string = re.sub(pattern, replace, input_string)",
            "        return localized_string",
            "",
            "",
            "class File_Path_Generator:",
            "    @staticmethod",
            "    def generate_unique_file_path(folder_path, file_base_name, file_extension):",
            "        folder_path = Path(folder_path)",
            "        index = 0",
            "        while True:",
            "            # Construct the full file path with the current index",
            "            file_name = f\"{file_base_name}_{index}.{file_extension}\"",
            "            full_file_path = folder_path / file_name",
            "            ",
            "            # Check if the file already exists in the folder",
            "            if not full_file_path.exists():",
            "                return full_file_path",
            "            ",
            "            # If the file exists, increment the index and try again",
            "            index += 1",
            "",
            "",
            "def remove_text_from_string(string: str, text_to_find:str):",
            "    \"\"\"",
            "    Removes everything from the first occurrence of the specified text in the string (case-insensitive).",
            "",
            "    Parameters:",
            "    string (str): The original string.",
            "    text_to_find (str): The text to find in the string.",
            "",
            "    Returns:",
            "    str: The updated string.",
            "    \"\"\"",
            "    index = string.lower().find(text_to_find.lower())",
            "",
            "    if index != -1:",
            "        string = string[:index]",
            "",
            "    return string"
        ],
        "action": [
            "0",
            "0",
            "0",
            "1",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0",
            "0",
            "0",
            "0",
            "2",
            "0",
            "0",
            "0"
        ],
        "dele_reviseLocation": {
            "40": []
        },
        "addLocation": []
    }
}